/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 90);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.throttle = throttle;
exports.wrapNum = wrapNum;
exports.falseFn = falseFn;
exports.formatNum = formatNum;
exports.trim = trim;
exports.splitWords = splitWords;
exports.setOptions = setOptions;
exports.getParamString = getParamString;
exports.template = template;
exports.indexOf = indexOf;
exports.requestAnimFrame = requestAnimFrame;
exports.cancelAnimFrame = cancelAnimFrame;
/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = exports.freeze = Object.freeze;
Object.freeze = function (obj) {
	return obj;
};

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = exports.create = Object.create || function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
}();

// @function bind(fn: Function, …): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = exports.lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assiging it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || (exports.lastId = lastId += 1);
	return obj._leaflet_id;
	/*eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function later() {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function wrapperFn() {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;
		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
	    min = range[0],
	    d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() {
	return false;
}

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, digits || 5);
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_\-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values — they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);
		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = exports.isArray = Array.isArray || function (obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) {
			return i;
		}
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = exports.emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
	    timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = exports.requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = exports.cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
	window.clearTimeout(id);
};

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.enableTextSelection = exports.disableTextSelection = exports.TRANSITION_END = exports.TRANSITION = exports.TRANSFORM = undefined;
exports.get = get;
exports.getStyle = getStyle;
exports.create = create;
exports.remove = remove;
exports.empty = empty;
exports.toFront = toFront;
exports.toBack = toBack;
exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.setClass = setClass;
exports.getClass = getClass;
exports.setOpacity = setOpacity;
exports.testProp = testProp;
exports.setTransform = setTransform;
exports.setPosition = setPosition;
exports.getPosition = getPosition;
exports.disableImageDrag = disableImageDrag;
exports.enableImageDrag = enableImageDrag;
exports.preventOutline = preventOutline;
exports.restoreOutline = restoreOutline;

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Point = __webpack_require__(3);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = exports.TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = exports.TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END = exports.TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';

// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || el.currentStyle && el.currentStyle[style];

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = Util.splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, Util.trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
	    filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) {
			return;
		}
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = value !== 100;
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new _Point.Point(0, 0);

	el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/*eslint-enable */

	if (Browser.any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new _Point.Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection = exports.disableTextSelection = undefined;
var enableTextSelection = exports.enableTextSelection = undefined;
var _userSelect;
if ('onselectstart' in document) {
	exports.disableTextSelection = disableTextSelection = function disableTextSelection() {
		DomEvent.on(window, 'selectstart', DomEvent.preventDefault);
	};
	exports.enableTextSelection = enableTextSelection = function enableTextSelection() {
		DomEvent.off(window, 'selectstart', DomEvent.preventDefault);
	};
} else {
	var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	exports.disableTextSelection = disableTextSelection = function disableTextSelection() {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	exports.enableTextSelection = enableTextSelection = function enableTextSelection() {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	DomEvent.on(window, 'dragstart', DomEvent.preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	DomEvent.off(window, 'dragstart', DomEvent.preventDefault);
}

var _outlineElement, _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) {
		return;
	}
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	DomEvent.on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) {
		return;
	}
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	DomEvent.off(window, 'keydown', restoreOutline);
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.JSCompiler_renameProperty = function (prop, obj) {
  return prop;
};

/** @namespace */
var Polymer = void 0;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.Point = Point;
exports.toPoint = toPoint;

var _Util = __webpack_require__(0);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = round ? Math.round(x) : x;
	// @property y: Number; The `y` coordinate of the point
	this.y = round ? Math.round(y) : y;
}

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function clone() {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function add(point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function _add(point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function subtract(point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function _subtract(point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function divideBy(num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function _divideBy(num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function multiplyBy(num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function _multiplyBy(num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function scaleBy(point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function unscaleBy(point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function round() {
		return this.clone()._round();
	},

	_round: function _round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function floor() {
		return this.clone()._floor();
	},

	_floor: function _floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function ceil() {
		return this.clone()._ceil();
	},

	_ceil: function _ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function distanceTo(point) {
		point = toPoint(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function equals(point) {
		point = toPoint(point);

		return point.x === this.x && point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function contains(point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function toString() {
		return 'Point(' + (0, _Util.formatNum)(this.x) + ', ' + (0, _Util.formatNum)(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if ((0, _Util.isArray)(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vml = exports.svg = exports.canvas = exports.retina = exports.mobileGecko = exports.mobileOpera = exports.touch = exports.pointer = exports.msPointer = exports.mobileWebkit3d = exports.mobileWebkit = exports.mobile = exports.any3d = exports.gecko3d = exports.webkit3d = exports.ie3d = exports.win = exports.opera12 = exports.phantom = exports.safari = exports.gecko = exports.chrome = exports.opera = exports.android23 = exports.android = exports.webkit = exports.edge = exports.ielt9 = exports.ie = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _SVG = __webpack_require__(75);

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = exports.ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = exports.ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = exports.edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = exports.webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = exports.android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = exports.android23 = userAgentContains('android 2') || userAgentContains('android 3');

// @property opera: Boolean; `true` for the Opera browser
var opera = exports.opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = exports.chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = exports.gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = exports.safari = !chrome && userAgentContains('safari');

var phantom = exports.phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = exports.opera12 = 'OTransition' in style;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = exports.win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = exports.ie3d = ie && 'transition' in style;

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = exports.webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = exports.gecko3d = 'MozPerspective' in style;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = exports.any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = exports.mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = exports.mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = exports.mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = exports.msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = exports.pointer = !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = exports.touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = exports.mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = exports.mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen.
var retina = exports.retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;

// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = exports.canvas = function () {
  return !!document.createElement('canvas').getContext;
}();

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = exports.svg = !!(document.createElementNS && (0, _SVG.svgCreate)('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = exports.vml = !svg && function () {
  try {
    var div = document.createElement('div');
    div.innerHTML = '<v:shape adj="1"/>';

    var shape = div.firstChild;
    shape.style.behavior = 'url(#default#VML)';

    return shape && _typeof(shape.adj) === 'object';
  } catch (e) {
    return false;
  }
}();

function userAgentContains(str) {
  return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.removeListener = exports.addListener = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.on = on;
exports.off = off;
exports.stopPropagation = stopPropagation;
exports.disableScrollPropagation = disableScrollPropagation;
exports.disableClickPropagation = disableClickPropagation;
exports.preventDefault = preventDefault;
exports.stop = stop;
exports.getMousePosition = getMousePosition;
exports.getWheelDelta = getWheelDelta;
exports.fakeStop = fakeStop;
exports.skipped = skipped;
exports.isExternalTarget = isExternalTarget;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(76);

var _DomEvent2 = __webpack_require__(116);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = Util.splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function. If no function is specified,
// it will remove all the listeners of that particular DOM event from the element.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

// @alternative
// @function off(el: HTMLElement): this
// Removes all known event listeners
function off(obj, types, fn, context) {

	if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = Util.splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) {
		return this;
	}

	var handler = function handler(e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (Browser.pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		(0, _DomEvent.addPointerListener)(obj, type, handler, id);
	} else if (Browser.touch && type === 'dblclick' && _DomEvent2.addDoubleTapListener && !(Browser.pointer && Browser.chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		(0, _DomEvent2.addDoubleTapListener)(obj, handler, id);
	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
		} else if (type === 'mouseenter' || type === 'mouseleave') {
			handler = function handler(e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);
		} else {
			if (type === 'click' && Browser.android) {
				handler = function handler(e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}
	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : ''),
	    handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) {
		return this;
	}

	if (Browser.pointer && type.indexOf('touch') === 0) {
		(0, _DomEvent.removePointerListener)(obj, type, id);
	} else if (Browser.touch && type === 'dblclick' && _DomEvent2.removeDoubleTapListener) {
		(0, _DomEvent2.removeDoubleTapListener)(obj, id);
	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
		} else {
			obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}
	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {
		// In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new _Point.Point(e.clientX, e.clientY);
	}

	var rect = container.getBoundingClientRect();

	return new _Point.Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor = Browser.win && Browser.chrome ? 2 * window.devicePixelRatio : Browser.gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return Browser.edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
	e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
	e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
	e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
	e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
	e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
	e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
	e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
	0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) {
		return true;
	}

	try {
		while (related && related !== el) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return related !== el;
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,
	    elapsed = lastClick && timeStamp - lastClick;

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}

// @function addListener(…): this
// Alias to [`L.DomEvent.on`](#domevent-on)
exports.addListener = on;

// @function removeListener(…): this
// Alias to [`L.DomEvent.off`](#domevent-off)

exports.removeListener = off;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Base = undefined;

var _legacyElementMixin = __webpack_require__(60);

__webpack_require__(28);

__webpack_require__(100);

__webpack_require__(101);

__webpack_require__(44);

__webpack_require__(102);

__webpack_require__(103);

__webpack_require__(104);

__webpack_require__(106);

var Base = exports.Base = (0, _legacyElementMixin.LegacyElementMixin)(HTMLElement).prototype;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Map = undefined;
exports.createMap = createMap;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Events = __webpack_require__(19);

var _CRS = __webpack_require__(73);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(8);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _PosAnimation = __webpack_require__(77);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = exports.Map = _Events.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: _CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,

		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function initialize(id, options) {
		// (HTMLElement or String, Object)
		options = Util.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = Util.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView((0, _LatLng.toLatLng)(options.center), options.zoom, { reset: true });
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = DomUtil.TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			DomEvent.on(this._proxy, DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},

	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function setView(center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter((0, _LatLng.toLatLng)(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = Util.extend({ animate: options.animate }, options.zoom);
				options.pan = Util.extend({ animate: options.animate, duration: options.duration }, options.pan);
			}

			// try animating pan or zoom
			var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function setZoom(zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, { zoom: options });
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function zoomIn(delta, options) {
		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function zoomOut(delta, options) {
		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function setZoomAround(latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof _Point.Point ? latlng : this.latLngToContainerPoint(latlng),
		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, { zoom: options });
	},

	_getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : (0, _LatLngBounds.toLatLngBounds)(bounds);

		var paddingTL = (0, _Point.toPoint)(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = (0, _Point.toPoint)(options.paddingBottomRight || options.padding || [0, 0]),
		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function fitBounds(bounds, options) {

		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function fitWorld(options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function panTo(center, options) {
		// (LatLng)
		return this.setView(center, this._zoom, { pan: options });
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function panBy(offset, options) {
		offset = (0, _Point.toPoint)(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new _PosAnimation.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function flyTo(targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = (0, _LatLng.toLatLng)(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = to.distanceTo(from) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			// workaround for floating point precision bug when sq = 0, log = -Infinite,
			// thus triggering an infinite loop in flyTo
			var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) {
			return (Math.exp(n) - Math.exp(-n)) / 2;
		}
		function cosh(n) {
			return (Math.exp(n) + Math.exp(-n)) / 2;
		}
		function tanh(n) {
			return sinh(n) / cosh(n);
		}

		var r0 = r(0);

		function w(s) {
			return w0 * (cosh(r0) / cosh(r0 + rho * s));
		}
		function u(s) {
			return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
		}

		function easeOut(t) {
			return 1 - Math.pow(1 - t, 1.5);
		}

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = Util.requestAnimFrame(frame, this);

				this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), { flyTo: true });
			} else {
				this._move(targetCenter, targetZoom)._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function flyToBounds(bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function setMaxBounds(bounds) {
		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function setMinZoom(zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function setMaxZoom(zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && this.getZoom() > this.options.maxZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function panInsideBounds(bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, (0, _LatLngBounds.toLatLngBounds)(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function invalidateSize(options) {
		if (!this._loaded) {
			return this;
		}

		options = Util.extend({
			animate: false,
			pan: true
		}, options === true ? { animate: true } : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) {
			return this;
		}

		if (options.animate && options.pan) {
			this.panBy(offset);
		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(Util.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function stop() {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function locate(options) {

		options = this._locateOptions = Util.extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = Util.bind(this._handleGeolocationResponse, this),
		    onError = Util.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function stopLocate() {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function _handleGeolocationError(error) {
		var c = error.code,
		    message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function _handleGeolocationResponse(pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new _LatLng.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function addHandler(name, HandlerClass) {
		if (!HandlerClass) {
			return this;
		}

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function remove() {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/*eslint-enable */
			this._containerId = undefined;
		}

		DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			DomUtil.remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function createPane(name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function getCenter() {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function getZoom() {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function getBounds() {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new _LatLngBounds.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function getMinZoom() {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function getMaxZoom() {
		return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {
		// (LatLngBounds[, Boolean, Point]) -> Number
		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);
		padding = (0, _Point.toPoint)(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = (0, _Bounds.toBounds)(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = Browser.any3d ? this.options.zoomSnap : 1,
		    scalex = size.x / boundsSize.x,
		    scaley = size.y / boundsSize.y,
		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function getSize() {
		if (!this._size || this._sizeChanged) {
			this._size = new _Point.Point(this._container.clientWidth || 0, this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function getPixelBounds(center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new _Bounds.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function getPixelOrigin() {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function getPixelWorldBounds(zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function getPane(pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function getPanes() {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function getContainer() {
		return this._container;
	},

	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function getZoomScale(toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function getScaleZoom(scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function project(latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint((0, _LatLng.toLatLng)(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function unproject(point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng((0, _Point.toPoint)(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function layerPointToLatLng(point) {
		var projectedPoint = (0, _Point.toPoint)(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function latLngToLayerPoint(latlng) {
		var projectedPoint = this.project((0, _LatLng.toLatLng)(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function wrapLatLng(latlng) {
		return this.options.crs.wrapLatLng((0, _LatLng.toLatLng)(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function wrapLatLngBounds(latlng) {
		return this.options.crs.wrapLatLngBounds((0, _LatLngBounds.toLatLngBounds)(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function distance(latlng1, latlng2) {
		return this.options.crs.distance((0, _LatLng.toLatLng)(latlng1), (0, _LatLng.toLatLng)(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function containerPointToLayerPoint(point) {
		// (Point)
		return (0, _Point.toPoint)(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function layerPointToContainerPoint(point) {
		// (Point)
		return (0, _Point.toPoint)(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function containerPointToLatLng(point) {
		var layerPoint = this.containerPointToLayerPoint((0, _Point.toPoint)(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function latLngToContainerPoint(latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint((0, _LatLng.toLatLng)(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {
		return DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function mouseEventToLatLng(e) {
		// (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},

	// map initialization methods

	_initContainer: function _initContainer(id) {
		var container = this._container = DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		DomEvent.on(container, 'scroll', this._onScroll, this);
		this._containerId = Util.stamp(container);
	},

	_initLayout: function _initLayout() {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;

		DomUtil.addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function _initPanes() {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		DomUtil.setPosition(this._mapPane, new _Point.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},

	// private methods that modify map state

	// @section Map state change events
	_resetView: function _resetView(center, zoom) {
		DomUtil.setPosition(this._mapPane, new _Point.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this._moveStart(zoomChanged)._move(center, zoom)._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function _moveStart(zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function _move(center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || data && data.pinch) {
			// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function _moveEnd(zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function _stop() {
		Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function _rawPanBy(offset) {
		DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function _getZoomSpan() {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function _panInsideMaxBounds() {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function _checkIfLoaded() {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function _initEvents(remove) {
		this._targets = {};
		this._targets[Util.stamp(this._container)] = this;

		var onOff = remove ? DomEvent.off : DomEvent.on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (Browser.any3d && this.options.transform3DLimit) {
			(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function _onResize() {
		Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = Util.requestAnimFrame(function () {
			this.invalidateSize({ debounceMoveend: true });
		}, this);
	},

	_onScroll: function _onScroll() {
		this._container.scrollTop = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function _onMoveEnd() {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function _findEventTargets(e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[Util.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !DomEvent.isExternalTarget(src, e)) {
					break;
				}
				targets.push(target);
				if (isHover) {
					break;
				}
			}
			if (src === this._container) {
				break;
			}
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && DomEvent.isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function _handleDOMEvent(e) {
		if (!this._loaded || DomEvent.skipped(e)) {
			return;
		}

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress') {
			// prevents outline when clicking on keyboard-focusable element
			DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function _fireDOMEvent(e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) {
			return;
		}

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) {
			return;
		}

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target.options && 'icon' in target.options;
			data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && Util.indexOf(this._mouseEvents, type) !== -1) {
				return;
			}
		}
	},

	_draggableMoved: function _draggableMoved(obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
	},

	_clearHandlers: function _clearHandlers() {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function whenReady(callback, context) {
		if (this._loaded) {
			callback.call(context || this, { target: this });
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	// private methods for getting map state

	_getMapPanePos: function _getMapPanePos() {
		return DomUtil.getPosition(this._mapPane) || new _Point.Point(0, 0);
	},

	_moved: function _moved() {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function _getTopLeftPoint(center, zoom) {
		var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return (0, _Bounds.toBounds)([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function _getCenterLayerPoint() {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function _getCenterOffset(latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function _limitCenter(center, zoom, bounds) {

		if (!bounds) {
			return center;
		}

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new _Bounds.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function _limitOffset(offset, bounds) {
		if (!bounds) {
			return offset;
		}

		var viewBounds = this.getPixelBounds(),
		    newBounds = new _Bounds.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = (0, _Bounds.toBounds)(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new _Point.Point(dx, dy);
	},

	_rebound: function _rebound(left, right) {
		return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function _limitZoom(zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function _onPanTransitionStep() {
		this.fire('move');
	},

	_onPanTransitionEnd: function _onPanTransitionEnd() {
		DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function _tryAnimatedPan(center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
			return false;
		}

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function _createAnimProxy() {

		var proxy = this._proxy = DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = DomUtil.TRANSFORM,
			    transform = this._proxy.style[prop];

			DomUtil.setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			DomUtil.setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function _destroyAnimProxy() {
		DomUtil.remove(this._proxy);
		delete this._proxy;
	},

	_catchTransitionEnd: function _catchTransitionEnd(e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function _nothingToAnimate() {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {

		if (this._animatingZoom) {
			return true;
		}

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
			return false;
		}

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) {
			return false;
		}

		Util.requestAnimFrame(function () {
			this._moveStart(true)._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(Util.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function _onZoomTransitionEnd() {
		if (!this._animatingZoom) {
			return;
		}

		DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Bounds = Bounds;
exports.toBounds = toBounds;

var _Point = __webpack_require__(3);

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

function Bounds(a, b) {
	if (!a) {
		return;
	}

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function extend(point) {
		// (Point)
		point = (0, _Point.toPoint)(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function getCenter(round) {
		return new _Point.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function getBottomLeft() {
		return new _Point.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function getTopRight() {
		// -> Point
		return new _Point.Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function getTopLeft() {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function getBottomRight() {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function getSize() {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function contains(obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof _Point.Point) {
			obj = (0, _Point.toPoint)(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function intersects(bounds) {
		// (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = max2.x >= min.x && min2.x <= max.x,
		    yIntersects = max2.y >= min.y && min2.y <= max.y;

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function overlaps(bounds) {
		// (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = max2.x > min.x && min2.x < max.x,
		    yOverlaps = max2.y > min.y && min2.y < max.y;

		return xOverlaps && yOverlaps;
	},

	isValid: function isValid() {
		return !!(this.min && this.max);
	}
};

// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.LatLng = LatLng;
exports.toLatLng = toLatLng;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _CRS = __webpack_require__(16);

var _LatLngBounds = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function equals(obj, maxMargin) {
		if (!obj) {
			return false;
		}

		obj = toLatLng(obj);

		var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function toString(precision) {
		return 'LatLng(' + Util.formatNum(this.lat, precision) + ', ' + Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function distanceTo(other) {
		return _CRS.Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function wrap() {
		return _CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function toBounds(sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);

		return (0, _LatLngBounds.toLatLngBounds)([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function clone() {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};

// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (Util.isArray(a) && _typeof(a[0]) !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LatLngBounds = LatLngBounds;
exports.toLatLngBounds = toLatLngBounds;

var _LatLng = __webpack_require__(9);

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 */

function LatLngBounds(corner1, corner2) {
	// (LatLng, LatLng) or (LatLng[])
	if (!corner1) {
		return;
	}

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function extend(obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2,
		    ne2;

		if (obj instanceof _LatLng.LatLng) {
			sw2 = obj;
			ne2 = obj;
		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) {
				return this;
			}
		} else {
			return obj ? this.extend((0, _LatLng.toLatLng)(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new _LatLng.LatLng(sw2.lat, sw2.lng);
			this._northEast = new _LatLng.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function pad(bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(new _LatLng.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new _LatLng.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function getCenter() {
		return new _LatLng.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function getSouthWest() {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function getNorthEast() {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function getNorthWest() {
		return new _LatLng.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function getSouthEast() {
		return new _LatLng.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function getWest() {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function getSouth() {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function getEast() {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function getNorth() {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function contains(obj) {
		// (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof _LatLng.LatLng || 'lat' in obj) {
			obj = (0, _LatLng.toLatLng)(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2,
		    ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function intersects(bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),
		    latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
		    lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function overlaps(bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),
		    latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
		    lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function toBBoxString() {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function equals(bounds, maxMargin) {
		if (!bounds) {
			return false;
		}

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function isValid() {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Element = undefined;

var _elementMixin = __webpack_require__(33);

/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin Polymer.ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */
var Element = (0, _elementMixin.ElementMixin)(HTMLElement);
exports.Element = Element;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Layer = undefined;

var _Events = __webpack_require__(19);

var _Map = __webpack_require__(7);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */

var Layer = exports.Layer = _Events.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
  * Classes extending `L.Layer` will inherit the following methods:
  *
  * @method addTo(map: Map|LayerGroup): this
  * Adds the layer to the given map or layer group.
  */
	addTo: function addTo(map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function remove() {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function removeFrom(obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function getPane(name) {
		return this._map.getPane(name ? this.options[name] || name : this.options.pane);
	},

	addInteractiveTarget: function addInteractiveTarget(targetEl) {
		this._map._targets[Util.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function removeInteractiveTarget(targetEl) {
		delete this._map._targets[Util.stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function getAttribution() {
		return this.options.attribution;
	},

	_layerAdd: function _layerAdd(e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) {
			return;
		}

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', { layer: this });
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */

/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
_Map.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function addLayer(layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = Util.stamp(layer);
		if (this._layers[id]) {
			return this;
		}
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function removeLayer(layer) {
		var id = Util.stamp(layer);

		if (!this._layers[id]) {
			return this;
		}

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', { layer: layer });
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function hasLayer(layer) {
		return !!layer && Util.stamp(layer) in this._layers;
	},

	/* @method eachLayer(fn: Function, context?: Object): this
  * Iterates over the layers of the map, optionally specifying context of the iterator function.
  * ```
  * map.eachLayer(function(layer){
  *     layer.bindPopup('Hello');
  * });
  * ```
  */
	eachLayer: function eachLayer(method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function _addLayers(layers) {
		layers = layers ? Util.isArray(layers) ? layers : [layers] : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function _addZoomLimit(layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[Util.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function _removeZoomLimit(layer) {
		var id = Util.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function _updateZoomLevels() {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dedupingMixin = undefined;

__webpack_require__(2);

// unique global id for deduping mixins.
var dedupeId = 0;

/**
 * @constructor
 * @extends {Function}
 */
function MixinFunction() {}
/** @type {(WeakMap | undefined)} */
MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */
MixinFunction.prototype.__mixinSet;

var dedupingMixin = exports.dedupingMixin = function dedupingMixin(mixin) {
  var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
  }
  // maintain a unique id for each mixin
  var mixinDedupeId = dedupeId++;
  function dedupingMixin(base) {
    var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    var map = mixinApplications;
    var extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */mixin(base);
      map.set(base, extended);
    }
    // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.
    var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Handler = undefined;

var _Class = __webpack_require__(20);

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = exports.Handler = _Class.Class.extend({
	initialize: function initialize(map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function enable() {
		if (this._enabled) {
			return this;
		}

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function disable() {
		if (!this._enabled) {
			return this;
		}

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function enabled() {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.microTask = exports.idlePeriod = exports.animationFrame = exports.timeOut = undefined;

__webpack_require__(2);

/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

// Microtask implemented using Mutation Observer
var microtaskCurrHandle = 0;
var microtaskLastHandle = 0;
var microtaskCallbacks = [];
var microtaskNodeContent = 0;
var microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

function microtaskFlush() {
  var len = microtaskCallbacks.length;
  for (var i = 0; i < len; i++) {
    var cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

var timeOut = exports.timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} delay Time to wait before calling callbacks in ms
   * @return {AsyncInterface} An async timeout interface
   */
  after: function after(delay) {
    return {
      run: function run(fn) {
        return setTimeout(fn, delay);
      },

      cancel: window.clearTimeout.bind(window)
    };
  },

  /**
   * Enqueues a function called in the next task.
   *
   * @memberof Polymer.Async.timeOut
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.setTimeout.bind(window),
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.clearTimeout.bind(window)
};

var animationFrame = exports.animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof Polymer.Async.animationFrame
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.requestAnimationFrame.bind(window),
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.cancelAnimationFrame.bind(window)
};

var idlePeriod = exports.idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {function(IdleDeadline)} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: function run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },

  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: function cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }
};

var microTask = exports.microTask = {

  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof Polymer.Async.microTask
   * @param {Function} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run: function run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },


  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof Polymer.Async.microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: function cancel(handle) {
    var idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Earth = undefined;

var _CRS = __webpack_require__(47);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = exports.Earth = Util.extend({}, _CRS.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function distance(latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDebouncer = exports.flush = exports.matchesSelector = exports.dom = exports.DomApi = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

__webpack_require__(34);

var _flattenedNodesObserver = __webpack_require__(67);

var _flush = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var p = Element.prototype;
/**
 * @const {function(this:Element, string): boolean}
 */
var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @memberof Polymer.dom
 * @param {!Element} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
var matchesSelector = function matchesSelector(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};

/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 */

var DomApi = function () {

  /**
   * @param {Node} node Node for which to create a Polymer.dom helper object.
   */
  function DomApi(node) {
    _classCallCheck(this, DomApi);

    this.node = node;
  }

  /**
   * Returns an instance of `Polymer.FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {Function} callback Called when direct or distributed children
   *   of this element changes
   * @return {Polymer.FlattenedNodesObserver} Observer instance
   */


  _createClass(DomApi, [{
    key: 'observeNodes',
    value: function observeNodes(callback) {
      return new _flattenedNodesObserver.FlattenedNodesObserver(this.node, callback);
    }

    /**
     * Disconnects an observer previously created via `observeNodes`
     *
     * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
     *   to disconnect.
     */

  }, {
    key: 'unobserveNodes',
    value: function unobserveNodes(observerHandle) {
      observerHandle.disconnect();
    }

    /**
     * Provided as a backwards-compatible API only.  This method does nothing.
     */

  }, {
    key: 'notifyObserver',
    value: function notifyObserver() {}

    /**
     * Returns true if the provided node is contained with this element's
     * light-DOM children or shadow root, including any nested shadow roots
     * of children therein.
     *
     * @param {Node} node Node to test
     * @return {boolean} Returns true if the given `node` is contained within
     *   this element's light or shadow DOM.
     */

  }, {
    key: 'deepContains',
    value: function deepContains(node) {
      if (this.node.contains(node)) {
        return true;
      }
      var n = node;
      var doc = node.ownerDocument;
      // walk from node to `this` or `document`
      while (n && n !== doc && n !== this.node) {
        // use logical parentnode, or native ShadowRoot host
        n = n.parentNode || n.host;
      }
      return n === this.node;
    }

    /**
     * Returns the root node of this node.  Equivalent to `getRoodNode()`.
     *
     * @return {Node} Top most element in the dom tree in which the node
     * exists. If the node is connected to a document this is either a
     * shadowRoot or the document; otherwise, it may be the node
     * itself or a node or document fragment containing it.
     */

  }, {
    key: 'getOwnerRoot',
    value: function getOwnerRoot() {
      return this.node.getRootNode();
    }

    /**
     * For slot elements, returns the nodes assigned to the slot; otherwise
     * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
     *
     * @return {Array<Node>} Array of assigned nodes
     */

  }, {
    key: 'getDistributedNodes',
    value: function getDistributedNodes() {
      return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
    }

    /**
     * Returns an array of all slots this element was distributed to.
     *
     * @return {Array<HTMLSlotElement>} Description
     */

  }, {
    key: 'getDestinationInsertionPoints',
    value: function getDestinationInsertionPoints() {
      var ip$ = [];
      var n = this.node.assignedSlot;
      while (n) {
        ip$.push(n);
        n = n.assignedSlot;
      }
      return ip$;
    }

    /**
     * Calls `importNode` on the `ownerDocument` for this node.
     *
     * @param {Node} node Node to import
     * @param {boolean} deep True if the node should be cloned deeply during
     *   import
     * @return {Node} Clone of given node imported to this owner document
     */

  }, {
    key: 'importNode',
    value: function importNode(node, deep) {
      var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
      return doc.importNode(node, deep);
    }

    /**
     * @return {Array} Returns a flattened list of all child nodes and nodes assigned
     * to child slots.
     */

  }, {
    key: 'getEffectiveChildNodes',
    value: function getEffectiveChildNodes() {
      return _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(this.node);
    }

    /**
     * Returns a filtered list of flattened child elements for this element based
     * on the given selector.
     *
     * @param {string} selector Selector to filter nodes against
     * @return {Array<HTMLElement>} List of flattened child elements
     */

  }, {
    key: 'queryDistributedElements',
    value: function queryDistributedElements(selector) {
      var c$ = this.getEffectiveChildNodes();
      var list = [];
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
          list.push(c);
        }
      }
      return list;
    }

    /**
     * For shadow roots, returns the currently focused element within this
     * shadow root.
     *
     * @return {Node|undefined} Currently focused element
     */

  }, {
    key: 'activeElement',
    get: function get() {
      var node = this.node;
      return node._activeElement !== undefined ? node._activeElement : node.activeElement;
    }
  }]);

  return DomApi;
}();

function forwardMethods(proto, methods) {
  var _loop = function _loop(i) {
    var method = methods[i];
    proto[method] = /** @this {DomApi} */function () {
      return this.node[method].apply(this.node, arguments);
    };
  };

  for (var i = 0; i < methods.length; i++) {
    _loop(i);
  }
}

function forwardReadOnlyProperties(proto, properties) {
  var _loop2 = function _loop2(i) {
    var name = properties[i];
    Object.defineProperty(proto, name, {
      get: function get() {
        return (/** @type {DomApi} */this.node[name]
        );
      },
      configurable: true
    });
  };

  for (var i = 0; i < properties.length; i++) {
    _loop2(i);
  }
}

function forwardProperties(proto, properties) {
  var _loop3 = function _loop3(i) {
    var name = properties[i];
    Object.defineProperty(proto, name, {
      get: function get() {
        return (/** @type {DomApi} */this.node[name]
        );
      },
      set: function set(value) {
        /** @type {DomApi} */this.node[name] = value;
      },
      configurable: true
    });
  };

  for (var i = 0; i < properties.length; i++) {
    _loop3(i);
  }
}

forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

/**
 * Event API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is an `Event`.
 */

var EventApi = function () {
  function EventApi(event) {
    _classCallCheck(this, EventApi);

    this.event = event;
  }

  /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {Node} The node this event was dispatched to
   */


  _createClass(EventApi, [{
    key: 'rootTarget',
    get: function get() {
      return this.event.composedPath()[0];
    }

    /**
     * Returns the local (re-targeted) target for this event.
     *
     * @return {Node} The local (re-targeted) target for this event.
     */

  }, {
    key: 'localTarget',
    get: function get() {
      return this.event.target;
    }

    /**
     * Returns the `composedPath` for this event.
     */

  }, {
    key: 'path',
    get: function get() {
      return this.event.composedPath();
    }
  }]);

  return EventApi;
}();

exports.DomApi = DomApi;
var dom = exports.dom = function dom(obj) {
  obj = obj || document;
  if (!obj.__domApi) {
    var helper = void 0;
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApi(obj);
    }
    obj.__domApi = helper;
  }
  return obj.__domApi;
};

exports.matchesSelector = matchesSelector;
exports.flush = _flush.flush;
exports.addDebouncer = _flush.enqueueDebouncer;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.featureGroup = exports.FeatureGroup = undefined;

var _LayerGroup = __webpack_require__(46);

var _LatLngBounds = __webpack_require__(10);

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = exports.FeatureGroup = _LayerGroup.LayerGroup.extend({

	addLayer: function addLayer(layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		_LayerGroup.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', { layer: layer });
	},

	removeLayer: function removeLayer(layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		_LayerGroup.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', { layer: layer });
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function setStyle(style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function bringToFront() {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function bringToBack() {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function getBounds() {
		var bounds = new _LatLngBounds.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = exports.featureGroup = function featureGroup(layers) {
	return new FeatureGroup(layers);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Evented = exports.Events = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _Class = __webpack_require__(20);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = exports.Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
  * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  *
  * @alternative
  * @method on(eventMap: Object): this
  * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  */
	on: function on(types, fn, context) {

		// types can be a map of types/handlers
		if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}
		} else {
			// types can be a string of space-separated words
			types = Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
  * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  *
  * @alternative
  * @method off(eventMap: Object): this
  * Removes a set of type/listener pairs.
  *
  * @alternative
  * @method off: this
  * Removes all listeners to all events on the object.
  */
	off: function off(types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;
		} else if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}
		} else {
			types = Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function _on(type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = { fn: fn, ctx: context },
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function _off(type, fn, context) {
		var listeners, i, len;

		if (!this._events) {
			return;
		}

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) {
					continue;
				}
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function fire(type, data, propagate) {
		if (!this.listens(type, propagate)) {
			return this;
		}

		var event = Util.extend({}, data, { type: type, target: this });

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = this._firingCount + 1 || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function listens(type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) {
			return true;
		}

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) {
					return true;
				}
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function once(types, fn, context) {

		if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = Util.bind(function () {
			this.off(types, fn, context).off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this.on(types, fn, context).on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function addEventParent(obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[Util.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function removeEventParent(obj) {
		if (this._eventParents) {
			delete this._eventParents[Util.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function _propagateEvent(e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, Util.extend({ layer: e.target }, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = exports.Evented = _Class.Class.extend(Events);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Class = Class;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function NewClass() {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		Util.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = Util.extend(Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	Util.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) {
			return;
		}

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};

// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	Util.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	Util.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) {
	// (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (!L || !L.Mixin) {
		return;
	}

	includes = Util.isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Transformation = Transformation;
exports.toTransformation = toTransformation;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */

// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (Util.isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function transform(point, scale) {
		// (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function _transform(point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function untransform(point, scale) {
		scale = scale || 1;
		return new _Point.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coeficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.control = exports.Control = undefined;

var _Class = __webpack_require__(20);

var _Map = __webpack_require__(7);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = exports.Control = _Class.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
	},

	/* @section
  * Classes extending L.Control will inherit the following methods:
  *
  * @method getPosition: string
  * Returns the position of the control.
  */
	getPosition: function getPosition() {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function setPosition(position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function getContainer() {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function addTo(map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function remove() {
		if (!this._map) {
			return this;
		}

		DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function _refocusOnMap(e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = exports.control = function control(options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
_Map.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function addControl(control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function removeControl(control) {
		control.remove();
		return this;
	},

	_initControlPos: function _initControlPos() {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer = DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function _clearControlPos() {
		for (var i in this._controlCorners) {
			DomUtil.remove(this._controlCorners[i]);
		}
		DomUtil.remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Path = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = exports.Path = _Layer.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function beforeAdd(map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function onAdd() {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function onRemove() {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function redraw() {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function setStyle(style) {
		Util.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function bringToFront() {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function bringToBack() {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function getElement() {
		return this._path;
	},

	_reset: function _reset() {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function _clickTolerance() {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (_Browser.touch ? 10 : 0);
	}
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.simplify = simplify;
exports.pointToSegmentDistance = pointToSegmentDistance;
exports.closestPointOnSegment = closestPointOnSegment;
exports.clipSegment = clipSegment;
exports._getEdgeIntersection = _getEdgeIntersection;
exports._getBitCode = _getBitCode;
exports._sqClosestPointOnSegment = _sqClosestPointOnSegment;
exports.isFlat = isFlat;
exports._flat = _flat;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

	// stage 1: vertex reduction
	points = _reducePoints(points, sqTolerance);

	// stage 2: Douglas-Peucker simplification
	points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
	    ArrayConstructor = (typeof Uint8Array === 'undefined' ? 'undefined' : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,
	    markers = new ArrayConstructor(len);

	markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
	    newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	    index,
	    i,
	    sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
	    codeB = _getBitCode(b, bounds),
	    codeOut,
	    p,
	    newCode;

	// save 2nd code to avoid calculating it on the next segment
	_lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
	    dy = b.y - a.y,
	    min = bounds.min,
	    max = bounds.max,
	    x,
	    y;

	if (code & 8) {
		// top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;
	} else if (code & 4) {
		// bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;
	} else if (code & 2) {
		// right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;
	} else if (code & 1) {
		// left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new _Point.Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) {
		// left
		code |= 1;
	} else if (p.x > bounds.max.x) {
		// right
		code |= 2;
	}

	if (p.y < bounds.min.y) {
		// bottom
		code |= 4;
	} else if (p.y > bounds.max.y) {
		// top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
	    dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
	    y = p1.y,
	    dx = p2.x - x,
	    dy = p2.y - y,
	    dot = dx * dx + dy * dy,
	    t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new _Point.Point(x, y);
}

// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !Util.isArray(latlngs[0]) || _typeof(latlngs[0][0]) !== 'object' && typeof latlngs[0][0] !== 'undefined';
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathFromUrl = exports.resolveUrl = exports.resolveCss = undefined;

__webpack_require__(2);

var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var workingURL = void 0;
var resolveDoc = void 0;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  // Lazy feature detection.
  if (workingURL === undefined) {
    workingURL = false;
    try {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = u.href === 'http://a/c%20d';
    } catch (e) {
      // silently fail
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    return new URL(url, baseURI).href;
  }
  // Fallback to creating an anchor into a disconnected document.
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}

/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
    return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
  });
}

/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}

exports.resolveCss = resolveCss;
exports.resolveUrl = resolveUrl;
exports.pathFromUrl = pathFromUrl;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDeep = undefined;
exports.isPath = isPath;
exports.root = root;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
exports.translate = translate;
exports.matches = matches;
exports.normalize = normalize;
exports.split = split;
exports.get = get;
exports.set = set;

__webpack_require__(2);

function isPath(path) {
  return path.indexOf('.') >= 0;
}

function root(path) {
  var dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}

function matches(base, path) {
  return base === path || isAncestor(base, path) || isDescendant(base, path);
}

function normalize(path) {
  if (Array.isArray(path)) {
    var parts = [];
    for (var i = 0; i < path.length; i++) {
      var args = path[i].toString().split('.');
      for (var j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }
  return path.toString().split('.');
}

function get(root, path, info) {
  var prop = root;
  var parts = split(path);
  // Loop over path parts[0..n-1] and dereference
  for (var i = 0; i < parts.length; i++) {
    if (!prop) {
      return;
    }
    var part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}

function set(root, path, value) {
  var prop = root;
  var parts = split(path);
  var last = parts[parts.length - 1];
  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (var i = 0; i < parts.length - 1; i++) {
      var part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    // Set value to object at end of path
    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }
  return parts.join('.');
}

var isDeep = exports.isDeep = isPath;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Debouncer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

__webpack_require__(13);

__webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
var AsyncModule = void 0; // eslint-disable-line no-unused-vars

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 * @memberof Polymer
 */

var Debouncer = function () {
  function Debouncer() {
    _classCallCheck(this, Debouncer);

    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncModule} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   */


  _createClass(Debouncer, [{
    key: 'setConfig',
    value: function setConfig(asyncModule, callback) {
      var _this = this;

      this._asyncModule = asyncModule;
      this._callback = callback;
      this._timer = this._asyncModule.run(function () {
        _this._timer = null;
        _this._callback();
      });
    }
    /**
     * Cancels an active debouncer and returns a reference to itself.
     */

  }, {
    key: 'cancel',
    value: function cancel() {
      if (this.isActive()) {
        this._asyncModule.cancel(this._timer);
        this._timer = null;
      }
    }
    /**
     * Flushes an active debouncer and returns a reference to itself.
     */

  }, {
    key: 'flush',
    value: function flush() {
      if (this.isActive()) {
        this.cancel();
        this._callback();
      }
    }
    /**
     * Returns true if the debouncer is active.
     *
     * @return {boolean} True if active.
     */

  }, {
    key: 'isActive',
    value: function isActive() {
      return this._timer != null;
    }
    /**
     * Creates a debouncer if no debouncer is passed as a parameter
     * or it cancels an active debouncer otherwise. The following
     * example shows how a debouncer can be called multiple times within a
     * microtask and "debounced" such that the provided callback function is
     * called once. Add this method to a custom element:
     *
     * _debounceWork() {
     *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
     *       Polymer.Async.microTask, () => {
     *     this._doWork();
     *   });
     * }
     *
     * If the `_debounceWork` method is called multiple times within the same
     * microtask, the `_doWork` function will be called only once at the next
     * microtask checkpoint.
     *
     * Note: In testing it is often convenient to avoid asynchrony. To accomplish
     * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
     * `Polymer.flush`. For example, extend the above example by adding
     * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
     * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
     * the debouncer has completed.
     *
     * @param {Debouncer?} debouncer Debouncer object.
     * @param {!AsyncModule} asyncModule Object with Async interface
     * @param {function()} callback Callback to run.
     * @return {!Debouncer} Returns a debouncer object.
     */

  }], [{
    key: 'debounce',
    value: function debounce(debouncer, asyncModule, callback) {
      if (debouncer instanceof Debouncer) {
        debouncer.cancel();
      } else {
        debouncer = new Debouncer();
      }
      debouncer.setConfig(asyncModule, callback);
      return debouncer;
    }
  }]);

  return Debouncer;
}();

exports.Debouncer = Debouncer;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Polymer = undefined;

var _class = __webpack_require__(99);

var Polymer = exports.Polymer = function Polymer(info) {
  // if input is a `class` (aka a function with a prototype), use the prototype
  // remember that the `constructor` will never be called
  var klass = void 0;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = (0, _class.Class)(info);
  }
  customElements.define(klass.is, /** @type {!HTMLElement} */klass);
  return klass;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionalMutableData = exports.MutableData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _mixin = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
  var isObject = void 0;
  if (mutableData) {
    isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
    // Pull `old` for Objects from temp cache, but treat `null` as a primitive
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  // Strict equality check, but return false for NaN===NaN
  var shouldChange = old !== value && (old === old || value === value);
  // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}

var MutableData = exports.MutableData = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  var MutableData = function (_superClass) {
    _inherits(MutableData, _superClass);

    function MutableData() {
      _classCallCheck(this, MutableData);

      return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
    }

    _createClass(MutableData, [{
      key: '_shouldPropertyChange',

      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * This method pulls the value to dirty check against from the `__dataTemp`
       * cache (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      value: function _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, true);
      }
    }]);

    return MutableData;
  }(superClass);
  /** @type {boolean} */


  MutableData.prototype.mutableData = false;

  return MutableData;
});

var OptionalMutableData = exports.OptionalMutableData = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  var OptionalMutableData = function (_superClass2) {
    _inherits(OptionalMutableData, _superClass2);

    function OptionalMutableData() {
      _classCallCheck(this, OptionalMutableData);

      return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
    }

    _createClass(OptionalMutableData, [{
      key: '_shouldPropertyChange',


      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * When `this.mutableData` is true on this instance, this method
       * pulls the value to dirty check against from the `__dataTemp` cache
       * (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      value: function _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, this.mutableData);
      }
    }], [{
      key: 'properties',
      get: function get() {
        return {
          /**
           * Instance-level flag for configuring the dirty-checking strategy
           * for this element.  When true, Objects and Arrays will skip dirty
           * checking, otherwise strict equality checking will be used.
           */
          mutableData: Boolean
        };
      }
    }]);

    return OptionalMutableData;
  }(superClass);

  return OptionalMutableData;
});

// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Icon = undefined;
exports.icon = icon;

var _Class = __webpack_require__(20);

var _Util = __webpack_require__(0);

var _Point = __webpack_require__(3);

var _Browser = __webpack_require__(4);

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = exports.Icon = _Class.Class.extend({

	/* @section
  * @aka Icon options
  *
  * @option iconUrl: String = null
  * **(required)** The URL to the icon image (absolute or relative to your script path).
  *
  * @option iconRetinaUrl: String = null
  * The URL to a retina sized version of the icon image (absolute or relative to your
  * script path). Used for Retina screen devices.
  *
  * @option iconSize: Point = null
  * Size of the icon image in pixels.
  *
  * @option iconAnchor: Point = null
  * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  * will be aligned so that this point is at the marker's geographical location. Centered
  * by default if size is specified, also can be set in CSS with negative margins.
  *
  * @option popupAnchor: Point = null
  * The coordinates of the point from which popups will "open", relative to the icon anchor.
  *
  * @option shadowUrl: String = null
  * The URL to the icon shadow image. If not specified, no shadow image will be created.
  *
  * @option shadowRetinaUrl: String = null
  *
  * @option shadowSize: Point = null
  * Size of the shadow image in pixels.
  *
  * @option shadowAnchor: Point = null
  * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  * as iconAnchor if not specified).
  *
  * @option className: String = ''
  * A custom class name to assign to both icon and shadow images. Empty by default.
  */

	initialize: function initialize(options) {
		(0, _Util.setOptions)(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function createIcon(oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function createShadow(oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function _createIcon(name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function _setIconStyles(img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = (0, _Point.toPoint)(sizeOption),
		    anchor = (0, _Point.toPoint)(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = -anchor.x + 'px';
			img.style.marginTop = -anchor.y + 'px';
		}

		if (size) {
			img.style.width = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function _createImg(src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function _getIconUrl(name) {
		return _Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});

// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Renderer = undefined;

var _Layer = __webpack_require__(12);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = exports.Renderer = _Layer.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
		Util.stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function onAdd() {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function onRemove() {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function getEvents() {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function _onAnimZoom(ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function _onZoom() {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function _updateTransform(center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),
		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (Browser.any3d) {
			DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function _reset() {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function _onZoomEnd() {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function _updatePaths() {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function _update() {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new _Bounds.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CircleMarker = undefined;
exports.circleMarker = circleMarker;

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = exports.CircleMarker = _Path.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function initialize(latlng, options) {
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function setLatLng(latlng) {
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this.redraw();
		return this.fire('move', { latlng: this._latlng });
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function setRadius(radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function getRadius() {
		return this._radius;
	},

	setStyle: function setStyle(options) {
		var radius = options && options.radius || this._radius;
		_Path.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function _project() {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function _updateBounds() {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new _Bounds.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function _update() {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function _updatePath() {
		this._renderer._updateCircle(this);
	},

	_empty: function _empty() {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});

// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStyles = exports.registrations = exports.instanceCount = exports.ElementMixin = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports._regLog = _regLog;
exports.register = register;
exports.dumpRegistrations = dumpRegistrations;

__webpack_require__(2);

var _settings = __webpack_require__(34);

var _mixin = __webpack_require__(13);

var _caseMap = __webpack_require__(35);

var caseMap$0 = _interopRequireWildcard(_caseMap);

var _styleGather = __webpack_require__(58);

var _resolveUrl = __webpack_require__(25);

var _domModule = __webpack_require__(59);

var _propertyEffects = __webpack_require__(36);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ElementMixin = exports.ElementMixin = (0, _mixin.dedupingMixin)(function (base) {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_PropertyEffects}
   */
  var polymerElementBase = (0, _propertyEffects.PropertyEffects)(base);

  var caseMap = caseMap$0;

  /**
   * Returns the `properties` object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   *
   * @param {HTMLElement} klass Element class
   * @return {Object} Object containing own properties for this class
   * @private
   */
  function ownPropertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
      klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
      /** @type PolymerElementConstructor */klass.properties : {};
    }
    return klass.__ownProperties;
  }

  /**
   * Returns the `observers` array specifically on `klass`. Use for
   * setting up observers.
   *
   * @param {HTMLElement} klass Element class
   * @return {Array} Array containing own observers for this class
   * @private
   */
  function ownObserversForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
      klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
      /** @type PolymerElementConstructor */klass.observers : [];
    }
    return klass.__ownObservers;
  }

  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   *
   * @param {Object} flattenedProps Bag to collect flattened properties into
   * @param {Object} props Bag of properties to add to `flattenedProps`
   * @return {Object} The input `flattenedProps` bag
   * @private
   */
  function flattenProperties(flattenedProps, props) {
    for (var p in props) {
      var o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   * @suppress {missingProperties} class.prototype is not a property for some reason?
   * @private
   */
  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
      klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
      var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
      }
    }
    return klass.__classProperties;
  }

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */
  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
      klass.__classPropertyDefaults = null;
      var props = propertiesForClass(klass);
      for (var p in props) {
        var info = props[p];
        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }
    return klass.__classPropertyDefaults;
  }

  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {PolymerElementConstructor} klass Element class
   * @return {boolean} True if all metaprogramming for this class has been
   *   completed
   * @private
   */
  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
  }

  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClassAndSuper(klass) {
    var proto = /** @type PolymerElementConstructor */klass.prototype;
    var superCtor = Object.getPrototypeOf(proto).constructor;
    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }
    finalizeClass(klass);
  }

  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClass(klass) {
    klass.__finalized = true;
    var proto = /** @type PolymerElementConstructor */klass.prototype;
    if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
      register(proto);
    }
    var props = ownPropertiesForClass(klass);
    if (props) {
      finalizeProperties(proto, props);
    }
    var observers = ownObserversForClass(klass);
    if (observers) {
      finalizeObservers(proto, observers, props);
    }
    // note: create "working" template that is finalized at instance time
    var template = /** @type PolymerElementConstructor */klass.template;
    if (template) {
      if (typeof template === 'string') {
        var t = document.createElement('template');
        t.innerHTML = template;
        template = t;
      } else {
        template = template.cloneNode(true);
      }
      proto._template = template;
    }
  }

  /**
   * Configures a `proto` based on a `properties` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *    and effects to
   * @param {Object} properties Flattened bag of property descriptors for
   *    this class
   * @private
   */
  function finalizeProperties(proto, properties) {
    for (var p in properties) {
      createPropertyFromConfig(proto, p, properties[p], properties);
    }
  }

  /**
   * Configures a `proto` based on a `observers` array.
   * Leverages `PropertyEffects` to create observers.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {Object} observers Flattened array of observer descriptors for
   *   this class
   * @param {Object} dynamicFns Object containing keys for any properties
   *   that are functions and should trigger the effect when the function
   *   reference is changed
   * @private
   */
  function finalizeObservers(proto, observers, dynamicFns) {
    for (var i = 0; i < observers.length; i++) {
      proto._createMethodObserver(observers[i], dynamicFns);
    }
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should may contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttriute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   * Also consider adding warnings when an effect cannot be changed.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @private
   */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }

  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {!HTMLTemplateElement} template Template to process and bind
   * @param {string} baseURI URL against which to resolve urls in
   *   style element cssText
   * @param {string} is Tag name (or type extension name) for this element
   * @param {string=} ext For type extensions, the tag name that was extended
   * @private
   */
  function finalizeTemplate(proto, template, baseURI, is, ext) {
    // support `include="module-name"`
    var cssText = (0, _styleGather.cssFromModuleImports)(is) + (0, _styleGather.cssFromTemplate)(template, baseURI);
    if (cssText) {
      var style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }
    proto._bindTemplate(template);
  }

  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   */

  var PolymerElement = function (_polymerElementBase) {
    _inherits(PolymerElement, _polymerElementBase);

    _createClass(PolymerElement, null, [{
      key: 'finalize',


      /**
       * Called automatically when the first element instance is created to
       * ensure that class finalization work has been completed.
       * May be called by users to eagerly perform class finalization work
       * prior to the creation of the first element instance.
       *
       * Class finalization work generally includes meta-programming such as
       * creating property accessors and any property effect metadata needed for
       * the features used.
       *
       * @public
       */
      value: function finalize() {
        if (!hasClassFinalized(this)) {
          finalizeClassAndSuper(this);
        }
      }

      /**
       * Returns the template that will be stamped into this element's shadow root.
       *
       * If a `static get is()` getter is defined, the default implementation
       * will return the first `<template>` in a `dom-module` whose `id`
       * matches this element's `is`.
       *
       * Users may override this getter to return an arbitrary template
       * (in which case the `is` getter is unnecessary). The template returned
       * may be either an `HTMLTemplateElement` or a string that will be
       * automatically parsed into a template.
       *
       * Note that when subclassing, if the super class overrode the default
       * implementation and the subclass would like to provide an alternate
       * template via a `dom-module`, it should override this getter and
       * return `Polymer.DomModule.import(this.is, 'template')`.
       *
       * If a subclass would like to modify the super class template, it should
       * clone it rather than modify it in place.  If the getter does expensive
       * work such as cloning/modifying a template, it should memoize the
       * template for maximum performance:
       *
       *   let memoizedTemplate;
       *   class MySubClass extends MySuperClass {
       *     static get template() {
       *       if (!memoizedTemplate) {
       *         memoizedTemplate = super.template.cloneNode(true);
       *         let subContent = document.createElement('div');
       *         subContent.textContent = 'This came from MySubClass';
       *         memoizedTemplate.content.appendChild(subContent);
       *       }
       *       return memoizedTemplate;
       *     }
       *   }
       *
       * @return {HTMLTemplateElement|string} Template to be stamped
       */

    }, {
      key: 'observedAttributes',


      /**
       * Standard Custom Elements V1 API.  The default implementation returns
       * a list of dash-cased attributes based on a flattening of all properties
       * declared in `static get properties()` for this element and any
       * superclasses.
       *
       * @return {Array} Observed attribute list
       */
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
          var list = [];
          var properties = propertiesForClass(this);
          for (var prop in properties) {
            list.push((0, _caseMap.camelToDashCase)(prop));
          }
          this.__observedAttributes = list;
        }
        return this.__observedAttributes;
      }
    }, {
      key: 'template',
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
          this._template = _domModule.DomModule && _domModule.DomModule.import(
          /** @type PolymerElementConstructor*/this.is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
        }
        return this._template;
      }

      /**
       * Path matching the url from which the element was imported.
       * This path is used to resolve url's in template style cssText.
       * The `importPath` property is also set on element instances and can be
       * used to create bindings relative to the import path.
       * Defaults to the path matching the url containing a `dom-module` element
       * matching this element's static `is` property.
       * Note, this path should contain a trailing `/`.
       *
       * @return {string} The import path for this element class
       */

    }, {
      key: 'importPath',
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
          var module = _domModule.DomModule && _domModule.DomModule.import( /** @type PolymerElementConstructor */this.is);
          this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
        }
        return this._importPath;
      }
    }]);

    function PolymerElement() {
      _classCallCheck(this, PolymerElement);

      /** @type {HTMLTemplateElement} */
      var _this = _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).call(this));

      _this._template;
      /** @type {string} */
      _this._importPath;
      /** @type {string} */
      _this.rootPath;
      /** @type {string} */
      _this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
      _this.root;
      /** @type {!Object<string, !Node>} */
      _this.$;
      return _this;
    }

    /**
     * Overrides the default `Polymer.PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @override
     * @suppress {invalidCasts}
     */


    _createClass(PolymerElement, [{
      key: '_initializeProperties',
      value: function _initializeProperties() {
        exports.instanceCount = instanceCount += 1;
        this.constructor.finalize();
        var importPath = this.constructor.importPath;
        // note: finalize template when we have access to `localName` to
        // avoid dependence on `is` for polyfilling styling.
        if (this._template && !this._template.__polymerFinalized) {
          this._template.__polymerFinalized = true;
          var baseURI = importPath ? (0, _resolveUrl.resolveUrl)(importPath) : '';
          finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
          /**@type {!HTMLElement}*/this.localName);
        }
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
        // set path defaults
        this.rootPath = _settings.rootPath;
        this.importPath = importPath;
        // apply property defaults...
        var p$ = propertyDefaultsForClass(this.constructor);
        if (!p$) {
          return;
        }
        for (var p in p$) {
          var info = p$[p];
          // Don't set default value if there is already an own property, which
          // happens when a `properties` property with default but no effects had
          // a property set (e.g. bound) by its host before upgrade
          if (!this.hasOwnProperty(p)) {
            var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
            // Set via `_setProperty` if there is an accessor, to enable
            // initializing readOnly property defaults
            if (this._hasAccessor(p)) {
              this._setPendingProperty(p, value, true);
            } else {
              this[p] = value;
            }
          }
        }
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `connectedCallback`.
       *
       * The default implementation enables the property effects system and
       * flushes any pending properties, and updates shimmed CSS properties
       * when using the ShadyCSS scoping/custom properties polyfill.
       *
       * @suppress {invalidCasts}
       */

    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        if (window.ShadyCSS && this._template) {
          window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
        }
        this._enableProperties();
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `disconnectedCallback`.
       */

    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {}

      /**
       * Stamps the element template.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        if (this._template) {
          this.root = this._stampTemplate(this._template);
          this.$ = this.root.$;
        }
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
      }

      /**
       * Implements `PropertyEffects`'s `_readyClients` call. Attaches
       * element dom by calling `_attachDom` with the dom stamped from the
       * element's template via `_stampTemplate`. Note that this allows
       * client dom to be attached to the element prior to any observers
       * running.
       *
       * @override
       */

    }, {
      key: '_readyClients',
      value: function _readyClients() {
        if (this._template) {
          this.root = this._attachDom( /** @type {StampedTemplate} */this.root);
        }
        // The super._readyClients here sets the clients initialized flag.
        // We must wait to do this until after client dom is created/attached
        // so that this flag can be checked to prevent notifications fired
        // during this process from being handled before clients are ready.
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
      }

      /**
       * Attaches an element's stamped dom to itself. By default,
       * this method creates a `shadowRoot` and adds the dom to it.
       * However, this method may be overridden to allow an element
       * to put its dom in another location.
       *
       * @throws {Error}
       * @suppress {missingReturn}
       * @param {StampedTemplate} dom to attach to the element.
       * @return {ShadowRoot} node to which the dom has been attached.
       */

    }, {
      key: '_attachDom',
      value: function _attachDom(dom) {
        if (this.attachShadow) {
          if (dom) {
            if (!this.shadowRoot) {
              this.attachShadow({ mode: 'open' });
            }
            this.shadowRoot.appendChild(dom);
            return this.shadowRoot;
          }
          return null;
        } else {
          throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
          'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
        }
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `attributeChangedCallback`.
       *
       * By default, attributes declared in `properties` metadata are
       * deserialized using their `type` information to properties of the
       * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
       * properties.
       *
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @override
       */

    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          var property = caseMap.dashToCamelCase(name);
          var type = propertiesForClass(this.constructor)[property].type;
          if (!this._hasReadOnlyEffect(property)) {
            this._attributeToProperty(name, value, type);
          }
        }
      }

      /**
       * When using the ShadyCSS scoping and custom property shim, causes all
       * shimmed styles in this element (and its subtree) to be updated
       * based on current custom property values.
       *
       * The optional parameter overrides inline custom property styles with an
       * object of properties where the keys are CSS properties, and the values
       * are strings.
       *
       * Example: `this.updateStyles({'--color': 'blue'})`
       *
       * These properties are retained unless a value of `null` is set.
       *
       * @param {Object=} properties Bag of custom property key/values to
       *   apply to this element.
       * @suppress {invalidCasts}
       */

    }, {
      key: 'updateStyles',
      value: function updateStyles(properties) {
        if (window.ShadyCSS) {
          window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
        }
      }

      /**
       * Rewrites a given URL relative to a base URL. The base URL defaults to
       * the original location of the document containing the `dom-module` for
       * this element. This method will return the same URL before and after
       * bundling.
       *
       * @param {string} url URL to resolve.
       * @param {string=} base Optional base URL to resolve against, defaults
       * to the element's `importPath`
       * @return {string} Rewritten URL relative to base
       */

    }, {
      key: 'resolveUrl',
      value: function resolveUrl(url, base) {
        if (!base && this.importPath) {
          base = (0, _resolveUrl.resolveUrl)(this.importPath);
        }
        return (0, _resolveUrl.resolveUrl)(url, base);
      }

      /**
       * Overrides `PropertyAccessors` to add map of dynamic functions on
       * template info, for consumption by `PropertyEffects` template binding
       * code. This map determines which method templates should have accessors
       * created for them.
       *
       * @override
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }], [{
      key: '_parseTemplateContent',
      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
        templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
        return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
      }
    }]);

    return PolymerElement;
  }(polymerElementBase);

  return PolymerElement;
});

var instanceCount = exports.instanceCount = 0;
var registrations = exports.registrations = [];

function _regLog(prototype) {
  console.log('[' + prototype.is + ']: registered');
}

function register(prototype) {
  registrations.push(prototype);
  undefined && _regLog(prototype);
}

function dumpRegistrations() {
  registrations.forEach(_regLog);
}

var updateStyles = exports.updateStyles = function updateStyles(props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setSanitizeDOMValue = exports.sanitizeDOMValue = exports.setRootPath = exports.rootPath = exports.Settings = exports.useNativeCustomElements = exports.useNativeCSSProperties = exports.useShadow = undefined;

__webpack_require__(2);

var _resolveUrl = __webpack_require__(25);

/**
 * Legacy settings.
 * @namespace
 * @memberof Polymer
 */
var settings = undefined || {};
var useShadow = exports.useShadow = !window.ShadyDOM;
var useNativeCSSProperties = exports.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
var useNativeCustomElements = exports.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
exports.Settings = settings;

/**
 * Globally settable property that is automatically assigned to
 * `Polymer.ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `Polymer.rootPath` to provide a stable application mount path when
 * using client side routing.
 *
 * @memberof Polymer
 */

var rootPath = undefined || (0, _resolveUrl.pathFromUrl)(document.baseURI || window.location.href);

exports.rootPath = rootPath;
var setRootPath = exports.setRootPath = function setRootPath(path) {
  exports.rootPath = rootPath = path;
};

/**
 * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
 *
 *     Polymer = {
 *       sanitizeDOMValue: function(value, name, type, node) { ... }
 *     }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 * @memberof Polymer
 */
var sanitizeDOMValue = undefined;

exports.sanitizeDOMValue = sanitizeDOMValue;
var setSanitizeDOMValue = exports.setSanitizeDOMValue = function setSanitizeDOMValue(newSanitizeDOMValue) {
  exports.sanitizeDOMValue = sanitizeDOMValue = newSanitizeDOMValue;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dashToCamelCase = dashToCamelCase;
exports.camelToDashCase = camelToDashCase;

__webpack_require__(2);

var caseMap = {};
var DASH_TO_CAMEL = /-[a-z]/g;
var CAMEL_TO_DASH = /([A-Z])/g;

function dashToCamelCase(dash) {
  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
    return m[1].toUpperCase();
  }));
}

function camelToDashCase(camel) {
  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertyEffects = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _path = __webpack_require__(26);

var _caseMap = __webpack_require__(35);

var caseMap = _interopRequireWildcard(_caseMap);

var _propertyAccessors = __webpack_require__(91);

var _templateStamp = __webpack_require__(92);

var _settings = __webpack_require__(34);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @const {Object} */
var CaseMap = caseMap;

// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
var dedupeId = 0;

/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */
var TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};

/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */
var DataTrigger = void 0; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */
var DataEffect = void 0; //eslint-disable-line no-unused-vars

var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */
function ensureOwnEffectMap(model, type) {
  var effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    for (var p in effects) {
      var protoFx = effects[p];
      var instFx = effects[p] = Array(protoFx.length);
      for (var i = 0; i < protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }
  return effects;
}

// -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {Object} props Bag of current property changes
 * @param {Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    var ran = false;
    var id = dedupeId++;
    for (var prop in props) {
      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }
    return ran;
  }
  return false;
}

/**
 * Runs a list of effects for a given property.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  var ran = false;
  var rootProperty = hasPaths ? (0, _path.root)(prop) : prop;
  var fxs = effects[rootProperty];
  if (fxs) {
    for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}

/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    var triggerPath = trigger.name;
    return triggerPath == path || trigger.structured && (0, _path.isAncestor)(triggerPath, path) || trigger.wildcard && (0, _path.isDescendant)(triggerPath, path);
  } else {
    return true;
  }
}

/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runObserverEffect(inst, property, props, oldProps, info) {
  var fn = inst[info.methodName];
  var changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.methodName + '` not defined');
  }
}

/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  var fxs = inst[TYPES.NOTIFY];
  var notified = void 0;
  var id = dedupeId++;
  // Try normal notify effects; if none, fall back to try path notification
  for (var prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.
  var host = void 0;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}

/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */
function notifyPath(inst, path, props) {
  var rootProperty = (0, _path.root)(path);
  if (rootProperty !== path) {
    var eventName = (0, _caseMap.camelToDashCase)(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}

/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} eventName The name of the event to send ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property changed, the path
 *   that changed (optional).
 * @private
 * @suppress {invalidCasts}
 */
function dispatchNotifyEvent(inst, eventName, value, path) {
  var detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
}

/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  var rootProperty = hasPaths ? (0, _path.root)(property) : property;
  var path = rootProperty != property ? property : null;
  var value = path ? (0, _path.get)(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property]; // specifically for .splices
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}

/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!PropertyEffectsType} inst Host element instance handling the notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @private
 */
function handleNotification(event, inst, fromProp, toPath, negate) {
  var value = void 0;
  var detail = /** @type {Object} */event.detail;
  var fromPath = detail && detail.path;
  if (fromPath) {
    toPath = (0, _path.translate)(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.target[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}

/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runReflectEffect(inst, property, props, oldProps, info) {
  var value = inst.__data[property];
  if (_settings.sanitizeDOMValue) {
    value = (0, _settings.sanitizeDOMValue)(value, info.attrName, 'attribute', /** @type {Node} */inst);
  }
  inst._propertyToAttribute(property, info.attrName, value);
}

/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {!Object} changedProps Bag of changed properties
 * @param {!Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  var computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    var inputProps = changedProps;
    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(oldProps, inst.__dataOld);
      Object.assign(changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}

/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runComputedEffect(inst, property, props, oldProps, info) {
  var result = runMethodEffect(inst, property, props, oldProps, info);
  var computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}

/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!PropertyEffectsType} inst The instance whose props are changing
 * @param {string | !Array<(string|number)>} path Path that has changed
 * @param {*} value Value of changed path
 * @private
 */
function computeLinkedPaths(inst, path, value) {
  var links = inst.__dataLinkedPaths;
  if (links) {
    var link = void 0;
    for (var a in links) {
      var b = links[a];
      if ((0, _path.isDescendant)(a, path)) {
        link = (0, _path.translate)(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if ((0, _path.isDescendant)(b, path)) {
        link = (0, _path.translate)(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}

// -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @private
 */
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
  nodeInfo.bindings.push(binding);
  // Add listener info to binding metadata
  if (shouldAddListener(binding)) {
    var _binding$parts$ = binding.parts[0],
        event = _binding$parts$.event,
        negate = _binding$parts$.negate;

    binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
    binding.listenerNegate = negate;
  }
  // Add "propagate" property effects to templateInfo
  var index = templateInfo.nodeInfoList.length;
  for (var i = 0; i < binding.parts.length; i++) {
    var part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}

/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 */
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      var dependencies = part.dependencies;
      var info = { index: index, binding: binding, part: part, evaluator: constructor };
      for (var j = 0; j < dependencies.length; j++) {
        var trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info: info, trigger: trigger
        });
      }
    }
  }
}

/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @private
 */
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  var node = nodeList[info.index];
  var binding = info.binding;
  var part = info.part;
  // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    var value = props[path];
    path = (0, _path.translate)(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    // Propagate value to child
    applyBindingValue(inst, node, binding, part, _value);
  }
}

/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!PropertyEffectsType} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @private
 */
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (_settings.sanitizeDOMValue) {
    value = (0, _settings.sanitizeDOMValue)(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
  } else {
    // Property binding
    var prop = binding.target;
    if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}

/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    var storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}

/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */
function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
}

/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!PropertyEffectsType} inst Instance that bas been previously bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @private
 */
function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  var nodeList = templateInfo.nodeList,
      nodeInfoList = templateInfo.nodeInfoList;

  if (nodeInfoList.length) {
    for (var i = 0; i < nodeInfoList.length; i++) {
      var info = nodeInfoList[i];
      var node = nodeList[i];
      var bindings = info.bindings;
      if (bindings) {
        for (var _i = 0; _i < bindings.length; _i++) {
          var binding = bindings[_i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}

/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @private
 */
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    var parts = binding.parts;
    // Copy literals from parts into storage for this binding
    var literals = new Array(parts.length);
    for (var j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    var target = binding.target;
    storage[target] = literals;
    // Configure properties with their literal parts
    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}

/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!PropertyEffectsType} inst Host element instance to handle notification event
 * @param {Binding} binding Binding metadata
 * @private
 */
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    var part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function (e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}

// -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @private
 */
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
  var info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo: methodInfo,
    dynamicFn: dynamicFn
  };
  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
}

/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */
function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  var context = inst._methodHost || inst;
  var fn = context[info.methodName];
  if (fn) {
    var args = marshalArgs(inst.__data, info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

var emptyArray = [];

// Regular expressions used for binding
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?'; // Group 2
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
var bindingRegex = new RegExp(EXPRESSION, "g");

/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */
function literalFromParts(parts) {
  var s = '';
  for (var i = 0; i < parts.length; i++) {
    var literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}

/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */
function parseMethod(expression) {
  // tries to match valid javascript property names
  var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    var methodName = m[1];
    var sig = { methodName: methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      var args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}

/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */
function parseArgs(argList, sig) {
  sig.args = argList.map(function (rawArg) {
    var arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}

/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */
function parseArg(rawArg) {
  // clean up whitespace
  var arg = rawArg.trim()
  // replace comma entity with comma
  .replace(/&comma;/g, ',')
  // repair extra escape sequences; note only commas strictly need
  // escaping, but we allow any other char to be escaped since its
  // likely users will do this
  .replace(/\\(.)/g, '\$1');
  // basic argument descriptor
  var a = {
    name: arg,
    value: '',
    literal: false
  };
  // detect literal value (must be String or Number)
  var fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch (fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  // if not literal, look for structured path
  if (!a.literal) {
    a.rootProperty = (0, _path.root)(arg);
    // detect structured path (has dots)
    a.structured = (0, _path.isPath)(arg);
    if (a.structured) {
      a.wildcard = arg.slice(-2) == '.*';
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}

/**
 * Gather the argument values for a method specified in the provided array
 * of argument metadata.
 *
 * The `path` and `value` arguments are used to fill in wildcard descriptor
 * when the method is being called as a result of a path notification.
 *
 * @param {Object} data Instance data storage object to read properties from
 * @param {!Array<!MethodArg>} args Array of argument metadata
 * @param {string} path Property/path name that triggered the method effect
 * @param {Object} props Bag of current property changes
 * @return {Array<*>} Array of argument values
 * @private
 */
function marshalArgs(data, args, path, props) {
  var values = [];
  for (var i = 0, l = args.length; i < l; i++) {
    var arg = args[i];
    var name = arg.name;
    var v = void 0;
    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = (0, _path.get)(data, name);
        // when data is not stored e.g. `splices`
        if (v === undefined) {
          v = props[name];
        }
      } else {
        v = data[name];
      }
    }
    if (arg.wildcard) {
      // Only send the actual path changed info if the change that
      // caused the observer to run matched the wildcard
      var baseChanged = name.indexOf(path + '.') === 0;
      var matches = path.indexOf(name) === 0 && !baseChanged;
      values[i] = {
        path: matches ? path : name,
        value: matches ? props[path] : v,
        base: v
      };
    } else {
      values[i] = v;
    }
  }
  return values;
}

// data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @private
 */
function _notifySplices(inst, array, path, splices) {
  var splicesPath = path + '.splices';
  inst.notifyPath(splicesPath, { indexSplices: splices });
  inst.notifyPath(path + '.length', array.length);
  // Null here to allow potentially large splice records to be GC'ed.
  inst.__data[splicesPath] = { indexSplices: null };
}

/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @private
 */
function notifySplice(inst, array, path, index, addedCount, removed) {
  _notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}

/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

var PropertyEffects = exports.PropertyEffects = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   */
  var propertyEffectsBase = (0, _templateStamp.TemplateStamp)((0, _propertyAccessors.PropertyAccessors)(superClass));

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */

  var PropertyEffects = function (_propertyEffectsBase) {
    _inherits(PropertyEffects, _propertyEffectsBase);

    function PropertyEffects() {
      _classCallCheck(this, PropertyEffects);

      /** @type {boolean} */
      var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

      _this.__dataClientsReady;
      /** @type {Array} */
      _this.__dataPendingClients;
      /** @type {Object} */
      _this.__dataToNotify;
      /** @type {Object} */
      _this.__dataLinkedPaths;
      /** @type {boolean} */
      _this.__dataHasPaths;
      /** @type {Object} */
      _this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */
      _this.__dataHost;
      /** @type {!Object} */
      _this.__dataTemp;
      /** @type {boolean} */
      _this.__dataClientsInitialized;
      /** @type {!Object} */
      _this.__data;
      /** @type {!Object} */
      _this.__dataPending;
      /** @type {!Object} */
      _this.__dataOld;
      /** @type {Object} */
      _this.__computeEffects;
      /** @type {Object} */
      _this.__reflectEffects;
      /** @type {Object} */
      _this.__notifyEffects;
      /** @type {Object} */
      _this.__propagateEffects;
      /** @type {Object} */
      _this.__observeEffects;
      /** @type {Object} */
      _this.__readOnly;
      /** @type {number} */
      _this.__dataCounter;
      /** @type {!TemplateInfo} */
      _this.__templateInfo;
      return _this;
    }

    _createClass(PropertyEffects, [{
      key: '_initializeProperties',
      value: function _initializeProperties() {
        _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
        hostStack.registerHost(this);
        this.__dataClientsReady = false;
        this.__dataPendingClients = null;
        this.__dataToNotify = null;
        this.__dataLinkedPaths = null;
        this.__dataHasPaths = false;
        // May be set on instance prior to upgrade
        this.__dataCompoundStorage = this.__dataCompoundStorage || null;
        this.__dataHost = this.__dataHost || null;
        this.__dataTemp = {};
        this.__dataClientsInitialized = false;
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to provide a
       * more efficient implementation of initializing properties from
       * the prototype on the instance.
       *
       * @override
       * @param {Object} props Properties to initialize on the prototype
       */

    }, {
      key: '_initializeProtoProperties',
      value: function _initializeProtoProperties(props) {
        this.__data = Object.create(props);
        this.__dataPending = Object.create(props);
        this.__dataOld = {};
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
       * `_setProperty`'s `shouldNotify: true`.
       *
       * @override
       * @param {Object} props Properties to initialize on the instance
       */

    }, {
      key: '_initializeInstanceProperties',
      value: function _initializeInstanceProperties(props) {
        var readOnly = this[TYPES.READ_ONLY];
        for (var prop in props) {
          if (!readOnly || !readOnly[prop]) {
            this.__dataPending = this.__dataPending || {};
            this.__dataOld = this.__dataOld || {};
            this.__data[prop] = this.__dataPending[prop] = props[prop];
          }
        }
      }

      // Prototype setup ----------------------------------------

      /**
       * Equivalent to static `addPropertyEffect` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_addPropertyEffect',
      value: function _addPropertyEffect(property, type, effect) {
        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
        // effects are accumulated into arrays per property based on type
        var effects = ensureOwnEffectMap(this, type)[property];
        if (!effects) {
          effects = this[type][property] = [];
        }
        effects.push(effect);
      }

      /**
       * Removes the given property effect.
       *
       * @param {string} property Property the effect was associated with
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object to remove
       */

    }, {
      key: '_removePropertyEffect',
      value: function _removePropertyEffect(property, type, effect) {
        var effects = ensureOwnEffectMap(this, type)[property];
        var idx = effects.indexOf(effect);
        if (idx >= 0) {
          effects.splice(idx, 1);
        }
      }

      /**
       * Returns whether the current prototype/instance has a property effect
       * of a certain type.
       *
       * @param {string} property Property name
       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasPropertyEffect',
      value: function _hasPropertyEffect(property, type) {
        var effects = this[type];
        return Boolean(effects && effects[property]);
      }

      /**
       * Returns whether the current prototype/instance has a "read only"
       * accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasReadOnlyEffect',
      value: function _hasReadOnlyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.READ_ONLY);
      }

      /**
       * Returns whether the current prototype/instance has a "notify"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasNotifyEffect',
      value: function _hasNotifyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.NOTIFY);
      }

      /**
       * Returns whether the current prototype/instance has a "reflect to attribute"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasReflectEffect',
      value: function _hasReflectEffect(property) {
        return this._hasPropertyEffect(property, TYPES.REFLECT);
      }

      /**
       * Returns whether the current prototype/instance has a "computed"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasComputedEffect',
      value: function _hasComputedEffect(property) {
        return this._hasPropertyEffect(property, TYPES.COMPUTE);
      }

      // Runtime ----------------------------------------

      /**
       * Sets a pending property or path.  If the root property of the path in
       * question had no accessor, the path is set, otherwise it is enqueued
       * via `_setPendingProperty`.
       *
       * This function isolates relatively expensive functionality necessary
       * for the public API (`set`, `setProperties`, `notifyPath`, and property
       * change listeners via {{...}} bindings), such that it is only done
       * when paths enter the system, and not at every propagation step.  It
       * also sets a `__dataHasPaths` flag on the instance which is used to
       * fast-path slower path-matching code in the property effects host paths.
       *
       * `path` can be a path string or array of path parts as accepted by the
       * public API.
       *
       * @param {string | !Array<number|string>} path Path to set
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify Set to true if this change should
       *  cause a property notification event dispatch
       * @param {boolean=} isPathNotification If the path being set is a path
       *   notification of an already changed value, as opposed to a request
       *   to set and notify the change.  In the latter `false` case, a dirty
       *   check is performed and then the value is set to the path before
       *   enqueuing the pending property change.
       * @return {boolean} Returns true if the property/path was enqueued in
       *   the pending changes bag.
       * @protected
       */

    }, {
      key: '_setPendingPropertyOrPath',
      value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
        if (isPathNotification || (0, _path.root)(Array.isArray(path) ? path[0] : path) !== path) {
          // Dirty check changes being set to a path against the actual object,
          // since this is the entry point for paths into the system; from here
          // the only dirty checks are against the `__dataTemp` cache to prevent
          // duplicate work in the same turn only. Note, if this was a notification
          // of a change already set to a path (isPathNotification: true),
          // we always let the change through and skip the `set` since it was
          // already dirty checked at the point of entry and the underlying
          // object has already been updated
          if (!isPathNotification) {
            var old = (0, _path.get)(this, path);
            path = /** @type {string} */(0, _path.set)(this, path, value);
            // Use property-accessor's simpler dirty check
            if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
              return false;
            }
          }
          this.__dataHasPaths = true;
          if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
            computeLinkedPaths(this, path, value);
            return true;
          }
        } else {
          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
            return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
          } else {
            this[path] = value;
          }
        }
        return false;
      }

      /**
       * Applies a value to a non-Polymer element/node's property.
       *
       * The implementation makes a best-effort at binding interop:
       * Some native element properties have side-effects when
       * re-setting the same value (e.g. setting `<input>.value` resets the
       * cursor position), so we do a dirty-check before setting the value.
       * However, for better interop with non-Polymer custom elements that
       * accept objects, we explicitly re-set object changes coming from the
       * Polymer world (which may include deep object changes without the
       * top reference changing), erring on the side of providing more
       * information.
       *
       * Users may override this method to provide alternate approaches.
       *
       * @param {Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       * @protected
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        // It is a judgment call that resetting primitives is
        // "bad" and resettings objects is also "good"; alternatively we could
        // implement a whitelist of tag & property values that should never
        // be reset (e.g. <input>.value && <select>.value)
        if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
          node[prop] = value;
        }
      }

      /**
       * Overrides the `PropertyAccessors` implementation to introduce special
       * dirty check logic depending on the property & value being set:
       *
       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
       * 2. Object set to simple property (e.g. 'prop': {...})
       *    Stored in `__dataTemp` and `__data`, dirty checked against
       *    `__dataTemp` by default implementation of `_shouldPropertyChange`
       * 3. Primitive value set to simple property (e.g. 'prop': 42)
       *    Stored in `__data`, dirty checked against `__data`
       *
       * The dirty-check is important to prevent cycles due to two-way
       * notification, but paths and objects are only dirty checked against any
       * previous value set during this turn via a "temporary cache" that is
       * cleared when the last `_propertiesChaged` exits. This is so:
       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
       *    due to array mutations like shift/unshift/splice; this is fine
       *    since path changes are dirty-checked at user entry points like `set`
       * b. dirty-checking for objects only lasts one turn to allow the user
       *    to mutate the object in-place and re-set it with the same identity
       *    and have all sub-properties re-propagated in a subsequent turn.
       *
       * The temp cache is not necessarily sufficient to prevent invalid array
       * paths, since a splice can happen during the same turn (with pathological
       * user code); we could introduce a "fixup" for temporarily cached array
       * paths if needed: https://github.com/Polymer/polymer/issues/4227
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify True if property should fire notification
       *   event (applies only for `notify: true` properties)
       * @return {boolean} Returns true if the property changed
       * @override
       */

    }, {
      key: '_setPendingProperty',
      value: function _setPendingProperty(property, value, shouldNotify) {
        var isPath = this.__dataHasPaths && (0, _path.isPath)(property);
        var prevProps = isPath ? this.__dataTemp : this.__data;
        if (this._shouldPropertyChange(property, value, prevProps[property])) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = this.__data[property];
          }
          // Paths are stored in temporary cache (cleared at end of turn),
          // which is used for dirty-checking, all others stored in __data
          if (isPath) {
            this.__dataTemp[property] = value;
          } else {
            this.__data[property] = value;
          }
          // All changes go into pending property bag, passed to _propertiesChanged
          this.__dataPending[property] = value;
          // Track properties that should notify separately
          if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
            this.__dataToNotify = this.__dataToNotify || {};
            this.__dataToNotify[property] = shouldNotify;
          }
          return true;
        }
        return false;
      }

      /**
       * Overrides base implementation to ensure all accessors set `shouldNotify`
       * to true, for per-property notification tracking.
       *
       * @override
       */

    }, {
      key: '_setProperty',
      value: function _setProperty(property, value) {
        if (this._setPendingProperty(property, value, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Overrides `PropertyAccessor`'s default async queuing of
       * `_propertiesChanged`: if `__dataReady` is false (has not yet been
       * manually flushed), the function no-ops; otherwise flushes
       * `_propertiesChanged` synchronously.
       *
       * @override
       */

    }, {
      key: '_invalidateProperties',
      value: function _invalidateProperties() {
        if (this.__dataReady) {
          this._flushProperties();
        }
      }

      /**
       * Enqueues the given client on a list of pending clients, whose
       * pending property changes can later be flushed via a call to
       * `_flushClients`.
       *
       * @param {Object} client PropertyEffects client to enqueue
       * @protected
       */

    }, {
      key: '_enqueueClient',
      value: function _enqueueClient(client) {
        this.__dataPendingClients = this.__dataPendingClients || [];
        if (client !== this) {
          this.__dataPendingClients.push(client);
        }
      }

      /**
       * Flushes any clients previously enqueued via `_enqueueClient`, causing
       * their `_flushProperties` method to run.
       *
       * @protected
       */

    }, {
      key: '_flushClients',
      value: function _flushClients() {
        if (!this.__dataClientsReady) {
          this.__dataClientsReady = true;
          this._readyClients();
          // Override point where accessors are turned on; importantly,
          // this is after clients have fully readied, providing a guarantee
          // that any property effects occur only after all clients are ready.
          this.__dataReady = true;
        } else {
          this.__enableOrFlushClients();
        }
      }

      // NOTE: We ensure clients either enable or flush as appropriate. This
      // handles two corner cases:
      // (1) clients flush properly when connected/enabled before the host
      // enables; e.g.
      //   (a) Templatize stamps with no properties and does not flush and
      //   (b) the instance is inserted into dom and
      //   (c) then the instance flushes.
      // (2) clients enable properly when not connected/enabled when the host
      // flushes; e.g.
      //   (a) a template is runtime stamped and not yet connected/enabled
      //   (b) a host sets a property, causing stamped dom to flush
      //   (c) the stamped dom enables.

    }, {
      key: '__enableOrFlushClients',
      value: function __enableOrFlushClients() {
        var clients = this.__dataPendingClients;
        if (clients) {
          this.__dataPendingClients = null;
          for (var i = 0; i < clients.length; i++) {
            var client = clients[i];
            if (!client.__dataEnabled) {
              client._enableProperties();
            } else if (client.__dataPending) {
              client._flushProperties();
            }
          }
        }
      }

      /**
       * Perform any initial setup on client dom. Called before the first
       * `_flushProperties` call on client dom and before any element
       * observers are called.
       *
       * @protected
       */

    }, {
      key: '_readyClients',
      value: function _readyClients() {
        this.__enableOrFlushClients();
      }

      /**
       * Sets a bag of property changes to this instance, and
       * synchronously processes all effects of the properties as a batch.
       *
       * Property names must be simple properties, not paths.  Batched
       * path propagation is not supported.
       *
       * @param {Object} props Bag of one or more key-value pairs whose key is
       *   a property and value is the new value to set for that property.
       * @param {boolean=} setReadOnly When true, any private values set in
       *   `props` will be set. By default, `setProperties` will not set
       *   `readOnly: true` root properties.
       * @public
       */

    }, {
      key: 'setProperties',
      value: function setProperties(props, setReadOnly) {
        for (var path in props) {
          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
            //TODO(kschaaf): explicitly disallow paths in setProperty?
            // wildcard observers currently only pass the first changed path
            // in the `info` object, and you could do some odd things batching
            // paths, e.g. {'foo.bar': {...}, 'foo': null}
            this._setPendingPropertyOrPath(path, props[path], true);
          }
        }
        this._invalidateProperties();
      }

      /**
       * Overrides `PropertyAccessors` so that property accessor
       * side effects are not enabled until after client dom is fully ready.
       * Also calls `_flushClients` callback to ensure client dom is enabled
       * that was not enabled as a result of flushing properties.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        // It is important that `super.ready()` is not called here as it
        // immediately turns on accessors. Instead, we wait until `readyClients`
        // to enable accessors to provide a guarantee that clients are ready
        // before processing any accessors side effects.
        this._flushProperties();
        // If no data was pending, `_flushProperties` will not `flushClients`
        // so ensure this is done.
        if (!this.__dataClientsReady) {
          this._flushClients();
        }
        // Before ready, client notifications do not trigger _flushProperties.
        // Therefore a flush is necessary here if data has been set.
        if (this.__dataPending) {
          this._flushProperties();
        }
      }

      /**
       * Implements `PropertyAccessors`'s properties changed callback.
       *
       * Runs each class of effects for the batch of changed properties in
       * a specific order (compute, propagate, reflect, observe, notify).
       *
       * @override
       */

    }, {
      key: '_propertiesChanged',
      value: function _propertiesChanged(currentProps, changedProps, oldProps) {
        // ----------------------------
        // let c = Object.getOwnPropertyNames(changedProps || {});
        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
        // if (window.debug) { debugger; }
        // ----------------------------
        var hasPaths = this.__dataHasPaths;
        this.__dataHasPaths = false;
        // Compute properties
        runComputedEffects(this, changedProps, oldProps, hasPaths);
        // Clear notify properties prior to possible reentry (propagate, observe),
        // but after computing effects have a chance to add to them
        var notifyProps = this.__dataToNotify;
        this.__dataToNotify = null;
        // Propagate properties to clients
        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
        // Flush clients
        this._flushClients();
        // Reflect properties
        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
        // Observe properties
        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
        // Notify properties to host
        if (notifyProps) {
          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
        }
        // Clear temporary cache at end of turn
        if (this.__dataCounter == 1) {
          this.__dataTemp = {};
        }
        // ----------------------------
        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
        // ----------------------------
      }

      /**
       * Called to propagate any property changes to stamped template nodes
       * managed by this element.
       *
       * @param {Object} changedProps Bag of changed properties
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @protected
       */

    }, {
      key: '_propagatePropertyChanges',
      value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
        if (this[TYPES.PROPAGATE]) {
          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
        }
        var templateInfo = this.__templateInfo;
        while (templateInfo) {
          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
          templateInfo = templateInfo.nextTemplateInfo;
        }
      }

      /**
       * Aliases one data path as another, such that path notifications from one
       * are routed to the other.
       *
       * @param {string | !Array<string|number>} to Target path to link.
       * @param {string | !Array<string|number>} from Source path to link.
       * @public
       */

    }, {
      key: 'linkPaths',
      value: function linkPaths(to, from) {
        to = (0, _path.normalize)(to);
        from = (0, _path.normalize)(from);
        this.__dataLinkedPaths = this.__dataLinkedPaths || {};
        this.__dataLinkedPaths[to] = from;
      }

      /**
       * Removes a data path alias previously established with `_linkPaths`.
       *
       * Note, the path to unlink should be the target (`to`) used when
       * linking the paths.
       *
       * @param {string | !Array<string|number>} path Target path to unlink.
       * @public
       */

    }, {
      key: 'unlinkPaths',
      value: function unlinkPaths(path) {
        path = (0, _path.normalize)(path);
        if (this.__dataLinkedPaths) {
          delete this.__dataLinkedPaths[path];
        }
      }

      /**
       * Notify that an array has changed.
       *
       * Example:
       *
       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
       *     ...
       *     this.items.splice(1, 1, {name: 'Sam'});
       *     this.items.push({name: 'Bob'});
       *     this.notifySplices('items', [
       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
       *     ]);
       *
       * @param {string} path Path that should be notified.
       * @param {Array} splices Array of splice records indicating ordered
       *   changes that occurred to the array. Each record should have the
       *   following fields:
       *    * index: index at which the change occurred
       *    * removed: array of items that were removed from this index
       *    * addedCount: number of new items added at this index
       *    * object: a reference to the array in question
       *    * type: the string literal 'splice'
       *
       *   Note that splice records _must_ be normalized such that they are
       *   reported in index order (raw results from `Object.observe` are not
       *   ordered and must be normalized/merged before notifying).
       * @public
      */

    }, {
      key: 'notifySplices',
      value: function notifySplices(path, splices) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        _notifySplices(this, array, info.path, splices);
      }

      /**
       * Convenience method for reading a value from a path.
       *
       * Note, if any part in the path is undefined, this method returns
       * `undefined` (this method does not throw when dereferencing undefined
       * paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `users.12.name` or `['users', 12, 'name']`).
       * @param {Object=} root Root object from which the path is evaluated.
       * @return {*} Value at the path, or `undefined` if any part of the path
       *   is undefined.
       * @public
       */

    }, {
      key: 'get',
      value: function get(path, root) {
        return (0, _path.get)(root || this, path);
      }

      /**
       * Convenience method for setting a value to a path and notifying any
       * elements bound to the same path.
       *
       * Note, if any part in the path except for the last is undefined,
       * this method does nothing (this method does not throw when
       * dereferencing undefined paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
       * @param {*} value Value to set at the specified path.
       * @param {Object=} root Root object from which the path is evaluated.
       *   When specified, no notification will occur.
       * @public
      */

    }, {
      key: 'set',
      value: function set(path, value, root) {
        if (root) {
          (0, _path.set)(root, path, value);
        } else {
          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
            if (this._setPendingPropertyOrPath(path, value, true)) {
              this._invalidateProperties();
            }
          }
        }
      }

      /**
       * Adds items onto the end of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to push onto array
       * @return {number} New length of the array.
       * @public
       */

    }, {
      key: 'push',
      value: function push(path) {
        var info = { path: '' };
        var array = /** @type {Array}*/(0, _path.get)(this, path, info);
        var len = array.length;

        for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          items[_key - 1] = arguments[_key];
        }

        var ret = array.push.apply(array, items);
        if (items.length) {
          notifySplice(this, array, info.path, len, items.length, []);
        }
        return ret;
      }

      /**
       * Removes an item from the end of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */

    }, {
      key: 'pop',
      value: function pop(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        var hadLength = Boolean(array.length);
        var ret = array.pop();
        if (hadLength) {
          notifySplice(this, array, info.path, array.length, 0, [ret]);
        }
        return ret;
      }

      /**
       * Starting from the start index specified, removes 0 or more items
       * from the array and inserts 0 or more new items in their place.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.splice`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {number} start Index from which to start removing/inserting.
       * @param {number} deleteCount Number of items to remove.
       * @param {...*} items Items to insert into array.
       * @return {Array} Array of removed items.
       * @public
       */

    }, {
      key: 'splice',
      value: function splice(path, start, deleteCount) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        // Normalize fancy native splice handling of crazy start values
        if (start < 0) {
          start = array.length - Math.floor(-start);
        } else {
          start = Math.floor(start);
        }
        if (!start) {
          start = 0;
        }

        for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          items[_key2 - 3] = arguments[_key2];
        }

        var ret = array.splice.apply(array, [start, deleteCount].concat(items));
        if (items.length || ret.length) {
          notifySplice(this, array, info.path, start, items.length, ret);
        }
        return ret;
      }

      /**
       * Removes an item from the beginning of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */

    }, {
      key: 'shift',
      value: function shift(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        var hadLength = Boolean(array.length);
        var ret = array.shift();
        if (hadLength) {
          notifySplice(this, array, info.path, 0, 0, [ret]);
        }
        return ret;
      }

      /**
       * Adds items onto the beginning of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to insert info array
       * @return {number} New length of the array.
       * @public
       */

    }, {
      key: 'unshift',
      value: function unshift(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);

        for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          items[_key3 - 1] = arguments[_key3];
        }

        var ret = array.unshift.apply(array, items);
        if (items.length) {
          notifySplice(this, array, info.path, 0, items.length, []);
        }
        return ret;
      }

      /**
       * Notify that a path has changed.
       *
       * Example:
       *
       *     this.item.user.name = 'Bob';
       *     this.notifyPath('item.user.name');
       *
       * @param {string} path Path that should be notified.
       * @param {*=} value Value at the path (optional).
       * @public
      */

    }, {
      key: 'notifyPath',
      value: function notifyPath(path, value) {
        /** @type {string} */
        var propPath = void 0;
        if (arguments.length == 1) {
          // Get value if not supplied
          var info = { path: '' };
          value = (0, _path.get)(this, path, info);
          propPath = info.path;
        } else if (Array.isArray(path)) {
          // Normalize path if needed
          propPath = (0, _path.normalize)(path);
        } else {
          propPath = /** @type{string} */path;
        }
        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Equivalent to static `createReadOnlyProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */

    }, {
      key: '_createReadOnlyProperty',
      value: function _createReadOnlyProperty(property, protectedSetter) {
        this._addPropertyEffect(property, TYPES.READ_ONLY);
        if (protectedSetter) {
          this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
            this._setProperty(property, value);
          };
        }
      }

      /**
       * Equivalent to static `createPropertyObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createPropertyObserver',
      value: function _createPropertyObserver(property, methodName, dynamicFn) {
        var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
        this._addPropertyEffect(property, TYPES.OBSERVE, {
          fn: runObserverEffect, info: info, trigger: { name: property }
        });
        if (dynamicFn) {
          this._addPropertyEffect(methodName, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: methodName }
          });
        }
      }

      /**
       * Equivalent to static `createMethodObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createMethodObserver',
      value: function _createMethodObserver(expression, dynamicFn) {
        var sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed observer expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
      }

      /**
       * Equivalent to static `createNotifyingProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: '_createNotifyingProperty',
      value: function _createNotifyingProperty(property) {
        this._addPropertyEffect(property, TYPES.NOTIFY, {
          fn: runNotifyEffect,
          info: {
            eventName: CaseMap.camelToDashCase(property) + '-changed',
            property: property
          }
        });
      }

      /**
       * Equivalent to static `createReflectedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: '_createReflectedProperty',
      value: function _createReflectedProperty(property) {
        var attr = CaseMap.camelToDashCase(property);
        if (attr[0] === '-') {
          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
        } else {
          this._addPropertyEffect(property, TYPES.REFLECT, {
            fn: runReflectEffect,
            info: {
              attrName: attr
            }
          });
        }
      }

      /**
       * Equivalent to static `createComputedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createComputedProperty',
      value: function _createComputedProperty(property, expression, dynamicFn) {
        var sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed computed expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
      }

      // -- static class methods ------------

      /**
       * Ensures an accessor exists for the specified property, and adds
       * to a list of "property effects" that will run when the accessor for
       * the specified property is set.  Effects are grouped by "type", which
       * roughly corresponds to a phase in effect processing.  The effect
       * metadata should be in the following form:
       *
       *     {
       *       fn: effectFunction, // Reference to function to call to perform effect
       *       info: { ... }       // Effect metadata passed to function
       *       trigger: {          // Optional triggering metadata; if not provided
       *         name: string      // the property is treated as a wildcard
       *         structured: boolean
       *         wildcard: boolean
       *       }
       *     }
       *
       * Effects are called from `_propertiesChanged` in the following order by
       * type:
       *
       * 1. COMPUTE
       * 2. PROPAGATE
       * 3. REFLECT
       * 4. OBSERVE
       * 5. NOTIFY
       *
       * Effect functions are called with the following signature:
       *
       *     effectFunction(inst, path, props, oldProps, info, hasPaths)
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_bindTemplate',


      // -- binding ----------------------------------------------

      /**
       * Equivalent to static `bindTemplate` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * This method may be called on the prototype (for prototypical template
       * binding, to avoid creating accessors every instance) once per prototype,
       * and will be called with `runtimeBinding: true` by `_stampTemplate` to
       * create and link an instance of the template metadata associated with a
       * particular stamping.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @param {boolean=} instanceBinding When false (default), performs
       *   "prototypical" binding of the template and overwrites any previously
       *   bound template for the class. When true (as passed from
       *   `_stampTemplate`), the template info is instanced and linked into
       *   the list of bound templates.
       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
       *   this is an instance of the prototypical template info
       * @protected
       */
      value: function _bindTemplate(template, instanceBinding) {
        var templateInfo = this.constructor._parseTemplate(template);
        var wasPreBound = this.__templateInfo == templateInfo;
        // Optimization: since this is called twice for proto-bound templates,
        // don't attempt to recreate accessors if this template was pre-bound
        if (!wasPreBound) {
          for (var prop in templateInfo.propertyEffects) {
            this._createPropertyAccessor(prop);
          }
        }
        if (instanceBinding) {
          // For instance-time binding, create instance of template metadata
          // and link into list of templates if necessary
          templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
          templateInfo.wasPreBound = wasPreBound;
          if (!wasPreBound && this.__templateInfo) {
            var last = this.__templateInfoLast || this.__templateInfo;
            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
            templateInfo.previousTemplateInfo = last;
            return templateInfo;
          }
        }
        return this.__templateInfo = templateInfo;
      }

      /**
       * Adds a property effect to the given template metadata, which is run
       * at the "propagate" stage of `_propertiesChanged` when the template
       * has been bound to the element via `_bindTemplate`.
       *
       * The `effect` object should match the format in `_addPropertyEffect`.
       *
       * @param {Object} templateInfo Template metadata to add effect to
       * @param {string} prop Property that should trigger the effect
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_stampTemplate',


      /**
       * Stamps the provided template and performs instance-time setup for
       * Polymer template features, including data bindings, declarative event
       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
       * is returned containing the stamped DOM, ready for insertion into the
       * DOM.
       *
       * This method may be called more than once; however note that due to
       * `shadycss` polyfill limitations, only styles from templates prepared
       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
       * to the shadow root and support CSS custom properties), and note that
       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
       * any styles required by in runtime-stamped templates must be included
       * in the main element template.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       * @override
       * @protected
       */
      value: function _stampTemplate(template) {
        // Ensures that created dom is `_enqueueClient`'d to this element so
        // that it can be flushed on next call to `_flushProperties`
        hostStack.beginHosting(this);
        var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
        hostStack.endHosting(this);
        var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
        // Add template-instance-specific data to instanced templateInfo
        templateInfo.nodeList = dom.nodeList;
        // Capture child nodes to allow unstamping of non-prototypical templates
        if (!templateInfo.wasPreBound) {
          var nodes = templateInfo.childNodes = [];
          for (var n = dom.firstChild; n; n = n.nextSibling) {
            nodes.push(n);
          }
        }
        dom.templateInfo = templateInfo;
        // Setup compound storage, 2-way listeners, and dataHost for bindings
        setupBindings(this, templateInfo);
        // Flush properties into template nodes if already booted
        if (this.__dataReady) {
          runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
        }
        return dom;
      }

      /**
       * Removes and unbinds the nodes previously contained in the provided
       * DocumentFragment returned from `_stampTemplate`.
       *
       * @param {!StampedTemplate} dom DocumentFragment previously returned
       *   from `_stampTemplate` associated with the nodes to be removed
       * @protected
       */

    }, {
      key: '_removeBoundDom',
      value: function _removeBoundDom(dom) {
        // Unlink template info
        var templateInfo = dom.templateInfo;
        if (templateInfo.previousTemplateInfo) {
          templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
        }
        if (templateInfo.nextTemplateInfo) {
          templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
        }
        if (this.__templateInfoLast == templateInfo) {
          this.__templateInfoLast = templateInfo.previousTemplateInfo;
        }
        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
        // Remove stamped nodes
        var nodes = templateInfo.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          node.parentNode.removeChild(node);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: 'PROPERTY_EFFECT_TYPES',
      get: function get() {
        return TYPES;
      }
    }], [{
      key: 'addPropertyEffect',
      value: function addPropertyEffect(property, type, effect) {
        this.prototype._addPropertyEffect(property, type, effect);
      }

      /**
       * Creates a single-property observer for the given property.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createPropertyObserver',
      value: function createPropertyObserver(property, methodName, dynamicFn) {
        this.prototype._createPropertyObserver(property, methodName, dynamicFn);
      }

      /**
       * Creates a multi-property "method observer" based on the provided
       * expression, which should be a string in the form of a normal Javascript
       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
       * should correspond to a property or path in the context of this
       * prototype (or instance), or may be a literal string or number.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createMethodObserver',
      value: function createMethodObserver(expression, dynamicFn) {
        this.prototype._createMethodObserver(expression, dynamicFn);
      }

      /**
       * Causes the setter for the given property to dispatch `<property>-changed`
       * events to notify of changes to the property.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: 'createNotifyingProperty',
      value: function createNotifyingProperty(property) {
        this.prototype._createNotifyingProperty(property);
      }

      /**
       * Creates a read-only accessor for the given property.
       *
       * To set the property, use the protected `_setProperty` API.
       * To create a custom protected setter (e.g. `_setMyProp()` for
       * property `myProp`), pass `true` for `protectedSetter`.
       *
       * Note, if the property will have other property effects, this method
       * should be called first, before adding other effects.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */

    }, {
      key: 'createReadOnlyProperty',
      value: function createReadOnlyProperty(property, protectedSetter) {
        this.prototype._createReadOnlyProperty(property, protectedSetter);
      }

      /**
       * Causes the setter for the given property to reflect the property value
       * to a (dash-cased) attribute of the same name.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: 'createReflectedProperty',
      value: function createReflectedProperty(property) {
        this.prototype._createReflectedProperty(property);
      }

      /**
       * Creates a computed property whose value is set to the result of the
       * method described by the given `expression` each time one or more
       * arguments to the method changes.  The expression should be a string
       * in the form of a normal Javascript function signature:
       * `'methodName(arg1, [..., argn])'`
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
       *   method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createComputedProperty',
      value: function createComputedProperty(property, expression, dynamicFn) {
        this.prototype._createComputedProperty(property, expression, dynamicFn);
      }

      /**
       * Parses the provided template to ensure binding effects are created
       * for them, and then ensures property accessors are created for any
       * dependent properties in the template.  Binding effects for bound
       * templates are stored in a linked list on the instance so that
       * templates can be efficiently stamped and unstamped.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @return {Object} Template metadata object
       * @protected
       */

    }, {
      key: 'bindTemplate',
      value: function bindTemplate(template) {
        return this.prototype._bindTemplate(template);
      }
    }, {
      key: '_addTemplatePropertyEffect',
      value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
        var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
        hostProps[prop] = true;
        var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
        var propEffects = effects[prop] = effects[prop] || [];
        propEffects.push(effect);
      }
    }, {
      key: '_parseTemplateNode',
      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
        if (node.nodeType === Node.TEXT_NODE) {
          var parts = this._parseBindings(node.textContent, templateInfo);
          if (parts) {
            // Initialize the textContent with any literal parts
            // NOTE: default to a space here so the textNode remains; some browsers
            // (IE) evacipate an empty textNode following cloneNode/importNode.
            node.textContent = literalFromParts(parts) || ' ';
            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
            noted = true;
          }
        }
        return noted;
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from attributes.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: '_parseTemplateNodeAttribute',
      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        var parts = this._parseBindings(value, templateInfo);
        if (parts) {
          // Attribute or property
          var origName = name;
          var kind = 'property';
          if (name[name.length - 1] == '$') {
            name = name.slice(0, -1);
            kind = 'attribute';
          }
          // Initialize attribute bindings with any literal parts
          var literal = literalFromParts(parts);
          if (literal && kind == 'attribute') {
            node.setAttribute(name, literal);
          }
          // Clear attribute before removing, since IE won't allow removing
          // `value` attribute if it previously had a value (can't
          // unconditionally set '' before removing since attributes with `$`
          // can't be set using setAttribute)
          if (node.localName === 'input' && origName === 'value') {
            node.setAttribute(origName, '');
          }
          // Remove annotation
          node.removeAttribute(origName);
          // Case hackery: attributes are lower-case, but bind targets
          // (properties) are case sensitive. Gambit is to map dash-case to
          // camel-case: `foo-bar` becomes `fooBar`.
          // Attribute bindings are excepted.
          if (kind === 'property') {
            name = (0, _caseMap.dashToCamelCase)(name);
          }
          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
          return true;
        } else {
          return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * binding the properties that a nested template depends on to the template
       * as `_host_<property>`.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: '_parseTemplateNestedTemplate',
      value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
        // Merge host props into outer template and add bindings
        var hostProps = nodeInfo.templateInfo.hostProps;
        var mode = '{';
        for (var source in hostProps) {
          var parts = [{ mode: mode, source: source, dependencies: [source] }];
          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
        }
        return noted;
      }

      /**
       * Called to parse text in a template (either attribute values or
       * textContent) into binding metadata.
       *
       * Any overrides of this method should return an array of binding part
       * metadata  representing one or more bindings found in the provided text
       * and any "literal" text in between.  Any non-literal parts will be passed
       * to `_evaluateBinding` when any dependencies change.  The only required
       * fields of each "part" in the returned array are as follows:
       *
       * - `dependencies` - Array containing trigger metadata for each property
       *   that should trigger the binding to update
       * - `literal` - String containing text if the part represents a literal;
       *   in this case no `dependencies` are needed
       *
       * Additional metadata for use by `_evaluateBinding` may be provided in
       * each part object as needed.
       *
       * The default implementation handles the following types of bindings
       * (one or more may be intermixed with literal strings):
       * - Property binding: `[[prop]]`
       * - Path binding: `[[object.prop]]`
       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
       * - Two-way property or path bindings (supports negation):
       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
       * - Inline computed method (supports negation):
       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
       *
       * @param {string} text Text to parse from attribute or textContent
       * @param {Object} templateInfo Current template metadata
       * @return {Array<!BindingPart>} Array of binding part metadata
       * @protected
       */

    }, {
      key: '_parseBindings',
      value: function _parseBindings(text, templateInfo) {
        var parts = [];
        var lastIndex = 0;
        var m = void 0;
        // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
        // Regex matches:
        //        Iteration 1:  Iteration 2:
        // m[1]: '{{'          '[['
        // m[2]: ''            '!'
        // m[3]: 'prop'        'compute(foo,bar)'
        while ((m = bindingRegex.exec(text)) !== null) {
          // Add literal part
          if (m.index > lastIndex) {
            parts.push({ literal: text.slice(lastIndex, m.index) });
          }
          // Add binding part
          var mode = m[1][0];
          var negate = Boolean(m[2]);
          var source = m[3].trim();
          var customEvent = false,
              notifyEvent = '',
              colon = -1;
          if (mode == '{' && (colon = source.indexOf('::')) > 0) {
            notifyEvent = source.substring(colon + 2);
            source = source.substring(0, colon);
            customEvent = true;
          }
          var signature = parseMethod(source);
          var dependencies = [];
          if (signature) {
            // Inline computed function
            var args = signature.args,
                methodName = signature.methodName;

            for (var i = 0; i < args.length; i++) {
              var arg = args[i];
              if (!arg.literal) {
                dependencies.push(arg);
              }
            }
            var dynamicFns = templateInfo.dynamicFns;
            if (dynamicFns && dynamicFns[methodName] || signature.static) {
              dependencies.push(methodName);
              signature.dynamicFn = true;
            }
          } else {
            // Property or path
            dependencies.push(source);
          }
          parts.push({
            source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
            event: notifyEvent
          });
          lastIndex = bindingRegex.lastIndex;
        }
        // Add a final literal part
        if (lastIndex && lastIndex < text.length) {
          var literal = text.substring(lastIndex);
          if (literal) {
            parts.push({
              literal: literal
            });
          }
        }
        if (parts.length) {
          return parts;
        } else {
          return null;
        }
      }

      /**
       * Called to evaluate a previously parsed binding part based on a set of
       * one or more changed dependencies.
       *
       * @param {this} inst Element that should be used as scope for
       *   binding dependencies
       * @param {BindingPart} part Binding part metadata
       * @param {string} path Property/path that triggered this effect
       * @param {Object} props Bag of current property changes
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @return {*} Value the binding part evaluated to
       * @protected
       */

    }, {
      key: '_evaluateBinding',
      value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
        var value = void 0;
        if (part.signature) {
          value = runMethodEffect(inst, path, props, oldProps, part.signature);
        } else if (path != part.source) {
          value = (0, _path.get)(inst, part.source);
        } else {
          if (hasPaths && (0, _path.isPath)(path)) {
            value = (0, _path.get)(inst, path);
          } else {
            value = inst.__data[path];
          }
        }
        if (part.negate) {
          value = !value;
        }
        return value;
      }
    }]);

    return PropertyEffects;
  }(propertyEffectsBase);

  // make a typing for closure :P


  PropertyEffectsType = PropertyEffects;

  return PropertyEffects;
});

/**
 * Helper api for enqueing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */
var hostStack = {

  stack: [],

  /**
   * @param {*} inst Instance to add to hostStack
   * @this {hostStack}
   */
  registerHost: function registerHost(inst) {
    if (this.stack.length) {
      var host = this.stack[this.stack.length - 1];
      host._enqueueClient(inst);
    }
  },


  /**
   * @param {*} inst Instance to begin hosting
   * @this {hostStack}
   */
  beginHosting: function beginHosting(inst) {
    this.stack.push(inst);
  },


  /**
   * @param {*} inst Instance to end hosting
   * @this {hostStack}
   */
  endHosting: function endHosting(inst) {
    var stackLen = this.stack.length;
    if (stackLen && this.stack[stackLen - 1] == inst) {
      this.stack.pop();
    }
  }
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
var nativeShadow = exports.nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
var nativeCssVariables = exports.nativeCssVariables = void 0;

/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */
function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    exports.nativeCssVariables = nativeCssVariables = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    exports.nativeCssVariables = nativeCssVariables = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  exports.nativeCssVariables = nativeCssVariables = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  // reset window variable to let ShadyCSS API take its place
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/



/** @unrestricted */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.stringify = stringify;
exports.removeCustomPropAssignment = removeCustomPropAssignment;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleNode = function StyleNode() {
  _classCallCheck(this, StyleNode);

  /** @type {number} */
  this['start'] = 0;
  /** @type {number} */
  this['end'] = 0;
  /** @type {StyleNode} */
  this['previous'] = null;
  /** @type {StyleNode} */
  this['parent'] = null;
  /** @type {Array<StyleNode>} */
  this['rules'] = null;
  /** @type {string} */
  this['parsedCssText'] = '';
  /** @type {string} */
  this['cssText'] = '';
  /** @type {boolean} */
  this['atRule'] = false;
  /** @type {number} */
  this['type'] = 0;
  /** @type {string} */
  this['keyframesName'] = '';
  /** @type {string} */
  this['selector'] = '';
  /** @type {string} */
  this['parsedSelector'] = '';
};

exports.StyleNode = StyleNode;

// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */

function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}

// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}

// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function lex(text) {
  var root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length;
  var n = root;
  for (var i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      var p = n;
      var previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}

// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */
function parseCss(node, text) {
  var t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    var ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax
    t = t.substring(t.lastIndexOf(';') + 1);
    var s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = s.indexOf(AT_START) === 0;
    // note, support a subset of rule types...
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  var r$ = node['rules'];
  if (r$) {
    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}

/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
    var code = arguments[1],
        repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}

/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */
function stringify(node, preserveProperties) {
  var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  // calc rule cssText
  var cssText = '';
  if (node['cssText'] || node['rules']) {
    var r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  // emit rule if there is cssText
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}

/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */
function _hasMixinRules(rules) {
  var r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
}

/** @enum {number} */
var types = exports.types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
};

var OPEN_BRACE = '{';
var CLOSE_BRACE = '}';

// helper regexp's
var RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};

var VAR_START = '--';
var MEDIA_START = '@media';
var AT_START = '@';

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

var VAR_ASSIGN = exports.VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
var MIXIN_MATCH = exports.MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
var VAR_CONSUMED = exports.VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
var ANIMATION_MATCH = exports.ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
var MEDIA_MATCH = exports.MEDIA_MATCH = /@media\s(.*)/;
var IS_VAR = exports.IS_VAR = /^--/;
var BRACKETED = exports.BRACKETED = /\{[^}]*\}/g;
var HOST_PREFIX = exports.HOST_PREFIX = '(?:^|[^.#[:])';
var HOST_SUFFIX = exports.HOST_SUFFIX = '($|[.:[\\s>+~])';

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateNativeProperties = updateNativeProperties;
exports.getComputedStyleValue = getComputedStyleValue;
exports.detectMixin = detectMixin;

var _commonRegex = __webpack_require__(39);

/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (var p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  var value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}

/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */
function detectMixin(cssText) {
  var has = _commonRegex.MIXIN_MATCH.test(cssText) || _commonRegex.VAR_ASSIGN.test(cssText);
  // reset state of the regexes
  _commonRegex.MIXIN_MATCH.lastIndex = 0;
  _commonRegex.VAR_ASSIGN.lastIndex = 0;
  return has;
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = exports.add = exports.findOriginalTarget = exports.prevent = exports._fire = exports.recognizers = exports.gestures = undefined;
exports.deepTargetFind = deepTargetFind;
exports._findOriginalTarget = _findOriginalTarget;
exports._handleNative = _handleNative;
exports._handleTouchAction = _handleTouchAction;
exports.addListener = addListener;
exports.removeListener = removeListener;
exports._add = _add;
exports._remove = _remove;
exports.register = register;
exports._findRecognizerByEvent = _findRecognizerByEvent;
exports.setTouchAction = setTouchAction;
exports.resetMouseCanceller = resetMouseCanceller;

__webpack_require__(2);

var _async = __webpack_require__(15);

var _debounce = __webpack_require__(27);

// detect native touch action support
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
// number of last N track positions to keep
var TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
var MOUSE_HAS_BUTTONS = function () {
  try {
    return new MouseEvent('test', { buttons: 1 }).buttons === 1;
  } catch (e) {
    return false;
  }
}();

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
var SUPPORTS_PASSIVE = false;
(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', { get: function get() {
        SUPPORTS_PASSIVE = true;
      } });
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch (e) {}
})();

// Check for touch-only devices
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
GestureRecognizer.prototype.reset = function () {};
/** @type {function(MouseEvent) | undefined} */
GestureRecognizer.prototype.mousedown;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mousemove;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mouseup;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchstart;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchmove;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchend;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.click;

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
var mouseCanceller = function mouseCanceller(mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  var sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  // skip synthetic mouse events
  mouseEvent[HANDLED_OBJ] = { skip: true };
  // disable "ghost clicks"
  if (mouseEvent.type === 'click') {
    var path = mouseEvent.composedPath && mouseEvent.composedPath();
    if (path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};

/**
 * @param {boolean=} setup True to add, false to remove.
 */
function setupTeardownMouseCanceller(setup) {
  var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (var i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  var unset = function unset() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = e.composedPath()[0];
  POINTERSTATE.mouse.mouseIgnoreJob = _debounce.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, _async.timeOut.after(MOUSE_TIMEOUT), unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
  var type = ev.type;
  // exit early if the event is not a mouse event
  if (MOUSE_EVENTS.indexOf(type) === -1) {
    return false;
  }
  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
  if (type === 'mousemove') {
    // allow undefined for testing events
    var buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    // buttons is a bitmask, check that the left button bit is set (1)
    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    var button = ev.button === undefined ? 0 : ev.button;
    // ev.button is 0 in mousedown/mouseup/click for left button activation
    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    }
    // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(
    var t = _findOriginalTarget(ev);
    // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click
    if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    var bcr = /** @type {Element} */t.getBoundingClientRect();
    // use page x/y to account for scrolling
    var x = ev.pageX,
        y = ev.pageY;
    // ev is a synthetic click if the position is outside the bounding box of the target
    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
  }
  return false;
}

var POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  var ta = 'auto';
  var path = ev.composedPath && ev.composedPath();
  if (path) {
    for (var i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
  }
  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

// use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

var gestures = exports.gestures = {};
var recognizers = exports.recognizers = [];

function deepTargetFind(x, y) {
  var node = document.elementFromPoint(x, y);
  var next = node;
  // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop
  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    var oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    // on Safari, elementFromPoint may return the shadowRoot host
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}

function _findOriginalTarget(ev) {
  // shadowdom
  if (ev.composedPath) {
    return (/** @type {EventTarget} */ev.composedPath()[0]
    );
  }
  // shadydom
  return ev.target;
}

function _handleNative(ev) {
  var handled = void 0;
  var type = ev.type;
  var node = ev.currentTarget;
  var gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  var gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
      var t = ev.changedTouches[0];
      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  // used to ignore synthetic mouse events
  if (handled.skip) {
    return;
  }
  // reset recognizer state
  for (var i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  // enforce gesture recognizer order
  for (var _i = 0, _r; _i < recognizers.length; _i++) {
    _r = recognizers[_i];
    if (gs[_r.name] && !handled[_r.name]) {
      handled[_r.name] = true;
      _r[type](ev);
    }
  }
}

function _handleTouchAction(ev) {
  var t = ev.changedTouches[0];
  var type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    var ta = firstTouchAction(ev);
    var _prevent = false;
    var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) {
      // scrolling is happening
    } else if (ta === 'none') {
      _prevent = true;
    } else if (ta === 'pan-x') {
      _prevent = dy > dx;
    } else if (ta === 'pan-y') {
      _prevent = dx > dy;
    }
    if (_prevent) {
      ev.preventDefault();
    } else {
      _prevent('track');
    }
  }
}

function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}

function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}

function _add(node, evType, handler) {
  var recognizer = gestures[evType];
  var deps = recognizer.deps;
  var name = recognizer.name;
  var gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (var i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    // don't add mouse handlers on iOS because they cause gray selection overlays
    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = { _count: 0 };
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative);
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}

function _remove(node, evType, handler) {
  var recognizer = gestures[evType];
  var deps = recognizer.deps;
  var name = recognizer.name;
  var gobj = node[GESTURE_KEY];
  if (gobj) {
    for (var i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative);
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}

function register(recog) {
  recognizers.push(recog);
  for (var i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}

function _findRecognizerByEvent(evName) {
  for (var i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (var j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}

function setTouchAction(node, value) {
  if (HAS_NATIVE_TA) {
    node.style.touchAction = value;
  }
  node[TOUCH_ACTION] = value;
}

function _fire2(target, type, detail) {
  var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  target.dispatchEvent(ev);
  // forward `preventDefault` in a clean way
  if (ev.defaultPrevented) {
    var preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}

exports._fire = _fire2;
function _prevent2(evName) {
  var recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}

exports.prevent = _prevent2;
function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}

/* eslint-disable valid-jsdoc */

register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],

  info: {
    movefn: null,
    upfn: null
  },

  /** @this {GestureRecognizer} */
  reset: function reset() {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = _findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        self._fire('up', t, e);
        untrackDocument(self.info);
      }
    };
    var upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        self._fire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this._fire('down', t, e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @param {string} type
   * @param {EventTarget} target
   * @param {Event} event
   * @param {Function} preventer
   */
  _fire: function _fire(type, target, event, preventer) {
    _fire2(target, type, {
      x: event.clientX,
      y: event.clientY,
      sourceEvent: event,
      preventer: preventer,
      prevent: function prevent(e) {
        return _prevent2(e);
      }
    });
  }
});

register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],

  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    /** @this {GestureRecognizer} */
    addMove: function addMove(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /** @this {GestureRecognizer} */
  reset: function reset() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  hasMovedEnough: function hasMovedEnough(x, y) {
    if (this.info.prevent) {
      return false;
    }
    if (this.info.started) {
      return true;
    }
    var dx = Math.abs(this.info.x - x);
    var dy = Math.abs(this.info.y - y);
    return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = _findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      var x = e.clientX,
          y = e.clientY;
      if (self.hasMovedEnough(x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          _prevent2('tap');
        }
        self.info.addMove({ x: x, y: y });
        if (!hasLeftMouseButton(e)) {
          // always _fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        self._fire(t, e);
        self.info.started = true;
      }
    };
    var upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }

      // remove the temporary listeners
      untrackDocument(self.info);
    };
    // add temporary document listeners as mouse retargets
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    var ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchmove: function touchmove(e) {
    var t = _findOriginalTarget(e);
    var ct = e.changedTouches[0];
    var x = ct.clientX,
        y = ct.clientY;
    if (this.hasMovedEnough(x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        _prevent2('tap');
      }
      this.info.addMove({ x: x, y: y });
      this._fire(t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    var t = _findOriginalTarget(e);
    var ct = e.changedTouches[0];
    // only trackend if track was started and not aborted
    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({ x: ct.clientX, y: ct.clientY });
      this._fire(t, ct, e);
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {EventTarget} target
   * @param {Touch} touch
   */
  _fire: function _fire(target, touch) {
    var secondlast = this.info.moves[this.info.moves.length - 2];
    var lastmove = this.info.moves[this.info.moves.length - 1];
    var dx = lastmove.x - this.info.x;
    var dy = lastmove.y - this.info.y;
    var ddx = void 0,
        ddy = 0;
    if (secondlast) {
      ddx = lastmove.x - secondlast.x;
      ddy = lastmove.y - secondlast.y;
    }
    _fire2(target, 'track', {
      state: this.info.state,
      x: touch.clientX,
      y: touch.clientY,
      dx: dx,
      dy: dy,
      ddx: ddx,
      ddy: ddy,
      sourceEvent: touch,
      hover: function hover() {
        return deepTargetFind(touch.clientX, touch.clientY);
      }
    });
  }

});

register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /** @this {GestureRecognizer} */
  reset: function reset() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /** @this {GestureRecognizer} */
  save: function save(e) {
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (hasLeftMouseButton(e)) {
      this.save(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  click: function click(e) {
    if (hasLeftMouseButton(e)) {
      this.forward(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    this.save(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    this.forward(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {Event | Touch} e
   * @param {Event=} preventer
   */
  forward: function forward(e, preventer) {
    var dx = Math.abs(e.clientX - this.info.x);
    var dy = Math.abs(e.clientY - this.info.y);
    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
    var t = _findOriginalTarget(preventer || e);
    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
    if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
      // prevent taps from being generated if an event has canceled them
      if (!this.info.prevent) {
        _fire2(t, 'tap', {
          x: e.clientX,
          y: e.clientY,
          sourceEvent: e,
          preventer: preventer
        });
      }
    }
  }
});

var findOriginalTarget = exports.findOriginalTarget = _findOriginalTarget;
var add = exports.add = addListener;
var remove = exports.remove = removeListener;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flush = exports.enqueueDebouncer = undefined;

__webpack_require__(2);

var debouncerQueue = [];

var enqueueDebouncer = exports.enqueueDebouncer = function enqueueDebouncer(debouncer) {
  debouncerQueue.push(debouncer);
};

function flushDebouncers() {
  var didFlush = Boolean(debouncerQueue.length);
  while (debouncerQueue.length) {
    try {
      debouncerQueue.shift().flush();
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }
  return didFlush;
}

var flush = exports.flush = function flush() {
  var shadyDOM = void 0,
      debouncers = void 0;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplateInstanceBase = exports.Templatize = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(2);

var _propertyEffects = __webpack_require__(36);

var _mutableData = __webpack_require__(29);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
var newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 */
function HTMLTemplateElementExtension() {
  return newInstance;
}
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 */
var DataTemplate = (0, _propertyEffects.PropertyEffects)(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 */
var MutableDataTemplate = (0, _mutableData.MutableData)(DataTemplate);

// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}

// Base class for TemplateInstance's
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 */
var base = (0, _propertyEffects.PropertyEffects)(function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  return _class;
}());

/**
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @unrestricted
 */

var TemplateInstanceBase = function (_base) {
  _inherits(TemplateInstanceBase, _base);

  function TemplateInstanceBase(props) {
    _classCallCheck(this, TemplateInstanceBase);

    var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

    _this._configureProperties(props);
    _this.root = _this._stampTemplate(_this.__dataHost);
    // Save list of stamped children
    var children = _this.children = [];
    for (var n = _this.root.firstChild; n; n = n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = _this;
    }
    if (_this.__templatizeOwner.__hideTemplateChildren__) {
      _this._showHideChildren(true);
    }
    // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.
    var options = _this.__templatizeOptions;
    if (props && options.instanceProps || !options.instanceProps) {
      _this._enableProperties();
    }
    return _this;
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   */


  _createClass(TemplateInstanceBase, [{
    key: '_configureProperties',
    value: function _configureProperties(props) {
      var options = this.__templatizeOptions;
      if (props) {
        for (var iprop in options.instanceProps) {
          if (iprop in props) {
            this._setPendingProperty(iprop, props[iprop]);
          }
        }
      }
      for (var hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
      }
    }
    /**
     * Forwards a host property to this instance.  This method should be
     * called on instances from the `options.forwardHostProp` callback
     * to propagate changes of host properties to each instance.
     *
     * Note this method enqueues the change, which are flushed as a batch.
     *
     * @param {string} prop Property or path name
     * @param {*} value Value of the property to forward
     */

  }, {
    key: 'forwardHostProp',
    value: function forwardHostProp(prop, value) {
      if (this._setPendingPropertyOrPath(prop, value, false, true)) {
        this.__dataHost._enqueueClient(this);
      }
    }
    /**
     * @override
     */

  }, {
    key: '_addEventListenerToNode',
    value: function _addEventListenerToNode(node, eventName, handler) {
      var _this2 = this;

      if (this._methodHost && this.__templatizeOptions.parentModel) {
        // If this instance should be considered a parent model, decorate
        // events this template instance as `model`
        this._methodHost._addEventListenerToNode(node, eventName, function (e) {
          e.model = _this2;
          handler(e);
        });
      } else {
        // Otherwise delegate to the template's host (which could be)
        // another template instance
        var templateHost = this.__dataHost.__dataHost;
        if (templateHost) {
          templateHost._addEventListenerToNode(node, eventName, handler);
        }
      }
    }
    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @param {boolean} hide Set to true to hide the children;
     * set to false to show them.
     * @protected
     */

  }, {
    key: '_showHideChildren',
    value: function _showHideChildren(hide) {
      var c = this.children;
      for (var i = 0; i < c.length; i++) {
        var n = c[i];
        // Ignore non-changes
        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
          if (n.nodeType === Node.TEXT_NODE) {
            if (hide) {
              n.__polymerTextContent__ = n.textContent;
              n.textContent = '';
            } else {
              n.textContent = n.__polymerTextContent__;
            }
          } else if (n.style) {
            if (hide) {
              n.__polymerDisplay__ = n.style.display;
              n.style.display = 'none';
            } else {
              n.style.display = n.__polymerDisplay__;
            }
          }
        }
        n.__hideTemplateChildren__ = hide;
        if (n._showHideChildren) {
          n._showHideChildren(hide);
        }
      }
    }
    /**
     * Overrides default property-effects implementation to intercept
     * textContent bindings while children are "hidden" and cache in
     * private storage for later retrieval.
     *
     * @override
     */

  }, {
    key: '_setUnmanagedPropertyToNode',
    value: function _setUnmanagedPropertyToNode(node, prop, value) {
      if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
        node.__polymerTextContent__ = value;
      } else {
        _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
      }
    }
    /**
     * Find the parent model of this template instance.  The parent model
     * is either another templatize instance that had option `parentModel: true`,
     * or else the host element.
     *
     * @return {Polymer_PropertyEffects} The parent model of this instance
     */

  }, {
    key: 'parentModel',
    get: function get() {
      var model = this.__parentModel;
      if (!model) {
        var options = void 0;
        model = this;
        do {
          // A template instance's `__dataHost` is a <template>
          // `model.__dataHost.__dataHost` is the template's host
          model = model.__dataHost.__dataHost;
        } while ((options = model.__templatizeOptions) && !options.parentModel);
        this.__parentModel = model;
      }
      return model;
    }
  }]);

  return TemplateInstanceBase;
}(base);

/** @type {!DataTemplate} */


TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */
TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */
TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */
TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */
TemplateInstanceBase.prototype.__hostProps;

/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 */
var MutableTemplateInstanceBase = (0, _mutableData.MutableData)(TemplateInstanceBase);

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  var templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}

/* eslint-disable valid-jsdoc */
/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function createTemplatizerClass(template, templateInfo, options) {
  // Anonymous class created by the templatize
  var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
  /**
   * @constructor
   * @extends {base}
   */
  var klass = function (_base2) {
    _inherits(klass, _base2);

    function klass() {
      _classCallCheck(this, klass);

      return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
    }

    return klass;
  }(base);
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}

/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function addPropagateEffects(template, templateInfo, options) {
  var userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp) {
    // Provide data API and property effects on memoized template class
    var klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
      klass = templateInfo.templatizeTemplateClass = function (_base4) {
        _inherits(TemplatizedTemplate, _base4);

        function TemplatizedTemplate() {
          _classCallCheck(this, TemplatizedTemplate);

          return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
        }

        return TemplatizedTemplate;
      }(_base3);
      // Add template - >instances effects
      // and host <- template effects
      var hostProps = templateInfo.hostProps;
      for (var prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
    }
    upgradeTemplate(template, klass);
    // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time
    if (template.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(template.__data, template.__dataProto);
    }
    // Clear any pending data for performance
    template.__dataTemp = {};
    template.__dataPending = null;
    template.__dataOld = null;
    template._enableProperties();
  }
}
/* eslint-enable valid-jsdoc */

function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  var hostProps = templateInfo.hostProps || {};
  for (var iprop in options.instanceProps) {
    delete hostProps[iprop];
    var userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (var hprop in hostProps) {
      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}

/**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Polymer.Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customze property forwarding and event model decoration
 *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
 *       parentModel: true,
 *       instanceProps: {...},
 *       forwardHostProp(property, value) {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 *
 * @namespace
 * @memberof Polymer
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */

var Templatize = {

  /**
   * Returns an anonymous `Polymer.PropertyEffects` class bound to the
   * `<template>` provided.  Instancing the class will result in the
   * template being stamped into document fragment stored as the instance's
   * `root` property, after which it can be appended to the DOM.
   *
   * Templates may utilize all Polymer data-binding features as well as
   * declarative event listeners.  Event listeners and inline computing
   * functions in the template will be called on the host of the template.
   *
   * The constructor returned takes a single argument dictionary of initial
   * property values to propagate into template bindings.  Additionally
   * host properties can be forwarded in, and instance properties can be
   * notified out by providing optional callbacks in the `options` dictionary.
   *
   * Valid configuration in `options` are as follows:
   *
   * - `forwardHostProp(property, value)`: Called when a property referenced
   *   in the template changed on the template's host. As this library does
   *   not retain references to templates instanced by the user, it is the
   *   templatize owner's responsibility to forward host property changes into
   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
   *    method on the generated class should be called to forward host
   *   properties into the template to prevent unnecessary property-changed
   *   notifications. Any properties referenced in the template that are not
   *   defined in `instanceProps` will be notified up to the template's host
   *   automatically.
   * - `instanceProps`: Dictionary of property names that will be added
   *   to the instance by the templatize owner.  These properties shadow any
   *   host properties, and changes within the template to these properties
   *   will result in `notifyInstanceProp` being called.
   * - `mutableData`: When `true`, the generated class will skip strict
   *   dirty-checking for objects and arrays (always consider them to be
   *   "dirty").
   * - `notifyInstanceProp(instance, property, value)`: Called when
   *   an instance property changes.  Users may choose to call `notifyPath`
   *   on e.g. the owner to notify the change.
   * - `parentModel`: When `true`, events handled by declarative event listeners
   *   (`on-event="handler"`) will be decorated with a `model` property pointing
   *   to the template instance that stamped it.  It will also be returned
   *   from `instance.parentModel` in cases where template instance nesting
   *   causes an inner model to shadow an outer model.
   *
   * Note that the class returned from `templatize` is generated only once
   * for a given `<template>` using `options` from the first call for that
   * template, and the cached class is returned for all subsequent calls to
   * `templatize` for that template.  As such, `options` callbacks should not
   * close over owner-specific properties since only the first `options` is
   * used; rather, callbacks are called bound to the `owner`, and so context
   * needed from the callbacks (such as references to `instances` stamped)
   * should be stored on the `owner` such that they can be retrieved via `this`.
   *
   * @memberof Polymer.Templatize
   * @param {!HTMLTemplateElement} template Template to templatize
   * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
   *   any optional callbacks will be bound to this owner.
   * @param {Object=} options Options dictionary (see summary for details)
   * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
   *   provided
   * @suppress {invalidCasts}
   */
  templatize: function templatize(template, owner, options) {
    options = /** @type {!TemplatizeOptions} */options || {};
    if (template.__templatizeOwner) {
      throw new Error('A <template> can only be templatized once');
    }
    template.__templatizeOwner = owner;
    var templateInfo = owner.constructor._parseTemplate(template);
    // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding
    var baseClass = templateInfo.templatizeInstanceClass;
    if (!baseClass) {
      baseClass = createTemplatizerClass(template, templateInfo, options);
      templateInfo.templatizeInstanceClass = baseClass;
    }
    // Host property forwarding must be installed onto template instance
    addPropagateEffects(template, templateInfo, options);
    // Subclass base class and add reference for this specific template
    var klass = function (_baseClass) {
      _inherits(TemplateInstance, _baseClass);

      function TemplateInstance() {
        _classCallCheck(this, TemplateInstance);

        return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
      }

      return TemplateInstance;
    }(baseClass);
    klass.prototype._methodHost = findMethodHost(template);
    klass.prototype.__dataHost = template;
    klass.prototype.__templatizeOwner = owner;
    klass.prototype.__hostProps = templateInfo.hostProps;
    return (/** @type {function(new:TemplateInstanceBase)} */klass
    );
  },


  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of
   * `TemplateInstanceBase`, and should be used to manipulate data
   * associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @memberof Polymer.Templatize
   * @param {HTMLTemplateElement} template The model will be returned for
   *   elements stamped from this template
   * @param {Node} node Node for which to return a template model.
   * @return {TemplateInstanceBase} Template instance representing the
   *   binding scope for the element
   */
  modelForElement: function modelForElement(template, node) {
    var model = void 0;
    while (node) {
      // An element with a __templatizeInstance marks the top boundary
      // of a scope; walk up until we find one, and then ensure that
      // its __dataHost matches `this`, meaning this dom-repeat stamped it
      if (model = node.__templatizeInstance) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) {
          node = model.__dataHost;
        } else {
          return model;
        }
      } else {
        // Still in a template scope, keep going up until
        // a __templatizeInstance is found
        node = node.parentNode;
      }
    }
    return null;
  }
};

exports.Templatize = Templatize;
exports.TemplateInstanceBase = TemplateInstanceBase;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomRepeat = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _templatize = __webpack_require__(43);

var _debounce = __webpack_require__(27);

var _flush = __webpack_require__(42);

var _mutableData = __webpack_require__(29);

var _path = __webpack_require__(26);

var _async = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TemplateInstanceBase = _templatize.TemplateInstanceBase; // eslint-disable-line

/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {Polymer.Element}
 */
var domRepeatBase = (0, _mutableData.OptionalMutableData)(_polymerElement.Element);

/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 *   <script>
 *     Polymer({
 *       is: 'employee-list',
 *       ready: function() {
 *         this.employees = [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *         ];
 *       }
 *     });
 *   < /script>
 *
 * </dom-module>
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
 * `unshift`), and template instances will be kept in sync with the data in the
 * array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model is an instance of Polymer.Base, and should
 * be used to manipulate data on the instance, for example
 * `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer: function(item) {
 *     return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <template is="dom-repeat" items="{{employees}}"
 *           filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @extends {domRepeatBase}
 * @appliesMixin Polymer.OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */

var DomRepeat = function (_domRepeatBase) {
  _inherits(DomRepeat, _domRepeatBase);

  _createClass(DomRepeat, null, [{
    key: 'is',


    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'dom-repeat';
    }
  }, {
    key: 'template',
    get: function get() {
      return null;
    }
  }, {
    key: 'properties',
    get: function get() {

      /**
       * Fired whenever DOM is added or removed by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */
      return {

        /**
         * An array containing items determining how many instances of the template
         * to stamp and that that each template instance should bind to.
         */
        items: {
          type: Array
        },

        /**
         * The name of the variable to add to the binding scope for the array
         * element associated with a given template instance.
         */
        as: {
          type: String,
          value: 'item'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the sorted and filtered list of rendered items.
         * Note, for the index in the `this.items` array, use the value of the
         * `itemsIndexAs` property.
         */
        indexAs: {
          type: String,
          value: 'index'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the `this.items` array. Note, for the index of
         * this instance in the sorted and filtered list of rendered items,
         * use the value of the `indexAs` property.
         */
        itemsIndexAs: {
          type: String,
          value: 'itemsIndex'
        },

        /**
         * A function that should determine the sort order of the items.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.sort`.
         * Using a sort function has no effect on the underlying `items` array.
         */
        sort: {
          type: Function,
          observer: '__sortChanged'
        },

        /**
         * A function that can be used to filter items out of the view.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.filter`.
         * Using a filter function has no effect on the underlying `items` array.
         */
        filter: {
          type: Function,
          observer: '__filterChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `observe` property
         * should be set to a space-separated list of the names of item
         * sub-fields that should trigger a re-sort or re-filter when changed.
         * These should generally be fields of `item` that the sort or filter
         * function depends on.
         */
        observe: {
          type: String,
          observer: '__observeChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `delay` property
         * determines a debounce time after a change to observed item
         * properties that must pass before the filter or sort is re-run.
         * This is useful in rate-limiting shuffing of the view when
         * item changes may be frequent.
         */
        delay: Number,

        /**
         * Count of currently rendered items after `filter` (if any) has been applied.
         * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
         * set of template instances is rendered.
         *
         */
        renderedItemCount: {
          type: Number,
          notify: true,
          readOnly: true
        },

        /**
         * Defines an initial count of template instances to render after setting
         * the `items` array, before the next paint, and puts the `dom-repeat`
         * into "chunking mode".  The remaining items will be created and rendered
         * incrementally at each animation frame therof until all instances have
         * been rendered.
         */
        initialCount: {
          type: Number,
          observer: '__initializeChunking'
        },

        /**
         * When `initialCount` is used, this property defines a frame rate to
         * target by throttling the number of instances rendered each frame to
         * not exceed the budget for the target frame rate.  Setting this to a
         * higher number will allow lower latency and higher throughput for
         * things like event handlers, but will result in a longer time for the
         * remaining items to complete rendering.
         */
        targetFramerate: {
          type: Number,
          value: 20
        },

        _targetFrameTime: {
          type: Number,
          computed: '__computeFrameTime(targetFramerate)'
        }

      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['__itemsChanged(items.*)'];
    }
  }]);

  function DomRepeat() {
    _classCallCheck(this, DomRepeat);

    var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

    _this.__instances = [];
    _this.__limit = Infinity;
    _this.__pool = [];
    _this.__renderDebouncer = null;
    _this.__itemsIdxToInstIdx = {};
    _this.__chunkCount = null;
    _this.__lastChunkTime = null;
    _this.__sortFn = null;
    _this.__filterFn = null;
    _this.__observePaths = null;
    _this.__ctor = null;
    _this.__isDetached = true;
    _this.template = null;
    return _this;
  }

  _createClass(DomRepeat, [{
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
      this.__isDetached = true;
      for (var i = 0; i < this.__instances.length; i++) {
        this.__detachInstance(i);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
      // only perform attachment if the element was previously detached.
      if (this.__isDetached) {
        this.__isDetached = false;
        var parent = this.parentNode;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__attachInstance(i, parent);
        }
      }
    }
  }, {
    key: '__ensureTemplatized',
    value: function __ensureTemplatized() {
      var _this2 = this;

      // Templatizing (generating the instance constructor) needs to wait
      // until ready, since won't have its template content handed back to
      // it until then
      if (!this.__ctor) {
        var template = this.template = this.querySelector('template');
        if (!template) {
          // // Wait until childList changes and template should be there by then
          var observer = new MutationObserver(function () {
            if (_this2.querySelector('template')) {
              observer.disconnect();
              _this2.__render();
            } else {
              throw new Error('dom-repeat requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return false;
        }
        // Template instance props that should be excluded from forwarding
        var instanceProps = {};
        instanceProps[this.as] = true;
        instanceProps[this.indexAs] = true;
        instanceProps[this.itemsIndexAs] = true;
        this.__ctor = _templatize.Templatize.templatize(template, this, {
          mutableData: this.mutableData,
          parentModel: true,
          instanceProps: instanceProps,
          /**
           * @this {this}
           * @param {string} prop Property to set
           * @param {*} value Value to set property to
           */
          forwardHostProp: function forwardHostProp(prop, value) {
            var i$ = this.__instances;
            for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
              inst.forwardHostProp(prop, value);
            }
          },
          /**
           * @this {this}
           * @param {Object} inst Instance to notify
           * @param {string} prop Property to notify
           * @param {*} value Value to notify
           */
          notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
            if ((0, _path.matches)(this.as, prop)) {
              var idx = inst[this.itemsIndexAs];
              if (prop == this.as) {
                this.items[idx] = value;
              }
              var path = (0, _path.translate)(this.as, 'items.' + idx, prop);
              this.notifyPath(path, value);
            }
          }
        });
      }
      return true;
    }
  }, {
    key: '__getMethodHost',
    value: function __getMethodHost() {
      // Technically this should be the owner of the outermost template.
      // In shadow dom, this is always getRootNode().host, but we can
      // approximate this via cooperation with our dataHost always setting
      // `_methodHost` as long as there were bindings (or id's) on this
      // instance causing it to get a dataHost.
      return this.__dataHost._methodHost || this.__dataHost;
    }
  }, {
    key: '__sortChanged',
    value: function __sortChanged(sort) {
      var methodHost = this.__getMethodHost();
      this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
        return methodHost[sort].apply(methodHost, arguments);
      });
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__filterChanged',
    value: function __filterChanged(filter) {
      var methodHost = this.__getMethodHost();
      this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
        return methodHost[filter].apply(methodHost, arguments);
      });
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__computeFrameTime',
    value: function __computeFrameTime(rate) {
      return Math.ceil(1000 / rate);
    }
  }, {
    key: '__initializeChunking',
    value: function __initializeChunking() {
      if (this.initialCount) {
        this.__limit = this.initialCount;
        this.__chunkCount = this.initialCount;
        this.__lastChunkTime = performance.now();
      }
    }
  }, {
    key: '__tryRenderChunk',
    value: function __tryRenderChunk() {
      // Debounced so that multiple calls through `_render` between animation
      // frames only queue one new rAF (e.g. array mutation & chunked render)
      if (this.items && this.__limit < this.items.length) {
        this.__debounceRender(this.__requestRenderChunk);
      }
    }
  }, {
    key: '__requestRenderChunk',
    value: function __requestRenderChunk() {
      var _this3 = this;

      requestAnimationFrame(function () {
        return _this3.__renderChunk();
      });
    }
  }, {
    key: '__renderChunk',
    value: function __renderChunk() {
      // Simple auto chunkSize throttling algorithm based on feedback loop:
      // measure actual time between frames and scale chunk count by ratio
      // of target/actual frame time
      var currChunkTime = performance.now();
      var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
      this.__limit += this.__chunkCount;
      this.__lastChunkTime = currChunkTime;
      this.__debounceRender(this.__render);
    }
  }, {
    key: '__observeChanged',
    value: function __observeChanged() {
      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
    }
  }, {
    key: '__itemsChanged',
    value: function __itemsChanged(change) {
      if (this.items && !Array.isArray(this.items)) {
        console.warn('dom-repeat expected array for `items`, found', this.items);
      }
      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
      // path to that instance synchronously (retuns false for non-item paths)
      if (!this.__handleItemPath(change.path, change.value)) {
        // Otherwise, the array was reset ('items') or spliced ('items.splices'),
        // so queue a full refresh
        this.__initializeChunking();
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__handleObservedPaths',
    value: function __handleObservedPaths(path) {
      if (this.__observePaths) {
        path = path.substring(path.indexOf('.') + 1);
        var paths = this.__observePaths;
        for (var i = 0; i < paths.length; i++) {
          if (path.indexOf(paths[i]) === 0) {
            this.__debounceRender(this.__render, this.delay);
            return true;
          }
        }
      }
    }

    /**
     * @param {function(this:DomRepeat)} fn Function to debounce.
     * @param {number=} delay Delay in ms to debounce by.
     */

  }, {
    key: '__debounceRender',
    value: function __debounceRender(fn) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? _async.timeOut.after(delay) : _async.microTask, fn.bind(this));
      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */

  }, {
    key: 'render',
    value: function render() {
      // Queue this repeater, then flush all in order
      this.__debounceRender(this.__render);
      (0, _flush.flush)();
    }
  }, {
    key: '__render',
    value: function __render() {
      if (!this.__ensureTemplatized()) {
        // No template found yet
        return;
      }
      this.__applyFullRefresh();
      // Reset the pool
      // TODO(kschaaf): Reuse pool across turns and nested templates
      // Now that objects/arrays are re-evaluated when set, we can safely
      // reuse pooled instances across turns, however we still need to decide
      // semantics regarding how long to hold, how many to hold, etc.
      this.__pool.length = 0;
      // Set rendered item count
      this._setRenderedItemCount(this.__instances.length);
      // Notify users
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      // Check to see if we need to render more items
      this.__tryRenderChunk();
    }
  }, {
    key: '__applyFullRefresh',
    value: function __applyFullRefresh() {
      var _this4 = this;

      var items = this.items || [];
      var isntIdxToItemsIdx = new Array(items.length);
      for (var i = 0; i < items.length; i++) {
        isntIdxToItemsIdx[i] = i;
      }
      // Apply user filter
      if (this.__filterFn) {
        isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
          return _this4.__filterFn(items[i], idx, array);
        });
      }
      // Apply user sort
      if (this.__sortFn) {
        isntIdxToItemsIdx.sort(function (a, b) {
          return _this4.__sortFn(items[a], items[b]);
        });
      }
      // items->inst map kept for item path forwarding
      var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
      var instIdx = 0;
      // Generate instances and assign items
      var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
      for (; instIdx < limit; instIdx++) {
        var inst = this.__instances[instIdx];
        var itemIdx = isntIdxToItemsIdx[instIdx];
        var item = items[itemIdx];
        itemsIdxToInstIdx[itemIdx] = instIdx;
        if (inst && instIdx < this.__limit) {
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          this.__insertInstance(item, instIdx, itemIdx);
        }
      }
      // Remove any extra instances from previous state
      for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
        this.__detachAndRemoveInstance(_i);
      }
    }
  }, {
    key: '__detachInstance',
    value: function __detachInstance(idx) {
      var inst = this.__instances[idx];
      for (var i = 0; i < inst.children.length; i++) {
        var el = inst.children[i];
        inst.root.appendChild(el);
      }
      return inst;
    }
  }, {
    key: '__attachInstance',
    value: function __attachInstance(idx, parent) {
      var inst = this.__instances[idx];
      parent.insertBefore(inst.root, this);
    }
  }, {
    key: '__detachAndRemoveInstance',
    value: function __detachAndRemoveInstance(idx) {
      var inst = this.__detachInstance(idx);
      if (inst) {
        this.__pool.push(inst);
      }
      this.__instances.splice(idx, 1);
    }
  }, {
    key: '__stampInstance',
    value: function __stampInstance(item, instIdx, itemIdx) {
      var model = {};
      model[this.as] = item;
      model[this.indexAs] = instIdx;
      model[this.itemsIndexAs] = itemIdx;
      return new this.__ctor(model);
    }
  }, {
    key: '__insertInstance',
    value: function __insertInstance(item, instIdx, itemIdx) {
      var inst = this.__pool.pop();
      if (inst) {
        // TODO(kschaaf): If the pool is shared across turns, hostProps
        // need to be re-set to reused instances in addition to item
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        inst = this.__stampInstance(item, instIdx, itemIdx);
      }
      var beforeRow = this.__instances[instIdx + 1];
      var beforeNode = beforeRow ? beforeRow.children[0] : this;
      this.parentNode.insertBefore(inst.root, beforeNode);
      this.__instances[instIdx] = inst;
      return inst;
    }

    // Implements extension point from Templatize mixin

  }, {
    key: '_showHideChildren',
    value: function _showHideChildren(hidden) {
      for (var i = 0; i < this.__instances.length; i++) {
        this.__instances[i]._showHideChildren(hidden);
      }
    }

    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to inst for key

  }, {
    key: '__handleItemPath',
    value: function __handleItemPath(path, value) {
      var itemsPath = path.slice(6); // 'items.'.length == 6
      var dot = itemsPath.indexOf('.');
      var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
      // If path was index into array...
      if (itemsIdx == parseInt(itemsIdx, 10)) {
        var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
        // If the path is observed, it will trigger a full refresh
        this.__handleObservedPaths(itemSubPath);
        // Note, even if a rull refresh is triggered, always do the path
        // notification because unless mutableData is used for dom-repeat
        // and all elements in the instance subtree, a full refresh may
        // not trigger the proper update.
        var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
        var inst = this.__instances[instIdx];
        if (inst) {
          var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
          // This is effectively `notifyPath`, but avoids some of the overhead
          // of the public API
          inst._setPendingPropertyOrPath(itemPath, value, false, true);
          inst._flushProperties();
        }
        return true;
      }
    }

    /**
     * Returns the item associated with a given element stamped by
     * this `dom-repeat`.
     *
     * Note, to modify sub-properties of the item,
     * `modelForElement(el).set('item.<sub-prop>', value)`
     * should be used.
     *
     * @param {HTMLElement} el Element for which to return the item.
     * @return {*} Item associated with the element.
     */

  }, {
    key: 'itemForElement',
    value: function itemForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.as];
    }

    /**
     * Returns the inst index for a given element stamped by this `dom-repeat`.
     * If `sort` is provided, the index will reflect the sorted order (rather
     * than the original array order).
     *
     * @param {HTMLElement} el Element for which to return the index.
     * @return {*} Row index associated with the element (note this may
     *   not correspond to the array index if a user `sort` is applied).
     */

  }, {
    key: 'indexForElement',
    value: function indexForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.indexAs];
    }

    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of `Polymer.Base`, and
     * should be used to manipulate data associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     */

  }, {
    key: 'modelForElement',
    value: function modelForElement(el) {
      return _templatize.Templatize.modelForElement(this.template, el);
    }
  }]);

  return DomRepeat;
}(domRepeatBase);

customElements.define(DomRepeat.is, DomRepeat);

exports.DomRepeat = DomRepeat;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperRippleBehavior = undefined;

__webpack_require__(6);

__webpack_require__(115);

var _ironButtonState = __webpack_require__(70);

var _polymerDom = __webpack_require__(17);

var PaperRippleBehavior = exports.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    _ironButtonState.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        (0, _polymerDom.dom)(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = (0, _polymerDom.dom)(this._rippleContainer || this);
        var target = (0, _polymerDom.dom)(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.layerGroup = exports.LayerGroup = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = exports.LayerGroup = _Layer.Layer.extend({

	initialize: function initialize(layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function addLayer(layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function removeLayer(layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function hasLayer(layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function clearLayers() {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function invoke(methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i,
		    layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function onAdd(map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function onRemove(map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function eachLayer(method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function getLayer(id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function getLayers() {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function setZIndex(zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function getLayerId(layer) {
		return Util.stamp(layer);
	}
});

// @factory L.layerGroup(layers?: Layer[])
// Create a layer group, optionally given an initial set of layers.
var layerGroup = exports.layerGroup = function layerGroup(layers) {
	return new LayerGroup(layers);
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CRS = undefined;

var _Bounds = __webpack_require__(8);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

var CRS = exports.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function latLngToPoint(latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function pointToLatLng(point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function project(latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function unproject(point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function scale(zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function zoom(scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function getProjectedBounds(zoom) {
		if (this.infinite) {
			return null;
		}

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return new _Bounds.Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function wrapLatLng(latlng) {
		var lng = this.wrapLng ? Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return new _LatLng.LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function wrapLatLngBounds(bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = new _LatLng.LatLng(sw.lat - latShift, sw.lng - lngShift),
		    newNe = new _LatLng.LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new _LatLngBounds.LatLngBounds(newSw, newNe);
	}
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Marker = undefined;
exports.marker = marker;

var _Layer = __webpack_require__(12);

var _Icon = __webpack_require__(78);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Marker = __webpack_require__(117);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = exports.Marker = _Layer.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new _Icon.IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false
	},

	/* @section
  *
  * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  */

	initialize: function initialize(latlng, options) {
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);
	},

	onAdd: function onAdd(map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function onRemove(map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function getEvents() {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function setLatLng(latlng) {
		var oldLatLng = this._latlng;
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', { oldLatLng: oldLatLng, latlng: this._latlng });
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function setZIndexOffset(offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function setIcon(icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function getElement() {
		return this._icon;
	},

	update: function update() {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function _initIcon() {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			DomUtil.addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;

		if (options.opacity < 1) {
			this._updateOpacity();
		}

		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function _removeIcon() {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function _removeShadow() {
		if (this._shadow) {
			DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function _setPos(pos) {
		DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function _updateZIndex(offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function _animateZoom(opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function _initInteraction() {

		if (!this.options.interactive) {
			return;
		}

		DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (_Marker.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new _Marker.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function _updateOpacity() {
		var opacity = this.options.opacity;

		DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function _bringToFront() {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function _resetZIndex() {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function _getPopupAnchor() {
		return this.options.icon.options.popupAnchor || [0, 0];
	},

	_getTooltipAnchor: function _getTooltipAnchor() {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});

// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Draggable = undefined;

var _Events = __webpack_require__(19);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Point = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};

var Draggable = exports.Draggable = _Events.Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function initialize(element, dragStartTarget, preventOutline, options) {
		Util.setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function enable() {
		if (this._enabled) {
			return;
		}

		DomEvent.on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function disable() {
		if (!this._enabled) {
			return;
		}

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		DomEvent.off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function _onDown(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}

		this._moved = false;

		if (DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) {
			return;
		}

		if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
			return;
		}
		Draggable._dragging = this; // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			DomUtil.preventOutline(this._element);
		}

		DomUtil.disableImageDrag();
		DomUtil.disableTextSelection();

		if (this._moving) {
			return;
		}

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new _Point.Point(first.clientX, first.clientY);

		DomEvent.on(document, MOVE[e.type], this._onMove, this);
		DomEvent.on(document, END[e.type], this._onUp, this);
	},

	_onMove: function _onMove(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
		    newPoint = new _Point.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) {
			return;
		}
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
			return;
		}

		DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = DomUtil.getPosition(this._element).subtract(offset);

			DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function _updatePosition() {
		var e = { originalEvent: this._lastEvent };

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function _onUp(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}
		this.finishDrag();
	},

	finishDrag: function finishDrag() {
		DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			DomEvent.off(document, MOVE[i], this._onMove, this);
			DomEvent.off(document, END[i], this._onUp, this);
		}

		DomUtil.enableImageDrag();
		DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.imageOverlay = exports.ImageOverlay = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = exports.ImageOverlay = _Layer.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the tile layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: ''
	},

	initialize: function initialize(url, bounds, options) {
		// (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		Util.setOptions(this, options);
	},

	onAdd: function onAdd() {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function onRemove() {
		DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function setStyle(styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function setUrl(url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function setBounds(bounds) {
		this._bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function getEvents() {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method: setZIndex(value: Number) : this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function setZIndex(value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function getBounds() {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function getElement() {
		return this._image;
	},

	_initImage: function _initImage() {
		var img = this._image = DomUtil.create('img', 'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : '') + (this.options.className || ''));

		img.onselectstart = Util.falseFn;
		img.onmousemove = Util.falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = Util.bind(this.fire, this, 'load');
		img.onerror = Util.bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function _animateZoom(e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function _reset() {
		var image = this._image,
		    bounds = new _Bounds.Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		DomUtil.setPosition(image, bounds.min);

		image.style.width = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function _updateOpacity() {
		DomUtil.setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function _updateZIndex() {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function _overlayOnError() {
		// @event error: Event
		// Fired when the ImageOverlay layer has loaded its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = exports.imageOverlay = function imageOverlay(url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DivOverlay = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _Point = __webpack_require__(3);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = exports.DivOverlay = _Layer.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function initialize(options, source) {
		Util.setOptions(this, options);

		this._source = source;
	},

	onAdd: function onAdd(map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function onRemove(map) {
		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(Util.bind(DomUtil.remove, undefined, this._container), 200);
		} else {
			DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function setLatLng(latlng) {
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function getContent() {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function setContent(content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function getElement() {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function update() {
		if (!this._map) {
			return;
		}

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function getEvents() {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function isOpen() {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function _updateContent() {
		if (!this._content) {
			return;
		}

		var node = this._contentNode;
		var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function _updatePosition() {
		if (!this._map) {
			return;
		}

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = (0, _Point.toPoint)(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function _getAnchor() {
		return [0, 0];
	}

});

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TileLayer = undefined;
exports.tileLayer = tileLayer;

var _GridLayer = __webpack_require__(83);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */

var TileLayer = exports.TileLayer = _GridLayer.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function initialize(url, options) {

		this._url = url;

		options = Util.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function setUrl(url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function createTile(coords, done) {
		var tile = document.createElement('img');

		DomEvent.on(tile, 'load', Util.bind(this._tileOnLoad, this, done, tile));
		DomEvent.on(tile, 'error', Util.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
   Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
   http://www.w3.org/TR/WCAG20-TECHS/H67
  */
		tile.alt = '';

		/*
   Set role="presentation" to force screen readers to ignore this
   https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
  */
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function getTileUrl(coords) {
		var data = {
			r: Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return Util.template(this._url, Util.extend(data, this.options));
	},

	_tileOnLoad: function _tileOnLoad(done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (Browser.ielt9) {
			setTimeout(Util.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function _tileOnError(done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.src !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function _onTileRemove(e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function _getZoomForUrl() {
		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom,
		    zoomReverse = this.options.zoomReverse,
		    zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function _getSubdomain(tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function _abortLoading() {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = Util.falseFn;
				tile.onerror = Util.falseFn;

				if (!tile.complete) {
					tile.src = Util.emptyImageUrl;
					DomUtil.remove(tile);
				}
			}
		}
	}
});

// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});
exports.TileLayerWMS = undefined;
exports.tileLayerWMS = tileLayerWMS;

var _TileLayer = __webpack_require__(52);

var _Util = __webpack_require__(0);

var _Browser = __webpack_require__(4);

var _CRS = __webpack_require__(54);

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = exports.TileLayerWMS = _TileLayer.TileLayer.extend({

		// @section
		// @aka TileLayer.WMS options
		// If any custom options not documented here are used, they will be sent to the
		// WMS server as extra parameters in each request URL. This can be useful for
		// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
		defaultWmsParams: {
				service: 'WMS',
				request: 'GetMap',

				// @option layers: String = ''
				// **(required)** Comma-separated list of WMS layers to show.
				layers: '',

				// @option styles: String = ''
				// Comma-separated list of WMS styles.
				styles: '',

				// @option format: String = 'image/jpeg'
				// WMS image format (use `'image/png'` for layers with transparency).
				format: 'image/jpeg',

				// @option transparent: Boolean = false
				// If `true`, the WMS service will return images with transparency.
				transparent: false,

				// @option version: String = '1.1.1'
				// Version of the WMS service to use
				version: '1.1.1'
		},

		options: {
				// @option crs: CRS = null
				// Coordinate Reference System to use for the WMS requests, defaults to
				// map CRS. Don't change this if you're not sure what it means.
				crs: null,

				// @option uppercase: Boolean = false
				// If `true`, WMS request parameter keys will be uppercase.
				uppercase: false
		},

		initialize: function initialize(url, options) {

				this._url = url;

				var wmsParams = (0, _Util.extend)({}, this.defaultWmsParams);

				// all keys that are not TileLayer options go to WMS params
				for (var i in options) {
						if (!(i in this.options)) {
								wmsParams[i] = options[i];
						}
				}

				options = (0, _Util.setOptions)(this, options);

				wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && _Browser.retina ? 2 : 1);

				this.wmsParams = wmsParams;
		},

		onAdd: function onAdd(map) {

				this._crs = this.options.crs || map.options.crs;
				this._wmsVersion = parseFloat(this.wmsParams.version);

				var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
				this.wmsParams[projectionKey] = this._crs.code;

				_TileLayer.TileLayer.prototype.onAdd.call(this, map);
		},

		getTileUrl: function getTileUrl(coords) {

				var tileBounds = this._tileCoordsToBounds(coords),
				    nw = this._crs.project(tileBounds.getNorthWest()),
				    se = this._crs.project(tileBounds.getSouthEast()),
				    bbox = (this._wmsVersion >= 1.3 && this._crs === _CRS.EPSG4326 ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(','),
				    url = _TileLayer.TileLayer.prototype.getTileUrl.call(this, coords);

				return url + (0, _Util.getParamString)(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
		},

		// @method setParams(params: Object, noRedraw?: Boolean): this
		// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
		setParams: function setParams(params, noRedraw) {

				(0, _Util.extend)(this.wmsParams, params);

				if (!noRedraw) {
						this.redraw();
				}

				return this;
		}
});

// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
		return new TileLayerWMS(url, options);
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EPSG4326 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(55);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = exports.EPSG4326 = Util.extend({}, _CRS.Earth, {
  code: 'EPSG:4326',
  projection: _Projection.LonLat,
  transformation: (0, _Transformation.toTransformation)(1 / 180, 1, -1 / 180, 0.5)
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LonLat = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = exports.LonLat = {
  project: function project(latlng) {
    return new _Point.Point(latlng.lng, latlng.lat);
  },

  unproject: function unproject(point) {
    return new _LatLng.LatLng(point.y, point.x);
  },

  bounds: new _Bounds.Bounds([-180, -90], [180, 90])
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Polyline = undefined;
exports.polyline = polyline;

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */

var Polyline = exports.Polyline = _Path.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function initialize(latlngs, options) {
		Util.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function getLatLngs() {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function setLatLngs(latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function isEmpty() {
		return !this._latlngs.length;
	},

	closestLayerPoint: function closestLayerPoint(p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = LineUtil._sqClosestPointOnSegment,
		    p1,
		    p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function getCenter() {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i,
		    halfDist,
		    segDist,
		    dist,
		    p1,
		    p2,
		    ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) {
			return null;
		}

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function getBounds() {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function addLatLng(latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = (0, _LatLng.toLatLng)(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function _setLatLngs(latlngs) {
		this._bounds = new _LatLngBounds.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function _defaultShape() {
		return LineUtil.isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function _convertLatLngs(latlngs) {
		var result = [],
		    flat = LineUtil.isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = (0, _LatLng.toLatLng)(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function _project() {
		var pxBounds = new _Bounds.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new _Point.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof _LatLng.LatLng,
		    len = latlngs.length,
		    i,
		    ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function _clipPoints() {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i,
		    j,
		    k,
		    len,
		    len2,
		    segment,
		    points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) {
					continue;
				}

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if (segment[1] !== points[j + 1] || j === len2 - 2) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function _simplifyPoints() {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function _update() {
		if (!this._map) {
			return;
		}

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function _updatePath() {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p, closed) {
		var i,
		    j,
		    k,
		    len,
		    len2,
		    part,
		    w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) {
			return false;
		}

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && j === 0) {
					continue;
				}

				if (LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = LineUtil._flat;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Polygon = undefined;
exports.polygon = polygon;

var _Polyline = __webpack_require__(56);

var _LatLng = __webpack_require__(9);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(8);

var _PolyUtil = __webpack_require__(86);

var PolyUtil = _interopRequireWildcard(_PolyUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = exports.Polygon = _Polyline.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function isEmpty() {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function getCenter() {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i,
		    j,
		    p1,
		    p2,
		    f,
		    area,
		    x,
		    y,
		    center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) {
			return null;
		}

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function _convertLatLngs(latlngs) {
		var result = _Polyline.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof _LatLng.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function _setLatLngs(latlngs) {
		_Polyline.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (LineUtil.isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function _defaultShape() {
		return LineUtil.isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function _clipPoints() {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new _Point.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new _Bounds.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function _updatePath() {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p) {
		var inside = false,
		    part,
		    p1,
		    p2,
		    i,
		    j,
		    k,
		    len,
		    len2;

		if (!this._pxBounds.contains(p)) {
			return false;
		}

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || _Polyline.Polyline.prototype._containsPoint.call(this, p, true);
	}

});

// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssFromModules = cssFromModules;
exports.cssFromModule = cssFromModule;
exports.cssFromTemplate = cssFromTemplate;
exports.cssFromModuleImports = cssFromModuleImports;
exports._cssFromModuleImports = _cssFromModuleImports;

var _resolveUrl = __webpack_require__(25);

var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
var INCLUDE_ATTR = 'include';

function importModule(moduleId) {
  var /** Polymer.DomModule */PolymerDomModule = customElements.get('dom-module');
  if (!PolymerDomModule) {
    return null;
  }
  return PolymerDomModule.import(moduleId);
}

/** @typedef {{assetpath: string}} */
var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

function cssFromModules(moduleIds) {
  var modules = moduleIds.trim().split(/\s+/);
  var cssText = '';
  for (var i = 0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }
  return cssText;
}

function cssFromModule(moduleId) {
  var m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    var cssText = _cssFromModuleImports(m);
    // include css from the first template in the module
    var t = m.querySelector('template');
    if (t) {
      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */m.assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}

function cssFromTemplate(template, baseURI) {
  var cssText = '';
  // if element is a template, get content from its .content
  var e$ = template.content.querySelectorAll('style');
  for (var i = 0; i < e$.length; i++) {
    var e = e$[i];
    // support style sharing by allowing styles to "include"
    // other dom-modules that contain styling
    var include = e.getAttribute(INCLUDE_ATTR);
    if (include) {
      cssText += cssFromModules(include);
    }
    e.parentNode.removeChild(e);
    cssText += baseURI ? (0, _resolveUrl.resolveCss)(e.textContent, baseURI) : e.textContent;
  }
  return cssText;
}

function cssFromModuleImports(moduleId) {
  var m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}

function _cssFromModuleImports(module) {
  var cssText = '';
  var p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (var i = 0; i < p$.length; i++) {
    var p = p$[i];
    if (p.import) {
      var importDoc = p.import;
      // NOTE: polyfill affordance.
      // under the HTMLImports polyfill, there will be no 'body',
      // but the import pseudo-doc can be used directly.
      var container = importDoc.body ? importDoc.body : importDoc;
      cssText += (0, _resolveUrl.resolveCss)(container.textContent, importDoc.baseURI);
    }
  }
  return cssText;
}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomModule = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _resolveUrl = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var modules = {};
var lcModules = {};
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}

/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */

var DomModule = function (_HTMLElement) {
  _inherits(DomModule, _HTMLElement);

  function DomModule() {
    _classCallCheck(this, DomModule);

    return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
  }

  _createClass(DomModule, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this.register();
      }
    }

    /**
     * The absolute URL of the original location of this `dom-module`.
     *
     * This value will differ from this element's `ownerDocument` in the
     * following ways:
     * - Takes into account any `assetpath` attribute added during bundling
     *   to indicate the original location relative to the bundled location
     * - Uses the HTMLImports polyfill's `importForElement` API to ensure
     *   the path is relative to the import document's location since
     *   `ownerDocument` is not currently polyfilled
     */

  }, {
    key: 'register',


    /**
     * Registers the dom-module at a given id. This method should only be called
     * when a dom-module is imperatively created. For
     * example, `document.createElement('dom-module').register('foo')`.
     * @param {string=} id The id at which to register the dom-module.
     */
    value: function register(id) {
      id = id || this.id;
      if (id) {
        this.id = id;
        // store id separate from lowercased id so that
        // in all cases mixedCase id will stored distinctly
        // and lowercase version is a fallback
        modules[id] = this;
        lcModules[id.toLowerCase()] = this;
        styleOutsideTemplateCheck(this);
      }
    }
  }, {
    key: 'assetpath',
    get: function get() {
      // Don't override existing assetpath.
      if (!this.__assetpath) {
        // note: assetpath set via an attribute must be relative to this
        // element's location; accomodate polyfilled HTMLImports
        var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
        var url = (0, _resolveUrl.resolveUrl)(this.getAttribute('assetpath') || '', owner.baseURI);
        this.__assetpath = (0, _resolveUrl.pathFromUrl)(url);
      }
      return this.__assetpath;
    }
  }], [{
    key: 'import',


    /**
     * Retrieves the element specified by the css `selector` in the module
     * registered by `id`. For example, this.import('foo', 'img');
     * @param {string} id The id of the dom-module in which to search.
     * @param {string=} selector The css selector by which to find the element.
     * @return {Element} Returns the element which matches `selector` in the
     * module registered at the specified `id`.
     */
    value: function _import(id, selector) {
      if (id) {
        var m = findModule(id);
        if (m && selector) {
          return m.querySelector(selector);
        }
        return m;
      }
      return null;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['id'];
    }
  }]);

  return DomModule;
}(HTMLElement);

DomModule.prototype['modules'] = modules;

customElements.define('dom-module', DomModule);

exports.DomModule = DomModule;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LegacyElementMixin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(94);

var _elementMixin = __webpack_require__(33);

var _gestureEventListeners = __webpack_require__(65);

var _mixin = __webpack_require__(13);

var _importHref = __webpack_require__(97);

__webpack_require__(66);

__webpack_require__(98);

var _polymerDom = __webpack_require__(17);

var _gestures = __webpack_require__(41);

var _debounce = __webpack_require__(27);

var _async = __webpack_require__(15);

var _path = __webpack_require__(26);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var styleInterface = window.ShadyCSS;

var LegacyElementMixin = exports.LegacyElementMixin = (0, _mixin.dedupingMixin)(function (base) {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   */
  var legacyElementBase = (0, _gestureEventListeners.GestureEventListeners)((0, _elementMixin.ElementMixin)(base));

  /**
   * Map of simple names to touch action names
   * @dict
   */
  var DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };

  /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */

  var LegacyElement = function (_legacyElementBase) {
    _inherits(LegacyElement, _legacyElementBase);

    function LegacyElement() {
      _classCallCheck(this, LegacyElement);

      var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

      _this.root = _this;
      /** @type {boolean} */
      _this.isAttached;
      /** @type {WeakMap<!Element, !Object<string, !Function>>} */
      _this.__boundListeners;
      /** @type {Object<string, Function>} */
      _this._debouncers;
      _this.created();
      return _this;
    }

    /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     */


    _createClass(LegacyElement, [{
      key: 'created',
      value: function created() {}

      /**
       * Provides an implementation of `connectedCallback`
       * which adds Polymer legacy API's `attached` method.
       * @override
       */

    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
        this.isAttached = true;
        this.attached();
      }

      /**
       * Legacy callback called during `connectedCallback`, for overriding
       * by the user.
       */

    }, {
      key: 'attached',
      value: function attached() {}

      /**
       * Provides an implementation of `disconnectedCallback`
       * which adds Polymer legacy API's `detached` method.
       * @override
       */

    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
        this.isAttached = false;
        this.detached();
      }

      /**
       * Legacy callback called during `disconnectedCallback`, for overriding
       * by the user.
       */

    }, {
      key: 'detached',
      value: function detached() {}

      /**
       * Provides an override implementation of `attributeChangedCallback`
       * which adds the Polymer legacy API's `attributeChanged` method.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @override
       */

    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
          this.attributeChanged(name, old, value);
        }
      }

      /**
       * Legacy callback called during `attributeChangedChallback`, for overriding
       * by the user.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       */

    }, {
      key: 'attributeChanged',
      value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for class initialization via the `_registered` callback.
       * This is called only when the first instance of the element is created.
       *
       * @override
       */

    }, {
      key: '_initializeProperties',
      value: function _initializeProperties() {
        var proto = Object.getPrototypeOf(this);
        if (!proto.hasOwnProperty('__hasRegisterFinished')) {
          proto.__hasRegisterFinished = true;
          this._registered();
        }
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
      }

      /**
       * Called automatically when an element is initializing.
       * Users may override this method to perform class registration time
       * work. The implementation should ensure the work is performed
       * only once for the class.
       * @protected
       */

    }, {
      key: '_registered',
      value: function _registered() {}

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for installing `hostAttributes` and `listeners`.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        this._ensureAttributes();
        this._applyListeners();
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
      }

      /**
       * Ensures an element has required attributes. Called when the element
       * is being readied via `ready`. Users should override to set the
       * element's required attributes. The implementation should be sure
       * to check and not override existing attributes added by
       * the user of the element. Typically, setting attributes should be left
       * to the element user and not done here; reasonable exceptions include
       * setting aria roles and focusability.
       * @protected
       */

    }, {
      key: '_ensureAttributes',
      value: function _ensureAttributes() {}

      /**
       * Adds element event listeners. Called when the element
       * is being readied via `ready`. Users should override to
       * add any required element event listeners.
       * In performance critical elements, the work done here should be kept
       * to a minimum since it is done before the element is rendered. In
       * these elements, consider adding listeners asychronously so as not to
       * block render.
       * @protected
       */

    }, {
      key: '_applyListeners',
      value: function _applyListeners() {}

      /**
       * Converts a typed JavaScript value to a string.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features. To customize
       * how properties are serialized to attributes for attribute bindings and
       * `reflectToAttribute: true` properties as well as this method, override
       * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
       *
       * @param {*} value Value to deserialize
       * @return {string | undefined} Serialized value
       */

    }, {
      key: 'serialize',
      value: function serialize(value) {
        return this._serializeValue(value);
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.  To customize
       * how attributes are deserialized to properties for in
       * `attributeChangedCallback`, override `_deserializeValue` method
       * provided by `Polymer.PropertyAccessors`.
       *
       * @param {string} value String to deserialize
       * @param {*} type Type to deserialize the string to
       * @return {*} Returns the deserialized value in the `type` given.
       */

    }, {
      key: 'deserialize',
      value: function deserialize(value, type) {
        return this._deserializeValue(value, type);
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */

    }, {
      key: 'reflectPropertyToAttribute',
      value: function reflectPropertyToAttribute(property, attribute, value) {
        this._propertyToAttribute(property, attribute, value);
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @param {Element} node Element to set attribute to.
       */

    }, {
      key: 'serializeValueToAttribute',
      value: function serializeValueToAttribute(value, attribute, node) {
        this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
      }

      /**
       * Copies own properties (including accessor descriptors) from a source
       * object to a target object.
       *
       * @param {Object} prototype Target object to copy properties to.
       * @param {Object} api Source object to copy properties from.
       * @return {Object} prototype object that was passed as first argument.
       */

    }, {
      key: 'extend',
      value: function extend(prototype, api) {
        if (!(prototype && api)) {
          return prototype || api;
        }
        var n$ = Object.getOwnPropertyNames(api);
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
          var pd = Object.getOwnPropertyDescriptor(api, n);
          if (pd) {
            Object.defineProperty(prototype, n, pd);
          }
        }
        return prototype;
      }

      /**
       * Copies props from a source object to a target object.
       *
       * Note, this method uses a simple `for...in` strategy for enumerating
       * properties.  To ensure only `ownProperties` are copied from source
       * to target and that accessor implementations are copied, use `extend`.
       *
       * @param {Object} target Target object to copy properties to.
       * @param {Object} source Source object to copy properties from.
       * @return {Object} Target object that was passed as first argument.
       */

    }, {
      key: 'mixin',
      value: function mixin(target, source) {
        for (var i in source) {
          target[i] = source[i];
        }
        return target;
      }

      /**
       * Sets the prototype of an object.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       * @param {Object} object The object on which to set the prototype.
       * @param {Object} prototype The prototype that will be set on the given
       * `object`.
       * @return {Object} Returns the given `object` with its prototype set
       * to the given `prototype` object.
       */

    }, {
      key: 'chainObject',
      value: function chainObject(object, prototype) {
        if (object && prototype && object !== prototype) {
          object.__proto__ = prototype;
        }
        return object;
      }

      /* **** Begin Template **** */

      /**
       * Calls `importNode` on the `content` of the `template` specified and
       * returns a document fragment containing the imported content.
       *
       * @param {HTMLTemplateElement} template HTML template element to instance.
       * @return {DocumentFragment} Document fragment containing the imported
       *   template content.
      */

    }, {
      key: 'instanceTemplate',
      value: function instanceTemplate(template) {
        var content = this.constructor._contentForTemplate(template);
        var dom = /** @type {DocumentFragment} */
        document.importNode(content, true);
        return dom;
      }

      /* **** Begin Events **** */

      /**
       * Dispatches a custom event with an optional detail value.
       *
       * @param {string} type Name of event type.
       * @param {*=} detail Detail value containing event-specific
       *   payload.
       * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
       *  options Object specifying options.  These may include:
       *  `bubbles` (boolean, defaults to `true`),
       *  `cancelable` (boolean, defaults to false), and
       *  `node` on which to fire the event (HTMLElement, defaults to `this`).
       * @return {Event} The new event that was fired.
       */

    }, {
      key: 'fire',
      value: function fire(type, detail, options) {
        options = options || {};
        detail = detail === null || detail === undefined ? {} : detail;
        var event = new Event(type, {
          bubbles: options.bubbles === undefined ? true : options.bubbles,
          cancelable: Boolean(options.cancelable),
          composed: options.composed === undefined ? true : options.composed
        });
        event.detail = detail;
        var node = options.node || this;
        node.dispatchEvent(event);
        return event;
      }

      /**
       * Convenience method to add an event listener on a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to add event listener to.
       * @param {string} eventName Name of event to listen for.
       * @param {string} methodName Name of handler method on `this` to call.
       */

    }, {
      key: 'listen',
      value: function listen(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
        var bl = hbl.get(node);
        if (!bl) {
          bl = {};
          hbl.set(node, bl);
        }
        var key = eventName + methodName;
        if (!bl[key]) {
          bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
        }
      }

      /**
       * Convenience method to remove an event listener from a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to remove event listener from.
       * @param {string} eventName Name of event to stop listening to.
       * @param {string} methodName Name of handler method on `this` to not call
       anymore.
       */

    }, {
      key: 'unlisten',
      value: function unlisten(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        var bl = this.__boundListeners && this.__boundListeners.get(node);
        var key = eventName + methodName;
        var handler = bl && bl[key];
        if (handler) {
          this._removeEventListenerFromNode(node, eventName, handler);
          bl[key] = null;
        }
      }

      /**
       * Override scrolling behavior to all direction, one direction, or none.
       *
       * Valid scroll directions:
       *   - 'all': scroll in any direction
       *   - 'x': scroll only in the 'x' direction
       *   - 'y': scroll only in the 'y' direction
       *   - 'none': disable scrolling for this node
       *
       * @param {string=} direction Direction to allow scrolling
       * Defaults to `all`.
       * @param {Element=} node Element to apply scroll direction setting.
       * Defaults to `this`.
       */

    }, {
      key: 'setScrollDirection',
      value: function setScrollDirection(direction, node) {
        (0, _gestures.setTouchAction)(node || this, DIRECTION_MAP[direction] || 'auto');
      }
      /* **** End Events **** */

      /**
       * Convenience method to run `querySelector` on this local DOM scope.
       *
       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
       *
       * @param {string} slctr Selector to run on this local DOM scope
       * @return {Element} Element found by the selector, or null if not found.
       */

    }, {
      key: '$$',
      value: function $$(slctr) {
        return this.root.querySelector(slctr);
      }

      /**
       * Return the element whose local dom within which this element
       * is contained. This is a shorthand for
       * `this.getRootNode().host`.
       * @this {Element}
       */

    }, {
      key: 'distributeContent',


      /**
       * Force this element to distribute its children to its local dom.
       * This should not be necessary as of Polymer 2.0.2 and is provided only
       * for backwards compatibility.
       */
      value: function distributeContent() {
        if (window.ShadyDOM && this.shadowRoot) {
          ShadyDOM.flush();
        }
      }

      /**
       * Returns a list of nodes that are the effective childNodes. The effective
       * childNodes list is the same as the element's childNodes except that
       * any `<content>` elements are replaced with the list of nodes distributed
       * to the `<content>`, the result of its `getDistributedNodes` method.
       * @this {Element}
       * @return {Array<Node>} List of effctive child nodes.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return (
          /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(this).getEffectiveChildNodes()
        );
      }

      /**
       * Returns a list of nodes distributed within this element that match
       * `selector`. These can be dom children or elements distributed to
       * children that are insertion points.
       * @param {string} selector Selector to run.
       * @this {Element}
       * @return {Array<Node>} List of distributed elements that match selector.
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        return (
          /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(this).queryDistributedElements(selector)
        );
      }

      /**
       * Returns a list of elements that are the effective children. The effective
       * children list is the same as the element's children except that
       * any `<content>` elements are replaced with the list of elements
       * distributed to the `<content>`.
       *
       * @return {Array<Node>} List of effctive children.
       */

    }, {
      key: 'getEffectiveChildren',
      value: function getEffectiveChildren() {
        var list = this.getEffectiveChildNodes();
        return list.filter(function ( /** @type {Node} */n) {
          return n.nodeType === Node.ELEMENT_NODE;
        });
      }

      /**
       * Returns a string of text content that is the concatenation of the
       * text content's of the element's effective childNodes (the elements
       * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
       *
       * @return {string} List of effctive children.
       */

    }, {
      key: 'getEffectiveTextContent',
      value: function getEffectiveTextContent() {
        var cn = this.getEffectiveChildNodes();
        var tc = [];
        for (var i = 0, c; c = cn[i]; i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      }

      /**
       * Returns the first effective childNode within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {Object<Node>} First effective child node that matches selector.
       */

    }, {
      key: 'queryEffectiveChildren',
      value: function queryEffectiveChildren(selector) {
        var e$ = this.queryDistributedElements(selector);
        return e$ && e$[0];
      }

      /**
       * Returns a list of effective childNodes within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {Array<Node>} List of effective child nodes that match selector.
       */

    }, {
      key: 'queryAllEffectiveChildren',
      value: function queryAllEffectiveChildren(selector) {
        return this.queryDistributedElements(selector);
      }

      /**
       * Returns a list of nodes distributed to this element's `<slot>`.
       *
       * If this element contains more than one `<slot>` in its local DOM,
       * an optional selector may be passed to choose the desired content.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<slot>`.  Defaults to `content`.
       * @return {Array<Node>} List of distributed nodes for the `<slot>`.
       */

    }, {
      key: 'getContentChildNodes',
      value: function getContentChildNodes(slctr) {
        var content = this.root.querySelector(slctr || 'slot');
        return content ? /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(content).getDistributedNodes() : [];
      }

      /**
       * Returns a list of element children distributed to this element's
       * `<slot>`.
       *
       * If this element contains more than one `<slot>` in its
       * local DOM, an optional selector may be passed to choose the desired
       * content.  This method differs from `getContentChildNodes` in that only
       * elements are returned.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<HTMLElement>} List of distributed nodes for the
       *   `<slot>`.
       * @suppress {invalidCasts}
       */

    }, {
      key: 'getContentChildren',
      value: function getContentChildren(slctr) {
        return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
            return n.nodeType === Node.ELEMENT_NODE;
          })
        );
      }

      /**
       * Checks whether an element is in this element's light DOM tree.
       *
       * @param {?Node} node The element to be checked.
       * @this {Element}
       * @return {boolean} true if node is in this element's light DOM tree.
       */

    }, {
      key: 'isLightDescendant',
      value: function isLightDescendant(node) {
        return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
      }

      /**
       * Checks whether an element is in this element's local DOM tree.
       *
       * @param {Element=} node The element to be checked.
       * @return {boolean} true if node is in this element's local DOM tree.
       */

    }, {
      key: 'isLocalDescendant',
      value: function isLocalDescendant(node) {
        return this.root === node.getRootNode();
      }

      // NOTE: should now be handled by ShadyCss library.

    }, {
      key: 'scopeSubtree',
      value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


      /**
       * Returns the computed style value for the given property.
       * @param {string} property The css property name.
       * @return {string} Returns the computed css property value for the given
       * `property`.
       */

    }, {
      key: 'getComputedStyleValue',
      value: function getComputedStyleValue(property) {
        return styleInterface.getComputedStyleValue(this, property);
      }

      // debounce

      /**
       * Call `debounce` to collapse multiple requests for a named task into
       * one invocation which is made after the wait time has elapsed with
       * no new request.  If no wait time is given, the callback will be called
       * at microtask timing (guaranteed before paint).
       *
       *     debouncedClickAction(e) {
       *       // will not call `processClick` more than once per 100ms
       *       this.debounce('click', function() {
       *        this.processClick();
       *       } 100);
       *     }
       *
       * @param {string} jobName String to indentify the debounce job.
       * @param {function()} callback Function that is called (with `this`
       *   context) when the wait time elapses.
       * @param {number} wait Optional wait time in milliseconds (ms) after the
       *   last signal that must elapse before invoking `callback`
       * @return {Object} Returns a debouncer object on which exists the
       * following methods: `isActive()` returns true if the debouncer is
       * active; `cancel()` cancels the debouncer if it is active;
       * `flush()` immediately invokes the debounced callback if the debouncer
       * is active.
       */

    }, {
      key: 'debounce',
      value: function debounce(jobName, callback, wait) {
        this._debouncers = this._debouncers || {};
        return this._debouncers[jobName] = _debounce.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? _async.timeOut.after(wait) : _async.microTask, callback.bind(this));
      }

      /**
       * Returns whether a named debouncer is active.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       * @return {boolean} Whether the debouncer is active (has not yet fired).
       */

    }, {
      key: 'isDebouncerActive',
      value: function isDebouncerActive(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.isActive());
      }

      /**
       * Immediately calls the debouncer `callback` and inactivates it.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       */

    }, {
      key: 'flushDebouncer',
      value: function flushDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.flush();
        }
      }

      /**
       * Cancels an active debouncer.  The `callback` will not be called.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       */

    }, {
      key: 'cancelDebouncer',
      value: function cancelDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.cancel();
        }
      }

      /**
       * Runs a callback function asyncronously.
       *
       * By default (if no waitTime is specified), async callbacks are run at
       * microtask timing, which will occur before paint.
       *
       * @param {Function} callback The callback function to run, bound to `this`.
       * @param {number=} waitTime Time to wait before calling the
       *   `callback`.  If unspecified or 0, the callback will be run at microtask
       *   timing (before paint).
       * @return {number} Handle that may be used to cancel the async job.
       */

    }, {
      key: 'async',
      value: function async(callback, waitTime) {
        return waitTime > 0 ? _async.timeOut.run(callback.bind(this), waitTime) : ~_async.microTask.run(callback.bind(this));
      }

      /**
       * Cancels an async operation started with `async`.
       *
       * @param {number} handle Handle returned from original `async` call to
       *   cancel.
       */

    }, {
      key: 'cancelAsync',
      value: function cancelAsync(handle) {
        handle < 0 ? _async.microTask.cancel(~handle) : _async.timeOut.cancel(handle);
      }

      // other

      /**
       * Convenience method for creating an element and configuring it.
       *
       * @param {string} tag HTML element tag to create.
       * @param {Object} props Object of properties to configure on the
       *    instance.
       * @return {Element} Newly created and configured element.
       */

    }, {
      key: 'create',
      value: function create(tag, props) {
        var elt = document.createElement(tag);
        if (props) {
          if (elt.setProperties) {
            elt.setProperties(props);
          } else {
            for (var n in props) {
              elt[n] = props[n];
            }
          }
        }
        return elt;
      }

      /**
       * Convenience method for importing an HTML document imperatively.
       *
       * This method creates a new `<link rel="import">` element with
       * the provided URL and appends it to the document to start loading.
       * In the `onload` callback, the `import` property of the `link`
       * element will contain the imported document contents.
       *
       * @param {string} href URL to document to load.
       * @param {Function} onload Callback to notify when an import successfully
       *   loaded.
       * @param {Function} onerror Callback to notify when an import
       *   unsuccessfully loaded.
       * @param {boolean} optAsync True if the import should be loaded `async`.
       *   Defaults to `false`.
       * @return {HTMLLinkElement} The link element for the URL to be loaded.
       */

    }, {
      key: 'importHref',
      value: function importHref(href, onload, onerror, optAsync) {
        // eslint-disable-line no-unused-vars
        var loadFn = onload ? onload.bind(this) : null;
        var errorFn = onerror ? onerror.bind(this) : null;
        return (0, _importHref.importHref)(href, loadFn, errorFn, optAsync);
      }

      /**
       * Polyfill for Element.prototype.matches, which is sometimes still
       * prefixed.
       *
       * @param {string} selector Selector to test.
       * @param {Element=} node Element to test the selector against.
       * @return {boolean} Whether the element matches the selector.
       */

    }, {
      key: 'elementMatches',
      value: function elementMatches(selector, node) {
        return (0, _polymerDom.matchesSelector)(node || this, selector);
      }

      /**
       * Toggles an HTML attribute on or off.
       *
       * @param {string} name HTML attribute name
       * @param {boolean=} bool Boolean to force the attribute on or off.
       *    When unspecified, the state of the attribute will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       */

    }, {
      key: 'toggleAttribute',
      value: function toggleAttribute(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.hasAttribute(name);
        }
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      }

      /**
       * Toggles a CSS class on or off.
       *
       * @param {string} name CSS class name
       * @param {boolean=} bool Boolean to force the class on or off.
       *    When unspecified, the state of the class will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       */

    }, {
      key: 'toggleClass',
      value: function toggleClass(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.classList.contains(name);
        }
        if (bool) {
          node.classList.add(name);
        } else {
          node.classList.remove(name);
        }
      }

      /**
       * Cross-platform helper for setting an element's CSS `transform` property.
       *
       * @param {string} transformText Transform setting.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`
       */

    }, {
      key: 'transform',
      value: function transform(transformText, node) {
        node = /** @type {Element} */node || this;
        node.style.webkitTransform = transformText;
        node.style.transform = transformText;
      }

      /**
       * Cross-platform helper for setting an element's CSS `translate3d`
       * property.
       *
       * @param {number} x X offset.
       * @param {number} y Y offset.
       * @param {number} z Z offset.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`.
       */

    }, {
      key: 'translate3d',
      value: function translate3d(x, y, z, node) {
        node = /** @type {Element} */node || this;
        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
      }

      /**
       * Removes an item from an array, if it exists.
       *
       * If the array is specified by path, a change notification is
       * generated, so that observers, data bindings and computed
       * properties watching that path can update.
       *
       * If the array is passed directly, **no change
       * notification is generated**.
       *
       * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
       *   (or the array itself).
       * @param {*} item Item to remove.
       * @return {Array} Array containing item removed.
       */

    }, {
      key: 'arrayDelete',
      value: function arrayDelete(arrayOrPath, item) {
        var index = void 0;
        if (Array.isArray(arrayOrPath)) {
          index = arrayOrPath.indexOf(item);
          if (index >= 0) {
            return arrayOrPath.splice(index, 1);
          }
        } else {
          var arr = (0, _path.get)(this, arrayOrPath);
          index = arr.indexOf(item);
          if (index >= 0) {
            return this.splice(arrayOrPath, index, 1);
          }
        }
        return null;
      }

      // logging

      /**
       * Facades `console.log`/`warn`/`error` as override point.
       *
       * @param {string} level One of 'log', 'warn', 'error'
       * @param {Array} args Array of strings or objects to log
       */

    }, {
      key: '_logger',
      value: function _logger(level, args) {
        var _console;

        // accept ['foo', 'bar'] and [['foo', 'bar']]
        if (Array.isArray(args) && args.length === 1) {
          args = args[0];
        }
        switch (level) {
          case 'log':
          case 'warn':
          case 'error':
            (_console = console)[level].apply(_console, _toConsumableArray(args));
        }
      }

      /**
       * Facades `console.log` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_log',
      value: function _log() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        this._logger('log', args);
      }

      /**
       * Facades `console.warn` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_warn',
      value: function _warn() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        this._logger('warn', args);
      }

      /**
       * Facades `console.error` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_error',
      value: function _error() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        this._logger('error', args);
      }

      /**
       * Formats a message using the element type an a method name.
       *
       * @param {string} methodName Method name to associate with message
       * @param {...*} args Array of strings or objects to log
       * @return {Array} Array with formatting information for `console`
       *   logging.
       */

    }, {
      key: '_logf',
      value: function _logf(methodName) {
        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        return ['[%s::%s]', this.is, methodName].concat(args);
      }
    }, {
      key: 'domHost',
      get: function get() {
        var root = this.getRootNode();
        return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
      }
    }]);

    return LegacyElement;
  }(legacyElementBase);

  LegacyElement.prototype.is = '';

  return LegacyElement;
});

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toCssText = toCssText;
exports.rulesForStyle = rulesForStyle;
exports.isKeyframesSelector = isKeyframesSelector;
exports.forEachRule = forEachRule;
exports.applyCss = applyCss;
exports.createScopeStyle = createScopeStyle;
exports.applyStylePlaceHolder = applyStylePlaceHolder;
exports.applyStyle = applyStyle;
exports.isTargetedBuild = isTargetedBuild;
exports.getCssBuildType = getCssBuildType;
exports.processVariableAndFallback = processVariableAndFallback;
exports.setElementClassRaw = setElementClassRaw;
exports.getIsExtends = getIsExtends;

var _styleSettings = __webpack_require__(37);

var _cssParse = __webpack_require__(38);

var _commonRegex = __webpack_require__(39);

/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */
function toCssText(rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = (0, _cssParse.parse)(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return (0, _cssParse.stringify)(rules, _styleSettings.nativeCssVariables);
}

/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */
// eslint-disable-line no-unused-vars
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = (0, _cssParse.parse)(style.textContent);
  }
  return style['__cssRules'] || null;
}

// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */
function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) && rule['parent']['type'] === _cssParse.types.KEYFRAMES_RULE;
}

/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  var skipRules = false;
  var type = node['type'];
  if (onlyActiveRules) {
    if (type === _cssParse.types.MEDIA_RULE) {
      var matchMedia = node['selector'].match(_commonRegex.MEDIA_MATCH);
      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === _cssParse.types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === _cssParse.types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === _cssParse.types.MIXIN_RULE) {
    skipRules = true;
  }
  var r$ = node['rules'];
  if (r$ && !skipRules) {
    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}

// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */
function applyCss(cssText, moniker, target, contextNode) {
  var style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}

/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */
function createScopeStyle(cssText, moniker) {
  var style = /** @type {HTMLStyleElement} */document.createElement('style');
  if (moniker) {
    style.setAttribute('scope', moniker);
  }
  style.textContent = cssText;
  return style;
}

/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */
var lastHeadApplyNode = null;

// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {!Comment}
 */
function applyStylePlaceHolder(moniker) {
  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
  var after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;
  var scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}

/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */
function applyStyle(style, target, contextNode) {
  target = target || document.head;
  var after = contextNode && contextNode.nextSibling || target.firstChild;
  target.insertBefore(style, after);
  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    var position = style.compareDocumentPosition(lastHeadApplyNode);
    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}

/**
 * @param {string} buildType
 * @return {boolean}
 */
function isTargetedBuild(buildType) {
  return _styleSettings.nativeShadow ? buildType === 'shadow' : buildType === 'shady';
}

/**
 * @param {Element} element
 * @return {?string}
 */
function getCssBuildType(element) {
  return element.getAttribute('css-build');
}

/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */
function findMatchingParen(text, start) {
  var level = 0;
  for (var i = start, l = text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */
function processVariableAndFallback(str, callback) {
  // find 'var('
  var start = str.indexOf('var(');
  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  }
  //${prefix}var(${inner})${suffix}
  var end = findMatchingParen(str, start + 3);
  var inner = str.substring(start + 4, end);
  var prefix = str.substring(0, start);
  // suffix may have other variables
  var suffix = processVariableAndFallback(str.substring(end + 1), callback);
  var comma = inner.indexOf(',');
  // value and fallback args should be trimmed to match in property lookup
  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  }
  // var(${value},${fallback})
  var value = inner.substring(0, comma).trim();
  var fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}

/**
 * @param {Element} element
 * @param {string} value
 */
function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (_styleSettings.nativeShadow) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}

/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */
function getIsExtends(element) {
  var localName = element['localName'];
  var is = '',
      typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = element.getAttribute && element.getAttribute('is') || '';
    }
  } else {
    is = /** @type {?} */element.is;
    typeExtension = /** @type {?} */element.extends;
  }
  return { is: is, typeExtension: typeExtension };
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var templateMap = {};
exports.default = templateMap;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {Promise<void>} */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = documentWait;
var readyPromise = null;

/** @type {?function(?function())} */
var whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
var resolveFn = void 0;

/**
 * @param {?function()} callback
 */
function documentWait(callback) {
  requestAnimationFrame(function () {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise(function (resolve) {
          resolveFn = resolve;
        });
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', function () {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function () {
        callback && callback();
      });
    }
  });
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStyleInterfaceInterface = exports.CustomStyleProvider = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _documentWait = __webpack_require__(63);

var _documentWait2 = _interopRequireDefault(_documentWait);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
 */
var CustomStyleProvider = exports.CustomStyleProvider = void 0;

var SEEN_MARKER = '__seenByShadyCSS';
var CACHED_STYLE = '__shadyCSSCachedStyle';

/** @type {?function(!HTMLStyleElement)} */
var transformFn = null;

/** @type {?function()} */
var validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/

var CustomStyleInterface = function () {
  function CustomStyleInterface() {
    _classCallCheck(this, CustomStyleInterface);

    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */


  _createClass(CustomStyleInterface, [{
    key: 'enqueueDocumentValidation',
    value: function enqueueDocumentValidation() {
      if (this['enqueued'] || !validateFn) {
        return;
      }
      this['enqueued'] = true;
      (0, _documentWait2.default)(validateFn);
    }
    /**
     * @param {!HTMLStyleElement} style
     */

  }, {
    key: 'addCustomStyle',
    value: function addCustomStyle(style) {
      if (!style[SEEN_MARKER]) {
        style[SEEN_MARKER] = true;
        this['customStyles'].push(style);
        this.enqueueDocumentValidation();
      }
    }
    /**
     * @param {!CustomStyleProvider} customStyle
     * @return {HTMLStyleElement}
     */

  }, {
    key: 'getStyleForCustomStyle',
    value: function getStyleForCustomStyle(customStyle) {
      if (customStyle[CACHED_STYLE]) {
        return customStyle[CACHED_STYLE];
      }
      var style = void 0;
      if (customStyle['getStyle']) {
        style = customStyle['getStyle']();
      } else {
        style = customStyle;
      }
      return style;
    }
    /**
     * @return {!Array<!CustomStyleProvider>}
     */

  }, {
    key: 'processStyles',
    value: function processStyles() {
      var cs = this['customStyles'];
      for (var i = 0; i < cs.length; i++) {
        var customStyle = cs[i];
        if (customStyle[CACHED_STYLE]) {
          continue;
        }
        var style = this.getStyleForCustomStyle(customStyle);
        if (style) {
          // HTMLImports polyfill may have cloned the style into the main document,
          // which is referenced with __appliedElement.
          var styleToTransform = /** @type {!HTMLStyleElement} */style['__appliedElement'] || style;
          if (transformFn) {
            transformFn(styleToTransform);
          }
          customStyle[CACHED_STYLE] = styleToTransform;
        }
      }
      return cs;
    }
  }]);

  return CustomStyleInterface;
}();

exports.default = CustomStyleInterface;


CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get: function get() {
      return transformFn;
    },

    /** @param {?function(!HTMLStyleElement)} fn */
    set: function set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get: function get() {
      return validateFn;
    },

    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set: function set(fn) {
      var needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    }
  }
});

/** @typedef {{
 * customStyles: !Array<!CustomStyleProvider>,
 * addCustomStyle: function(!CustomStyleProvider),
 * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
 * findStyles: function(),
 * transformCallback: ?function(!HTMLStyleElement),
 * validateCallback: ?function()
 * }}
 */
var CustomStyleInterfaceInterface = exports.CustomStyleInterfaceInterface = void 0;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GestureEventListeners = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _gestures = __webpack_require__(41);

var gestures$0 = _interopRequireWildcard(_gestures);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @const {Polymer.Gestures}
 */
var gestures = gestures$0;

var GestureEventListeners = exports.GestureEventListeners = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  var GestureEventListeners = function (_superClass) {
    _inherits(GestureEventListeners, _superClass);

    function GestureEventListeners() {
      _classCallCheck(this, GestureEventListeners);

      return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
    }

    _createClass(GestureEventListeners, [{
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        if (!gestures.addListener(node, eventName, handler)) {
          _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
        }
      }
    }, {
      key: '_removeEventListenerFromNode',
      value: function _removeEventListenerFromNode(node, eventName, handler) {
        if (!gestures.removeListener(node, eventName, handler)) {
          _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
        }
      }
    }]);

    return GestureEventListeners;
  }(superClass);

  return GestureEventListeners;
});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flush = undefined;
exports.beforeNextRender = beforeNextRender;
exports.afterNextRender = afterNextRender;

__webpack_require__(2);

var scheduled = false;
var beforeRenderQueue = [];
var afterRenderQueue = [];

function schedule() {
  scheduled = true;
  // before next render
  requestAnimationFrame(function () {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    // after the render
    setTimeout(function () {
      runQueue(afterRenderQueue);
    });
  });
}

function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}

function runQueue(queue) {
  for (var i = 0, l = queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}

function callMethod(info) {
  var context = info[0];
  var callback = info[1];
  var args = info[2];
  try {
    callback.apply(context, args);
  } catch (e) {
    setTimeout(function () {
      throw e;
    });
  }
}

function flush() {
  while (beforeRenderQueue.length || afterRenderQueue.length) {
    flushQueue(beforeRenderQueue);
    flushQueue(afterRenderQueue);
  }
  scheduled = false;
}

function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}

function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}

exports.flush = flush;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlattenedNodesObserver = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _arraySplice = __webpack_require__(68);

var _async = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Returns true if `node` is a slot element
 * @param {HTMLElement} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */
function isSlot(node) {
  return node.localName === 'slot';
}

/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * @memberof Polymer
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 */

var FlattenedNodesObserver = function () {
  _createClass(FlattenedNodesObserver, null, [{
    key: 'getFlattenedNodes',


    /**
     * Returns the list of flattened nodes for the given `node`.
     * This list consists of a node's children and, for any children
     * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
     * For example, if the observed node has children `<a></a><slot></slot><b></b>`
     * and the `<slot>` has one `<div>` assigned to it, then the flattened
     * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
     * `<slot>` elements assigned to it, these are flattened as well.
     *
     * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
     * @return {Array} The list of flattened nodes for the given `node`.
    */
    value: function getFlattenedNodes(node) {
      if (isSlot(node)) {
        return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
        );
      } else {
        return Array.from(node.childNodes).map(function (node) {
          if (isSlot(node)) {
            return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
            );
          } else {
            return [node];
          }
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
      }
    }

    /**
     * @param {Node} target Node on which to listen for changes.
     * @param {Function} callback Function called when there are additions
     * or removals from the target's list of flattened nodes.
    */

  }]);

  function FlattenedNodesObserver(target, callback) {
    var _this = this;

    _classCallCheck(this, FlattenedNodesObserver);

    /** @type {MutationObserver} */
    this._shadyChildrenObserver = null;
    /** @type {MutationObserver} */
    this._nativeChildrenObserver = null;
    this._connected = false;
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /** @type {function()} */
    this._boundSchedule = function () {
      _this._schedule();
    };
    this.connect();
    this._schedule();
  }

  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   */


  _createClass(FlattenedNodesObserver, [{
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (isSlot(this._target)) {
        this._listenSlots([this._target]);
      } else {
        this._listenSlots(this._target.children);
        if (window.ShadyDOM) {
          this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
            _this2._processMutations(mutations);
          });
        } else {
          this._nativeChildrenObserver = new MutationObserver(function (mutations) {
            _this2._processMutations(mutations);
          });
          this._nativeChildrenObserver.observe(this._target, { childList: true });
        }
      }
      this._connected = true;
    }

    /**
     * Deactivates the flattened nodes observer. After calling this method
     * the observer callback will not be called when changes to flattened nodes
     * occur. The `connect` method may be subsequently called to reactivate
     * the observer.
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (isSlot(this._target)) {
        this._unlistenSlots([this._target]);
      } else {
        this._unlistenSlots(this._target.children);
        if (window.ShadyDOM && this._shadyChildrenObserver) {
          ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
          this._shadyChildrenObserver = null;
        } else if (this._nativeChildrenObserver) {
          this._nativeChildrenObserver.disconnect();
          this._nativeChildrenObserver = null;
        }
      }
      this._connected = false;
    }
  }, {
    key: '_schedule',
    value: function _schedule() {
      var _this3 = this;

      if (!this._scheduled) {
        this._scheduled = true;
        _async.microTask.run(function () {
          return _this3.flush();
        });
      }
    }
  }, {
    key: '_processMutations',
    value: function _processMutations(mutations) {
      this._processSlotMutations(mutations);
      this.flush();
    }
  }, {
    key: '_processSlotMutations',
    value: function _processSlotMutations(mutations) {
      if (mutations) {
        for (var i = 0; i < mutations.length; i++) {
          var mutation = mutations[i];
          if (mutation.addedNodes) {
            this._listenSlots(mutation.addedNodes);
          }
          if (mutation.removedNodes) {
            this._unlistenSlots(mutation.removedNodes);
          }
        }
      }
    }

    /**
     * Flushes the observer causing any pending changes to be immediately
     * delivered the observer callback. By default these changes are delivered
     * asynchronously at the next microtask checkpoint.
     *
     * @return {boolean} Returns true if any pending changes caused the observer
     * callback to run.
     */

  }, {
    key: 'flush',
    value: function flush() {
      if (!this._connected) {
        return false;
      }
      if (window.ShadyDOM) {
        ShadyDOM.flush();
      }
      if (this._nativeChildrenObserver) {
        this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
      } else if (this._shadyChildrenObserver) {
        this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
      }
      this._scheduled = false;
      var info = {
        target: this._target,
        addedNodes: [],
        removedNodes: []
      };
      var newNodes = this.constructor.getFlattenedNodes(this._target);
      var splices = (0, _arraySplice.calculateSplices)(newNodes, this._effectiveNodes);
      // process removals
      for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
          info.removedNodes.push(n);
        }
      }
      // process adds
      for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
        for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
          info.addedNodes.push(newNodes[_j]);
        }
      }
      // update cache
      this._effectiveNodes = newNodes;
      var didFlush = false;
      if (info.addedNodes.length || info.removedNodes.length) {
        didFlush = true;
        this.callback.call(this._target, info);
      }
      return didFlush;
    }
  }, {
    key: '_listenSlots',
    value: function _listenSlots(nodeList) {
      for (var i = 0; i < nodeList.length; i++) {
        var n = nodeList[i];
        if (isSlot(n)) {
          n.addEventListener('slotchange', this._boundSchedule);
        }
      }
    }
  }, {
    key: '_unlistenSlots',
    value: function _unlistenSlots(nodeList) {
      for (var i = 0; i < nodeList.length; i++) {
        var n = nodeList[i];
        if (isSlot(n)) {
          n.removeEventListener('slotchange', this._boundSchedule);
        }
      }
    }
  }]);

  return FlattenedNodesObserver;
}();

exports.FlattenedNodesObserver = FlattenedNodesObserver;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSplices = undefined;

__webpack_require__(2);

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;

// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  // "Deletion" columns
  var rowCount = oldEnd - oldStart + 1;
  var columnCount = currentEnd - currentStart + 1;
  var distances = new Array(rowCount);

  // "Addition" rows. Initialize null column.
  for (var i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }

  // Initialize null row
  for (var j = 0; j < columnCount; j++) {
    distances[0][j] = j;
  }for (var _i = 1; _i < rowCount; _i++) {
    for (var _j = 1; _j < columnCount; _j++) {
      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
        var north = distances[_i - 1][_j] + 1;
        var west = distances[_i][_j - 1] + 1;
        distances[_i][_j] = north < west ? north : west;
      }
    }
  }

  return distances;
}

// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
  var i = distances.length - 1;
  var j = distances[0].length - 1;
  var current = distances[i][j];
  var edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    var northWest = distances[i - 1][j - 1];
    var west = distances[i - 1][j];
    var north = distances[i][j - 1];

    var min = void 0;
    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}

/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  var prefixCount = 0;
  var suffixCount = 0;
  var splice = void 0;

  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;

  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd) {
      splice.removed.push(old[oldStart++]);
    }return [splice];
  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

  splice = undefined;
  var splices = [];
  var index = currentStart;
  var oldIndex = oldStart;
  for (var i = 0; i < ops.length; i++) {
    switch (ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice) splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice) splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice) splice = newSplice(index, [], 0);

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }
  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (var i = 0; i < searchLength; i++) {
    if (!equals(current[i], old[i])) return i;
  }return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  var index1 = current.length;
  var index2 = old.length;
  var count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2])) {
    count++;
  }return count;
}

function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0, previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}

exports.calculateSplices = calculateSplices;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n\n      /* Material Design color palette for Google products */\n\n      --google-red-100: #f4c7c3;\n      --google-red-300: #e67c73;\n      --google-red-500: #db4437;\n      --google-red-700: #c53929;\n\n      --google-blue-100: #c6dafc;\n      --google-blue-300: #7baaf7;\n      --google-blue-500: #4285f4;\n      --google-blue-700: #3367d6;\n\n      --google-green-100: #b7e1cd;\n      --google-green-300: #57bb8a;\n      --google-green-500: #0f9d58;\n      --google-green-700: #0b8043;\n\n      --google-yellow-100: #fce8b2;\n      --google-yellow-300: #f7cb4d;\n      --google-yellow-500: #f4b400;\n      --google-yellow-700: #f09300;\n\n      --google-grey-100: #f5f5f5;\n      --google-grey-300: #e0e0e0;\n      --google-grey-500: #9e9e9e;\n      --google-grey-700: #616161;\n\n      /* Material Design color palette from online spec document */\n\n      --paper-red-50: #ffebee;\n      --paper-red-100: #ffcdd2;\n      --paper-red-200: #ef9a9a;\n      --paper-red-300: #e57373;\n      --paper-red-400: #ef5350;\n      --paper-red-500: #f44336;\n      --paper-red-600: #e53935;\n      --paper-red-700: #d32f2f;\n      --paper-red-800: #c62828;\n      --paper-red-900: #b71c1c;\n      --paper-red-a100: #ff8a80;\n      --paper-red-a200: #ff5252;\n      --paper-red-a400: #ff1744;\n      --paper-red-a700: #d50000;\n\n      --paper-pink-50: #fce4ec;\n      --paper-pink-100: #f8bbd0;\n      --paper-pink-200: #f48fb1;\n      --paper-pink-300: #f06292;\n      --paper-pink-400: #ec407a;\n      --paper-pink-500: #e91e63;\n      --paper-pink-600: #d81b60;\n      --paper-pink-700: #c2185b;\n      --paper-pink-800: #ad1457;\n      --paper-pink-900: #880e4f;\n      --paper-pink-a100: #ff80ab;\n      --paper-pink-a200: #ff4081;\n      --paper-pink-a400: #f50057;\n      --paper-pink-a700: #c51162;\n\n      --paper-purple-50: #f3e5f5;\n      --paper-purple-100: #e1bee7;\n      --paper-purple-200: #ce93d8;\n      --paper-purple-300: #ba68c8;\n      --paper-purple-400: #ab47bc;\n      --paper-purple-500: #9c27b0;\n      --paper-purple-600: #8e24aa;\n      --paper-purple-700: #7b1fa2;\n      --paper-purple-800: #6a1b9a;\n      --paper-purple-900: #4a148c;\n      --paper-purple-a100: #ea80fc;\n      --paper-purple-a200: #e040fb;\n      --paper-purple-a400: #d500f9;\n      --paper-purple-a700: #aa00ff;\n\n      --paper-deep-purple-50: #ede7f6;\n      --paper-deep-purple-100: #d1c4e9;\n      --paper-deep-purple-200: #b39ddb;\n      --paper-deep-purple-300: #9575cd;\n      --paper-deep-purple-400: #7e57c2;\n      --paper-deep-purple-500: #673ab7;\n      --paper-deep-purple-600: #5e35b1;\n      --paper-deep-purple-700: #512da8;\n      --paper-deep-purple-800: #4527a0;\n      --paper-deep-purple-900: #311b92;\n      --paper-deep-purple-a100: #b388ff;\n      --paper-deep-purple-a200: #7c4dff;\n      --paper-deep-purple-a400: #651fff;\n      --paper-deep-purple-a700: #6200ea;\n\n      --paper-indigo-50: #e8eaf6;\n      --paper-indigo-100: #c5cae9;\n      --paper-indigo-200: #9fa8da;\n      --paper-indigo-300: #7986cb;\n      --paper-indigo-400: #5c6bc0;\n      --paper-indigo-500: #3f51b5;\n      --paper-indigo-600: #3949ab;\n      --paper-indigo-700: #303f9f;\n      --paper-indigo-800: #283593;\n      --paper-indigo-900: #1a237e;\n      --paper-indigo-a100: #8c9eff;\n      --paper-indigo-a200: #536dfe;\n      --paper-indigo-a400: #3d5afe;\n      --paper-indigo-a700: #304ffe;\n\n      --paper-blue-50: #e3f2fd;\n      --paper-blue-100: #bbdefb;\n      --paper-blue-200: #90caf9;\n      --paper-blue-300: #64b5f6;\n      --paper-blue-400: #42a5f5;\n      --paper-blue-500: #2196f3;\n      --paper-blue-600: #1e88e5;\n      --paper-blue-700: #1976d2;\n      --paper-blue-800: #1565c0;\n      --paper-blue-900: #0d47a1;\n      --paper-blue-a100: #82b1ff;\n      --paper-blue-a200: #448aff;\n      --paper-blue-a400: #2979ff;\n      --paper-blue-a700: #2962ff;\n\n      --paper-light-blue-50: #e1f5fe;\n      --paper-light-blue-100: #b3e5fc;\n      --paper-light-blue-200: #81d4fa;\n      --paper-light-blue-300: #4fc3f7;\n      --paper-light-blue-400: #29b6f6;\n      --paper-light-blue-500: #03a9f4;\n      --paper-light-blue-600: #039be5;\n      --paper-light-blue-700: #0288d1;\n      --paper-light-blue-800: #0277bd;\n      --paper-light-blue-900: #01579b;\n      --paper-light-blue-a100: #80d8ff;\n      --paper-light-blue-a200: #40c4ff;\n      --paper-light-blue-a400: #00b0ff;\n      --paper-light-blue-a700: #0091ea;\n\n      --paper-cyan-50: #e0f7fa;\n      --paper-cyan-100: #b2ebf2;\n      --paper-cyan-200: #80deea;\n      --paper-cyan-300: #4dd0e1;\n      --paper-cyan-400: #26c6da;\n      --paper-cyan-500: #00bcd4;\n      --paper-cyan-600: #00acc1;\n      --paper-cyan-700: #0097a7;\n      --paper-cyan-800: #00838f;\n      --paper-cyan-900: #006064;\n      --paper-cyan-a100: #84ffff;\n      --paper-cyan-a200: #18ffff;\n      --paper-cyan-a400: #00e5ff;\n      --paper-cyan-a700: #00b8d4;\n\n      --paper-teal-50: #e0f2f1;\n      --paper-teal-100: #b2dfdb;\n      --paper-teal-200: #80cbc4;\n      --paper-teal-300: #4db6ac;\n      --paper-teal-400: #26a69a;\n      --paper-teal-500: #009688;\n      --paper-teal-600: #00897b;\n      --paper-teal-700: #00796b;\n      --paper-teal-800: #00695c;\n      --paper-teal-900: #004d40;\n      --paper-teal-a100: #a7ffeb;\n      --paper-teal-a200: #64ffda;\n      --paper-teal-a400: #1de9b6;\n      --paper-teal-a700: #00bfa5;\n\n      --paper-green-50: #e8f5e9;\n      --paper-green-100: #c8e6c9;\n      --paper-green-200: #a5d6a7;\n      --paper-green-300: #81c784;\n      --paper-green-400: #66bb6a;\n      --paper-green-500: #4caf50;\n      --paper-green-600: #43a047;\n      --paper-green-700: #388e3c;\n      --paper-green-800: #2e7d32;\n      --paper-green-900: #1b5e20;\n      --paper-green-a100: #b9f6ca;\n      --paper-green-a200: #69f0ae;\n      --paper-green-a400: #00e676;\n      --paper-green-a700: #00c853;\n\n      --paper-light-green-50: #f1f8e9;\n      --paper-light-green-100: #dcedc8;\n      --paper-light-green-200: #c5e1a5;\n      --paper-light-green-300: #aed581;\n      --paper-light-green-400: #9ccc65;\n      --paper-light-green-500: #8bc34a;\n      --paper-light-green-600: #7cb342;\n      --paper-light-green-700: #689f38;\n      --paper-light-green-800: #558b2f;\n      --paper-light-green-900: #33691e;\n      --paper-light-green-a100: #ccff90;\n      --paper-light-green-a200: #b2ff59;\n      --paper-light-green-a400: #76ff03;\n      --paper-light-green-a700: #64dd17;\n\n      --paper-lime-50: #f9fbe7;\n      --paper-lime-100: #f0f4c3;\n      --paper-lime-200: #e6ee9c;\n      --paper-lime-300: #dce775;\n      --paper-lime-400: #d4e157;\n      --paper-lime-500: #cddc39;\n      --paper-lime-600: #c0ca33;\n      --paper-lime-700: #afb42b;\n      --paper-lime-800: #9e9d24;\n      --paper-lime-900: #827717;\n      --paper-lime-a100: #f4ff81;\n      --paper-lime-a200: #eeff41;\n      --paper-lime-a400: #c6ff00;\n      --paper-lime-a700: #aeea00;\n\n      --paper-yellow-50: #fffde7;\n      --paper-yellow-100: #fff9c4;\n      --paper-yellow-200: #fff59d;\n      --paper-yellow-300: #fff176;\n      --paper-yellow-400: #ffee58;\n      --paper-yellow-500: #ffeb3b;\n      --paper-yellow-600: #fdd835;\n      --paper-yellow-700: #fbc02d;\n      --paper-yellow-800: #f9a825;\n      --paper-yellow-900: #f57f17;\n      --paper-yellow-a100: #ffff8d;\n      --paper-yellow-a200: #ffff00;\n      --paper-yellow-a400: #ffea00;\n      --paper-yellow-a700: #ffd600;\n\n      --paper-amber-50: #fff8e1;\n      --paper-amber-100: #ffecb3;\n      --paper-amber-200: #ffe082;\n      --paper-amber-300: #ffd54f;\n      --paper-amber-400: #ffca28;\n      --paper-amber-500: #ffc107;\n      --paper-amber-600: #ffb300;\n      --paper-amber-700: #ffa000;\n      --paper-amber-800: #ff8f00;\n      --paper-amber-900: #ff6f00;\n      --paper-amber-a100: #ffe57f;\n      --paper-amber-a200: #ffd740;\n      --paper-amber-a400: #ffc400;\n      --paper-amber-a700: #ffab00;\n\n      --paper-orange-50: #fff3e0;\n      --paper-orange-100: #ffe0b2;\n      --paper-orange-200: #ffcc80;\n      --paper-orange-300: #ffb74d;\n      --paper-orange-400: #ffa726;\n      --paper-orange-500: #ff9800;\n      --paper-orange-600: #fb8c00;\n      --paper-orange-700: #f57c00;\n      --paper-orange-800: #ef6c00;\n      --paper-orange-900: #e65100;\n      --paper-orange-a100: #ffd180;\n      --paper-orange-a200: #ffab40;\n      --paper-orange-a400: #ff9100;\n      --paper-orange-a700: #ff6500;\n\n      --paper-deep-orange-50: #fbe9e7;\n      --paper-deep-orange-100: #ffccbc;\n      --paper-deep-orange-200: #ffab91;\n      --paper-deep-orange-300: #ff8a65;\n      --paper-deep-orange-400: #ff7043;\n      --paper-deep-orange-500: #ff5722;\n      --paper-deep-orange-600: #f4511e;\n      --paper-deep-orange-700: #e64a19;\n      --paper-deep-orange-800: #d84315;\n      --paper-deep-orange-900: #bf360c;\n      --paper-deep-orange-a100: #ff9e80;\n      --paper-deep-orange-a200: #ff6e40;\n      --paper-deep-orange-a400: #ff3d00;\n      --paper-deep-orange-a700: #dd2c00;\n\n      --paper-brown-50: #efebe9;\n      --paper-brown-100: #d7ccc8;\n      --paper-brown-200: #bcaaa4;\n      --paper-brown-300: #a1887f;\n      --paper-brown-400: #8d6e63;\n      --paper-brown-500: #795548;\n      --paper-brown-600: #6d4c41;\n      --paper-brown-700: #5d4037;\n      --paper-brown-800: #4e342e;\n      --paper-brown-900: #3e2723;\n\n      --paper-grey-50: #fafafa;\n      --paper-grey-100: #f5f5f5;\n      --paper-grey-200: #eeeeee;\n      --paper-grey-300: #e0e0e0;\n      --paper-grey-400: #bdbdbd;\n      --paper-grey-500: #9e9e9e;\n      --paper-grey-600: #757575;\n      --paper-grey-700: #616161;\n      --paper-grey-800: #424242;\n      --paper-grey-900: #212121;\n\n      --paper-blue-grey-50: #eceff1;\n      --paper-blue-grey-100: #cfd8dc;\n      --paper-blue-grey-200: #b0bec5;\n      --paper-blue-grey-300: #90a4ae;\n      --paper-blue-grey-400: #78909c;\n      --paper-blue-grey-500: #607d8b;\n      --paper-blue-grey-600: #546e7a;\n      --paper-blue-grey-700: #455a64;\n      --paper-blue-grey-800: #37474f;\n      --paper-blue-grey-900: #263238;\n\n      /* opacity for dark text on a light background */\n      --dark-divider-opacity: 0.12;\n      --dark-disabled-opacity: 0.38; /* or hint text or icon */\n      --dark-secondary-opacity: 0.54;\n      --dark-primary-opacity: 0.87;\n\n      /* opacity for light text on a dark background */\n      --light-divider-opacity: 0.12;\n      --light-disabled-opacity: 0.3; /* or hint text or icon */\n      --light-secondary-opacity: 0.7;\n      --light-primary-opacity: 1.0;\n\n    }\n\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronButtonState = exports.IronButtonStateImpl = undefined;

__webpack_require__(6);

var _ironA11yKeysBehavior = __webpack_require__(71);

__webpack_require__(72);

var _polymerDom = __webpack_require__(17);

var IronButtonStateImpl = exports.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = (0, _polymerDom.dom)(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = (0, _polymerDom.dom)(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

var IronButtonState = exports.IronButtonState = [_ironA11yKeysBehavior.IronA11yKeysBehavior, IronButtonStateImpl];

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronA11yKeysBehavior = undefined;

__webpack_require__(6);

/**
 * Chrome uses an older version of DOM Level 3 Keyboard Events
 *
 * Most keys are labeled as text, but some are Unicode codepoints.
 * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
 */
var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};

/**
 * Special table for KeyboardEvent.keyCode.
 * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
 * than that.
 *
 * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
 */
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};

/**
 * MODIFIER_KEYS maps the short name for modifier keys used in a key
 * combo string to the property name that references those same keys
 * in a KeyboardEvent instance.
 */
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};

/**
 * KeyboardEvent.key is mostly represented by printable character made by
 * the keyboard, with unprintable keys labeled nicely.
 *
 * However, on OS X, Alt+char can make a Unicode character that follows an
 * Apple-specific mapping. In this case, we fall back to .keyCode.
 */
var KEY_CHAR = /[a-z0-9*]/;

/**
 * Matches a keyIdentifier string.
 */
var IDENT_CHAR = /U\+/;

/**
 * Matches arrow keys in Gecko 27.0+
 */
var ARROW_KEY = /^arrow/;

/**
 * Matches space keys everywhere (notably including IE10's exceptional name
 * `spacebar`).
 */
var SPACE_KEY = /^space(bar)?/;

/**
 * Matches ESC key.
 *
 * Value from: http://w3c.github.io/uievents-key/#key-Escape
 */
var ESC_KEY = /^escape$/;

/**
 * Transforms the key.
 * @param {string} key The KeyBoardEvent.key
 * @param {Boolean} [noSpecialChars] Limits the transformation to
 * alpha-numeric characters.
 */
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      // numpad '*' can map to Multiply on IE/Windows
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}

function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}

function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      // ascii a-z
      // lowercase is 32 offset from uppercase
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      // function keys f1-f12
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      // top 0-9 keys
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      // num pad 0-9
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}

/**
  * Calculates the normalized key for a KeyboardEvent.
  * @param {KeyboardEvent} keyEvent
  * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
  * transformation to alpha-numeric chars. This is useful with key
  * combinations like shift + 2, which on FF for MacOS produces
  * keyEvent.key = @
  * To get 2 returned, set noSpecialChars = true
  * To get @ returned, set noSpecialChars = false
 */
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  // Fall back from .key, to .detail.key for artifical keyboard events,
  // and then to deprecated .keyIdentifier and .keyCode.
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
}

function keyComboMatchesEvent(keyCombo, event) {
  // For combos with modifiers we support only alpha-numeric keys
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
}

function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {
      combo: keyComboString,
      key: keyComboString,
      event: 'keydown'
    };
  }
  return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
    var eventParts = keyComboPart.split(':');
    var keyName = eventParts[0];
    var event = eventParts[1];

    if (keyName in MODIFIER_KEYS) {
      parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
      parsedKeyCombo.hasModifiers = true;
    } else {
      parsedKeyCombo.key = keyName;
      parsedKeyCombo.event = event || 'keydown';
    }

    return parsedKeyCombo;
  }, {
    combo: keyComboString.split(':').shift()
  });
}

function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function (keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}

var IronA11yKeysBehavior = exports.IronA11yKeysBehavior = {
  properties: {
    /**
     * The EventTarget that will be firing relevant KeyboardEvents. Set it to
     * `null` to disable the listeners.
     * @type {?EventTarget}
     */
    keyEventTarget: {
      type: Object,
      value: function value() {
        return this;
      }
    },

    /**
     * If true, this property will cause the implementing element to
     * automatically stop propagation on any handled KeyboardEvents.
     */
    stopKeyboardEventPropagation: {
      type: Boolean,
      value: false
    },

    _boundKeyHandlers: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    // We use this due to a limitation in IE10 where instances will have
    // own properties of everything on the "prototype".
    _imperativeKeyBindings: {
      type: Object,
      value: function value() {
        return {};
      }
    }
  },

  observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

  /**
   * To be used to express what combination of keys  will trigger the relative
   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
   * @type {!Object}
   */
  keyBindings: {},

  registered: function registered() {
    this._prepKeyBindings();
  },

  attached: function attached() {
    this._listenKeyEventListeners();
  },

  detached: function detached() {
    this._unlistenKeyEventListeners();
  },

  /**
   * Can be used to imperatively add a key binding to the implementing
   * element. This is the imperative equivalent of declaring a keybinding
   * in the `keyBindings` prototype property.
   *
   * @param {string} eventString
   * @param {string} handlerName
   */
  addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * When called, will remove all imperatively-added key bindings.
   */
  removeOwnKeyBindings: function removeOwnKeyBindings() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * Returns true if a keyboard event matches `eventString`.
   *
   * @param {KeyboardEvent} event
   * @param {string} eventString
   * @return {boolean}
   */
  keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },

  _collectKeyBindings: function _collectKeyBindings() {
    var keyBindings = this.behaviors.map(function (behavior) {
      return behavior.keyBindings;
    });

    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }

    return keyBindings;
  },

  _prepKeyBindings: function _prepKeyBindings() {
    this._keyBindings = {};

    this._collectKeyBindings().forEach(function (keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);

    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
    }

    // Give precedence to combos with modifiers to be checked first.
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function (kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return b1 === b2 ? 0 : b1 ? -1 : 1;
      });
    }
  },

  _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
    parseEventString(eventString).forEach(function (keyCombo) {
      this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
    }, this);
  },

  _resetKeyEventListeners: function _resetKeyEventListeners() {
    this._unlistenKeyEventListeners();

    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },

  _listenKeyEventListeners: function _listenKeyEventListeners() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function (eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },

  _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;

    while (this._boundKeyHandlers.length) {
      // My kingdom for block-scope binding and destructuring assignment..
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];

      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },

  _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }

    // if event has been already prevented, don't do anything
    if (event.defaultPrevented) {
      return;
    }

    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        // exit the loop if eventDefault was prevented
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },

  _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event = new CustomEvent(keyCombo.event, {
      detail: detail,
      cancelable: true
    });
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronControlState = undefined;

__webpack_require__(6);

var _polymerElement = __webpack_require__(11);

var _polymerDom = __webpack_require__(17);

var IronControlState = exports.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !_polymerElement.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (_polymerElement.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */(0, _polymerDom.dom)(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EPSG900913 = exports.EPSG3857 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(74);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = exports.EPSG3857 = Util.extend({}, _CRS.Earth, {
  code: 'EPSG:3857',
  projection: _Projection.SphericalMercator,

  transformation: function () {
    var scale = 0.5 / (Math.PI * _Projection.SphericalMercator.R);
    return (0, _Transformation.toTransformation)(scale, 0.5, -scale, 0.5);
  }()
});

var EPSG900913 = exports.EPSG900913 = Util.extend({}, EPSG3857, {
  code: 'EPSG:900913'
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SphericalMercator = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var SphericalMercator = exports.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function project(latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new _Point.Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function unproject(point) {
		var d = 180 / Math.PI;

		return new _LatLng.LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
	},

	bounds: function () {
		var d = 6378137 * Math.PI;
		return new _Bounds.Bounds([-d, -d], [d, d]);
	}()
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.svgCreate = svgCreate;
exports.pointsToPath = pointsToPath;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	    i,
	    j,
	    len,
	    len2,
	    points,
	    p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? Browser.svg ? 'z' : 'x' : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports._pointersCount = undefined;
exports.addPointerListener = addPointerListener;
exports.removePointerListener = removePointerListener;

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
    POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove',
    POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup',
    POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
    TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'],
    _pointers = {},
    _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = exports._pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);
	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);
	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);
	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);
	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = Util.bind(function (e) {
		if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				DomEvent.preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	exports._pointersCount = _pointersCount += 1;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	exports._pointersCount = _pointersCount -= 1;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function onMove(e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
			return;
		}

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function onUp(e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.PosAnimation = undefined;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Events = __webpack_require__(19);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = exports.PosAnimation = _Events.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function run(el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function stop() {
		if (!this._inProgress) {
			return;
		}

		this._step(true);
		this._complete();
	},

	_animate: function _animate() {
		// animation loop
		this._animId = Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function _step(round) {
		var elapsed = +new Date() - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function _runFrame(progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function _complete() {
		Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function _easeOut(t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.IconDefault = undefined;

var _Icon = __webpack_require__(30);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = exports.IconDefault = _Icon.Icon.extend({

	options: {
		iconUrl: 'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl: 'marker-shadow.png',
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize: [41, 41]
	},

	_getIconUrl: function _getIconUrl(name) {
		if (!IconDefault.imagePath) {
			// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the absolute location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right absolute path.
		return (this.options.imagePath || IconDefault.imagePath) + _Icon.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function _detectIconPath() {
		var el = DomUtil.create('div', 'leaflet-default-icon-path', document.body);
		var path = DomUtil.getStyle(el, 'background-image') || DomUtil.getStyle(el, 'backgroundImage'); // IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '');
		}

		return path;
	}
});

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = exports.Map = undefined;

var _Map = __webpack_require__(7);

Object.defineProperty(exports, 'Map', {
  enumerable: true,
  get: function get() {
    return _Map.Map;
  }
});
Object.defineProperty(exports, 'map', {
  enumerable: true,
  get: function get() {
    return _Map.createMap;
  }
});

var _Map2 = __webpack_require__(121);

var _Map3 = __webpack_require__(122);

var _Map4 = __webpack_require__(123);

var _Map5 = __webpack_require__(124);

var _Map6 = __webpack_require__(125);

var _Map7 = __webpack_require__(126);

var _Map8 = __webpack_require__(127);

_Map.Map.BoxZoom = _Map2.BoxZoom;

_Map.Map.DoubleClickZoom = _Map3.DoubleClickZoom;

_Map.Map.Drag = _Map4.Drag;

_Map.Map.Keyboard = _Map5.Keyboard;

_Map.Map.ScrollWheelZoom = _Map6.ScrollWheelZoom;

_Map.Map.Tap = _Map7.Tap;

_Map.Map.TouchZoom = _Map8.TouchZoom;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.attribution = exports.Attribution = undefined;

var _Control = __webpack_require__(22);

var _Map = __webpack_require__(7);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = exports.Attribution = _Control.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function onAdd(map) {
		map.attributionControl = this;
		this._container = DomUtil.create('div', 'leaflet-control-attribution');
		DomEvent.disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function setPrefix(prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function addAttribution(text) {
		if (!text) {
			return this;
		}

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function removeAttribution(text) {
		if (!text) {
			return this;
		}

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function _update() {
		if (!this._map) {
			return;
		}

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
_Map.Map.mergeOptions({
	attributionControl: true
});

_Map.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = exports.attribution = function attribution(options) {
	return new Attribution(options);
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.control = exports.Control = undefined;

var _Control = __webpack_require__(22);

var _Control2 = __webpack_require__(128);

var _Control3 = __webpack_require__(129);

var _Control4 = __webpack_require__(130);

var _Control5 = __webpack_require__(80);

_Control.Control.Layers = _Control2.Layers;
_Control.Control.Zoom = _Control3.Zoom;
_Control.Control.Scale = _Control4.Scale;
_Control.Control.Attribution = _Control5.Attribution;

_Control.control.layers = _Control2.layers;
_Control.control.zoom = _Control3.zoom;
_Control.control.scale = _Control4.scale;
_Control.control.attribution = _Control5.attribution;

exports.Control = _Control.Control;
exports.control = _Control.control;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tooltip = exports.Tooltip = exports.popup = exports.Popup = exports.DivOverlay = exports.videoOverlay = exports.VideoOverlay = exports.imageOverlay = exports.ImageOverlay = exports.geoJson = exports.geoJSON = exports.GeoJSON = exports.featureGroup = exports.FeatureGroup = exports.layerGroup = exports.LayerGroup = exports.Layer = undefined;

var _Layer = __webpack_require__(12);

Object.defineProperty(exports, 'Layer', {
  enumerable: true,
  get: function get() {
    return _Layer.Layer;
  }
});

var _LayerGroup = __webpack_require__(46);

Object.defineProperty(exports, 'LayerGroup', {
  enumerable: true,
  get: function get() {
    return _LayerGroup.LayerGroup;
  }
});
Object.defineProperty(exports, 'layerGroup', {
  enumerable: true,
  get: function get() {
    return _LayerGroup.layerGroup;
  }
});

var _FeatureGroup = __webpack_require__(18);

Object.defineProperty(exports, 'FeatureGroup', {
  enumerable: true,
  get: function get() {
    return _FeatureGroup.FeatureGroup;
  }
});
Object.defineProperty(exports, 'featureGroup', {
  enumerable: true,
  get: function get() {
    return _FeatureGroup.featureGroup;
  }
});

var _ImageOverlay = __webpack_require__(50);

Object.defineProperty(exports, 'ImageOverlay', {
  enumerable: true,
  get: function get() {
    return _ImageOverlay.ImageOverlay;
  }
});
Object.defineProperty(exports, 'imageOverlay', {
  enumerable: true,
  get: function get() {
    return _ImageOverlay.imageOverlay;
  }
});

var _VideoOverlay = __webpack_require__(131);

Object.defineProperty(exports, 'VideoOverlay', {
  enumerable: true,
  get: function get() {
    return _VideoOverlay.VideoOverlay;
  }
});
Object.defineProperty(exports, 'videoOverlay', {
  enumerable: true,
  get: function get() {
    return _VideoOverlay.videoOverlay;
  }
});

var _DivOverlay = __webpack_require__(51);

Object.defineProperty(exports, 'DivOverlay', {
  enumerable: true,
  get: function get() {
    return _DivOverlay.DivOverlay;
  }
});

var _Popup = __webpack_require__(132);

Object.defineProperty(exports, 'Popup', {
  enumerable: true,
  get: function get() {
    return _Popup.Popup;
  }
});
Object.defineProperty(exports, 'popup', {
  enumerable: true,
  get: function get() {
    return _Popup.popup;
  }
});

var _Tooltip = __webpack_require__(133);

Object.defineProperty(exports, 'Tooltip', {
  enumerable: true,
  get: function get() {
    return _Tooltip.Tooltip;
  }
});
Object.defineProperty(exports, 'tooltip', {
  enumerable: true,
  get: function get() {
    return _Tooltip.tooltip;
  }
});

var _index = __webpack_require__(134);

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

var _index2 = __webpack_require__(136);

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index2[key];
    }
  });
});

var _index3 = __webpack_require__(137);

Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index3[key];
    }
  });
});

var _GeoJSON = __webpack_require__(88);

_GeoJSON.GeoJSON.geometryToLayer = _GeoJSON.geometryToLayer;
_GeoJSON.GeoJSON.coordsToLatLng = _GeoJSON.coordsToLatLng;
_GeoJSON.GeoJSON.coordsToLatLngs = _GeoJSON.coordsToLatLngs;
_GeoJSON.GeoJSON.latLngToCoords = _GeoJSON.latLngToCoords;
_GeoJSON.GeoJSON.latLngsToCoords = _GeoJSON.latLngsToCoords;
_GeoJSON.GeoJSON.getFeature = _GeoJSON.getFeature;
_GeoJSON.GeoJSON.asFeature = _GeoJSON.asFeature;
exports.GeoJSON = _GeoJSON.GeoJSON;
exports.geoJSON = _GeoJSON.geoJSON;
exports.geoJson = _GeoJSON.geoJson;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.GridLayer = undefined;
exports.gridLayer = gridLayer;

var _Layer = __webpack_require__(12);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(8);

var _LatLngBounds = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */

var GridLayer = exports.GridLayer = _Layer.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
	},

	onAdd: function onAdd() {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function beforeAdd(map) {
		map._addZoomLimit(this);
	},

	onRemove: function onRemove(map) {
		this._removeAllTiles();
		DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function getContainer() {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function setZIndex(zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function isLoading() {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function redraw() {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function getEvents() {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function createTile() {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function getTileSize() {
		var s = this.options.tileSize;
		return s instanceof _Point.Point ? s : new _Point.Point(s, s);
	},

	_updateZIndex: function _updateZIndex() {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function _setAutoZIndex(compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function _updateOpacity() {
		if (!this._map) {
			return;
		}

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (Browser.ielt9) {
			return;
		}

		DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) {
				continue;
			}

			var fade = Math.min(1, (now - tile.loaded) / 200);

			DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) {
			this._pruneTiles();
		}

		if (nextFrame) {
			Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: Util.falseFn,

	_initContainer: function _initContainer() {
		if (this._container) {
			return;
		}

		this._container = DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function _updateLevels() {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) {
			return undefined;
		}

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			Util.falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: Util.falseFn,

	_onRemoveLevel: Util.falseFn,

	_onCreateLevel: Util.falseFn,

	_pruneTiles: function _pruneTiles() {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function _removeTilesAtZoom(zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function _removeAllTiles() {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function _invalidateAll() {
		for (var z in this._levels) {
			DomUtil.remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function _retainParent(x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new _Point.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;
		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function _retainChildren(x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new _Point.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;
				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function _resetView(e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function _animateZoom(e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function _clampZoom(zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function _setView(center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function _setZoomTransforms(center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function _setZoomTransform(level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (Browser.any3d) {
			DomUtil.setTransform(level.el, translate, scale);
		} else {
			DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function _resetGrid() {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
	},

	_onMoveEnd: function _onMoveEnd() {
		if (!this._map || this._map._animatingZoom) {
			return;
		}

		this._update();
	},

	_getTiledPixelBounds: function _getTiledPixelBounds(center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new _Bounds.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function _update(center) {
		var map = this._map;
		if (!map) {
			return;
		}
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) {
			center = map.getCenter();
		}
		if (this._tileZoom === undefined) {
			return;
		} // if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new _Bounds.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
			throw new Error('Attempted to load an infinite number of tiles');
		}

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new _Point.Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) {
			this._setView(center, zoom);return;
		}

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new _Point.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) {
					continue;
				}

				if (!this._tiles[this._tileCoordsToKey(coords)]) {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function _isValidTile(coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
				return false;
			}
		}

		if (!this.options.bounds) {
			return true;
		}

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return (0, _LatLngBounds.toLatLngBounds)(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function _keyToBounds(key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function _tileCoordsToBounds(coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),
		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),
		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z),
		    bounds = new _LatLngBounds.LatLngBounds(nw, se);

		if (!this.options.noWrap) {
			map.wrapLatLngBounds(bounds);
		}

		return bounds;
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function _tileCoordsToKey(coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function _keyToTileCoords(key) {
		var k = key.split(':'),
		    coords = new _Point.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function _removeTile(key) {
		var tile = this._tiles[key];
		if (!tile) {
			return;
		}

		DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function _initTile(tile) {
		DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = Util.falseFn;
		tile.onmousemove = Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (Browser.ielt9 && this.options.opacity < 1) {
			DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (Browser.android && !Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function _addTile(coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), Util.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			Util.requestAnimFrame(Util.bind(this._tileReady, this, coords, null, tile));
		}

		DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function _tileReady(coords, err, tile) {
		if (!this._map) {
			return;
		}

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) {
			return;
		}

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			DomUtil.setOpacity(tile.el, 0);
			Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (Browser.ielt9 || !this._map._fadeAnimated) {
				Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(Util.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function _getTilePos(coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function _wrapCoords(coords) {
		var newCoords = new _Point.Point(this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {
		var tileSize = this.getTileSize();
		return new _Bounds.Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function _noTilesToLoad() {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) {
				return false;
			}
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Canvas = undefined;
exports.canvas = canvas;

var _Renderer = __webpack_require__(31);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = exports.Canvas = _Renderer.Renderer.extend({
	getEvents: function getEvents() {
		var events = _Renderer.Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function _onViewPreReset() {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function onAdd() {
		_Renderer.Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function _initContainer() {
		var container = this._container = document.createElement('canvas');

		DomEvent.on(container, 'mousemove', Util.throttle(this._onMouseMove, 32, this), this);
		DomEvent.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		DomEvent.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function _destroyContainer() {
		delete this._ctx;
		DomUtil.remove(this._container);
		DomEvent.off(this._container);
		delete this._container;
	},

	_updatePaths: function _updatePaths() {
		if (this._postponeUpdatePaths) {
			return;
		}

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function _update() {
		if (this._map._animatingZoom && this._bounds) {
			return;
		}

		this._drawnLayers = {};

		_Renderer.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = Browser.retina ? 2 : 1;

		DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function _reset() {
		_Renderer.Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function _initPath(layer) {
		this._updateDashArray(layer);
		this._layers[Util.stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) {
			this._drawLast.next = order;
		}
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function _addPath(layer) {
		this._requestRedraw(layer);
	},

	_removePath: function _removePath(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[L.stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function _updatePath(layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function _updateStyle(layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function _updateDashArray(layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function _requestRedraw(layer) {
		if (!this._map) {
			return;
		}

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || Util.requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function _extendRedrawBounds(layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new _Bounds.Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function _redraw() {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function _clear() {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function _draw() {
		var layer,
		    bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore(); // Restore state before clipping.
	},

	_updatePoly: function _updatePoly(layer, closed) {
		if (!this._drawing) {
			return;
		}

		var i,
		    j,
		    len2,
		    p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) {
			return;
		}

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function _updateCircle(layer) {

		if (!this._drawing || layer._empty()) {
			return;
		}

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function _fillStroke(ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function _onClick(e) {
		var point = this._map.mouseEventToLayerPoint(e),
		    layer,
		    clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer) {
			DomEvent.fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function _onMouseMove(e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
			return;
		}

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},

	_handleMouseOut: function _handleMouseOut(e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function _handleMouseHover(e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function _fireEvent(layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function _bringToFront(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// signle entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function _bringToBack(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// signle entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas(options) {
	return Browser.canvas ? new Canvas(options) : null;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Circle = undefined;
exports.circle = circle;

var _CircleMarker = __webpack_require__(32);

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _CRS = __webpack_require__(16);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = exports.Circle = _CircleMarker.CircleMarker.extend({

	initialize: function initialize(latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = Util.extend({}, legacyOptions, { radius: options });
		}
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);

		if (isNaN(this.options.radius)) {
			throw new Error('Circle radius cannot be NaN');
		}

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function setRadius(radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function getRadius() {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function getBounds() {
		var half = [this._radius, this._radiusY || this._radius];

		return new _LatLngBounds.LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: _Path.Path.prototype.setStyle,

	_project: function _project() {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === _CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = this._mRadius / _CRS.Earth.R / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);
		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.clipPolygon = clipPolygon;

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i,
	    j,
	    k,
	    a,
	    b,
	    len,
	    edge,
	    p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = LineUtil._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = LineUtil._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = LineUtil._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

				// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = LineUtil._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = LineUtil._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SVG = exports.create = exports.pointsToPath = undefined;
exports.svg = svg;

var _Renderer = __webpack_require__(31);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var _SVG = __webpack_require__(75);

var _SVG2 = __webpack_require__(139);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.pointsToPath = _SVG.pointsToPath;
var create = exports.create = Browser.vml ? _SVG2.vmlCreate : _SVG.svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = exports.SVG = _Renderer.Renderer.extend({

	getEvents: function getEvents() {
		var events = _Renderer.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function _initContainer() {
		this._container = create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function _destroyContainer() {
		DomUtil.remove(this._container);
		DomEvent.off(this._container);
		delete this._container;
		delete this._rootGroup;
	},

	_onZoomStart: function _onZoomStart() {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function _update() {
		if (this._map._animatingZoom && this._bounds) {
			return;
		}

		_Renderer.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function _initPath(layer) {
		var path = layer._path = create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[(0, _Util.stamp)(layer)] = layer;
	},

	_addPath: function _addPath(layer) {
		if (!this._rootGroup) {
			this._initContainer();
		}
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function _removePath(layer) {
		DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[(0, _Util.stamp)(layer)];
	},

	_updatePath: function _updatePath(layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function _updateStyle(layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) {
			return;
		}

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function _updatePoly(layer, closed) {
		this._setPath(layer, (0, _SVG.pointsToPath)(layer._parts, closed));
	},

	_updateCircle: function _updateCircle(layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function _setPath(layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function _bringToFront(layer) {
		DomUtil.toFront(layer._path);
	},

	_bringToBack: function _bringToBack(layer) {
		DomUtil.toBack(layer._path);
	}
});

if (Browser.vml) {
	SVG.include(_SVG2.vmlMixin);
}

// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg(options) {
	return Browser.svg || Browser.vml ? new SVG(options) : null;
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.geoJson = exports.GeoJSON = undefined;
exports.geometryToLayer = geometryToLayer;
exports.coordsToLatLng = coordsToLatLng;
exports.coordsToLatLngs = coordsToLatLngs;
exports.latLngToCoords = latLngToCoords;
exports.latLngsToCoords = latLngsToCoords;
exports.getFeature = getFeature;
exports.asFeature = asFeature;
exports.geoJSON = geoJSON;

var _LayerGroup = __webpack_require__(46);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Marker = __webpack_require__(48);

var _Circle = __webpack_require__(85);

var _CircleMarker = __webpack_require__(32);

var _Polyline = __webpack_require__(56);

var _Polygon = __webpack_require__(57);

var _LatLng = __webpack_require__(9);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = exports.GeoJSON = _FeatureGroup.FeatureGroup.extend({

	/* @section
  * @aka GeoJSON options
  *
  * @option pointToLayer: Function = *
  * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  * The default is to spawn a default `Marker`:
  * ```js
  * function(geoJsonPoint, latlng) {
  * 	return L.marker(latlng);
  * }
  * ```
  *
  * @option style: Function = *
  * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  * called internally when data is added.
  * The default value is to not override any defaults:
  * ```js
  * function (geoJsonFeature) {
  * 	return {}
  * }
  * ```
  *
  * @option onEachFeature: Function = *
  * A `Function` that will be called once for each created `Feature`, after it has
  * been created and styled. Useful for attaching events and popups to features.
  * The default is to do nothing with the newly created layers:
  * ```js
  * function (feature, layer) {}
  * ```
  *
  * @option filter: Function = *
  * A `Function` that will be used to decide whether to include a feature or not.
  * The default is to include all features:
  * ```js
  * function (geoJsonFeature) {
  * 	return true;
  * }
  * ```
  * Note: dynamically changing the `filter` option will have effect only on newly
  * added data. It will _not_ re-evaluate already included features.
  *
  * @option coordsToLatLng: Function = *
  * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  * The default is the `coordsToLatLng` static method.
  */

	initialize: function initialize(geojson, options) {
		Util.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function addData(geojson) {
		var features = Util.isArray(geojson) ? geojson : geojson.features,
		    i,
		    len,
		    feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) {
			return this;
		}

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function resetStyle(layer) {
		// reset any custom styles
		layer.options = Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function setStyle(style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function _setLayerStyle(layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
	    coords = geometry ? geometry.coordinates : null,
	    layers = [],
	    pointToLayer = options && options.pointToLayer,
	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
	    latlng,
	    latlngs,
	    i,
	    len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
		case 'Point':
			latlng = _coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new _Marker.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = _coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new _Marker.Marker(latlng));
			}
			return new _FeatureGroup.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
			return new _Polyline.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
			return new _Polygon.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new _FeatureGroup.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
	}
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new _LatLng.LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ? [Util.formatNum(latlng.lng, precision), Util.formatNum(latlng.lat, precision), Util.formatNum(latlng.alt, precision)] : [Util.formatNum(latlng.lng, precision), Util.formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ? Util.extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function toGeoJSON(precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
_Marker.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
_Circle.Circle.include(PointToGeoJSON);
_CircleMarker.CircleMarker.include(PointToGeoJSON);

// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
_Polyline.Polyline.include({
	toGeoJSON: function toGeoJSON(precision) {
		var multi = !LineUtil.isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
_Polygon.Polygon.include({
	toGeoJSON: function toGeoJSON(precision) {
		var holes = !LineUtil.isFlat(this._latlngs),
		    multi = holes && !LineUtil.isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});

// @namespace LayerGroup
_LayerGroup.LayerGroup.include({
	toMultiPoint: function toMultiPoint(precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function toGeoJSON(precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = exports.geoJson = geoJSON;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Mercator = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

var Mercator = exports.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new _Bounds.Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function project(latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new _Point.Point(latlng.lng * d * r, y);
	},

	unproject: function unproject(point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new _LatLng.LatLng(phi * d, point.x * d / r);
	}
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GGMapViewer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

__webpack_require__(93);

var _FeatureGroup = __webpack_require__(18);

var _Marker = __webpack_require__(48);

var _Icon = __webpack_require__(30);

var _markerIcon = __webpack_require__(118);

var _markerIcon2 = _interopRequireDefault(_markerIcon);

var _markerShadow = __webpack_require__(119);

var _markerShadow2 = _interopRequireDefault(_markerShadow);

var _leafletMap = __webpack_require__(120);

var _leafletWmsGroup = __webpack_require__(141);

var _leafletTileLayer = __webpack_require__(144);

var _leafletGeojsonPoints = __webpack_require__(145);

var _appTemplate = __webpack_require__(164);

var _appTemplate2 = _interopRequireDefault(_appTemplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var yaml = __webpack_require__(165);

var GGMapViewer = exports.GGMapViewer = function (_PolymerElement) {
  _inherits(GGMapViewer, _PolymerElement);

  _createClass(GGMapViewer, null, [{
    key: 'template',
    get: function get() {
      return _appTemplate2.default;
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        config: {
          type: String
        },
        map: {
          type: Object
        },
        baseSource: {
          type: String
        },
        baseFormat: {
          type: String
        },
        selectedOverlay: {
          type: Object,
          observer: '_overlayChanged'
        },
        wmsGroups: {
          type: Array,
          value: []
        },
        geojsonLayers: {
          type: Array,
          value: []
        },
        baseMaps: {
          type: Array
        },
        overlayMaps: {
          type: Array
        },
        searchMarkers: {
          type: Array,
          value: [],
          observer: '_markMap'
        }
      };
    }
  }]);

  function GGMapViewer() {
    _classCallCheck(this, GGMapViewer);

    var _this = _possibleConstructorReturn(this, (GGMapViewer.__proto__ || Object.getPrototypeOf(GGMapViewer)).call(this));

    _this._markersGroup = new _FeatureGroup.FeatureGroup([]);
    return _this;
  }

  _createClass(GGMapViewer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(GGMapViewer.prototype.__proto__ || Object.getPrototypeOf(GGMapViewer.prototype), 'connectedCallback', this).call(this);

      fetch(this.config).then(function (r) {
        return r.text();
      }).then(this.initializeMap.bind(this));

      this.initializeSearch();
    }
  }, {
    key: 'initializeMap',
    value: function initializeMap(response) {
      var rjson = yaml.safeLoad(response);

      this.baseMaps = rjson.baseMaps;
      this.overlayMaps = rjson.overlayMaps;

      // iterate through groups of layers
      for (var i = 0; i < this.overlayMaps.length; i++) {
        var l = this.overlayMaps[i].layers;
        this.overlayMaps[i].flattenedLayers = [];

        // iterate through layer interaction types (always on, exclusives, optionals)
        for (var t in l) {
          this.overlayMaps[i].flattenedLayers = this.overlayMaps[i].flattenedLayers.concat(l[t]);

          // iterate through all layers
          for (var j = 0; j < l[t].length; j++) {
            l[t][j].interaction = t;

            // always on layers should always be visible
            if (t === 'alwaysOn') {
              l[t][j].visible = true;
            }

            // For convenience, allow source to be globally defined, but propagate it here.
            if ((l[t][j].type === 'wms' || l[t][j].type === undefined) && l[t][j].source === undefined) {
              l[t][j].type = 'wms';
              l[t][j].source = rjson.wmsDefaultSource;
            }
          }
        }
      }

      // FIXME: hacky hardcoded initial view
      this._selectedBasemap = 0;
      this.baseSource = this.baseMaps[0].source;
      this.baseFormat = this.baseMaps[0].format;
      this.baseLayers = this.baseMaps[0].layers;

      this.overlaySelect();
    }
  }, {
    key: 'initializeSearch',
    value: function initializeSearch() {
      var _this2 = this;

      this._markersGroup.addTo(this.map);

      jQuery('#search', this.shadowRoot).autocomplete({
        preventBadQueries: false,
        deferRequestBy: 200,
        minChars: 3,
        serviceUrl: '//www.ci.garden-grove.ca.us/maps/api/addresses/search',
        paramName: 'q',
        // params: { limit: 10 },
        transformResult: function transformResult(response) {
          var addresses = JSON.parse(response).addresses;
          return {
            suggestions: addresses.map(function (d) {
              return { value: d.address, data: d };
            })
          };
        },
        onSearchStart: function onSearchStart() {
          return _this2.set('searchMakers', []);
        },
        onSearchComplete: function onSearchComplete(q, s) {
          return _this2.set('searchMarkers', s.map(function (obj) {
            return [obj.data.latitude, obj.data.longitude];
          }));
        },
        onSelect: function onSelect(obj) {
          return _this2.set('searchMarkers', [[obj.data.latitude, obj.data.longitude]]);
        }
      });
    }
  }, {
    key: 'toggleLayer',
    value: function toggleLayer(event) {
      // First save the current state
      var currVisible = event.model.layer.visible;

      if (event.model.layer.interaction === 'exclusives') {
        // Turn all exclusive layers off
        for (var i = 0; i < this.selectedOverlay.layers.exclusives.length; i++) {
          this.set('selectedOverlay.layers.exclusives.' + i + '.visible', false);
        }
      }

      // Compute toggle on original state
      event.model.set('layer.visible', !currVisible);

      this._parseLayers(this.selectedOverlay);
    }
  }, {
    key: 'overlaySelect',
    value: function overlaySelect(event) {
      this.selectedOverlay = event ? event.model.item : this.overlayMaps[0];

      if (this.selectedOverlay.resetViewOnSelect) {
        this.map.flyTo(this.selectedOverlay.initialCenter, this.selectedOverlay.initialZoom);
      }
    }

    // FIXE: Achtung! Uber hacky!!!

  }, {
    key: 'switchBasemap',
    value: function switchBasemap(event) {
      var idx = ++this._selectedBasemap % 2;
      this.baseSource = this.baseMaps[idx].source;
      this.baseFormat = this.baseMaps[idx].format;
      this.baseLayers = this.baseMaps[idx].layers;

      if (idx === 1) {
        event.target.style.backgroundImage = "url(./vector.png)";
      } else {
        event.target.style.backgroundImage = "url(./aerial.png)";
      }
    }
  }, {
    key: 'toggleLayersMenu',
    value: function toggleLayersMenu() {
      var layersMenu = this.shadowRoot.querySelector('main#layers-menu');
      layersMenu.classList.toggle('show');
    }
  }, {
    key: '_parseLayers',
    value: function _parseLayers(overlay) {
      var _this3 = this;

      var layers = overlay.flattenedLayers;
      var wmsLayers = {};

      // reset
      this.set('wmsGroups', []);
      this.set('geojsonLayers', []);

      layers.filter(function (l) {
        return l.visible;
      }).forEach(function (l) {
        if (l.type === 'wms') {
          // group the sources
          wmsLayers[l.source] = wmsLayers[l.source] || [];
          wmsLayers[l.source].push(l.machineName);
        } else if (l.type === 'geojson') {
          _this3.push('geojsonLayers', l);
        }
      });

      // flattened the grouped WMS sources
      for (var s in wmsLayers) {
        this.push('wmsGroups', { source: s, layers: wmsLayers[s] });
      }
    }
  }, {
    key: '_markMap',
    value: function _markMap(markersCoords) {
      var _this4 = this;

      this._markersGroup.clearLayers();
      if (markersCoords.length === 0) return;

      markersCoords.forEach(function (m) {
        _this4._markersGroup.addLayer(new _Marker.Marker(m, { icon: new _Icon.Icon({ iconUrl: _markerIcon2.default, shadowUrl: _markerShadow2.default }) }));
      });

      if (markersCoords.length === 1) this.map.flyTo(markersCoords[0]);else this.map.fitBounds(this._markersGroup.getBounds());
    }
  }, {
    key: '_isCurrentExclusive',
    value: function _isCurrentExclusive(layer) {
      return layer.visible;
    }
  }, {
    key: '_isCurrentOverlay',
    value: function _isCurrentOverlay(selected, item) {
      return selected === item;
    }
  }, {
    key: '_overlayChanged',
    value: function _overlayChanged(newOverlay) {
      this._parseLayers(newOverlay);
    }
  }, {
    key: '_overlayLayersShow',
    value: function _overlayLayersShow(selected, item) {
      if (selected === item) return "collapse show";
      return "collapse";
    }
  }, {
    key: '_overlayItemClass',
    value: function _overlayItemClass(selected, item) {
      var defaultClass = "overlay-item d-flex justify-content-start";
      if (selected === item) return defaultClass + ' selected';
      return defaultClass;
    }

    // FIXME: make this less hardcodey

  }, {
    key: 'downloadLayer',
    value: function downloadLayer(event) {
      event.stopPropagation();
      event.preventDefault();

      // if modal is not already found in light DOM, pull from shadow DOM
      var dom = document.querySelector('#download-modal') ? document : this.shadowRoot;

      var layer = event.model.layer;
      // FIXME: hardcoded url
      var downloadURL = 'https://www.ci.garden-grove.ca.us/geoserver/gis/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=' + layer.machineName;

      jQuery('#layer-name', dom).html(layer.name);
      jQuery('#geojson-download', dom).attr('href', downloadURL + '&outputFormat=application/json');
      jQuery('#csv-download', dom).attr('href', downloadURL + '&outputFormat=csv');
      jQuery('#kml-download', dom).attr('href', downloadURL + '&outputFormat=application/vnd.google-earth.kml+xml');
      jQuery('#shapefile-download', dom).attr('href', downloadURL + '&outputFormat=SHAPE-ZIP');
      jQuery('#download-modal', dom).modal();
    }
  }]);

  return GGMapViewer;
}(_polymerElement.Element);

customElements.define('gg-map-viewer', GGMapViewer);

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertyAccessors = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _caseMap = __webpack_require__(35);

var caseMap$0 = _interopRequireWildcard(_caseMap);

var _async = __webpack_require__(15);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var caseMap = caseMap$0;

var microtask = _async.microTask;

// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
var nativeProperties = {};
var proto = HTMLElement.prototype;
while (proto) {
  var props = Object.getOwnPropertyNames(proto);
  for (var i = 0; i < props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}

/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @private
 */
function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    var value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}

var PropertyAccessors = exports.PropertyAccessors = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends HTMLElement
   * @unrestricted
   */
  var PropertyAccessors = function (_superClass) {
    _inherits(PropertyAccessors, _superClass);

    _createClass(PropertyAccessors, null, [{
      key: 'createPropertiesForAttributes',


      /**
       * Generates property accessors for all attributes in the standard
       * static `observedAttributes` array.
       *
       * Attribute names are mapped to property names using the `dash-case` to
       * `camelCase` convention
       *
       */
      value: function createPropertiesForAttributes() {
        var a$ = this.observedAttributes;
        for (var _i = 0; _i < a$.length; _i++) {
          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
        }
      }
    }]);

    function PropertyAccessors() {
      _classCallCheck(this, PropertyAccessors);

      /** @type {boolean} */
      var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

      _this.__serializing;
      /** @type {number} */
      _this.__dataCounter;
      /** @type {boolean} */
      _this.__dataEnabled;
      /** @type {boolean} */
      _this.__dataReady;
      /** @type {boolean} */
      _this.__dataInvalid;
      /** @type {!Object} */
      _this.__data;
      /** @type {Object} */
      _this.__dataPending;
      /** @type {Object} */
      _this.__dataOld;
      /** @type {Object} */
      _this.__dataProto;
      /** @type {Object} */
      _this.__dataHasAccessor;
      /** @type {Object} */
      _this.__dataInstanceProps;
      _this._initializeProperties();
      return _this;
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     */


    _createClass(PropertyAccessors, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this._attributeToProperty(name, value);
        }
      }

      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @protected
       */

    }, {
      key: '_initializeProperties',
      value: function _initializeProperties() {
        this.__serializing = false;
        this.__dataCounter = 0;
        this.__dataEnabled = false;
        this.__dataReady = false;
        this.__dataInvalid = false;
        this.__data = {};
        this.__dataPending = null;
        this.__dataOld = null;
        if (this.__dataProto) {
          this._initializeProtoProperties(this.__dataProto);
          this.__dataProto = null;
        }
        // Capture instance properties; these will be set into accessors
        // during first flush. Don't set them here, since we want
        // these to overwrite defaults/constructor assignments
        for (var p in this.__dataHasAccessor) {
          if (this.hasOwnProperty(p)) {
            this.__dataInstanceProps = this.__dataInstanceProps || {};
            this.__dataInstanceProps[p] = this[p];
            delete this[p];
          }
        }
      }

      /**
       * Called at instance time with bag of properties that were overwritten
       * by accessors on the prototype when accessors were created.
       *
       * The default implementation sets these properties back into the
       * setter at instance time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @protected
       */

    }, {
      key: '_initializeProtoProperties',
      value: function _initializeProtoProperties(props) {
        for (var p in props) {
          this._setProperty(p, props[p]);
        }
      }

      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @protected
       */

    }, {
      key: '_initializeInstanceProperties',
      value: function _initializeInstanceProperties(props) {
        Object.assign(this, props);
      }

      /**
       * Ensures the element has the given attribute. If it does not,
       * assigns the given value to the attribute.
       *
       *
       * @param {string} attribute Name of attribute to ensure is set.
       * @param {string} value of the attribute.
       */

    }, {
      key: '_ensureAttribute',
      value: function _ensureAttribute(attribute, value) {
        if (!this.hasAttribute(attribute)) {
          this._valueToNodeAttribute(this, value, attribute);
        }
      }

      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to.
       */

    }, {
      key: '_attributeToProperty',
      value: function _attributeToProperty(attribute, value, type) {
        // Don't deserialize back to property if currently reflecting
        if (!this.__serializing) {
          var property = caseMap.dashToCamelCase(attribute);
          this[property] = this._deserializeValue(value, type);
        }
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */

    }, {
      key: '_propertyToAttribute',
      value: function _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = arguments.length < 3 ? this[property] : value;
        this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
        this.__serializing = false;
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       */

    }, {
      key: '_valueToNodeAttribute',
      value: function _valueToNodeAttribute(node, value, attribute) {
        var str = this._serializeValue(value);
        if (str === undefined) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(attribute, str);
        }
      }

      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called by Polymer when setting JS property values to
       * HTML attributes.  Users may override this method on Polymer element
       * prototypes to provide serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided property value.
       */

    }, {
      key: '_serializeValue',
      value: function _serializeValue(value) {
        /* eslint-disable no-fallthrough */
        switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
          case 'boolean':
            return value ? '' : undefined;

          case 'object':
            if (value instanceof Date) {
              return value.toString();
            } else if (value) {
              try {
                return JSON.stringify(value);
              } catch (x) {
                return '';
              }
            }

          default:
            return value != null ? value.toString() : undefined;
        }
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called by Polymer when reading HTML attribute values to
       * JS properties.  Users may override this method on Polymer element
       * prototypes to provide deserialization for custom `type`s.  Note,
       * the `type` argument is the value of the `type` field provided in the
       * `properties` configuration object for a given property, and is
       * by convention the constructor for the type to deserialize.
       *
       * Note: The return value of `undefined` is used as a sentinel value to
       * indicate the attribute should be removed.
       *
       * @param {?string} value Attribute value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       */

    }, {
      key: '_deserializeValue',
      value: function _deserializeValue(value, type) {
        /**
         * @type {*}
         */
        var outValue = void 0;
        switch (type) {
          case Number:
            outValue = Number(value);
            break;

          case Boolean:
            outValue = value !== null;
            break;

          case Object:
            try {
              outValue = JSON.parse( /** @type string */value);
            } catch (x) {
              // allow non-JSON literals like Strings and Numbers
            }
            break;

          case Array:
            try {
              outValue = JSON.parse( /** @type string */value);
            } catch (x) {
              outValue = null;
              console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
            }
            break;

          case Date:
            outValue = new Date(value);
            break;

          case String:
          default:
            outValue = value;
            break;
        }

        return outValue;
      }
      /* eslint-enable no-fallthrough */

      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.  When calling on
       * a prototype, any overwritten values are saved in `__dataProto`,
       * and it is up to the subclasser to decide how/when to set those
       * properties back into the accessor.  When calling on an instance,
       * the overwritten value is set via `_setPendingProperty`, and the
       * user should call `_invalidateProperties` or `_flushProperties`
       * for the values to take effect.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @protected
       */

    }, {
      key: '_createPropertyAccessor',
      value: function _createPropertyAccessor(property, readOnly) {
        if (!this.hasOwnProperty('__dataHasAccessor')) {
          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
        }
        if (!this.__dataHasAccessor[property]) {
          this.__dataHasAccessor[property] = true;
          saveAccessorValue(this, property);
          Object.defineProperty(this, property, {
            /* eslint-disable valid-jsdoc */
            /** @this {PropertyAccessors} */
            get: function get() {
              return this.__data[property];
            },
            /** @this {PropertyAccessors} */
            set: readOnly ? function () {} : function (value) {
              this._setProperty(property, value);
            }
            /* eslint-enable */
          });
        }
      }

      /**
       * Returns true if this library created an accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if an accessor was created
       */

    }, {
      key: '_hasAccessor',
      value: function _hasAccessor(property) {
        return this.__dataHasAccessor && this.__dataHasAccessor[property];
      }

      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @protected
       */

    }, {
      key: '_setProperty',
      value: function _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }

      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {boolean} Returns true if the property changed
       * @protected
       */

    }, {
      key: '_setPendingProperty',
      value: function _setPendingProperty(property, value) {
        var old = this.__data[property];
        var changed = this._shouldPropertyChange(property, value, old);
        if (changed) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (this.__dataOld && !(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
        }
        return changed;
      }

      /**
       * Returns true if the specified property has a pending change.
       *
       * @param {string} prop Property name
       * @return {boolean} True if property has a pending change
       * @protected
       */

    }, {
      key: '_isPropertyPending',
      value: function _isPropertyPending(prop) {
        return Boolean(this.__dataPending && prop in this.__dataPending);
      }

      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @protected
       */

    }, {
      key: '_invalidateProperties',
      value: function _invalidateProperties() {
        var _this2 = this;

        if (!this.__dataInvalid && this.__dataReady) {
          this.__dataInvalid = true;
          microtask.run(function () {
            if (_this2.__dataInvalid) {
              _this2.__dataInvalid = false;
              _this2._flushProperties();
            }
          });
        }
      }

      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       */

    }, {
      key: '_enableProperties',
      value: function _enableProperties() {
        if (!this.__dataEnabled) {
          this.__dataEnabled = true;
          if (this.__dataInstanceProps) {
            this._initializeInstanceProperties(this.__dataInstanceProps);
            this.__dataInstanceProps = null;
          }
          this.ready();
        }
      }

      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       *
       * @protected
       */

    }, {
      key: '_flushProperties',
      value: function _flushProperties() {
        if (this.__dataPending && this.__dataOld) {
          var changedProps = this.__dataPending;
          this.__dataPending = null;
          this.__dataCounter++;
          this._propertiesChanged(this.__data, changedProps, this.__dataOld);
          this.__dataCounter--;
        }
      }

      /**
       * Lifecycle callback called the first time properties are being flushed.
       * Prior to `ready`, all property sets through accessors are queued and
       * their effects are flushed after this method returns.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its properties initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @public
       */

    }, {
      key: 'ready',
      value: function ready() {
        this.__dataReady = true;
        // Run normal flush
        this._flushProperties();
      }

      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {!Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {!Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @protected
       */

    }, {
      key: '_propertiesChanged',
      value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` for primitive types if a
       * strict equality check fails, and returns `true` for all Object/Arrays.
       * The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       */

    }, {
      key: '_shouldPropertyChange',
      value: function _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check
          old !== value && (
          // This ensures (old==NaN, value==NaN) always returns false
          old === old || value === value)
        );
      }
    }]);

    return PropertyAccessors;
  }(superClass);

  return PropertyAccessors;
});

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplateStamp = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _mixin = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
var templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
function wrapTemplateExtension(node) {
  var is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    var t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while (t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }
  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  // unwind the stack, returning the indexed node at each level
  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}

// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}

// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}

// push configuration references at configure time
function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;
  var handler = function handler(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}

var TemplateStamp = exports.TemplateStamp = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  var TemplateStamp = function (_superClass) {
    _inherits(TemplateStamp, _superClass);

    function TemplateStamp() {
      _classCallCheck(this, TemplateStamp);

      return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
    }

    _createClass(TemplateStamp, [{
      key: '_stampTemplate',


      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       */
      value: function _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        var templateInfo = this.constructor._parseTemplate(template);
        var nodeInfo = templateInfo.nodeInfoList;
        var content = templateInfo.content || template.content;
        var dom = /** @type DocumentFragment */document.importNode(content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
        var nodes = dom.nodeList = new Array(nodeInfo.length);
        dom.$ = {};
        for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
          var node = nodes[i] = findTemplateNode(dom, info);
          applyIdToMap(this, dom.$, node, info);
          applyTemplateContent(this, node, info);
          applyEventListener(this, node, info);
        }
        return (/** @type {!StampedTemplate} */dom
        );
      }

      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {Node} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       */

    }, {
      key: '_addMethodEventListenerToNode',
      value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        var handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {Node} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {Function} handler Listener function to add
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {Node} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {Function} handler Listener function to remove
       */

    }, {
      key: '_removeEventListenerFromNode',
      value: function _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }
    }], [{
      key: '_parseTemplate',


      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       */
      value: function _parseTemplate(template, outerTemplateInfo) {
        // since a template may be re-used, memo-ize metadata
        if (!template._templateInfo) {
          var templateInfo = template._templateInfo = {};
          templateInfo.nodeInfoList = [];
          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
          this._parseTemplateContent(template, templateInfo, { parent: null });
        }
        return template._templateInfo;
      }
    }, {
      key: '_parseTemplateContent',
      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
      }

      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNode',
      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
        var noted = void 0;
        var element = /** @type Element */node;
        if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
        } else if (element.localName === 'slot') {
          // For ShadyDom optimization, indicating there is an insertion point
          templateInfo.hasInsertionPoint = true;
        }
        if (element.firstChild) {
          noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
        }
        if (element.hasAttributes && element.hasAttributes()) {
          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
        }
        return noted;
      }

      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       */

    }, {
      key: '_parseTemplateChildNodes',
      value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
        for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
          // Wrap templates
          if (node.localName == 'template') {
            node = wrapTemplateExtension(node);
          }
          // collapse adjacent textNodes: fixes an IE issue that can cause
          // text nodes to be inexplicably split =(
          // note that root.normalize() should work but does not so we do this
          // manually.
          next = node.nextSibling;
          if (node.nodeType === Node.TEXT_NODE) {
            var /** Node */n = next;
            while (n && n.nodeType === Node.TEXT_NODE) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root.removeChild(n);
              n = next;
            }
            // optionally strip whitespace
            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
              root.removeChild(node);
              continue;
            }
          }
          var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
          if (this._parseTemplateNode(node, templateInfo, childInfo)) {
            childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
          }
          // Increment if not removed
          if (node.parentNode) {
            parentIndex++;
          }
        }
      }

      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNestedTemplate',
      value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
        var templateInfo = this._parseTemplate(node, outerTemplateInfo);
        var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
        content.appendChild(node.content);
        nodeInfo.templateInfo = templateInfo;
        return true;
      }

      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNodeAttributes',
      value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
        // Make copy of original attribute list, since the order may change
        // as attributes are added and removed
        var noted = false;
        var attrs = Array.from(node.attributes);
        for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
        }
        return noted;
      }

      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNodeAttribute',
      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        // events (on-*)
        if (name.slice(0, 3) === 'on-') {
          node.removeAttribute(name);
          nodeInfo.events = nodeInfo.events || [];
          nodeInfo.events.push({
            name: name.slice(3),
            value: value
          });
          return true;
        }
        // static id
        else if (name === 'id') {
            nodeInfo.id = value;
            return true;
          }
        return false;
      }

      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       */

    }, {
      key: '_contentForTemplate',
      value: function _contentForTemplate(template) {
        var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
        return templateInfo && templateInfo.content || template.content;
      }
    }]);

    return TemplateStamp;
  }(superClass);

  return TemplateStamp;
});

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

__webpack_require__(107);

__webpack_require__(69);

__webpack_require__(108);

var _paperCheckedElementBehavior = __webpack_require__(109);

var _polymerFn = __webpack_require__(28);

var _renderStatus = __webpack_require__(66);

var _gestures = __webpack_require__(41);

var _paperRippleBehavior = __webpack_require__(45);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<dom-module id="paper-toggle-button">\n  <template strip-whitespace="">\n\n    <style>\n      :host {\n        display: inline-block;\n        @apply --layout-horizontal;\n        @apply --layout-center;\n        @apply --paper-font-common-base;\n      }\n\n      :host([disabled]) {\n        pointer-events: none;\n      }\n\n      :host(:focus) {\n        outline:none;\n      }\n\n      .toggle-bar {\n        position: absolute;\n        height: 100%;\n        width: 100%;\n        border-radius: 8px;\n        pointer-events: none;\n        opacity: 0.4;\n        transition: background-color linear .08s;\n        background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);\n\n        @apply --paper-toggle-button-unchecked-bar;\n      }\n\n      .toggle-button {\n        position: absolute;\n        top: -3px;\n        left: 0;\n        height: 20px;\n        width: 20px;\n        border-radius: 50%;\n        box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);\n        transition: -webkit-transform linear .08s, background-color linear .08s;\n        transition: transform linear .08s, background-color linear .08s;\n        will-change: transform;\n        background-color: var(--paper-toggle-button-unchecked-button-color, var(--paper-grey-50));\n\n        @apply --paper-toggle-button-unchecked-button;\n      }\n\n      .toggle-button.dragging {\n        -webkit-transition: none;\n        transition: none;\n      }\n\n      :host([checked]:not([disabled])) .toggle-bar {\n        opacity: 0.5;\n        background-color: var(--paper-toggle-button-checked-bar-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-bar;\n      }\n\n      :host([disabled]) .toggle-bar {\n        background-color: #000;\n        opacity: 0.12;\n      }\n\n      :host([checked]) .toggle-button {\n        -webkit-transform: translate(16px, 0);\n        transform: translate(16px, 0);\n      }\n\n      :host([checked]:not([disabled])) .toggle-button {\n        background-color: var(--paper-toggle-button-checked-button-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-button;\n      }\n\n      :host([disabled]) .toggle-button {\n        background-color: #bdbdbd;\n        opacity: 1;\n      }\n\n      .toggle-ink {\n        position: absolute;\n        top: -14px;\n        left: -14px;\n        right: auto;\n        bottom: auto;\n        width: 48px;\n        height: 48px;\n        opacity: 0.5;\n        pointer-events: none;\n        color: var(--paper-toggle-button-unchecked-ink-color, var(--primary-text-color));\n\n        @apply --paper-toggle-button-unchecked-ink;\n      }\n\n      :host([checked]) .toggle-ink {\n        color: var(--paper-toggle-button-checked-ink-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-ink;\n      }\n\n      .toggle-container {\n        display: inline-block;\n        position: relative;\n        width: 36px;\n        height: 14px;\n        /* The toggle button has an absolute position of -3px; The extra 1px\n        /* accounts for the toggle button shadow box. */\n        margin: 4px 1px;\n      }\n\n      .toggle-label {\n        position: relative;\n        display: inline-block;\n        vertical-align: middle;\n        padding-left: var(--paper-toggle-button-label-spacing, 8px);\n        pointer-events: none;\n        color: var(--paper-toggle-button-label-color, var(--primary-text-color));\n      }\n\n      /* invalid state */\n      :host([invalid]) .toggle-bar {\n        background-color: var(--paper-toggle-button-invalid-bar-color, var(--error-color));\n      }\n\n      :host([invalid]) .toggle-button {\n        background-color: var(--paper-toggle-button-invalid-button-color, var(--error-color));\n      }\n\n      :host([invalid]) .toggle-ink {\n        color: var(--paper-toggle-button-invalid-ink-color, var(--error-color));\n      }\n    </style>\n\n    <div class="toggle-container">\n      <div id="toggleBar" class="toggle-bar"></div>\n      <div id="toggleButton" class="toggle-button"></div>\n    </div>\n\n    <div class="toggle-label"><slot></slot></div>\n\n  </template>\n\n  \n</dom-module>';

document.head.appendChild($_documentContainer);
(0, _polymerFn.Polymer)({
  is: 'paper-toggle-button',

  behaviors: [_paperCheckedElementBehavior.PaperCheckedElementBehavior],

  hostAttributes: {
    role: 'button',
    'aria-pressed': 'false',
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
  },

  listeners: {
    track: '_ontrack'
  },

  attached: function attached() {
    (0, _renderStatus.afterNextRender)(this, function () {
      (0, _gestures.setTouchAction)(this, 'pan-y');
    });
  },

  _ontrack: function _ontrack(event) {
    var track = event.detail;
    if (track.state === 'start') {
      this._trackStart(track);
    } else if (track.state === 'track') {
      this._trackMove(track);
    } else if (track.state === 'end') {
      this._trackEnd(track);
    }
  },

  _trackStart: function _trackStart(track) {
    this._width = this.$.toggleBar.offsetWidth / 2;
    /*
     * keep an track-only check state to keep the dragging behavior smooth
     * while toggling activations
     */
    this._trackChecked = this.checked;
    this.$.toggleButton.classList.add('dragging');
  },

  _trackMove: function _trackMove(track) {
    var dx = track.dx;
    this._x = Math.min(this._width, Math.max(0, this._trackChecked ? this._width + dx : dx));
    this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
    this._userActivate(this._x > this._width / 2);
  },

  _trackEnd: function _trackEnd(track) {
    this.$.toggleButton.classList.remove('dragging');
    this.transform('', this.$.toggleButton);
  },

  // customize the element's ripple
  _createRipple: function _createRipple() {
    this._rippleContainer = this.$.toggleButton;
    var ripple = _paperRippleBehavior.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('recenters', '');
    ripple.classList.add('circle', 'toggle-ink');
    return ripple;
  }

});

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


var _applyShim = __webpack_require__(95);

var _applyShim2 = _interopRequireDefault(_applyShim);

var _templateMap = __webpack_require__(62);

var _templateMap2 = _interopRequireDefault(_templateMap);

var _styleUtil = __webpack_require__(61);

var _applyShimUtils = __webpack_require__(96);

var ApplyShimUtils = _interopRequireWildcard(_applyShimUtils);

var _documentWait = __webpack_require__(63);

var _documentWait2 = _interopRequireDefault(_documentWait);

var _commonUtils = __webpack_require__(40);

var _customStyleInterface = __webpack_require__(64);

var _styleSettings = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @const {ApplyShim} */
var applyShim = new _applyShim2.default();

var ApplyShimInterface = function () {
  function ApplyShimInterface() {
    var _this = this;

    _classCallCheck(this, ApplyShimInterface);

    /** @type {?CustomStyleInterfaceInterface} */
    this.customStyleInterface = null;
    (0, _documentWait2.default)(function () {
      _this.ensure();
    });
    applyShim['invalidCallback'] = ApplyShimUtils.invalidate;
  }

  _createClass(ApplyShimInterface, [{
    key: 'ensure',
    value: function ensure() {
      var _this2 = this;

      if (this.customStyleInterface) {
        return;
      }
      this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
      if (this.customStyleInterface) {
        this.customStyleInterface['transformCallback'] = function (style) {
          applyShim.transformCustomStyle(style);
        };
        this.customStyleInterface['validateCallback'] = function () {
          requestAnimationFrame(function () {
            if (_this2.customStyleInterface['enqueued']) {
              _this2.flushCustomStyles();
            }
          });
        };
      }
    }
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     */

  }, {
    key: 'prepareTemplate',
    value: function prepareTemplate(template, elementName) {
      this.ensure();
      _templateMap2.default[elementName] = template;
      var ast = applyShim.transformTemplate(template, elementName);
      // save original style ast to use for revalidating instances
      template['_styleAst'] = ast;
    }
  }, {
    key: 'flushCustomStyles',
    value: function flushCustomStyles() {
      this.ensure();
      if (!this.customStyleInterface) {
        return;
      }
      var styles = this.customStyleInterface['processStyles']();
      if (!this.customStyleInterface['enqueued']) {
        return;
      }
      for (var i = 0; i < styles.length; i++) {
        var cs = styles[i];
        var style = this.customStyleInterface['getStyleForCustomStyle'](cs);
        if (style) {
          applyShim.transformCustomStyle(style);
        }
      }
      this.customStyleInterface['enqueued'] = false;
    }
    /**
     * @param {HTMLElement} element
     * @param {Object=} properties
     */

  }, {
    key: 'styleSubtree',
    value: function styleSubtree(element, properties) {
      this.ensure();
      if (properties) {
        (0, _commonUtils.updateNativeProperties)(element, properties);
      }
      if (element.shadowRoot) {
        this.styleElement(element);
        var shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
        for (var i = 0; i < shadowChildren.length; i++) {
          this.styleSubtree( /** @type {HTMLElement} */shadowChildren[i]);
        }
      } else {
        var children = element.children || element.childNodes;
        for (var _i = 0; _i < children.length; _i++) {
          this.styleSubtree( /** @type {HTMLElement} */children[_i]);
        }
      }
    }
    /**
     * @param {HTMLElement} element
     */

  }, {
    key: 'styleElement',
    value: function styleElement(element) {
      this.ensure();

      var _getIsExtends = (0, _styleUtil.getIsExtends)(element),
          is = _getIsExtends.is;

      var template = _templateMap2.default[is];
      if (template && !ApplyShimUtils.templateIsValid(template)) {
        // only revalidate template once
        if (!ApplyShimUtils.templateIsValidating(template)) {
          this.prepareTemplate(template, is);
          ApplyShimUtils.startValidatingTemplate(template);
        }
        // update this element instance
        var root = element.shadowRoot;
        if (root) {
          var style = /** @type {HTMLStyleElement} */root.querySelector('style');
          if (style) {
            // reuse the template's style ast, it has all the original css text
            style['__cssRules'] = template['_styleAst'];
            style.textContent = (0, _styleUtil.toCssText)(template['_styleAst']);
          }
        }
      }
    }
    /**
     * @param {Object=} properties
     */

  }, {
    key: 'styleDocument',
    value: function styleDocument(properties) {
      this.ensure();
      this.styleSubtree(document.body, properties);
    }
  }]);

  return ApplyShimInterface;
}();

if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  var applyShimInterface = new ApplyShimInterface();
  var CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;

  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate: function prepareTemplate(template, elementName, elementExtends) {
      // eslint-disable-line no-unused-vars
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName);
    },


    /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */
    styleSubtree: function styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },


    /**
     * @param {!HTMLElement} element
     */
    styleElement: function styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },


    /**
     * @param {Object=} properties
     */
    styleDocument: function styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },


    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue: function getComputedStyleValue(element, property) {
      return (0, _commonUtils.getComputedStyleValue)(element, property);
    },

    nativeCss: _styleSettings.nativeCssVariables,
    nativeShadow: _styleSettings.nativeShadow
  };

  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}

window.ShadyCSS.ApplyShim = applyShim;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/*
 * The apply shim simulates the behavior of `@apply` proposed at
 * https://tabatkins.github.io/specs/css-apply-rule/.
 * The approach is to convert a property like this:
 *
 *    --foo: {color: red; background: blue;}
 *
 * to this:
 *
 *    --foo_-_color: red;
 *    --foo_-_background: blue;
 *
 * Then where `@apply --foo` is used, that is converted to:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background);
 *
 * This approach generally works but there are some issues and limitations.
 * Consider, for example, that somewhere *between* where `--foo` is set and used,
 * another element sets it to:
 *
 *    --foo: { border: 2px solid red; }
 *
 * We must now ensure that the color and background from the previous setting
 * do not apply. This is accomplished by changing the property set to this:
 *
 *    --foo_-_border: 2px solid red;
 *    --foo_-_color: initial;
 *    --foo_-_background: initial;
 *
 * This works but introduces one new issue.
 * Consider this setup at the point where the `@apply` is used:
 *
 *    background: orange;
 *    `@apply` --foo;
 *
 * In this case the background will be unset (initial) rather than the desired
 * `orange`. We address this by altering the property set to use a fallback
 * value like this:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background, orange);
 *    border: var(--foo_-_border);
 *
 * Note that the default is retained in the property set and the `background` is
 * the desired `orange`. This leads us to a limitation.
 *
 * Limitation 1:

 * Only properties in the rule where the `@apply`
 * is used are considered as default values.
 * If another rule matches the element and sets `background` with
 * less specificity than the rule in which `@apply` appears,
 * the `background` will not be set.
 *
 * Limitation 2:
 *
 * When using Polymer's `updateStyles` api, new properties may not be set for
 * `@apply` properties.

*/



Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _styleUtil = __webpack_require__(61);

var _commonRegex = __webpack_require__(39);

var _commonUtils = __webpack_require__(40);

var _cssParse = __webpack_require__(38);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// eslint-disable-line no-unused-vars

var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;

// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
var MIXIN_VAR_SEP = '_-_';

/**
 * @typedef {!Object<string, string>}
 */
var PropertyEntry = void 0; // eslint-disable-line no-unused-vars

/**
 * @typedef {!Object<string, boolean>}
 */
var DependantsEntry = void 0; // eslint-disable-line no-unused-vars

/** @typedef {{
 *    properties: PropertyEntry,
 *    dependants: DependantsEntry
 * }}
 */
var MixinMapEntry = void 0; // eslint-disable-line no-unused-vars

// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}

var MixinMap = function () {
  function MixinMap() {
    _classCallCheck(this, MixinMap);

    /** @type {!Object<string, !MixinMapEntry>} */
    this._map = {};
  }
  /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */


  _createClass(MixinMap, [{
    key: 'set',
    value: function set(name, props) {
      name = name.trim();
      this._map[name] = {
        properties: props,
        dependants: {}
      };
    }
    /**
     * @param {string} name
     * @return {MixinMapEntry}
     */

  }, {
    key: 'get',
    value: function get(name) {
      name = name.trim();
      return this._map[name] || null;
    }
  }]);

  return MixinMap;
}();

/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */


var invalidCallback = null;

/** @unrestricted */

var ApplyShim = function () {
  function ApplyShim() {
    _classCallCheck(this, ApplyShim);

    /** @type {?string} */
    this._currentElement = null;
    /** @type {HTMLMetaElement} */
    this._measureElement = null;
    this._map = new MixinMap();
  }
  /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */


  _createClass(ApplyShim, [{
    key: 'detectMixin',
    value: function detectMixin(cssText) {
      return (0, _commonUtils.detectMixin)(cssText);
    }
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @return {StyleNode}
     */

  }, {
    key: 'transformTemplate',
    value: function transformTemplate(template, elementName) {
      var style = /** @type {HTMLStyleElement} */template.content.querySelector('style');
      /** @type {StyleNode} */
      var ast = null;
      if (style) {
        ast = this.transformStyle(style, elementName);
      }
      return ast;
    }
    /**
     * @param {!HTMLStyleElement} style
     * @param {string} elementName
     * @return {StyleNode}
     */

  }, {
    key: 'transformStyle',
    value: function transformStyle(style) {
      var elementName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var ast = (0, _styleUtil.rulesForStyle)(style);
      this.transformRules(ast, elementName);
      style.textContent = (0, _styleUtil.toCssText)(ast);
      return ast;
    }
    /**
     * @param {!HTMLStyleElement} style
     * @return {StyleNode}
     */

  }, {
    key: 'transformCustomStyle',
    value: function transformCustomStyle(style) {
      var _this = this;

      var ast = (0, _styleUtil.rulesForStyle)(style);
      (0, _styleUtil.forEachRule)(ast, function (rule) {
        if (rule['selector'] === ':root') {
          rule['selector'] = 'html';
        }
        _this.transformRule(rule);
      });
      style.textContent = (0, _styleUtil.toCssText)(ast);
      return ast;
    }
    /**
     * @param {StyleNode} rules
     * @param {string} elementName
     */

  }, {
    key: 'transformRules',
    value: function transformRules(rules, elementName) {
      var _this2 = this;

      this._currentElement = elementName;
      (0, _styleUtil.forEachRule)(rules, function (r) {
        _this2.transformRule(r);
      });
      this._currentElement = null;
    }
    /**
     * @param {!StyleNode} rule
     */

  }, {
    key: 'transformRule',
    value: function transformRule(rule) {
      rule['cssText'] = this.transformCssText(rule['parsedCssText']);
      // :root was only used for variable assignment in property shim,
      // but generates invalid selectors with real properties.
      // replace with `:host > *`, which serves the same effect
      if (rule['selector'] === ':root') {
        rule['selector'] = ':host > *';
      }
    }
    /**
     * @param {string} cssText
     * @return {string}
     */

  }, {
    key: 'transformCssText',
    value: function transformCssText(cssText) {
      var _this3 = this;

      // produce variables
      cssText = cssText.replace(_commonRegex.VAR_ASSIGN, function (matchText, propertyName, valueProperty, valueMixin) {
        return _this3._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);
      });
      // consume mixins
      return this._consumeCssProperties(cssText);
    }
    /**
     * @param {string} property
     * @return {string}
     */

  }, {
    key: '_getInitialValueForProperty',
    value: function _getInitialValueForProperty(property) {
      if (!this._measureElement) {
        this._measureElement = /** @type {HTMLMetaElement} */document.createElement('meta');
        this._measureElement.setAttribute('apply-shim-measure', '');
        this._measureElement.style.all = 'initial';
        document.head.appendChild(this._measureElement);
      }
      return window.getComputedStyle(this._measureElement).getPropertyValue(property);
    }
    /**
     * replace mixin consumption with variable consumption
     * @param {string} text
     * @return {string}
     */

  }, {
    key: '_consumeCssProperties',
    value: function _consumeCssProperties(text) {
      /** @type {Array} */
      var m = null;
      // loop over text until all mixins with defintions have been applied
      while (m = _commonRegex.MIXIN_MATCH.exec(text)) {
        var matchText = m[0];
        var mixinName = m[1];
        var idx = m.index;
        // collect properties before apply to be "defaults" if mixin might override them
        // match includes a "prefix", so find the start and end positions of @apply
        var applyPos = idx + matchText.indexOf('@apply');
        var afterApplyPos = idx + matchText.length;
        // find props defined before this @apply
        var textBeforeApply = text.slice(0, applyPos);
        var textAfterApply = text.slice(afterApplyPos);
        var defaults = this._cssTextToMap(textBeforeApply);
        var replacement = this._atApplyToCssProperties(mixinName, defaults);
        // use regex match position to replace mixin, keep linear processing time
        text = '' + textBeforeApply + replacement + textAfterApply;
        // move regex search to _after_ replacement
        _commonRegex.MIXIN_MATCH.lastIndex = idx + replacement.length;
      }
      return text;
    }
    /**
     * produce variable consumption at the site of mixin consumption
     * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
     * Example:
     *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
     *
     * @param {string} mixinName
     * @param {Object} fallbacks
     * @return {string}
     */

  }, {
    key: '_atApplyToCssProperties',
    value: function _atApplyToCssProperties(mixinName, fallbacks) {
      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
      var vars = [];
      var mixinEntry = this._map.get(mixinName);
      // if we depend on a mixin before it is created
      // make a sentinel entry in the map to add this element as a dependency for when it is defined.
      if (!mixinEntry) {
        this._map.set(mixinName, {});
        mixinEntry = this._map.get(mixinName);
      }
      if (mixinEntry) {
        if (this._currentElement) {
          mixinEntry.dependants[this._currentElement] = true;
        }
        var p = void 0,
            parts = void 0,
            f = void 0;
        for (p in mixinEntry.properties) {
          f = fallbacks && fallbacks[p];
          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
          if (f) {
            parts.push(',', f);
          }
          parts.push(')');
          vars.push(parts.join(''));
        }
      }
      return vars.join('; ');
    }

    /**
     * @param {string} property
     * @param {string} value
     * @return {string}
     */

  }, {
    key: '_replaceInitialOrInherit',
    value: function _replaceInitialOrInherit(property, value) {
      var match = INITIAL_INHERIT.exec(value);
      if (match) {
        if (match[1]) {
          // initial
          // replace `initial` with the concrete initial value for this property
          value = this._getInitialValueForProperty(property);
        } else {
          // inherit
          // with this purposfully illegal value, the variable will be invalid at
          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
          // and for inheriting values, will behave similarly
          // we cannot support the same behavior for non inheriting values like 'border'
          value = 'apply-shim-inherit';
        }
      }
      return value;
    }

    /**
     * "parse" a mixin definition into a map of properties and values
     * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
     * @param {string} text
     * @return {!Object<string, string>}
     */

  }, {
    key: '_cssTextToMap',
    value: function _cssTextToMap(text) {
      var props = text.split(';');
      var property = void 0,
          value = void 0;
      var out = {};
      for (var i = 0, p, sp; i < props.length; i++) {
        p = props[i];
        if (p) {
          sp = p.split(':');
          // ignore lines that aren't definitions like @media
          if (sp.length > 1) {
            property = sp[0].trim();
            // some properties may have ':' in the value, like data urls
            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
            out[property] = value;
          }
        }
      }
      return out;
    }

    /**
     * @param {MixinMapEntry} mixinEntry
     */

  }, {
    key: '_invalidateMixinEntry',
    value: function _invalidateMixinEntry(mixinEntry) {
      if (!invalidCallback) {
        return;
      }
      for (var elementName in mixinEntry.dependants) {
        if (elementName !== this._currentElement) {
          invalidCallback(elementName);
        }
      }
    }

    /**
     * @param {string} matchText
     * @param {string} propertyName
     * @param {?string} valueProperty
     * @param {?string} valueMixin
     * @return {string}
     */

  }, {
    key: '_produceCssProperties',
    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
      var _this4 = this;

      // handle case where property value is a mixin
      if (valueProperty) {
        // form: --mixin2: var(--mixin1), where --mixin1 is in the map
        (0, _styleUtil.processVariableAndFallback)(valueProperty, function (prefix, value) {
          if (value && _this4._map.get(value)) {
            valueMixin = '@apply ' + value + ';';
          }
        });
      }
      if (!valueMixin) {
        return matchText;
      }
      var mixinAsProperties = this._consumeCssProperties(valueMixin);
      var prefix = matchText.slice(0, matchText.indexOf('--'));
      var mixinValues = this._cssTextToMap(mixinAsProperties);
      var combinedProps = mixinValues;
      var mixinEntry = this._map.get(propertyName);
      var oldProps = mixinEntry && mixinEntry.properties;
      if (oldProps) {
        // NOTE: since we use mixin, the map of properties is updated here
        // and this is what we want.
        combinedProps = Object.assign(Object.create(oldProps), mixinValues);
      } else {
        this._map.set(propertyName, combinedProps);
      }
      var out = [];
      var p = void 0,
          v = void 0;
      // set variables defined by current mixin
      var needToInvalidate = false;
      for (p in combinedProps) {
        v = mixinValues[p];
        // if property not defined by current mixin, set initial
        if (v === undefined) {
          v = 'initial';
        }
        if (oldProps && !(p in oldProps)) {
          needToInvalidate = true;
        }
        out.push('' + propertyName + MIXIN_VAR_SEP + p + ': ' + v);
      }
      if (needToInvalidate) {
        this._invalidateMixinEntry(mixinEntry);
      }
      if (mixinEntry) {
        mixinEntry.properties = combinedProps;
      }
      // because the mixinMap is global, the mixin might conflict with
      // a different scope's simple variable definition:
      // Example:
      // some style somewhere:
      // --mixin1:{ ... }
      // --mixin2: var(--mixin1);
      // some other element:
      // --mixin1: 10px solid red;
      // --foo: var(--mixin1);
      // In this case, we leave the original variable definition in place.
      if (valueProperty) {
        prefix = matchText + ';' + prefix;
      }
      return '' + prefix + out.join('; ') + ';';
    }
  }]);

  return ApplyShim;
}();

/* exports */


ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  /** @return {?function(string)} */
  get: function get() {
    return invalidCallback;
  },

  /** @param {?function(string)} cb */
  set: function set(cb) {
    invalidCallback = cb;
  }
});

exports.default = ApplyShim;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invalidate = invalidate;
exports.invalidateTemplate = invalidateTemplate;
exports.isValid = isValid;
exports.templateIsValid = templateIsValid;
exports.isValidating = isValidating;
exports.templateIsValidating = templateIsValidating;
exports.startValidating = startValidating;
exports.startValidatingTemplate = startValidatingTemplate;
exports.elementsAreInvalid = elementsAreInvalid;

var _templateMap = __webpack_require__(62);

var _templateMap2 = _interopRequireDefault(_templateMap);

var _cssParse = __webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line no-unused-vars

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */
var CURRENT_VERSION = '_applyShimCurrentVersion';

/** @const {string} */
var NEXT_VERSION = '_applyShimNextVersion';

/** @const {string} */
var VALIDATING_VERSION = '_applyShimValidatingVersion';

/**
 * @const {Promise<void>}
 */
var promise = Promise.resolve();

/**
 * @param {string} elementName
 */
function invalidate(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */
function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  // ensure the "validating for" flag exists
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  // increment the next version
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValid(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    return templateIsValid(template);
  }
  return true;
}

/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValidating(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    return templateIsValidating(template);
  }
  return false;
}

/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}

/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
*/
function startValidating(elementName) {
  var template = _templateMap2.default[elementName];
  startValidatingTemplate(template);
}

/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */
function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  // however, there only needs to be one async task to clear the counters
  if (!template._validating) {
    template._validating = true;
    promise.then(function () {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
 * @return {boolean}
 */
function elementsAreInvalid() {
  for (var elementName in _templateMap2.default) {
    var template = _templateMap2.default[elementName];
    if (!templateIsValid(template)) {
      return true;
    }
  }
  return false;
}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.importHref = undefined;

__webpack_require__(2);

// run a callback when HTMLImports are ready or immediately if
// this api is not available.
function whenImportsReady(cb) {
  if (window.HTMLImports) {
    HTMLImports.whenReady(cb);
  } else {
    cb();
  }
}

var importHref = exports.importHref = function importHref(href, onload, onerror, optAsync) {
  var link = /** @type {HTMLLinkElement} */
  document.head.querySelector('link[href="' + href + '"][import-href]');
  if (!link) {
    link = /** @type {HTMLLinkElement} */document.createElement('link');
    link.rel = 'import';
    link.href = href;
    link.setAttribute('import-href', '');
  }
  // always ensure link has `async` attribute if user specified one,
  // even if it was previously not async. This is considered less confusing.
  if (optAsync) {
    link.setAttribute('async', '');
  }
  // NOTE: the link may now be in 3 states: (1) pending insertion,
  // (2) inflight, (3) already laoded. In each case, we need to add
  // event listeners to process callbacks.
  var cleanup = function cleanup() {
    link.removeEventListener('load', loadListener);
    link.removeEventListener('error', errorListener);
  };
  var loadListener = function loadListener(event) {
    cleanup();
    // In case of a successful load, cache the load event on the link so
    // that it can be used to short-circuit this method in the future when
    // it is called with the same href param.
    link.__dynamicImportLoaded = true;
    if (onload) {
      whenImportsReady(function () {
        onload(event);
      });
    }
  };
  var errorListener = function errorListener(event) {
    cleanup();
    // In case of an error, remove the link from the document so that it
    // will be automatically created again the next time `importHref` is
    // called.
    if (link.parentNode) {
      link.parentNode.removeChild(link);
    }
    if (onerror) {
      whenImportsReady(function () {
        onerror(event);
      });
    }
  };
  link.addEventListener('load', loadListener);
  link.addEventListener('error', errorListener);
  if (link.parentNode == null) {
    document.head.appendChild(link);
    // if the link already loaded, dispatch a fake load event
    // so that listeners are called and get a proper event argument.
  } else if (link.__dynamicImportLoaded) {
    link.dispatchEvent(new Event('load'));
  }
  return link;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function resolve() {
  document.body.removeAttribute('unresolved');
}

if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mixinBehaviors = exports.Class = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _legacyElementMixin = __webpack_require__(60);

var _domModule = __webpack_require__(59);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var metaProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  // meta objects
  behaviors: true
};

/**
 * Applies a "legacy" behavior or array of behaviors to the provided class.
 *
 * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
 * to ensure that any legacy behaviors can rely on legacy Polymer API on
 * the underlying element.
 *
 * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
 * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
 * @return {function(new:HTMLElement)} Returns a new Element class extended by the
 * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
 * @memberof Polymer
 * @suppress {invalidCasts, checkTypes}
 */
function mixinBehaviors(behaviors, klass) {
  if (!behaviors) {
    return (/** @type {HTMLElement} */klass
    );
  }
  // NOTE: ensure the bahevior is extending a class with
  // legacy element api. This is necessary since behaviors expect to be able
  // to access 1.x legacy api.
  klass = (0, _legacyElementMixin.LegacyElementMixin)(klass);
  if (!Array.isArray(behaviors)) {
    behaviors = [behaviors];
  }
  var superBehaviors = klass.prototype.behaviors;
  // get flattened, deduped list of behaviors *not* already on super class
  behaviors = flattenBehaviors(behaviors, null, superBehaviors);
  // mixin new behaviors
  klass = _mixinBehaviors(behaviors, klass);
  if (superBehaviors) {
    behaviors = superBehaviors.concat(behaviors);
  }
  // Set behaviors on prototype for BC...
  klass.prototype.behaviors = behaviors;
  return klass;
}

// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function _mixinBehaviors(behaviors, klass) {
  for (var i = 0; i < behaviors.length; i++) {
    var b = behaviors[i];
    if (b) {
      klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
    }
  }
  return klass;
}

/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (var i = behaviors.length - 1; i >= 0; i--) {
    var b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        // dedup
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}

/**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */
function GenerateClassFromInfo(info, Base) {
  var PolymerGenerated = function (_Base) {
    _inherits(PolymerGenerated, _Base);

    function PolymerGenerated() {
      _classCallCheck(this, PolymerGenerated);

      return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
    }

    _createClass(PolymerGenerated, [{
      key: 'created',
      value: function created() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
        if (info.created) {
          info.created.call(this);
        }
      }
    }, {
      key: '_registered',
      value: function _registered() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
        /* NOTE: `beforeRegister` is called here for bc, but the behavior
         is different than in 1.x. In 1.0, the method was called *after*
         mixing prototypes together but *before* processing of meta-objects.
         However, dynamic effects can still be set here and can be done either
         in `beforeRegister` or `registered`. It is no longer possible to set
         `is` in `beforeRegister` as you could in 1.x.
        */
        if (info.beforeRegister) {
          info.beforeRegister.call(Object.getPrototypeOf(this));
        }
        if (info.registered) {
          info.registered.call(Object.getPrototypeOf(this));
        }
      }
    }, {
      key: '_applyListeners',
      value: function _applyListeners() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
        if (info.listeners) {
          for (var l in info.listeners) {
            this._addMethodEventListenerToNode(this, l, info.listeners[l]);
          }
        }
      }

      // note: exception to "super then me" rule;
      // do work before calling super so that super attributes
      // only apply if not already set.

    }, {
      key: '_ensureAttributes',
      value: function _ensureAttributes() {
        if (info.hostAttributes) {
          for (var a in info.hostAttributes) {
            this._ensureAttribute(a, info.hostAttributes[a]);
          }
        }
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
      }
    }, {
      key: 'ready',
      value: function ready() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
        if (info.ready) {
          info.ready.call(this);
        }
      }
    }, {
      key: 'attached',
      value: function attached() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
        if (info.attached) {
          info.attached.call(this);
        }
      }
    }, {
      key: 'detached',
      value: function detached() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
        if (info.detached) {
          info.detached.call(this);
        }
      }
    }, {
      key: 'attributeChanged',
      value: function attributeChanged(name, old, value) {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
        if (info.attributeChanged) {
          info.attributeChanged.call(this, name, old, value);
        }
      }
    }], [{
      key: 'properties',
      get: function get() {
        return info.properties;
      }
    }, {
      key: 'observers',
      get: function get() {
        return info.observers;
      }

      /**
       * @return {HTMLTemplateElement} template for this class
       */

    }, {
      key: 'template',
      get: function get() {
        // get template first from any imperative set in `info._template`
        return info._template ||
        // next look in dom-module associated with this element's is.
        _domModule.DomModule && _domModule.DomModule.import(this.is, 'template') ||
        // next look for superclass template (note: use superclass symbol
        // to ensure correct `this.is`)
        Base.template ||
        // finally fall back to `_template` in element's protoype.
        this.prototype._template || null;
      }
    }]);

    return PolymerGenerated;
  }(Base);

  PolymerGenerated.generatedFrom = info;

  for (var p in info) {
    // NOTE: cannot copy `metaProps` methods onto prototype at least because
    // `super.ready` must be called and is not included in the user fn.
    if (!(p in metaProps)) {
      var pd = Object.getOwnPropertyDescriptor(info, p);
      if (pd) {
        Object.defineProperty(PolymerGenerated.prototype, p, pd);
      }
    }
  }

  return PolymerGenerated;
}

var Class = exports.Class = function Class(info) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  var klass = GenerateClassFromInfo(info, info.behaviors ?
  // note: mixinBehaviors ensures `LegacyElementMixin`.
  mixinBehaviors(info.behaviors, HTMLElement) : (0, _legacyElementMixin.LegacyElementMixin)(HTMLElement));
  // decorate klass with registration info
  klass.is = info.is;
  return klass;
};

exports.mixinBehaviors = mixinBehaviors;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Templatizer = undefined;

var _templatize = __webpack_require__(43);

var TemplateInstanceBase = _templatize.TemplateInstanceBase; // eslint-disable-line

/**
 * @typedef {{
 *   _templatizerTemplate: HTMLTemplateElement,
 *   _parentModel: boolean,
 *   _instanceProps: Object,
 *   _forwardHostPropV2: Function,
 *   _notifyInstancePropV2: Function,
 *   ctor: TemplateInstanceBase
 * }}
 */
var TemplatizerUser = void 0; // eslint-disable-line

/**
 * The `Polymer.Templatizer` behavior adds methods to generate instances of
 * templates that are each managed by an anonymous `Polymer.PropertyEffects`
 * instance where data-bindings in the stamped template content are bound to
 * accessors on itself.
 *
 * This behavior is provided in Polymer 2.x as a hybrid-element convenience
 * only.  For non-hybrid usage, the `Polymer.Templatize` library
 * should be used instead.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     this.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = this.stamp({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. light DOM
 *     Polymer.dom(this).appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * Users of `Templatizer` may need to implement the following abstract
 * API's to determine how properties and paths from the host should be
 * forwarded into to instances:
 *
 *     _forwardHostPropV2: function(prop, value)
 *
 * Likewise, users may implement these additional abstract API's to determine
 * how instance-specific properties that change on the instance should be
 * forwarded out to the host, if necessary.
 *
 *     _notifyInstancePropV2: function(inst, prop, value)
 *
 * In order to determine which properties are instance-specific and require
 * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
 * object containing keys for each instance prop, for example:
 *
 *     _instanceProps: {
 *       item: true,
 *       index: true
 *     }
 *
 * Any properties used in the template that are not defined in _instanceProp
 * will be forwarded out to the Templatize `owner` automatically.
 *
 * Users may also implement the following abstract function to show or
 * hide any DOM generated using `stamp`:
 *
 *     _showHideChildren: function(shouldHide)
 *
 * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
 * as the implementations will need to differ from the callbacks required
 * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
 * between versions 1.x and 2.x.
 *
 * @polymerBehavior
 * @memberof Polymer
 */
var Templatizer = {

  /**
   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
   * for the provided template.  This method should be called once per
   * template to prepare an element for stamping the template, followed
   * by `stamp` to create new instances of the template.
   *
   * @param {HTMLTemplateElement} template Template to prepare
   * @param {boolean=} mutableData When `true`, the generated class will skip
   *   strict dirty-checking for objects and arrays (always consider them to
   *   be "dirty"). Defaults to false.
   * @this {TemplatizerUser}
   */
  templatize: function templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = _templatize.Templatize.templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },


  /**
   * Creates an instance of the template prepared by `templatize`.  The object
   * returned is an instance of the anonymous class generated by `templatize`
   * whose `root` property is a document fragment containing newly cloned
   * template content, and which has property accessors corresponding to
   * properties referenced in template bindings.
   *
   * @param {Object=} model Object containing initial property values to
   *   populate into the template bindings.
   * @return {TemplateInstanceBase} Returns the created instance of
   * the template prepared by `templatize`.
   * @this {TemplatizerUser}
   */
  stamp: function stamp(model) {
    return new this.ctor(model);
  },


  /**
   * Returns the template "model" (`TemplateInstance`) associated with
   * a given element, which serves as the binding scope for the template
   * instance the element is contained in.  A template model should be used
   * to manipulate data associated with this template instance.
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   * @this {TemplatizerUser}
   */
  modelForElement: function modelForElement(el) {
    return _templatize.Templatize.modelForElement(this._templatizerTemplate, el);
  }
};

exports.Templatizer = Templatizer;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomBind = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _propertyEffects = __webpack_require__(36);

var _mutableData = __webpack_require__(29);

var _gestureEventListeners = __webpack_require__(65);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 */
var domBindBase = (0, _gestureEventListeners.GestureEventListeners)((0, _mutableData.OptionalMutableData)((0, _propertyEffects.PropertyEffects)(HTMLElement)));

/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @appliesMixin Polymer.OptionalMutableData
 * @appliesMixin Polymer.GestureEventListeners
 * @extends {domBindBase}
 * @memberof Polymer
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */

var DomBind = function (_domBindBase) {
  _inherits(DomBind, _domBindBase);

  _createClass(DomBind, null, [{
    key: 'observedAttributes',
    get: function get() {
      return ['mutable-data'];
    }
  }]);

  function DomBind() {
    _classCallCheck(this, DomBind);

    var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

    _this.root = null;
    _this.$ = null;
    _this.__children = null;
    return _this;
  }

  // assumes only one observed attribute


  _createClass(DomBind, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback() {
      this.mutableData = true;
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.render();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.__removeChildren();
    }
  }, {
    key: '__insertChildren',
    value: function __insertChildren() {
      this.parentNode.insertBefore(this.root, this);
    }
  }, {
    key: '__removeChildren',
    value: function __removeChildren() {
      if (this.__children) {
        for (var i = 0; i < this.__children.length; i++) {
          this.root.appendChild(this.__children[i]);
        }
      }
    }

    /**
     * Forces the element to render its content. This is typically only
     * necessary to call if HTMLImports with the async attribute are used.
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var template = void 0;
      if (!this.__children) {
        template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
        if (!template) {
          // Wait until childList changes and template should be there by then
          var observer = new MutationObserver(function () {
            template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
            if (template) {
              observer.disconnect();
              _this2.render();
            } else {
              throw new Error('dom-bind requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return;
        }
        this.root = this._stampTemplate(template);
        this.$ = this.root.$;
        this.__children = [];
        for (var n = this.root.firstChild; n; n = n.nextSibling) {
          this.__children[this.__children.length] = n;
        }
        this._enableProperties();
      }
      this.__insertChildren();
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
    }
  }]);

  return DomBind;
}(domBindBase);

customElements.define('dom-bind', DomBind);

exports.DomBind = DomBind;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomIf = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _templatize = __webpack_require__(43);

var _debounce = __webpack_require__(27);

var _flush = __webpack_require__(42);

var _async = __webpack_require__(15);

var _path = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsey, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends Polymer.Element
 * @memberof Polymer
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */
var DomIf = function (_Element) {
  _inherits(DomIf, _Element);

  _createClass(DomIf, null, [{
    key: 'is',


    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'dom-if';
    }
  }, {
    key: 'template',
    get: function get() {
      return null;
    }
  }, {
    key: 'properties',
    get: function get() {

      return {

        /**
         * Fired whenever DOM is added or removed/hidden by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */

        /**
         * A boolean indicating whether this template should stamp.
         */
        if: {
          type: Boolean,
          observer: '__debounceRender'
        },

        /**
         * When true, elements will be removed from DOM and discarded when `if`
         * becomes false and re-created and added back to the DOM when `if`
         * becomes true.  By default, stamped elements will be hidden but left
         * in the DOM when `if` becomes false, which is generally results
         * in better performance.
         */
        restamp: {
          type: Boolean,
          observer: '__debounceRender'
        }

      };
    }
  }]);

  function DomIf() {
    _classCallCheck(this, DomIf);

    var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

    _this.__renderDebouncer = null;
    _this.__invalidProps = null;
    _this.__instance = null;
    _this._lastIf = false;
    _this.__ctor = null;
    return _this;
  }

  _createClass(DomIf, [{
    key: '__debounceRender',
    value: function __debounceRender() {
      var _this2 = this;

      // Render is async for 2 reasons:
      // 1. To eliminate dom creation trashing if user code thrashes `if` in the
      //    same turn. This was more common in 1.x where a compound computed
      //    property could result in the result changing multiple times, but is
      //    mitigated to a large extent by batched property processing in 2.x.
      // 2. To avoid double object propagation when a bag including values bound
      //    to the `if` property as well as one or more hostProps could enqueue
      //    the <dom-if> to flush before the <template>'s host property
      //    forwarding. In that scenario creating an instance would result in
      //    the host props being set once, and then the enqueued changes on the
      //    template would set properties a second time, potentially causing an
      //    object to be set to an instance more than once.  Creating the
      //    instance async from flushing data ensures this doesn't happen. If
      //    we wanted a sync option in the future, simply having <dom-if> flush
      //    (or clear) its template's pending host properties before creating
      //    the instance would also avoid the problem.
      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, _async.microTask, function () {
        return _this2.__render();
      });
      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
      if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
        this.__teardownInstance();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
      if (this.if) {
        this.__debounceRender();
      }
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */

  }, {
    key: 'render',
    value: function render() {
      (0, _flush.flush)();
    }
  }, {
    key: '__render',
    value: function __render() {
      if (this.if) {
        if (!this.__ensureInstance()) {
          // No template found yet
          return;
        }
        this._showHideChildren();
      } else if (this.restamp) {
        this.__teardownInstance();
      }
      if (!this.restamp && this.__instance) {
        this._showHideChildren();
      }
      if (this.if != this._lastIf) {
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        this._lastIf = this.if;
      }
    }
  }, {
    key: '__ensureInstance',
    value: function __ensureInstance() {
      var _this3 = this;

      var parentNode = this.parentNode;
      // Guard against element being detached while render was queued
      if (parentNode) {
        if (!this.__ctor) {
          var template = this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this3.querySelector('template')) {
                observer.disconnect();
                _this3.__render();
              } else {
                throw new Error('dom-if requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          this.__ctor = _templatize.Templatize.templatize(template, this, {
            // dom-if templatizer instances require `mutable: true`, as
            // `__syncHostProperties` relies on that behavior to sync objects
            mutableData: true,
            /**
             * @param {string} prop Property to forward
             * @param {*} value Value of property
             * @this {this}
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              if (this.__instance) {
                if (this.if) {
                  this.__instance.forwardHostProp(prop, value);
                } else {
                  // If we have an instance but are squelching host property
                  // forwarding due to if being false, note the invalidated
                  // properties so `__syncHostProperties` can sync them the next
                  // time `if` becomes true
                  this.__invalidProps = this.__invalidProps || Object.create(null);
                  this.__invalidProps[(0, _path.root)(prop)] = true;
                }
              }
            }
          });
        }
        if (!this.__instance) {
          this.__instance = new this.__ctor();
          parentNode.insertBefore(this.__instance.root, this);
        } else {
          this.__syncHostProperties();
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // Detect case where dom-if was re-attached in new position
            var lastChild = this.previousSibling;
            if (lastChild !== c$[c$.length - 1]) {
              for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                parentNode.insertBefore(n, this);
              }
            }
          }
        }
      }
      return true;
    }
  }, {
    key: '__syncHostProperties',
    value: function __syncHostProperties() {
      var props = this.__invalidProps;
      if (props) {
        for (var prop in props) {
          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
        }
        this.__invalidProps = null;
        this.__instance._flushProperties();
      }
    }
  }, {
    key: '__teardownInstance',
    value: function __teardownInstance() {
      if (this.__instance) {
        var c$ = this.__instance.children;
        if (c$ && c$.length) {
          // use first child parent, for case when dom-if may have been detached
          var parent = c$[0].parentNode;
          for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
            parent.removeChild(n);
          }
        }
        this.__instance = null;
        this.__invalidProps = null;
      }
    }
  }, {
    key: '_showHideChildren',
    value: function _showHideChildren() {
      var hidden = this.__hideTemplateChildren__ || !this.if;
      if (this.__instance) {
        this.__instance._showHideChildren(hidden);
      }
    }
  }]);

  return DomIf;
}(_polymerElement.Element);

customElements.define(DomIf.is, DomIf);

exports.DomIf = DomIf;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArraySelector = exports.ArraySelectorMixin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _mixin = __webpack_require__(13);

var _arraySplice = __webpack_require__(68);

var _elementMixin = __webpack_require__(33);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin Polymer.ElementMixin
 * @memberof Polymer
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */
var ArraySelectorMixin = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_ElementMixin}
   */
  var elementBase = (0, _elementMixin.ElementMixin)(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */

  var ArraySelectorMixin = function (_elementBase) {
    _inherits(ArraySelectorMixin, _elementBase);

    _createClass(ArraySelectorMixin, null, [{
      key: 'properties',
      get: function get() {

        return {

          /**
           * An array containing items from which selection will be made.
           */
          items: {
            type: Array
          },

          /**
           * When `true`, multiple items may be selected at once (in this case,
           * `selected` is an array of currently selected items).  When `false`,
           * only one item may be selected at a time.
           */
          multi: {
            type: Boolean,
            value: false
          },

          /**
           * When `multi` is true, this is an array that contains any selected.
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?(Object|Array<!Object>)}
           */
          selected: {
            type: Object,
            notify: true
          },

          /**
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?Object}
           */
          selectedItem: {
            type: Object,
            notify: true
          },

          /**
           * When `true`, calling `select` on an item that is already selected
           * will deselect the item.
           */
          toggle: {
            type: Boolean,
            value: false
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__updateSelection(multi, items.*)'];
      }
    }]);

    function ArraySelectorMixin() {
      _classCallCheck(this, ArraySelectorMixin);

      var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

      _this.__lastItems = null;
      _this.__lastMulti = null;
      _this.__selectedMap = null;
      return _this;
    }

    _createClass(ArraySelectorMixin, [{
      key: '__updateSelection',
      value: function __updateSelection(multi, itemsInfo) {
        var path = itemsInfo.path;
        if (path == 'items') {
          // Case 1 - items array changed, so diff against previous array and
          // deselect any removed items and adjust selected indices
          var newItems = itemsInfo.base || [];
          var lastItems = this.__lastItems;
          var lastMulti = this.__lastMulti;
          if (multi !== lastMulti) {
            this.clearSelection();
          }
          if (lastItems) {
            var splices = (0, _arraySplice.calculateSplices)(newItems, lastItems);
            this.__applySplices(splices);
          }
          this.__lastItems = newItems;
          this.__lastMulti = multi;
        } else if (itemsInfo.path == 'items.splices') {
          // Case 2 - got specific splice information describing the array mutation:
          // deselect any removed items and adjust selected indices
          this.__applySplices(itemsInfo.value.indexSplices);
        } else {
          // Case 3 - an array element was changed, so deselect the previous
          // item for that index if it was previously selected
          var part = path.slice('items.'.length);
          var idx = parseInt(part, 10);
          if (part.indexOf('.') < 0 && part == idx) {
            this.__deselectChangedIdx(idx);
          }
        }
      }
    }, {
      key: '__applySplices',
      value: function __applySplices(splices) {
        var _this2 = this;

        var selected = this.__selectedMap;
        // Adjust selected indices and mark removals

        var _loop = function _loop(i) {
          var s = splices[i];
          selected.forEach(function (idx, item) {
            if (idx < s.index) {
              // no change
            } else if (idx >= s.index + s.removed.length) {
              // adjust index
              selected.set(item, idx + s.addedCount - s.removed.length);
            } else {
              // remove index
              selected.set(item, -1);
            }
          });
          for (var j = 0; j < s.addedCount; j++) {
            var idx = s.index + j;
            if (selected.has(_this2.items[idx])) {
              selected.set(_this2.items[idx], idx);
            }
          }
        };

        for (var i = 0; i < splices.length; i++) {
          _loop(i);
        }
        // Update linked paths
        this.__updateLinks();
        // Remove selected items that were removed from the items array
        var sidx = 0;
        selected.forEach(function (idx, item) {
          if (idx < 0) {
            if (_this2.multi) {
              _this2.splice('selected', sidx, 1);
            } else {
              _this2.selected = _this2.selectedItem = null;
            }
            selected.delete(item);
          } else {
            sidx++;
          }
        });
      }
    }, {
      key: '__updateLinks',
      value: function __updateLinks() {
        var _this3 = this;

        this.__dataLinkedPaths = {};
        if (this.multi) {
          var sidx = 0;
          this.__selectedMap.forEach(function (idx) {
            if (idx >= 0) {
              _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
            }
          });
        } else {
          this.__selectedMap.forEach(function (idx) {
            _this3.linkPaths('selected', 'items.' + idx);
            _this3.linkPaths('selectedItem', 'items.' + idx);
          });
        }
      }

      /**
       * Clears the selection state.
       *
       */

    }, {
      key: 'clearSelection',
      value: function clearSelection() {
        // Unbind previous selection
        this.__dataLinkedPaths = {};
        // The selected map stores 3 pieces of information:
        // key: items array object
        // value: items array index
        // order: selected array index
        this.__selectedMap = new Map();
        // Initialize selection
        this.selected = this.multi ? [] : null;
        this.selectedItem = null;
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {*} item Item from `items` array to test
       * @return {boolean} Whether the item is selected
       */

    }, {
      key: 'isSelected',
      value: function isSelected(item) {
        return this.__selectedMap.has(item);
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {number} idx Index from `items` array to test
       * @return {boolean} Whether the item is selected
       */

    }, {
      key: 'isIndexSelected',
      value: function isIndexSelected(idx) {
        return this.isSelected(this.items[idx]);
      }
    }, {
      key: '__deselectChangedIdx',
      value: function __deselectChangedIdx(idx) {
        var _this4 = this;

        var sidx = this.__selectedIndexForItemIndex(idx);
        if (sidx >= 0) {
          var i = 0;
          this.__selectedMap.forEach(function (idx, item) {
            if (sidx == i++) {
              _this4.deselect(item);
            }
          });
        }
      }
    }, {
      key: '__selectedIndexForItemIndex',
      value: function __selectedIndexForItemIndex(idx) {
        var selected = this.__dataLinkedPaths['items.' + idx];
        if (selected) {
          return parseInt(selected.slice('selected.'.length), 10);
        }
      }

      /**
       * Deselects the given item if it is already selected.
       *
       * @param {*} item Item from `items` array to deselect
       */

    }, {
      key: 'deselect',
      value: function deselect(item) {
        var idx = this.__selectedMap.get(item);
        if (idx >= 0) {
          this.__selectedMap.delete(item);
          var sidx = void 0;
          if (this.multi) {
            sidx = this.__selectedIndexForItemIndex(idx);
          }
          this.__updateLinks();
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
        }
      }

      /**
       * Deselects the given index if it is already selected.
       *
       * @param {number} idx Index from `items` array to deselect
       */

    }, {
      key: 'deselectIndex',
      value: function deselectIndex(idx) {
        this.deselect(this.items[idx]);
      }

      /**
       * Selects the given item.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {*} item Item from `items` array to select
       */

    }, {
      key: 'select',
      value: function select(item) {
        this.selectIndex(this.items.indexOf(item));
      }

      /**
       * Selects the given index.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {number} idx Index from `items` array to select
       */

    }, {
      key: 'selectIndex',
      value: function selectIndex(idx) {
        var item = this.items[idx];
        if (!this.isSelected(item)) {
          if (!this.multi) {
            this.__selectedMap.clear();
          }
          this.__selectedMap.set(item, idx);
          this.__updateLinks();
          if (this.multi) {
            this.push('selected', item);
          } else {
            this.selected = this.selectedItem = item;
          }
        } else if (this.toggle) {
          this.deselectIndex(idx);
        }
      }
    }]);

    return ArraySelectorMixin;
  }(elementBase);

  return ArraySelectorMixin;
});

exports.ArraySelectorMixin = ArraySelectorMixin;

/**
 * @constructor
 * @extends {Polymer.Element}
 * @implements {Polymer_ArraySelectorMixin}
 */

var baseArraySelector = ArraySelectorMixin(_polymerElement.Element);

/**
 * Element implementing the `Polymer.ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *         <button on-click="toggleSelection">Select</button>
 *     </template>
 *
 *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
 *
 *     <div> Selected employees: </div>
 *     <template is="dom-repeat" items="{{selected}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * ```js
 * Polymer({
 *   is: 'employee-list',
 *   ready() {
 *     this.employees = [
 *         {first: 'Bob', last: 'Smith'},
 *         {first: 'Sally', last: 'Johnson'},
 *         ...
 *     ];
 *   },
 *   toggleSelection(e) {
 *     let item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * });
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin Polymer.ArraySelectorMixin
 * @memberof Polymer
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */

var ArraySelector = function (_baseArraySelector) {
  _inherits(ArraySelector, _baseArraySelector);

  function ArraySelector() {
    _classCallCheck(this, ArraySelector);

    return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
  }

  _createClass(ArraySelector, null, [{
    key: 'is',

    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'array-selector';
    }
  }]);

  return ArraySelector;
}(baseArraySelector);

customElements.define(ArraySelector.is, ArraySelector);
exports.ArraySelector = ArraySelector;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(105);

var _styleGather = __webpack_require__(58);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var attr = 'include';

var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 * ...
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */

var CustomStyle = function (_HTMLElement) {
  _inherits(CustomStyle, _HTMLElement);

  function CustomStyle() {
    _classCallCheck(this, CustomStyle);

    var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

    _this._style = null;
    CustomStyleInterface.addCustomStyle(_this);
    return _this;
  }
  /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */


  _createClass(CustomStyle, [{
    key: 'getStyle',
    value: function getStyle() {
      if (this._style) {
        return this._style;
      }
      var style = /** @type {HTMLStyleElement} */this.querySelector('style');
      if (!style) {
        return null;
      }
      this._style = style;
      var include = style.getAttribute(attr);
      if (include) {
        style.removeAttribute(attr);
        style.textContent = (0, _styleGather.cssFromModules)(include) + style.textContent;
      }
      return this._style;
    }
  }]);

  return CustomStyle;
}(HTMLElement);

window.customElements.define('custom-style', CustomStyle);
exports.CustomStyle = CustomStyle;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



var _customStyleInterface = __webpack_require__(64);

var _customStyleInterface2 = _interopRequireDefault(_customStyleInterface);

var _commonUtils = __webpack_require__(40);

var _styleSettings = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var customStyleInterface = new _customStyleInterface2.default();

if (!window.ShadyCSS) {
  window.ShadyCSS = {
    /**
     * @param {HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate: function prepareTemplate(template, elementName, elementExtends) {},
    // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    styleSubtree: function styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      (0, _commonUtils.updateNativeProperties)(element, properties);
    },


    /**
     * @param {Element} element
     */
    styleElement: function styleElement(element) {
      // eslint-disable-line no-unused-vars
      customStyleInterface.processStyles();
    },


    /**
     * @param {Object=} properties
     */
    styleDocument: function styleDocument(properties) {
      customStyleInterface.processStyles();
      (0, _commonUtils.updateNativeProperties)(document.body, properties);
    },


    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue: function getComputedStyleValue(element, property) {
      return (0, _commonUtils.getComputedStyleValue)(element, property);
    },

    nativeCss: _styleSettings.nativeCssVariables,
    nativeShadow: _styleSettings.nativeShadow
  };
}

window.ShadyCSS.CustomStyleInterface = customStyleInterface;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionalMutableDataBehavior = exports.MutableDataBehavior = undefined;

var _mutableData = __webpack_require__(29);

var mutablePropertyChange = void 0;
(
/** @suppress {missingProperties} */
function () {
  mutablePropertyChange = _mutableData.MutableData._mutablePropertyChange;
})();

var MutableDataBehavior = exports.MutableDataBehavior = {

  /**
   * Overrides `Polymer.PropertyEffects` to provide option for skipping
   * strict equality checking for Objects and Arrays.
   *
   * This method pulls the value to dirty check against from the `__dataTemp`
   * cache (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   */
  _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, true);
  }
};

var OptionalMutableDataBehavior = exports.OptionalMutableDataBehavior = {

  properties: {
    /**
     * Instance-level flag for configuring the dirty-checking strategy
     * for this element.  When true, Objects and Arrays will skip dirty
     * checking, otherwise strict equality checking will be used.
     */
    mutableData: Boolean
  },

  /**
   * Overrides `Polymer.PropertyEffects` to skip strict equality checking
   * for Objects and Arrays.
   *
   * Pulls the value to dirty check against from the `__dataTemp` cache
   * (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @this {this}
   * @protected
   */
  _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n\n      --layout: {\n        display: -ms-flexbox;\n        display: -webkit-flex;\n        display: flex;\n      };\n\n      --layout-inline: {\n        display: -ms-inline-flexbox;\n        display: -webkit-inline-flex;\n        display: inline-flex;\n      };\n\n      --layout-horizontal: {\n        @apply --layout;\n\n        -ms-flex-direction: row;\n        -webkit-flex-direction: row;\n        flex-direction: row;\n      };\n\n      --layout-horizontal-reverse: {\n        @apply --layout;\n\n        -ms-flex-direction: row-reverse;\n        -webkit-flex-direction: row-reverse;\n        flex-direction: row-reverse;\n      };\n\n      --layout-vertical: {\n        @apply --layout;\n\n        -ms-flex-direction: column;\n        -webkit-flex-direction: column;\n        flex-direction: column;\n      };\n\n      --layout-vertical-reverse: {\n        @apply --layout;\n\n        -ms-flex-direction: column-reverse;\n        -webkit-flex-direction: column-reverse;\n        flex-direction: column-reverse;\n      };\n\n      --layout-wrap: {\n        -ms-flex-wrap: wrap;\n        -webkit-flex-wrap: wrap;\n        flex-wrap: wrap;\n      };\n\n      --layout-wrap-reverse: {\n        -ms-flex-wrap: wrap-reverse;\n        -webkit-flex-wrap: wrap-reverse;\n        flex-wrap: wrap-reverse;\n      };\n\n      --layout-flex-auto: {\n        -ms-flex: 1 1 auto;\n        -webkit-flex: 1 1 auto;\n        flex: 1 1 auto;\n      };\n\n      --layout-flex-none: {\n        -ms-flex: none;\n        -webkit-flex: none;\n        flex: none;\n      };\n\n      --layout-flex: {\n        -ms-flex: 1 1 0.000000001px;\n        -webkit-flex: 1;\n        flex: 1;\n        -webkit-flex-basis: 0.000000001px;\n        flex-basis: 0.000000001px;\n      };\n\n      --layout-flex-2: {\n        -ms-flex: 2;\n        -webkit-flex: 2;\n        flex: 2;\n      };\n\n      --layout-flex-3: {\n        -ms-flex: 3;\n        -webkit-flex: 3;\n        flex: 3;\n      };\n\n      --layout-flex-4: {\n        -ms-flex: 4;\n        -webkit-flex: 4;\n        flex: 4;\n      };\n\n      --layout-flex-5: {\n        -ms-flex: 5;\n        -webkit-flex: 5;\n        flex: 5;\n      };\n\n      --layout-flex-6: {\n        -ms-flex: 6;\n        -webkit-flex: 6;\n        flex: 6;\n      };\n\n      --layout-flex-7: {\n        -ms-flex: 7;\n        -webkit-flex: 7;\n        flex: 7;\n      };\n\n      --layout-flex-8: {\n        -ms-flex: 8;\n        -webkit-flex: 8;\n        flex: 8;\n      };\n\n      --layout-flex-9: {\n        -ms-flex: 9;\n        -webkit-flex: 9;\n        flex: 9;\n      };\n\n      --layout-flex-10: {\n        -ms-flex: 10;\n        -webkit-flex: 10;\n        flex: 10;\n      };\n\n      --layout-flex-11: {\n        -ms-flex: 11;\n        -webkit-flex: 11;\n        flex: 11;\n      };\n\n      --layout-flex-12: {\n        -ms-flex: 12;\n        -webkit-flex: 12;\n        flex: 12;\n      };\n\n      /* alignment in cross axis */\n\n      --layout-start: {\n        -ms-flex-align: start;\n        -webkit-align-items: flex-start;\n        align-items: flex-start;\n      };\n\n      --layout-center: {\n        -ms-flex-align: center;\n        -webkit-align-items: center;\n        align-items: center;\n      };\n\n      --layout-end: {\n        -ms-flex-align: end;\n        -webkit-align-items: flex-end;\n        align-items: flex-end;\n      };\n\n      --layout-baseline: {\n        -ms-flex-align: baseline;\n        -webkit-align-items: baseline;\n        align-items: baseline;\n      };\n\n      /* alignment in main axis */\n\n      --layout-start-justified: {\n        -ms-flex-pack: start;\n        -webkit-justify-content: flex-start;\n        justify-content: flex-start;\n      };\n\n      --layout-center-justified: {\n        -ms-flex-pack: center;\n        -webkit-justify-content: center;\n        justify-content: center;\n      };\n\n      --layout-end-justified: {\n        -ms-flex-pack: end;\n        -webkit-justify-content: flex-end;\n        justify-content: flex-end;\n      };\n\n      --layout-around-justified: {\n        -ms-flex-pack: distribute;\n        -webkit-justify-content: space-around;\n        justify-content: space-around;\n      };\n\n      --layout-justified: {\n        -ms-flex-pack: justify;\n        -webkit-justify-content: space-between;\n        justify-content: space-between;\n      };\n\n      --layout-center-center: {\n        @apply --layout-center;\n        @apply --layout-center-justified;\n      };\n\n      /* self alignment */\n\n      --layout-self-start: {\n        -ms-align-self: flex-start;\n        -webkit-align-self: flex-start;\n        align-self: flex-start;\n      };\n\n      --layout-self-center: {\n        -ms-align-self: center;\n        -webkit-align-self: center;\n        align-self: center;\n      };\n\n      --layout-self-end: {\n        -ms-align-self: flex-end;\n        -webkit-align-self: flex-end;\n        align-self: flex-end;\n      };\n\n      --layout-self-stretch: {\n        -ms-align-self: stretch;\n        -webkit-align-self: stretch;\n        align-self: stretch;\n      };\n\n      --layout-self-baseline: {\n        -ms-align-self: baseline;\n        -webkit-align-self: baseline;\n        align-self: baseline;\n      };\n\n      /* multi-line alignment in main axis */\n\n      --layout-start-aligned: {\n        -ms-flex-line-pack: start;  /* IE10 */\n        -ms-align-content: flex-start;\n        -webkit-align-content: flex-start;\n        align-content: flex-start;\n      };\n\n      --layout-end-aligned: {\n        -ms-flex-line-pack: end;  /* IE10 */\n        -ms-align-content: flex-end;\n        -webkit-align-content: flex-end;\n        align-content: flex-end;\n      };\n\n      --layout-center-aligned: {\n        -ms-flex-line-pack: center;  /* IE10 */\n        -ms-align-content: center;\n        -webkit-align-content: center;\n        align-content: center;\n      };\n\n      --layout-between-aligned: {\n        -ms-flex-line-pack: justify;  /* IE10 */\n        -ms-align-content: space-between;\n        -webkit-align-content: space-between;\n        align-content: space-between;\n      };\n\n      --layout-around-aligned: {\n        -ms-flex-line-pack: distribute;  /* IE10 */\n        -ms-align-content: space-around;\n        -webkit-align-content: space-around;\n        align-content: space-around;\n      };\n\n      /*******************************\n                Other Layout\n      *******************************/\n\n      --layout-block: {\n        display: block;\n      };\n\n      --layout-invisible: {\n        visibility: hidden !important;\n      };\n\n      --layout-relative: {\n        position: relative;\n      };\n\n      --layout-fit: {\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n      --layout-scroll: {\n        -webkit-overflow-scrolling: touch;\n        overflow: auto;\n      };\n\n      --layout-fullbleed: {\n        margin: 0;\n        height: 100vh;\n      };\n\n      /* fixed position */\n\n      --layout-fixed-top: {\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n      };\n\n      --layout-fixed-right: {\n        position: fixed;\n        top: 0;\n        right: 0;\n        bottom: 0;\n      };\n\n      --layout-fixed-bottom: {\n        position: fixed;\n        right: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n      --layout-fixed-left: {\n        position: fixed;\n        top: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n    }\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

__webpack_require__(69);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n      /*\n       * You can use these generic variables in your elements for easy theming.\n       * For example, if all your elements use `--primary-text-color` as its main\n       * color, then switching from a light to a dark theme is just a matter of\n       * changing the value of `--primary-text-color` in your application.\n       */\n      --primary-text-color: var(--light-theme-text-color);\n      --primary-background-color: var(--light-theme-background-color);\n      --secondary-text-color: var(--light-theme-secondary-color);\n      --disabled-text-color: var(--light-theme-disabled-color);\n      --divider-color: var(--light-theme-divider-color);\n      --error-color: var(--paper-deep-orange-a700);\n\n      /*\n       * Primary and accent colors. Also see color.html for more colors.\n       */\n      --primary-color: var(--paper-indigo-500);\n      --light-primary-color: var(--paper-indigo-100);\n      --dark-primary-color: var(--paper-indigo-700);\n\n      --accent-color: var(--paper-pink-a200);\n      --light-accent-color: var(--paper-pink-a100);\n      --dark-accent-color: var(--paper-pink-a400);\n\n\n      /*\n       * Material Design Light background theme\n       */\n      --light-theme-background-color: #ffffff;\n      --light-theme-base-color: #000000;\n      --light-theme-text-color: var(--paper-grey-900);\n      --light-theme-secondary-color: #737373;  /* for secondary text and icons */\n      --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */\n      --light-theme-divider-color: #dbdbdb;\n\n      /*\n       * Material Design Dark background theme\n       */\n      --dark-theme-background-color: var(--paper-grey-900);\n      --dark-theme-base-color: #ffffff;\n      --dark-theme-text-color: #ffffff;\n      --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */\n      --dark-theme-disabled-color: #646464;  /* disabled/hint text */\n      --dark-theme-divider-color: #3c3c3c;\n\n      /*\n       * Deprecated values because of their confusing names.\n       */\n      --text-primary-color: var(--dark-theme-text-color);\n      --default-primary-color: var(--primary-color);\n    }\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperCheckedElementBehavior = exports.PaperCheckedElementBehaviorImpl = undefined;

__webpack_require__(6);

var _ironCheckedElementBehavior = __webpack_require__(110);

var _paperInkyFocusBehavior = __webpack_require__(114);

var _paperRippleBehavior = __webpack_require__(45);

var PaperCheckedElementBehaviorImpl = exports.PaperCheckedElementBehaviorImpl = {
  /**
   * Synchronizes the element's checked state with its ripple effect.
   */
  _checkedChanged: function _checkedChanged() {
    _ironCheckedElementBehavior.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
    if (this.hasRipple()) {
      if (this.checked) {
        this._ripple.setAttribute('checked', '');
      } else {
        this._ripple.removeAttribute('checked');
      }
    }
  },

  /**
   * Synchronizes the element's `active` and `checked` state.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    _paperRippleBehavior.PaperRippleBehavior._buttonStateChanged.call(this);
    if (this.disabled) {
      return;
    }
    if (this.isAttached) {
      this.checked = this.active;
    }
  }
};

var PaperCheckedElementBehavior = exports.PaperCheckedElementBehavior = [_paperInkyFocusBehavior.PaperInkyFocusBehavior, _ironCheckedElementBehavior.IronCheckedElementBehavior, PaperCheckedElementBehaviorImpl];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronCheckedElementBehavior = exports.IronCheckedElementBehaviorImpl = undefined;

__webpack_require__(6);

var _ironValidatableBehavior = __webpack_require__(111);

var _ironFormElementBehavior = __webpack_require__(113);

var IronCheckedElementBehaviorImpl = exports.IronCheckedElementBehaviorImpl = {

  properties: {
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */

    /**
     * Gets or sets the state, `true` is checked and `false` is unchecked.
     */
    checked: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      notify: true,
      observer: '_checkedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: true,
      reflectToAttribute: true
    },

    /* Overriden from Polymer.IronFormElementBehavior */
    value: {
      type: String,
      value: 'on',
      observer: '_valueChanged'
    }
  },

  observers: ['_requiredChanged(required)'],

  created: function created() {
    // Used by `iron-form` to handle the case that an element with this behavior
    // doesn't have a role of 'checkbox' or 'radio', but should still only be
    // included when the form is serialized if `this.checked === true`.
    this._hasIronCheckedElementBehavior = true;
  },

  /**
   * Returns false if the element is required and not checked, and true otherwise.
   * @param {*=} _value Ignored.
   * @return {boolean} true if `required` is false or if `checked` is true.
   */
  _getValidity: function _getValidity(_value) {
    return this.disabled || !this.required || this.checked;
  },

  /**
   * Update the aria-required label when `required` is changed.
   */
  _requiredChanged: function _requiredChanged() {
    if (this.required) {
      this.setAttribute('aria-required', 'true');
    } else {
      this.removeAttribute('aria-required');
    }
  },

  /**
   * Fire `iron-changed` when the checked state changes.
   */
  _checkedChanged: function _checkedChanged() {
    this.active = this.checked;
    this.fire('iron-change');
  },

  /**
   * Reset value to 'on' if it is set to `undefined`.
   */
  _valueChanged: function _valueChanged() {
    if (this.value === undefined || this.value === null) {
      this.value = 'on';
    }
  }
};

var IronCheckedElementBehavior = exports.IronCheckedElementBehavior = [_ironFormElementBehavior.IronFormElementBehavior, _ironValidatableBehavior.IronValidatableBehavior, IronCheckedElementBehaviorImpl];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronValidatableBehavior = exports.IronValidatableBehaviorMeta = undefined;

__webpack_require__(6);

var _ironMeta = __webpack_require__(112);

var IronValidatableBehaviorMeta = exports.IronValidatableBehaviorMeta = null;

var IronValidatableBehavior = exports.IronValidatableBehavior = {

  properties: {
    /**
     * Name of the validator to use.
     */
    validator: {
      type: String
    },

    /**
     * True if the last call to `validate` is invalid.
     */
    invalid: {
      notify: true,
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_invalidChanged'
    }
  },

  registered: function registered() {
    exports.IronValidatableBehaviorMeta = IronValidatableBehaviorMeta = new _ironMeta.IronMeta({ type: 'validator' });
  },

  _invalidChanged: function _invalidChanged() {
    if (this.invalid) {
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('aria-invalid');
    }
  },

  /* Recompute this every time it's needed, because we don't know if the
   * underlying IronValidatableBehaviorMeta has changed. */
  get _validator() {
    return IronValidatableBehaviorMeta && IronValidatableBehaviorMeta.byKey(this.validator);
  },

  /**
   * @return {boolean} True if the validator `validator` exists.
   */
  hasValidator: function hasValidator() {
    return this._validator != null;
  },

  /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.
    * @param {Object} value Deprecated: The value to be validated. By default,
   * it is passed to the validator's `validate()` function, if a validator is set.
   * If this argument is not specified, then the element's `value` property
   * is used, if it exists.
   * @return {boolean} True if `value` is valid.
   */
  validate: function validate(value) {
    // If this is an element that also has a value property, and there was
    // no explicit value argument passed, use the element's property instead.
    if (value === undefined && this.value !== undefined) this.invalid = !this._getValidity(this.value);else this.invalid = !this._getValidity(value);
    return !this.invalid;
  },

  /**
   * Returns true if `value` is valid.  By default, it is passed
   * to the validator's `validate()` function, if a validator is set. You
   * should override this method if you want to implement custom validity
   * logic for your element.
   *
   * @param {Object} value The value to be validated.
   * @return {boolean} True if `value` is valid.
   */

  _getValidity: function _getValidity(value) {
    if (this.hasValidator()) {
      return this._validator.validate(value);
    }
    return true;
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronMeta = undefined;

__webpack_require__(6);

var _polymerFn = __webpack_require__(28);

/**
 * @constructor
 * @param {{type: (string|null), key: (string|null), value: *}} options
 */
function IronMeta(options) {
  this.type = options && options.type || 'default';
  this.key = options && options.key;
  if ('value' in options) {
    this.value = options.value;
  }
}

IronMeta.types = {};

IronMeta.prototype = {
  get value() {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      return IronMeta.types[type] && IronMeta.types[type][key];
    }
  },

  set value(value) {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      type = IronMeta.types[type] = IronMeta.types[type] || {};
      if (value == null) {
        delete type[key];
      } else {
        type[key] = value;
      }
    }
  },

  get list() {
    var type = this.type;

    if (type) {
      return Object.keys(IronMeta.types[this.type]).map(function (key) {
        return metaDatas[this.type][key];
      }, this);
    }
  },

  byKey: function byKey(key) {
    this.key = key;
    return this.value;
  }
};

exports.IronMeta = IronMeta;


var metaDatas = IronMeta.types;

(0, _polymerFn.Polymer)({

  is: 'iron-meta',

  properties: {

    /**
     * The type of meta-data.  All meta-data of the same type is stored
     * together.
     * @type {string}
     */
    type: {
      type: String,
      value: 'default'
    },

    /**
     * The key used to store `value` under the `type` namespace.
     * @type {?string}
     */
    key: {
      type: String
    },

    /**
     * The meta-data to store or retrieve.
     * @type {*}
     */
    value: {
      type: String,
      notify: true
    },

    /**
     * If true, `value` is set to the iron-meta instance itself.
     */
    self: {
      type: Boolean,
      observer: '_selfChanged'
    },

    __meta: {
      type: Boolean,
      computed: '__computeMeta(type, key, value)'
    }
  },

  hostAttributes: {
    hidden: true
  },

  __computeMeta: function __computeMeta(type, key, value) {
    var meta = new IronMeta({
      type: type,
      key: key
    });

    if (value !== undefined && value !== meta.value) {
      meta.value = value;
    } else if (this.value !== meta.value) {
      this.value = meta.value;
    }

    return meta;
  },

  get list() {
    return this.__meta && this.__meta.list;
  },

  _selfChanged: function _selfChanged(self) {
    if (self) {
      this.value = this;
    }
  },

  /**
   * Retrieves meta data value by key.
   *
   * @method byKey
   * @param {string} key The key of the meta-data to be returned.
   * @return {*}
   */
  byKey: function byKey(key) {
    return new IronMeta({
      type: this.type,
      key: key
    }).value;
  }
});

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronFormElementBehavior = undefined;

__webpack_require__(6);

var _polymerElement = __webpack_require__(11);

var IronFormElementBehavior = exports.IronFormElementBehavior = {

  properties: {
    /**
     * Fired when the element is added to an `iron-form`.
     *
     * @event iron-form-element-register
     */

    /**
     * Fired when the element is removed from an `iron-form`.
     *
     * @event iron-form-element-unregister
     */

    /**
     * The name of this element.
     */
    name: {
      type: String
    },

    /**
     * The value for this element.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to mark the input as required. If used in a form, a
     * custom element that uses this behavior should also use
     * Polymer.IronValidatableBehavior and define a custom validation method.
     * Otherwise, a `required` element will always be considered valid.
     * It's also strongly recommended to provide a visual style for the element
     * when its value is invalid.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The form that the element is registered to.
     */
    _parentForm: {
      type: Object
    }
  },

  attached: _polymerElement.Element ? null : function () {
    // Note: the iron-form that this element belongs to will set this
    // element's _parentForm property when handling this event.
    this.fire('iron-form-element-register');
  },

  detached: _polymerElement.Element ? null : function () {
    if (this._parentForm) {
      this._parentForm.fire('iron-form-element-unregister', { target: this });
    }
  }

};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperInkyFocusBehavior = exports.PaperInkyFocusBehaviorImpl = undefined;

__webpack_require__(6);

var _ironButtonState = __webpack_require__(70);

var _paperRippleBehavior = __webpack_require__(45);

var _ironControlState = __webpack_require__(72);

var PaperInkyFocusBehaviorImpl = exports.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = _paperRippleBehavior.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

var PaperInkyFocusBehavior = exports.PaperInkyFocusBehavior = [_ironButtonState.IronButtonState, _ironControlState.IronControlState, _paperRippleBehavior.PaperRippleBehavior, PaperInkyFocusBehaviorImpl];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

var _ironA11yKeysBehavior = __webpack_require__(71);

var _polymerDom = __webpack_require__(17);

var _polymerFn = __webpack_require__(28);

var Utility = {
  distance: function distance(x1, y1, x2, y2) {
    var xDelta = x1 - x2;
    var yDelta = y1 - y2;

    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },

  now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;

  this.size = Math.max(this.width, this.height);
}

ElementMetrics.prototype = {
  get boundingRect() {
    return this.element.getBoundingClientRect();
  },

  furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);

    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;

  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  (0, _polymerDom.dom)(this.waveContainer).appendChild(this.wave);

  this.resetInteractionState();
}

Ripple.MAX_RADIUS = 300;

Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },

  get center() {
    return this.element.center;
  },

  get mouseDownElapsed() {
    var elapsed;

    if (!this.mouseDownStart) {
      return 0;
    }

    elapsed = Utility.now() - this.mouseDownStart;

    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }

    return elapsed;
  },

  get mouseUpElapsed() {
    return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
  },

  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },

  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },

  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },

  get initialOpacity() {
    return this.element.initialOpacity;
  },

  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },

  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));

    return Math.abs(size);
  },

  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }

    return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
  },

  get outerOpacity() {
    // Linear increase in background opacity, capped at the opacity
    // of the wavefront (waveOpacity).
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;

    return Math.max(0, Math.min(outerOpacity, waveOpacity));
  },

  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isAnimationComplete() {
    return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
  },

  get translationFraction() {
    return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
  },

  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }

    return this.xStart;
  },

  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }

    return this.yStart;
  },

  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },

  resetInteractionState: function resetInteractionState() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;

    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;

    this.containerMetrics = new ElementMetrics(this.element);
  },

  draw: function draw() {
    var scale;
    var translateString;
    var dx;
    var dy;

    this.wave.style.opacity = this.opacity;

    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - this.containerMetrics.width / 2;
    dy = this.yNow - this.containerMetrics.height / 2;

    // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
    // https://bugs.webkit.org/show_bug.cgi?id=98538
    this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },

  /** @param {Event=} event */
  downAction: function downAction(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;

    this.resetInteractionState();
    this.mouseDownStart = Utility.now();

    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    } else {
      this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
      this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
    }

    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    }

    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

    this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },

  /** @param {Event=} event */
  upAction: function upAction(event) {
    if (!this.isMouseDown) {
      return;
    }

    this.mouseUpStart = Utility.now();
  },

  remove: function remove() {
    (0, _polymerDom.dom)(this.waveContainer.parentNode).removeChild(this.waveContainer);
  }
};

(0, _polymerFn.Polymer)({
  _template: '\n    <style>\n      :host {\n        display: block;\n        position: absolute;\n        border-radius: inherit;\n        overflow: hidden;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n\n        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,\n         * creating a node (with a position:absolute) in the middle of an event\n         * handler "interrupts" that event handler (which happens when the\n         * ripple is created on demand) */\n        pointer-events: none;\n      }\n\n      :host([animating]) {\n        /* This resolves a rendering issue in Chrome (as of 40) where the\n           ripple is not properly clipped by its parent (which may have\n           rounded corners). See: http://jsbin.com/temexa/4\n\n           Note: We only apply this style conditionally. Otherwise, the browser\n           will create a new compositing layer for every ripple element on the\n           page, and that would be bad. */\n        -webkit-transform: translate(0, 0);\n        transform: translate3d(0, 0, 0);\n      }\n\n      #background,\n      #waves,\n      .wave-container,\n      .wave {\n        pointer-events: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      #background,\n      .wave {\n        opacity: 0;\n      }\n\n      #waves,\n      .wave {\n        overflow: hidden;\n      }\n\n      .wave-container,\n      .wave {\n        border-radius: 50%;\n      }\n\n      :host(.circle) #background,\n      :host(.circle) #waves {\n        border-radius: 50%;\n      }\n\n      :host(.circle) .wave-container {\n        overflow: hidden;\n      }\n    </style>\n\n    <div id="background"></div>\n    <div id="waves"></div>\n',

  is: 'paper-ripple',

  behaviors: [_ironA11yKeysBehavior.IronA11yKeysBehavior],

  properties: {
    /**
     * The initial opacity set on the wave.
     *
     * @attribute initialOpacity
     * @type number
     * @default 0.25
     */
    initialOpacity: {
      type: Number,
      value: 0.25
    },

    /**
     * How fast (opacity per second) the wave fades out.
     *
     * @attribute opacityDecayVelocity
     * @type number
     * @default 0.8
     */
    opacityDecayVelocity: {
      type: Number,
      value: 0.8
    },

    /**
     * If true, ripples will exhibit a gravitational pull towards
     * the center of their container as they fade away.
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    recenters: {
      type: Boolean,
      value: false
    },

    /**
     * If true, ripples will center inside its container
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    center: {
      type: Boolean,
      value: false
    },

    /**
     * A list of the visual ripples.
     *
     * @attribute ripples
     * @type Array
     * @default []
     */
    ripples: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    /**
     * True when there are visible ripples animating within the
     * element.
     */
    animating: {
      type: Boolean,
      readOnly: true,
      reflectToAttribute: true,
      value: false
    },

    /**
     * If true, the ripple will remain in the "down" state until `holdDown`
     * is set to false again.
     */
    holdDown: {
      type: Boolean,
      value: false,
      observer: '_holdDownChanged'
    },

    /**
     * If true, the ripple will not generate a ripple effect
     * via pointer interaction.
     * Calling ripple's imperative api like `simulatedRipple` will
     * still generate the ripple effect.
     */
    noink: {
      type: Boolean,
      value: false
    },

    _animating: {
      type: Boolean
    },

    _boundAnimate: {
      type: Function,
      value: function value() {
        return this.animate.bind(this);
      }
    }
  },

  get target() {
    return this.keyEventTarget;
  },

  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },

  attached: function attached() {
    // Set up a11yKeysBehavior to listen to key events on the target,
    // so that space and enter activate the ripple even if the target doesn't
    // handle key events. The key handlers deal with `noink` themselves.
    if (this.parentNode.nodeType == 11) {
      // DOCUMENT_FRAGMENT_NODE
      this.keyEventTarget = (0, _polymerDom.dom)(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = this.parentNode;
    }
    var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },

  detached: function detached() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },

  get shouldKeepAnimating() {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }

    return false;
  },

  simulatedRipple: function simulatedRipple() {
    this.downAction(null);

    // Please see polymer/polymer#1305
    this.async(function () {
      this.upAction();
    }, 1);
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiDownAction: function uiDownAction(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  downAction: function downAction(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }

    var ripple = this.addRipple();

    ripple.downAction(event);

    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiUpAction: function uiUpAction(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  upAction: function upAction(event) {
    if (this.holdDown) {
      return;
    }

    this.ripples.forEach(function (ripple) {
      ripple.upAction(event);
    });

    this._animating = true;
    this.animate();
  },

  onAnimationComplete: function onAnimationComplete() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire('transitionend');
  },

  addRipple: function addRipple() {
    var ripple = new Ripple(this);

    (0, _polymerDom.dom)(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);

    this._setAnimating(true);

    return ripple;
  },

  removeRipple: function removeRipple(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);

    if (rippleIndex < 0) {
      return;
    }

    this.ripples.splice(rippleIndex, 1);

    ripple.remove();

    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },

  /**
   * This conflicts with Element#antimate().
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
   * @suppress {checkTypes}
   */
  animate: function animate() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;

    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];

      ripple.draw();

      this.$.background.style.opacity = ripple.outerOpacity;

      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }

    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },

  _onEnterKeydown: function _onEnterKeydown() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },

  _onSpaceKeydown: function _onSpaceKeydown() {
    this.uiDownAction();
  },

  _onSpaceKeyup: function _onSpaceKeyup() {
    this.uiUpAction();
  },

  // note: holdDown does not respect noink since it can be a focus based
  // effect.
  _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.
   @event transitionend
  @param {{node: Object}} detail Contains the animated node.
  */
});

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.addDoubleTapListener = addDoubleTapListener;
exports.removeDoubleTapListener = removeDoubleTapListener;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(76);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = Browser.msPointer ? 'MSPointerDown' : Browser.pointer ? 'pointerdown' : 'touchstart',
    _touchend = Browser.msPointer ? 'MSPointerUp' : Browser.pointer ? 'pointerup' : 'touchend',
    _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last,
	    touch,
	    doubleTap = false,
	    delay = 250;

	function onTouchStart(e) {
		var count;

		if (Browser.pointer) {
			if (!Browser.edge || e.pointerType === 'mouse') {
				return;
			}
			count = _DomEvent._pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) {
			return;
		}

		var now = Date.now(),
		    delta = now - (last || now);

		touch = e.touches ? e.touches[0] : e;
		doubleTap = delta > 0 && delta <= delay;
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch.cancelBubble) {
			if (Browser.pointer) {
				if (!Browser.edge || e.pointerType === 'mouse') {
					return;
				}
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
				    prop,
				    i;

				for (i in touch) {
					prop = touch[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
				}
				touch = newTouch;
			}
			touch.type = 'dblclick';
			handler(touch);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, false);
	obj.addEventListener(_touchend, onTouchEnd, false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
	    touchend = obj[_pre + _touchend + id],
	    dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, false);
	obj.removeEventListener(_touchend, touchend, false);
	if (!Browser.edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.MarkerDrag = undefined;

var _Handler = __webpack_require__(14);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Draggable = __webpack_require__(49);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = exports.MarkerDrag = _Handler.Handler.extend({
	initialize: function initialize(marker) {
		this._marker = marker;
	},

	addHooks: function addHooks() {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new _Draggable.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function removeHooks() {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function moved() {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function _onDragStart() {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker.closePopup().fire('movestart').fire('dragstart');
	},

	_onDrag: function _onDrag(e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker.fire('move', e).fire('drag', e);
	},

	_onDragEnd: function _onDragEnd(e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker.fire('moveend').fire('dragend', e);
	}
});

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "2273e3d8ad9264b7daa5bdbf8e6b47f8.png";

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "44a526eed258222515aa21eaffd14a96.png";

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletMap = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _flattenedNodesObserver = __webpack_require__(67);

var _map = __webpack_require__(79);

var _ControlAttribution = __webpack_require__(80);

__webpack_require__(81);

__webpack_require__(82);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Need these side effects


var LeafletMap = exports.LeafletMap = function (_PolymerElement) {
  _inherits(LeafletMap, _PolymerElement);

  _createClass(LeafletMap, null, [{
    key: 'template',
    get: function get() {
      return '\n      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />\n\n      <!-- FIXME: Figure out Shadow DOM so this doesn\'t have to be included here -->\n      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css" media="screen">\n      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css" media="screen">\n\n      <style>\n        #map {\n          width: 100%;\n          height: 100%;\n          @apply (--leaflet-map-component)\n        }\n      </style>\n\n      <div id="map">\n        <slot></slot>\n      </div>\n    ';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          notify: true
        },
        latitude: {
          type: Number
        },
        longitude: {
          type: Number
        },
        zoom: {
          type: Number
        },
        minZoom: {
          type: Number
        },
        maxZoom: {
          type: Number
        },
        zoomControl: {
          type: Boolean,
          value: false
        },
        attributionPrefix: {
          type: String
        },
        _childrenObserver: Object
      };
    }
  }]);

  function LeafletMap() {
    _classCallCheck(this, LeafletMap);

    return _possibleConstructorReturn(this, (LeafletMap.__proto__ || Object.getPrototypeOf(LeafletMap)).call(this));
  }

  _createClass(LeafletMap, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletMap.prototype.__proto__ || Object.getPrototypeOf(LeafletMap.prototype), 'connectedCallback', this).call(this);

      this.map = new _map.Map(this.$.map, {
        center: [this.latitude, this.longitude],
        zoom: this.zoom,
        zoomControl: this.zoomControl,
        inertiaDeceleration: 3000,
        inertiaMaxSpeed: 3000,
        attributionControl: false,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom
      });

      if (this.attributionPrefix) {
        var attrControl = new _ControlAttribution.Attribution({ prefix: this.attributionPrefix });
        this.map.addControl(attrControl);
      }

      var slot = this.shadowRoot.querySelector('slot');
      this._childrenObserver = new _flattenedNodesObserver.FlattenedNodesObserver(slot, this._bindDependencies.bind(this));
    }

    /* Shitty way of passing value to children */

  }, {
    key: '_bindDependencies',
    value: function _bindDependencies(_ref) {
      var _this2 = this;

      var addedNodes = _ref.addedNodes;

      addedNodes.forEach(function (n) {
        n.map = _this2.map;
      });
    }
  }]);

  return LeafletMap;
}(_polymerElement.Element);

customElements.define('leaflet-map', LeafletMap);

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.BoxZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = exports.BoxZoom = _Handler.Handler.extend({
	initialize: function initialize(map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function addHooks() {
		DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function moved() {
		return this._moved;
	},

	_destroy: function _destroy() {
		DomUtil.remove(this._pane);
		delete this._pane;
	},

	_resetState: function _resetState() {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function _clearDeferredResetState() {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function _onMouseDown(e) {
		if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
			return false;
		}

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		DomUtil.disableTextSelection();
		DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		DomEvent.on(document, {
			contextmenu: DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function _onMouseMove(e) {
		if (!this._moved) {
			this._moved = true;

			this._box = DomUtil.create('div', 'leaflet-zoom-box', this._container);
			DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new _Bounds.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function _finish() {
		if (this._moved) {
			DomUtil.remove(this._box);
			DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		DomUtil.enableTextSelection();
		DomUtil.enableImageDrag();

		DomEvent.off(document, {
			contextmenu: DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function _onMouseUp(e) {
		if (e.which !== 1 && e.button !== 1) {
			return;
		}

		this._finish();

		if (!this._moved) {
			return;
		}
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(Util.bind(this._resetState, this), 0);

		var bounds = new _LatLngBounds.LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

		this._map.fitBounds(bounds).fire('boxzoomend', { boxZoomBounds: bounds });
	},

	_onKeyDown: function _onKeyDown(e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
_Map.Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DoubleClickZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

_Map.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = exports.DoubleClickZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function removeHooks() {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function _onDoubleClick(e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
_Map.Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Drag = undefined;

var _Map = __webpack_require__(7);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Handler = __webpack_require__(14);

var _Draggable = __webpack_require__(49);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = exports.Drag = _Handler.Handler.extend({
	addHooks: function addHooks() {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new _Draggable.Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function removeHooks() {
		DomUtil.removeClass(this._map._container, 'leaflet-grab');
		DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function moved() {
		return this._draggable && this._draggable._moved;
	},

	moving: function moving() {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function _onDragStart() {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = (0, _LatLngBounds.toLatLngBounds)(this._map.options.maxBounds);

			this._offsetLimit = (0, _Bounds.toBounds)(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map.fire('movestart').fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function _onDrag(e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map.fire('move', e).fire('drag', e);
	},

	_onZoomEnd: function _onZoomEnd() {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function _viscousLimit(value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function _onPreDragLimit() {
		if (!this._viscosity || !this._offsetLimit) {
			return;
		}

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) {
			offset.x = this._viscousLimit(offset.x, limit.min.x);
		}
		if (offset.y < limit.min.y) {
			offset.y = this._viscousLimit(offset.y, limit.min.y);
		}
		if (offset.x > limit.max.x) {
			offset.x = this._viscousLimit(offset.x, limit.max.x);
		}
		if (offset.y > limit.max.y) {
			offset.y = this._viscousLimit(offset.y, limit.max.y);
		}

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function _onPreDragWrap() {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function _onDragEnd(e) {
		var map = this._map,
		    options = map.options,
		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');
		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,
			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),
			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');
			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
_Map.Map.addInitHook('addHandler', 'dragging', Drag);

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Keyboard = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var _Point = __webpack_require__(3);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
_Map.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = exports.Keyboard = _Handler.Handler.extend({

	keyCodes: {
		left: [37],
		right: [39],
		down: [40],
		up: [38],
		zoomIn: [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function initialize(map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function addHooks() {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		(0, _DomEvent.on)(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function removeHooks() {
		this._removeHooks();

		(0, _DomEvent.off)(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function _onMouseDown() {
		if (this._focused) {
			return;
		}

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function _onFocus() {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function _onBlur() {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function _setPanDelta(panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i,
		    len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function _setZoomDelta(zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i,
		    len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function _addHooks() {
		(0, _DomEvent.on)(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function _removeHooks() {
		(0, _DomEvent.off)(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function _onKeyDown(e) {
		if (e.altKey || e.ctrlKey || e.metaKey) {
			return;
		}

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) {
				return;
			}

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = (0, _Point.toPoint)(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
		} else if (key === 27 && map._popup) {
			map.closePopup();
		} else {
			return;
		}

		(0, _DomEvent.stop)(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
_Map.Map.addInitHook('addHandler', 'keyboard', Keyboard);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ScrollWheelZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = exports.ScrollWheelZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function _onWheelScroll(e) {
		var delta = DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(Util.bind(this._performZoom, this), left);

		DomEvent.stop(e);
	},

	_performZoom: function _performZoom() {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) {
			return;
		}

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
_Map.Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Tap = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = exports.Tap = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function _onDown(e) {
		if (!e.touches) {
			return;
		}

		DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new _Point.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(Util.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function _onUp(e) {
		clearTimeout(this._holdTimeout);

		DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function _isTapValid() {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function _onMove(e) {
		var first = e.touches[0];
		this._newPos = new _Point.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function _simulateEvent(type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (Browser.touch && !Browser.pointer) {
	_Map.Map.addInitHook('addHandler', 'tap', Tap);
}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TouchZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: Browser.touch && !Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = exports.TouchZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function removeHooks() {
		DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function _onTouchStart(e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
			return;
		}

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		DomEvent.on(document, 'touchmove', this._onTouchMove, this);
		DomEvent.on(document, 'touchend', this._onTouchEnd, this);

		DomEvent.preventDefault(e);
	},

	_onTouchMove: function _onTouchMove(e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) {
			return;
		}

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) {
				return;
			}
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) {
				return;
			}
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		Util.cancelAnimFrame(this._animRequest);

		var moveFn = Util.bind(map._move, map, this._center, this._zoom, { pinch: true, round: false });
		this._animRequest = Util.requestAnimFrame(moveFn, this, true);

		DomEvent.preventDefault(e);
	},

	_onTouchEnd: function _onTouchEnd() {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		Util.cancelAnimFrame(this._animRequest);

		DomEvent.off(document, 'touchmove', this._onTouchMove);
		DomEvent.off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
_Map.Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.layers = exports.Layers = undefined;

var _Control = __webpack_require__(22);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = exports.Layers = _Control.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function sortFunction(layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
		}
	},

	initialize: function initialize(baseLayers, overlays, options) {
		Util.setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function onAdd(map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function addTo(map) {
		_Control.Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function onRemove() {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function addBaseLayer(layer, name) {
		this._addLayer(layer, name);
		return this._map ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function addOverlay(layer, name) {
		this._addLayer(layer, name, true);
		return this._map ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function removeLayer(layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(Util.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return this._map ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function expand() {
		DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function collapse() {
		DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function _initLayout() {
		var className = 'leaflet-control-layers',
		    container = this._container = DomUtil.create('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		DomEvent.disableClickPropagation(container);
		DomEvent.disableScrollPropagation(container);

		var form = this._form = DomUtil.create('form', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!Browser.android) {
				DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = DomUtil.create('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (Browser.touch) {
			DomEvent.on(link, 'click', DomEvent.stop);
			DomEvent.on(link, 'click', this.expand, this);
		} else {
			DomEvent.on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = DomUtil.create('div', className + '-base', form);
		this._separator = DomUtil.create('div', className + '-separator', form);
		this._overlaysList = DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function _getLayer(id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && Util.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function _addLayer(layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(Util.bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function _update() {
		if (!this._container) {
			return this;
		}

		DomUtil.empty(this._baseLayersList);
		DomUtil.empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent,
		    overlaysPresent,
		    i,
		    obj,
		    baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function _onLayerChange(e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(Util.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function _createRadioElement(name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function _addItem(obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = Util.stamp(obj.layer);

		DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function _onInputClick() {
		var inputs = this._layerControlInputs,
		    input,
		    layer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function _checkDisabledLayers() {
		var inputs = this._layerControlInputs,
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
		}
	},

	_expandIfNotCollapsed: function _expandIfNotCollapsed() {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function _expand() {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function _collapse() {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});

// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = exports.layers = function layers(baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.zoom = exports.Zoom = undefined;

var _Control = __webpack_require__(22);

var _Map = __webpack_require__(7);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = exports.Zoom = _Control.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function onAdd(map) {
		var zoomName = 'leaflet-control-zoom',
		    container = DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function onRemove(map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function disable() {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function enable() {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function _zoomIn(e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function _zoomOut(e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function _createButton(html, title, className, container, fn) {
		var link = DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
   * Will force screen readers like VoiceOver to read this as "Zoom in - button"
   */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		DomEvent.disableClickPropagation(link);
		DomEvent.on(link, 'click', DomEvent.stop);
		DomEvent.on(link, 'click', fn, this);
		DomEvent.on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function _updateDisabled() {
		var map = this._map,
		    className = 'leaflet-disabled';

		DomUtil.removeClass(this._zoomInButton, className);
		DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
_Map.Map.mergeOptions({
	zoomControl: true
});

_Map.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = exports.zoom = function zoom(options) {
	return new Zoom(options);
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.scale = exports.Scale = undefined;

var _Control = __webpack_require__(22);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = exports.Scale = _Control.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function onAdd(map) {
		var className = 'leaflet-control-scale',
		    container = DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function onRemove(map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function _addScales(options, className, container) {
		if (options.metric) {
			this._mScale = DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = DomUtil.create('div', className, container);
		}
	},

	_update: function _update() {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function _updateScales(maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function _updateMetric(maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function _updateImperial(maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles,
		    miles,
		    feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function _updateScale(scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function _getRoundNum(num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = exports.scale = function scale(options) {
	return new Scale(options);
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.VideoOverlay = undefined;
exports.videoOverlay = videoOverlay;

var _ImageOverlay = __webpack_require__(50);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.VideoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = exports.VideoOverlay = _ImageOverlay.ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true
	},

	_initImage: function _initImage() {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : DomUtil.create('video');

		vid.class = vid.class || '';
		vid.class += 'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : '');

		vid.onselectstart = Util.falseFn;
		vid.onmousemove = Util.falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = Util.bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			return;
		}

		if (!Util.isArray(this._url)) {
			this._url = [this._url];
		}

		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = DomUtil.create('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});

// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.popup = exports.Popup = undefined;

var _DivOverlay = __webpack_require__(51);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Point = __webpack_require__(3);

var _Map = __webpack_require__(7);

var _Layer = __webpack_require__(12);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Path = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */

// @namespace Popup
var Popup = exports.Popup = _DivOverlay.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function openOn(map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function onAdd(map) {
		_DivOverlay.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', { popup: this });

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', { popup: this }, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof _Path.Path)) {
				this._source.on('preclick', DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function onRemove(map) {
		_DivOverlay.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', { popup: this });

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', { popup: this }, true);
			if (!(this._source instanceof _Path.Path)) {
				this._source.off('preclick', DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function getEvents() {
		var events = _DivOverlay.DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function _close() {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function _initLayout() {
		var prefix = 'leaflet-popup',
		    container = this._container = DomUtil.create('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');

		var wrapper = this._wrapper = DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = DomUtil.create('div', prefix + '-content', wrapper);

		DomEvent.disableClickPropagation(wrapper);
		DomEvent.disableScrollPropagation(this._contentNode);
		DomEvent.on(wrapper, 'contextmenu', DomEvent.stopPropagation);

		this._tipContainer = DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = DomUtil.create('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function _updateLayout() {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = width + 1 + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			DomUtil.addClass(container, scrolledClass);
		} else {
			DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function _animateZoom(e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function _adjustPan() {
		if (!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress) {
			return;
		}

		var map = this._map,
		    marginBottom = parseInt(DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new _Point.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = (0, _Point.toPoint)(this.options.autoPanPadding),
		    paddingTL = (0, _Point.toPoint)(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = (0, _Point.toPoint)(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) {
			// right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) {
			// left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) {
			// bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) {
			// top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map.fire('autopanstart').panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function _onCloseButtonClick(e) {
		this._close();
		DomEvent.stop(e);
	},

	_getAnchor: function _getAnchor() {
		// Where should we anchor the popup on the source layer?
		return (0, _Point.toPoint)(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = exports.popup = function popup(options, source) {
	return new Popup(options, source);
};

/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
_Map.Map.mergeOptions({
	closePopupOnClick: true
});

// @namespace Map
// @section Methods for Layers and Controls
_Map.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function openPopup(popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function closePopup(popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
_Layer.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function bindPopup(content, options) {

		if (content instanceof Popup) {
			Util.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function unbindPopup() {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function openPopup(layer, latlng) {
		if (!(layer instanceof _Layer.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof _FeatureGroup.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function closePopup() {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function togglePopup(target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function isPopupOpen() {
		return this._popup ? this._popup.isOpen() : false;
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function setPopupContent(content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function getPopup() {
		return this._popup;
	},

	_openPopup: function _openPopup(e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof _Path.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function _movePopup(e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function _onKeyPress(e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.tooltip = exports.Tooltip = undefined;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DivOverlay = __webpack_require__(51);

var _Point = __webpack_require__(3);

var _Map = __webpack_require__(7);

var _Layer = __webpack_require__(12);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */

// @namespace Tooltip
var Tooltip = exports.Tooltip = _DivOverlay.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function onAdd(map) {
		_DivOverlay.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', { tooltip: this });

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', { tooltip: this }, true);
		}
	},

	onRemove: function onRemove(map) {
		_DivOverlay.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', { tooltip: this });

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', { tooltip: this }, true);
		}
	},

	getEvents: function getEvents() {
		var events = _DivOverlay.DivOverlay.prototype.getEvents.call(this);

		if (Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function _close() {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function _initLayout() {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = DomUtil.create('div', className);
	},

	_updateLayout: function _updateLayout() {},

	_adjustPan: function _adjustPan() {},

	_setPosition: function _setPosition(pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = (0, _Point.toPoint)(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add((0, _Point.toPoint)(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add((0, _Point.toPoint)(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		DomUtil.removeClass(container, 'leaflet-tooltip-right');
		DomUtil.removeClass(container, 'leaflet-tooltip-left');
		DomUtil.removeClass(container, 'leaflet-tooltip-top');
		DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		DomUtil.setPosition(container, pos);
	},

	_updatePosition: function _updatePosition() {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function _animateZoom(e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function _getAnchor() {
		// Where should we anchor the tooltip on the source layer?
		return (0, _Point.toPoint)(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = exports.tooltip = function tooltip(options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
_Map.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function openTooltip(tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function closeTooltip(tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
_Layer.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function bindTooltip(content, options) {

		if (content instanceof Tooltip) {
			Util.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);
		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function unbindTooltip() {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function _initTooltipInteractions(remove) {
		if (!remove && this._tooltipHandlersAdded) {
			return;
		}
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		};
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function openTooltip(layer, latlng) {
		if (!(layer instanceof _Layer.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof _FeatureGroup.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function closeTooltip() {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function toggleTooltip(target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function isTooltipOpen() {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function setTooltipContent(content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function getTooltip() {
		return this._tooltip;
	},

	_openTooltip: function _openTooltip(e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function _moveTooltip(e) {
		var latlng = e.latlng,
		    containerPoint,
		    layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.marker = exports.Marker = exports.divIcon = exports.DivIcon = exports.Icon = exports.icon = undefined;

var _Icon = __webpack_require__(30);

Object.defineProperty(exports, 'icon', {
  enumerable: true,
  get: function get() {
    return _Icon.icon;
  }
});

var _DivIcon = __webpack_require__(135);

Object.defineProperty(exports, 'DivIcon', {
  enumerable: true,
  get: function get() {
    return _DivIcon.DivIcon;
  }
});
Object.defineProperty(exports, 'divIcon', {
  enumerable: true,
  get: function get() {
    return _DivIcon.divIcon;
  }
});

var _Marker = __webpack_require__(48);

Object.defineProperty(exports, 'Marker', {
  enumerable: true,
  get: function get() {
    return _Marker.Marker;
  }
});
Object.defineProperty(exports, 'marker', {
  enumerable: true,
  get: function get() {
    return _Marker.marker;
  }
});

var _Icon2 = __webpack_require__(78);

_Icon.Icon.Default = _Icon2.IconDefault;
exports.Icon = _Icon.Icon;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DivIcon = undefined;
exports.divIcon = divIcon;

var _Icon = __webpack_require__(30);

var _Point = __webpack_require__(3);

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = exports.DivIcon = _Icon.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function createIcon(oldIcon) {
		var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = (0, _Point.toPoint)(options.bgPos);
			div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function createShadow() {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tileLayer = exports.TileLayer = exports.gridLayer = exports.GridLayer = undefined;

var _GridLayer = __webpack_require__(83);

Object.defineProperty(exports, 'GridLayer', {
  enumerable: true,
  get: function get() {
    return _GridLayer.GridLayer;
  }
});
Object.defineProperty(exports, 'gridLayer', {
  enumerable: true,
  get: function get() {
    return _GridLayer.gridLayer;
  }
});

var _TileLayer = __webpack_require__(52);

var _TileLayer2 = __webpack_require__(53);

_TileLayer.TileLayer.WMS = _TileLayer2.TileLayerWMS;
_TileLayer.tileLayer.wms = _TileLayer2.tileLayerWMS;
exports.TileLayer = _TileLayer.TileLayer;
exports.tileLayer = _TileLayer.tileLayer;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectangle = exports.Rectangle = exports.polygon = exports.Polygon = exports.polyline = exports.Polyline = exports.circle = exports.Circle = exports.circleMarker = exports.CircleMarker = exports.Path = exports.svg = exports.SVG = exports.canvas = exports.Canvas = exports.Renderer = undefined;

var _Renderer = __webpack_require__(31);

Object.defineProperty(exports, 'Renderer', {
  enumerable: true,
  get: function get() {
    return _Renderer.Renderer;
  }
});

var _Canvas = __webpack_require__(84);

Object.defineProperty(exports, 'Canvas', {
  enumerable: true,
  get: function get() {
    return _Canvas.Canvas;
  }
});
Object.defineProperty(exports, 'canvas', {
  enumerable: true,
  get: function get() {
    return _Canvas.canvas;
  }
});

var _Path = __webpack_require__(23);

Object.defineProperty(exports, 'Path', {
  enumerable: true,
  get: function get() {
    return _Path.Path;
  }
});

var _CircleMarker = __webpack_require__(32);

Object.defineProperty(exports, 'CircleMarker', {
  enumerable: true,
  get: function get() {
    return _CircleMarker.CircleMarker;
  }
});
Object.defineProperty(exports, 'circleMarker', {
  enumerable: true,
  get: function get() {
    return _CircleMarker.circleMarker;
  }
});

var _Circle = __webpack_require__(85);

Object.defineProperty(exports, 'Circle', {
  enumerable: true,
  get: function get() {
    return _Circle.Circle;
  }
});
Object.defineProperty(exports, 'circle', {
  enumerable: true,
  get: function get() {
    return _Circle.circle;
  }
});

var _Polyline = __webpack_require__(56);

Object.defineProperty(exports, 'Polyline', {
  enumerable: true,
  get: function get() {
    return _Polyline.Polyline;
  }
});
Object.defineProperty(exports, 'polyline', {
  enumerable: true,
  get: function get() {
    return _Polyline.polyline;
  }
});

var _Polygon = __webpack_require__(57);

Object.defineProperty(exports, 'Polygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.Polygon;
  }
});
Object.defineProperty(exports, 'polygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.polygon;
  }
});

var _Rectangle = __webpack_require__(138);

Object.defineProperty(exports, 'Rectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.Rectangle;
  }
});
Object.defineProperty(exports, 'rectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.rectangle;
  }
});

var _SVG = __webpack_require__(87);

__webpack_require__(140);

_SVG.SVG.create = _SVG.create;
_SVG.SVG.pointsToPath = _SVG.pointsToPath;
exports.SVG = _SVG.SVG;
exports.svg = _SVG.svg;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rectangle = undefined;
exports.rectangle = rectangle;

var _Polygon = __webpack_require__(57);

var _LatLngBounds = __webpack_require__(10);

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */

var Rectangle = exports.Rectangle = _Polygon.Polygon.extend({
  initialize: function initialize(latLngBounds, options) {
    _Polygon.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  },

  // @method setBounds(latLngBounds: LatLngBounds): this
  // Redraws the rectangle with the passed bounds.
  setBounds: function setBounds(latLngBounds) {
    return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  },

  _boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {
    latLngBounds = (0, _LatLngBounds.toLatLngBounds)(latLngBounds);
    return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
  }
});

// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
  return new Rectangle(latLngBounds, options);
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.vmlMixin = exports.vmlCreate = undefined;

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Renderer = __webpack_require__(31);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

var vmlCreate = exports.vmlCreate = function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
}();

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = exports.vmlMixin = {

	_initContainer: function _initContainer() {
		this._container = DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function _update() {
		if (this._map._animatingZoom) {
			return;
		}
		_Renderer.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function _initPath(layer) {
		var container = layer._container = vmlCreate('shape');

		DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[Util.stamp(layer)] = layer;
	},

	_addPath: function _addPath(layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function _removePath(layer) {
		var container = layer._container;
		DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[Util.stamp(layer)];
	},

	_updateStyle: function _updateStyle(layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = Util.isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;
		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;
		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function _updateCircle(layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
	},

	_setPath: function _setPath(layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function _bringToFront(layer) {
		DomUtil.toFront(layer._container);
	},

	_bringToBack: function _bringToBack(layer) {
		DomUtil.toBack(layer._container);
	}
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Map = __webpack_require__(7);

var _Canvas = __webpack_require__(84);

var _SVG = __webpack_require__(87);

_Map.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function getRenderer(layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = this.options.preferCanvas && (0, _Canvas.canvas)() || (0, _SVG.svg)();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function _getPaneRenderer(name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = _SVG.SVG && (0, _SVG.svg)({ pane: name }) || _Canvas.Canvas && (0, _Canvas.canvas)({ pane: name });
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletWMSGroup = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _domRepeat = __webpack_require__(44);

var _leafletWms = __webpack_require__(142);

__webpack_require__(143);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletWMSGroup = exports.LeafletWMSGroup = function (_PolymerElement) {
  _inherits(LeafletWMSGroup, _PolymerElement);

  _createClass(LeafletWMSGroup, null, [{
    key: 'template',
    get: function get() {
      // return `
      //   <template is="dom-repeat" items="{{subLayers}}">
      //     <leaflet-wms-layer wms-source="[[wmsSource]]" layer="[[item]]"></leaflet-wms-layer>
      //   </template>
      // `;
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },

        source: {
          type: String,
          observer: '_sourceChange',
          reflectToAttribute: true
        },
        layers: {
          type: Array,
          observer: '_layersChange',
          reflectToAttribute: true
        },

        transparent: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        },
        format: {
          type: String,
          value: 'image/png',
          reflectToAttribute: true
        },
        identify: Boolean,
        minZoom: Number,
        maxZoom: Number,
        attribution: String,

        wmsSource: Object,
        subLayers: {
          type: Array,
          value: []
        }
      };
    }
  }]);

  function LeafletWMSGroup() {
    _classCallCheck(this, LeafletWMSGroup);

    return _possibleConstructorReturn(this, (LeafletWMSGroup.__proto__ || Object.getPrototypeOf(LeafletWMSGroup)).call(this));
  }

  _createClass(LeafletWMSGroup, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletWMSGroup.prototype.__proto__ || Object.getPrototypeOf(LeafletWMSGroup.prototype), 'connectedCallback', this).call(this);
    }
  }, {
    key: '_sourceChange',
    value: function _sourceChange() {
      if (this.wmsSource) this.wmsSource.removeFrom(this.map);

      this._wmsOptions = {
        transparent: this.transparent,
        format: this.format,
        identify: this.identify,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        attribution: this.attribution
      };

      this.wmsSource = new _leafletWms.wms.Source(this.source, this._wmsOptions);
      if (this.map) this.wmsSource.addTo(this.map);

      this._layersChange();
    }
  }, {
    key: '_layersChange',
    value: function _layersChange(newValue, oldValue) {
      // FIXME: use promise instead please
      if (this.wmsSource) this.wmsSource.replaceAllSubLayers(this.layers);
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      this.wmsSource.addTo(this.map); // FIXME: there could be a race condition here for this.map
    }
  }]);

  return LeafletWMSGroup;
}(_polymerElement.Element);

customElements.define('leaflet-wms-group', LeafletWMSGroup);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wms = undefined;

var _Layer = __webpack_require__(12);

var _ImageOverlay = __webpack_require__(50);

var _TileLayerWMS = __webpack_require__(53);

var _CRSEPSG = __webpack_require__(54);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var wms = exports.wms = {};

/*
 * wms.Source
 * The Source object manages a single WMS connection.  Multiple "layers" can be
 * created with the getLayer function, but a single request will be sent for
 * each image update.  Can be used in non-tiled "overlay" mode (default), or
 * tiled mode, via an internal wms.Overlay or wms.TileLayer, respectively.
 */
/*!
 * leaflet.wms.js
 * A collection of Leaflet utilities for working with Web Mapping services.
 * (c) 2014-2016, Houston Engineering, Inc.
 * MIT License
 */

wms.Source = _Layer.Layer.extend({
    'options': {
        'untiled': true,
        'identify': true
    },

    'initialize': function initialize(url, options) {
        Util.setOptions(this, options);
        if (this.options.tiled) {
            this.options.untiled = false;
        }
        this._url = url;
        this._subLayers = {};
        this._overlay = this.createOverlay(this.options.untiled);
    },

    'createOverlay': function createOverlay(untiled) {
        // Create overlay with all options other than untiled & identify
        var overlayOptions = {};
        for (var opt in this.options) {
            if (opt != 'untiled' && opt != 'identify') {
                overlayOptions[opt] = this.options[opt];
            }
        }
        if (untiled) {
            return wms.overlay(this._url, overlayOptions);
        } else {
            return wms.tileLayer(this._url, overlayOptions);
        }
    },

    'onAdd': function onAdd() {
        this.refreshOverlay();
    },

    'onRemove': function onRemove() {
        if (this._map) this._overlay.removeFrom(this._map);
    },

    'getEvents': function getEvents() {
        if (this.options.identify) {
            return { 'click': this.identify };
        } else {
            return {};
        }
    },

    'setOpacity': function setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._overlay) {
            this._overlay.setOpacity(opacity);
        }
    },

    'bringToBack': function bringToBack() {
        this.options.isBack = true;
        if (this._overlay) {
            this._overlay.bringToBack();
        }
    },

    'bringToFront': function bringToFront() {
        this.options.isBack = false;
        if (this._overlay) {
            this._overlay.bringToFront();
        }
    },

    'getLayer': function getLayer(name) {
        return wms.layer(this, name);
    },

    'getSubLayers': function getSubLayers() {
        return this._subLayers;
    },

    'addSubLayer': function addSubLayer(name) {
        this._subLayers[name] = true;
        this.refreshOverlay();
    },

    'removeSubLayer': function removeSubLayer(name) {
        delete this._subLayers[name];
        this.refreshOverlay();
    },

    /* Efficient way to swap out all sub layers */
    'replaceAllSubLayers': function replaceAllSubLayers(newSubLayers) {
        this._subLayers = {};
        for (var i = 0; i < newSubLayers.length; i++) {
            this._subLayers[newSubLayers[i]] = true;
        }this.refreshOverlay();
    },

    'refreshOverlay': function refreshOverlay() {
        var subLayers = Object.keys(this._subLayers).join(",");
        if (!this._map) {
            return;
        }
        if (!subLayers) {
            this._overlay.remove();
        } else {
            this._overlay.setParams({ 'layers': subLayers });
            this._overlay.addTo(this._map);
        }
    },

    'identify': function identify(evt) {
        // Identify map features in response to map clicks. To customize this
        // behavior, create a class extending wms.Source and override one or
        // more of the following hook functions.

        var layers = this.getIdentifyLayers();
        if (!layers.length) {
            return;
        }
        this.getFeatureInfo(evt.containerPoint, evt.latlng, layers, this.showFeatureInfo);
    },

    'getFeatureInfo': function getFeatureInfo(point, latlng, layers, callback) {
        // Request WMS GetFeatureInfo and call callback with results
        // (split from identify() to faciliate use outside of map events)
        var params = this.getFeatureInfoParams(point, layers),
            url = this._url + Util.getParamString(params, this._url);

        this.showWaiting();
        this.ajax(url, done);

        function done(result) {
            this.hideWaiting();
            var text = this.parseFeatureInfo(result, url);
            callback.call(this, latlng, text);
        }
    },

    'ajax': function ajax(url, callback) {
        wms.ajax.call(this, url, callback);
    },

    'getIdentifyLayers': function getIdentifyLayers() {
        // Hook to determine which layers to identify
        if (this.options.identifyLayers) return this.options.identifyLayers;
        return Object.keys(this._subLayers);
    },

    'getFeatureInfoParams': function getFeatureInfoParams(point, layers) {
        // Hook to generate parameters for WMS service GetFeatureInfo request
        var wmsParams, overlay;
        if (this.options.untiled) {
            // Use existing overlay
            wmsParams = this._overlay.wmsParams;
        } else {
            // Create overlay instance to leverage updateWmsParams
            overlay = this.createOverlay(true);
            overlay.updateWmsParams(this._map);
            wmsParams = overlay.wmsParams;
            wmsParams.layers = layers.join(',');
        }
        var infoParams = {
            'request': 'GetFeatureInfo',
            'query_layers': layers.join(','),
            'X': Math.round(point.x),
            'Y': Math.round(point.y)
        };
        return Util.extend({}, wmsParams, infoParams);
    },

    'parseFeatureInfo': function parseFeatureInfo(result, url) {
        // Hook to handle parsing AJAX response
        if (result == "error") {
            // AJAX failed, possibly due to CORS issues.
            // Try loading content in <iframe>.
            result = "<iframe src='" + url + "' style='border:none'>";
        }
        return result;
    },

    'showFeatureInfo': function showFeatureInfo(latlng, info) {
        // Hook to handle displaying parsed AJAX response to the user
        if (!this._map) {
            return;
        }
        this._map.openPopup(info, latlng);
    },

    'showWaiting': function showWaiting() {
        // Hook to customize AJAX wait animation
        if (!this._map) return;
        this._map._container.style.cursor = "progress";
    },

    'hideWaiting': function hideWaiting() {
        // Hook to remove AJAX wait animation
        if (!this._map) return;
        this._map._container.style.cursor = "default";
    }
});

wms.source = function (url, options) {
    return new wms.Source(url, options);
};

/*
 * Layer
 * Leaflet "layer" with all actual rendering handled via an underlying Source
 * object.  Can be called directly with a URL to automatically create or reuse
 * an existing Source.  Note that the auto-source feature doesn't work well in
 * multi-map environments; so for best results, create a Source first and use
 * getLayer() to retrieve wms.Layer instances.
 */

wms.Layer = _Layer.Layer.extend({
    'initialize': function initialize(source, layerName, options) {
        Util.setOptions(this, options);
        if (!source.addSubLayer) {
            // Assume source is a URL
            source = wms.getSourceForUrl(source, options);
        }
        this._source = source;
        this._name = layerName;
    },
    'onAdd': function onAdd() {
        if (!this._source._map) this._source.addTo(this._map);
        this._source.addSubLayer(this._name);
    },
    'onRemove': function onRemove() {
        this._source.removeSubLayer(this._name);
    },
    'setOpacity': function setOpacity(opacity) {
        this._source.setOpacity(opacity);
    },
    'bringToBack': function bringToBack() {
        this._source.bringToBack();
    },
    'bringToFront': function bringToFront() {
        this._source.bringToFront();
    }
});

wms.layer = function (source, options) {
    return new wms.Layer(source, options);
};

// Cache of sources for use with wms.Layer auto-source option
wms.sources = {};
wms.getSourceForUrl = function (url, options) {
    if (!wms.sources[url]) {
        wms.sources[url] = wms.source(url, options);
    }
    return wms.sources[url];
};

// Copy tiled WMS layer from leaflet core, in case we need to subclass it later
wms.TileLayer = _TileLayerWMS.TileLayerWMS;
wms.tileLayer = _TileLayerWMS.tileLayerWMS;

/*
 * wms.Overlay:
 * "Single Tile" WMS image overlay that updates with map changes.
 * Portions of wms.Overlay are directly extracted from L.TileLayer.WMS.
 * See Leaflet license.
 */
wms.Overlay = _Layer.Layer.extend({
    'defaultWmsParams': {
        'service': 'WMS',
        'request': 'GetMap',
        'version': '1.1.1',
        'layers': '',
        'styles': '',
        'format': 'image/jpeg',
        'transparent': false
    },

    'options': {
        'crs': null,
        'uppercase': false,
        'attribution': '',
        'opacity': 1,
        'isBack': false,
        'minZoom': 0,
        'maxZoom': 18
    },

    'initialize': function initialize(url, options) {
        this._url = url;

        // Move WMS parameters to params object
        var params = {},
            opts = {};
        for (var opt in options) {
            if (opt in this.options) {
                opts[opt] = options[opt];
            } else {
                params[opt] = options[opt];
            }
        }
        Util.setOptions(this, opts);
        this.wmsParams = Util.extend({}, this.defaultWmsParams, params);
    },

    'setParams': function setParams(params) {
        Util.extend(this.wmsParams, params);
        this.update();
    },

    'getAttribution': function getAttribution() {
        return this.options.attribution;
    },

    'onAdd': function onAdd() {
        this.update();
    },

    'onRemove': function onRemove(map) {
        if (this._currentOverlay) {
            map.removeLayer(this._currentOverlay);
            delete this._currentOverlay;
        }
        if (this._currentUrl) {
            delete this._currentUrl;
        }
    },

    'getEvents': function getEvents() {
        return {
            'moveend': this.update
        };
    },

    'update': function update() {
        if (!this._map) {
            return;
        }
        // Determine image URL and whether it has changed since last update
        this.updateWmsParams();
        var url = this.getImageUrl();
        if (this._currentUrl == url) {
            return;
        }
        this._currentUrl = url;

        // Keep current image overlay in place until new one loads
        // (inspired by esri.leaflet)
        var bounds = this._map.getBounds();
        var overlay = new _ImageOverlay.ImageOverlay(url, bounds, { 'opacity': 0 });
        overlay.addTo(this._map);
        overlay.once('load', _swap, this);
        function _swap() {
            if (!this._map) {
                return;
            }
            if (overlay._url != this._currentUrl) {
                this._map.removeLayer(overlay);
                return;
            } else if (this._currentOverlay) {
                this._map.removeLayer(this._currentOverlay);
            }
            this._currentOverlay = overlay;
            overlay.setOpacity(this.options.opacity ? this.options.opacity : 1);
            if (this.options.isBack === true) {
                overlay.bringToBack();
            }
            if (this.options.isBack === false) {
                overlay.bringToFront();
            }
        }
        if (this._map.getZoom() < this.options.minZoom || this._map.getZoom() > this.options.maxZoom) {
            this._map.removeLayer(overlay);
        }
    },

    'setOpacity': function setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._currentOverlay) {
            this._currentOverlay.setOpacity(opacity);
        }
    },

    'bringToBack': function bringToBack() {
        this.options.isBack = true;
        if (this._currentOverlay) {
            this._currentOverlay.bringToBack();
        }
    },

    'bringToFront': function bringToFront() {
        this.options.isBack = false;
        if (this._currentOverlay) {
            this._currentOverlay.bringToFront();
        }
    },

    // See L.TileLayer.WMS: onAdd() & getTileUrl()
    'updateWmsParams': function updateWmsParams(map) {
        if (!map) {
            map = this._map;
        }
        // Compute WMS options
        var bounds = map.getBounds();
        var size = map.getSize();
        var wmsVersion = parseFloat(this.wmsParams.version);
        var crs = this.options.crs || map.options.crs;
        var projectionKey = wmsVersion >= 1.3 ? 'crs' : 'srs';
        var nw = crs.project(bounds.getNorthWest());
        var se = crs.project(bounds.getSouthEast());

        // Assemble WMS parameter string
        var params = {
            'width': size.x,
            'height': size.y
        };
        params[projectionKey] = crs.code;
        params.bbox = (wmsVersion >= 1.3 && crs.code === _CRSEPSG.EPSG4326.code ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(',');

        Util.extend(this.wmsParams, params);
    },

    'getImageUrl': function getImageUrl() {
        var uppercase = this.options.uppercase || false;
        var pstr = Util.getParamString(this.wmsParams, this._url, uppercase);
        return this._url + pstr;
    }
});

wms.overlay = function (url, options) {
    return new wms.Overlay(url, options);
};

// Simple AJAX helper (since we can't assume jQuery etc. are present)
wms.ajax = function (url, callback) {
    var context = this,
        request = new XMLHttpRequest();
    request.onreadystatechange = change;
    request.open('GET', url);
    request.send();

    function change() {
        if (request.readyState === 4) {
            if (request.status === 200) {
                callback.call(context, request.responseText);
            } else {
                callback.call(context, "error");
            }
        }
    }
};

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletWMSLayer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletWMSLayer = exports.LeafletWMSLayer = function (_PolymerElement) {
  _inherits(LeafletWMSLayer, _PolymerElement);

  _createClass(LeafletWMSLayer, null, [{
    key: 'properties',
    get: function get() {
      return {
        wmsSource: Object,
        layer: {
          type: String,
          reflectToAttribute: true
        }
      };
    }
  }]);

  function LeafletWMSLayer() {
    _classCallCheck(this, LeafletWMSLayer);

    return _possibleConstructorReturn(this, (LeafletWMSLayer.__proto__ || Object.getPrototypeOf(LeafletWMSLayer)).call(this));
  }

  _createClass(LeafletWMSLayer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletWMSLayer.prototype.__proto__ || Object.getPrototypeOf(LeafletWMSLayer.prototype), 'connectedCallback', this).call(this);

      if (this.wmsSource === undefined || this.layer === '') return;
      this.wmsSource.addSubLayer(this.layer);
    }
  }]);

  return LeafletWMSLayer;
}(_polymerElement.Element);

customElements.define('leaflet-wms-layer', LeafletWMSLayer);

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletTileLayer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _TileLayer = __webpack_require__(52);

var _TileLayerWMS = __webpack_require__(53);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletTileLayer = exports.LeafletTileLayer = function (_PolymerElement) {
  _inherits(LeafletTileLayer, _PolymerElement);

  _createClass(LeafletTileLayer, null, [{
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },
        base: Boolean,
        url: {
          type: String,
          value: "//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          observer: '_urlChanged',
          reflectToAttribute: true
        },
        format: {
          type: String,
          observer: '_formatChanged',
          reflectToAttribute: true
        },
        layers: {
          type: String,
          observer: '_layersChanged'
        },
        minZoom: Number,
        maxZoom: Number,
        attribution: String
      };
    }
  }]);

  function LeafletTileLayer() {
    _classCallCheck(this, LeafletTileLayer);

    return _possibleConstructorReturn(this, (LeafletTileLayer.__proto__ || Object.getPrototypeOf(LeafletTileLayer)).call(this));
  }

  _createClass(LeafletTileLayer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletTileLayer.prototype.__proto__ || Object.getPrototypeOf(LeafletTileLayer.prototype), 'connectedCallback', this).call(this);
    }
  }, {
    key: '_urlChanged',
    value: function _urlChanged() {
      console.log('url changed', this.url);
      if (this.leafletLayer) this.leafletLayer.setUrl(this.url);
    }
  }, {
    key: '_layersChanged',
    value: function _layersChanged() {
      console.log('layers changed', this.layers);
      if (this.leafletLayer && this.leafletLayer instanceof _TileLayerWMS.TileLayerWMS) this.leafletLayer.setParams({ layers: this.layers });
    }
  }, {
    key: '_formatChanged',
    value: function _formatChanged() {
      console.log('format changed', this.format);

      if (this.leafletLayer && this.map) {
        this.leafletLayer.removeFrom(this.map);
      }

      var options = {
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        attribution: this.attribution
      };

      switch (this.format) {
        case 'XYZ':
          this.leafletLayer = new _TileLayer.TileLayer(this.url, options);
          break;
        case 'WMS':
          this.leafletLayer = new _TileLayerWMS.TileLayerWMS(this.url, Object.assign(options, {
            layers: this.layers,
            format: 'image/png',
            transparent: false,
            hints: 'quality'
          }));
          break;
        default:
          console.error('Invalid leaflet-tile-layer format: ', this.format);
          return;
      }

      if (this.map) this.leafletLayer.addTo(this.map);else console.log('map not yet set');
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      console.log('map set');
      if (this.leafletLayer && !this.map.hasLayer(this.leafletLayer)) {
        console.log('no layer yet, adding');
        this.leafletLayer.addTo(this.map);
      } else {
        console.log('layer object not set / layer exists, skipping');
      }
    }
  }]);

  return LeafletTileLayer;
}(_polymerElement.Element);

customElements.define('leaflet-tile-layer', LeafletTileLayer);

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletGeoJSON = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _domRepeat = __webpack_require__(44);

var _CircleMarker = __webpack_require__(32);

var _GeoJSON = __webpack_require__(88);

__webpack_require__(146);

var _src = __webpack_require__(156);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Dev only
// import { LeafletMap } from '../../@ggcity/leaflet-map/leaflet-map.js';

var LeafletGeoJSON = exports.LeafletGeoJSON = function (_PolymerElement) {
  _inherits(LeafletGeoJSON, _PolymerElement);

  _createClass(LeafletGeoJSON, null, [{
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },

        source: {
          type: String,
          observer: '_sourceChange',
          reflectToAttribute: true
        },

        fillColor: {
          type: String,
          value: '#FF80AB'
        },

        outlineColor: {
          type: String,
          value: '#FF1744'
        },

        radius: {
          type: Number,
          value: 10
        },

        weight: {
          type: Number,
          value: 3
        },

        opacity: {
          type: Number,
          value: 1.0
        },

        fillOpacity: {
          type: Number,
          value: 1.0
        },

        cluster: Boolean,
        maxClusterRadius: {
          type: Number,
          value: 80
        },
        identify: Boolean,
        minZoom: Number,
        maxZoom: Number,
        attribution: String
      };
    }
  }]);

  function LeafletGeoJSON() {
    _classCallCheck(this, LeafletGeoJSON);

    return _possibleConstructorReturn(this, (LeafletGeoJSON.__proto__ || Object.getPrototypeOf(LeafletGeoJSON)).call(this));
  }

  _createClass(LeafletGeoJSON, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletGeoJSON.prototype.__proto__ || Object.getPrototypeOf(LeafletGeoJSON.prototype), 'connectedCallback', this).call(this);

      this._clusterGroup = new _src.MarkerClusterGroup({
        showCoverageOnHover: false,
        maxClusterRadius: this.maxClusterRadius
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(LeafletGeoJSON.prototype.__proto__ || Object.getPrototypeOf(LeafletGeoJSON.prototype), 'disconnectedCallback', this).call(this);
      this.map.removeLayer(this._clusterGroup);
      this._clusterGroup.clearLayers();
    }
  }, {
    key: '_addGeoJSONLayer',
    value: function _addGeoJSONLayer(geojson) {
      this._clusterGroup.clearLayers();

      this._geoJSONOptions = {
        pointToLayer: this.cluster ? this._clusterPoints.bind(this) : this._simplePoints.bind(this),
        attribution: this.attribution,
        onEachFeature: this.identify ? this._onEachFeature.bind(this) : null
      };
      this._geoJSONLayer = new _GeoJSON.GeoJSON(geojson, this._geoJSONOptions);

      this.map.addLayer(this._clusterGroup);
    }
  }, {
    key: '_clusterPoints',
    value: function _clusterPoints(feature, latlng) {
      this._clusterGroup.addLayer(new _CircleMarker.CircleMarker(latlng, {
        color: this.outlineColor,
        fillColor: this.fillColor,
        radius: this.radius,
        weight: this.weight,
        opacity: this.opacity,
        fillOpacity: this.fillOpacity
      }).bindPopup(this._generatePopupContent(feature)));
    }
  }, {
    key: '_simplePoints',
    value: function _simplePoints(feature, latlng) {
      return new _CircleMarker.CircleMarker(latlng);
    }
  }, {
    key: '_onEachFeature',
    value: function _onEachFeature(feature, layer) {
      layer.bindPopup(this._generatePopupContent(feature));
    }
  }, {
    key: '_generatePopupContent',
    value: function _generatePopupContent(feature) {
      var rows = '';
      for (var p in feature.properties) {
        var fieldName = p.replace(/\w\S*/g, function (txt) {
          return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase().replace('_', ' ');
        });
        rows += '<tr><td>' + fieldName + ':</td><td><strong>' + feature.properties[p] + '</strong></td></tr>';
      }

      return '<table>' + rows + '</table>';
    }
  }, {
    key: '_sourceChange',
    value: function _sourceChange() {
      if (this.map && this._geoJSONLayer) this._geoJSONLayer.removeFrom(this.map);

      fetch(this.source).then(function (res) {
        return res.json();
      }).then(this._addGeoJSONLayer.bind(this));
      // .catch(() => alert('Unable to load layer'));
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      // console.log('adding layer');
      // this.map.addLayer(this._geoJSONLayer);
    }
  }]);

  return LeafletGeoJSON;
}(_polymerElement.Element);

customElements.define('leaflet-geojson-points', LeafletGeoJSON);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.version = undefined;

var _index = __webpack_require__(81);

Object.keys(_index).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index[key];
		}
	});
});

var _index2 = __webpack_require__(147);

Object.keys(_index2).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index2[key];
		}
	});
});

var _index3 = __webpack_require__(148);

Object.keys(_index3).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index3[key];
		}
	});
});

var _index4 = __webpack_require__(149);

Object.keys(_index4).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index4[key];
		}
	});
});

var _index5 = __webpack_require__(150);

Object.keys(_index5).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index5[key];
		}
	});
});

var _index6 = __webpack_require__(82);

Object.keys(_index6).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index6[key];
		}
	});
});

var _index7 = __webpack_require__(79);

Object.keys(_index7).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index7[key];
		}
	});
});
exports.noConflict = noConflict;

var _package = __webpack_require__(155);

var _Util = __webpack_require__(0);

exports.version = _package.version;

// control


// core


// dom


// geometry


// geo


// layer


// map

// misc

var oldL = window.L;
function noConflict() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

Object.freeze = _Util.freeze;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setOptions = exports.stamp = exports.bind = exports.extend = exports.Util = exports.Handler = exports.Mixin = exports.Evented = exports.Class = exports.Browser = undefined;

var _Class = __webpack_require__(20);

Object.defineProperty(exports, 'Class', {
  enumerable: true,
  get: function get() {
    return _Class.Class;
  }
});

var _Handler = __webpack_require__(14);

Object.defineProperty(exports, 'Handler', {
  enumerable: true,
  get: function get() {
    return _Handler.Handler;
  }
});

var _Util = __webpack_require__(0);

Object.defineProperty(exports, 'extend', {
  enumerable: true,
  get: function get() {
    return _Util.extend;
  }
});
Object.defineProperty(exports, 'bind', {
  enumerable: true,
  get: function get() {
    return _Util.bind;
  }
});
Object.defineProperty(exports, 'stamp', {
  enumerable: true,
  get: function get() {
    return _Util.stamp;
  }
});
Object.defineProperty(exports, 'setOptions', {
  enumerable: true,
  get: function get() {
    return _Util.setOptions;
  }
});

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Events = __webpack_require__(19);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Browser = Browser;
exports.Evented = _Events.Evented;
var Mixin = exports.Mixin = { Events: _Events.Events };

exports.Util = Util;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Draggable = exports.DomUtil = exports.DomEvent = exports.PosAnimation = undefined;

var _PosAnimation = __webpack_require__(77);

Object.defineProperty(exports, 'PosAnimation', {
  enumerable: true,
  get: function get() {
    return _PosAnimation.PosAnimation;
  }
});

var _Draggable = __webpack_require__(49);

Object.defineProperty(exports, 'Draggable', {
  enumerable: true,
  get: function get() {
    return _Draggable.Draggable;
  }
});

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolyUtil = exports.LineUtil = exports.transformation = exports.Transformation = exports.bounds = exports.Bounds = exports.point = exports.Point = undefined;

var _Point = __webpack_require__(3);

Object.defineProperty(exports, 'Point', {
  enumerable: true,
  get: function get() {
    return _Point.Point;
  }
});
Object.defineProperty(exports, 'point', {
  enumerable: true,
  get: function get() {
    return _Point.toPoint;
  }
});

var _Bounds = __webpack_require__(8);

Object.defineProperty(exports, 'Bounds', {
  enumerable: true,
  get: function get() {
    return _Bounds.Bounds;
  }
});
Object.defineProperty(exports, 'bounds', {
  enumerable: true,
  get: function get() {
    return _Bounds.toBounds;
  }
});

var _Transformation = __webpack_require__(21);

Object.defineProperty(exports, 'Transformation', {
  enumerable: true,
  get: function get() {
    return _Transformation.Transformation;
  }
});
Object.defineProperty(exports, 'transformation', {
  enumerable: true,
  get: function get() {
    return _Transformation.toTransformation;
  }
});

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _PolyUtil = __webpack_require__(86);

var PolyUtil = _interopRequireWildcard(_PolyUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Projection = exports.latLngBounds = exports.LatLngBounds = exports.latLng = exports.LatLng = undefined;

var _LatLng = __webpack_require__(9);

Object.defineProperty(exports, 'LatLng', {
  enumerable: true,
  get: function get() {
    return _LatLng.LatLng;
  }
});
Object.defineProperty(exports, 'latLng', {
  enumerable: true,
  get: function get() {
    return _LatLng.toLatLng;
  }
});

var _LatLngBounds = __webpack_require__(10);

Object.defineProperty(exports, 'LatLngBounds', {
  enumerable: true,
  get: function get() {
    return _LatLngBounds.LatLngBounds;
  }
});
Object.defineProperty(exports, 'latLngBounds', {
  enumerable: true,
  get: function get() {
    return _LatLngBounds.toLatLngBounds;
  }
});

var _index = __webpack_require__(151);

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

var _index2 = __webpack_require__(154);

var Projection = _interopRequireWildcard(_index2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Projection = Projection;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CRS = undefined;

var _CRS = __webpack_require__(47);

var _CRS2 = __webpack_require__(16);

var _CRS3 = __webpack_require__(152);

var _CRS4 = __webpack_require__(73);

var _CRS5 = __webpack_require__(54);

var _CRS6 = __webpack_require__(153);

_CRS.CRS.Earth = _CRS2.Earth;
_CRS.CRS.EPSG3395 = _CRS3.EPSG3395;
_CRS.CRS.EPSG3857 = _CRS4.EPSG3857;
_CRS.CRS.EPSG900913 = _CRS4.EPSG900913;
_CRS.CRS.EPSG4326 = _CRS5.EPSG4326;
_CRS.CRS.Simple = _CRS6.Simple;

exports.CRS = _CRS.CRS;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.EPSG3395 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(89);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = exports.EPSG3395 = Util.extend({}, _CRS.Earth, {
	code: 'EPSG:3395',
	projection: _Projection.Mercator,

	transformation: function () {
		var scale = 0.5 / (Math.PI * _Projection.Mercator.R);
		return (0, _Transformation.toTransformation)(scale, 0.5, -scale, 0.5);
	}()
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Simple = undefined;

var _CRS = __webpack_require__(47);

var _Projection = __webpack_require__(55);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = exports.Simple = Util.extend({}, _CRS.CRS, {
	projection: _Projection.LonLat,
	transformation: (0, _Transformation.toTransformation)(1, 0, -1, 0),

	scale: function scale(zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function zoom(scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function distance(latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Projection = __webpack_require__(55);

Object.defineProperty(exports, 'LonLat', {
  enumerable: true,
  get: function get() {
    return _Projection.LonLat;
  }
});

var _Projection2 = __webpack_require__(89);

Object.defineProperty(exports, 'Mercator', {
  enumerable: true,
  get: function get() {
    return _Projection2.Mercator;
  }
});

var _Projection3 = __webpack_require__(74);

Object.defineProperty(exports, 'SphericalMercator', {
  enumerable: true,
  get: function get() {
    return _Projection3.SphericalMercator;
  }
});

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = {"name":"leaflet","version":"1.2.0","description":"JavaScript library for mobile-friendly interactive maps","devDependencies":{"eslint":"^3.5.0 <3.6.0","eslint-config-mourner":"^2.0.1","git-rev-sync":"^1.8.0","happen":"~0.3.1","jake":"~8.0.12","karma":"^1.3.0","karma-chrome-launcher":"^2.0.0","karma-coverage":"~1.1.1","karma-firefox-launcher":"~1.0.0","karma-mocha":"^1.2.0","karma-phantomjs-launcher":"^1.0.2","karma-rollup-preprocessor":"^4.0.2","karma-safari-launcher":"~1.0.0","leafdoc":"^1.4.1","mocha":"^3.5.0","phantomjs-prebuilt":"^2.1.12","prosthetic-hand":"^1.3.1","rollup":"^0.45.2","rollup-plugin-git-version":"0.2.1","rollup-plugin-json":"^2.1.0","rollup-watch":"^4.3.1","source-map":"^0.5.6","ssri":"^4.1.2","uglify-js":"~3.0.26"},"main":"dist/leaflet-src.js","style":"dist/leaflet.css","files":["dist","src","!dist/leaflet.zip"],"scripts":{"test-jake":"jake test","test":"jake test","build-jake":"jake build","build":"npm run rollup && npm run uglify","release":"./build/publish.sh","lint":"eslint src; eslint spec/suites","lintfix":"eslint src --fix; eslint spec/suites --fix; ","rollup":"rollup -c build/rollup-config.js","watch":"rollup -w -c build/rollup-watch-config.js","uglify":"uglifyjs dist/leaflet-src.js -c -m -o dist/leaflet.js --source-map filename=dist/leaflet.js.map --in-source-map dist/leaflet-src.js.map --source-map-url leaflet.js.map --comments","integrity":"nodejs ./build/integrity.js"},"eslintConfig":{"root":true,"globals":{"L":true},"env":{"commonjs":true,"amd":true,"node":false},"extends":"mourner","parserOptions":{"ecmaVersion":6,"sourceType":"module"},"rules":{"linebreak-style":[0,"unix"],"no-mixed-spaces-and-tabs":[2,"smart-tabs"],"indent":[2,"tab",{"VariableDeclarator":0}],"curly":2,"spaced-comment":2,"strict":0,"wrap-iife":0,"key-spacing":0,"consistent-return":0}},"repository":{"type":"git","url":"git://github.com/Leaflet/Leaflet.git"},"keywords":["gis","map"],"license":"BSD-2-Clause"}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerCluster = exports.MarkerClusterGroup = undefined;

var _MarkerClusterGroup = __webpack_require__(157);

Object.defineProperty(exports, 'MarkerClusterGroup', {
  enumerable: true,
  get: function get() {
    return _MarkerClusterGroup.MarkerClusterGroup;
  }
});

var _MarkerCluster = __webpack_require__(158);

Object.defineProperty(exports, 'MarkerCluster', {
  enumerable: true,
  get: function get() {
    return _MarkerCluster.MarkerCluster;
  }
});

__webpack_require__(159);

__webpack_require__(160);

__webpack_require__(161);

__webpack_require__(162);

__webpack_require__(163);

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

var MarkerClusterGroup = exports.MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({

	options: {
		maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
		iconCreateFunction: null,
		clusterPane: L.Marker.prototype.options.pane,

		spiderfyOnMaxZoom: true,
		showCoverageOnHover: true,
		zoomToBoundsOnClick: true,
		singleMarkerMode: false,

		disableClusteringAtZoom: null,

		// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
		// is the default behaviour for performance reasons.
		removeOutsideVisibleBounds: true,

		// Set to false to disable all animations (zoom and spiderfy).
		// If false, option animateAddingMarkers below has no effect.
		// If L.DomUtil.TRANSITION is falsy, this option has no effect.
		animate: true,

		//Whether to animate adding markers after adding the MarkerClusterGroup to the map
		// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
		animateAddingMarkers: false,

		//Increase to increase the distance away that spiderfied markers appear from the center
		spiderfyDistanceMultiplier: 1,

		// Make it possible to specify a polyline options on a spider leg
		spiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },

		// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
		chunkedLoading: false,
		chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
		chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
		chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

		//Options to pass to the L.Polygon constructor
		polygonOptions: {}
	},

	initialize: function initialize(options) {
		L.Util.setOptions(this, options);
		if (!this.options.iconCreateFunction) {
			this.options.iconCreateFunction = this._defaultIconCreateFunction;
		}

		this._featureGroup = L.featureGroup();
		this._featureGroup.addEventParent(this);

		this._nonPointGroup = L.featureGroup();
		this._nonPointGroup.addEventParent(this);

		this._inZoomAnimation = 0;
		this._needsClustering = [];
		this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
		//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
		this._currentShownBounds = null;

		this._queue = [];

		this._childMarkerEventHandlers = {
			'dragstart': this._childMarkerDragStart,
			'move': this._childMarkerMoved,
			'dragend': this._childMarkerDragEnd
		};

		// Hook the appropriate animation methods.
		var animate = L.DomUtil.TRANSITION && this.options.animate;
		L.extend(this, animate ? this._withAnimation : this._noAnimation);
		// Remember which MarkerCluster class to instantiate (animated or not).
		this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
	},

	addLayer: function addLayer(layer) {

		if (layer instanceof L.LayerGroup) {
			return this.addLayers([layer]);
		}

		//Don't cluster non point data
		if (!layer.getLatLng) {
			this._nonPointGroup.addLayer(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (!this._map) {
			this._needsClustering.push(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (this.hasLayer(layer)) {
			return this;
		}

		//If we have already clustered we'll need to add this one to a cluster

		if (this._unspiderfy) {
			this._unspiderfy();
		}

		this._addLayer(layer, this._maxZoom);
		this.fire('layeradd', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Work out what is visible
		var visibleLayer = layer,
		    currentZoom = this._zoom;
		if (layer.__parent) {
			while (visibleLayer.__parent._zoom >= currentZoom) {
				visibleLayer = visibleLayer.__parent;
			}
		}

		if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
			if (this.options.animateAddingMarkers) {
				this._animationAddLayer(layer, visibleLayer);
			} else {
				this._animationAddLayerNonAnimated(layer, visibleLayer);
			}
		}
		return this;
	},

	removeLayer: function removeLayer(layer) {

		if (layer instanceof L.LayerGroup) {
			return this.removeLayers([layer]);
		}

		//Non point layers
		if (!layer.getLatLng) {
			this._nonPointGroup.removeLayer(layer);
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!this._map) {
			if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
				this._needsRemoving.push({ layer: layer, latlng: layer._latlng });
			}
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!layer.__parent) {
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			this._unspiderfyLayer(layer);
		}

		//Remove the marker from clusters
		this._removeLayer(layer, true);
		this.fire('layerremove', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		layer.off(this._childMarkerEventHandlers, this);

		if (this._featureGroup.hasLayer(layer)) {
			this._featureGroup.removeLayer(layer);
			if (layer.clusterShow) {
				layer.clusterShow();
			}
		}

		return this;
	},

	//Takes an array of markers and adds them in bulk
	addLayers: function addLayers(layersArray, skipLayerAddEvent) {
		if (!L.Util.isArray(layersArray)) {
			return this.addLayer(layersArray);
		}

		var fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    chunked = this.options.chunkedLoading,
		    chunkInterval = this.options.chunkInterval,
		    chunkProgress = this.options.chunkProgress,
		    l = layersArray.length,
		    offset = 0,
		    originalArray = true,
		    m;

		if (this._map) {
			var started = new Date().getTime();
			var process = L.bind(function () {
				var start = new Date().getTime();
				for (; offset < l; offset++) {
					if (chunked && offset % 200 === 0) {
						// every couple hundred markers, instrument the time elapsed since processing started:
						var elapsed = new Date().getTime() - start;
						if (elapsed > chunkInterval) {
							break; // been working too hard, time to take a break :-)
						}
					}

					m = layersArray[offset];

					// Group of layers, append children to layersArray and skip.
					// Side effects:
					// - Total increases, so chunkProgress ratio jumps backward.
					// - Groups are not included in this group, only their non-group child layers (hasLayer).
					// Changing array length while looping does not affect performance in current browsers:
					// http://jsperf.com/for-loop-changing-length/6
					if (m instanceof L.LayerGroup) {
						if (originalArray) {
							layersArray = layersArray.slice();
							originalArray = false;
						}
						this._extractNonGroupLayers(m, layersArray);
						l = layersArray.length;
						continue;
					}

					//Not point data, can't be clustered
					if (!m.getLatLng) {
						npg.addLayer(m);
						if (!skipLayerAddEvent) {
							this.fire('layeradd', { layer: m });
						}
						continue;
					}

					if (this.hasLayer(m)) {
						continue;
					}

					this._addLayer(m, this._maxZoom);
					if (!skipLayerAddEvent) {
						this.fire('layeradd', { layer: m });
					}

					//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
					if (m.__parent) {
						if (m.__parent.getChildCount() === 2) {
							var markers = m.__parent.getAllChildMarkers(),
							    otherMarker = markers[0] === m ? markers[1] : markers[0];
							fg.removeLayer(otherMarker);
						}
					}
				}

				if (chunkProgress) {
					// report progress and time elapsed:
					chunkProgress(offset, l, new Date().getTime() - started);
				}

				// Completed processing all markers.
				if (offset === l) {

					// Refresh bounds and weighted positions.
					this._topClusterLevel._recalculateBounds();

					this._refreshClustersIcons();

					this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
				} else {
					setTimeout(process, this.options.chunkDelay);
				}
			}, this);

			process();
		} else {
			var needsClustering = this._needsClustering;

			for (; offset < l; offset++) {
				m = layersArray[offset];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				//Not point data, can't be clustered
				if (!m.getLatLng) {
					npg.addLayer(m);
					continue;
				}

				if (this.hasLayer(m)) {
					continue;
				}

				needsClustering.push(m);
			}
		}
		return this;
	},

	//Takes an array of markers and removes them in bulk
	removeLayers: function removeLayers(layersArray) {
		var i,
		    m,
		    l = layersArray.length,
		    fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    originalArray = true;

		if (!this._map) {
			for (i = 0; i < l; i++) {
				m = layersArray[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				this._arraySplice(this._needsClustering, m);
				npg.removeLayer(m);
				if (this.hasLayer(m)) {
					this._needsRemoving.push({ layer: m, latlng: m._latlng });
				}
				this.fire('layerremove', { layer: m });
			}
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();

			// Work on a copy of the array, so that next loop is not affected.
			var layersArray2 = layersArray.slice(),
			    l2 = l;
			for (i = 0; i < l2; i++) {
				m = layersArray2[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					this._extractNonGroupLayers(m, layersArray2);
					l2 = layersArray2.length;
					continue;
				}

				this._unspiderfyLayer(m);
			}
		}

		for (i = 0; i < l; i++) {
			m = layersArray[i];

			// Group of layers, append children to layersArray and skip.
			if (m instanceof L.LayerGroup) {
				if (originalArray) {
					layersArray = layersArray.slice();
					originalArray = false;
				}
				this._extractNonGroupLayers(m, layersArray);
				l = layersArray.length;
				continue;
			}

			if (!m.__parent) {
				npg.removeLayer(m);
				this.fire('layerremove', { layer: m });
				continue;
			}

			this._removeLayer(m, true, true);
			this.fire('layerremove', { layer: m });

			if (fg.hasLayer(m)) {
				fg.removeLayer(m);
				if (m.clusterShow) {
					m.clusterShow();
				}
			}
		}

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Fix up the clusters and markers on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

		return this;
	},

	//Removes all layers from the MarkerClusterGroup
	clearLayers: function clearLayers() {
		//Need our own special implementation as the LayerGroup one doesn't work for us

		//If we aren't on the map (yet), blow away the markers we know of
		if (!this._map) {
			this._needsClustering = [];
			delete this._gridClusters;
			delete this._gridUnclustered;
		}

		if (this._noanimationUnspiderfy) {
			this._noanimationUnspiderfy();
		}

		//Remove all the visible layers
		this._featureGroup.clearLayers();
		this._nonPointGroup.clearLayers();

		this.eachLayer(function (marker) {
			marker.off(this._childMarkerEventHandlers, this);
			delete marker.__parent;
		}, this);

		if (this._map) {
			//Reset _topClusterLevel and the DistanceGrids
			this._generateInitialClusters();
		}

		return this;
	},

	//Override FeatureGroup.getBounds as it doesn't work
	getBounds: function getBounds() {
		var bounds = new L.LatLngBounds();

		if (this._topClusterLevel) {
			bounds.extend(this._topClusterLevel._bounds);
		}

		for (var i = this._needsClustering.length - 1; i >= 0; i--) {
			bounds.extend(this._needsClustering[i].getLatLng());
		}

		bounds.extend(this._nonPointGroup.getBounds());

		return bounds;
	},

	//Overrides LayerGroup.eachLayer
	eachLayer: function eachLayer(method, context) {
		var markers = this._needsClustering.slice(),
		    needsRemoving = this._needsRemoving,
		    thisNeedsRemoving,
		    i,
		    j;

		if (this._topClusterLevel) {
			this._topClusterLevel.getAllChildMarkers(markers);
		}

		for (i = markers.length - 1; i >= 0; i--) {
			thisNeedsRemoving = true;

			for (j = needsRemoving.length - 1; j >= 0; j--) {
				if (needsRemoving[j].layer === markers[i]) {
					thisNeedsRemoving = false;
					break;
				}
			}

			if (thisNeedsRemoving) {
				method.call(context, markers[i]);
			}
		}

		this._nonPointGroup.eachLayer(method, context);
	},

	//Overrides LayerGroup.getLayers
	getLayers: function getLayers() {
		var layers = [];
		this.eachLayer(function (l) {
			layers.push(l);
		});
		return layers;
	},

	//Overrides LayerGroup.getLayer, WARNING: Really bad performance
	getLayer: function getLayer(id) {
		var result = null;

		id = parseInt(id, 10);

		this.eachLayer(function (l) {
			if (L.stamp(l) === id) {
				result = l;
			}
		});

		return result;
	},

	//Returns true if the given layer is in this MarkerClusterGroup
	hasLayer: function hasLayer(layer) {
		if (!layer) {
			return false;
		}

		var i,
		    anArray = this._needsClustering;

		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return true;
			}
		}

		anArray = this._needsRemoving;
		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i].layer === layer) {
				return false;
			}
		}

		return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
	},

	//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
	zoomToShowLayer: function zoomToShowLayer(layer, callback) {

		if (typeof callback !== 'function') {
			callback = function callback() {};
		}

		var showMarker = function showMarker() {
			if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
				this._map.off('moveend', showMarker, this);
				this.off('animationend', showMarker, this);

				if (layer._icon) {
					callback();
				} else if (layer.__parent._icon) {
					this.once('spiderfied', callback, this);
					layer.__parent.spiderfy();
				}
			}
		};

		if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
			//Layer is visible ond on screen, immediate return
			callback();
		} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {
			//Layer should be visible at this zoom level. It must not be on screen so just pan over to it
			this._map.on('moveend', showMarker, this);
			this._map.panTo(layer.getLatLng());
		} else {
			this._map.on('moveend', showMarker, this);
			this.on('animationend', showMarker, this);
			layer.__parent.zoomToBounds();
		}
	},

	//Overrides FeatureGroup.onAdd
	onAdd: function onAdd(map) {
		this._map = map;
		var i, l, layer;

		if (!isFinite(this._map.getMaxZoom())) {
			throw "Map has no maxZoom specified";
		}

		this._featureGroup.addTo(map);
		this._nonPointGroup.addTo(map);

		if (!this._gridClusters) {
			this._generateInitialClusters();
		}

		this._maxLat = map.options.crs.projection.MAX_LATITUDE;

		//Restore all the positions as they are in the MCG before removing them
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			layer.newlatlng = layer.layer._latlng;
			layer.layer._latlng = layer.latlng;
		}
		//Remove them, then restore their new positions
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			this._removeLayer(layer.layer, true);
			layer.layer._latlng = layer.newlatlng;
		}
		this._needsRemoving = [];

		//Remember the current zoom level and bounds
		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();

		this._map.on('zoomend', this._zoomEnd, this);
		this._map.on('moveend', this._moveEnd, this);

		if (this._spiderfierOnAdd) {
			//TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnAdd();
		}

		this._bindEvents();

		//Actually add our markers to the map:
		l = this._needsClustering;
		this._needsClustering = [];
		this.addLayers(l, true);
	},

	//Overrides FeatureGroup.onRemove
	onRemove: function onRemove(map) {
		map.off('zoomend', this._zoomEnd, this);
		map.off('moveend', this._moveEnd, this);

		this._unbindEvents();

		//In case we are in a cluster animation
		this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

		if (this._spiderfierOnRemove) {
			//TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnRemove();
		}

		delete this._maxLat;

		//Clean up all the layers we added to the map
		this._hideCoverage();
		this._featureGroup.remove();
		this._nonPointGroup.remove();

		this._featureGroup.clearLayers();

		this._map = null;
	},

	getVisibleParent: function getVisibleParent(marker) {
		var vMarker = marker;
		while (vMarker && !vMarker._icon) {
			vMarker = vMarker.__parent;
		}
		return vMarker || null;
	},

	//Remove the given object from the given array
	_arraySplice: function _arraySplice(anArray, obj) {
		for (var i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === obj) {
				anArray.splice(i, 1);
				return true;
			}
		}
	},

	/**
  * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
  * @param marker to be removed from _gridUnclustered.
  * @param z integer bottom start zoom level (included)
  * @private
  */
	_removeFromGridUnclustered: function _removeFromGridUnclustered(marker, z) {
		var map = this._map,
		    gridUnclustered = this._gridUnclustered,
		    minZoom = Math.floor(this._map.getMinZoom());

		for (; z >= minZoom; z--) {
			if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
				break;
			}
		}
	},

	_childMarkerDragStart: function _childMarkerDragStart(e) {
		e.target.__dragStart = e.target._latlng;
	},

	_childMarkerMoved: function _childMarkerMoved(e) {
		if (!this._ignoreMove && !e.target.__dragStart) {
			var isPopupOpen = e.target._popup && e.target._popup.isOpen();

			this._moveChild(e.target, e.oldLatLng, e.latlng);

			if (isPopupOpen) {
				e.target.openPopup();
			}
		}
	},

	_moveChild: function _moveChild(layer, from, to) {
		layer._latlng = from;
		this.removeLayer(layer);

		layer._latlng = to;
		this.addLayer(layer);
	},

	_childMarkerDragEnd: function _childMarkerDragEnd(e) {
		if (e.target.__dragStart) {
			this._moveChild(e.target, e.target.__dragStart, e.target._latlng);
		}
		delete e.target.__dragStart;
	},

	//Internal function for removing a marker from everything.
	//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
	_removeLayer: function _removeLayer(marker, removeFromDistanceGrid, dontUpdateMap) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    fg = this._featureGroup,
		    map = this._map,
		    minZoom = Math.floor(this._map.getMinZoom());

		//Remove the marker from distance clusters it might be in
		if (removeFromDistanceGrid) {
			this._removeFromGridUnclustered(marker, this._maxZoom);
		}

		//Work our way up the clusters removing them as we go if required
		var cluster = marker.__parent,
		    markers = cluster._markers,
		    otherMarker;

		//Remove the marker from the immediate parents marker list
		this._arraySplice(markers, marker);

		while (cluster) {
			cluster._childCount--;
			cluster._boundsNeedUpdate = true;

			if (cluster._zoom < minZoom) {
				//Top level, do nothing
				break;
			} else if (removeFromDistanceGrid && cluster._childCount <= 1) {
				//Cluster no longer required
				//We need to push the other marker up to the parent
				otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

				//Update distance grid
				gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
				gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

				//Move otherMarker up to parent
				this._arraySplice(cluster.__parent._childClusters, cluster);
				cluster.__parent._markers.push(otherMarker);
				otherMarker.__parent = cluster.__parent;

				if (cluster._icon) {
					//Cluster is currently on the map, need to put the marker on the map instead
					fg.removeLayer(cluster);
					if (!dontUpdateMap) {
						fg.addLayer(otherMarker);
					}
				}
			} else {
				cluster._iconNeedsUpdate = true;
			}

			cluster = cluster.__parent;
		}

		delete marker.__parent;
	},

	_isOrIsParent: function _isOrIsParent(el, oel) {
		while (oel) {
			if (el === oel) {
				return true;
			}
			oel = oel.parentNode;
		}
		return false;
	},

	//Override L.Evented.fire
	fire: function fire(type, data, propagate) {
		if (data && data.layer instanceof L.MarkerCluster) {
			//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
			if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {
				return;
			}
			type = 'cluster' + type;
		}

		L.FeatureGroup.prototype.fire.call(this, type, data, propagate);
	},

	//Override L.Evented.listens
	listens: function listens(type, propagate) {
		return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);
	},

	//Default functionality
	_defaultIconCreateFunction: function _defaultIconCreateFunction(cluster) {
		var childCount = cluster.getChildCount();

		var c = ' marker-cluster-';
		if (childCount < 10) {
			c += 'small';
		} else if (childCount < 100) {
			c += 'medium';
		} else {
			c += 'large';
		}

		return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
	},

	_bindEvents: function _bindEvents() {
		var map = this._map,
		    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

		//Zoom on cluster click or spiderfy if we are at the lowest level
		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.on('clusterclick', this._zoomOrSpiderfy, this);
		}

		//Show convex hull (boundary) polygon on mouse over
		if (showCoverageOnHover) {
			this.on('clustermouseover', this._showCoverage, this);
			this.on('clustermouseout', this._hideCoverage, this);
			map.on('zoomend', this._hideCoverage, this);
		}
	},

	_zoomOrSpiderfy: function _zoomOrSpiderfy(e) {
		var cluster = e.layer,
		    bottomCluster = cluster;

		while (bottomCluster._childClusters.length === 1) {
			bottomCluster = bottomCluster._childClusters[0];
		}

		if (bottomCluster._zoom === this._maxZoom && bottomCluster._childCount === cluster._childCount && this.options.spiderfyOnMaxZoom) {

			// All child markers are contained in a single cluster from this._maxZoom to this cluster.
			cluster.spiderfy();
		} else if (this.options.zoomToBoundsOnClick) {
			cluster.zoomToBounds();
		}

		// Focus the map again for keyboard users.
		if (e.originalEvent && e.originalEvent.keyCode === 13) {
			this._map._container.focus();
		}
	},

	_showCoverage: function _showCoverage(e) {
		var map = this._map;
		if (this._inZoomAnimation) {
			return;
		}
		if (this._shownPolygon) {
			map.removeLayer(this._shownPolygon);
		}
		if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
			this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
			map.addLayer(this._shownPolygon);
		}
	},

	_hideCoverage: function _hideCoverage() {
		if (this._shownPolygon) {
			this._map.removeLayer(this._shownPolygon);
			this._shownPolygon = null;
		}
	},

	_unbindEvents: function _unbindEvents() {
		var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
		    map = this._map;

		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.off('clusterclick', this._zoomOrSpiderfy, this);
		}
		if (showCoverageOnHover) {
			this.off('clustermouseover', this._showCoverage, this);
			this.off('clustermouseout', this._hideCoverage, this);
			map.off('zoomend', this._hideCoverage, this);
		}
	},

	_zoomEnd: function _zoomEnd() {
		if (!this._map) {
			//May have been removed from the map by a zoomEnd handler
			return;
		}
		this._mergeSplitClusters();

		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();
	},

	_moveEnd: function _moveEnd() {
		if (this._inZoomAnimation) {
			return;
		}

		var newBounds = this._getExpandedVisibleBounds();

		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);

		this._currentShownBounds = newBounds;
		return;
	},

	_generateInitialClusters: function _generateInitialClusters() {
		var maxZoom = Math.ceil(this._map.getMaxZoom()),
		    minZoom = Math.floor(this._map.getMinZoom()),
		    radius = this.options.maxClusterRadius,
		    radiusFn = radius;

		//If we just set maxClusterRadius to a single number, we need to create
		//a simple function to return that number. Otherwise, we just have to
		//use the function we've passed in.
		if (typeof radius !== "function") {
			radiusFn = function radiusFn() {
				return radius;
			};
		}

		if (this.options.disableClusteringAtZoom !== null) {
			maxZoom = this.options.disableClusteringAtZoom - 1;
		}
		this._maxZoom = maxZoom;
		this._gridClusters = {};
		this._gridUnclustered = {};

		//Set up DistanceGrids for each zoom
		for (var zoom = maxZoom; zoom >= minZoom; zoom--) {
			this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
			this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
		}

		// Instantiate the appropriate L.MarkerCluster class (animated or not).
		this._topClusterLevel = new this._markerCluster(this, minZoom - 1);
	},

	//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
	_addLayer: function _addLayer(layer, zoom) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    minZoom = Math.floor(this._map.getMinZoom()),
		    markerPoint,
		    z;

		if (this.options.singleMarkerMode) {
			this._overrideMarkerIcon(layer);
		}

		layer.on(this._childMarkerEventHandlers, this);

		//Find the lowest zoom level to slot this one in
		for (; zoom >= minZoom; zoom--) {
			markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

			//Try find a cluster close by
			var closest = gridClusters[zoom].getNearObject(markerPoint);
			if (closest) {
				closest._addChild(layer);
				layer.__parent = closest;
				return;
			}

			//Try find a marker close by to form a new cluster with
			closest = gridUnclustered[zoom].getNearObject(markerPoint);
			if (closest) {
				var parent = closest.__parent;
				if (parent) {
					this._removeLayer(closest, false);
				}

				//Create new cluster with these 2 in it

				var newCluster = new this._markerCluster(this, zoom, closest, layer);
				gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
				closest.__parent = newCluster;
				layer.__parent = newCluster;

				//First create any new intermediate parent clusters that don't exist
				var lastParent = newCluster;
				for (z = zoom - 1; z > parent._zoom; z--) {
					lastParent = new this._markerCluster(this, z, lastParent);
					gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
				}
				parent._addChild(lastParent);

				//Remove closest from this zoom level and any above that it is in, replace with newCluster
				this._removeFromGridUnclustered(closest, zoom);

				return;
			}

			//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
			gridUnclustered[zoom].addObject(layer, markerPoint);
		}

		//Didn't get in anything, add us to the top
		this._topClusterLevel._addChild(layer);
		layer.__parent = this._topClusterLevel;
		return;
	},

	/**
  * Refreshes the icon of all "dirty" visible clusters.
  * Non-visible "dirty" clusters will be updated when they are added to the map.
  * @private
  */
	_refreshClustersIcons: function _refreshClustersIcons() {
		this._featureGroup.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
				c._updateIcon();
			}
		});
	},

	//Enqueue code to fire after the marker expand/contract has happened
	_enqueue: function _enqueue(fn) {
		this._queue.push(fn);
		if (!this._queueTimeout) {
			this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
		}
	},
	_processQueue: function _processQueue() {
		for (var i = 0; i < this._queue.length; i++) {
			this._queue[i].call(this);
		}
		this._queue.length = 0;
		clearTimeout(this._queueTimeout);
		this._queueTimeout = null;
	},

	//Merge and split any existing clusters that are too big or small
	_mergeSplitClusters: function _mergeSplitClusters() {
		var mapZoom = Math.round(this._map._zoom);

		//In case we are starting to split before the animation finished
		this._processQueue();

		if (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) {
			//Zoom in, split
			this._animationStart();
			//Remove clusters now off screen
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());

			this._animationZoomIn(this._zoom, mapZoom);
		} else if (this._zoom > mapZoom) {
			//Zoom out, merge
			this._animationStart();

			this._animationZoomOut(this._zoom, mapZoom);
		} else {
			this._moveEnd();
		}
	},

	//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
	_getExpandedVisibleBounds: function _getExpandedVisibleBounds() {
		if (!this.options.removeOutsideVisibleBounds) {
			return this._mapBoundsInfinite;
		} else if (L.Browser.mobile) {
			return this._checkBoundsMaxLat(this._map.getBounds());
		}

		return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.
	},

	/**
  * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
  * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
  * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
  * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
  * making the user think that MCG "eats" them and never displays them again.
  * @param bounds L.LatLngBounds
  * @returns {L.LatLngBounds}
  * @private
  */
	_checkBoundsMaxLat: function _checkBoundsMaxLat(bounds) {
		var maxLat = this._maxLat;

		if (maxLat !== undefined) {
			if (bounds.getNorth() >= maxLat) {
				bounds._northEast.lat = Infinity;
			}
			if (bounds.getSouth() <= -maxLat) {
				bounds._southWest.lat = -Infinity;
			}
		}

		return bounds;
	},

	//Shared animation code
	_animationAddLayerNonAnimated: function _animationAddLayerNonAnimated(layer, newCluster) {
		if (newCluster === layer) {
			this._featureGroup.addLayer(layer);
		} else if (newCluster._childCount === 2) {
			newCluster._addToMap();

			var markers = newCluster.getAllChildMarkers();
			this._featureGroup.removeLayer(markers[0]);
			this._featureGroup.removeLayer(markers[1]);
		} else {
			newCluster._updateIcon();
		}
	},

	/**
  * Extracts individual (i.e. non-group) layers from a Layer Group.
  * @param group to extract layers from.
  * @param output {Array} in which to store the extracted layers.
  * @returns {*|Array}
  * @private
  */
	_extractNonGroupLayers: function _extractNonGroupLayers(group, output) {
		var layers = group.getLayers(),
		    i = 0,
		    layer;

		output = output || [];

		for (; i < layers.length; i++) {
			layer = layers[i];

			if (layer instanceof L.LayerGroup) {
				this._extractNonGroupLayers(layer, output);
				continue;
			}

			output.push(layer);
		}

		return output;
	},

	/**
  * Implements the singleMarkerMode option.
  * @param layer Marker to re-style using the Clusters iconCreateFunction.
  * @returns {L.Icon} The newly created icon.
  * @private
  */
	_overrideMarkerIcon: function _overrideMarkerIcon(layer) {
		var icon = layer.options.icon = this.options.iconCreateFunction({
			getChildCount: function getChildCount() {
				return 1;
			},
			getAllChildMarkers: function getAllChildMarkers() {
				return [layer];
			}
		});

		return icon;
	}
});

// Constant bounds used in case option "removeOutsideVisibleBounds" is set to false.
L.MarkerClusterGroup.include({
	_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))
});

L.MarkerClusterGroup.include({
	_noAnimation: {
		//Non Animated versions of everything
		_animationStart: function _animationStart() {
			//Do nothing...
		},
		_animationZoomIn: function _animationZoomIn(previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationZoomOut: function _animationZoomOut(previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationAddLayer: function _animationAddLayer(layer, newCluster) {
			this._animationAddLayerNonAnimated(layer, newCluster);
		}
	},

	_withAnimation: {
		//Animated versions here
		_animationStart: function _animationStart() {
			this._map._mapPane.className += ' leaflet-cluster-anim';
			this._inZoomAnimation++;
		},

		_animationZoomIn: function _animationZoomIn(previousZoomLevel, newZoomLevel) {
			var bounds = this._getExpandedVisibleBounds(),
			    fg = this._featureGroup,
			    minZoom = Math.floor(this._map.getMinZoom()),
			    i;

			this._ignoreMove = true;

			//Add all children of current clusters to map and remove those clusters from map
			this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
				var startPos = c._latlng,
				    markers = c._markers,
				    m;

				if (!bounds.contains(startPos)) {
					startPos = null;
				}

				if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) {
					//Immediately add the new child and remove us
					fg.removeLayer(c);
					c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
				} else {
					//Fade out old cluster
					c.clusterHide();
					c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
				}

				//Remove all markers that aren't visible any more
				//TODO: Do we actually need to do this on the higher levels too?
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];
					if (!bounds.contains(m._latlng)) {
						fg.removeLayer(m);
					}
				}
			});

			this._forceLayout();

			//Update opacities
			this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
			//TODO Maybe? Update markers in _recursivelyBecomeVisible
			fg.eachLayer(function (n) {
				if (!(n instanceof L.MarkerCluster) && n._icon) {
					n.clusterShow();
				}
			});

			//update the positions of the just added clusters/markers
			this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
				c._recursivelyRestoreChildPositions(newZoomLevel);
			});

			this._ignoreMove = false;

			//Remove the old clusters and close the zoom animation
			this._enqueue(function () {
				//update the positions of the just added clusters/markers
				this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
					fg.removeLayer(c);
					c.clusterShow();
				});

				this._animationEnd();
			});
		},

		_animationZoomOut: function _animationZoomOut(previousZoomLevel, newZoomLevel) {
			this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

			//Need to add markers for those that weren't on the map before but are now
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
			//Remove markers that were on the map before but won't be now
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());
		},

		_animationAddLayer: function _animationAddLayer(layer, newCluster) {
			var me = this,
			    fg = this._featureGroup;

			fg.addLayer(layer);
			if (newCluster !== layer) {
				if (newCluster._childCount > 2) {
					//Was already a cluster

					newCluster._updateIcon();
					this._forceLayout();
					this._animationStart();

					layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
					layer.clusterHide();

					this._enqueue(function () {
						fg.removeLayer(layer);
						layer.clusterShow();

						me._animationEnd();
					});
				} else {
					//Just became a cluster
					this._forceLayout();

					me._animationStart();
					me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);
				}
			}
		}
	},

	// Private methods for animated versions.
	_animationZoomOutSingle: function _animationZoomOutSingle(cluster, previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds(),
		    minZoom = Math.floor(this._map.getMinZoom());

		//Animate all of the markers in the clusters to move to their cluster center point
		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);

		var me = this;

		//Update the opacity (If we immediately set it they won't animate)
		this._forceLayout();
		cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

		//TODO: Maybe use the transition timing stuff to make this more reliable
		//When the animations are done, tidy up
		this._enqueue(function () {

			//This cluster stopped being a cluster before the timeout fired
			if (cluster._childCount === 1) {
				var m = cluster._markers[0];
				//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
				this._ignoreMove = true;
				m.setLatLng(m.getLatLng());
				this._ignoreMove = false;
				if (m.clusterShow) {
					m.clusterShow();
				}
			} else {
				cluster._recursively(bounds, newZoomLevel, minZoom, function (c) {
					c._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);
				});
			}
			me._animationEnd();
		});
	},

	_animationEnd: function _animationEnd() {
		if (this._map) {
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
		}
		this._inZoomAnimation--;
		this.fire('animationend');
	},

	//Force a browser layout of stuff in the map
	// Should apply the current opacity and location to all elements so we can update them again for an animation
	_forceLayout: function _forceLayout() {
		//In my testing this works, infact offsetWidth of any element seems to work.
		//Could loop all this._layers and do this for each _icon if it stops working

		L.Util.falseFn(document.body.offsetWidth);
	}
});

L.markerClusterGroup = function (options) {
	return new L.MarkerClusterGroup(options);
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var MarkerCluster = exports.MarkerCluster = L.MarkerCluster = L.Marker.extend({
	options: L.Icon.prototype.options,

	initialize: function initialize(group, zoom, a, b) {

		L.Marker.prototype.initialize.call(this, a ? a._cLatLng || a.getLatLng() : new L.LatLng(0, 0), { icon: this, pane: group.options.clusterPane });

		this._group = group;
		this._zoom = zoom;

		this._markers = [];
		this._childClusters = [];
		this._childCount = 0;
		this._iconNeedsUpdate = true;
		this._boundsNeedUpdate = true;

		this._bounds = new L.LatLngBounds();

		if (a) {
			this._addChild(a);
		}
		if (b) {
			this._addChild(b);
		}
	},

	//Recursively retrieve all child markers of this cluster
	getAllChildMarkers: function getAllChildMarkers(storageArray) {
		storageArray = storageArray || [];

		for (var i = this._childClusters.length - 1; i >= 0; i--) {
			this._childClusters[i].getAllChildMarkers(storageArray);
		}

		for (var j = this._markers.length - 1; j >= 0; j--) {
			storageArray.push(this._markers[j]);
		}

		return storageArray;
	},

	//Returns the count of how many child markers we have
	getChildCount: function getChildCount() {
		return this._childCount;
	},

	//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
	zoomToBounds: function zoomToBounds(fitBoundsOptions) {
		var childClusters = this._childClusters.slice(),
		    map = this._group._map,
		    boundsZoom = map.getBoundsZoom(this._bounds),
		    zoom = this._zoom + 1,
		    mapZoom = map.getZoom(),
		    i;

		//calculate how far we need to zoom down to see all of the markers
		while (childClusters.length > 0 && boundsZoom > zoom) {
			zoom++;
			var newClusters = [];
			for (i = 0; i < childClusters.length; i++) {
				newClusters = newClusters.concat(childClusters[i]._childClusters);
			}
			childClusters = newClusters;
		}

		if (boundsZoom > zoom) {
			this._group._map.setView(this._latlng, zoom);
		} else if (boundsZoom <= mapZoom) {
			//If fitBounds wouldn't zoom us down, zoom us down instead
			this._group._map.setView(this._latlng, mapZoom + 1);
		} else {
			this._group._map.fitBounds(this._bounds, fitBoundsOptions);
		}
	},

	getBounds: function getBounds() {
		var bounds = new L.LatLngBounds();
		bounds.extend(this._bounds);
		return bounds;
	},

	_updateIcon: function _updateIcon() {
		this._iconNeedsUpdate = true;
		if (this._icon) {
			this.setIcon(this);
		}
	},

	//Cludge for Icon, we pretend to be an icon for performance
	createIcon: function createIcon() {
		if (this._iconNeedsUpdate) {
			this._iconObj = this._group.options.iconCreateFunction(this);
			this._iconNeedsUpdate = false;
		}
		return this._iconObj.createIcon();
	},
	createShadow: function createShadow() {
		return this._iconObj.createShadow();
	},

	_addChild: function _addChild(new1, isNotificationFromChild) {

		this._iconNeedsUpdate = true;

		this._boundsNeedUpdate = true;
		this._setClusterCenter(new1);

		if (new1 instanceof L.MarkerCluster) {
			if (!isNotificationFromChild) {
				this._childClusters.push(new1);
				new1.__parent = this;
			}
			this._childCount += new1._childCount;
		} else {
			if (!isNotificationFromChild) {
				this._markers.push(new1);
			}
			this._childCount++;
		}

		if (this.__parent) {
			this.__parent._addChild(new1, true);
		}
	},

	/**
  * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
  * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
  * @private
  */
	_setClusterCenter: function _setClusterCenter(child) {
		if (!this._cLatLng) {
			// when clustering, take position of the first point as the cluster center
			this._cLatLng = child._cLatLng || child._latlng;
		}
	},

	/**
  * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
  * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
  * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
  * @private
  */
	_resetBounds: function _resetBounds() {
		var bounds = this._bounds;

		if (bounds._southWest) {
			bounds._southWest.lat = Infinity;
			bounds._southWest.lng = Infinity;
		}
		if (bounds._northEast) {
			bounds._northEast.lat = -Infinity;
			bounds._northEast.lng = -Infinity;
		}
	},

	_recalculateBounds: function _recalculateBounds() {
		var markers = this._markers,
		    childClusters = this._childClusters,
		    latSum = 0,
		    lngSum = 0,
		    totalCount = this._childCount,
		    i,
		    child,
		    childLatLng,
		    childCount;

		// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.
		if (totalCount === 0) {
			return;
		}

		// Reset rather than creating a new object, for performance.
		this._resetBounds();

		// Child markers.
		for (i = 0; i < markers.length; i++) {
			childLatLng = markers[i]._latlng;

			this._bounds.extend(childLatLng);

			latSum += childLatLng.lat;
			lngSum += childLatLng.lng;
		}

		// Child clusters.
		for (i = 0; i < childClusters.length; i++) {
			child = childClusters[i];

			// Re-compute child bounds and weighted position first if necessary.
			if (child._boundsNeedUpdate) {
				child._recalculateBounds();
			}

			this._bounds.extend(child._bounds);

			childLatLng = child._wLatLng;
			childCount = child._childCount;

			latSum += childLatLng.lat * childCount;
			lngSum += childLatLng.lng * childCount;
		}

		this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);

		// Reset dirty flag.
		this._boundsNeedUpdate = false;
	},

	//Set our markers position as given and add it to the map
	_addToMap: function _addToMap(startPos) {
		if (startPos) {
			this._backupLatlng = this._latlng;
			this.setLatLng(startPos);
		}
		this._group._featureGroup.addLayer(this);
	},

	_recursivelyAnimateChildrenIn: function _recursivelyAnimateChildrenIn(bounds, center, maxZoom) {
		this._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1, function (c) {
			var markers = c._markers,
			    i,
			    m;
			for (i = markers.length - 1; i >= 0; i--) {
				m = markers[i];

				//Only do it if the icon is still on the map
				if (m._icon) {
					m._setPos(center);
					m.clusterHide();
				}
			}
		}, function (c) {
			var childClusters = c._childClusters,
			    j,
			    cm;
			for (j = childClusters.length - 1; j >= 0; j--) {
				cm = childClusters[j];
				if (cm._icon) {
					cm._setPos(center);
					cm.clusterHide();
				}
			}
		});
	},

	_recursivelyAnimateChildrenInAndAddSelfToMap: function _recursivelyAnimateChildrenInAndAddSelfToMap(bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {
		this._recursively(bounds, newZoomLevel, mapMinZoom, function (c) {
			c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

			//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
			//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
			if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
				c.clusterShow();
				c._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
			} else {
				c.clusterHide();
			}

			c._addToMap();
		});
	},

	_recursivelyBecomeVisible: function _recursivelyBecomeVisible(bounds, zoomLevel) {
		this._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {
			c.clusterShow();
		});
	},

	_recursivelyAddChildrenToMap: function _recursivelyAddChildrenToMap(startPos, zoomLevel, bounds) {
		this._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel, function (c) {
			if (zoomLevel === c._zoom) {
				return;
			}

			//Add our child markers at startPos (so they can be animated out)
			for (var i = c._markers.length - 1; i >= 0; i--) {
				var nm = c._markers[i];

				if (!bounds.contains(nm._latlng)) {
					continue;
				}

				if (startPos) {
					nm._backupLatlng = nm.getLatLng();

					nm.setLatLng(startPos);
					if (nm.clusterHide) {
						nm.clusterHide();
					}
				}

				c._group._featureGroup.addLayer(nm);
			}
		}, function (c) {
			c._addToMap(startPos);
		});
	},

	_recursivelyRestoreChildPositions: function _recursivelyRestoreChildPositions(zoomLevel) {
		//Fix positions of child markers
		for (var i = this._markers.length - 1; i >= 0; i--) {
			var nm = this._markers[i];
			if (nm._backupLatlng) {
				nm.setLatLng(nm._backupLatlng);
				delete nm._backupLatlng;
			}
		}

		if (zoomLevel - 1 === this._zoom) {
			//Reposition child clusters
			for (var j = this._childClusters.length - 1; j >= 0; j--) {
				this._childClusters[j]._restorePosition();
			}
		} else {
			for (var k = this._childClusters.length - 1; k >= 0; k--) {
				this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
			}
		}
	},

	_restorePosition: function _restorePosition() {
		if (this._backupLatlng) {
			this.setLatLng(this._backupLatlng);
			delete this._backupLatlng;
		}
	},

	//exceptBounds: If set, don't remove any markers/clusters in it
	_recursivelyRemoveChildrenFromMap: function _recursivelyRemoveChildrenFromMap(previousBounds, mapMinZoom, zoomLevel, exceptBounds) {
		var m, i;
		this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1, function (c) {
			//Remove markers at every level
			for (i = c._markers.length - 1; i >= 0; i--) {
				m = c._markers[i];
				if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
					c._group._featureGroup.removeLayer(m);
					if (m.clusterShow) {
						m.clusterShow();
					}
				}
			}
		}, function (c) {
			//Remove child clusters at just the bottom level
			for (i = c._childClusters.length - 1; i >= 0; i--) {
				m = c._childClusters[i];
				if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
					c._group._featureGroup.removeLayer(m);
					if (m.clusterShow) {
						m.clusterShow();
					}
				}
			}
		});
	},

	//Run the given functions recursively to this and child clusters
	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
	// zoomLevelToStart: zoom level to start running functions (inclusive)
	// zoomLevelToStop: zoom level to stop running functions (inclusive)
	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
	_recursively: function _recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
		var childClusters = this._childClusters,
		    zoom = this._zoom,
		    i,
		    c;

		if (zoomLevelToStart <= zoom) {
			if (runAtEveryLevel) {
				runAtEveryLevel(this);
			}
			if (runAtBottomLevel && zoom === zoomLevelToStop) {
				runAtBottomLevel(this);
			}
		}

		if (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {
			for (i = childClusters.length - 1; i >= 0; i--) {
				c = childClusters[i];
				if (boundsToApplyTo.intersects(c._bounds)) {
					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
				}
			}
		}
	},

	//Returns true if we are the parent of only one cluster and that cluster is the same as us
	_isSingleParent: function _isSingleParent() {
		//Don't need to check this._markers as the rest won't work if there are any
		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
	}
});

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
* Extends L.Marker to include two extra methods: clusterHide and clusterShow.
* 
* They work as setOpacity(0) and setOpacity(1) respectively, but
* they will remember the marker's opacity when hiding and showing it again.
* 
*/

L.Marker.include({

	clusterHide: function clusterHide() {
		this.options.opacityWhenUnclustered = this.options.opacity || 1;
		return this.setOpacity(0);
	},

	clusterShow: function clusterShow() {
		var ret = this.setOpacity(this.options.opacity || this.options.opacityWhenUnclustered);
		delete this.options.opacityWhenUnclustered;
		return ret;
	}

});

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


L.DistanceGrid = function (cellSize) {
	this._cellSize = cellSize;
	this._sqCellSize = cellSize * cellSize;
	this._grid = {};
	this._objectPoint = {};
};

L.DistanceGrid.prototype = {

	addObject: function addObject(obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    stamp = L.Util.stamp(obj);

		this._objectPoint[stamp] = point;

		cell.push(obj);
	},

	updateObject: function updateObject(obj, point) {
		this.removeObject(obj);
		this.addObject(obj, point);
	},

	//Returns true if the object was found
	removeObject: function removeObject(obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    i,
		    len;

		delete this._objectPoint[L.Util.stamp(obj)];

		for (i = 0, len = cell.length; i < len; i++) {
			if (cell[i] === obj) {

				cell.splice(i, 1);

				if (len === 1) {
					delete row[x];
				}

				return true;
			}
		}
	},

	eachObject: function eachObject(fn, context) {
		var i,
		    j,
		    k,
		    len,
		    row,
		    cell,
		    removed,
		    grid = this._grid;

		for (i in grid) {
			row = grid[i];

			for (j in row) {
				cell = row[j];

				for (k = 0, len = cell.length; k < len; k++) {
					removed = fn.call(context, cell[k]);
					if (removed) {
						k--;
						len--;
					}
				}
			}
		}
	},

	getNearObject: function getNearObject(point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    i,
		    j,
		    k,
		    row,
		    cell,
		    len,
		    obj,
		    dist,
		    objectPoint = this._objectPoint,
		    closestDistSq = this._sqCellSize,
		    closest = null;

		for (i = y - 1; i <= y + 1; i++) {
			row = this._grid[i];
			if (row) {

				for (j = x - 1; j <= x + 1; j++) {
					cell = row[j];
					if (cell) {

						for (k = 0, len = cell.length; k < len; k++) {
							obj = cell[k];
							dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
							if (dist < closestDistSq || dist <= closestDistSq && closest === null) {
								closestDistSq = dist;
								closest = obj;
							}
						}
					}
				}
			}
		}
		return closest;
	},

	_getCoord: function _getCoord(x) {
		var coord = Math.floor(x / this._cellSize);
		return isFinite(coord) ? coord : x;
	},

	_sqDist: function _sqDist(p, p2) {
		var dx = p2.x - p.x,
		    dy = p2.y - p.y;
		return dx * dx + dy * dy;
	}
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* Copyright (c) 2012 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
*/

(function () {
	L.QuickHull = {

		/*
   * @param {Object} cpt a point to be measured from the baseline
   * @param {Array} bl the baseline, as represented by a two-element
   *   array of latlng objects.
   * @returns {Number} an approximate distance measure
   */
		getDistant: function getDistant(cpt, bl) {
			var vY = bl[1].lat - bl[0].lat,
			    vX = bl[0].lng - bl[1].lng;
			return vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng);
		},

		/*
   * @param {Array} baseLine a two-element array of latlng objects
   *   representing the baseline to project from
   * @param {Array} latLngs an array of latlng objects
   * @returns {Object} the maximum point and all new points to stay
   *   in consideration for the hull.
   */
		findMostDistantPointFromBaseLine: function findMostDistantPointFromBaseLine(baseLine, latLngs) {
			var maxD = 0,
			    maxPt = null,
			    newPoints = [],
			    i,
			    pt,
			    d;

			for (i = latLngs.length - 1; i >= 0; i--) {
				pt = latLngs[i];
				d = this.getDistant(pt, baseLine);

				if (d > 0) {
					newPoints.push(pt);
				} else {
					continue;
				}

				if (d > maxD) {
					maxD = d;
					maxPt = pt;
				}
			}

			return { maxPoint: maxPt, newPoints: newPoints };
		},

		/*
   * Given a baseline, compute the convex hull of latLngs as an array
   * of latLngs.
   *
   * @param {Array} latLngs
   * @returns {Array}
   */
		buildConvexHull: function buildConvexHull(baseLine, latLngs) {
			var convexHullBaseLines = [],
			    t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

			if (t.maxPoint) {
				// if there is still a point "outside" the base line
				convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints));
				convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints));
				return convexHullBaseLines;
			} else {
				// if there is no more point "outside" the base line, the current base line is part of the convex hull
				return [baseLine[0]];
			}
		},

		/*
   * Given an array of latlngs, compute a convex hull as an array
   * of latlngs
   *
   * @param {Array} latLngs
   * @returns {Array}
   */
		getConvexHull: function getConvexHull(latLngs) {
			// find first baseline
			var maxLat = false,
			    minLat = false,
			    maxLng = false,
			    minLng = false,
			    maxLatPt = null,
			    minLatPt = null,
			    maxLngPt = null,
			    minLngPt = null,
			    maxPt = null,
			    minPt = null,
			    i;

			for (i = latLngs.length - 1; i >= 0; i--) {
				var pt = latLngs[i];
				if (maxLat === false || pt.lat > maxLat) {
					maxLatPt = pt;
					maxLat = pt.lat;
				}
				if (minLat === false || pt.lat < minLat) {
					minLatPt = pt;
					minLat = pt.lat;
				}
				if (maxLng === false || pt.lng > maxLng) {
					maxLngPt = pt;
					maxLng = pt.lng;
				}
				if (minLng === false || pt.lng < minLng) {
					minLngPt = pt;
					minLng = pt.lng;
				}
			}

			if (minLat !== maxLat) {
				minPt = minLatPt;
				maxPt = maxLatPt;
			} else {
				minPt = minLngPt;
				maxPt = maxLngPt;
			}

			var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs), this.buildConvexHull([maxPt, minPt], latLngs));
			return ch;
		}
	};
})();

L.MarkerCluster.include({
	getConvexHull: function getConvexHull() {
		var childMarkers = this.getAllChildMarkers(),
		    points = [],
		    p,
		    i;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			p = childMarkers[i].getLatLng();
			points.push(p);
		}

		return L.QuickHull.getConvexHull(points);
	}
});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

L.MarkerCluster.include({

	_2PI: Math.PI * 2,
	_circleFootSeparation: 25, //related to circumference of circle
	_circleStartAngle: 0,

	_spiralFootSeparation: 28, //related to size of spiral (experiment!)
	_spiralLengthStart: 11,
	_spiralLengthFactor: 5,

	_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
	// 0 -> always spiral; Infinity -> always circle

	spiderfy: function spiderfy() {
		if (this._group._spiderfied === this || this._group._inZoomAnimation) {
			return;
		}

		var childMarkers = this.getAllChildMarkers(),
		    group = this._group,
		    map = group._map,
		    center = map.latLngToLayerPoint(this._latlng),
		    positions;

		this._group._unspiderfy();
		this._group._spiderfied = this;

		//TODO Maybe: childMarkers order by distance to center

		if (childMarkers.length >= this._circleSpiralSwitchover) {
			positions = this._generatePointsSpiral(childMarkers.length, center);
		} else {
			center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.
			positions = this._generatePointsCircle(childMarkers.length, center);
		}

		this._animationSpiderfy(childMarkers, positions);
	},

	unspiderfy: function unspiderfy(zoomDetails) {
		/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
		if (this._group._inZoomAnimation) {
			return;
		}
		this._animationUnspiderfy(zoomDetails);

		this._group._spiderfied = null;
	},

	_generatePointsCircle: function _generatePointsCircle(count, centerPt) {
		var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
		    legLength = circumference / this._2PI,
		    //radius from circumference
		angleStep = this._2PI / count,
		    res = [],
		    i,
		    angle;

		legLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.

		res.length = count;

		for (i = 0; i < count; i++) {
			// Clockwise, like spiral.
			angle = this._circleStartAngle + i * angleStep;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
		}

		return res;
	},

	_generatePointsSpiral: function _generatePointsSpiral(count, centerPt) {
		var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,
		    legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,
		    separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,
		    lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,
		    angle = 0,
		    res = [],
		    i;

		res.length = count;

		// Higher index, closer position to cluster center.
		for (i = count; i >= 0; i--) {
			// Skip the first position, so that we are already farther from center and we avoid
			// being under the default cluster icon (especially important for Circle Markers).
			if (i < count) {
				res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			}
			angle += separation / legLength + i * 0.0005;
			legLength += lengthFactor / angle;
		}
		return res;
	},

	_noanimationUnspiderfy: function _noanimationUnspiderfy() {
		var group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    childMarkers = this.getAllChildMarkers(),
		    m,
		    i;

		group._ignoreMove = true;

		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			fg.removeLayer(m);

			if (m._preSpiderfyLatlng) {
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;
			}
			if (m.setZIndexOffset) {
				m.setZIndexOffset(0);
			}

			if (m._spiderLeg) {
				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
		}

		group.fire('unspiderfied', {
			cluster: this,
			markers: childMarkers
		});
		group._ignoreMove = false;
		group._spiderfied = null;
	}
});

//Non Animated versions of everything
L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
	_animationSpiderfy: function _animationSpiderfy(childMarkers, positions) {
		var group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    legOptions = this._group.options.spiderLegPolylineOptions,
		    i,
		    m,
		    leg,
		    newPos;

		group._ignoreMove = true;

		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([this._latlng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Now add the marker.
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
			}

			fg.addLayer(m);
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;
		group.fire('spiderfied', {
			cluster: this,
			markers: childMarkers
		});
	},

	_animationUnspiderfy: function _animationUnspiderfy() {
		this._noanimationUnspiderfy();
	}
});

//Animated versions here
L.MarkerCluster.include({

	_animationSpiderfy: function _animationSpiderfy(childMarkers, positions) {
		var me = this,
		    group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    thisLayerLatLng = this._latlng,
		    thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),
		    svg = L.Path.SVG,
		    legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions),
		    // Copy the options so that we can modify them for animation.
		finalLegOpacity = legOptions.opacity,
		    i,
		    m,
		    leg,
		    legPath,
		    legLength,
		    newPos;

		if (finalLegOpacity === undefined) {
			finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;
		}

		if (svg) {
			// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.
			legOptions.opacity = 0;

			// Add the class for CSS transitions.
			legOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';
		} else {
			// Make sure we have a defined opacity.
			legOptions.opacity = finalLegOpacity;
		}

		group._ignoreMove = true;

		// Add markers and spider legs to map, hidden at our center point.
		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			m = childMarkers[i];

			newPos = map.layerPointToLatLng(positions[i]);

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([thisLayerLatLng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/
			// In our case the transition property is declared in the CSS file.
			if (svg) {
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.
				legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.
				legPath.style.strokeDashoffset = legLength;
			}

			// If it is a marker, add it now and we'll animate it out
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING
			}
			if (m.clusterHide) {
				m.clusterHide();
			}

			// Vectors just get immediately added
			fg.addLayer(m);

			if (m._setPos) {
				m._setPos(thisLayerPos);
			}
		}

		group._forceLayout();
		group._animationStart();

		// Reveal markers and spider legs.
		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			//Move marker to new position
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);

			if (m.clusterShow) {
				m.clusterShow();
			}

			// Animate leg (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legPath.style.strokeDashoffset = 0;
				//legPath.style.strokeOpacity = finalLegOpacity;
				leg.setStyle({ opacity: finalLegOpacity });
			}
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;

		setTimeout(function () {
			group._animationEnd();
			group.fire('spiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	},

	_animationUnspiderfy: function _animationUnspiderfy(zoomDetails) {
		var me = this,
		    group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
		    childMarkers = this.getAllChildMarkers(),
		    svg = L.Path.SVG,
		    m,
		    i,
		    leg,
		    legPath,
		    legLength,
		    nonAnimatable;

		group._ignoreMove = true;
		group._animationStart();

		//Make us visible and bring the child markers back in
		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//Marker was added to us after we were spiderfied
			if (!m._preSpiderfyLatlng) {
				continue;
			}

			//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll
			m.closePopup();

			//Fix up the location to the real one
			m.setLatLng(m._preSpiderfyLatlng);
			delete m._preSpiderfyLatlng;

			//Hack override the location to be our center
			nonAnimatable = true;
			if (m._setPos) {
				m._setPos(thisLayerPos);
				nonAnimatable = false;
			}
			if (m.clusterHide) {
				m.clusterHide();
				nonAnimatable = false;
			}
			if (nonAnimatable) {
				fg.removeLayer(m);
			}

			// Animate the spider leg back in (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1;
				legPath.style.strokeDashoffset = legLength;
				leg.setStyle({ opacity: 0 });
			}
		}

		group._ignoreMove = false;

		setTimeout(function () {
			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
			var stillThereChildCount = 0;
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];
				if (m._spiderLeg) {
					stillThereChildCount++;
				}
			}

			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				if (!m._spiderLeg) {
					//Has already been unspiderfied
					continue;
				}

				if (m.clusterShow) {
					m.clusterShow();
				}
				if (m.setZIndexOffset) {
					m.setZIndexOffset(0);
				}

				if (stillThereChildCount > 1) {
					fg.removeLayer(m);
				}

				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
			group._animationEnd();
			group.fire('unspiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	}
});

L.MarkerClusterGroup.include({
	//The MarkerCluster currently spiderfied (if any)
	_spiderfied: null,

	unspiderfy: function unspiderfy() {
		this._unspiderfy.apply(this, arguments);
	},

	_spiderfierOnAdd: function _spiderfierOnAdd() {
		this._map.on('click', this._unspiderfyWrapper, this);

		if (this._map.options.zoomAnimation) {
			this._map.on('zoomstart', this._unspiderfyZoomStart, this);
		}
		//Browsers without zoomAnimation or a big zoom don't fire zoomstart
		this._map.on('zoomend', this._noanimationUnspiderfy, this);

		if (!L.Browser.touch) {
			this._map.getRenderer(this);
			//Needs to happen in the pageload, not after, or animations don't work in webkit
			//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
			//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
		}
	},

	_spiderfierOnRemove: function _spiderfierOnRemove() {
		this._map.off('click', this._unspiderfyWrapper, this);
		this._map.off('zoomstart', this._unspiderfyZoomStart, this);
		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._map.off('zoomend', this._noanimationUnspiderfy, this);

		//Ensure that markers are back where they should be
		// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane
		this._noanimationUnspiderfy();
	},

	//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
	//This means we can define the animation they do rather than Markers doing an animation to their actual location
	_unspiderfyZoomStart: function _unspiderfyZoomStart() {
		if (!this._map) {
			//May have been removed from the map by a zoomEnd handler
			return;
		}

		this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
	},

	_unspiderfyZoomAnim: function _unspiderfyZoomAnim(zoomDetails) {
		//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
		if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
			return;
		}

		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._unspiderfy(zoomDetails);
	},

	_unspiderfyWrapper: function _unspiderfyWrapper() {
		/// <summary>_unspiderfy but passes no arguments</summary>
		this._unspiderfy();
	},

	_unspiderfy: function _unspiderfy(zoomDetails) {
		if (this._spiderfied) {
			this._spiderfied.unspiderfy(zoomDetails);
		}
	},

	_noanimationUnspiderfy: function _noanimationUnspiderfy() {
		if (this._spiderfied) {
			this._spiderfied._noanimationUnspiderfy();
		}
	},

	//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
	_unspiderfyLayer: function _unspiderfyLayer(layer) {
		if (layer._spiderLeg) {
			this._featureGroup.removeLayer(layer);

			if (layer.clusterShow) {
				layer.clusterShow();
			}
			//Position will be fixed up immediately in _animationUnspiderfy
			if (layer.setZIndexOffset) {
				layer.setZIndexOffset(0);
			}

			this._map.removeLayer(layer._spiderLeg);
			delete layer._spiderLeg;
		}
	}
});

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
 * markers' icon options and refreshing their icon and their parent clusters
 * accordingly (case where their iconCreateFunction uses data of childMarkers
 * to make up the cluster icon).
 */

L.MarkerClusterGroup.include({
	/**
  * Updates the icon of all clusters which are parents of the given marker(s).
  * In singleMarkerMode, also updates the given marker(s) icon.
  * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
  * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
  * clusters need to be updated. If not provided, retrieves all child markers of this.
  * @returns {L.MarkerClusterGroup}
  */
	refreshClusters: function refreshClusters(layers) {
		if (!layers) {
			layers = this._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.MarkerClusterGroup) {
			layers = layers._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.LayerGroup) {
			layers = layers._layers;
		} else if (layers instanceof L.MarkerCluster) {
			layers = layers.getAllChildMarkers();
		} else if (layers instanceof L.Marker) {
			layers = [layers];
		} // else: must be an Array(L.Marker)|Map(L.Marker)
		this._flagParentsIconsNeedUpdate(layers);
		this._refreshClustersIcons();

		// In case of singleMarkerMode, also re-draw the markers.
		if (this.options.singleMarkerMode) {
			this._refreshSingleMarkerModeMarkers(layers);
		}

		return this;
	},

	/**
  * Simply flags all parent clusters of the given markers as having a "dirty" icon.
  * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
  * @private
  */
	_flagParentsIconsNeedUpdate: function _flagParentsIconsNeedUpdate(layers) {
		var id, parent;

		// Assumes layers is an Array or an Object whose prototype is non-enumerable.
		for (id in layers) {
			// Flag parent clusters' icon as "dirty", all the way up.
			// Dumb process that flags multiple times upper parents, but still
			// much more efficient than trying to be smart and make short lists,
			// at least in the case of a hierarchy following a power law:
			// http://jsperf.com/flag-nodes-in-power-hierarchy/2
			parent = layers[id].__parent;
			while (parent) {
				parent._iconNeedsUpdate = true;
				parent = parent.__parent;
			}
		}
	},

	/**
  * Re-draws the icon of the supplied markers.
  * To be used in singleMarkerMode only.
  * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
  * @private
  */
	_refreshSingleMarkerModeMarkers: function _refreshSingleMarkerModeMarkers(layers) {
		var id, layer;

		for (id in layers) {
			layer = layers[id];

			// Make sure we do not override markers that do not belong to THIS group.
			if (this.hasLayer(layer)) {
				// Need to re-create the icon first, then re-draw the marker.
				layer.setIcon(this._overrideMarkerIcon(layer));
			}
		}
	}
});

L.Marker.include({
	/**
  * Updates the given options in the marker's icon and refreshes the marker.
  * @param options map object of icon options.
  * @param directlyRefreshClusters boolean (optional) true to trigger
  * MCG.refreshClustersOf() right away with this single marker.
  * @returns {L.Marker}
  */
	refreshIconOptions: function refreshIconOptions(options, directlyRefreshClusters) {
		var icon = this.options.icon;

		L.setOptions(icon, options);

		this.setIcon(icon);

		// Shortcut to refresh the associated MCG clusters right away.
		// To be used when refreshing a single marker.
		// Otherwise, better use MCG.refreshClusters() once at the end with
		// the list of modified markers.
		if (directlyRefreshClusters && this.__parent) {
			this.__parent._group.refreshClusters(this);
		}

		return this;
	}
});

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "<link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\" integrity=\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\"\n  crossorigin=\"anonymous\">\n<link href=\"https://fonts.googleapis.com/css?family=Lato:300,400,400i,900\" rel=\"stylesheet\">\n<link href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\" rel=\"stylesheet\" integrity=\"sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN\"\n  crossorigin=\"anonymous\">\n\n\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css\" media=\"screen\">\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css\" media=\"screen\">\n\n\n<style>\n   :host {\n    font-family: 'Lato', sans-serif;\n    --primary-color: #003d7d;\n    --secondary-color: #ff4b5f;\n  }\n\n  main.card {\n    position: absolute;\n    left: 15px;\n    top: 15px;\n    bottom: 15px;\n    width: 300px;\n    z-index: 1005;\n\n    background-color: #fff;\n    box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.3);\n\n    transition: transform 175ms;\n  }\n\n  a {\n    color: var(--primary-color, inherit);\n  }\n\n  .btn-primary {\n    color: #fff;\n    background-color: var(--primary-color, inherit);\n    border-color: var(--primary-color, inherit);\n  }\n\n  header#page-title {\n    padding: 10px;\n    background-color: var(--primary-color);\n    height: 150px;\n  }\n\n  header#page-title h1 {\n    color: #fff;\n    font-weight: 900;\n  }\n\n  section#overlays {\n    overflow: auto;\n    padding-bottom: 5px;\n  }\n\n  section#overlays>ul>li.list-group-item {\n    padding: 0;\n  }\n\n  section#overlays .overlay-item {\n    font-size: 1.1rem;\n    padding: 0.75rem 1.25rem;\n    color: #444;\n  }\n\n  section#overlays .overlay-item:hover {\n    cursor: pointer;\n    background-color: #eee;\n  }\n\n  section#overlays .overlay-item.selected {\n    background-color: #ddd;\n    color: var(--primary-color);\n\n    /* left border and offset text back */\n    border-left: 0.25rem solid var(--primary-color);\n    padding-left: 1rem;\n  }\n\n  ul.overlay-layers>li.list-group-item {\n    border: 0;\n    border-left: 0.25rem solid var(--primary-color);\n    padding-left: 1.75rem;\n    background-color: #eee;\n    cursor: pointer;\n  }\n\n  ul.overlay-layers .overlay-layers-toggle {\n    --primary-color: var(--secondary-color);\n  }\n\n  button#basemap-switcher,\n  button#layers-menu-toggle {\n    position: absolute;\n    right: 30px;\n    width: 160px;\n    height: 90px;\n    z-index: 1001;\n    border: 5px solid #ffffff;\n    box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.3);\n    cursor: pointer;\n  }\n\n  button#basemap-switcher {\n    background-image: url('./aerial.png');\n    bottom: 30px;\n  }\n\n  button#layers-menu-toggle {\n    display: none;\n    bottom: 130px;\n  }\n\n  section#download-disclaimer {\n    max-height: 400px;\n    overflow: auto;\n    text-align: justify;\n  }\n\n  .show-mobile {\n    display: none;\n  }\n\n  @media (max-width: 600px) {\n    main {\n      right: 30px;\n      left: 30px;\n      top: 30px;\n      bottom: 30px;\n      width: unset;\n      transform: scale(0);\n    }\n\n    main.show {\n      transform: scale(1);\n    }\n\n    .show-mobile {\n      display: block;\n    }\n\n    button#basemap-switcher,\n    button#layers-menu-toggle {\n      display: block;\n      width: 90px;\n      height: 90px;\n      border-radius: 90px;\n    }\n  }\n</style>\n\n<!--link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\" integrity=\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\" crossorigin=\"anonymous\"-->\n\n<main id=\"layers-menu\" class=\"card\">\n  <header id=\"page-title\" class=\"card-img-top d-flex align-items-end\">\n    <h1 class=\"h2\">City of Garden Grove Public Maps</h1>\n  </header>\n\n  <!-- Search section -->\n  <section id=\"search-section\" class=\"input-group\">\n    <input type=\"text\" name=\"search\" id=\"search\" class=\"form-control rounded-0\" placeholder=\"Search address\">\n    <span class=\"input-group-btn rounded-0\">\n      <button class=\"btn btn-secondary rounded-0\">\n        <i class=\"fa fa-fw fa-search\"></i>\n      </button>\n    </span>\n  </section>\n\n  <!-- List of available overlays -->\n  <section id=\"overlays\">\n    <ul class=\"list-group\">\n\n      <template is=\"dom-repeat\" items=\"{{overlayMaps}}\">\n        <li class=\"list-group-item\">\n\n          <!-- Main overlay toggle -->\n          <div title=\"[[item.description]]\" class$=\"[[_overlayItemClass(selectedOverlay, item)]]\" on-click=\"overlaySelect\">\n            <paper-toggle-button checked=\"[[_isCurrentOverlay(selectedOverlay, item)]]\"></paper-toggle-button>\n            <span>[[item.name]]</span>\n          </div>\n\n          <div class$=\"[[_overlayLayersShow(selectedOverlay, item)]]\">\n            <ul class=\"overlay-layers list-group list-group-flush\">\n\n              <!-- Exclusive layers -->\n              <template is=\"dom-repeat\" items=\"{{item.layers.exclusives}}\" as=\"layer\">\n                <li class=\"list-group-item d-flex justify-content-start\" on-click=\"toggleLayer\">\n                  <paper-toggle-button class=\"overlay-layers-toggle\" checked=\"[[_isCurrentExclusive(layer, wmsGroups)]]\"></paper-toggle-button>\n                  <span class=\"mr-auto\">\n                    [[layer.name]]\n                  </span>\n                  <a href=\"#\" on-click=\"downloadLayer\" class=\"justify-self-end\"><i title=\"Download [[layer.name]]\" class=\"fa fa-fw fa-download\"></i></a>\n                </li>\n              </template>\n\n              <!-- Optional layers -->\n              <template is=\"dom-repeat\" items=\"{{item.layers.optionals}}\" as=\"layer\">\n                <li class=\"list-group-item d-flex justify-content-start\" on-click=\"toggleLayer\">\n                  <paper-toggle-button class=\"overlay-layers-toggle\" checked=\"[[layer.visible]]\"></paper-toggle-button>\n                  <span class=\"mr-auto\">\n                    [[layer.name]]\n                  </span>\n                  <a href=\"#\" on-click=\"downloadLayer\" class=\"justify-self-end\"><i title=\"Download [[layer.name]]\" class=\"fa fa-fw fa-download\"></i></a>\n                </li>\n              </template>\n\n            </ul>\n          </div>\n\n        </li>\n      </template>\n\n    </ul>\n  </section>\n\n  <footer class=\"card-body\">\n    <a href=\"#\" class=\"btn btn-link\">Help</a>\n    <a href=\"#\" class=\"btn btn-link\">Tour</a>\n    <div class=\"pull-right show-mobile\">\n      <a href=\"#\" class=\"btn btn-primary\" on-click=\"toggleLayersMenu\">\n        <i class=\"fa fa-map\"></i>\n        View Map\n      </a>\n    </div>\n  </footer>\n</main>\n\n<!-- Basemap toggle button -->\n<button id=\"basemap-switcher\" on-click=\"switchBasemap\"></button>\n\n<!-- Layers control menu (mobile only) -->\n<button id=\"layers-menu-toggle\" class=\"btn btn-primary\" on-click=\"toggleLayersMenu\"><i class=\"fa fa-map fa-3x\"></i></button>\n\n<leaflet-map map=\"{{map}}\" latitude=\"33.778724\" longitude=\"-117.960058\" zoom=\"13\" min-zoom=\"11\" max-zoom=\"19\" attribution-prefix=\"City of Garden Grove\">\n\n  <template is=\"dom-if\" if=\"{{baseSource}}\" restamp>\n    <leaflet-tile-layer map=\"{{map}}\" url=\"[[baseSource]]\" format=\"[[baseFormat]]\" layers=\"[[baseLayers]]\" attribution=\"&copy; OpenStreetMap\">\n    </leaflet-tile-layer>\n  </template>\n\n  <template is=\"dom-repeat\" items=\"{{wmsGroups}}\" as=\"group\">\n    <leaflet-wms-group map=\"{{map}}\" source=\"[[group.source]]\" layers=\"[[group.layers]]\" transparent format=\"image/png\">\n    </leaflet-wms-group>\n  </template>\n\n  <template is=\"dom-repeat\" items=\"{{geojsonLayers}}\" as=\"layer\">\n    <leaflet-geojson-points map=\"{{map}}\" source$=\"[[layer.source]]\" radius$=\"[[layer.radius]]\" weight$=\"[[layer.weight]]\" max-cluster-radius$=\"[[layer.maxClusterRadius]]\"\n      fill-color$=\"[[layer.fillColor]]\" outline-color$=\"[[layer.outlineColor]]\" opacity$=\"[[layer.opacity]]\" fill-opacity$=\"[[layer.fillOpacity]]\" identify$=\"[[layer.identify]]\"\n      attribution$=\"[[layer.attribution]]\" cluster$=\"[[layer.cluster]]\">\n    </leaflet-geojson-points>\n  </template>\n</leaflet-map>\n\n<!-- Download Modal -->\n<div class=\"modal fade\" id=\"download-modal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"download-modal-label\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h3 class=\"modal-title\" id=\"download-modal-label\">\n          <span id=\"layer-name\"></span>\n        </h3>\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n          <span aria-hidden=\"true\">&times;</span>\n        </button>\n      </div>\n      <div class=\"modal-body\">\n        <section style=\"height: 400px; overflow: auto; padding: 10px; background-color: #eee; font-size: 0.85rem;\">\n          <h5>Download Disclaimer</h5>\n\n          <p>The City of Garden Grove provides the data as a public resource of general information for use \"as is.\" The City\n            of Garden Grove provides this information with the understanding that it is not guaranteed to be accurate, correct\n            or complete and any conclusions drawn from such information are the sole responsibility of the user. Further,\n            the City of Garden Grove makes no warranty, representation or guaranty as to the content, sequence, accuracy,\n            timeliness or completeness of any of the spatial or database information provided herein. While every effort\n            has been made to ensure the content, sequence, accuracy, timeliness or completeness of materials presented within\n            these pages, the City of Garden Grove assumes no responsibility for errors or omissions, and explicitly disclaims\n            any representations and warranties, including, without limitation, the implied warranties of merchantability\n            and fitness for a particular purpose. The City of Garden Grove shall assume no liability for:</p>\n          <p>1.Any errors, omissions, or inaccuracies in the information provided, regardless of how caused; or 2.Any decision\n            made or action taken or not taken by viewer in reliance upon any information or data furnished hereunder.</p>\n          <p>Availability of the City of Garden Grove GIS is not guaranteed. Applications, servers, and network connections\n            may be unavailable at any time for maintenance or unscheduled outages. Outages may be of long duration. Users\n            are cautioned to create dependencies on these services for critical needs.</p>\n          <p>THE FOREGOING WARRANTY IS EXCLUSIVE AND IN LIEU OF ALL OTHER WARRANTIES OF MERCHANTABILITY, FITNESS FOR PARTICULAR\n            PURPOSE AND/OR ANY OTHER TYPE WHETHER EXPRESSED OR IMPLIED. In no event shall The City of Garden Grove become\n            liable to users of these data, or any other party, for any loss or direct, indirect, special, incidental or consequential\n            damages, including, but not limited to, time, money or goodwill, arising from the use or modification of the\n            data.</p>\n          <p>To assist The City of Garden Grove in the maintenance and/or correction of the data, users should provide the City\n            of Garden Grove with information concerning errors or discrepancies found in using the data. Please acknowledge\n            the City of Garden Grove as the source when data is used in the preparation of reports, papers, publications,\n            maps, or other products.</p>\n        </section>\n      </div>\n      <div class=\"modal-footer\">\n        <!--button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\">Close</button-->\n        <span id=\"download-buttons-label\">Download as:</span>\n        <a id=\"geojson-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>GeoJSON\n        </a>\n        <a id=\"csv-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>CSV\n        </a>\n        <a id=\"kml-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>KML\n        </a>\n        <a id=\"shapefile-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>Shapefile\n        </a>\n      </div>\n    </div>\n  </div>\n</div>"

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e) {
  if ("object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
    ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).jsyaml = e();
  }
}(function () {
  return function e(t, n, i) {
    function r(a, s) {
      if (!n[a]) {
        if (!t[a]) {
          var c = "function" == typeof require && require;if (!s && c) return require(a, !0);if (o) return o(a, !0);var u = new Error("Cannot find module '" + a + "'");throw u.code = "MODULE_NOT_FOUND", u;
        }var l = n[a] = { exports: {} };t[a][0].call(l.exports, function (e) {
          var n = t[a][1][e];return r(n || e);
        }, l, l.exports, e, t, n, i);
      }return n[a].exports;
    }for (var o = "function" == typeof require && require, a = 0; a < i.length; a++) {
      r(i[a]);
    }return r;
  }({ 1: [function (e, t, n) {
      "use strict";
      function i(e) {
        return function () {
          throw new Error("Function " + e + " is deprecated and cannot be used.");
        };
      }var r = e("./js-yaml/loader"),
          o = e("./js-yaml/dumper");t.exports.Type = e("./js-yaml/type"), t.exports.Schema = e("./js-yaml/schema"), t.exports.FAILSAFE_SCHEMA = e("./js-yaml/schema/failsafe"), t.exports.JSON_SCHEMA = e("./js-yaml/schema/json"), t.exports.CORE_SCHEMA = e("./js-yaml/schema/core"), t.exports.DEFAULT_SAFE_SCHEMA = e("./js-yaml/schema/default_safe"), t.exports.DEFAULT_FULL_SCHEMA = e("./js-yaml/schema/default_full"), t.exports.load = r.load, t.exports.loadAll = r.loadAll, t.exports.safeLoad = r.safeLoad, t.exports.safeLoadAll = r.safeLoadAll, t.exports.dump = o.dump, t.exports.safeDump = o.safeDump, t.exports.YAMLException = e("./js-yaml/exception"), t.exports.MINIMAL_SCHEMA = e("./js-yaml/schema/failsafe"), t.exports.SAFE_SCHEMA = e("./js-yaml/schema/default_safe"), t.exports.DEFAULT_SCHEMA = e("./js-yaml/schema/default_full"), t.exports.scan = i("scan"), t.exports.parse = i("parse"), t.exports.compose = i("compose"), t.exports.addConstructor = i("addConstructor");
    }, { "./js-yaml/dumper": 3, "./js-yaml/exception": 4, "./js-yaml/loader": 5, "./js-yaml/schema": 7, "./js-yaml/schema/core": 8, "./js-yaml/schema/default_full": 9, "./js-yaml/schema/default_safe": 10, "./js-yaml/schema/failsafe": 11, "./js-yaml/schema/json": 12, "./js-yaml/type": 13 }], 2: [function (e, t, n) {
      "use strict";
      function i(e) {
        return void 0 === e || null === e;
      }t.exports.isNothing = i, t.exports.isObject = function (e) {
        return "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e;
      }, t.exports.toArray = function (e) {
        return Array.isArray(e) ? e : i(e) ? [] : [e];
      }, t.exports.repeat = function (e, t) {
        var n,
            i = "";for (n = 0; n < t; n += 1) {
          i += e;
        }return i;
      }, t.exports.isNegativeZero = function (e) {
        return 0 === e && Number.NEGATIVE_INFINITY === 1 / e;
      }, t.exports.extend = function (e, t) {
        var n, i, r, o;if (t) for (n = 0, i = (o = Object.keys(t)).length; n < i; n += 1) {
          e[r = o[n]] = t[r];
        }return e;
      };
    }, {}], 3: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        var n, i, r, o, a, s, c;if (null === t) return {};for (n = {}, r = 0, o = (i = Object.keys(t)).length; r < o; r += 1) {
          a = i[r], s = String(t[a]), "!!" === a.slice(0, 2) && (a = "tag:yaml.org,2002:" + a.slice(2)), (c = e.compiledTypeMap.fallback[a]) && T.call(c.styleAliases, s) && (s = c.styleAliases[s]), n[a] = s;
        }return n;
      }function r(e) {
        var t, n, i;if (t = e.toString(16).toUpperCase(), e <= 255) n = "x", i = 2;else if (e <= 65535) n = "u", i = 4;else {
          if (!(e <= 4294967295)) throw new F("code point within a string may not be greater than 0xFFFFFFFF");n = "U", i = 8;
        }return "\\" + n + E.repeat("0", i - t.length) + t;
      }function o(e) {
        this.schema = e.schema || _, this.indent = Math.max(1, e.indent || 2), this.skipInvalid = e.skipInvalid || !1, this.flowLevel = E.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = i(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
      }function a(e, t) {
        for (var n, i = E.repeat(" ", t), r = 0, o = -1, a = "", s = e.length; r < s;) {
          -1 === (o = e.indexOf("\n", r)) ? (n = e.slice(r), r = s) : (n = e.slice(r, o + 1), r = o + 1), n.length && "\n" !== n && (a += i), a += n;
        }return a;
      }function s(e, t) {
        return "\n" + E.repeat(" ", e.indent * t);
      }function c(e, t) {
        var n, i;for (n = 0, i = e.implicitTypes.length; n < i; n += 1) {
          if (e.implicitTypes[n].resolve(t)) return !0;
        }return !1;
      }function u(e) {
        return e === U || e === L;
      }function l(e) {
        return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && 8232 !== e && 8233 !== e || 57344 <= e && e <= 65533 && 65279 !== e || 65536 <= e && e <= 1114111;
      }function p(e) {
        return l(e) && 65279 !== e && e !== $ && e !== J && e !== Q && e !== ee && e !== ne && e !== G && e !== R;
      }function f(e) {
        return l(e) && 65279 !== e && !u(e) && e !== H && e !== Z && e !== G && e !== $ && e !== J && e !== Q && e !== ee && e !== ne && e !== R && e !== W && e !== K && e !== q && e !== te && e !== V && e !== B && e !== Y && e !== P && e !== z && e !== X;
      }function d(e, t, n, i, r) {
        var o,
            a,
            s = !1,
            c = !1,
            d = -1 !== i,
            h = -1,
            m = f(e.charCodeAt(0)) && !u(e.charCodeAt(e.length - 1));if (t) for (o = 0; o < e.length; o++) {
          if (a = e.charCodeAt(o), !l(a)) return ue;m = m && p(a);
        } else {
          for (o = 0; o < e.length; o++) {
            if ((a = e.charCodeAt(o)) === D) s = !0, d && (c = c || o - h - 1 > i && " " !== e[h + 1], h = o);else if (!l(a)) return ue;m = m && p(a);
          }c = c || d && o - h - 1 > i && " " !== e[h + 1];
        }return s || c ? " " === e[0] && n > 9 ? ue : c ? ce : se : m && !r(e) ? oe : ae;
      }function h(e, t, n, i) {
        e.dump = function () {
          if (0 === t.length) return "''";if (!e.noCompatMode && -1 !== re.indexOf(t)) return "'" + t + "'";var r = e.indent * Math.max(1, n),
              o = -1 === e.lineWidth ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - r),
              s = i || e.flowLevel > -1 && n >= e.flowLevel;switch (d(t, s, e.indent, o, function (t) {
            return c(e, t);
          })) {case oe:
              return t;case ae:
              return "'" + t.replace(/'/g, "''") + "'";case se:
              return "|" + m(t, e.indent) + g(a(t, r));case ce:
              return ">" + m(t, e.indent) + g(a(y(t, o), r));case ue:
              return '"' + v(t) + '"';default:
              throw new F("impossible error: invalid scalar style");}
        }();
      }function m(e, t) {
        var n = " " === e[0] ? String(t) : "",
            i = "\n" === e[e.length - 1];return n + (i && ("\n" === e[e.length - 2] || "\n" === e) ? "+" : i ? "" : "-") + "\n";
      }function g(e) {
        return "\n" === e[e.length - 1] ? e.slice(0, -1) : e;
      }function y(e, t) {
        for (var n, i, r = /(\n+)([^\n]*)/g, o = function () {
          var n = e.indexOf("\n");return n = -1 !== n ? n : e.length, r.lastIndex = n, x(e.slice(0, n), t);
        }(), a = "\n" === e[0] || " " === e[0]; i = r.exec(e);) {
          var s = i[1],
              c = i[2];n = " " === c[0], o += s + (a || n || "" === c ? "" : "\n") + x(c, t), a = n;
        }return o;
      }function x(e, t) {
        if ("" === e || " " === e[0]) return e;for (var n, i, r = / [^ ]/g, o = 0, a = 0, s = 0, c = ""; n = r.exec(e);) {
          (s = n.index) - o > t && (i = a > o ? a : s, c += "\n" + e.slice(o, i), o = i + 1), a = s;
        }return c += "\n", e.length - o > t && a > o ? c += e.slice(o, a) + "\n" + e.slice(a + 1) : c += e.slice(o), c.slice(1);
      }function v(e) {
        for (var t, n, i, o = "", a = 0; a < e.length; a++) {
          (t = e.charCodeAt(a)) >= 55296 && t <= 56319 && (n = e.charCodeAt(a + 1)) >= 56320 && n <= 57343 ? (o += r(1024 * (t - 55296) + n - 56320 + 65536), a++) : o += !(i = ie[t]) && l(t) ? e[a] : i || r(t);
        }return o;
      }function A(e, t, n) {
        var i,
            r,
            o = "",
            a = e.tag;for (i = 0, r = n.length; i < r; i += 1) {
          j(e, t, n[i], !1, !1) && (0 !== i && (o += "," + (e.condenseFlow ? "" : " ")), o += e.dump);
        }e.tag = a, e.dump = "[" + o + "]";
      }function b(e, t, n, i) {
        var r,
            o,
            a = "",
            c = e.tag;for (r = 0, o = n.length; r < o; r += 1) {
          j(e, t + 1, n[r], !0, !0) && (i && 0 === r || (a += s(e, t)), e.dump && D === e.dump.charCodeAt(0) ? a += "-" : a += "- ", a += e.dump);
        }e.tag = c, e.dump = a || "[]";
      }function w(e, t, n) {
        var i,
            r,
            o,
            a,
            s,
            c = "",
            u = e.tag,
            l = Object.keys(n);for (i = 0, r = l.length; i < r; i += 1) {
          s = e.condenseFlow ? '"' : "", 0 !== i && (s += ", "), a = n[o = l[i]], j(e, t, o, !1, !1) && (e.dump.length > 1024 && (s += "? "), s += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), j(e, t, a, !1, !1) && (c += s += e.dump));
        }e.tag = u, e.dump = "{" + c + "}";
      }function C(e, t, n, i) {
        var r,
            o,
            a,
            c,
            u,
            l,
            p = "",
            f = e.tag,
            d = Object.keys(n);if (!0 === e.sortKeys) d.sort();else if ("function" == typeof e.sortKeys) d.sort(e.sortKeys);else if (e.sortKeys) throw new F("sortKeys must be a boolean or a function");for (r = 0, o = d.length; r < o; r += 1) {
          l = "", i && 0 === r || (l += s(e, t)), c = n[a = d[r]], j(e, t + 1, a, !0, !0, !0) && ((u = null !== e.tag && "?" !== e.tag || e.dump && e.dump.length > 1024) && (e.dump && D === e.dump.charCodeAt(0) ? l += "?" : l += "? "), l += e.dump, u && (l += s(e, t)), j(e, t + 1, c, !0, u) && (e.dump && D === e.dump.charCodeAt(0) ? l += ":" : l += ": ", p += l += e.dump));
        }e.tag = f, e.dump = p || "{}";
      }function k(e, t, n) {
        var i, r, o, a, s, c;for (o = 0, a = (r = n ? e.explicitTypes : e.implicitTypes).length; o < a; o += 1) {
          if (((s = r[o]).instanceOf || s.predicate) && (!s.instanceOf || "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t instanceof s.instanceOf) && (!s.predicate || s.predicate(t))) {
            if (e.tag = n ? s.tag : "?", s.represent) {
              if (c = e.styleMap[s.tag] || s.defaultStyle, "[object Function]" === M.call(s.represent)) i = s.represent(t, c);else {
                if (!T.call(s.represent, c)) throw new F("!<" + s.tag + '> tag resolver accepts not "' + c + '" style');i = s.represent[c](t, c);
              }e.dump = i;
            }return !0;
          }
        }return !1;
      }function j(e, t, n, i, r, o) {
        e.tag = null, e.dump = n, k(e, n, !1) || k(e, n, !0);var a = M.call(e.dump);i && (i = e.flowLevel < 0 || e.flowLevel > t);var s,
            c,
            u = "[object Object]" === a || "[object Array]" === a;if (u && (c = -1 !== (s = e.duplicates.indexOf(n))), (null !== e.tag && "?" !== e.tag || c || 2 !== e.indent && t > 0) && (r = !1), c && e.usedDuplicates[s]) e.dump = "*ref_" + s;else {
          if (u && c && !e.usedDuplicates[s] && (e.usedDuplicates[s] = !0), "[object Object]" === a) i && 0 !== Object.keys(e.dump).length ? (C(e, t, e.dump, r), c && (e.dump = "&ref_" + s + e.dump)) : (w(e, t, e.dump), c && (e.dump = "&ref_" + s + " " + e.dump));else if ("[object Array]" === a) i && 0 !== e.dump.length ? (b(e, t, e.dump, r), c && (e.dump = "&ref_" + s + e.dump)) : (A(e, t, e.dump), c && (e.dump = "&ref_" + s + " " + e.dump));else {
            if ("[object String]" !== a) {
              if (e.skipInvalid) return !1;throw new F("unacceptable kind of an object to dump " + a);
            }"?" !== e.tag && h(e, e.dump, t, o);
          }null !== e.tag && "?" !== e.tag && (e.dump = "!<" + e.tag + "> " + e.dump);
        }return !0;
      }function I(e, t) {
        var n,
            i,
            r = [],
            o = [];for (S(e, r, o), n = 0, i = o.length; n < i; n += 1) {
          t.duplicates.push(r[o[n]]);
        }t.usedDuplicates = new Array(i);
      }function S(e, t, n) {
        var i, r, o;if (null !== e && "object" == (typeof e === "undefined" ? "undefined" : _typeof(e))) if (-1 !== (r = t.indexOf(e))) -1 === n.indexOf(r) && n.push(r);else if (t.push(e), Array.isArray(e)) for (r = 0, o = e.length; r < o; r += 1) {
          S(e[r], t, n);
        } else for (r = 0, o = (i = Object.keys(e)).length; r < o; r += 1) {
          S(e[i[r]], t, n);
        }
      }function O(e, t) {
        var n = new o(t = t || {});return n.noRefs || I(e, n), j(n, 0, e, !0, !0) ? n.dump + "\n" : "";
      }var E = e("./common"),
          F = e("./exception"),
          _ = e("./schema/default_full"),
          N = e("./schema/default_safe"),
          M = Object.prototype.toString,
          T = Object.prototype.hasOwnProperty,
          L = 9,
          D = 10,
          U = 32,
          q = 33,
          Y = 34,
          R = 35,
          P = 37,
          W = 38,
          B = 39,
          K = 42,
          $ = 44,
          H = 45,
          G = 58,
          V = 62,
          Z = 63,
          z = 64,
          J = 91,
          Q = 93,
          X = 96,
          ee = 123,
          te = 124,
          ne = 125,
          ie = {};ie[0] = "\\0", ie[7] = "\\a", ie[8] = "\\b", ie[9] = "\\t", ie[10] = "\\n", ie[11] = "\\v", ie[12] = "\\f", ie[13] = "\\r", ie[27] = "\\e", ie[34] = '\\"', ie[92] = "\\\\", ie[133] = "\\N", ie[160] = "\\_", ie[8232] = "\\L", ie[8233] = "\\P";var re = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
          oe = 1,
          ae = 2,
          se = 3,
          ce = 4,
          ue = 5;t.exports.dump = O, t.exports.safeDump = function (e, t) {
        return O(e, E.extend({ schema: N }, t));
      };
    }, { "./common": 2, "./exception": 4, "./schema/default_full": 9, "./schema/default_safe": 10 }], 4: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
      }(i.prototype = Object.create(Error.prototype)).constructor = i, i.prototype.toString = function (e) {
        var t = this.name + ": ";return t += this.reason || "(unknown reason)", !e && this.mark && (t += " " + this.mark.toString()), t;
      }, t.exports = i;
    }, {}], 5: [function (e, t, n) {
      "use strict";
      function i(e) {
        return 10 === e || 13 === e;
      }function r(e) {
        return 9 === e || 32 === e;
      }function o(e) {
        return 9 === e || 32 === e || 10 === e || 13 === e;
      }function a(e) {
        return 44 === e || 91 === e || 93 === e || 123 === e || 125 === e;
      }function s(e) {
        var t;return 48 <= e && e <= 57 ? e - 48 : 97 <= (t = 32 | e) && t <= 102 ? t - 97 + 10 : -1;
      }function c(e) {
        return 120 === e ? 2 : 117 === e ? 4 : 85 === e ? 8 : 0;
      }function u(e) {
        return 48 <= e && e <= 57 ? e - 48 : -1;
      }function l(e) {
        return 48 === e ? "\0" : 97 === e ? "" : 98 === e ? "\b" : 116 === e ? "\t" : 9 === e ? "\t" : 110 === e ? "\n" : 118 === e ? "\v" : 102 === e ? "\f" : 114 === e ? "\r" : 101 === e ? "" : 32 === e ? " " : 34 === e ? '"' : 47 === e ? "/" : 92 === e ? "\\" : 78 === e ? "" : 95 === e ? " " : 76 === e ? "\u2028" : 80 === e ? "\u2029" : "";
      }function p(e) {
        return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(55296 + (e - 65536 >> 10), 56320 + (e - 65536 & 1023));
      }function f(e, t) {
        this.input = e, this.filename = t.filename || null, this.schema = t.schema || W, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
      }function d(e, t) {
        return new Y(t, new R(e.filename, e.input, e.position, e.line, e.position - e.lineStart));
      }function h(e, t) {
        throw d(e, t);
      }function m(e, t) {
        e.onWarning && e.onWarning.call(null, d(e, t));
      }function g(e, t, n, i) {
        var r, o, a, s;if (t < n) {
          if (s = e.input.slice(t, n), i) for (r = 0, o = s.length; r < o; r += 1) {
            9 === (a = s.charCodeAt(r)) || 32 <= a && a <= 1114111 || h(e, "expected valid JSON character");
          } else J.test(s) && h(e, "the stream contains non-printable characters");e.result += s;
        }
      }function y(e, t, n, i) {
        var r, o, a, s;for (q.isObject(n) || h(e, "cannot merge mappings; the provided source object is unacceptable"), a = 0, s = (r = Object.keys(n)).length; a < s; a += 1) {
          o = r[a], B.call(t, o) || (t[o] = n[o], i[o] = !0);
        }
      }function x(e, t, n, i, r, o, a, s) {
        var c, u;if (r = String(r), null === t && (t = {}), "tag:yaml.org,2002:merge" === i) {
          if (Array.isArray(o)) for (c = 0, u = o.length; c < u; c += 1) {
            y(e, t, o[c], n);
          } else y(e, t, o, n);
        } else e.json || B.call(n, r) || !B.call(t, r) || (e.line = a || e.line, e.position = s || e.position, h(e, "duplicated mapping key")), t[r] = o, delete n[r];return t;
      }function v(e) {
        var t;10 === (t = e.input.charCodeAt(e.position)) ? e.position++ : 13 === t ? (e.position++, 10 === e.input.charCodeAt(e.position) && e.position++) : h(e, "a line break is expected"), e.line += 1, e.lineStart = e.position;
      }function A(e, t, n) {
        for (var o = 0, a = e.input.charCodeAt(e.position); 0 !== a;) {
          for (; r(a);) {
            a = e.input.charCodeAt(++e.position);
          }if (t && 35 === a) do {
            a = e.input.charCodeAt(++e.position);
          } while (10 !== a && 13 !== a && 0 !== a);if (!i(a)) break;for (v(e), a = e.input.charCodeAt(e.position), o++, e.lineIndent = 0; 32 === a;) {
            e.lineIndent++, a = e.input.charCodeAt(++e.position);
          }
        }return -1 !== n && 0 !== o && e.lineIndent < n && m(e, "deficient indentation"), o;
      }function b(e) {
        var t,
            n = e.position;return !(45 !== (t = e.input.charCodeAt(n)) && 46 !== t || t !== e.input.charCodeAt(n + 1) || t !== e.input.charCodeAt(n + 2) || (n += 3, 0 !== (t = e.input.charCodeAt(n)) && !o(t)));
      }function w(e, t) {
        1 === t ? e.result += " " : t > 1 && (e.result += q.repeat("\n", t - 1));
      }function C(e, t, n) {
        var s,
            c,
            u,
            l,
            p,
            f,
            d,
            h,
            m,
            y = e.kind,
            x = e.result;if (m = e.input.charCodeAt(e.position), o(m) || a(m) || 35 === m || 38 === m || 42 === m || 33 === m || 124 === m || 62 === m || 39 === m || 34 === m || 37 === m || 64 === m || 96 === m) return !1;if ((63 === m || 45 === m) && (c = e.input.charCodeAt(e.position + 1), o(c) || n && a(c))) return !1;for (e.kind = "scalar", e.result = "", u = l = e.position, p = !1; 0 !== m;) {
          if (58 === m) {
            if (c = e.input.charCodeAt(e.position + 1), o(c) || n && a(c)) break;
          } else if (35 === m) {
            if (s = e.input.charCodeAt(e.position - 1), o(s)) break;
          } else {
            if (e.position === e.lineStart && b(e) || n && a(m)) break;if (i(m)) {
              if (f = e.line, d = e.lineStart, h = e.lineIndent, A(e, !1, -1), e.lineIndent >= t) {
                p = !0, m = e.input.charCodeAt(e.position);continue;
              }e.position = l, e.line = f, e.lineStart = d, e.lineIndent = h;break;
            }
          }p && (g(e, u, l, !1), w(e, e.line - f), u = l = e.position, p = !1), r(m) || (l = e.position + 1), m = e.input.charCodeAt(++e.position);
        }return g(e, u, l, !1), !!e.result || (e.kind = y, e.result = x, !1);
      }function k(e, t) {
        var n, r, o;if (39 !== (n = e.input.charCodeAt(e.position))) return !1;for (e.kind = "scalar", e.result = "", e.position++, r = o = e.position; 0 !== (n = e.input.charCodeAt(e.position));) {
          if (39 === n) {
            if (g(e, r, e.position, !0), 39 !== (n = e.input.charCodeAt(++e.position))) return !0;r = e.position, e.position++, o = e.position;
          } else i(n) ? (g(e, r, o, !0), w(e, A(e, !1, t)), r = o = e.position) : e.position === e.lineStart && b(e) ? h(e, "unexpected end of the document within a single quoted scalar") : (e.position++, o = e.position);
        }h(e, "unexpected end of the stream within a single quoted scalar");
      }function j(e, t) {
        var n, r, o, a, u, l;if (34 !== (l = e.input.charCodeAt(e.position))) return !1;for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; 0 !== (l = e.input.charCodeAt(e.position));) {
          if (34 === l) return g(e, n, e.position, !0), e.position++, !0;if (92 === l) {
            if (g(e, n, e.position, !0), l = e.input.charCodeAt(++e.position), i(l)) A(e, !1, t);else if (l < 256 && ne[l]) e.result += ie[l], e.position++;else if ((u = c(l)) > 0) {
              for (o = u, a = 0; o > 0; o--) {
                (u = s(l = e.input.charCodeAt(++e.position))) >= 0 ? a = (a << 4) + u : h(e, "expected hexadecimal character");
              }e.result += p(a), e.position++;
            } else h(e, "unknown escape sequence");n = r = e.position;
          } else i(l) ? (g(e, n, r, !0), w(e, A(e, !1, t)), n = r = e.position) : e.position === e.lineStart && b(e) ? h(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
        }h(e, "unexpected end of the stream within a double quoted scalar");
      }function I(e, t) {
        var n,
            i,
            r,
            a,
            s,
            c,
            u,
            l,
            p,
            f,
            d = !0,
            m = e.tag,
            g = e.anchor,
            y = {};if (91 === (f = e.input.charCodeAt(e.position))) r = 93, c = !1, i = [];else {
          if (123 !== f) return !1;r = 125, c = !0, i = {};
        }for (null !== e.anchor && (e.anchorMap[e.anchor] = i), f = e.input.charCodeAt(++e.position); 0 !== f;) {
          if (A(e, !0, t), (f = e.input.charCodeAt(e.position)) === r) return e.position++, e.tag = m, e.anchor = g, e.kind = c ? "mapping" : "sequence", e.result = i, !0;d || h(e, "missed comma between flow collection entries"), l = u = p = null, a = s = !1, 63 === f && o(e.input.charCodeAt(e.position + 1)) && (a = s = !0, e.position++, A(e, !0, t)), n = e.line, M(e, t, K, !1, !0), l = e.tag, u = e.result, A(e, !0, t), f = e.input.charCodeAt(e.position), !s && e.line !== n || 58 !== f || (a = !0, f = e.input.charCodeAt(++e.position), A(e, !0, t), M(e, t, K, !1, !0), p = e.result), c ? x(e, i, y, l, u, p) : a ? i.push(x(e, null, y, l, u, p)) : i.push(u), A(e, !0, t), 44 === (f = e.input.charCodeAt(e.position)) ? (d = !0, f = e.input.charCodeAt(++e.position)) : d = !1;
        }h(e, "unexpected end of the stream within a flow collection");
      }function S(e, t) {
        var n,
            o,
            a,
            s,
            c = V,
            l = !1,
            p = !1,
            f = t,
            d = 0,
            m = !1;if (124 === (s = e.input.charCodeAt(e.position))) o = !1;else {
          if (62 !== s) return !1;o = !0;
        }for (e.kind = "scalar", e.result = ""; 0 !== s;) {
          if (43 === (s = e.input.charCodeAt(++e.position)) || 45 === s) V === c ? c = 43 === s ? z : Z : h(e, "repeat of a chomping mode identifier");else {
            if (!((a = u(s)) >= 0)) break;0 === a ? h(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : p ? h(e, "repeat of an indentation width identifier") : (f = t + a - 1, p = !0);
          }
        }if (r(s)) {
          do {
            s = e.input.charCodeAt(++e.position);
          } while (r(s));if (35 === s) do {
            s = e.input.charCodeAt(++e.position);
          } while (!i(s) && 0 !== s);
        }for (; 0 !== s;) {
          for (v(e), e.lineIndent = 0, s = e.input.charCodeAt(e.position); (!p || e.lineIndent < f) && 32 === s;) {
            e.lineIndent++, s = e.input.charCodeAt(++e.position);
          }if (!p && e.lineIndent > f && (f = e.lineIndent), i(s)) d++;else {
            if (e.lineIndent < f) {
              c === z ? e.result += q.repeat("\n", l ? 1 + d : d) : c === V && l && (e.result += "\n");break;
            }for (o ? r(s) ? (m = !0, e.result += q.repeat("\n", l ? 1 + d : d)) : m ? (m = !1, e.result += q.repeat("\n", d + 1)) : 0 === d ? l && (e.result += " ") : e.result += q.repeat("\n", d) : e.result += q.repeat("\n", l ? 1 + d : d), l = !0, p = !0, d = 0, n = e.position; !i(s) && 0 !== s;) {
              s = e.input.charCodeAt(++e.position);
            }g(e, n, e.position, !1);
          }
        }return !0;
      }function O(e, t) {
        var n,
            i,
            r,
            a = e.tag,
            s = e.anchor,
            c = [],
            u = !1;for (null !== e.anchor && (e.anchorMap[e.anchor] = c), r = e.input.charCodeAt(e.position); 0 !== r && 45 === r && (i = e.input.charCodeAt(e.position + 1), o(i));) {
          if (u = !0, e.position++, A(e, !0, -1) && e.lineIndent <= t) c.push(null), r = e.input.charCodeAt(e.position);else if (n = e.line, M(e, t, H, !1, !0), c.push(e.result), A(e, !0, -1), r = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && 0 !== r) h(e, "bad indentation of a sequence entry");else if (e.lineIndent < t) break;
        }return !!u && (e.tag = a, e.anchor = s, e.kind = "sequence", e.result = c, !0);
      }function E(e, t, n) {
        var i,
            a,
            s,
            c,
            u,
            l = e.tag,
            p = e.anchor,
            f = {},
            d = {},
            m = null,
            g = null,
            y = null,
            v = !1,
            b = !1;for (null !== e.anchor && (e.anchorMap[e.anchor] = f), u = e.input.charCodeAt(e.position); 0 !== u;) {
          if (i = e.input.charCodeAt(e.position + 1), s = e.line, c = e.position, 63 !== u && 58 !== u || !o(i)) {
            if (!M(e, n, $, !1, !0)) break;if (e.line === s) {
              for (u = e.input.charCodeAt(e.position); r(u);) {
                u = e.input.charCodeAt(++e.position);
              }if (58 === u) o(u = e.input.charCodeAt(++e.position)) || h(e, "a whitespace character is expected after the key-value separator within a block mapping"), v && (x(e, f, d, m, g, null), m = g = y = null), b = !0, v = !1, a = !1, m = e.tag, g = e.result;else {
                if (!b) return e.tag = l, e.anchor = p, !0;h(e, "can not read an implicit mapping pair; a colon is missed");
              }
            } else {
              if (!b) return e.tag = l, e.anchor = p, !0;h(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
            }
          } else 63 === u ? (v && (x(e, f, d, m, g, null), m = g = y = null), b = !0, v = !0, a = !0) : v ? (v = !1, a = !0) : h(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, u = i;if ((e.line === s || e.lineIndent > t) && (M(e, t, G, !0, a) && (v ? g = e.result : y = e.result), v || (x(e, f, d, m, g, y, s, c), m = g = y = null), A(e, !0, -1), u = e.input.charCodeAt(e.position)), e.lineIndent > t && 0 !== u) h(e, "bad indentation of a mapping entry");else if (e.lineIndent < t) break;
        }return v && x(e, f, d, m, g, null), b && (e.tag = l, e.anchor = p, e.kind = "mapping", e.result = f), b;
      }function F(e) {
        var t,
            n,
            i,
            r,
            a = !1,
            s = !1;if (33 !== (r = e.input.charCodeAt(e.position))) return !1;if (null !== e.tag && h(e, "duplication of a tag property"), 60 === (r = e.input.charCodeAt(++e.position)) ? (a = !0, r = e.input.charCodeAt(++e.position)) : 33 === r ? (s = !0, n = "!!", r = e.input.charCodeAt(++e.position)) : n = "!", t = e.position, a) {
          do {
            r = e.input.charCodeAt(++e.position);
          } while (0 !== r && 62 !== r);e.position < e.length ? (i = e.input.slice(t, e.position), r = e.input.charCodeAt(++e.position)) : h(e, "unexpected end of the stream within a verbatim tag");
        } else {
          for (; 0 !== r && !o(r);) {
            33 === r && (s ? h(e, "tag suffix cannot contain exclamation marks") : (n = e.input.slice(t - 1, e.position + 1), ee.test(n) || h(e, "named tag handle cannot contain such characters"), s = !0, t = e.position + 1)), r = e.input.charCodeAt(++e.position);
          }i = e.input.slice(t, e.position), X.test(i) && h(e, "tag suffix cannot contain flow indicator characters");
        }return i && !te.test(i) && h(e, "tag name cannot contain such characters: " + i), a ? e.tag = i : B.call(e.tagMap, n) ? e.tag = e.tagMap[n] + i : "!" === n ? e.tag = "!" + i : "!!" === n ? e.tag = "tag:yaml.org,2002:" + i : h(e, 'undeclared tag handle "' + n + '"'), !0;
      }function _(e) {
        var t, n;if (38 !== (n = e.input.charCodeAt(e.position))) return !1;for (null !== e.anchor && h(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; 0 !== n && !o(n) && !a(n);) {
          n = e.input.charCodeAt(++e.position);
        }return e.position === t && h(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
      }function N(e) {
        var t, n, i;if (42 !== (i = e.input.charCodeAt(e.position))) return !1;for (i = e.input.charCodeAt(++e.position), t = e.position; 0 !== i && !o(i) && !a(i);) {
          i = e.input.charCodeAt(++e.position);
        }return e.position === t && h(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), e.anchorMap.hasOwnProperty(n) || h(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], A(e, !0, -1), !0;
      }function M(e, t, n, i, r) {
        var o,
            a,
            s,
            c,
            u,
            l,
            p,
            f,
            d = 1,
            m = !1,
            g = !1;if (null !== e.listener && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, o = a = s = G === n || H === n, i && A(e, !0, -1) && (m = !0, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)), 1 === d) for (; F(e) || _(e);) {
          A(e, !0, -1) ? (m = !0, s = o, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)) : s = !1;
        }if (s && (s = m || r), 1 !== d && G !== n || (p = K === n || $ === n ? t : t + 1, f = e.position - e.lineStart, 1 === d ? s && (O(e, f) || E(e, f, p)) || I(e, p) ? g = !0 : (a && S(e, p) || k(e, p) || j(e, p) ? g = !0 : N(e) ? (g = !0, null === e.tag && null === e.anchor || h(e, "alias node should not have any properties")) : C(e, p, K === n) && (g = !0, null === e.tag && (e.tag = "?")), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : 0 === d && (g = s && O(e, f))), null !== e.tag && "!" !== e.tag) if ("?" === e.tag) {
          for (c = 0, u = e.implicitTypes.length; c < u; c += 1) {
            if ((l = e.implicitTypes[c]).resolve(e.result)) {
              e.result = l.construct(e.result), e.tag = l.tag, null !== e.anchor && (e.anchorMap[e.anchor] = e.result);break;
            }
          }
        } else B.call(e.typeMap[e.kind || "fallback"], e.tag) ? (l = e.typeMap[e.kind || "fallback"][e.tag], null !== e.result && l.kind !== e.kind && h(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + l.kind + '", not "' + e.kind + '"'), l.resolve(e.result) ? (e.result = l.construct(e.result), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : h(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")) : h(e, "unknown tag !<" + e.tag + ">");return null !== e.listener && e.listener("close", e), null !== e.tag || null !== e.anchor || g;
      }function T(e) {
        var t,
            n,
            a,
            s,
            c = e.position,
            u = !1;for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = {}, e.anchorMap = {}; 0 !== (s = e.input.charCodeAt(e.position)) && (A(e, !0, -1), s = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || 37 !== s));) {
          for (u = !0, s = e.input.charCodeAt(++e.position), t = e.position; 0 !== s && !o(s);) {
            s = e.input.charCodeAt(++e.position);
          }for (a = [], (n = e.input.slice(t, e.position)).length < 1 && h(e, "directive name must not be less than one character in length"); 0 !== s;) {
            for (; r(s);) {
              s = e.input.charCodeAt(++e.position);
            }if (35 === s) {
              do {
                s = e.input.charCodeAt(++e.position);
              } while (0 !== s && !i(s));break;
            }if (i(s)) break;for (t = e.position; 0 !== s && !o(s);) {
              s = e.input.charCodeAt(++e.position);
            }a.push(e.input.slice(t, e.position));
          }0 !== s && v(e), B.call(oe, n) ? oe[n](e, n, a) : m(e, 'unknown document directive "' + n + '"');
        }A(e, !0, -1), 0 === e.lineIndent && 45 === e.input.charCodeAt(e.position) && 45 === e.input.charCodeAt(e.position + 1) && 45 === e.input.charCodeAt(e.position + 2) ? (e.position += 3, A(e, !0, -1)) : u && h(e, "directives end mark is expected"), M(e, e.lineIndent - 1, G, !1, !0), A(e, !0, -1), e.checkLineBreaks && Q.test(e.input.slice(c, e.position)) && m(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && b(e) ? 46 === e.input.charCodeAt(e.position) && (e.position += 3, A(e, !0, -1)) : e.position < e.length - 1 && h(e, "end of the stream or a document separator is expected");
      }function L(e, t) {
        e = String(e), t = t || {}, 0 !== e.length && (10 !== e.charCodeAt(e.length - 1) && 13 !== e.charCodeAt(e.length - 1) && (e += "\n"), 65279 === e.charCodeAt(0) && (e = e.slice(1)));var n = new f(e, t);for (n.input += "\0"; 32 === n.input.charCodeAt(n.position);) {
          n.lineIndent += 1, n.position += 1;
        }for (; n.position < n.length - 1;) {
          T(n);
        }return n.documents;
      }function D(e, t, n) {
        var i,
            r,
            o = L(e, n);if ("function" != typeof t) return o;for (i = 0, r = o.length; i < r; i += 1) {
          t(o[i]);
        }
      }function U(e, t) {
        var n = L(e, t);if (0 !== n.length) {
          if (1 === n.length) return n[0];throw new Y("expected a single document in the stream, but found more");
        }
      }for (var q = e("./common"), Y = e("./exception"), R = e("./mark"), P = e("./schema/default_safe"), W = e("./schema/default_full"), B = Object.prototype.hasOwnProperty, K = 1, $ = 2, H = 3, G = 4, V = 1, Z = 2, z = 3, J = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Q = /[\x85\u2028\u2029]/, X = /[,\[\]\{\}]/, ee = /^(?:!|!!|![a-z\-]+!)$/i, te = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i, ne = new Array(256), ie = new Array(256), re = 0; re < 256; re++) {
        ne[re] = l(re) ? 1 : 0, ie[re] = l(re);
      }var oe = { YAML: function YAML(e, t, n) {
          var i, r, o;null !== e.version && h(e, "duplication of %YAML directive"), 1 !== n.length && h(e, "YAML directive accepts exactly one argument"), null === (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])) && h(e, "ill-formed argument of the YAML directive"), r = parseInt(i[1], 10), o = parseInt(i[2], 10), 1 !== r && h(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = o < 2, 1 !== o && 2 !== o && m(e, "unsupported YAML version of the document");
        }, TAG: function TAG(e, t, n) {
          var i, r;2 !== n.length && h(e, "TAG directive accepts exactly two arguments"), i = n[0], r = n[1], ee.test(i) || h(e, "ill-formed tag handle (first argument) of the TAG directive"), B.call(e.tagMap, i) && h(e, 'there is a previously declared suffix for "' + i + '" tag handle'), te.test(r) || h(e, "ill-formed tag prefix (second argument) of the TAG directive"), e.tagMap[i] = r;
        } };t.exports.loadAll = D, t.exports.load = U, t.exports.safeLoadAll = function (e, t, n) {
        if ("function" != typeof t) return D(e, q.extend({ schema: P }, n));D(e, t, q.extend({ schema: P }, n));
      }, t.exports.safeLoad = function (e, t) {
        return U(e, q.extend({ schema: P }, t));
      };
    }, { "./common": 2, "./exception": 4, "./mark": 6, "./schema/default_full": 9, "./schema/default_safe": 10 }], 6: [function (e, t, n) {
      "use strict";
      function i(e, t, n, i, r) {
        this.name = e, this.buffer = t, this.position = n, this.line = i, this.column = r;
      }var r = e("./common");i.prototype.getSnippet = function (e, t) {
        var n, i, o, a, s;if (!this.buffer) return null;for (e = e || 4, t = t || 75, n = "", i = this.position; i > 0 && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(i - 1));) {
          if (i -= 1, this.position - i > t / 2 - 1) {
            n = " ... ", i += 5;break;
          }
        }for (o = "", a = this.position; a < this.buffer.length && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(a));) {
          if ((a += 1) - this.position > t / 2 - 1) {
            o = " ... ", a -= 5;break;
          }
        }return s = this.buffer.slice(i, a), r.repeat(" ", e) + n + s + o + "\n" + r.repeat(" ", e + this.position - i + n.length) + "^";
      }, i.prototype.toString = function (e) {
        var t,
            n = "";return this.name && (n += 'in "' + this.name + '" '), n += "at line " + (this.line + 1) + ", column " + (this.column + 1), e || (t = this.getSnippet()) && (n += ":\n" + t), n;
      }, t.exports = i;
    }, { "./common": 2 }], 7: [function (e, t, n) {
      "use strict";
      function i(e, t, n) {
        var r = [];return e.include.forEach(function (e) {
          n = i(e, t, n);
        }), e[t].forEach(function (e) {
          n.forEach(function (t, n) {
            t.tag === e.tag && t.kind === e.kind && r.push(n);
          }), n.push(e);
        }), n.filter(function (e, t) {
          return -1 === r.indexOf(t);
        });
      }function r() {
        var e,
            t,
            n = { scalar: {}, sequence: {}, mapping: {}, fallback: {} };for (e = 0, t = arguments.length; e < t; e += 1) {
          arguments[e].forEach(function (e) {
            n[e.kind][e.tag] = n.fallback[e.tag] = e;
          });
        }return n;
      }function o(e) {
        this.include = e.include || [], this.implicit = e.implicit || [], this.explicit = e.explicit || [], this.implicit.forEach(function (e) {
          if (e.loadKind && "scalar" !== e.loadKind) throw new s("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }), this.compiledImplicit = i(this, "implicit", []), this.compiledExplicit = i(this, "explicit", []), this.compiledTypeMap = r(this.compiledImplicit, this.compiledExplicit);
      }var a = e("./common"),
          s = e("./exception"),
          c = e("./type");o.DEFAULT = null, o.create = function () {
        var e, t;switch (arguments.length) {case 1:
            e = o.DEFAULT, t = arguments[0];break;case 2:
            e = arguments[0], t = arguments[1];break;default:
            throw new s("Wrong number of arguments for Schema.create function");}if (e = a.toArray(e), t = a.toArray(t), !e.every(function (e) {
          return e instanceof o;
        })) throw new s("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");if (!t.every(function (e) {
          return e instanceof c;
        })) throw new s("Specified list of YAML types (or a single Type object) contains a non-Type object.");return new o({ include: e, explicit: t });
      }, t.exports = o;
    }, { "./common": 2, "./exception": 4, "./type": 13 }], 8: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./json")] });
    }, { "../schema": 7, "./json": 12 }], 9: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = i.DEFAULT = new i({ include: [e("./default_safe")], explicit: [e("../type/js/undefined"), e("../type/js/regexp"), e("../type/js/function")] });
    }, { "../schema": 7, "../type/js/function": 18, "../type/js/regexp": 19, "../type/js/undefined": 20, "./default_safe": 10 }], 10: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./core")], implicit: [e("../type/timestamp"), e("../type/merge")], explicit: [e("../type/binary"), e("../type/omap"), e("../type/pairs"), e("../type/set")] });
    }, { "../schema": 7, "../type/binary": 14, "../type/merge": 22, "../type/omap": 24, "../type/pairs": 25, "../type/set": 27, "../type/timestamp": 29, "./core": 8 }], 11: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ explicit: [e("../type/str"), e("../type/seq"), e("../type/map")] });
    }, { "../schema": 7, "../type/map": 21, "../type/seq": 26, "../type/str": 28 }], 12: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./failsafe")], implicit: [e("../type/null"), e("../type/bool"), e("../type/int"), e("../type/float")] });
    }, { "../schema": 7, "../type/bool": 15, "../type/float": 16, "../type/int": 17, "../type/null": 23, "./failsafe": 11 }], 13: [function (e, t, n) {
      "use strict";
      function i(e) {
        var t = {};return null !== e && Object.keys(e).forEach(function (n) {
          e[n].forEach(function (e) {
            t[String(e)] = n;
          });
        }), t;
      }var r = e("./exception"),
          o = ["kind", "resolve", "construct", "instanceOf", "predicate", "represent", "defaultStyle", "styleAliases"],
          a = ["scalar", "sequence", "mapping"];t.exports = function (e, t) {
        if (t = t || {}, Object.keys(t).forEach(function (t) {
          if (-1 === o.indexOf(t)) throw new r('Unknown option "' + t + '" is met in definition of "' + e + '" YAML type.');
        }), this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function () {
          return !0;
        }, this.construct = t.construct || function (e) {
          return e;
        }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.defaultStyle = t.defaultStyle || null, this.styleAliases = i(t.styleAliases || null), -1 === a.indexOf(this.kind)) throw new r('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
      };
    }, { "./exception": 4 }], 14: [function (e, t, n) {
      "use strict";
      var i;try {
        i = e("buffer").Buffer;
      } catch (e) {}var r = e("../type"),
          o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";t.exports = new r("tag:yaml.org,2002:binary", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t,
              n,
              i = 0,
              r = e.length,
              a = o;for (n = 0; n < r; n++) {
            if (!((t = a.indexOf(e.charAt(n))) > 64)) {
              if (t < 0) return !1;i += 6;
            }
          }return i % 8 == 0;
        }, construct: function construct(e) {
          var t,
              n,
              r = e.replace(/[\r\n=]/g, ""),
              a = r.length,
              s = o,
              c = 0,
              u = [];for (t = 0; t < a; t++) {
            t % 4 == 0 && t && (u.push(c >> 16 & 255), u.push(c >> 8 & 255), u.push(255 & c)), c = c << 6 | s.indexOf(r.charAt(t));
          }return 0 == (n = a % 4 * 6) ? (u.push(c >> 16 & 255), u.push(c >> 8 & 255), u.push(255 & c)) : 18 === n ? (u.push(c >> 10 & 255), u.push(c >> 2 & 255)) : 12 === n && u.push(c >> 4 & 255), i ? i.from ? i.from(u) : new i(u) : u;
        }, predicate: function predicate(e) {
          return i && i.isBuffer(e);
        }, represent: function represent(e) {
          var t,
              n,
              i = "",
              r = 0,
              a = e.length,
              s = o;for (t = 0; t < a; t++) {
            t % 3 == 0 && t && (i += s[r >> 18 & 63], i += s[r >> 12 & 63], i += s[r >> 6 & 63], i += s[63 & r]), r = (r << 8) + e[t];
          }return 0 == (n = a % 3) ? (i += s[r >> 18 & 63], i += s[r >> 12 & 63], i += s[r >> 6 & 63], i += s[63 & r]) : 2 === n ? (i += s[r >> 10 & 63], i += s[r >> 4 & 63], i += s[r << 2 & 63], i += s[64]) : 1 === n && (i += s[r >> 2 & 63], i += s[r << 4 & 63], i += s[64], i += s[64]), i;
        } });
    }, { "../type": 13 }], 15: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:bool", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t = e.length;return 4 === t && ("true" === e || "True" === e || "TRUE" === e) || 5 === t && ("false" === e || "False" === e || "FALSE" === e);
        }, construct: function construct(e) {
          return "true" === e || "True" === e || "TRUE" === e;
        }, predicate: function predicate(e) {
          return "[object Boolean]" === Object.prototype.toString.call(e);
        }, represent: { lowercase: function lowercase(e) {
            return e ? "true" : "false";
          }, uppercase: function uppercase(e) {
            return e ? "TRUE" : "FALSE";
          }, camelcase: function camelcase(e) {
            return e ? "True" : "False";
          } }, defaultStyle: "lowercase" });
    }, { "../type": 13 }], 16: [function (e, t, n) {
      "use strict";
      var i = e("../common"),
          r = e("../type"),
          o = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"),
          a = /^[-+]?[0-9]+e/;t.exports = new r("tag:yaml.org,2002:float", { kind: "scalar", resolve: function resolve(e) {
          return null !== e && !(!o.test(e) || "_" === e[e.length - 1]);
        }, construct: function construct(e) {
          var t, n, i, r;return t = e.replace(/_/g, "").toLowerCase(), n = "-" === t[0] ? -1 : 1, r = [], "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), ".inf" === t ? 1 === n ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : ".nan" === t ? NaN : t.indexOf(":") >= 0 ? (t.split(":").forEach(function (e) {
            r.unshift(parseFloat(e, 10));
          }), t = 0, i = 1, r.forEach(function (e) {
            t += e * i, i *= 60;
          }), n * t) : n * parseFloat(t, 10);
        }, predicate: function predicate(e) {
          return "[object Number]" === Object.prototype.toString.call(e) && (e % 1 != 0 || i.isNegativeZero(e));
        }, represent: function represent(e, t) {
          var n;if (isNaN(e)) switch (t) {case "lowercase":
              return ".nan";case "uppercase":
              return ".NAN";case "camelcase":
              return ".NaN";} else if (Number.POSITIVE_INFINITY === e) switch (t) {case "lowercase":
              return ".inf";case "uppercase":
              return ".INF";case "camelcase":
              return ".Inf";} else if (Number.NEGATIVE_INFINITY === e) switch (t) {case "lowercase":
              return "-.inf";case "uppercase":
              return "-.INF";case "camelcase":
              return "-.Inf";} else if (i.isNegativeZero(e)) return "-0.0";return n = e.toString(10), a.test(n) ? n.replace("e", ".e") : n;
        }, defaultStyle: "lowercase" });
    }, { "../common": 2, "../type": 13 }], 17: [function (e, t, n) {
      "use strict";
      function i(e) {
        return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
      }function r(e) {
        return 48 <= e && e <= 55;
      }function o(e) {
        return 48 <= e && e <= 57;
      }var a = e("../common"),
          s = e("../type");t.exports = new s("tag:yaml.org,2002:int", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t,
              n = e.length,
              a = 0,
              s = !1;if (!n) return !1;if ("-" !== (t = e[a]) && "+" !== t || (t = e[++a]), "0" === t) {
            if (a + 1 === n) return !0;if ("b" === (t = e[++a])) {
              for (a++; a < n; a++) {
                if ("_" !== (t = e[a])) {
                  if ("0" !== t && "1" !== t) return !1;s = !0;
                }
              }return s && "_" !== t;
            }if ("x" === t) {
              for (a++; a < n; a++) {
                if ("_" !== (t = e[a])) {
                  if (!i(e.charCodeAt(a))) return !1;s = !0;
                }
              }return s && "_" !== t;
            }for (; a < n; a++) {
              if ("_" !== (t = e[a])) {
                if (!r(e.charCodeAt(a))) return !1;s = !0;
              }
            }return s && "_" !== t;
          }if ("_" === t) return !1;for (; a < n; a++) {
            if ("_" !== (t = e[a])) {
              if (":" === t) break;if (!o(e.charCodeAt(a))) return !1;s = !0;
            }
          }return !(!s || "_" === t) && (":" !== t || /^(:[0-5]?[0-9])+$/.test(e.slice(a)));
        }, construct: function construct(e) {
          var t,
              n,
              i = e,
              r = 1,
              o = [];return -1 !== i.indexOf("_") && (i = i.replace(/_/g, "")), "-" !== (t = i[0]) && "+" !== t || ("-" === t && (r = -1), t = (i = i.slice(1))[0]), "0" === i ? 0 : "0" === t ? "b" === i[1] ? r * parseInt(i.slice(2), 2) : "x" === i[1] ? r * parseInt(i, 16) : r * parseInt(i, 8) : -1 !== i.indexOf(":") ? (i.split(":").forEach(function (e) {
            o.unshift(parseInt(e, 10));
          }), i = 0, n = 1, o.forEach(function (e) {
            i += e * n, n *= 60;
          }), r * i) : r * parseInt(i, 10);
        }, predicate: function predicate(e) {
          return "[object Number]" === Object.prototype.toString.call(e) && e % 1 == 0 && !a.isNegativeZero(e);
        }, represent: { binary: function binary(e) {
            return "0b" + e.toString(2);
          }, octal: function octal(e) {
            return "0" + e.toString(8);
          }, decimal: function decimal(e) {
            return e.toString(10);
          }, hexadecimal: function hexadecimal(e) {
            return "0x" + e.toString(16).toUpperCase();
          } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } });
    }, { "../common": 2, "../type": 13 }], 18: [function (e, t, n) {
      "use strict";
      var i;try {
        i = e("esprima");
      } catch (e) {
        "undefined" != typeof window && (i = window.esprima);
      }var r = e("../../type");t.exports = new r("tag:yaml.org,2002:js/function", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;try {
            var t = "(" + e + ")",
                n = i.parse(t, { range: !0 });return "Program" === n.type && 1 === n.body.length && "ExpressionStatement" === n.body[0].type && "FunctionExpression" === n.body[0].expression.type;
          } catch (e) {
            return !1;
          }
        }, construct: function construct(e) {
          var t,
              n = "(" + e + ")",
              r = i.parse(n, { range: !0 }),
              o = [];if ("Program" !== r.type || 1 !== r.body.length || "ExpressionStatement" !== r.body[0].type || "FunctionExpression" !== r.body[0].expression.type) throw new Error("Failed to resolve function");return r.body[0].expression.params.forEach(function (e) {
            o.push(e.name);
          }), t = r.body[0].expression.body.range, new Function(o, n.slice(t[0] + 1, t[1] - 1));
        }, predicate: function predicate(e) {
          return "[object Function]" === Object.prototype.toString.call(e);
        }, represent: function represent(e) {
          return e.toString();
        } });
    }, { "../../type": 13 }], 19: [function (e, t, n) {
      "use strict";
      var i = e("../../type");t.exports = new i("tag:yaml.org,2002:js/regexp", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;if (0 === e.length) return !1;var t = e,
              n = /\/([gim]*)$/.exec(e),
              i = "";if ("/" === t[0]) {
            if (n && (i = n[1]), i.length > 3) return !1;if ("/" !== t[t.length - i.length - 1]) return !1;
          }return !0;
        }, construct: function construct(e) {
          var t = e,
              n = /\/([gim]*)$/.exec(e),
              i = "";return "/" === t[0] && (n && (i = n[1]), t = t.slice(1, t.length - i.length - 1)), new RegExp(t, i);
        }, predicate: function predicate(e) {
          return "[object RegExp]" === Object.prototype.toString.call(e);
        }, represent: function represent(e) {
          var t = "/" + e.source + "/";return e.global && (t += "g"), e.multiline && (t += "m"), e.ignoreCase && (t += "i"), t;
        } });
    }, { "../../type": 13 }], 20: [function (e, t, n) {
      "use strict";
      var i = e("../../type");t.exports = new i("tag:yaml.org,2002:js/undefined", { kind: "scalar", resolve: function resolve() {
          return !0;
        }, construct: function construct() {}, predicate: function predicate(e) {
          return void 0 === e;
        }, represent: function represent() {
          return "";
        } });
    }, { "../../type": 13 }], 21: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:map", { kind: "mapping", construct: function construct(e) {
          return null !== e ? e : {};
        } });
    }, { "../type": 13 }], 22: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:merge", { kind: "scalar", resolve: function resolve(e) {
          return "<<" === e || null === e;
        } });
    }, { "../type": 13 }], 23: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:null", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !0;var t = e.length;return 1 === t && "~" === e || 4 === t && ("null" === e || "Null" === e || "NULL" === e);
        }, construct: function construct() {
          return null;
        }, predicate: function predicate(e) {
          return null === e;
        }, represent: { canonical: function canonical() {
            return "~";
          }, lowercase: function lowercase() {
            return "null";
          }, uppercase: function uppercase() {
            return "NULL";
          }, camelcase: function camelcase() {
            return "Null";
          } }, defaultStyle: "lowercase" });
    }, { "../type": 13 }], 24: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.hasOwnProperty,
          o = Object.prototype.toString;t.exports = new i("tag:yaml.org,2002:omap", { kind: "sequence", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n,
              i,
              a,
              s,
              c = [],
              u = e;for (t = 0, n = u.length; t < n; t += 1) {
            if (i = u[t], s = !1, "[object Object]" !== o.call(i)) return !1;for (a in i) {
              if (r.call(i, a)) {
                if (s) return !1;s = !0;
              }
            }if (!s) return !1;if (-1 !== c.indexOf(a)) return !1;c.push(a);
          }return !0;
        }, construct: function construct(e) {
          return null !== e ? e : [];
        } });
    }, { "../type": 13 }], 25: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.toString;t.exports = new i("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n,
              i,
              o,
              a,
              s = e;for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1) {
            if (i = s[t], "[object Object]" !== r.call(i)) return !1;if (1 !== (o = Object.keys(i)).length) return !1;a[t] = [o[0], i[o[0]]];
          }return !0;
        }, construct: function construct(e) {
          if (null === e) return [];var t,
              n,
              i,
              r,
              o,
              a = e;for (o = new Array(a.length), t = 0, n = a.length; t < n; t += 1) {
            i = a[t], r = Object.keys(i), o[t] = [r[0], i[r[0]]];
          }return o;
        } });
    }, { "../type": 13 }], 26: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:seq", { kind: "sequence", construct: function construct(e) {
          return null !== e ? e : [];
        } });
    }, { "../type": 13 }], 27: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.hasOwnProperty;t.exports = new i("tag:yaml.org,2002:set", { kind: "mapping", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n = e;for (t in n) {
            if (r.call(n, t) && null !== n[t]) return !1;
          }return !0;
        }, construct: function construct(e) {
          return null !== e ? e : {};
        } });
    }, { "../type": 13 }], 28: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:str", { kind: "scalar", construct: function construct(e) {
          return null !== e ? e : "";
        } });
    }, { "../type": 13 }], 29: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
          o = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");t.exports = new i("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: function resolve(e) {
          return null !== e && (null !== r.exec(e) || null !== o.exec(e));
        }, construct: function construct(e) {
          var t,
              n,
              i,
              a,
              s,
              c,
              u,
              l,
              p = 0,
              f = null;if (null === (t = r.exec(e)) && (t = o.exec(e)), null === t) throw new Error("Date resolve error");if (n = +t[1], i = +t[2] - 1, a = +t[3], !t[4]) return new Date(Date.UTC(n, i, a));if (s = +t[4], c = +t[5], u = +t[6], t[7]) {
            for (p = t[7].slice(0, 3); p.length < 3;) {
              p += "0";
            }p = +p;
          }return t[9] && (f = 6e4 * (60 * +t[10] + +(t[11] || 0)), "-" === t[9] && (f = -f)), l = new Date(Date.UTC(n, i, a, s, c, u, p)), f && l.setTime(l.getTime() - f), l;
        }, instanceOf: Date, represent: function represent(e) {
          return e.toISOString();
        } });
    }, { "../type": 13 }], "/": [function (e, t, n) {
      "use strict";
      var i = e("./lib/js-yaml.js");t.exports = i;
    }, { "./lib/js-yaml.js": 1 }] }, {}, [])("/");
});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDU2YzFiYmQ5NWFkN2FmY2VjOTYiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL1V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Cb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vTGF0TG5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL0xhdExuZ0JvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9GZWF0dXJlR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9QYXRoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL211dGFibGUtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXNldHRpbmdzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2Nzcy1wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3RlbXBsYXRpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvRGl2T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS11dGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3RlbXBsYXRlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9kb2N1bWVudC13YWl0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2NvbG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZG9tL1Bvc0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuQXR0cmlidXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL0dyaWRMYXllci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvUG9seVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvR2VvSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dnLW1hcC12aWV3ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvYXBwbHktc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9pbXBvcnQtaHJlZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvY2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1pZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tbWV0YS9pcm9uLW1ldGEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvTWFya2VyLkRyYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmciLCJ3ZWJwYWNrOi8vLy92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LW1hcC9sZWFmbGV0LW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5ab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLlNjYWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvUG9wdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9Ub29sdGlwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuVk1MLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmdldFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8vdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC13bXMvbGVhZmxldC13bXMtZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0Lndtcy5qcyIsIndlYnBhY2s6Ly8vL3Zhci93d3cvbG9jYWxob3N0L2h0ZG9jcy9AZ2djaXR5L2xlYWZsZXQtd21zL2xlYWZsZXQtd21zLWxheWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdnY2l0eS9sZWFmbGV0LXRpbGUtbGF5ZXIvbGVhZmxldC10aWxlLWxheWVyLmpzIiwid2VicGFjazovLy8vdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC1nZW9qc29uL2xlYWZsZXQtZ2VvanNvbi1wb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9MZWFmbGV0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czMzk1LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuU2ltcGxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3BhY2thZ2UuanNvbiIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXJHcm91cC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyT3BhY2l0eS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvRGlzdGFuY2VHcmlkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyLlF1aWNrSHVsbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlci5TcGlkZXJmaWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyR3JvdXAuUmVmcmVzaC5qcyIsIndlYnBhY2s6Ly8vLi4vYXBwLnRlbXBsYXRlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2Rpc3QvanMteWFtbC5taW4uanMiXSwibmFtZXMiOlsiZXh0ZW5kIiwiYmluZCIsInN0YW1wIiwidGhyb3R0bGUiLCJ3cmFwTnVtIiwiZmFsc2VGbiIsImZvcm1hdE51bSIsInRyaW0iLCJzcGxpdFdvcmRzIiwic2V0T3B0aW9ucyIsImdldFBhcmFtU3RyaW5nIiwidGVtcGxhdGUiLCJpbmRleE9mIiwicmVxdWVzdEFuaW1GcmFtZSIsImNhbmNlbEFuaW1GcmFtZSIsImZyZWV6ZSIsIk9iamVjdCIsIm9iaiIsImRlc3QiLCJpIiwiaiIsImxlbiIsInNyYyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNyZWF0ZSIsIkYiLCJwcm90byIsInByb3RvdHlwZSIsImZuIiwic2xpY2UiLCJBcnJheSIsImFwcGx5IiwiY2FsbCIsImFyZ3MiLCJjb25jYXQiLCJsYXN0SWQiLCJfbGVhZmxldF9pZCIsInRpbWUiLCJjb250ZXh0IiwibG9jayIsIndyYXBwZXJGbiIsImxhdGVyIiwic2V0VGltZW91dCIsIngiLCJyYW5nZSIsImluY2x1ZGVNYXgiLCJtYXgiLCJtaW4iLCJkIiwibnVtIiwiZGlnaXRzIiwicG93IiwiTWF0aCIsInJvdW5kIiwic3RyIiwicmVwbGFjZSIsInNwbGl0Iiwib3B0aW9ucyIsImhhc093blByb3BlcnR5IiwiZXhpc3RpbmdVcmwiLCJ1cHBlcmNhc2UiLCJwYXJhbXMiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9VcHBlckNhc2UiLCJqb2luIiwidGVtcGxhdGVSZSIsImRhdGEiLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiaXNBcnJheSIsInRvU3RyaW5nIiwiYXJyYXkiLCJlbCIsImVtcHR5SW1hZ2VVcmwiLCJnZXRQcmVmaXhlZCIsIm5hbWUiLCJ3aW5kb3ciLCJsYXN0VGltZSIsInRpbWVvdXREZWZlciIsIkRhdGUiLCJ0aW1lVG9DYWxsIiwicmVxdWVzdEZuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsRm4iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkIiwiY2xlYXJUaW1lb3V0IiwiaW1tZWRpYXRlIiwiZ2V0IiwiZ2V0U3R5bGUiLCJyZW1vdmUiLCJlbXB0eSIsInRvRnJvbnQiLCJ0b0JhY2siLCJoYXNDbGFzcyIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJzZXRDbGFzcyIsImdldENsYXNzIiwic2V0T3BhY2l0eSIsInRlc3RQcm9wIiwic2V0VHJhbnNmb3JtIiwic2V0UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsImRpc2FibGVJbWFnZURyYWciLCJlbmFibGVJbWFnZURyYWciLCJwcmV2ZW50T3V0bGluZSIsInJlc3RvcmVPdXRsaW5lIiwiRG9tRXZlbnQiLCJVdGlsIiwiQnJvd3NlciIsIlRSQU5TRk9STSIsIlRSQU5TSVRJT04iLCJUUkFOU0lUSU9OX0VORCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzdHlsZSIsImN1cnJlbnRTdHlsZSIsImRlZmF1bHRWaWV3IiwiY3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRhZ05hbWUiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJSZWdFeHAiLCJ0ZXN0IiwiY2xhc3NlcyIsImFkZCIsImJhc2VWYWwiLCJvcGFjaXR5IiwiX3NldE9wYWNpdHlJRSIsImZpbHRlciIsImZpbHRlck5hbWUiLCJmaWx0ZXJzIiwiaXRlbSIsImUiLCJFbmFibGVkIiwiT3BhY2l0eSIsInByb3BzIiwiZG9jdW1lbnRFbGVtZW50Iiwib2Zmc2V0Iiwic2NhbGUiLCJwb3MiLCJpZTNkIiwieSIsInBvaW50IiwiX2xlYWZsZXRfcG9zIiwiYW55M2QiLCJsZWZ0IiwidG9wIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiX3VzZXJTZWxlY3QiLCJvbiIsInByZXZlbnREZWZhdWx0Iiwib2ZmIiwidXNlclNlbGVjdFByb3BlcnR5IiwiX291dGxpbmVFbGVtZW50IiwiX291dGxpbmVTdHlsZSIsImVsZW1lbnQiLCJ0YWJJbmRleCIsIm91dGxpbmUiLCJKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5IiwicHJvcCIsIlBvbHltZXIiLCJQb2ludCIsInRvUG9pbnQiLCJjbG9uZSIsIl9hZGQiLCJzdWJ0cmFjdCIsIl9zdWJ0cmFjdCIsImRpdmlkZUJ5IiwiX2RpdmlkZUJ5IiwibXVsdGlwbHlCeSIsIl9tdWx0aXBseUJ5Iiwic2NhbGVCeSIsInVuc2NhbGVCeSIsIl9yb3VuZCIsImZsb29yIiwiX2Zsb29yIiwiY2VpbCIsIl9jZWlsIiwiZGlzdGFuY2VUbyIsInNxcnQiLCJlcXVhbHMiLCJhYnMiLCJpZSIsImllbHQ5IiwiYWRkRXZlbnRMaXN0ZW5lciIsImVkZ2UiLCJuYXZpZ2F0b3IiLCJ3ZWJraXQiLCJ1c2VyQWdlbnRDb250YWlucyIsImFuZHJvaWQiLCJhbmRyb2lkMjMiLCJvcGVyYSIsImNocm9tZSIsImdlY2tvIiwic2FmYXJpIiwicGhhbnRvbSIsIm9wZXJhMTIiLCJ3aW4iLCJwbGF0Zm9ybSIsIndlYmtpdDNkIiwiV2ViS2l0Q1NTTWF0cml4IiwiZ2Vja28zZCIsIkxfRElTQUJMRV8zRCIsIm1vYmlsZSIsIm9yaWVudGF0aW9uIiwibW9iaWxlV2Via2l0IiwibW9iaWxlV2Via2l0M2QiLCJtc1BvaW50ZXIiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsInBvaW50ZXIiLCJ0b3VjaCIsIkxfTk9fVE9VQ0giLCJEb2N1bWVudFRvdWNoIiwibW9iaWxlT3BlcmEiLCJtb2JpbGVHZWNrbyIsInJldGluYSIsImRldmljZVBpeGVsUmF0aW8iLCJzY3JlZW4iLCJkZXZpY2VYRFBJIiwibG9naWNhbFhEUEkiLCJjYW52YXMiLCJnZXRDb250ZXh0Iiwic3ZnIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlU1ZHUmVjdCIsInZtbCIsImRpdiIsImlubmVySFRNTCIsInNoYXBlIiwiYmVoYXZpb3IiLCJhZGoiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsInN0b3BQcm9wYWdhdGlvbiIsImRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsImRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwic3RvcCIsImdldE1vdXNlUG9zaXRpb24iLCJnZXRXaGVlbERlbHRhIiwiZmFrZVN0b3AiLCJza2lwcGVkIiwiaXNFeHRlcm5hbFRhcmdldCIsInR5cGVzIiwidHlwZSIsImFkZE9uZSIsImV2ZW50c0tleSIsInJlbW92ZU9uZSIsImhhbmRsZXIiLCJldmVudCIsIm9yaWdpbmFsSGFuZGxlciIsImZpbHRlckNsaWNrIiwiYXR0YWNoRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJvcmlnaW5hbEV2ZW50IiwiX3N0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJyZXR1cm5WYWx1ZSIsImNsaWVudFgiLCJjbGllbnRZIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJ3aGVlbFB4RmFjdG9yIiwid2hlZWxEZWx0YVkiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJkZWx0YVgiLCJkZWx0YVoiLCJ3aGVlbERlbHRhIiwiZGV0YWlsIiwic2tpcEV2ZW50cyIsImV2ZW50cyIsInJlbGF0ZWQiLCJyZWxhdGVkVGFyZ2V0IiwiZXJyIiwibGFzdENsaWNrIiwidGltZVN0YW1wIiwiZWxhcHNlZCIsInRhcmdldCIsIl9zaW11bGF0ZWRDbGljayIsIl9zaW11bGF0ZWQiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiQmFzZSIsIkhUTUxFbGVtZW50IiwiY3JlYXRlTWFwIiwiRG9tVXRpbCIsIk1hcCIsImNycyIsImNlbnRlciIsInpvb20iLCJtaW5ab29tIiwibWF4Wm9vbSIsImxheWVycyIsIm1heEJvdW5kcyIsInJlbmRlcmVyIiwiem9vbUFuaW1hdGlvbiIsInpvb21BbmltYXRpb25UaHJlc2hvbGQiLCJmYWRlQW5pbWF0aW9uIiwibWFya2VyWm9vbUFuaW1hdGlvbiIsInRyYW5zZm9ybTNETGltaXQiLCJ6b29tU25hcCIsInpvb21EZWx0YSIsInRyYWNrUmVzaXplIiwiaW5pdGlhbGl6ZSIsIl9pbml0Q29udGFpbmVyIiwiX2luaXRMYXlvdXQiLCJfb25SZXNpemUiLCJfaW5pdEV2ZW50cyIsInNldE1heEJvdW5kcyIsIl96b29tIiwiX2xpbWl0Wm9vbSIsInNldFZpZXciLCJyZXNldCIsIl9oYW5kbGVycyIsIl9sYXllcnMiLCJfem9vbUJvdW5kTGF5ZXJzIiwiX3NpemVDaGFuZ2VkIiwiY2FsbEluaXRIb29rcyIsIl96b29tQW5pbWF0ZWQiLCJfY3JlYXRlQW5pbVByb3h5IiwiX3Byb3h5IiwiX2NhdGNoVHJhbnNpdGlvbkVuZCIsIl9hZGRMYXllcnMiLCJfbGltaXRDZW50ZXIiLCJfc3RvcCIsIl9sb2FkZWQiLCJhbmltYXRlIiwicGFuIiwiZHVyYXRpb24iLCJtb3ZlZCIsIl90cnlBbmltYXRlZFpvb20iLCJfdHJ5QW5pbWF0ZWRQYW4iLCJfc2l6ZVRpbWVyIiwiX3Jlc2V0VmlldyIsInNldFpvb20iLCJnZXRDZW50ZXIiLCJ6b29tSW4iLCJkZWx0YSIsInpvb21PdXQiLCJzZXRab29tQXJvdW5kIiwibGF0bG5nIiwiZ2V0Wm9vbVNjYWxlIiwidmlld0hhbGYiLCJnZXRTaXplIiwiY29udGFpbmVyUG9pbnQiLCJsYXRMbmdUb0NvbnRhaW5lclBvaW50IiwiY2VudGVyT2Zmc2V0IiwibmV3Q2VudGVyIiwiY29udGFpbmVyUG9pbnRUb0xhdExuZyIsIl9nZXRCb3VuZHNDZW50ZXJab29tIiwiYm91bmRzIiwiZ2V0Qm91bmRzIiwicGFkZGluZ1RMIiwicGFkZGluZ1RvcExlZnQiLCJwYWRkaW5nIiwicGFkZGluZ0JSIiwicGFkZGluZ0JvdHRvbVJpZ2h0IiwiZ2V0Qm91bmRzWm9vbSIsIkluZmluaXR5IiwicGFkZGluZ09mZnNldCIsInN3UG9pbnQiLCJwcm9qZWN0IiwiZ2V0U291dGhXZXN0IiwibmVQb2ludCIsImdldE5vcnRoRWFzdCIsInVucHJvamVjdCIsImZpdEJvdW5kcyIsImlzVmFsaWQiLCJmaXRXb3JsZCIsInBhblRvIiwicGFuQnkiLCJmaXJlIiwiZ2V0Wm9vbSIsIl9wYW5BbmltIiwiX29uUGFuVHJhbnNpdGlvblN0ZXAiLCJfb25QYW5UcmFuc2l0aW9uRW5kIiwibm9Nb3ZlU3RhcnQiLCJfbWFwUGFuZSIsIm5ld1BvcyIsIl9nZXRNYXBQYW5lUG9zIiwicnVuIiwiZWFzZUxpbmVhcml0eSIsIl9yYXdQYW5CeSIsImZseVRvIiwidGFyZ2V0Q2VudGVyIiwidGFyZ2V0Wm9vbSIsImZyb20iLCJ0byIsInNpemUiLCJzdGFydFpvb20iLCJ3MCIsIncxIiwidTEiLCJyaG8iLCJyaG8yIiwiciIsInMxIiwiczIiLCJ0MSIsImIxIiwiYiIsInNxIiwibG9nIiwic2luaCIsIm4iLCJleHAiLCJjb3NoIiwidGFuaCIsInIwIiwidyIsInMiLCJ1IiwiZWFzZU91dCIsInQiLCJzdGFydCIsIm5vdyIsIlMiLCJmcmFtZSIsIl9mbHlUb0ZyYW1lIiwiX21vdmUiLCJnZXRTY2FsZVpvb20iLCJfbW92ZUVuZCIsIl9tb3ZlU3RhcnQiLCJmbHlUb0JvdW5kcyIsIl9wYW5JbnNpZGVNYXhCb3VuZHMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInBhbkluc2lkZUJvdW5kcyIsIl9lbmZvcmNpbmdCb3VuZHMiLCJpbnZhbGlkYXRlU2l6ZSIsIm9sZFNpemUiLCJfbGFzdENlbnRlciIsIm5ld1NpemUiLCJvbGRDZW50ZXIiLCJkZWJvdW5jZU1vdmVlbmQiLCJsb2NhdGUiLCJfbG9jYXRlT3B0aW9ucyIsInRpbWVvdXQiLCJ3YXRjaCIsIl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJvblJlc3BvbnNlIiwiX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UiLCJvbkVycm9yIiwiX2xvY2F0aW9uV2F0Y2hJZCIsImdlb2xvY2F0aW9uIiwid2F0Y2hQb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsInN0b3BMb2NhdGUiLCJjbGVhcldhdGNoIiwiZXJyb3IiLCJjIiwibGF0IiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsbmciLCJsb25naXR1ZGUiLCJ0b0JvdW5kcyIsImFjY3VyYWN5IiwidGltZXN0YW1wIiwiYWRkSGFuZGxlciIsIkhhbmRsZXJDbGFzcyIsImVuYWJsZSIsIl9jb250YWluZXJJZCIsIl9jb250YWluZXIiLCJfY2xlYXJDb250cm9sUG9zIiwiX2NsZWFySGFuZGxlcnMiLCJfcGFuZXMiLCJfcmVuZGVyZXIiLCJjcmVhdGVQYW5lIiwicGFuZSIsIl9jaGVja0lmTG9hZGVkIiwiX21vdmVkIiwibGF5ZXJQb2ludFRvTGF0TG5nIiwiX2dldENlbnRlckxheWVyUG9pbnQiLCJnZXRQaXhlbEJvdW5kcyIsInN3IiwiZ2V0Qm90dG9tTGVmdCIsIm5lIiwiZ2V0VG9wUmlnaHQiLCJnZXRNaW5ab29tIiwiX2xheWVyc01pblpvb20iLCJnZXRNYXhab29tIiwiX2xheWVyc01heFpvb20iLCJpbnNpZGUiLCJudyIsImdldE5vcnRoV2VzdCIsInNlIiwiZ2V0U291dGhFYXN0IiwiYm91bmRzU2l6ZSIsInNuYXAiLCJzY2FsZXgiLCJzY2FsZXkiLCJfc2l6ZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidG9wTGVmdFBvaW50IiwiX2dldFRvcExlZnRQb2ludCIsImdldFBpeGVsT3JpZ2luIiwiX3BpeGVsT3JpZ2luIiwiZ2V0UGl4ZWxXb3JsZEJvdW5kcyIsImdldFByb2plY3RlZEJvdW5kcyIsImdldFBhbmUiLCJnZXRQYW5lcyIsImdldENvbnRhaW5lciIsInRvWm9vbSIsImZyb21ab29tIiwiaXNOYU4iLCJsYXRMbmdUb1BvaW50IiwicG9pbnRUb0xhdExuZyIsInByb2plY3RlZFBvaW50IiwibGF0TG5nVG9MYXllclBvaW50Iiwid3JhcExhdExuZyIsIndyYXBMYXRMbmdCb3VuZHMiLCJkaXN0YW5jZSIsImxhdGxuZzEiLCJsYXRsbmcyIiwiY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQiLCJsYXllclBvaW50VG9Db250YWluZXJQb2ludCIsImxheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsIm1vdXNlRXZlbnRUb0xheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXRMbmciLCJfb25TY3JvbGwiLCJfZmFkZUFuaW1hdGVkIiwicG9zaXRpb24iLCJfaW5pdFBhbmVzIiwiX2luaXRDb250cm9sUG9zIiwicGFuZXMiLCJfcGFuZVJlbmRlcmVycyIsIm1hcmtlclBhbmUiLCJzaGFkb3dQYW5lIiwibG9hZGluZyIsInpvb21DaGFuZ2VkIiwiX2dldE5ld1BpeGVsT3JpZ2luIiwicGluY2giLCJfZ2V0Wm9vbVNwYW4iLCJfdGFyZ2V0cyIsIm9uT2ZmIiwiX2hhbmRsZURPTUV2ZW50IiwiX29uTW92ZUVuZCIsIl9yZXNpemVSZXF1ZXN0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIl9maW5kRXZlbnRUYXJnZXRzIiwidGFyZ2V0cyIsImlzSG92ZXIiLCJzcmNFbGVtZW50IiwiZHJhZ2dpbmciLCJfZHJhZ2dhYmxlTW92ZWQiLCJsaXN0ZW5zIiwiX2ZpcmVET01FdmVudCIsIl9tb3VzZUV2ZW50cyIsInN5bnRoIiwiaXNNYXJrZXIiLCJnZXRMYXRMbmciLCJidWJibGluZ01vdXNlRXZlbnRzIiwiZW5hYmxlZCIsImJveFpvb20iLCJkaXNhYmxlIiwid2hlblJlYWR5IiwiY2FsbGJhY2siLCJwaXhlbE9yaWdpbiIsIl9sYXRMbmdUb05ld0xheWVyUG9pbnQiLCJ0b3BMZWZ0IiwiX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJfZ2V0Q2VudGVyT2Zmc2V0IiwiY2VudGVyUG9pbnQiLCJ2aWV3Qm91bmRzIiwiX2dldEJvdW5kc09mZnNldCIsIl9saW1pdE9mZnNldCIsIm5ld0JvdW5kcyIsInB4Qm91bmRzIiwicHJvamVjdGVkTWF4Qm91bmRzIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiZHgiLCJfcmVib3VuZCIsImR5IiwicmlnaHQiLCJwcm94eSIsIm1hcFBhbmUiLCJ0cmFuc2Zvcm0iLCJfYW5pbWF0aW5nWm9vbSIsIl9vblpvb21UcmFuc2l0aW9uRW5kIiwieiIsIl9vbiIsIl9kZXN0cm95QW5pbVByb3h5IiwicHJvcGVydHlOYW1lIiwiX25vdGhpbmdUb0FuaW1hdGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiX2FuaW1hdGVab29tIiwic3RhcnRBbmltIiwibm9VcGRhdGUiLCJfYW5pbWF0ZVRvQ2VudGVyIiwiX2FuaW1hdGVUb1pvb20iLCJCb3VuZHMiLCJhIiwicG9pbnRzIiwiZ2V0VG9wTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiaW50ZXJzZWN0cyIsIm1pbjIiLCJtYXgyIiwieEludGVyc2VjdHMiLCJ5SW50ZXJzZWN0cyIsIm92ZXJsYXBzIiwieE92ZXJsYXBzIiwieU92ZXJsYXBzIiwiTGF0TG5nIiwidG9MYXRMbmciLCJhbHQiLCJtYXhNYXJnaW4iLCJtYXJnaW4iLCJwcmVjaXNpb24iLCJvdGhlciIsIndyYXAiLCJzaXplSW5NZXRlcnMiLCJsYXRBY2N1cmFjeSIsImxuZ0FjY3VyYWN5IiwiY29zIiwiUEkiLCJsb24iLCJMYXRMbmdCb3VuZHMiLCJ0b0xhdExuZ0JvdW5kcyIsImNvcm5lcjEiLCJjb3JuZXIyIiwibGF0bG5ncyIsIl9zb3V0aFdlc3QiLCJfbm9ydGhFYXN0Iiwic3cyIiwibmUyIiwicGFkIiwiYnVmZmVyUmF0aW8iLCJoZWlnaHRCdWZmZXIiLCJ3aWR0aEJ1ZmZlciIsImdldE5vcnRoIiwiZ2V0V2VzdCIsImdldFNvdXRoIiwiZ2V0RWFzdCIsImxhdEludGVyc2VjdHMiLCJsbmdJbnRlcnNlY3RzIiwibGF0T3ZlcmxhcHMiLCJsbmdPdmVybGFwcyIsInRvQkJveFN0cmluZyIsIkVsZW1lbnQiLCJMYXllciIsImF0dHJpYnV0aW9uIiwiYWRkVG8iLCJtYXAiLCJhZGRMYXllciIsInJlbW92ZUZyb20iLCJfbWFwIiwiX21hcFRvQWRkIiwicmVtb3ZlTGF5ZXIiLCJhZGRJbnRlcmFjdGl2ZVRhcmdldCIsInRhcmdldEVsIiwicmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQiLCJnZXRBdHRyaWJ1dGlvbiIsIl9sYXllckFkZCIsImhhc0xheWVyIiwiZ2V0RXZlbnRzIiwib25jZSIsIm9uQWRkIiwiYXR0cmlidXRpb25Db250cm9sIiwiYWRkQXR0cmlidXRpb24iLCJsYXllciIsImluY2x1ZGUiLCJiZWZvcmVBZGQiLCJvblJlbW92ZSIsInJlbW92ZUF0dHJpYnV0aW9uIiwiZWFjaExheWVyIiwibWV0aG9kIiwiX2FkZFpvb21MaW1pdCIsIl91cGRhdGVab29tTGV2ZWxzIiwiX3JlbW92ZVpvb21MaW1pdCIsIm9sZFpvb21TcGFuIiwiZGVkdXBlSWQiLCJNaXhpbkZ1bmN0aW9uIiwiX19taXhpbkFwcGxpY2F0aW9ucyIsIl9fbWl4aW5TZXQiLCJkZWR1cGluZ01peGluIiwibWl4aW4iLCJtaXhpbkFwcGxpY2F0aW9ucyIsIldlYWtNYXAiLCJtaXhpbkRlZHVwZUlkIiwiYmFzZSIsImJhc2VTZXQiLCJleHRlbmRlZCIsInNldCIsIm1peGluU2V0IiwiSGFuZGxlciIsIl9lbmFibGVkIiwiYWRkSG9va3MiLCJyZW1vdmVIb29rcyIsIkFzeW5jSW50ZXJmYWNlIiwibWljcm90YXNrQ3VyckhhbmRsZSIsIm1pY3JvdGFza0xhc3RIYW5kbGUiLCJtaWNyb3Rhc2tDYWxsYmFja3MiLCJtaWNyb3Rhc2tOb2RlQ29udGVudCIsIm1pY3JvdGFza05vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtaWNyb3Rhc2tGbHVzaCIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwiY2IiLCJzcGxpY2UiLCJ0aW1lT3V0IiwiYWZ0ZXIiLCJkZWxheSIsImNhbmNlbCIsImFuaW1hdGlvbkZyYW1lIiwiaWRsZVBlcmlvZCIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYW5kbGUiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJtaWNyb1Rhc2siLCJ0ZXh0Q29udGVudCIsImlkeCIsIkVhcnRoIiwid3JhcExuZyIsIlIiLCJyYWQiLCJsYXQxIiwibGF0MiIsInNpbiIsImFjb3MiLCJwIiwibm9ybWFsaXplZE1hdGNoZXNTZWxlY3RvciIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJub2RlIiwic2VsZWN0b3IiLCJEb21BcGkiLCJvYnNlcnZlckhhbmRsZSIsImRpc2Nvbm5lY3QiLCJkb2MiLCJvd25lckRvY3VtZW50IiwiaG9zdCIsImdldFJvb3ROb2RlIiwibG9jYWxOYW1lIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCJpcCQiLCJhc3NpZ25lZFNsb3QiLCJkZWVwIiwiRG9jdW1lbnQiLCJpbXBvcnROb2RlIiwiZ2V0RmxhdHRlbmVkTm9kZXMiLCJjJCIsImdldEVmZmVjdGl2ZUNoaWxkTm9kZXMiLCJsaXN0IiwibCIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsIl9hY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsImZvcndhcmRNZXRob2RzIiwibWV0aG9kcyIsImZvcndhcmRSZWFkT25seVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJmb3J3YXJkUHJvcGVydGllcyIsIkV2ZW50QXBpIiwiY29tcG9zZWRQYXRoIiwiZG9tIiwiX19kb21BcGkiLCJoZWxwZXIiLCJFdmVudCIsImZsdXNoIiwiYWRkRGVib3VuY2VyIiwiRmVhdHVyZUdyb3VwIiwiYWRkRXZlbnRQYXJlbnQiLCJyZW1vdmVFdmVudFBhcmVudCIsInNldFN0eWxlIiwiaW52b2tlIiwiYnJpbmdUb0Zyb250IiwiYnJpbmdUb0JhY2siLCJmZWF0dXJlR3JvdXAiLCJFdmVudHMiLCJfZXZlbnRzIiwiX29mZiIsInR5cGVMaXN0ZW5lcnMiLCJuZXdMaXN0ZW5lciIsImN0eCIsImxpc3RlbmVycyIsIl9maXJpbmdDb3VudCIsInByb3BhZ2F0ZSIsIl9wcm9wYWdhdGVFdmVudCIsIl9ldmVudFBhcmVudHMiLCJjbGVhckFsbEV2ZW50TGlzdGVuZXJzIiwiYWRkT25lVGltZUV2ZW50TGlzdGVuZXIiLCJmaXJlRXZlbnQiLCJoYXNFdmVudExpc3RlbmVycyIsIkV2ZW50ZWQiLCJDbGFzcyIsIk5ld0NsYXNzIiwicGFyZW50UHJvdG8iLCJfX3N1cGVyX18iLCJjb25zdHJ1Y3RvciIsInN0YXRpY3MiLCJpbmNsdWRlcyIsImNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzIiwiX2luaXRIb29rcyIsIl9pbml0SG9va3NDYWxsZWQiLCJtZXJnZU9wdGlvbnMiLCJhZGRJbml0SG9vayIsImluaXQiLCJMIiwiTWl4aW4iLCJjb25zb2xlIiwid2FybiIsInN0YWNrIiwiVHJhbnNmb3JtYXRpb24iLCJ0b1RyYW5zZm9ybWF0aW9uIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfdHJhbnNmb3JtIiwidW50cmFuc2Zvcm0iLCJDb250cm9sIiwicmVtb3ZlQ29udHJvbCIsImFkZENvbnRyb2wiLCJjb3JuZXIiLCJfY29udHJvbENvcm5lcnMiLCJfcmVmb2N1c09uTWFwIiwic2NyZWVuWCIsInNjcmVlblkiLCJmb2N1cyIsImNvbnRyb2wiLCJjb3JuZXJzIiwiX2NvbnRyb2xDb250YWluZXIiLCJjcmVhdGVDb3JuZXIiLCJ2U2lkZSIsImhTaWRlIiwiUGF0aCIsInN0cm9rZSIsImNvbG9yIiwid2VpZ2h0IiwibGluZUNhcCIsImxpbmVKb2luIiwiZGFzaEFycmF5IiwiZGFzaE9mZnNldCIsImZpbGwiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImZpbGxSdWxlIiwiaW50ZXJhY3RpdmUiLCJnZXRSZW5kZXJlciIsIl9pbml0UGF0aCIsIl9yZXNldCIsIl9hZGRQYXRoIiwiX3JlbW92ZVBhdGgiLCJyZWRyYXciLCJfdXBkYXRlUGF0aCIsIl91cGRhdGVTdHlsZSIsIl9icmluZ1RvRnJvbnQiLCJfYnJpbmdUb0JhY2siLCJnZXRFbGVtZW50IiwiX3BhdGgiLCJfcHJvamVjdCIsIl91cGRhdGUiLCJfY2xpY2tUb2xlcmFuY2UiLCJzaW1wbGlmeSIsInBvaW50VG9TZWdtZW50RGlzdGFuY2UiLCJjbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJjbGlwU2VnbWVudCIsIl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwiX2dldEJpdENvZGUiLCJfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJpc0ZsYXQiLCJfZmxhdCIsInRvbGVyYW5jZSIsInNxVG9sZXJhbmNlIiwiX3JlZHVjZVBvaW50cyIsIl9zaW1wbGlmeURQIiwicDEiLCJwMiIsIkFycmF5Q29uc3RydWN0b3IiLCJVaW50OEFycmF5IiwibWFya2VycyIsIl9zaW1wbGlmeURQU3RlcCIsIm5ld1BvaW50cyIsImZpcnN0IiwibGFzdCIsIm1heFNxRGlzdCIsImluZGV4Iiwic3FEaXN0IiwicmVkdWNlZFBvaW50cyIsInByZXYiLCJfc3FEaXN0IiwiX2xhc3RDb2RlIiwidXNlTGFzdENvZGUiLCJjb2RlQSIsImNvZGVCIiwiY29kZU91dCIsIm5ld0NvZGUiLCJkb3QiLCJDU1NfVVJMX1JYIiwiQUJTX1VSTCIsIndvcmtpbmdVUkwiLCJyZXNvbHZlRG9jIiwicmVzb2x2ZVVybCIsInVybCIsImJhc2VVUkkiLCJVUkwiLCJwYXRobmFtZSIsImhyZWYiLCJsb2NhdGlvbiIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiaGVhZCIsImFuY2hvciIsImJvZHkiLCJyZXNvbHZlQ3NzIiwiY3NzVGV4dCIsIm0iLCJwcmUiLCJwb3N0IiwicGF0aEZyb21VcmwiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImlzUGF0aCIsInJvb3QiLCJpc0FuY2VzdG9yIiwiaXNEZXNjZW5kYW50IiwidHJhbnNsYXRlIiwibm9ybWFsaXplIiwicGF0aCIsImRvdEluZGV4IiwibmV3QmFzZSIsInBhcnRzIiwiaW5mbyIsInBhcnQiLCJpc0RlZXAiLCJBc3luY01vZHVsZSIsIkRlYm91bmNlciIsIl9hc3luY01vZHVsZSIsIl9jYWxsYmFjayIsIl90aW1lciIsImFzeW5jTW9kdWxlIiwiaXNBY3RpdmUiLCJkZWJvdW5jZXIiLCJzZXRDb25maWciLCJrbGFzcyIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIiwiaXMiLCJtdXRhYmxlUHJvcGVydHlDaGFuZ2UiLCJpbnN0IiwicHJvcGVydHkiLCJvbGQiLCJtdXRhYmxlRGF0YSIsImlzT2JqZWN0IiwiX19kYXRhVGVtcCIsInNob3VsZENoYW5nZSIsIk11dGFibGVEYXRhIiwic3VwZXJDbGFzcyIsIk9wdGlvbmFsTXV0YWJsZURhdGEiLCJCb29sZWFuIiwiX211dGFibGVQcm9wZXJ0eUNoYW5nZSIsImljb24iLCJJY29uIiwiY3JlYXRlSWNvbiIsIm9sZEljb24iLCJfY3JlYXRlSWNvbiIsImNyZWF0ZVNoYWRvdyIsIl9nZXRJY29uVXJsIiwiaW1nIiwiX2NyZWF0ZUltZyIsIl9zZXRJY29uU3R5bGVzIiwic2l6ZU9wdGlvbiIsInNoYWRvd0FuY2hvciIsImljb25BbmNob3IiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwid2lkdGgiLCJoZWlnaHQiLCJSZW5kZXJlciIsIl91cGRhdGVQYXRocyIsIl9kZXN0cm95Q29udGFpbmVyIiwidmlld3Jlc2V0IiwiX29uWm9vbSIsIm1vdmVlbmQiLCJ6b29tZW5kIiwiX29uWm9vbUVuZCIsInpvb21hbmltIiwiX29uQW5pbVpvb20iLCJldiIsIl91cGRhdGVUcmFuc2Zvcm0iLCJjdXJyZW50Q2VudGVyUG9pbnQiLCJfY2VudGVyIiwiZGVzdENlbnRlclBvaW50IiwidG9wTGVmdE9mZnNldCIsIl9ib3VuZHMiLCJjaXJjbGVNYXJrZXIiLCJDaXJjbGVNYXJrZXIiLCJyYWRpdXMiLCJfbGF0bG5nIiwiX3JhZGl1cyIsInNldExhdExuZyIsInNldFJhZGl1cyIsImdldFJhZGl1cyIsIl9wb2ludCIsIl91cGRhdGVCb3VuZHMiLCJyMiIsIl9yYWRpdXNZIiwiX3B4Qm91bmRzIiwiX3VwZGF0ZUNpcmNsZSIsIl9lbXB0eSIsIl9jb250YWluc1BvaW50IiwiX3JlZ0xvZyIsInJlZ2lzdGVyIiwiZHVtcFJlZ2lzdHJhdGlvbnMiLCJjYXNlTWFwJDAiLCJFbGVtZW50TWl4aW4iLCJwb2x5bWVyRWxlbWVudEJhc2UiLCJjYXNlTWFwIiwib3duUHJvcGVydGllc0ZvckNsYXNzIiwiX19vd25Qcm9wZXJ0aWVzIiwib3duT2JzZXJ2ZXJzRm9yQ2xhc3MiLCJfX293bk9ic2VydmVycyIsIm9ic2VydmVycyIsImZsYXR0ZW5Qcm9wZXJ0aWVzIiwiZmxhdHRlbmVkUHJvcHMiLCJvIiwicHJvcGVydGllc0ZvckNsYXNzIiwiX19jbGFzc1Byb3BlcnRpZXMiLCJzdXBlckN0b3IiLCJnZXRQcm90b3R5cGVPZiIsIlBvbHltZXJFbGVtZW50IiwiYXNzaWduIiwicHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzIiwiX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMiLCJoYXNDbGFzc0ZpbmFsaXplZCIsImZpbmFsaXplQ2xhc3NBbmRTdXBlciIsImZpbmFsaXplIiwiZmluYWxpemVDbGFzcyIsIl9fZmluYWxpemVkIiwiZmluYWxpemVQcm9wZXJ0aWVzIiwiZmluYWxpemVPYnNlcnZlcnMiLCJjbG9uZU5vZGUiLCJfdGVtcGxhdGUiLCJjcmVhdGVQcm9wZXJ0eUZyb21Db25maWciLCJkeW5hbWljRm5zIiwiX2NyZWF0ZU1ldGhvZE9ic2VydmVyIiwiYWxsUHJvcHMiLCJjb21wdXRlZCIsInJlYWRPbmx5IiwiX2hhc1JlYWRPbmx5RWZmZWN0IiwiX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkiLCJfY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eSIsInJlZmxlY3RUb0F0dHJpYnV0ZSIsIl9oYXNSZWZsZWN0RWZmZWN0IiwiX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5Iiwibm90aWZ5IiwiX2hhc05vdGlmeUVmZmVjdCIsIl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eSIsIm9ic2VydmVyIiwiX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIiLCJmaW5hbGl6ZVRlbXBsYXRlIiwiZXh0IiwiY29udGVudCIsIlNoYWR5Q1NTIiwicHJlcGFyZVRlbXBsYXRlIiwiX2JpbmRUZW1wbGF0ZSIsIl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiaW1wb3J0IiwibW9kdWxlIiwiX2ltcG9ydFBhdGgiLCJhc3NldHBhdGgiLCJpbXBvcnRQYXRoIiwicm9vdFBhdGgiLCIkIiwiaW5zdGFuY2VDb3VudCIsIl9fcG9seW1lckZpbmFsaXplZCIsIl9fcHJvdG9fXyIsInAkIiwiX2hhc0FjY2Vzc29yIiwiX3NldFBlbmRpbmdQcm9wZXJ0eSIsInN0eWxlRWxlbWVudCIsIl9lbmFibGVQcm9wZXJ0aWVzIiwiX3N0YW1wVGVtcGxhdGUiLCJfYXR0YWNoRG9tIiwiYXR0YWNoU2hhZG93Iiwic2hhZG93Um9vdCIsIm1vZGUiLCJkYXNoVG9DYW1lbENhc2UiLCJfYXR0cmlidXRlVG9Qcm9wZXJ0eSIsInN0eWxlU3VidHJlZSIsInRlbXBsYXRlSW5mbyIsIm5vZGVJbmZvIiwicmVnaXN0cmF0aW9ucyIsImZvckVhY2giLCJ1cGRhdGVTdHlsZXMiLCJzdHlsZURvY3VtZW50Iiwic2V0dGluZ3MiLCJ1c2VTaGFkb3ciLCJTaGFkeURPTSIsInVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMiLCJuYXRpdmVDc3MiLCJ1c2VOYXRpdmVDdXN0b21FbGVtZW50cyIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJTZXR0aW5ncyIsInNldFJvb3RQYXRoIiwic2FuaXRpemVET01WYWx1ZSIsInNldFNhbml0aXplRE9NVmFsdWUiLCJuZXdTYW5pdGl6ZURPTVZhbHVlIiwiY2FtZWxUb0Rhc2hDYXNlIiwiREFTSF9UT19DQU1FTCIsIkNBTUVMX1RPX0RBU0giLCJkYXNoIiwiY2FtZWwiLCJDYXNlTWFwIiwiVFlQRVMiLCJDT01QVVRFIiwiUkVGTEVDVCIsIk5PVElGWSIsIlBST1BBR0FURSIsIk9CU0VSVkUiLCJSRUFEX09OTFkiLCJEYXRhVHJpZ2dlciIsIkRhdGFFZmZlY3QiLCJQcm9wZXJ0eUVmZmVjdHNUeXBlIiwiZW5zdXJlT3duRWZmZWN0TWFwIiwibW9kZWwiLCJlZmZlY3RzIiwicHJvdG9GeCIsImluc3RGeCIsInJ1bkVmZmVjdHMiLCJvbGRQcm9wcyIsImhhc1BhdGhzIiwiZXh0cmFBcmdzIiwicmFuIiwicnVuRWZmZWN0c0ZvclByb3BlcnR5Iiwicm9vdFByb3BlcnR5IiwiZnhzIiwiZngiLCJsYXN0UnVuIiwicGF0aE1hdGNoZXNUcmlnZ2VyIiwidHJpZ2dlciIsInRyaWdnZXJQYXRoIiwic3RydWN0dXJlZCIsIndpbGRjYXJkIiwicnVuT2JzZXJ2ZXJFZmZlY3QiLCJtZXRob2ROYW1lIiwiY2hhbmdlZFByb3AiLCJfX2RhdGEiLCJkeW5hbWljRm4iLCJydW5Ob3RpZnlFZmZlY3RzIiwibm90aWZ5UHJvcHMiLCJub3RpZmllZCIsIm5vdGlmeVBhdGgiLCJfX2RhdGFIb3N0IiwiX2ludmFsaWRhdGVQcm9wZXJ0aWVzIiwiZXZlbnROYW1lIiwiZGlzcGF0Y2hOb3RpZnlFdmVudCIsInF1ZXVlUHJvcGVydHkiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJydW5Ob3RpZnlFZmZlY3QiLCJoYW5kbGVOb3RpZmljYXRpb24iLCJmcm9tUHJvcCIsInRvUGF0aCIsIm5lZ2F0ZSIsImZyb21QYXRoIiwiX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCIsInJ1blJlZmxlY3RFZmZlY3QiLCJhdHRyTmFtZSIsIl9wcm9wZXJ0eVRvQXR0cmlidXRlIiwicnVuQ29tcHV0ZWRFZmZlY3RzIiwiY2hhbmdlZFByb3BzIiwiY29tcHV0ZUVmZmVjdHMiLCJpbnB1dFByb3BzIiwiX19kYXRhT2xkIiwiX19kYXRhUGVuZGluZyIsInJ1bkNvbXB1dGVkRWZmZWN0IiwicmVzdWx0IiwicnVuTWV0aG9kRWZmZWN0IiwiY29tcHV0ZWRQcm9wIiwibWV0aG9kSW5mbyIsIl9fZGF0YUhhc0FjY2Vzc29yIiwiY29tcHV0ZUxpbmtlZFBhdGhzIiwibGlua3MiLCJfX2RhdGFMaW5rZWRQYXRocyIsImxpbmsiLCJhZGRCaW5kaW5nIiwia2luZCIsImxpdGVyYWwiLCJiaW5kaW5ncyIsImJpbmRpbmciLCJpc0NvbXBvdW5kIiwic2hvdWxkQWRkTGlzdGVuZXIiLCJsaXN0ZW5lckV2ZW50IiwibGlzdGVuZXJOZWdhdGUiLCJub2RlSW5mb0xpc3QiLCJjb21wb3VuZEluZGV4IiwiYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQiLCJkZXBlbmRlbmNpZXMiLCJldmFsdWF0b3IiLCJwYXJzZUFyZyIsIl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0IiwicnVuQmluZGluZ0VmZmVjdCIsIm5vZGVMaXN0Iiwic291cmNlIiwiX2VucXVldWVDbGllbnQiLCJfZXZhbHVhdGVCaW5kaW5nIiwiYXBwbHlCaW5kaW5nVmFsdWUiLCJjb21wdXRlQmluZGluZ1ZhbHVlIiwiX3ZhbHVlVG9Ob2RlQXR0cmlidXRlIiwiX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlIiwic3RvcmFnZSIsIl9fZGF0YUNvbXBvdW5kU3RvcmFnZSIsInNldHVwQmluZGluZ3MiLCJzZXR1cENvbXBvdW5kU3RvcmFnZSIsImFkZE5vdGlmeUxpc3RlbmVyIiwibGl0ZXJhbHMiLCJjcmVhdGVNZXRob2RFZmZlY3QiLCJzaWciLCJlZmZlY3RGbiIsInN0YXRpYyIsImFyZyIsIl9hZGRQcm9wZXJ0eUVmZmVjdCIsIl9tZXRob2RIb3N0IiwibWFyc2hhbEFyZ3MiLCJlbXB0eUFycmF5IiwiSURFTlQiLCJOVU1CRVIiLCJTUVVPVEVfU1RSSU5HIiwiRFFVT1RFX1NUUklORyIsIlNUUklORyIsIkFSR1VNRU5UIiwiQVJHVU1FTlRTIiwiQVJHVU1FTlRfTElTVCIsIkJJTkRJTkciLCJPUEVOX0JSQUNLRVQiLCJDTE9TRV9CUkFDS0VUIiwiTkVHQVRFIiwiRVhQUkVTU0lPTiIsImJpbmRpbmdSZWdleCIsImxpdGVyYWxGcm9tUGFydHMiLCJwYXJzZU1ldGhvZCIsImV4cHJlc3Npb24iLCJtYXRjaCIsInBhcnNlQXJncyIsImFyZ0xpc3QiLCJyYXdBcmciLCJmYyIsIk51bWJlciIsInZhbHVlcyIsInYiLCJiYXNlQ2hhbmdlZCIsIm5vdGlmeVNwbGljZXMiLCJzcGxpY2VzIiwic3BsaWNlc1BhdGgiLCJpbmRleFNwbGljZXMiLCJub3RpZnlTcGxpY2UiLCJhZGRlZENvdW50IiwicmVtb3ZlZCIsIm9iamVjdCIsInVwcGVyIiwiUHJvcGVydHlFZmZlY3RzIiwicHJvcGVydHlFZmZlY3RzQmFzZSIsIl9fZGF0YUNsaWVudHNSZWFkeSIsIl9fZGF0YVBlbmRpbmdDbGllbnRzIiwiX19kYXRhVG9Ob3RpZnkiLCJfX2RhdGFIYXNQYXRocyIsIl9fZGF0YUNsaWVudHNJbml0aWFsaXplZCIsIl9fY29tcHV0ZUVmZmVjdHMiLCJfX3JlZmxlY3RFZmZlY3RzIiwiX19ub3RpZnlFZmZlY3RzIiwiX19wcm9wYWdhdGVFZmZlY3RzIiwiX19vYnNlcnZlRWZmZWN0cyIsIl9fcmVhZE9ubHkiLCJfX2RhdGFDb3VudGVyIiwiX190ZW1wbGF0ZUluZm8iLCJob3N0U3RhY2siLCJyZWdpc3Rlckhvc3QiLCJlZmZlY3QiLCJfY3JlYXRlUHJvcGVydHlBY2Nlc3NvciIsIl9oYXNQcm9wZXJ0eUVmZmVjdCIsInNob3VsZE5vdGlmeSIsImlzUGF0aE5vdGlmaWNhdGlvbiIsInByZXZQcm9wcyIsIl9zaG91bGRQcm9wZXJ0eUNoYW5nZSIsIl9fZGF0YVJlYWR5IiwiX2ZsdXNoUHJvcGVydGllcyIsImNsaWVudCIsIl9yZWFkeUNsaWVudHMiLCJfX2VuYWJsZU9yRmx1c2hDbGllbnRzIiwiY2xpZW50cyIsIl9fZGF0YUVuYWJsZWQiLCJzZXRSZWFkT25seSIsIl9mbHVzaENsaWVudHMiLCJjdXJyZW50UHJvcHMiLCJfcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzIiwicHJvcGVydHlFZmZlY3RzIiwibmV4dFRlbXBsYXRlSW5mbyIsIml0ZW1zIiwicmV0IiwiaGFkTGVuZ3RoIiwicG9wIiwiZGVsZXRlQ291bnQiLCJzaGlmdCIsInVuc2hpZnQiLCJwcm9wUGF0aCIsInByb3RlY3RlZFNldHRlciIsIl9zZXRQcm9wZXJ0eSIsImF0dHIiLCJpbnN0YW5jZUJpbmRpbmciLCJfcGFyc2VUZW1wbGF0ZSIsIndhc1ByZUJvdW5kIiwiX190ZW1wbGF0ZUluZm9MYXN0IiwicHJldmlvdXNUZW1wbGF0ZUluZm8iLCJiZWdpbkhvc3RpbmciLCJlbmRIb3N0aW5nIiwibm9kZXMiLCJjaGlsZE5vZGVzIiwibmV4dFNpYmxpbmciLCJob3N0UHJvcHMiLCJwcm9wRWZmZWN0cyIsIm5vdGVkIiwiVEVYVF9OT0RFIiwiX3BhcnNlQmluZGluZ3MiLCJvcmlnTmFtZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInRleHQiLCJsYXN0SW5kZXgiLCJleGVjIiwiY3VzdG9tRXZlbnQiLCJub3RpZnlFdmVudCIsImNvbG9uIiwic2lnbmF0dXJlIiwic3RhY2tMZW4iLCJuYXRpdmVTaGFkb3ciLCJuYXRpdmVDc3NWYXJpYWJsZXMiLCJjYWxjQ3NzVmFyaWFibGVzIiwiQ1NTIiwic3VwcG9ydHMiLCJwYXJzZSIsInN0cmluZ2lmeSIsInJlbW92ZUN1c3RvbVByb3BBc3NpZ25tZW50IiwiU3R5bGVOb2RlIiwiY2xlYW4iLCJwYXJzZUNzcyIsImxleCIsIlJYIiwiY29tbWVudHMiLCJwb3J0IiwiT1BFTl9CUkFDRSIsInByZXZpb3VzIiwiQ0xPU0VfQlJBQ0UiLCJzcyIsIl9leHBhbmRVbmljb2RlRXNjYXBlcyIsIm11bHRpcGxlU3BhY2VzIiwiQVRfU1RBUlQiLCJNRURJQV9TVEFSVCIsIk1FRElBX1JVTEUiLCJrZXlmcmFtZXNSdWxlIiwiS0VZRlJBTUVTX1JVTEUiLCJWQVJfU1RBUlQiLCJNSVhJTl9SVUxFIiwiU1RZTEVfUlVMRSIsInIkIiwicmVwZWF0IiwicHJlc2VydmVQcm9wZXJ0aWVzIiwiX2hhc01peGluUnVsZXMiLCJyZW1vdmVDdXN0b21Qcm9wcyIsInJ1bGVzIiwicmVtb3ZlQ3VzdG9tUHJvcEFwcGx5IiwiY3VzdG9tUHJvcCIsIm1peGluUHJvcCIsIm1peGluQXBwbHkiLCJ2YXJBcHBseSIsIlZBUl9BU1NJR04iLCJNSVhJTl9NQVRDSCIsIlZBUl9DT05TVU1FRCIsIkFOSU1BVElPTl9NQVRDSCIsIk1FRElBX01BVENIIiwiSVNfVkFSIiwiQlJBQ0tFVEVEIiwiSE9TVF9QUkVGSVgiLCJIT1NUX1NVRkZJWCIsInVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJkZXRlY3RNaXhpbiIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaGFzIiwiZGVlcFRhcmdldEZpbmQiLCJfZmluZE9yaWdpbmFsVGFyZ2V0IiwiX2hhbmRsZU5hdGl2ZSIsIl9oYW5kbGVUb3VjaEFjdGlvbiIsIl9yZW1vdmUiLCJfZmluZFJlY29nbml6ZXJCeUV2ZW50Iiwic2V0VG91Y2hBY3Rpb24iLCJyZXNldE1vdXNlQ2FuY2VsbGVyIiwiSEFTX05BVElWRV9UQSIsInRvdWNoQWN0aW9uIiwiR0VTVFVSRV9LRVkiLCJIQU5ETEVEX09CSiIsIlRPVUNIX0FDVElPTiIsIlRBUF9ESVNUQU5DRSIsIlRSQUNLX0RJU1RBTkNFIiwiVFJBQ0tfTEVOR1RIIiwiTU9VU0VfVElNRU9VVCIsIk1PVVNFX0VWRU5UUyIsIk1PVVNFX1dISUNIX1RPX0JVVFRPTlMiLCJNT1VTRV9IQVNfQlVUVE9OUyIsIk1vdXNlRXZlbnQiLCJidXR0b25zIiwiU1VQUE9SVFNfUEFTU0lWRSIsIm9wdHMiLCJJU19UT1VDSF9PTkxZIiwiR2VzdHVyZVJlY29nbml6ZXIiLCJtb3VzZWRvd24iLCJtb3VzZW1vdmUiLCJtb3VzZXVwIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwiY2xpY2siLCJtb3VzZUNhbmNlbGxlciIsIm1vdXNlRXZlbnQiLCJzYyIsInNvdXJjZUNhcGFiaWxpdGllcyIsImZpcmVzVG91Y2hFdmVudHMiLCJza2lwIiwiUE9JTlRFUlNUQVRFIiwibW91c2UiLCJzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIiLCJzZXR1cCIsImVuIiwiaWdub3JlTW91c2UiLCJtb3VzZUlnbm9yZUpvYiIsInVuc2V0IiwiZGVib3VuY2UiLCJoYXNMZWZ0TW91c2VCdXR0b24iLCJ3aGljaCIsImJ1dHRvbiIsImlzU3ludGhldGljQ2xpY2siLCJiY3IiLCJwYWdlWCIsInBhZ2VZIiwiYm90dG9tIiwic2Nyb2xsRGVjaWRlZCIsImZpcnN0VG91Y2hBY3Rpb24iLCJ0YSIsInRyYWNrRG9jdW1lbnQiLCJzdGF0ZU9iaiIsIm1vdmVmbiIsInVwZm4iLCJ1bnRyYWNrRG9jdW1lbnQiLCJwYXNzaXZlIiwiZ2VzdHVyZXMiLCJyZWNvZ25pemVycyIsImVsZW1lbnRGcm9tUG9pbnQiLCJuZXh0Iiwib2xkTmV4dCIsImhhbmRsZWQiLCJjdXJyZW50VGFyZ2V0IiwiZ29iaiIsImdzIiwiY2hhbmdlZFRvdWNoZXMiLCJ0b3VjaGVzIiwiaWRlbnRpZmllciIsImZsb3ciLCJwcmV2ZW50IiwiY2FuY2VsYWJsZSIsImV2VHlwZSIsInJlY29nbml6ZXIiLCJkZXBzIiwiZGVwIiwiZ2QiLCJfY291bnQiLCJyZWNvZyIsImVtaXRzIiwiZXZOYW1lIiwiX2ZpcmUiLCJidWJibGVzIiwiY29tcG9zZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicHJldmVudGVyIiwic291cmNlRXZlbnQiLCJlbmQiLCJzZWxmIiwic3RhdGUiLCJzdGFydGVkIiwibW92ZXMiLCJhZGRNb3ZlIiwibW92ZSIsImhhc01vdmVkRW5vdWdoIiwiY3QiLCJzZWNvbmRsYXN0IiwibGFzdG1vdmUiLCJkZHgiLCJkZHkiLCJob3ZlciIsIk5hTiIsInNhdmUiLCJmb3J3YXJkIiwiZmluZE9yaWdpbmFsVGFyZ2V0IiwiZGVib3VuY2VyUXVldWUiLCJlbnF1ZXVlRGVib3VuY2VyIiwiZmx1c2hEZWJvdW5jZXJzIiwiZGlkRmx1c2giLCJzaGFkeURPTSIsImRlYm91bmNlcnMiLCJTY29waW5nU2hpbSIsIm5ld0luc3RhbmNlIiwiSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbiIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJ3cml0YWJsZSIsIkRhdGFUZW1wbGF0ZSIsIk11dGFibGVEYXRhVGVtcGxhdGUiLCJ1cGdyYWRlVGVtcGxhdGUiLCJzZXRQcm90b3R5cGVPZiIsIlRlbXBsYXRlSW5zdGFuY2VCYXNlIiwiX2NvbmZpZ3VyZVByb3BlcnRpZXMiLCJjaGlsZHJlbiIsIl9fdGVtcGxhdGl6ZUluc3RhbmNlIiwiX190ZW1wbGF0aXplT3duZXIiLCJfX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18iLCJfc2hvd0hpZGVDaGlsZHJlbiIsIl9fdGVtcGxhdGl6ZU9wdGlvbnMiLCJpbnN0YW5jZVByb3BzIiwiaXByb3AiLCJocHJvcCIsIl9faG9zdFByb3BzIiwicGFyZW50TW9kZWwiLCJfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZSIsInRlbXBsYXRlSG9zdCIsImhpZGUiLCJfX3BvbHltZXJUZXh0Q29udGVudF9fIiwiX19wb2x5bWVyRGlzcGxheV9fIiwiZGlzcGxheSIsIl9fcGFyZW50TW9kZWwiLCJNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UiLCJmaW5kTWV0aG9kSG9zdCIsImNyZWF0ZVRlbXBsYXRpemVyQ2xhc3MiLCJhZGROb3RpZnlFZmZlY3RzIiwiYWRkUHJvcGFnYXRlRWZmZWN0cyIsInVzZXJGb3J3YXJkSG9zdFByb3AiLCJmb3J3YXJkSG9zdFByb3AiLCJ0ZW1wbGF0aXplVGVtcGxhdGVDbGFzcyIsIlBST1BFUlRZX0VGRkVDVF9UWVBFUyIsImNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdCIsIl9fZGF0YVByb3RvIiwiaG9zdFByb3AiLCJ1c2VyTm90aWZ5SW5zdGFuY2VQcm9wIiwibm90aWZ5SW5zdGFuY2VQcm9wIiwiY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0IiwiY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QiLCJpbnN0UHJvcCIsIm5vdGlmeUhvc3RQcm9wIiwiVGVtcGxhdGl6ZSIsInRlbXBsYXRpemUiLCJvd25lciIsImJhc2VDbGFzcyIsInRlbXBsYXRpemVJbnN0YW5jZUNsYXNzIiwibW9kZWxGb3JFbGVtZW50IiwiZG9tUmVwZWF0QmFzZSIsIkRvbVJlcGVhdCIsImFzIiwiU3RyaW5nIiwiaW5kZXhBcyIsIml0ZW1zSW5kZXhBcyIsInNvcnQiLCJGdW5jdGlvbiIsInJlbmRlcmVkSXRlbUNvdW50IiwiaW5pdGlhbENvdW50IiwidGFyZ2V0RnJhbWVyYXRlIiwiX3RhcmdldEZyYW1lVGltZSIsIl9faW5zdGFuY2VzIiwiX19saW1pdCIsIl9fcG9vbCIsIl9fcmVuZGVyRGVib3VuY2VyIiwiX19pdGVtc0lkeFRvSW5zdElkeCIsIl9fY2h1bmtDb3VudCIsIl9fbGFzdENodW5rVGltZSIsIl9fc29ydEZuIiwiX19maWx0ZXJGbiIsIl9fb2JzZXJ2ZVBhdGhzIiwiX19jdG9yIiwiX19pc0RldGFjaGVkIiwiX19kZXRhY2hJbnN0YW5jZSIsIl9fYXR0YWNoSW5zdGFuY2UiLCJxdWVyeVNlbGVjdG9yIiwiX19yZW5kZXIiLCJjaGlsZExpc3QiLCJpJCIsIm1ldGhvZEhvc3QiLCJfX2dldE1ldGhvZEhvc3QiLCJfX2RlYm91bmNlUmVuZGVyIiwicmF0ZSIsInBlcmZvcm1hbmNlIiwiX19yZXF1ZXN0UmVuZGVyQ2h1bmsiLCJfX3JlbmRlckNodW5rIiwiY3VyckNodW5rVGltZSIsInJhdGlvIiwiY2hhbmdlIiwiX19oYW5kbGVJdGVtUGF0aCIsIl9faW5pdGlhbGl6ZUNodW5raW5nIiwicGF0aHMiLCJfX2Vuc3VyZVRlbXBsYXRpemVkIiwiX19hcHBseUZ1bGxSZWZyZXNoIiwiX3NldFJlbmRlcmVkSXRlbUNvdW50IiwiX190cnlSZW5kZXJDaHVuayIsImlzbnRJZHhUb0l0ZW1zSWR4IiwiaXRlbXNJZHhUb0luc3RJZHgiLCJpbnN0SWR4IiwibGltaXQiLCJpdGVtSWR4IiwiX19pbnNlcnRJbnN0YW5jZSIsIl9fZGV0YWNoQW5kUmVtb3ZlSW5zdGFuY2UiLCJfX3N0YW1wSW5zdGFuY2UiLCJiZWZvcmVSb3ciLCJiZWZvcmVOb2RlIiwiaGlkZGVuIiwiaXRlbXNQYXRoIiwiaXRlbXNJZHgiLCJwYXJzZUludCIsIml0ZW1TdWJQYXRoIiwiX19oYW5kbGVPYnNlcnZlZFBhdGhzIiwiaXRlbVBhdGgiLCJpbnN0YW5jZSIsIlBhcGVyUmlwcGxlQmVoYXZpb3IiLCJub2luayIsIl9yaXBwbGVDb250YWluZXIiLCJfYnV0dG9uU3RhdGVDaGFuZ2VkIiwiZm9jdXNlZCIsImVuc3VyZVJpcHBsZSIsIl9kb3duSGFuZGxlciIsInByZXNzZWQiLCJvcHRUcmlnZ2VyaW5nRXZlbnQiLCJoYXNSaXBwbGUiLCJfcmlwcGxlIiwiX2NyZWF0ZVJpcHBsZSIsInJpcHBsZUNvbnRhaW5lciIsImRvbUNvbnRhaW5lciIsInJvb3RUYXJnZXQiLCJkZWVwQ29udGFpbnMiLCJ1aURvd25BY3Rpb24iLCJnZXRSaXBwbGUiLCJfbm9pbmtDaGFuZ2VkIiwiTGF5ZXJHcm91cCIsImdldExheWVySWQiLCJjbGVhckxheWVycyIsImdldExheWVyIiwiZ2V0TGF5ZXJzIiwic2V0WkluZGV4IiwiekluZGV4IiwibGF5ZXJHcm91cCIsIkNSUyIsInByb2plY3Rpb24iLCJ0cmFuc2Zvcm1hdGlvbiIsInVudHJhbnNmb3JtZWRQb2ludCIsIkxOMiIsImluZmluaXRlIiwid3JhcExhdCIsImxhdFNoaWZ0IiwibG5nU2hpZnQiLCJuZXdTdyIsIm5ld05lIiwibWFya2VyIiwiTWFya2VyIiwiZHJhZ2dhYmxlIiwia2V5Ym9hcmQiLCJ0aXRsZSIsInpJbmRleE9mZnNldCIsInJpc2VPbkhvdmVyIiwicmlzZU9mZnNldCIsIl9pbml0SWNvbiIsInVwZGF0ZSIsIl9yZW1vdmVJY29uIiwiX3JlbW92ZVNoYWRvdyIsIm9sZExhdExuZyIsInNldFpJbmRleE9mZnNldCIsInNldEljb24iLCJfcG9wdXAiLCJiaW5kUG9wdXAiLCJfaWNvbiIsIl9zZXRQb3MiLCJjbGFzc1RvQWRkIiwiYWRkSWNvbiIsIm1vdXNlb3ZlciIsIm1vdXNlb3V0IiwiX3Jlc2V0WkluZGV4IiwibmV3U2hhZG93IiwiX3NoYWRvdyIsImFkZFNoYWRvdyIsIl91cGRhdGVPcGFjaXR5IiwiX2luaXRJbnRlcmFjdGlvbiIsIl96SW5kZXgiLCJfdXBkYXRlWkluZGV4Iiwib3B0IiwiX2dldFBvcHVwQW5jaG9yIiwicG9wdXBBbmNob3IiLCJfZ2V0VG9vbHRpcEFuY2hvciIsInRvb2x0aXBBbmNob3IiLCJTVEFSVCIsIkVORCIsInBvaW50ZXJkb3duIiwiTVNQb2ludGVyRG93biIsIk1PVkUiLCJEcmFnZ2FibGUiLCJjbGlja1RvbGVyYW5jZSIsImRyYWdTdGFydFRhcmdldCIsIl9lbGVtZW50IiwiX2RyYWdTdGFydFRhcmdldCIsIl9wcmV2ZW50T3V0bGluZSIsIl9vbkRvd24iLCJfZHJhZ2dpbmciLCJmaW5pc2hEcmFnIiwic2hpZnRLZXkiLCJfbW92aW5nIiwiX3N0YXJ0UG9pbnQiLCJfb25Nb3ZlIiwiX29uVXAiLCJuZXdQb2ludCIsIl9zdGFydFBvcyIsIl9sYXN0VGFyZ2V0IiwiU1ZHRWxlbWVudEluc3RhbmNlIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJfbmV3UG9zIiwiX2FuaW1SZXF1ZXN0IiwiX2xhc3RFdmVudCIsIl91cGRhdGVQb3NpdGlvbiIsIkltYWdlT3ZlcmxheSIsImNyb3NzT3JpZ2luIiwiZXJyb3JPdmVybGF5VXJsIiwiX3VybCIsIl9pbWFnZSIsIl9pbml0SW1hZ2UiLCJzdHlsZU9wdHMiLCJzZXRVcmwiLCJzZXRCb3VuZHMiLCJvbnNlbGVjdHN0YXJ0Iiwib25tb3VzZW1vdmUiLCJvbmxvYWQiLCJvbmVycm9yIiwiX292ZXJsYXlPbkVycm9yIiwiaW1hZ2UiLCJlcnJvclVybCIsImltYWdlT3ZlcmxheSIsIkRpdk92ZXJsYXkiLCJfc291cmNlIiwiX3JlbW92ZVRpbWVvdXQiLCJfYWRqdXN0UGFuIiwiZ2V0Q29udGVudCIsIl9jb250ZW50Iiwic2V0Q29udGVudCIsInZpc2liaWxpdHkiLCJfdXBkYXRlQ29udGVudCIsIl91cGRhdGVMYXlvdXQiLCJpc09wZW4iLCJfY29udGVudE5vZGUiLCJoYXNDaGlsZE5vZGVzIiwiX2dldEFuY2hvciIsIl9jb250YWluZXJCb3R0b20iLCJfY29udGFpbmVyTGVmdCIsIl9jb250YWluZXJXaWR0aCIsInRpbGVMYXllciIsIlRpbGVMYXllciIsInN1YmRvbWFpbnMiLCJlcnJvclRpbGVVcmwiLCJ6b29tT2Zmc2V0IiwidG1zIiwiem9vbVJldmVyc2UiLCJkZXRlY3RSZXRpbmEiLCJ0aWxlU2l6ZSIsIl9vblRpbGVSZW1vdmUiLCJub1JlZHJhdyIsImNyZWF0ZVRpbGUiLCJkb25lIiwidGlsZSIsIl90aWxlT25Mb2FkIiwiX3RpbGVPbkVycm9yIiwiZ2V0VGlsZVVybCIsIl9nZXRTdWJkb21haW4iLCJfZ2V0Wm9vbUZvclVybCIsImludmVydGVkWSIsIl9nbG9iYWxUaWxlUmFuZ2UiLCJfdGlsZVpvb20iLCJ0aWxlUG9pbnQiLCJfYWJvcnRMb2FkaW5nIiwiX3RpbGVzIiwiY29tcGxldGUiLCJ0aWxlTGF5ZXJXTVMiLCJUaWxlTGF5ZXJXTVMiLCJkZWZhdWx0V21zUGFyYW1zIiwic2VydmljZSIsInJlcXVlc3QiLCJzdHlsZXMiLCJmb3JtYXQiLCJ0cmFuc3BhcmVudCIsInZlcnNpb24iLCJ3bXNQYXJhbXMiLCJfY3JzIiwiX3dtc1ZlcnNpb24iLCJwYXJzZUZsb2F0IiwicHJvamVjdGlvbktleSIsInRpbGVCb3VuZHMiLCJfdGlsZUNvb3Jkc1RvQm91bmRzIiwiYmJveCIsInNldFBhcmFtcyIsIkVQU0c0MzI2IiwiTG9uTGF0IiwicG9seWxpbmUiLCJMaW5lVXRpbCIsIlBvbHlsaW5lIiwic21vb3RoRmFjdG9yIiwibm9DbGlwIiwiX3NldExhdExuZ3MiLCJnZXRMYXRMbmdzIiwiX2xhdGxuZ3MiLCJzZXRMYXRMbmdzIiwiaXNFbXB0eSIsImNsb3Nlc3RMYXllclBvaW50IiwibWluRGlzdGFuY2UiLCJtaW5Qb2ludCIsImNsb3Nlc3QiLCJqTGVuIiwiX3BhcnRzIiwiaGFsZkRpc3QiLCJzZWdEaXN0IiwiZGlzdCIsIl9yaW5ncyIsImFkZExhdExuZyIsIl9kZWZhdWx0U2hhcGUiLCJfY29udmVydExhdExuZ3MiLCJmbGF0IiwiX3Byb2plY3RMYXRsbmdzIiwicHJvamVjdGVkQm91bmRzIiwicmluZyIsIl9jbGlwUG9pbnRzIiwiayIsImxlbjIiLCJzZWdtZW50IiwiX3NpbXBsaWZ5UG9pbnRzIiwiX3VwZGF0ZVBvbHkiLCJjbG9zZWQiLCJwb2x5Z29uIiwiUG9seVV0aWwiLCJQb2x5Z29uIiwiZiIsImFyZWEiLCJjbGlwcGVkIiwiY2xpcFBvbHlnb24iLCJjc3NGcm9tTW9kdWxlcyIsImNzc0Zyb21Nb2R1bGUiLCJjc3NGcm9tVGVtcGxhdGUiLCJjc3NGcm9tTW9kdWxlSW1wb3J0cyIsIl9jc3NGcm9tTW9kdWxlSW1wb3J0cyIsIk1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SIiwiSU5DTFVERV9BVFRSIiwiaW1wb3J0TW9kdWxlIiwibW9kdWxlSWQiLCJQb2x5bWVyRG9tTW9kdWxlIiwidGVtcGxhdGVXaXRoQXNzZXRQYXRoIiwibW9kdWxlSWRzIiwibW9kdWxlcyIsIl9jc3NUZXh0IiwiZSQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0QXR0cmlidXRlIiwiaW1wb3J0RG9jIiwibGNNb2R1bGVzIiwiZmluZE1vZHVsZSIsInN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2siLCJEb21Nb2R1bGUiLCJfX2Fzc2V0cGF0aCIsIkhUTUxJbXBvcnRzIiwiaW1wb3J0Rm9yRWxlbWVudCIsInN0eWxlSW50ZXJmYWNlIiwiTGVnYWN5RWxlbWVudE1peGluIiwibGVnYWN5RWxlbWVudEJhc2UiLCJESVJFQ1RJT05fTUFQIiwiTGVnYWN5RWxlbWVudCIsImlzQXR0YWNoZWQiLCJfX2JvdW5kTGlzdGVuZXJzIiwiX2RlYm91bmNlcnMiLCJjcmVhdGVkIiwiYXR0YWNoZWQiLCJkZXRhY2hlZCIsImF0dHJpYnV0ZUNoYW5nZWQiLCJfX2hhc1JlZ2lzdGVyRmluaXNoZWQiLCJfcmVnaXN0ZXJlZCIsIl9lbnN1cmVBdHRyaWJ1dGVzIiwiX2FwcGx5TGlzdGVuZXJzIiwiX3NlcmlhbGl6ZVZhbHVlIiwiX2Rlc2VyaWFsaXplVmFsdWUiLCJhdHRyaWJ1dGUiLCJhcGkiLCJuJCIsImdldE93blByb3BlcnR5TmFtZXMiLCJwZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9jb250ZW50Rm9yVGVtcGxhdGUiLCJoYmwiLCJibCIsIl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlIiwiX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZSIsImRpcmVjdGlvbiIsInNsY3RyIiwicXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzIiwiY24iLCJ0YyIsIkNPTU1FTlRfTk9ERSIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJnZXRDb250ZW50Q2hpbGROb2RlcyIsInNob3VsZE9ic2VydmUiLCJqb2JOYW1lIiwid2FpdCIsIndhaXRUaW1lIiwidGFnIiwiZWx0Iiwic2V0UHJvcGVydGllcyIsIm9wdEFzeW5jIiwibG9hZEZuIiwiZXJyb3JGbiIsImJvb2wiLCJoYXNBdHRyaWJ1dGUiLCJ0cmFuc2Zvcm1UZXh0Iiwid2Via2l0VHJhbnNmb3JtIiwiYXJyYXlPclBhdGgiLCJhcnIiLCJsZXZlbCIsIl9sb2dnZXIiLCJEb2N1bWVudEZyYWdtZW50IiwidG9Dc3NUZXh0IiwicnVsZXNGb3JTdHlsZSIsImlzS2V5ZnJhbWVzU2VsZWN0b3IiLCJmb3JFYWNoUnVsZSIsImFwcGx5Q3NzIiwiY3JlYXRlU2NvcGVTdHlsZSIsImFwcGx5U3R5bGVQbGFjZUhvbGRlciIsImFwcGx5U3R5bGUiLCJpc1RhcmdldGVkQnVpbGQiLCJnZXRDc3NCdWlsZFR5cGUiLCJwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayIsInNldEVsZW1lbnRDbGFzc1JhdyIsImdldElzRXh0ZW5kcyIsInJ1bGUiLCJzdHlsZVJ1bGVDYWxsYmFjayIsImtleWZyYW1lc1J1bGVDYWxsYmFjayIsIm9ubHlBY3RpdmVSdWxlcyIsInNraXBSdWxlcyIsIm1hdGNoTWVkaWEiLCJtb25pa2VyIiwiY29udGV4dE5vZGUiLCJsYXN0SGVhZEFwcGx5Tm9kZSIsInBsYWNlSG9sZGVyIiwiY3JlYXRlQ29tbWVudCIsInNjb3BlIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJidWlsZFR5cGUiLCJmaW5kTWF0Y2hpbmdQYXJlbiIsImlubmVyIiwicHJlZml4Iiwic3VmZml4IiwiY29tbWEiLCJmYWxsYmFjayIsInR5cGVFeHRlbnNpb24iLCJleHRlbmRzIiwidGVtcGxhdGVNYXAiLCJkb2N1bWVudFdhaXQiLCJyZWFkeVByb21pc2UiLCJyZXNvbHZlRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWR5U3RhdGUiLCJ0aGVuIiwiQ3VzdG9tU3R5bGVQcm92aWRlciIsIlNFRU5fTUFSS0VSIiwiQ0FDSEVEX1NUWUxFIiwidHJhbnNmb3JtRm4iLCJ2YWxpZGF0ZUZuIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJlbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uIiwiY3VzdG9tU3R5bGUiLCJjcyIsImdldFN0eWxlRm9yQ3VzdG9tU3R5bGUiLCJzdHlsZVRvVHJhbnNmb3JtIiwiYWRkQ3VzdG9tU3R5bGUiLCJwcm9jZXNzU3R5bGVzIiwiZGVmaW5lUHJvcGVydGllcyIsIm5lZWRzRW5xdWV1ZSIsIkN1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlIiwiZ2VzdHVyZXMkMCIsIkdlc3R1cmVFdmVudExpc3RlbmVycyIsImJlZm9yZU5leHRSZW5kZXIiLCJhZnRlck5leHRSZW5kZXIiLCJzY2hlZHVsZWQiLCJiZWZvcmVSZW5kZXJRdWV1ZSIsImFmdGVyUmVuZGVyUXVldWUiLCJzY2hlZHVsZSIsImZsdXNoUXVldWUiLCJydW5RdWV1ZSIsInF1ZXVlIiwiY2FsbE1ldGhvZCIsImlzU2xvdCIsIkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIiLCJyZWR1Y2UiLCJfc2hhZHlDaGlsZHJlbk9ic2VydmVyIiwiX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIiLCJfY29ubmVjdGVkIiwiX3RhcmdldCIsIl9lZmZlY3RpdmVOb2RlcyIsIl9vYnNlcnZlciIsIl9zY2hlZHVsZWQiLCJfYm91bmRTY2hlZHVsZSIsIl9zY2hlZHVsZSIsImNvbm5lY3QiLCJfbGlzdGVuU2xvdHMiLCJvYnNlcnZlQ2hpbGRyZW4iLCJtdXRhdGlvbnMiLCJfcHJvY2Vzc011dGF0aW9ucyIsIl91bmxpc3RlblNsb3RzIiwidW5vYnNlcnZlQ2hpbGRyZW4iLCJfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMiLCJtdXRhdGlvbiIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJ0YWtlUmVjb3JkcyIsIm5ld05vZGVzIiwibmV3U3BsaWNlIiwiRURJVF9MRUFWRSIsIkVESVRfVVBEQVRFIiwiRURJVF9BREQiLCJFRElUX0RFTEVURSIsImNhbGNFZGl0RGlzdGFuY2VzIiwiY3VycmVudCIsImN1cnJlbnRTdGFydCIsImN1cnJlbnRFbmQiLCJvbGRTdGFydCIsIm9sZEVuZCIsInJvd0NvdW50IiwiY29sdW1uQ291bnQiLCJkaXN0YW5jZXMiLCJub3J0aCIsIndlc3QiLCJzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMiLCJlZGl0cyIsIm5vcnRoV2VzdCIsInJldmVyc2UiLCJjYWxjU3BsaWNlcyIsInByZWZpeENvdW50Iiwic3VmZml4Q291bnQiLCJtaW5MZW5ndGgiLCJzaGFyZWRQcmVmaXgiLCJzaGFyZWRTdWZmaXgiLCJvcHMiLCJvbGRJbmRleCIsInNlYXJjaExlbmd0aCIsImluZGV4MSIsImluZGV4MiIsImNvdW50IiwiY2FsY3VsYXRlU3BsaWNlcyIsImN1cnJlbnRWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCIkX2RvY3VtZW50Q29udGFpbmVyIiwiSXJvbkJ1dHRvblN0YXRlSW1wbCIsInRvZ2dsZXMiLCJhY3RpdmUiLCJwb2ludGVyRG93biIsInJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQiLCJhcmlhQWN0aXZlQXR0cmlidXRlIiwiZG93biIsInVwIiwidGFwIiwia2V5QmluZGluZ3MiLCJfbW91c2VFdmVudFJlIiwiX3RhcEhhbmRsZXIiLCJfdXNlckFjdGl2YXRlIiwiX2ZvY3VzQ2hhbmdlZCIsIl9kZXRlY3RLZXlib2FyZEZvY3VzIiwiX3NldFByZXNzZWQiLCJfc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCIsIl9zZXRQb2ludGVyRG93biIsIl91cEhhbmRsZXIiLCJfc3BhY2VLZXlEb3duSGFuZGxlciIsImtleWJvYXJkRXZlbnQiLCJsb2NhbFRhcmdldCIsImlzTGlnaHREZXNjZW5kYW50Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiX3NwYWNlS2V5VXBIYW5kbGVyIiwiX2FzeW5jQ2xpY2siLCJhc3luYyIsIl9wcmVzc2VkQ2hhbmdlZCIsIl9jaGFuZ2VkQnV0dG9uU3RhdGUiLCJfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQiLCJvbGRWYWx1ZSIsIl9hY3RpdmVDaGFuZ2VkIiwiX2NvbnRyb2xTdGF0ZUNoYW5nZWQiLCJkaXNhYmxlZCIsIklyb25CdXR0b25TdGF0ZSIsIktFWV9JREVOVElGSUVSIiwiS0VZX0NPREUiLCJNT0RJRklFUl9LRVlTIiwiS0VZX0NIQVIiLCJJREVOVF9DSEFSIiwiQVJST1dfS0VZIiwiU1BBQ0VfS0VZIiwiRVNDX0tFWSIsInRyYW5zZm9ybUtleSIsIm5vU3BlY2lhbENoYXJzIiwidmFsaWRLZXkiLCJsS2V5IiwidHJhbnNmb3JtS2V5SWRlbnRpZmllciIsImtleUlkZW50IiwiZnJvbUNoYXJDb2RlIiwidHJhbnNmb3JtS2V5Q29kZSIsImtleUNvZGUiLCJub3JtYWxpemVkS2V5Rm9yRXZlbnQiLCJrZXlFdmVudCIsImtleUlkZW50aWZpZXIiLCJrZXlDb21ib01hdGNoZXNFdmVudCIsImtleUNvbWJvIiwiaGFzTW9kaWZpZXJzIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJwYXJzZUtleUNvbWJvU3RyaW5nIiwia2V5Q29tYm9TdHJpbmciLCJjb21ibyIsInBhcnNlZEtleUNvbWJvIiwia2V5Q29tYm9QYXJ0IiwiZXZlbnRQYXJ0cyIsImtleU5hbWUiLCJwYXJzZUV2ZW50U3RyaW5nIiwiZXZlbnRTdHJpbmciLCJJcm9uQTExeUtleXNCZWhhdmlvciIsImtleUV2ZW50VGFyZ2V0Iiwic3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbiIsIl9ib3VuZEtleUhhbmRsZXJzIiwiX2ltcGVyYXRpdmVLZXlCaW5kaW5ncyIsInJlZ2lzdGVyZWQiLCJfcHJlcEtleUJpbmRpbmdzIiwiX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzIiwiX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMiLCJhZGRPd25LZXlCaW5kaW5nIiwiaGFuZGxlck5hbWUiLCJfcmVzZXRLZXlFdmVudExpc3RlbmVycyIsInJlbW92ZU93bktleUJpbmRpbmdzIiwia2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzIiwia2V5Q29tYm9zIiwiX2NvbGxlY3RLZXlCaW5kaW5ncyIsImJlaGF2aW9ycyIsIl9rZXlCaW5kaW5ncyIsIl9hZGRLZXlCaW5kaW5nIiwia2IxIiwia2IyIiwiYjIiLCJrZXlzIiwiYm91bmRLZXlIYW5kbGVyIiwiX29uS2V5QmluZGluZ0V2ZW50Iiwia2V5SGFuZGxlclR1cGxlIiwiX3RyaWdnZXJLZXlIYW5kbGVyIiwiSXJvbkNvbnRyb2xTdGF0ZSIsIl9vbGRUYWJJbmRleCIsIl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIiLCJfZm9jdXNCbHVySGFuZGxlciIsIl9faGFuZGxlRXZlbnRSZXRhcmdldGluZyIsInJlYWR5IiwiX3NldEZvY3VzZWQiLCJfZGlzYWJsZWRDaGFuZ2VkIiwicG9pbnRlckV2ZW50cyIsImJsdXIiLCJfY2hhbmdlZENvbnRyb2xTdGF0ZSIsIkVQU0czODU3IiwiRVBTRzkwMDkxMyIsIlNwaGVyaWNhbE1lcmNhdG9yIiwiTUFYX0xBVElUVURFIiwiYXRhbiIsInN2Z0NyZWF0ZSIsInBvaW50c1RvUGF0aCIsInJpbmdzIiwiYWRkUG9pbnRlckxpc3RlbmVyIiwicmVtb3ZlUG9pbnRlckxpc3RlbmVyIiwiUE9JTlRFUl9ET1dOIiwiUE9JTlRFUl9NT1ZFIiwiUE9JTlRFUl9VUCIsIlBPSU5URVJfQ0FOQ0VMIiwiVEFHX1dISVRFX0xJU1QiLCJfcG9pbnRlcnMiLCJfcG9pbnRlckRvY0xpc3RlbmVyIiwiX3BvaW50ZXJzQ291bnQiLCJfYWRkUG9pbnRlclN0YXJ0IiwiX2FkZFBvaW50ZXJNb3ZlIiwiX2FkZFBvaW50ZXJFbmQiLCJvbkRvd24iLCJwb2ludGVyVHlwZSIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwiX2hhbmRsZVBvaW50ZXIiLCJfZ2xvYmFsUG9pbnRlckRvd24iLCJfZ2xvYmFsUG9pbnRlck1vdmUiLCJfZ2xvYmFsUG9pbnRlclVwIiwicG9pbnRlcklkIiwib25Nb3ZlIiwib25VcCIsIlBvc0FuaW1hdGlvbiIsIl9lbCIsIl9pblByb2dyZXNzIiwiX2R1cmF0aW9uIiwiX2Vhc2VPdXRQb3dlciIsIl9vZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2FuaW1hdGUiLCJfc3RlcCIsIl9jb21wbGV0ZSIsIl9hbmltSWQiLCJfcnVuRnJhbWUiLCJfZWFzZU91dCIsInByb2dyZXNzIiwiSWNvbkRlZmF1bHQiLCJpY29uVXJsIiwiaWNvblJldGluYVVybCIsInNoYWRvd1VybCIsImljb25TaXplIiwic2hhZG93U2l6ZSIsImltYWdlUGF0aCIsIl9kZXRlY3RJY29uUGF0aCIsIkJveFpvb20iLCJEb3VibGVDbGlja1pvb20iLCJEcmFnIiwiS2V5Ym9hcmQiLCJTY3JvbGxXaGVlbFpvb20iLCJUYXAiLCJUb3VjaFpvb20iLCJBdHRyaWJ1dGlvbiIsIl9hdHRyaWJ1dGlvbnMiLCJzZXRQcmVmaXgiLCJhdHRyaWJzIiwicHJlZml4QW5kQXR0cmlicyIsIkxheWVycyIsIlpvb20iLCJTY2FsZSIsIlZpZGVvT3ZlcmxheSIsInZpZGVvT3ZlcmxheSIsIlBvcHVwIiwicG9wdXAiLCJUb29sdGlwIiwidG9vbHRpcCIsImdlb21ldHJ5VG9MYXllciIsImNvb3Jkc1RvTGF0TG5nIiwiY29vcmRzVG9MYXRMbmdzIiwibGF0TG5nVG9Db29yZHMiLCJsYXRMbmdzVG9Db29yZHMiLCJnZXRGZWF0dXJlIiwiYXNGZWF0dXJlIiwiR2VvSlNPTiIsImdlb0pTT04iLCJnZW9Kc29uIiwiZ3JpZExheWVyIiwiR3JpZExheWVyIiwidXBkYXRlV2hlbklkbGUiLCJ1cGRhdGVXaGVuWm9vbWluZyIsInVwZGF0ZUludGVydmFsIiwibWF4TmF0aXZlWm9vbSIsIm1pbk5hdGl2ZVpvb20iLCJub1dyYXAiLCJrZWVwQnVmZmVyIiwiX2xldmVscyIsIl9yZW1vdmVBbGxUaWxlcyIsIl9zZXRBdXRvWkluZGV4IiwiaXNMb2FkaW5nIiwiX2xvYWRpbmciLCJ2aWV3cHJlcmVzZXQiLCJfaW52YWxpZGF0ZUFsbCIsImdldFRpbGVTaXplIiwiY29tcGFyZSIsImVkZ2VaSW5kZXgiLCJpc0Zpbml0ZSIsIm5leHRGcmFtZSIsIndpbGxQcnVuZSIsImxvYWRlZCIsImZhZGUiLCJfb25PcGFxdWVUaWxlIiwiX25vUHJ1bmUiLCJfcHJ1bmVUaWxlcyIsIl9mYWRlRnJhbWUiLCJfdXBkYXRlTGV2ZWxzIiwiX29uVXBkYXRlTGV2ZWwiLCJfcmVtb3ZlVGlsZXNBdFpvb20iLCJfb25SZW1vdmVMZXZlbCIsIm9yaWdpbiIsIl9zZXRab29tVHJhbnNmb3JtIiwib2Zmc2V0V2lkdGgiLCJfb25DcmVhdGVMZXZlbCIsIl9sZXZlbCIsInJldGFpbiIsIl9yZXRhaW5QYXJlbnQiLCJfcmV0YWluQ2hpbGRyZW4iLCJfcmVtb3ZlVGlsZSIsIngyIiwieTIiLCJ6MiIsImNvb3JkczIiLCJfdGlsZUNvb3Jkc1RvS2V5IiwiYW5pbWF0aW5nIiwiX3NldFZpZXciLCJfY2xhbXBab29tIiwibm9QcnVuZSIsInRpbGVab29tIiwidGlsZVpvb21DaGFuZ2VkIiwiX3Jlc2V0R3JpZCIsIl9zZXRab29tVHJhbnNmb3JtcyIsIl90aWxlU2l6ZSIsIl9weEJvdW5kc1RvVGlsZVJhbmdlIiwiX3dyYXBYIiwiX3dyYXBZIiwiX2dldFRpbGVkUGl4ZWxCb3VuZHMiLCJtYXBab29tIiwicGl4ZWxDZW50ZXIiLCJoYWxmU2l6ZSIsInBpeGVsQm91bmRzIiwidGlsZVJhbmdlIiwidGlsZUNlbnRlciIsIm5vUHJ1bmVSYW5nZSIsIl9pc1ZhbGlkVGlsZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIl9hZGRUaWxlIiwiX2tleVRvQm91bmRzIiwiX2tleVRvVGlsZUNvb3JkcyIsIm53UG9pbnQiLCJzZVBvaW50IiwiX2luaXRUaWxlIiwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IiwidGlsZVBvcyIsIl9nZXRUaWxlUG9zIiwiX3dyYXBDb29yZHMiLCJfdGlsZVJlYWR5IiwiX25vVGlsZXNUb0xvYWQiLCJuZXdDb29yZHMiLCJDYW52YXMiLCJfb25WaWV3UHJlUmVzZXQiLCJfcG9zdHBvbmVVcGRhdGVQYXRocyIsIl9kcmF3IiwiX29uTW91c2VNb3ZlIiwiX29uQ2xpY2siLCJfaGFuZGxlTW91c2VPdXQiLCJfY3R4IiwiX3JlZHJhd0JvdW5kcyIsIl9yZWRyYXciLCJfZHJhd25MYXllcnMiLCJfdXBkYXRlRGFzaEFycmF5Iiwib3JkZXIiLCJfb3JkZXIiLCJfZHJhd0xhc3QiLCJfZHJhd0ZpcnN0IiwiX3JlcXVlc3RSZWRyYXciLCJfZXh0ZW5kUmVkcmF3Qm91bmRzIiwiX2Rhc2hBcnJheSIsIl9yZWRyYXdSZXF1ZXN0IiwiX2NsZWFyIiwiY2xlYXJSZWN0IiwiYmVnaW5QYXRoIiwiY2xpcCIsIl9kcmF3aW5nIiwicmVzdG9yZSIsImNsb3NlUGF0aCIsIl9maWxsU3Ryb2tlIiwiYXJjIiwiZ2xvYmFsQWxwaGEiLCJmaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiY2xpY2tlZExheWVyIiwiX2ZpcmVFdmVudCIsIm1vdmluZyIsIl9oYW5kbGVNb3VzZUhvdmVyIiwiX2hvdmVyZWRMYXllciIsImNhbmRpZGF0ZUhvdmVyZWRMYXllciIsImNpcmNsZSIsIkNpcmNsZSIsImxlZ2FjeU9wdGlvbnMiLCJfbVJhZGl1cyIsImhhbGYiLCJsYXRSIiwibG5nUiIsImNsaXBwZWRQb2ludHMiLCJlZGdlcyIsIl9jb2RlIiwiU1ZHIiwiem9vbXN0YXJ0IiwiX29uWm9vbVN0YXJ0IiwiX3Jvb3RHcm91cCIsIl9zdmdTaXplIiwiX3NldFBhdGgiLCJnZW9qc29uIiwiYWRkRGF0YSIsImZlYXR1cmVzIiwiZmVhdHVyZSIsImdlb21ldHJpZXMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwiZGVmYXVsdE9wdGlvbnMiLCJyZXNldFN0eWxlIiwib25FYWNoRmVhdHVyZSIsIl9zZXRMYXllclN0eWxlIiwicG9pbnRUb0xheWVyIiwiX2Nvb3Jkc1RvTGF0TG5nIiwibGV2ZWxzRGVlcCIsIm5ld0dlb21ldHJ5IiwiUG9pbnRUb0dlb0pTT04iLCJ0b0dlb0pTT04iLCJtdWx0aSIsImhvbGVzIiwidG9NdWx0aVBvaW50IiwiaXNHZW9tZXRyeUNvbGxlY3Rpb24iLCJqc29ucyIsImpzb24iLCJNZXJjYXRvciIsIlJfTUlOT1IiLCJ0bXAiLCJjb24iLCJ0cyIsInRhbiIsInBoaSIsImRwaGkiLCJ5YW1sIiwicmVxdWlyZSIsIkdHTWFwVmlld2VyIiwiY29uZmlnIiwiYmFzZVNvdXJjZSIsImJhc2VGb3JtYXQiLCJzZWxlY3RlZE92ZXJsYXkiLCJ3bXNHcm91cHMiLCJnZW9qc29uTGF5ZXJzIiwiYmFzZU1hcHMiLCJvdmVybGF5TWFwcyIsInNlYXJjaE1hcmtlcnMiLCJfbWFya2Vyc0dyb3VwIiwiZmV0Y2giLCJpbml0aWFsaXplTWFwIiwiaW5pdGlhbGl6ZVNlYXJjaCIsInJlc3BvbnNlIiwicmpzb24iLCJzYWZlTG9hZCIsImZsYXR0ZW5lZExheWVycyIsImludGVyYWN0aW9uIiwidmlzaWJsZSIsIndtc0RlZmF1bHRTb3VyY2UiLCJfc2VsZWN0ZWRCYXNlbWFwIiwiYmFzZUxheWVycyIsIm92ZXJsYXlTZWxlY3QiLCJqUXVlcnkiLCJhdXRvY29tcGxldGUiLCJwcmV2ZW50QmFkUXVlcmllcyIsImRlZmVyUmVxdWVzdEJ5IiwibWluQ2hhcnMiLCJzZXJ2aWNlVXJsIiwicGFyYW1OYW1lIiwidHJhbnNmb3JtUmVzdWx0IiwiYWRkcmVzc2VzIiwiSlNPTiIsInN1Z2dlc3Rpb25zIiwiYWRkcmVzcyIsIm9uU2VhcmNoU3RhcnQiLCJvblNlYXJjaENvbXBsZXRlIiwicSIsIm9uU2VsZWN0IiwiY3VyclZpc2libGUiLCJleGNsdXNpdmVzIiwiX3BhcnNlTGF5ZXJzIiwicmVzZXRWaWV3T25TZWxlY3QiLCJpbml0aWFsQ2VudGVyIiwiaW5pdGlhbFpvb20iLCJiYWNrZ3JvdW5kSW1hZ2UiLCJsYXllcnNNZW51IiwidG9nZ2xlIiwib3ZlcmxheSIsIndtc0xheWVycyIsIm1hY2hpbmVOYW1lIiwibWFya2Vyc0Nvb3JkcyIsInNlbGVjdGVkIiwibmV3T3ZlcmxheSIsImRlZmF1bHRDbGFzcyIsImRvd25sb2FkVVJMIiwiaHRtbCIsIm1vZGFsIiwibWljcm90YXNrIiwibmF0aXZlUHJvcGVydGllcyIsInNhdmVBY2Nlc3NvclZhbHVlIiwiUHJvcGVydHlBY2Nlc3NvcnMiLCJhJCIsIm9ic2VydmVkQXR0cmlidXRlcyIsIl9fc2VyaWFsaXppbmciLCJfX2RhdGFJbnZhbGlkIiwiX19kYXRhSW5zdGFuY2VQcm9wcyIsIl9pbml0aWFsaXplUHJvcGVydGllcyIsIl9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzIiwib3V0VmFsdWUiLCJjaGFuZ2VkIiwiX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMiLCJfcHJvcGVydGllc0NoYW5nZWQiLCJ0ZW1wbGF0ZUV4dGVuc2lvbnMiLCJ3cmFwVGVtcGxhdGVFeHRlbnNpb24iLCJyZXBsYWNlQ2hpbGQiLCJhdHRyaWJ1dGVzIiwiZmluZFRlbXBsYXRlTm9kZSIsInBhcmVudEluZm8iLCJwYXJlbnRJbmRleCIsImFwcGx5SWRUb01hcCIsImFwcGx5RXZlbnRMaXN0ZW5lciIsImFwcGx5VGVtcGxhdGVDb250ZW50IiwiX3RlbXBsYXRlSW5mbyIsImNyZWF0ZU5vZGVFdmVudEhhbmRsZXIiLCJUZW1wbGF0ZVN0YW1wIiwiZGVjb3JhdGUiLCJfX25vSW5zZXJ0aW9uUG9pbnQiLCJoYXNJbnNlcnRpb25Qb2ludCIsIm91dGVyVGVtcGxhdGVJbmZvIiwic3RyaXBXaGl0ZVNwYWNlIiwiX3BhcnNlVGVtcGxhdGVDb250ZW50IiwiX3BhcnNlVGVtcGxhdGVOb2RlIiwiX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZSIsIl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyIsImhhc0F0dHJpYnV0ZXMiLCJfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzIiwiY2hpbGRJbmZvIiwiaW5mb0luZGV4IiwiYXR0cnMiLCJfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUiLCJob3N0QXR0cmlidXRlcyIsInJvbGUiLCJ0YWJpbmRleCIsInRyYWNrIiwiX29udHJhY2siLCJfdHJhY2tTdGFydCIsIl90cmFja01vdmUiLCJfdHJhY2tFbmQiLCJfd2lkdGgiLCJ0b2dnbGVCYXIiLCJfdHJhY2tDaGVja2VkIiwiY2hlY2tlZCIsInRvZ2dsZUJ1dHRvbiIsIl94IiwidHJhbnNsYXRlM2QiLCJyaXBwbGUiLCJBcHBseVNoaW1VdGlscyIsImFwcGx5U2hpbSIsIkFwcGx5U2hpbUludGVyZmFjZSIsImN1c3RvbVN0eWxlSW50ZXJmYWNlIiwiZW5zdXJlIiwiaW52YWxpZGF0ZSIsInRyYW5zZm9ybUN1c3RvbVN0eWxlIiwiZmx1c2hDdXN0b21TdHlsZXMiLCJlbGVtZW50TmFtZSIsImFzdCIsInRyYW5zZm9ybVRlbXBsYXRlIiwic2hhZG93Q2hpbGRyZW4iLCJ0ZW1wbGF0ZUlzVmFsaWQiLCJ0ZW1wbGF0ZUlzVmFsaWRhdGluZyIsInN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlIiwiYXBwbHlTaGltSW50ZXJmYWNlIiwiZWxlbWVudEV4dGVuZHMiLCJBcHBseVNoaW0iLCJBUFBMWV9OQU1FX0NMRUFOIiwiSU5JVElBTF9JTkhFUklUIiwiTUlYSU5fVkFSX1NFUCIsIlByb3BlcnR5RW50cnkiLCJEZXBlbmRhbnRzRW50cnkiLCJNaXhpbk1hcEVudHJ5IiwiTWl4aW5NYXAiLCJkZXBlbmRhbnRzIiwiaW52YWxpZENhbGxiYWNrIiwiX2N1cnJlbnRFbGVtZW50IiwiX21lYXN1cmVFbGVtZW50IiwidHJhbnNmb3JtU3R5bGUiLCJ0cmFuc2Zvcm1SdWxlcyIsInRyYW5zZm9ybVJ1bGUiLCJ0cmFuc2Zvcm1Dc3NUZXh0IiwibWF0Y2hUZXh0IiwidmFsdWVQcm9wZXJ0eSIsInZhbHVlTWl4aW4iLCJfcHJvZHVjZUNzc1Byb3BlcnRpZXMiLCJfY29uc3VtZUNzc1Byb3BlcnRpZXMiLCJhbGwiLCJtaXhpbk5hbWUiLCJhcHBseVBvcyIsImFmdGVyQXBwbHlQb3MiLCJ0ZXh0QmVmb3JlQXBwbHkiLCJ0ZXh0QWZ0ZXJBcHBseSIsImRlZmF1bHRzIiwiX2Nzc1RleHRUb01hcCIsInJlcGxhY2VtZW50IiwiX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMiLCJmYWxsYmFja3MiLCJ2YXJzIiwibWl4aW5FbnRyeSIsIl9nZXRJbml0aWFsVmFsdWVGb3JQcm9wZXJ0eSIsIm91dCIsInNwIiwiX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0IiwibWl4aW5Bc1Byb3BlcnRpZXMiLCJtaXhpblZhbHVlcyIsImNvbWJpbmVkUHJvcHMiLCJuZWVkVG9JbnZhbGlkYXRlIiwiX2ludmFsaWRhdGVNaXhpbkVudHJ5IiwiaW52YWxpZGF0ZVRlbXBsYXRlIiwiaXNWYWxpZGF0aW5nIiwic3RhcnRWYWxpZGF0aW5nIiwiZWxlbWVudHNBcmVJbnZhbGlkIiwiQ1VSUkVOVF9WRVJTSU9OIiwiTkVYVF9WRVJTSU9OIiwiVkFMSURBVElOR19WRVJTSU9OIiwicHJvbWlzZSIsIl92YWxpZGF0aW5nIiwid2hlbkltcG9ydHNSZWFkeSIsImltcG9ydEhyZWYiLCJyZWwiLCJjbGVhbnVwIiwibG9hZExpc3RlbmVyIiwiZXJyb3JMaXN0ZW5lciIsIl9fZHluYW1pY0ltcG9ydExvYWRlZCIsIm1ldGFQcm9wcyIsImJlZm9yZVJlZ2lzdGVyIiwibWl4aW5CZWhhdmlvcnMiLCJzdXBlckJlaGF2aW9ycyIsImZsYXR0ZW5CZWhhdmlvcnMiLCJfbWl4aW5CZWhhdmlvcnMiLCJHZW5lcmF0ZUNsYXNzRnJvbUluZm8iLCJleGNsdWRlIiwiUG9seW1lckdlbmVyYXRlZCIsIl9lbnN1cmVBdHRyaWJ1dGUiLCJnZW5lcmF0ZWRGcm9tIiwiVGVtcGxhdGl6ZXJVc2VyIiwiVGVtcGxhdGl6ZXIiLCJfdGVtcGxhdGl6ZXJUZW1wbGF0ZSIsImN0b3IiLCJfcGFyZW50TW9kZWwiLCJfaW5zdGFuY2VQcm9wcyIsIl9mb3J3YXJkSG9zdFByb3BWMiIsIl9ub3RpZnlJbnN0YW5jZVByb3BWMiIsImRvbUJpbmRCYXNlIiwiRG9tQmluZCIsIl9fY2hpbGRyZW4iLCJyZW5kZXIiLCJfX3JlbW92ZUNoaWxkcmVuIiwiX19pbnNlcnRDaGlsZHJlbiIsIkRvbUlmIiwiaWYiLCJyZXN0YW1wIiwiX19pbnZhbGlkUHJvcHMiLCJfX2luc3RhbmNlIiwiX2xhc3RJZiIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJfX3RlYXJkb3duSW5zdGFuY2UiLCJfX2Vuc3VyZUluc3RhbmNlIiwiX19zeW5jSG9zdFByb3BlcnRpZXMiLCJwcmV2aW91c1NpYmxpbmciLCJBcnJheVNlbGVjdG9yTWl4aW4iLCJlbGVtZW50QmFzZSIsInNlbGVjdGVkSXRlbSIsIl9fbGFzdEl0ZW1zIiwiX19sYXN0TXVsdGkiLCJfX3NlbGVjdGVkTWFwIiwiaXRlbXNJbmZvIiwibmV3SXRlbXMiLCJsYXN0SXRlbXMiLCJsYXN0TXVsdGkiLCJjbGVhclNlbGVjdGlvbiIsIl9fYXBwbHlTcGxpY2VzIiwiX19kZXNlbGVjdENoYW5nZWRJZHgiLCJfX3VwZGF0ZUxpbmtzIiwic2lkeCIsImRlbGV0ZSIsImxpbmtQYXRocyIsImlzU2VsZWN0ZWQiLCJfX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgiLCJkZXNlbGVjdCIsInNlbGVjdEluZGV4IiwiY2xlYXIiLCJkZXNlbGVjdEluZGV4IiwiYmFzZUFycmF5U2VsZWN0b3IiLCJBcnJheVNlbGVjdG9yIiwiQ3VzdG9tU3R5bGUiLCJfc3R5bGUiLCJNdXRhYmxlRGF0YUJlaGF2aW9yIiwiT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yIiwiUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCIsIl9jaGVja2VkQ2hhbmdlZCIsIlBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciIsIklyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCIsIl9oYXNJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciIsIl9nZXRWYWxpZGl0eSIsIl92YWx1ZSIsInJlcXVpcmVkIiwiX3JlcXVpcmVkQ2hhbmdlZCIsIl92YWx1ZUNoYW5nZWQiLCJJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciIsIklyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSIsIklyb25WYWxpZGF0YWJsZUJlaGF2aW9yIiwidmFsaWRhdG9yIiwiaW52YWxpZCIsIl9pbnZhbGlkQ2hhbmdlZCIsIl92YWxpZGF0b3IiLCJieUtleSIsImhhc1ZhbGlkYXRvciIsInZhbGlkYXRlIiwiSXJvbk1ldGEiLCJtZXRhRGF0YXMiLCJfX21ldGEiLCJfX2NvbXB1dGVNZXRhIiwibWV0YSIsIl9zZWxmQ2hhbmdlZCIsIklyb25Gb3JtRWxlbWVudEJlaGF2aW9yIiwiX3BhcmVudEZvcm0iLCJQYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbCIsIl9mb2N1c2VkQ2hhbmdlZCIsImhvbGREb3duIiwiUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciIsIlV0aWxpdHkiLCJ4MSIsInkxIiwieERlbHRhIiwieURlbHRhIiwiRWxlbWVudE1ldHJpY3MiLCJib3VuZGluZ1JlY3QiLCJmdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbSIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiUmlwcGxlIiwid2F2ZSIsIndhdmVDb250YWluZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJyZXNldEludGVyYWN0aW9uU3RhdGUiLCJNQVhfUkFESVVTIiwicmVjZW50ZXJzIiwibW91c2VEb3duRWxhcHNlZCIsIm1vdXNlRG93blN0YXJ0IiwibW91c2VVcFN0YXJ0IiwibW91c2VVcEVsYXBzZWQiLCJtb3VzZURvd25FbGFwc2VkU2Vjb25kcyIsIm1vdXNlVXBFbGFwc2VkU2Vjb25kcyIsIm1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzIiwiaW5pdGlhbE9wYWNpdHkiLCJvcGFjaXR5RGVjYXlWZWxvY2l0eSIsIndpZHRoMiIsImNvbnRhaW5lck1ldHJpY3MiLCJoZWlnaHQyIiwid2F2ZVJhZGl1cyIsInRpbWVOb3ciLCJvdXRlck9wYWNpdHkiLCJ3YXZlT3BhY2l0eSIsImlzT3BhY2l0eUZ1bGx5RGVjYXllZCIsIm1heFJhZGl1cyIsImlzUmVzdGluZ0F0TWF4UmFkaXVzIiwiaXNBbmltYXRpb25Db21wbGV0ZSIsInRyYW5zbGF0aW9uRnJhY3Rpb24iLCJ4Tm93IiwieEVuZCIsInhTdGFydCIsInlOb3ciLCJ5RW5kIiwieVN0YXJ0IiwiaXNNb3VzZURvd24iLCJzbGlkZURpc3RhbmNlIiwiZHJhdyIsInRyYW5zbGF0ZVN0cmluZyIsImRvd25BY3Rpb24iLCJ4Q2VudGVyIiwieUNlbnRlciIsInVwQWN0aW9uIiwicmlwcGxlcyIsIl9hbmltYXRpbmciLCJfYm91bmRBbmltYXRlIiwiZ2V0T3duZXJSb290IiwibGlzdGVuIiwidW5saXN0ZW4iLCJzaG91bGRLZWVwQW5pbWF0aW5nIiwic2ltdWxhdGVkUmlwcGxlIiwiYWRkUmlwcGxlIiwidWlVcEFjdGlvbiIsIm9uQW5pbWF0aW9uQ29tcGxldGUiLCJiYWNrZ3JvdW5kIiwid2F2ZXMiLCJfc2V0QW5pbWF0aW5nIiwicmVtb3ZlUmlwcGxlIiwicmlwcGxlSW5kZXgiLCJfb25FbnRlcktleWRvd24iLCJfb25TcGFjZUtleWRvd24iLCJfb25TcGFjZUtleXVwIiwiX2hvbGREb3duQ2hhbmdlZCIsIm5ld1ZhbCIsIm9sZFZhbCIsImFkZERvdWJsZVRhcExpc3RlbmVyIiwicmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIiLCJfdG91Y2hzdGFydCIsIl90b3VjaGVuZCIsIl9wcmUiLCJkb3VibGVUYXAiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoRW5kIiwibmV3VG91Y2giLCJkYmxjbGljayIsIk1hcmtlckRyYWciLCJfbWFya2VyIiwiX2RyYWdnYWJsZSIsImRyYWdzdGFydCIsIl9vbkRyYWdTdGFydCIsImRyYWciLCJfb25EcmFnIiwiZHJhZ2VuZCIsIl9vbkRyYWdFbmQiLCJfb2xkTGF0TG5nIiwiY2xvc2VQb3B1cCIsInNoYWRvdyIsImljb25Qb3MiLCJMZWFmbGV0TWFwIiwiem9vbUNvbnRyb2wiLCJhdHRyaWJ1dGlvblByZWZpeCIsIl9jaGlsZHJlbk9ic2VydmVyIiwiaW5lcnRpYURlY2VsZXJhdGlvbiIsImluZXJ0aWFNYXhTcGVlZCIsImF0dHJDb250cm9sIiwic2xvdCIsIl9iaW5kRGVwZW5kZW5jaWVzIiwiX3BhbmUiLCJvdmVybGF5UGFuZSIsIl9yZXNldFN0YXRlVGltZW91dCIsIl9kZXN0cm95IiwiX29uTW91c2VEb3duIiwiX3Jlc2V0U3RhdGUiLCJfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUiLCJjb250ZXh0bWVudSIsIl9vbk1vdXNlVXAiLCJrZXlkb3duIiwiX29uS2V5RG93biIsIl9ib3giLCJfZmluaXNoIiwiYm94Wm9vbUJvdW5kcyIsImRvdWJsZUNsaWNrWm9vbSIsIl9vbkRvdWJsZUNsaWNrIiwib2xkWm9vbSIsImluZXJ0aWEiLCJ3b3JsZENvcHlKdW1wIiwibWF4Qm91bmRzVmlzY29zaXR5IiwiX29uUHJlRHJhZ0xpbWl0IiwiX29uUHJlRHJhZ1dyYXAiLCJfcG9zaXRpb25zIiwiX3RpbWVzIiwiX29mZnNldExpbWl0IiwiX3Zpc2Nvc2l0eSIsIl9sYXN0VGltZSIsIl9sYXN0UG9zIiwiX2Fic1BvcyIsInB4Q2VudGVyIiwicHhXb3JsZENlbnRlciIsIl9pbml0aWFsV29ybGRPZmZzZXQiLCJfd29ybGRXaWR0aCIsIl92aXNjb3VzTGltaXQiLCJ0aHJlc2hvbGQiLCJ3b3JsZFdpZHRoIiwiaGFsZldpZHRoIiwibmV3WDEiLCJuZXdYMiIsIm5ld1giLCJub0luZXJ0aWEiLCJlYXNlIiwic3BlZWRWZWN0b3IiLCJzcGVlZCIsImxpbWl0ZWRTcGVlZCIsImxpbWl0ZWRTcGVlZFZlY3RvciIsImRlY2VsZXJhdGlvbkR1cmF0aW9uIiwia2V5Ym9hcmRQYW5EZWx0YSIsImtleUNvZGVzIiwiX3NldFBhbkRlbHRhIiwiX3NldFpvb21EZWx0YSIsIl9vbkZvY3VzIiwiX29uQmx1ciIsIl9hZGRIb29rcyIsIl9yZW1vdmVIb29rcyIsIl9mb2N1c2VkIiwiZG9jRWwiLCJzY3JvbGxUbyIsInBhbkRlbHRhIiwiX3BhbktleXMiLCJjb2RlcyIsIl96b29tS2V5cyIsInNjcm9sbFdoZWVsWm9vbSIsIndoZWVsRGVib3VuY2VUaW1lIiwid2hlZWxQeFBlclpvb21MZXZlbCIsIl9vbldoZWVsU2Nyb2xsIiwiX2RlbHRhIiwiX2xhc3RNb3VzZVBvcyIsIl9wZXJmb3JtWm9vbSIsImQyIiwiZDMiLCJkNCIsInRhcFRvbGVyYW5jZSIsIl9maXJlQ2xpY2siLCJfaG9sZFRpbWVvdXQiLCJfaXNUYXBWYWxpZCIsIl9zaW11bGF0ZUV2ZW50Iiwic2ltdWxhdGVkRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50IiwidG91Y2hab29tIiwiYm91bmNlQXRab29tTGltaXRzIiwiX29uVG91Y2hTdGFydCIsIl96b29taW5nIiwiX2NlbnRlclBvaW50IiwiX3N0YXJ0TGF0TG5nIiwiX3BpbmNoU3RhcnRMYXRMbmciLCJfc3RhcnREaXN0IiwiX3N0YXJ0Wm9vbSIsIl9vblRvdWNoTW92ZSIsIl9vblRvdWNoRW5kIiwibW92ZUZuIiwiY29sbGFwc2VkIiwiYXV0b1pJbmRleCIsImhpZGVTaW5nbGVCYXNlIiwic29ydExheWVycyIsInNvcnRGdW5jdGlvbiIsImxheWVyQSIsImxheWVyQiIsIm5hbWVBIiwibmFtZUIiLCJvdmVybGF5cyIsIl9sYXllckNvbnRyb2xJbnB1dHMiLCJfbGFzdFpJbmRleCIsIl9oYW5kbGluZ0NsaWNrIiwiX2FkZExheWVyIiwiX2NoZWNrRGlzYWJsZWRMYXllcnMiLCJfb25MYXllckNoYW5nZSIsIl9leHBhbmRJZk5vdENvbGxhcHNlZCIsImFkZEJhc2VMYXllciIsImFkZE92ZXJsYXkiLCJfZ2V0TGF5ZXIiLCJleHBhbmQiLCJfZm9ybSIsImFjY2VwdGFibGVIZWlnaHQiLCJvZmZzZXRUb3AiLCJjb2xsYXBzZSIsImZvcm0iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIl9sYXllcnNMaW5rIiwiX2Jhc2VMYXllcnNMaXN0IiwiX3NlcGFyYXRvciIsIl9vdmVybGF5c0xpc3QiLCJiYXNlTGF5ZXJzUHJlc2VudCIsIm92ZXJsYXlzUHJlc2VudCIsImJhc2VMYXllcnNDb3VudCIsIl9hZGRJdGVtIiwiX2NyZWF0ZVJhZGlvRWxlbWVudCIsInJhZGlvSHRtbCIsInJhZGlvRnJhZ21lbnQiLCJsYWJlbCIsImlucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJsYXllcklkIiwiX29uSW5wdXRDbGljayIsImhvbGRlciIsImlucHV0cyIsImFkZGVkTGF5ZXJzIiwicmVtb3ZlZExheWVycyIsIl9leHBhbmQiLCJfY29sbGFwc2UiLCJ6b29tSW5UZXh0Iiwiem9vbUluVGl0bGUiLCJ6b29tT3V0VGV4dCIsInpvb21PdXRUaXRsZSIsInpvb21OYW1lIiwiX3pvb21JbkJ1dHRvbiIsIl9jcmVhdGVCdXR0b24iLCJfem9vbUluIiwiX3pvb21PdXRCdXR0b24iLCJfem9vbU91dCIsIl91cGRhdGVEaXNhYmxlZCIsIl9kaXNhYmxlZCIsIm1heFdpZHRoIiwibWV0cmljIiwiaW1wZXJpYWwiLCJfYWRkU2NhbGVzIiwiX21TY2FsZSIsIl9pU2NhbGUiLCJtYXhNZXRlcnMiLCJfdXBkYXRlU2NhbGVzIiwiX3VwZGF0ZU1ldHJpYyIsIl91cGRhdGVJbXBlcmlhbCIsIm1ldGVycyIsIl9nZXRSb3VuZE51bSIsIl91cGRhdGVTY2FsZSIsIm1heEZlZXQiLCJtYXhNaWxlcyIsIm1pbGVzIiwiZmVldCIsInBvdzEwIiwiYXV0b3BsYXkiLCJsb29wIiwid2FzRWxlbWVudFN1cHBsaWVkIiwidmlkIiwiY2xhc3MiLCJvbmxvYWRlZGRhdGEiLCJ2aWRlbyIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwiYXV0b1BhbiIsImF1dG9QYW5QYWRkaW5nVG9wTGVmdCIsImF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQiLCJhdXRvUGFuUGFkZGluZyIsImtlZXBJblZpZXciLCJjbG9zZUJ1dHRvbiIsImF1dG9DbG9zZSIsIm9wZW5PbiIsIm9wZW5Qb3B1cCIsImNsb3NlT25DbGljayIsImNsb3NlUG9wdXBPbkNsaWNrIiwicHJlY2xpY2siLCJfY2xvc2UiLCJ3cmFwcGVyIiwiX3dyYXBwZXIiLCJfdGlwQ29udGFpbmVyIiwiX3RpcCIsIl9jbG9zZUJ1dHRvbiIsIl9vbkNsb3NlQnV0dG9uQ2xpY2siLCJ3aGl0ZVNwYWNlIiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsZWRDbGFzcyIsIm1hcmdpbkJvdHRvbSIsImNvbnRhaW5lckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibGF5ZXJQb3MiLCJjb250YWluZXJQb3MiLCJfcG9wdXBIYW5kbGVyc0FkZGVkIiwiX29wZW5Qb3B1cCIsImtleXByZXNzIiwiX29uS2V5UHJlc3MiLCJfbW92ZVBvcHVwIiwidW5iaW5kUG9wdXAiLCJ0b2dnbGVQb3B1cCIsImlzUG9wdXBPcGVuIiwic2V0UG9wdXBDb250ZW50IiwiZ2V0UG9wdXAiLCJwZXJtYW5lbnQiLCJzdGlja3kiLCJjbG9zZVRvb2x0aXAiLCJfc2V0UG9zaXRpb24iLCJ0b29sdGlwUG9pbnQiLCJ0b29sdGlwV2lkdGgiLCJ0b29sdGlwSGVpZ2h0Iiwib3BlblRvb2x0aXAiLCJiaW5kVG9vbHRpcCIsIl90b29sdGlwIiwiX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zIiwidW5iaW5kVG9vbHRpcCIsIl90b29sdGlwSGFuZGxlcnNBZGRlZCIsIl9tb3ZlVG9vbHRpcCIsIl9vcGVuVG9vbHRpcCIsInRvZ2dsZVRvb2x0aXAiLCJpc1Rvb2x0aXBPcGVuIiwic2V0VG9vbHRpcENvbnRlbnQiLCJnZXRUb29sdGlwIiwiRGl2SWNvbiIsImRpdkljb24iLCJEZWZhdWx0IiwiYmdQb3MiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJXTVMiLCJ3bXMiLCJSZWN0YW5nbGUiLCJyZWN0YW5nbGUiLCJfYm91bmRzVG9MYXRMbmdzIiwidm1sQ3JlYXRlIiwibmFtZXNwYWNlcyIsInZtbE1peGluIiwiY29vcmRzaXplIiwiX3N0cm9rZSIsIl9maWxsIiwic3Ryb2tlZCIsImZpbGxlZCIsImRhc2hTdHlsZSIsImVuZGNhcCIsImpvaW5zdHlsZSIsIl9nZXRQYW5lUmVuZGVyZXIiLCJwcmVmZXJDYW52YXMiLCJMZWFmbGV0V01TR3JvdXAiLCJpZGVudGlmeSIsIndtc1NvdXJjZSIsInN1YkxheWVycyIsIl93bXNPcHRpb25zIiwiU291cmNlIiwiX2xheWVyc0NoYW5nZSIsIm5ld1ZhbHVlIiwicmVwbGFjZUFsbFN1YkxheWVycyIsInRpbGVkIiwidW50aWxlZCIsIl9zdWJMYXllcnMiLCJfb3ZlcmxheSIsImNyZWF0ZU92ZXJsYXkiLCJvdmVybGF5T3B0aW9ucyIsInJlZnJlc2hPdmVybGF5IiwiaXNCYWNrIiwibmV3U3ViTGF5ZXJzIiwiZXZ0IiwiZ2V0SWRlbnRpZnlMYXllcnMiLCJnZXRGZWF0dXJlSW5mbyIsInNob3dGZWF0dXJlSW5mbyIsImdldEZlYXR1cmVJbmZvUGFyYW1zIiwic2hvd1dhaXRpbmciLCJhamF4IiwiaGlkZVdhaXRpbmciLCJwYXJzZUZlYXR1cmVJbmZvIiwiaWRlbnRpZnlMYXllcnMiLCJ1cGRhdGVXbXNQYXJhbXMiLCJpbmZvUGFyYW1zIiwiY3Vyc29yIiwibGF5ZXJOYW1lIiwiYWRkU3ViTGF5ZXIiLCJnZXRTb3VyY2VGb3JVcmwiLCJfbmFtZSIsInJlbW92ZVN1YkxheWVyIiwic291cmNlcyIsIk92ZXJsYXkiLCJfY3VycmVudE92ZXJsYXkiLCJfY3VycmVudFVybCIsImdldEltYWdlVXJsIiwiX3N3YXAiLCJ3bXNWZXJzaW9uIiwicHN0ciIsIlhNTEh0dHBSZXF1ZXN0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwib3BlbiIsInNlbmQiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJMZWFmbGV0V01TTGF5ZXIiLCJMZWFmbGV0VGlsZUxheWVyIiwibGVhZmxldExheWVyIiwiaGludHMiLCJMZWFmbGV0R2VvSlNPTiIsIm91dGxpbmVDb2xvciIsImNsdXN0ZXIiLCJtYXhDbHVzdGVyUmFkaXVzIiwiX2NsdXN0ZXJHcm91cCIsInNob3dDb3ZlcmFnZU9uSG92ZXIiLCJfZ2VvSlNPTk9wdGlvbnMiLCJfY2x1c3RlclBvaW50cyIsIl9zaW1wbGVQb2ludHMiLCJfb25FYWNoRmVhdHVyZSIsIl9nZW9KU09OTGF5ZXIiLCJfZ2VuZXJhdGVQb3B1cENvbnRlbnQiLCJyb3dzIiwiZmllbGROYW1lIiwidHh0IiwiY2hhckF0Iiwic3Vic3RyIiwicmVzIiwiX2FkZEdlb0pTT05MYXllciIsIm5vQ29uZmxpY3QiLCJvbGRMIiwiZXhwb3J0cyIsIlByb2plY3Rpb24iLCJFUFNHMzM5NSIsIlNpbXBsZSIsIk1hcmtlckNsdXN0ZXJHcm91cCIsIk1hcmtlckNsdXN0ZXIiLCJpY29uQ3JlYXRlRnVuY3Rpb24iLCJjbHVzdGVyUGFuZSIsInNwaWRlcmZ5T25NYXhab29tIiwiem9vbVRvQm91bmRzT25DbGljayIsInNpbmdsZU1hcmtlck1vZGUiLCJkaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSIsInJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzIiwiYW5pbWF0ZUFkZGluZ01hcmtlcnMiLCJzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciIsInNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyIsImNodW5rZWRMb2FkaW5nIiwiY2h1bmtJbnRlcnZhbCIsImNodW5rRGVsYXkiLCJjaHVua1Byb2dyZXNzIiwicG9seWdvbk9wdGlvbnMiLCJfZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbiIsIl9mZWF0dXJlR3JvdXAiLCJfbm9uUG9pbnRHcm91cCIsIl9pblpvb21BbmltYXRpb24iLCJfbmVlZHNDbHVzdGVyaW5nIiwiX25lZWRzUmVtb3ZpbmciLCJfY3VycmVudFNob3duQm91bmRzIiwiX3F1ZXVlIiwiX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycyIsIl9jaGlsZE1hcmtlckRyYWdTdGFydCIsIl9jaGlsZE1hcmtlck1vdmVkIiwiX2NoaWxkTWFya2VyRHJhZ0VuZCIsIl93aXRoQW5pbWF0aW9uIiwiX25vQW5pbWF0aW9uIiwiX21hcmtlckNsdXN0ZXIiLCJNYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQiLCJhZGRMYXllcnMiLCJfdW5zcGlkZXJmeSIsIl9tYXhab29tIiwiX3RvcENsdXN0ZXJMZXZlbCIsIl9yZWNhbGN1bGF0ZUJvdW5kcyIsIl9yZWZyZXNoQ2x1c3RlcnNJY29ucyIsInZpc2libGVMYXllciIsImN1cnJlbnRab29tIiwiX19wYXJlbnQiLCJfYW5pbWF0aW9uQWRkTGF5ZXIiLCJfYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZCIsInJlbW92ZUxheWVycyIsIl9hcnJheVNwbGljZSIsIl91bnNwaWRlcmZ5TGF5ZXIiLCJfcmVtb3ZlTGF5ZXIiLCJjbHVzdGVyU2hvdyIsImxheWVyc0FycmF5Iiwic2tpcExheWVyQWRkRXZlbnQiLCJmZyIsIm5wZyIsImNodW5rZWQiLCJvcmlnaW5hbEFycmF5IiwiZ2V0VGltZSIsInByb2Nlc3MiLCJfZXh0cmFjdE5vbkdyb3VwTGF5ZXJzIiwiZ2V0Q2hpbGRDb3VudCIsImdldEFsbENoaWxkTWFya2VycyIsIm90aGVyTWFya2VyIiwiX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcCIsIm5lZWRzQ2x1c3RlcmluZyIsImxheWVyc0FycmF5MiIsImwyIiwiX2dyaWRDbHVzdGVycyIsIl9ncmlkVW5jbHVzdGVyZWQiLCJfbm9hbmltYXRpb25VbnNwaWRlcmZ5IiwiX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzIiwibmVlZHNSZW1vdmluZyIsInRoaXNOZWVkc1JlbW92aW5nIiwiYW5BcnJheSIsIl9ncm91cCIsInpvb21Ub1Nob3dMYXllciIsInNob3dNYXJrZXIiLCJzcGlkZXJmeSIsInpvb21Ub0JvdW5kcyIsIl9tYXhMYXQiLCJuZXdsYXRsbmciLCJfZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzIiwiX3pvb21FbmQiLCJfc3BpZGVyZmllck9uQWRkIiwiX2JpbmRFdmVudHMiLCJfdW5iaW5kRXZlbnRzIiwiX3NwaWRlcmZpZXJPblJlbW92ZSIsIl9oaWRlQ292ZXJhZ2UiLCJnZXRWaXNpYmxlUGFyZW50Iiwidk1hcmtlciIsIl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkIiwiZ3JpZFVuY2x1c3RlcmVkIiwicmVtb3ZlT2JqZWN0IiwiX19kcmFnU3RhcnQiLCJfaWdub3JlTW92ZSIsIl9tb3ZlQ2hpbGQiLCJyZW1vdmVGcm9tRGlzdGFuY2VHcmlkIiwiZG9udFVwZGF0ZU1hcCIsImdyaWRDbHVzdGVycyIsIl9tYXJrZXJzIiwiX2NoaWxkQ291bnQiLCJfYm91bmRzTmVlZFVwZGF0ZSIsIl9jTGF0TG5nIiwiYWRkT2JqZWN0IiwiX2NoaWxkQ2x1c3RlcnMiLCJfaWNvbk5lZWRzVXBkYXRlIiwiX2lzT3JJc1BhcmVudCIsIm9lbCIsImNoaWxkQ291bnQiLCJfem9vbU9yU3BpZGVyZnkiLCJfc2hvd0NvdmVyYWdlIiwiYm90dG9tQ2x1c3RlciIsIl9zaG93blBvbHlnb24iLCJfc3BpZGVyZmllZCIsImdldENvbnZleEh1bGwiLCJfbWVyZ2VTcGxpdENsdXN0ZXJzIiwiX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwIiwicmFkaXVzRm4iLCJEaXN0YW5jZUdyaWQiLCJtYXJrZXJQb2ludCIsIl9vdmVycmlkZU1hcmtlckljb24iLCJnZXROZWFyT2JqZWN0IiwiX2FkZENoaWxkIiwibmV3Q2x1c3RlciIsImxhc3RQYXJlbnQiLCJfdXBkYXRlSWNvbiIsIl9lbnF1ZXVlIiwiX3F1ZXVlVGltZW91dCIsIl9wcm9jZXNzUXVldWUiLCJfYW5pbWF0aW9uU3RhcnQiLCJfYW5pbWF0aW9uWm9vbUluIiwiX2FuaW1hdGlvblpvb21PdXQiLCJfbWFwQm91bmRzSW5maW5pdGUiLCJfY2hlY2tCb3VuZHNNYXhMYXQiLCJtYXhMYXQiLCJfYWRkVG9NYXAiLCJncm91cCIsIm91dHB1dCIsInByZXZpb3VzWm9vbUxldmVsIiwibmV3Wm9vbUxldmVsIiwiX3JlY3Vyc2l2ZWx5Iiwic3RhcnRQb3MiLCJfaXNTaW5nbGVQYXJlbnQiLCJjbHVzdGVySGlkZSIsIl9mb3JjZUxheW91dCIsIl9yZWN1cnNpdmVseUJlY29tZVZpc2libGUiLCJfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMiLCJfYW5pbWF0aW9uRW5kIiwiX2FuaW1hdGlvblpvb21PdXRTaW5nbGUiLCJtZSIsIl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwIiwibWFya2VyQ2x1c3Rlckdyb3VwIiwic3RvcmFnZUFycmF5IiwiZml0Qm91bmRzT3B0aW9ucyIsImNoaWxkQ2x1c3RlcnMiLCJib3VuZHNab29tIiwibmV3Q2x1c3RlcnMiLCJfaWNvbk9iaiIsIm5ldzEiLCJpc05vdGlmaWNhdGlvbkZyb21DaGlsZCIsIl9zZXRDbHVzdGVyQ2VudGVyIiwiY2hpbGQiLCJfcmVzZXRCb3VuZHMiLCJsYXRTdW0iLCJsbmdTdW0iLCJ0b3RhbENvdW50IiwiY2hpbGRMYXRMbmciLCJfd0xhdExuZyIsIl9iYWNrdXBMYXRsbmciLCJfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbiIsImNtIiwibWFwTWluWm9vbSIsInpvb21MZXZlbCIsIm5tIiwiX3Jlc3RvcmVQb3NpdGlvbiIsInByZXZpb3VzQm91bmRzIiwiZXhjZXB0Qm91bmRzIiwiYm91bmRzVG9BcHBseVRvIiwiem9vbUxldmVsVG9TdGFydCIsInpvb21MZXZlbFRvU3RvcCIsInJ1bkF0RXZlcnlMZXZlbCIsInJ1bkF0Qm90dG9tTGV2ZWwiLCJvcGFjaXR5V2hlblVuY2x1c3RlcmVkIiwiY2VsbFNpemUiLCJfY2VsbFNpemUiLCJfc3FDZWxsU2l6ZSIsIl9ncmlkIiwiX29iamVjdFBvaW50IiwiX2dldENvb3JkIiwiZ3JpZCIsInJvdyIsImNlbGwiLCJ1cGRhdGVPYmplY3QiLCJlYWNoT2JqZWN0Iiwib2JqZWN0UG9pbnQiLCJjbG9zZXN0RGlzdFNxIiwiY29vcmQiLCJRdWlja0h1bGwiLCJnZXREaXN0YW50IiwiY3B0IiwidlkiLCJ2WCIsImZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lIiwiYmFzZUxpbmUiLCJsYXRMbmdzIiwibWF4RCIsIm1heFB0IiwicHQiLCJtYXhQb2ludCIsImJ1aWxkQ29udmV4SHVsbCIsImNvbnZleEh1bGxCYXNlTGluZXMiLCJtaW5MYXQiLCJtYXhMbmciLCJtaW5MbmciLCJtYXhMYXRQdCIsIm1pbkxhdFB0IiwibWF4TG5nUHQiLCJtaW5MbmdQdCIsIm1pblB0IiwiY2giLCJjaGlsZE1hcmtlcnMiLCJfMlBJIiwiX2NpcmNsZUZvb3RTZXBhcmF0aW9uIiwiX2NpcmNsZVN0YXJ0QW5nbGUiLCJfc3BpcmFsRm9vdFNlcGFyYXRpb24iLCJfc3BpcmFsTGVuZ3RoU3RhcnQiLCJfc3BpcmFsTGVuZ3RoRmFjdG9yIiwiX2NpcmNsZVNwaXJhbFN3aXRjaG92ZXIiLCJwb3NpdGlvbnMiLCJfZ2VuZXJhdGVQb2ludHNTcGlyYWwiLCJfZ2VuZXJhdGVQb2ludHNDaXJjbGUiLCJfYW5pbWF0aW9uU3BpZGVyZnkiLCJ1bnNwaWRlcmZ5Iiwiem9vbURldGFpbHMiLCJfYW5pbWF0aW9uVW5zcGlkZXJmeSIsImNlbnRlclB0IiwiY2lyY3VtZmVyZW5jZSIsImxlZ0xlbmd0aCIsImFuZ2xlU3RlcCIsImFuZ2xlIiwic2VwYXJhdGlvbiIsImxlbmd0aEZhY3RvciIsIl9wcmVTcGlkZXJmeUxhdGxuZyIsIl9zcGlkZXJMZWciLCJsZWdPcHRpb25zIiwibGVnIiwidGhpc0xheWVyTGF0TG5nIiwidGhpc0xheWVyUG9zIiwiZmluYWxMZWdPcGFjaXR5IiwibGVnUGF0aCIsImdldFRvdGFsTGVuZ3RoIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsIm5vbkFuaW1hdGFibGUiLCJzdGlsbFRoZXJlQ2hpbGRDb3VudCIsIl91bnNwaWRlcmZ5V3JhcHBlciIsIl91bnNwaWRlcmZ5Wm9vbVN0YXJ0IiwiX3Vuc3BpZGVyZnlab29tQW5pbSIsInJlZnJlc2hDbHVzdGVycyIsIl9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZSIsIl9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnMiLCJyZWZyZXNoSWNvbk9wdGlvbnMiLCJkaXJlY3RseVJlZnJlc2hDbHVzdGVycyIsImdsb2JhbCIsImpzeWFtbCIsIlR5cGUiLCJTY2hlbWEiLCJGQUlMU0FGRV9TQ0hFTUEiLCJKU09OX1NDSEVNQSIsIkNPUkVfU0NIRU1BIiwiREVGQVVMVF9TQUZFX1NDSEVNQSIsIkRFRkFVTFRfRlVMTF9TQ0hFTUEiLCJsb2FkIiwibG9hZEFsbCIsInNhZmVMb2FkQWxsIiwiZHVtcCIsInNhZmVEdW1wIiwiWUFNTEV4Y2VwdGlvbiIsIk1JTklNQUxfU0NIRU1BIiwiU0FGRV9TQ0hFTUEiLCJERUZBVUxUX1NDSEVNQSIsInNjYW4iLCJjb21wb3NlIiwiYWRkQ29uc3RydWN0b3IiLCJpc05vdGhpbmciLCJ0b0FycmF5IiwiaXNOZWdhdGl2ZVplcm8iLCJORUdBVElWRV9JTkZJTklUWSIsImNvbXBpbGVkVHlwZU1hcCIsIlQiLCJzdHlsZUFsaWFzZXMiLCJFIiwic2NoZW1hIiwiXyIsImluZGVudCIsInNraXBJbnZhbGlkIiwiZmxvd0xldmVsIiwic3R5bGVNYXAiLCJzb3J0S2V5cyIsIm5vUmVmcyIsIm5vQ29tcGF0TW9kZSIsImNvbmRlbnNlRmxvdyIsImltcGxpY2l0VHlwZXMiLCJjb21waWxlZEltcGxpY2l0IiwiZXhwbGljaXRUeXBlcyIsImNvbXBpbGVkRXhwbGljaXQiLCJkdXBsaWNhdGVzIiwidXNlZER1cGxpY2F0ZXMiLCJVIiwiSiIsIlEiLCJlZSIsIkciLCJIIiwiWiIsIlciLCJLIiwidGUiLCJWIiwiQiIsIlkiLCJQIiwiWCIsImgiLCJjaGFyQ29kZUF0IiwidWUiLCJEIiwiY2UiLCJvZSIsImFlIiwicmUiLCJnIiwiQSIsIkMiLCJpbnN0YW5jZU9mIiwicHJlZGljYXRlIiwicmVwcmVzZW50IiwiZGVmYXVsdFN0eWxlIiwiTSIsIkkiLCJPIiwiTiIsInJlYXNvbiIsIm1hcmsiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImZpbGVuYW1lIiwib25XYXJuaW5nIiwibGVnYWN5IiwibGlzdGVuZXIiLCJ0eXBlTWFwIiwibGluZSIsImxpbmVTdGFydCIsImxpbmVJbmRlbnQiLCJkb2N1bWVudHMiLCJhbmNob3JNYXAiLCJ0YWdNYXAiLCJjb25zdHJ1Y3QiLCJjaGVja0xpbmVCcmVha3MiLCJZQU1MIiwiVEFHIiwiYnVmZmVyIiwiY29sdW1uIiwiZ2V0U25pcHBldCIsInNjYWxhciIsInNlcXVlbmNlIiwibWFwcGluZyIsImltcGxpY2l0IiwiZXhwbGljaXQiLCJsb2FkS2luZCIsIkRFRkFVTFQiLCJldmVyeSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwibG93ZXJjYXNlIiwiY2FtZWxjYXNlIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJiaW5hcnkiLCJvY3RhbCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsImVzcHJpbWEiLCJtdWx0aWxpbmUiLCJpZ25vcmVDYXNlIiwiY2Fub25pY2FsIiwiVVRDIiwic2V0VGltZSIsInRvSVNPU3RyaW5nIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7UUNsRGdCQSxNLEdBQUFBLE07UUF5QkFDLEksR0FBQUEsSTtRQW9CQUMsSyxHQUFBQSxLO1FBY0FDLFEsR0FBQUEsUTtRQWdDQUMsTyxHQUFBQSxPO1FBU0FDLE8sR0FBQUEsTztRQUlBQyxTLEdBQUFBLFM7UUFPQUMsSSxHQUFBQSxJO1FBTUFDLFUsR0FBQUEsVTtRQU1BQyxVLEdBQUFBLFU7UUFlQUMsYyxHQUFBQSxjO1FBZUFDLFEsR0FBQUEsUTtRQXNCQUMsTyxHQUFBQSxPO1FBd0NBQyxnQixHQUFBQSxnQjtRQVVBQyxlLEdBQUFBLGU7QUE1T2hCOzs7Ozs7QUFNTyxJQUFJQywwQkFBU0MsT0FBT0QsTUFBcEI7QUFDUEMsT0FBT0QsTUFBUCxHQUFnQixVQUFVRSxHQUFWLEVBQWU7QUFBRSxRQUFPQSxHQUFQO0FBQWEsQ0FBOUM7O0FBRUE7QUFDQTtBQUNPLFNBQVNqQixNQUFULENBQWdCa0IsSUFBaEIsRUFBc0I7QUFDNUIsS0FBSUMs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QUFXLEVBQUVBLEVBQUUsRUFBRixLQUFPLENBQVQsQ0FBaEIsQ0FBRixFQUErQixRQUFNQSxFQUFFLENBQUYsQ0FBTixLQUFhbzZDLElBQUUsQ0FBQ0EsQ0FBaEIsQ0FBdEMsR0FBMEQxa0MsSUFBRSxJQUFJMXJCLElBQUosQ0FBU0EsS0FBS3c2RyxHQUFMLENBQVNqbEcsQ0FBVCxFQUFXdlosQ0FBWCxFQUFhMGxCLENBQWIsRUFBZTdMLENBQWYsRUFBaUIwQyxDQUFqQixFQUFtQnpDLENBQW5CLEVBQXFCK1QsQ0FBckIsQ0FBVCxDQUE1RCxFQUE4RnVtQyxLQUFHMWtDLEVBQUUrdUYsT0FBRixDQUFVL3VGLEVBQUV1NkUsT0FBRixLQUFZNzFDLENBQXRCLENBQWpHLEVBQTBIMWtDLENBQWpJO0FBQW1JLFNBQTNmLEVBQTRmNHJGLFlBQVd0M0csSUFBdmdCLEVBQTRnQnczRyxXQUFVLG1CQUFTdHpHLENBQVQsRUFBVztBQUFDLGlCQUFPQSxFQUFFdzJHLFdBQUYsRUFBUDtBQUF1QixTQUF6akIsRUFBcEMsQ0FBVjtBQUEwbUIsS0FBLzVCLEVBQWc2QixFQUFDLFdBQVUsRUFBWCxFQUFoNkIsQ0FBdjN1QyxFQUF1eXdDLEtBQUksQ0FBQyxVQUFTeDJHLENBQVQsRUFBVzhSLENBQVgsRUFBYVQsQ0FBYixFQUFlO0FBQUM7QUFBYSxVQUFJdlosSUFBRWtJLEVBQUUsa0JBQUYsQ0FBTixDQUE0QjhSLEVBQUVzc0YsT0FBRixHQUFVdG1HLENBQVY7QUFBWSxLQUF0RSxFQUF1RSxFQUFDLG9CQUFtQixDQUFwQixFQUF2RSxDQUEzeXdDLEVBQXBiLEVBQSt6eEMsRUFBL3p4QyxFQUFrMHhDLEVBQWwweEMsRUFBczB4QyxHQUF0MHhDLENBQVA7QUFBazF4QyxDQUExbXlDLENBQUQsQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA5MCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMDU2YzFiYmQ5NWFkN2FmY2VjOTYiLCIvKlxyXG4gKiBAbmFtZXNwYWNlIFV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBmcmVlemUgPSBPYmplY3QuZnJlZXplO1xyXG5PYmplY3QuZnJlZXplID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGBzcmNgIG9iamVjdCAob3IgbXVsdGlwbGUgb2JqZWN0cykgaW50byBgZGVzdGAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBsYXR0ZXIuIEhhcyBhbiBgTC5leHRlbmRgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGRlc3QpIHtcclxuXHR2YXIgaSwgaiwgbGVuLCBzcmM7XHJcblxyXG5cdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0c3JjID0gYXJndW1lbnRzW2pdO1xyXG5cdFx0Zm9yIChpIGluIHNyYykge1xyXG5cdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZGVzdDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShwcm90bzogT2JqZWN0LCBwcm9wZXJ0aWVzPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtPYmplY3QuY3JlYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlKVxyXG5leHBvcnQgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHRmdW5jdGlvbiBGKCkge31cclxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvKSB7XHJcblx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cdFx0cmV0dXJuIG5ldyBGKCk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbi8vIEBmdW5jdGlvbiBiaW5kKGZuOiBGdW5jdGlvbiwg4oCmKTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBib3VuZCB0byB0aGUgYXJndW1lbnRzIHBhc3NlZCwgbGlrZSBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxyXG4vLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gYmluZChmbiwgb2JqKSB7XHJcblx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuXHRpZiAoZm4uYmluZCkge1xyXG5cdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MubGVuZ3RoID8gYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IGFyZ3VtZW50cyk7XHJcblx0fTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGxhc3RJZDogTnVtYmVyXHJcbi8vIExhc3QgdW5pcXVlIElEIHVzZWQgYnkgW2BzdGFtcCgpYF0oI3V0aWwtc3RhbXApXHJcbmV4cG9ydCB2YXIgbGFzdElkID0gMDtcclxuXHJcbi8vIEBmdW5jdGlvbiBzdGFtcChvYmo6IE9iamVjdCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgYW4gb2JqZWN0LCBhc3NpZ2luZyBpdCBvbmUgaWYgaXQgZG9lc24ndCBoYXZlIGl0LlxyXG5leHBvcnQgZnVuY3Rpb24gc3RhbXAob2JqKSB7XHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdG9iai5fbGVhZmxldF9pZCA9IG9iai5fbGVhZmxldF9pZCB8fCArK2xhc3RJZDtcclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG5cdC8qZXNsaW50LWVuYWJsZSAqL1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA1IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBkaWdpdHMpIHtcclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIGRpZ2l0cyB8fCA1KTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfXFwtXSspICpcXH0vZztcclxuXHJcbi8vIEBmdW5jdGlvbiB0ZW1wbGF0ZShzdHI6IFN0cmluZywgZGF0YTogT2JqZWN0KTogU3RyaW5nXHJcbi8vIFNpbXBsZSB0ZW1wbGF0aW5nIGZhY2lsaXR5LCBhY2NlcHRzIGEgdGVtcGxhdGUgc3RyaW5nIG9mIHRoZSBmb3JtIGAnSGVsbG8ge2F9LCB7Yn0nYFxyXG4vLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG4vLyBgKCdIZWxsbyBmb28sIGJhcicpYC4gWW91IGNhbiBhbHNvIHNwZWNpZnkgZnVuY3Rpb25zIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3JcclxuLy8gZGF0YSB2YWx1ZXMg4oCUIHRoZXkgd2lsbCBiZSBldmFsdWF0ZWQgcGFzc2luZyBgZGF0YWAgYXMgYW4gYXJndW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZShzdHIsIGRhdGEpIHtcclxuXHRyZXR1cm4gc3RyLnJlcGxhY2UodGVtcGxhdGVSZSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgJyArIHN0cik7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZShkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzQXJyYXkob2JqKTogQm9vbGVhblxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcclxuZXhwb3J0IHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XHJcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gaW5kZXhPZihhcnJheTogQXJyYXksIGVsOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LnByb3RvdHlwZS5pbmRleE9mXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mKVxyXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWwpIHtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoYXJyYXlbaV0gPT09IGVsKSB7IHJldHVybiBpOyB9XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cclxuLy8gQHByb3BlcnR5IGVtcHR5SW1hZ2VVcmw6IFN0cmluZ1xyXG4vLyBEYXRhIFVSSSBzdHJpbmcgY29udGFpbmluZyBhIGJhc2U2NC1lbmNvZGVkIGVtcHR5IEdJRiBpbWFnZS5cclxuLy8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcbi8vIG1vYmlsZSBkZXZpY2VzIChieSBzZXR0aW5nIGltYWdlIGBzcmNgIHRvIHRoaXMgc3RyaW5nKS5cclxuZXhwb3J0IHZhciBlbXB0eUltYWdlVXJsID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxufVxyXG5cclxudmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG5leHBvcnQgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4vLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbi8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbi8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvVXRpbC5qcyIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0ZPUk06IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuZXhwb3J0IHZhciBUUkFOU0ZPUk0gPSB0ZXN0UHJvcChcclxuXHRbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG4vLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcbi8vIHRoZSBzYW1lIGZvciB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgaW4gcGFydGljdWxhciB0aGUgQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT046IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbiBzdHlsZSBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT04gPSB0ZXN0UHJvcChcclxuXHRbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OX0VORDogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uZW5kIGV2ZW50IG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTl9FTkQgPVxyXG5cdFRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBUUkFOU0lUSU9OID09PSAnT1RyYW5zaXRpb24nID8gVFJBTlNJVElPTiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXQoaWQ6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG4vLyBpZiBpdCB3YXMgcGFzc2VkIGRpcmVjdGx5LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkKSB7XHJcblx0cmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgYSBjZXJ0YWluIHN0eWxlIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LFxyXG4vLyBpbmNsdWRpbmcgY29tcHV0ZWQgdmFsdWVzIG9yIHZhbHVlcyBzZXQgdGhyb3VnaCBDU1MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbCwgc3R5bGUpIHtcclxuXHR2YXIgdmFsdWUgPSBlbC5zdHlsZVtzdHlsZV0gfHwgKGVsLmN1cnJlbnRTdHlsZSAmJiBlbC5jdXJyZW50U3R5bGVbc3R5bGVdKTtcclxuXHJcblx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdHZhciBjc3MgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKTtcclxuXHRcdHZhbHVlID0gY3NzID8gY3NzW3N0eWxlXSA6IG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWU6IFN0cmluZywgY2xhc3NOYW1lPzogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIENyZWF0ZXMgYW4gSFRNTCBlbGVtZW50IHdpdGggYHRhZ05hbWVgLCBzZXRzIGl0cyBjbGFzcyB0byBgY2xhc3NOYW1lYCwgYW5kIG9wdGlvbmFsbHkgYXBwZW5kcyBpdCB0byBgY29udGFpbmVyYCBlbGVtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdGlmIChjb250YWluZXIpIHtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG5cdHJldHVybiBlbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYGVsYCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCkge1xyXG5cdFx0cGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbXB0eShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIFJlbW92ZXMgYWxsIG9mIGBlbGAncyBjaGlsZHJlbiBlbGVtZW50cyBmcm9tIGBlbGBcclxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KGVsKSB7XHJcblx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuXHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBsYXN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgaW4gZnJvbnQgb2YgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Gcm9udChlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50LmZpcnN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCBwYXJlbnQuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpOiBCb29sZWFuXHJcbi8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGNvbnRhaW5zIGBuYW1lYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdH1cclxuXHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gQWRkcyBgbmFtZWAgdG8gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dmFyIGNsYXNzZXMgPSBVdGlsLnNwbGl0V29yZHMobmFtZSk7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsLCBuYW1lKSkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRcdHNldENsYXNzKGVsLCAoY2xhc3NOYW1lID8gY2xhc3NOYW1lICsgJyAnIDogJycpICsgbmFtZSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFJlbW92ZXMgYG5hbWVgIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c2V0Q2xhc3MoZWwsIFV0aWwudHJpbSgoJyAnICsgZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gU2V0cyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG4vLyBSZXR1cm5zIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzcyhlbCkge1xyXG5cdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4vLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHR0cnkge1xyXG5cdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHR9XHJcblxyXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdGlmIChmaWx0ZXIpIHtcclxuXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4vLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4vLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4vLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuXHRcdChCcm93c2VyLmllM2QgP1xyXG5cdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHQvKmVzbGludC1lbmFibGUgKi9cclxuXHJcblx0aWYgKEJyb3dzZXIuYW55M2QpIHtcclxuXHRcdHNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQpOiBQb2ludFxyXG4vLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWwpIHtcclxuXHQvLyB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZm9yIGVsZW1lbnRzIHByZXZpb3VzbHkgcG9zaXRpb25lZCB1c2luZyBzZXRQb3NpdGlvbixcclxuXHQvLyBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgdGhlIHBvc2l0aW9uIGZvciBwZXJmb3JtYW5jZVxyXG5cclxuXHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBQb2ludCgwLCAwKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gUHJldmVudHMgdGhlIHVzZXIgZnJvbSBnZW5lcmF0aW5nIGBzZWxlY3RzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWRcclxuLy8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuLy8gYnkgTGVhZmxldCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3VyIG9mIGFueSBjbGljay1hbmQtZHJhZyBpbnRlcmFjdGlvbiBvblxyXG4vLyB0aGUgbWFwLiBBZmZlY3RzIGRyYWcgaW50ZXJhY3Rpb25zIG9uIHRoZSB3aG9sZSBkb2N1bWVudC5cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgdmFyIGRpc2FibGVUZXh0U2VsZWN0aW9uO1xyXG5leHBvcnQgdmFyIGVuYWJsZVRleHRTZWxlY3Rpb247XHJcbnZhciBfdXNlclNlbGVjdDtcclxuaWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub24od2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IHRlc3RQcm9wKFxyXG5cdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG5cdGRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XTtcclxuXHRcdFx0c3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuXHRcdH1cclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gX3VzZXJTZWxlY3Q7XHJcblx0XHRcdF91c2VyU2VsZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuLy8gQXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbiksIGJ1dFxyXG4vLyBmb3IgYGRyYWdzdGFydGAgRE9NIGV2ZW50cywgdXN1YWxseSBnZW5lcmF0ZWQgd2hlbiB0aGUgdXNlciBkcmFncyBhbiBpbWFnZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWdgXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKSB7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxudmFyIF9vdXRsaW5lRWxlbWVudCwgX291dGxpbmVTdHlsZTtcclxuLy8gQGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgdGhlIFtvdXRsaW5lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1Mvb3V0bGluZSlcclxuLy8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuLy8gZm9jdXNhYmxlIGVsZW1lbnRzIGZyb20gZGlzcGxheWluZyBhbiBvdXRsaW5lIHdoZW4gdGhlIHVzZXIgcGVyZm9ybXMgYVxyXG4vLyBkcmFnIGludGVyYWN0aW9uIG9uIHRoZW0uXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbGVtZW50KSB7XHJcblx0d2hpbGUgKGVsZW1lbnQudGFiSW5kZXggPT09IC0xKSB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH1cclxuXHRpZiAoIWVsZW1lbnQuc3R5bGUpIHsgcmV0dXJuOyB9XHJcblx0cmVzdG9yZU91dGxpbmUoKTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdF9vdXRsaW5lU3R5bGUgPSBlbGVtZW50LnN0eWxlLm91dGxpbmU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlT3V0bGluZSgpIHtcclxuXHRpZiAoIV9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRfb3V0bGluZUVsZW1lbnQuc3R5bGUub3V0bGluZSA9IF9vdXRsaW5lU3R5bGU7XHJcblx0X291dGxpbmVFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cdF9vdXRsaW5lU3R5bGUgPSB1bmRlZmluZWQ7XHJcblx0RG9tRXZlbnQub2ZmKHdpbmRvdywgJ2tleWRvd24nLCByZXN0b3JlT3V0bGluZSk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tVXRpbC5qcyIsIndpbmRvdy5KU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCwgb2JqKSB7IHJldHVybiBwcm9wOyB9XG5cbi8qKiBAbmFtZXNwYWNlICovXG5sZXQgUG9seW1lcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qcyIsImltcG9ydCB7aXNBcnJheSwgZm9ybWF0TnVtfSBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59XHJcblxyXG5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdC8vIEBtZXRob2QgY2xvbmUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludC5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGQob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpdGlvbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRhZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gbm9uLWRlc3RydWN0aXZlLCByZXR1cm5zIGEgbmV3IHBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGQ6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gZGVzdHJ1Y3RpdmUsIHVzZWQgZGlyZWN0bHkgZm9yIHBlcmZvcm1hbmNlIGluIHNpdHVhdGlvbnMgd2hlcmUgaXQncyBzYWZlIHRvIG1vZGlmeSBleGlzdGluZyBwb2ludFxyXG5cdFx0dGhpcy54ICs9IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgKz0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3VidHJhY3Qob3RoZXJQb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQgZnJvbSB0aGUgY3VycmVudC5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpdmlkZUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZGl2aXNpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtdWx0aXBseUJ5KG51bTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbGljYXRpb24gb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgdGhlIGdpdmVuIG51bWJlci5cclxuXHRtdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0aXBseUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X211bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAqPSBudW07XHJcblx0XHR0aGlzLnkgKj0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gTXVsdGlwbHkgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IGVhY2ggY29vcmRpbmF0ZSBvZlxyXG5cdC8vIGBzY2FsZWAuIEluIGxpbmVhciBhbGdlYnJhIHRlcm1zLCBtdWx0aXBseSB0aGUgcG9pbnQgYnkgdGhlXHJcblx0Ly8gW3NjYWxpbmcgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TY2FsaW5nXyUyOGdlb21ldHJ5JTI5I01hdHJpeF9yZXByZXNlbnRhdGlvbilcclxuXHQvLyBkZWZpbmVkIGJ5IGBzY2FsZWAuXHJcblx0c2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBwb2ludC54LCB0aGlzLnkgLyBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJvdW5kKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCByb3VuZGVkIGNvb3JkaW5hdGVzLlxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbG9vcigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggZmxvb3JlZCBjb29yZGluYXRlcyAocm91bmRlZCBkb3duKS5cclxuXHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKTtcclxuXHR9LFxyXG5cclxuXHRfZmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2VpbCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggY2VpbGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHVwKS5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9jZWlsKCk7XHJcblx0fSxcclxuXHJcblx0X2NlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvUG9pbnQuanMiLCJpbXBvcnQge3N2Z0NyZWF0ZX0gZnJvbSAnLi4vbGF5ZXIvdmVjdG9yL1NWRy5VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuZXhwb3J0IHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbmV4cG9ydCB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5leHBvcnQgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG5leHBvcnQgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbmV4cG9ydCB2YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG5leHBvcnQgdmFyIG9wZXJhID0gISF3aW5kb3cub3BlcmE7XHJcblxyXG4vLyBAcHJvcGVydHkgY2hyb21lOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBDaHJvbWUgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBjaHJvbWUgPSB1c2VyQWdlbnRDb250YWlucygnY2hyb21lJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja286IEJvb2xlYW47IGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgbGlrZSBGaXJlZm94LlxyXG5leHBvcnQgdmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbmV4cG9ydCB2YXIgc2FmYXJpID0gIWNocm9tZSAmJiB1c2VyQWdlbnRDb250YWlucygnc2FmYXJpJyk7XHJcblxyXG5leHBvcnQgdmFyIHBoYW50b20gPSB1c2VyQWdlbnRDb250YWlucygncGhhbnRvbScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zICh2ZXJzaW9uIDEyIG9yIGxhdGVyKS5cclxuZXhwb3J0IHZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbmV4cG9ydCB2YXIgd2luID0gbmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ1dpbicpID09PSAwO1xyXG5cclxuLy8gQHByb3BlcnR5IGllM2Q6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gc3R5bGUpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIGdlY2tvM2QgPSAnTW96UGVyc3BlY3RpdmUnIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGFueTNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgYW55M2QgPSAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGU6IEJvb2xlYW47IGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQgPSBtb2JpbGUgJiYgd2Via2l0O1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2Ugc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBtb2JpbGVXZWJraXQzZCA9IG1vYmlsZSAmJiB3ZWJraXQzZDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtc1BvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBpbXBsZW1lbnRpbmcgdGhlIE1pY3Jvc29mdCB0b3VjaCBldmVudHMgbW9kZWwgKG5vdGFibHkgSUUxMCkuXHJcbmV4cG9ydCB2YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG5leHBvcnQgdmFyIHBvaW50ZXIgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IG1zUG9pbnRlcik7XHJcblxyXG4vLyBAcHJvcGVydHkgdG91Y2g6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbdG91Y2ggZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvVG91Y2hfZXZlbnRzKS5cclxuLy8gVGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4vLyB0b3VjaCBldmVudHMuXHJcbmV4cG9ydCB2YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHBvaW50ZXIgfHwgJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8XHJcblx0XHQod2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxuZXhwb3J0IHZhciBtb2JpbGVPcGVyYSA9IG1vYmlsZSAmJiBvcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtb2JpbGVHZWNrbzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZUdlY2tvID0gbW9iaWxlICYmIGdlY2tvO1xyXG5cclxuLy8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIG9uIGEgaGlnaC1yZXNvbHV0aW9uIFwicmV0aW5hXCIgc2NyZWVuLlxyXG5leHBvcnQgdmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbmV4cG9ydCB2YXIgY2FudmFzID0gKGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0O1xyXG59KCkpO1xyXG5cclxuLy8gQHByb3BlcnR5IHN2ZzogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxyXG5leHBvcnQgdmFyIHN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBzdmdDcmVhdGUoJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbmV4cG9ydCB2YXIgdm1sID0gIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcblxyXG5mdW5jdGlvbiB1c2VyQWdlbnRDb250YWlucyhzdHIpIHtcclxuXHRyZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyKSA+PSAwO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9Ccm93c2VyLmpzIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHthZGRQb2ludGVyTGlzdGVuZXIsIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuaW1wb3J0IHthZGREb3VibGVUYXBMaXN0ZW5lciwgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuRG91YmxlVGFwJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsXHJcbi8vIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBET00gZXZlbnQgZnJvbSB0aGUgZWxlbWVudC5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhbGwga25vd24gZXZlbnQgbGlzdGVuZXJzXHJcbmV4cG9ydCBmdW5jdGlvbiBvZmYob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKHR5cGVzKSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvciAodmFyIGogaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgaiwgb2JqW2V2ZW50c0tleV1bal0pO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cclxuXHRpZiAob2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBmbi5jYWxsKGNvbnRleHQgfHwgb2JqLCBlIHx8IHdpbmRvdy5ldmVudCk7XHJcblx0fTtcclxuXHJcblx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG5cdGlmIChCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHQvLyBOZWVkcyBEb21FdmVudC5Qb2ludGVyLmpzXHJcblx0XHRhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgYWRkRG91YmxlVGFwTGlzdGVuZXIgJiZcclxuXHQgICAgICAgICAgICEoQnJvd3Nlci5wb2ludGVyICYmIEJyb3dzZXIuY2hyb21lKSkge1xyXG5cdFx0Ly8gQ2hyb21lID41NSBkb2VzIG5vdCBuZWVkIHRoZSBzeW50aGV0aWMgZGJsY2xpY2tzIGZyb20gYWRkRG91YmxlVGFwTGlzdGVuZXJcclxuXHRcdC8vIFNlZSAjNTE4MFxyXG5cdFx0YWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0XHRpZiAoaXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcblx0XHRcdFx0XHRvcmlnaW5hbEhhbmRsZXIoZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6ICdtb3VzZW91dCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJyAmJiBCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGZpbHRlckNsaWNrKGUsIG9yaWdpbmFsSGFuZGxlcik7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdHZhciBpZCA9IHR5cGUgKyBVdGlsLnN0YW1wKGZuKSArIChjb250ZXh0ID8gJ18nICsgVXRpbC5zdGFtcChjb250ZXh0KSA6ICcnKSxcclxuXHQgICAgaGFuZGxlciA9IG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXTtcclxuXHJcblx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdGlmIChCcm93c2VyLnBvaW50ZXIgJiYgdHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwKSB7XHJcblx0XHRyZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIpIHtcclxuXHRcdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdvbndoZWVsJyBpbiBvYmogPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOlxyXG5cdFx0XHRcdHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/ICdtb3VzZW91dCcgOiB0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHRza2lwcGVkKGUpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ21vdXNld2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWwpIHtcclxuXHRhZGRPbmUoZWwsICdtb3VzZXdoZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkb3VibGVjbGljaydgLFxyXG4vLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbCkge1xyXG5cdG9uKGVsLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2snLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdGFkZE9uZShlbCwgJ2NsaWNrJywgZmFrZVN0b3ApO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBQcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIERPTSBFdmVudCBgZXZgIGZyb20gaGFwcGVuaW5nIChzdWNoIGFzXHJcbi8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuLy8gd2l0aCBwYWdlIHJlbG9hZCB3aGVuIGEgYDxmb3JtPmAgaXMgc3VibWl0dGVkKS5cclxuLy8gVXNlIGl0IGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlKSB7XHJcblx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3AoZXYpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGNvbnRhaW5lci5jbGllbnRMZWZ0LFxyXG5cdFx0ZS5jbGllbnRZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wKTtcclxufVxyXG5cclxuLy8gQ2hyb21lIG9uIFdpbiBzY3JvbGxzIGRvdWJsZSB0aGUgcGl4ZWxzIGFzIGluIG90aGVyIHBsYXRmb3JtcyAoc2VlICM0NTM4KSxcclxuLy8gYW5kIEZpcmVmb3ggc2Nyb2xscyBkZXZpY2UgcGl4ZWxzLCBub3QgQ1NTIHBpeGVsc1xyXG52YXIgd2hlZWxQeEZhY3RvciA9XHJcblx0KEJyb3dzZXIud2luICYmIEJyb3dzZXIuY2hyb21lKSA/IDIgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6XHJcblx0QnJvd3Nlci5nZWNrbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRXaGVlbERlbHRhKGV2OiBET01FdmVudCk6IE51bWJlclxyXG4vLyBHZXRzIG5vcm1hbGl6ZWQgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNld2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4vLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG5cdHJldHVybiAoQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdCAgICAgICAwO1xyXG59XHJcblxyXG52YXIgc2tpcEV2ZW50cyA9IHt9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZha2VTdG9wKGUpIHtcclxuXHQvLyBmYWtlcyBzdG9wUHJvcGFnYXRpb24gYnkgc2V0dGluZyBhIHNwZWNpYWwgZXZlbnQgZmxhZywgY2hlY2tlZC9yZXNldCB3aXRoIHNraXBwZWQoZSlcclxuXHRza2lwRXZlbnRzW2UudHlwZV0gPSB0cnVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2tpcHBlZChlKSB7XHJcblx0dmFyIGV2ZW50cyA9IHNraXBFdmVudHNbZS50eXBlXTtcclxuXHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IGZhbHNlO1xyXG5cdHJldHVybiBldmVudHM7XHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbFRhcmdldChlbCwgZSkge1xyXG5cclxuXHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdHRyeSB7XHJcblx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG59XHJcblxyXG52YXIgbGFzdENsaWNrO1xyXG5cclxuLy8gdGhpcyBpcyBhIGhvcnJpYmxlIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIEFuZHJvaWQgd2hlcmUgYSBzaW5nbGUgdG91Y2ggdHJpZ2dlcnMgdHdvIGNsaWNrIGV2ZW50c1xyXG5mdW5jdGlvbiBmaWx0ZXJDbGljayhlLCBoYW5kbGVyKSB7XHJcblx0dmFyIHRpbWVTdGFtcCA9IChlLnRpbWVTdGFtcCB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC50aW1lU3RhbXApKSxcclxuXHQgICAgZWxhcHNlZCA9IGxhc3RDbGljayAmJiAodGltZVN0YW1wIC0gbGFzdENsaWNrKTtcclxuXHJcblx0Ly8gYXJlIHRoZXkgY2xvc2VyIHRvZ2V0aGVyIHRoYW4gNTAwbXMgeWV0IG1vcmUgdGhhbiAxMDBtcz9cclxuXHQvLyBBbmRyb2lkIHR5cGljYWxseSB0cmlnZ2VycyB0aGVtIH4zMDBtcyBhcGFydCB3aGlsZSBtdWx0aXBsZSBsaXN0ZW5lcnNcclxuXHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0Ly8gb3IgY2hlY2sgaWYgY2xpY2sgaXMgc2ltdWxhdGVkIG9uIHRoZSBlbGVtZW50LCBhbmQgaWYgaXQgaXMsIHJlamVjdCBhbnkgbm9uLXNpbXVsYXRlZCBldmVudHNcclxuXHJcblx0aWYgKChlbGFwc2VkICYmIGVsYXBzZWQgPiAxMDAgJiYgZWxhcHNlZCA8IDUwMCkgfHwgKGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayAmJiAhZS5fc2ltdWxhdGVkKSkge1xyXG5cdFx0c3RvcChlKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0bGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRoYW5kbGVyKGUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub25gXSgjZG9tZXZlbnQtb24pXHJcbmV4cG9ydCB7b24gYXMgYWRkTGlzdGVuZXJ9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9mZmBdKCNkb21ldmVudC1vZmYpXHJcbmV4cG9ydCB7b2ZmIGFzIHJlbW92ZUxpc3RlbmVyfTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tRXZlbnQuanMiLCJpbXBvcnQgeyBMZWdhY3lFbGVtZW50TWl4aW4gfSBmcm9tICcuL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uanMnO1xuaW1wb3J0ICcuL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgJy4vbGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4vbGliL2VsZW1lbnRzL2RvbS1iaW5kLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5qcyc7XG5pbXBvcnQgJy4vbGliL2VsZW1lbnRzL2RvbS1pZi5qcyc7XG5pbXBvcnQgJy4vbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmpzJztcbmltcG9ydCAnLi9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5qcyc7XG5leHBvcnQgY29uc3QgQmFzZSA9IExlZ2FjeUVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCkucHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL3BvbHltZXIuanMiLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xyXG5pbXBvcnQge0VQU0czODU3fSBmcm9tICcuLi9nZW8vY3JzL0NSUy5FUFNHMzg1Nyc7XHJcbmltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtCb3VuZHMsIHRvQm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1Bvc0FuaW1hdGlvbn0gZnJvbSAnLi4vZG9tL1Bvc0FuaW1hdGlvbic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFwXHJcbiAqIEBha2EgTC5NYXBcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogVGhlIGNlbnRyYWwgY2xhc3Mgb2YgdGhlIEFQSSDigJQgaXQgaXMgdXNlZCB0byBjcmVhdGUgYSBtYXAgb24gYSBwYWdlIGFuZCBtYW5pcHVsYXRlIGl0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBpbml0aWFsaXplIHRoZSBtYXAgb24gdGhlIFwibWFwXCIgZGl2IHdpdGggYSBnaXZlbiBjZW50ZXIgYW5kIHpvb21cclxuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XHJcbiAqIFx0Y2VudGVyOiBbNTEuNTA1LCAtMC4wOV0sXHJcbiAqIFx0em9vbTogMTNcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFwID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9ICpcclxuXHRcdC8vIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCBhbmQgYXQgbGVhc3Qgb25lIGBHcmlkTGF5ZXJgIG9yIGBUaWxlTGF5ZXJgIGlzIGluIHRoZSBtYXAsXHJcblx0XHQvLyB0aGUgbG93ZXN0IG9mIHRoZWlyIGBtaW5ab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWluWm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBoaWdoZXN0IG9mIHRoZWlyIGBtYXhab29tYCBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbGF5ZXJzOiBMYXllcltdID0gW11cclxuXHRcdC8vIEFycmF5IG9mIGxheWVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCBpbml0aWFsbHlcclxuXHRcdGxheWVyczogW10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhCb3VuZHM6IExhdExuZ0JvdW5kcyA9IG51bGxcclxuXHRcdC8vIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0LCB0aGUgbWFwIHJlc3RyaWN0cyB0aGUgdmlldyB0byB0aGUgZ2l2ZW5cclxuXHRcdC8vIGdlb2dyYXBoaWNhbCBib3VuZHMsIGJvdW5jaW5nIHRoZSB1c2VyIGJhY2sgaWYgdGhlIHVzZXIgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIHpvb20gYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxyXG5cdFx0Ly8gV29uJ3QgYW5pbWF0ZSB6b29tIGlmIHRoZSB6b29tIGRpZmZlcmVuY2UgZXhjZWVkcyB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbUFuaW1hdGlvblRocmVzaG9sZDogNCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZhZGVBbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB0aWxlIGZhZGUgYW5pbWF0aW9uIGlzIGVuYWJsZWQuIEJ5IGRlZmF1bHQgaXQncyBlbmFibGVkXHJcblx0XHQvLyBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRmYWRlQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWFya2VyWm9vbUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgbWFya2VycyBhbmltYXRlIHRoZWlyIHpvb20gd2l0aCB0aGUgem9vbSBhbmltYXRpb24sIGlmIGRpc2FibGVkXHJcblx0XHQvLyB0aGV5IHdpbGwgZGlzYXBwZWFyIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBhbmltYXRpb24uIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdFx0Ly8gZW5hYmxlZCBpbiBhbGwgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUzMgVHJhbnNpdGlvbnMgZXhjZXB0IEFuZHJvaWQuXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNmb3JtM0RMaW1pdDogTnVtYmVyID0gMl4yM1xyXG5cdFx0Ly8gRGVmaW5lcyB0aGUgbWF4aW11bSBzaXplIG9mIGEgQ1NTIHRyYW5zbGF0aW9uIHRyYW5zZm9ybS4gVGhlIGRlZmF1bHRcclxuXHRcdC8vIHZhbHVlIHNob3VsZCBub3QgYmUgY2hhbmdlZCB1bmxlc3MgYSB3ZWIgYnJvd3NlciBwb3NpdGlvbnMgbGF5ZXJzIGluXHJcblx0XHQvLyB0aGUgd3JvbmcgcGxhY2UgYWZ0ZXIgZG9pbmcgYSBsYXJnZSBgcGFuQnlgLlxyXG5cdFx0dHJhbnNmb3JtM0RMaW1pdDogODM4ODYwOCwgLy8gUHJlY2lzaW9uIGxpbWl0IG9mIGEgMzItYml0IGZsb2F0XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiB6b29tU25hcDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gRm9yY2VzIHRoZSBtYXAncyB6b29tIGxldmVsIHRvIGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIHRoaXMsIHBhcnRpY3VsYXJseVxyXG5cdFx0Ly8gcmlnaHQgYWZ0ZXIgYSBbYGZpdEJvdW5kcygpYF0oI21hcC1maXRib3VuZHMpIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIHRoZSB6b29tIGxldmVsIHNuYXBzIHRvIHRoZSBuZWFyZXN0IGludGVnZXI7IGxvd2VyIHZhbHVlc1xyXG5cdFx0Ly8gKGUuZy4gYDAuNWAgb3IgYDAuMWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LiBBIHZhbHVlIG9mIGAwYFxyXG5cdFx0Ly8gbWVhbnMgdGhlIHpvb20gbGV2ZWwgd2lsbCBub3QgYmUgc25hcHBlZCBhZnRlciBgZml0Qm91bmRzYCBvciBhIHBpbmNoLXpvb20uXHJcblx0XHR6b29tU25hcDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21EZWx0YTogTnVtYmVyID0gMVxyXG5cdFx0Ly8gQ29udHJvbHMgaG93IG11Y2ggdGhlIG1hcCdzIHpvb20gbGV2ZWwgd2lsbCBjaGFuZ2UgYWZ0ZXIgYVxyXG5cdFx0Ly8gW2B6b29tSW4oKWBdKCNtYXAtem9vbWluKSwgW2B6b29tT3V0KClgXSgjbWFwLXpvb21vdXQpLCBwcmVzc2luZyBgK2BcclxuXHRcdC8vIG9yIGAtYCBvbiB0aGUga2V5Ym9hcmQsIG9yIHVzaW5nIHRoZSBbem9vbSBjb250cm9sc10oI2NvbnRyb2wtem9vbSkuXHJcblx0XHQvLyBWYWx1ZXMgc21hbGxlciB0aGFuIGAxYCAoZS5nLiBgMC41YCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuXHJcblx0XHR6b29tRGVsdGE6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFja1Jlc2l6ZTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcCBhdXRvbWF0aWNhbGx5IGhhbmRsZXMgYnJvd3NlciB3aW5kb3cgcmVzaXplIHRvIHVwZGF0ZSBpdHNlbGYuXHJcblx0XHR0cmFja1Jlc2l6ZTogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykgeyAvLyAoSFRNTEVsZW1lbnQgb3IgU3RyaW5nLCBPYmplY3QpXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gVXRpbC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gRG9tVXRpbC5UUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuXHRcdFx0RG9tRXZlbnQub24odGhpcy5fcHJveHksIERvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuXHRcdFx0XHRvcHRpb25zLnBhbiA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcblx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuXHRcdFx0aWYgKG1vdmVkKSB7XHJcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbSh6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHpvb20gb2YgdGhlIG1hcC5cclxuXHRzZXRab29tOiBmdW5jdGlvbiAoem9vbSwgb3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbUluKGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIEluY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gLSBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgZ2VvZ3JhcGhpY2FsIHBvaW50IG9uIHRoZSBtYXBcclxuXHQvLyBzdGF0aW9uYXJ5IChlLmcuIHVzZWQgaW50ZXJuYWxseSBmb3Igc2Nyb2xsIHpvb20gYW5kIGRvdWJsZS1jbGljayB6b29tKS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQob2Zmc2V0OiBQb2ludCwgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIHBpeGVsIG9uIHRoZSBtYXAgKHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIpIHN0YXRpb25hcnkuXHJcblx0c2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICBjb250YWluZXJQb2ludCA9IGxhdGxuZyBpbnN0YW5jZW9mIFBvaW50ID8gbGF0bG5nIDogdGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZyksXHJcblxyXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGNvbnRhaW5lclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKS5tdWx0aXBseUJ5KDEgLSAxIC8gc2NhbGUpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyh2aWV3SGFsZi5hZGQoY2VudGVyT2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhuZXdDZW50ZXIsIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0X2dldEJvdW5kc0NlbnRlclpvb206IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGJvdW5kcyA9IGJvdW5kcy5nZXRCb3VuZHMgPyBib3VuZHMuZ2V0Qm91bmRzKCkgOiB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nVEwgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ1RvcExlZnQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdCb3R0b21SaWdodCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHJcblx0XHQgICAgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMsIGZhbHNlLCBwYWRkaW5nVEwuYWRkKHBhZGRpbmdCUikpO1xyXG5cclxuXHRcdHpvb20gPSAodHlwZW9mIG9wdGlvbnMubWF4Wm9vbSA9PT0gJ251bWJlcicpID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0aWYgKHpvb20gPT09IEluZmluaXR5KSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Y2VudGVyOiBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHRcdFx0em9vbTogem9vbVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlbiBnZW9ncmFwaGljYWwgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gbWF4aW11bSB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignQm91bmRzIGFyZSBub3QgdmFsaWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0V29ybGQob3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgYSBtYXAgdmlldyB0aGF0IG1vc3RseSBjb250YWlucyB0aGUgd2hvbGUgd29ybGQgd2l0aCB0aGUgbWF4aW11bVxyXG5cdC8vIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0V29ybGQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maXRCb3VuZHMoW1stOTAsIC0xODBdLCBbOTAsIDE4MF1dLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhblRvKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIGEgZ2l2ZW4gY2VudGVyLlxyXG5cdHBhblRvOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7IC8vIChMYXRMbmcpXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KGNlbnRlciwgdGhpcy5fem9vbSwge3Bhbjogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuQnkob2Zmc2V0OiBQb2ludCwgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG5cdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcclxuXHRcdC8vIGFuZCBtYWtlcyB0aGVtIGRpc2FwcGVhciBvciBhcHBlYXIgaW4gdGhlIHdyb25nIHBsYWNlIChzbGlnaHRseSBvZmZzZXQpICMyNjAyXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltID0gbmV3IFBvc0FuaW1hdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XHJcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG5cdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHJcblx0XHRcdHZhciBuZXdQb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZseVRvKGxhdGxuZzogTGF0TG5nLCB6b29tPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHBlcmZvcm1pbmcgYSBzbW9vdGhcclxuXHQvLyBwYW4tem9vbSBhbmltYXRpb24uXHJcblx0Zmx5VG86IGZ1bmN0aW9uICh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8ICFCcm93c2VyLmFueTNkKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFZpZXcodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXHJcblx0XHQgICAgdG8gPSB0aGlzLnByb2plY3QodGFyZ2V0Q2VudGVyKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcclxuXHJcblx0XHR0YXJnZXRDZW50ZXIgPSB0b0xhdExuZyh0YXJnZXRDZW50ZXIpO1xyXG5cdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XHJcblxyXG5cdFx0dmFyIHcwID0gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpLFxyXG5cdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxyXG5cdFx0ICAgIHUxID0gKHRvLmRpc3RhbmNlVG8oZnJvbSkpIHx8IDEsXHJcblx0XHQgICAgcmhvID0gMS40MixcclxuXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHIoaSkge1xyXG5cdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxyXG5cdFx0XHQgICAgczIgPSBpID8gdzEgOiB3MCxcclxuXHRcdFx0ICAgIHQxID0gdzEgKiB3MSAtIHcwICogdzAgKyBzMSAqIHJobzIgKiByaG8yICogdTEgKiB1MSxcclxuXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxyXG5cdFx0XHQgICAgYiA9IHQxIC8gYjEsXHJcblx0XHRcdCAgICBzcSA9IE1hdGguc3FydChiICogYiArIDEpIC0gYjtcclxuXHJcblx0XHRcdCAgICAvLyB3b3JrYXJvdW5kIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gYnVnIHdoZW4gc3EgPSAwLCBsb2cgPSAtSW5maW5pdGUsXHJcblx0XHRcdCAgICAvLyB0aHVzIHRyaWdnZXJpbmcgYW4gaW5maW5pdGUgbG9vcCBpbiBmbHlUb1xyXG5cdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbG9nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cclxuXHRcdGZ1bmN0aW9uIHRhbmgobikgeyByZXR1cm4gc2luaChuKSAvIGNvc2gobik7IH1cclxuXHJcblx0XHR2YXIgcjAgPSByKDApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHcocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgLyBjb3NoKHIwICsgcmhvICogcykpOyB9XHJcblx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxyXG5cclxuXHRcdGZ1bmN0aW9uIGVhc2VPdXQodCkgeyByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCAxLjUpOyB9XHJcblxyXG5cdFx0dmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBTID0gKHIoMSkgLSByMCkgLyByaG8sXHJcblx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcclxuXHJcblx0XHRmdW5jdGlvbiBmcmFtZSgpIHtcclxuXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxyXG5cdFx0XHQgICAgcyA9IGVhc2VPdXQodCkgKiBTO1xyXG5cclxuXHRcdFx0aWYgKHQgPD0gMSkge1xyXG5cdFx0XHRcdHRoaXMuX2ZseVRvRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9tb3ZlKFxyXG5cdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NhbGVab29tKHcwIC8gdyhzKSwgc3RhcnRab29tKSxcclxuXHRcdFx0XHRcdHtmbHlUbzogdHJ1ZX0pO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzXHJcblx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxyXG5cdFx0XHRcdFx0Ll9tb3ZlRW5kKHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92ZVN0YXJ0KHRydWUpO1xyXG5cclxuXHRcdGZyYW1lLmNhbGwodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZseVRvQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxyXG5cdC8vIGJ1dCB0YWtlcyBhIGJvdW5kcyBwYXJhbWV0ZXIgbGlrZSBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuXHRmbHlUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcclxuXHRcdHJldHVybiB0aGlzLmZseVRvKHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IEJvdW5kcyk6IHRoaXNcclxuXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcblx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCB0b0xhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcblx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG5cdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcblx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcblx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBHZW9sb2NhdGlvbiBtZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBsb2NhdGUob3B0aW9ucz86IExvY2F0ZSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFRyaWVzIHRvIGxvY2F0ZSB0aGUgdXNlciB1c2luZyB0aGUgR2VvbG9jYXRpb24gQVBJLCBmaXJpbmcgYSBbYGxvY2F0aW9uZm91bmRgXSgjbWFwLWxvY2F0aW9uZm91bmQpXHJcblx0Ly8gZXZlbnQgd2l0aCBsb2NhdGlvbiBkYXRhIG9uIHN1Y2Nlc3Mgb3IgYSBbYGxvY2F0aW9uZXJyb3JgXSgjbWFwLWxvY2F0aW9uZXJyb3IpIGV2ZW50IG9uIGZhaWx1cmUsXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2V0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIHVzZXIncyBsb2NhdGlvbiB3aXRoIHJlc3BlY3QgdG9cclxuXHQvLyBkZXRlY3Rpb24gYWNjdXJhY3kgKG9yIHRvIHRoZSB3b3JsZCB2aWV3IGlmIGdlb2xvY2F0aW9uIGZhaWxlZCkuXHJcblx0Ly8gTm90ZSB0aGF0LCBpZiB5b3VyIHBhZ2UgZG9lc24ndCB1c2UgSFRUUFMsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpblxyXG5cdC8vIG1vZGVybiBicm93c2VycyAoW0Nocm9tZSA1MCBhbmQgbmV3ZXJdKGh0dHBzOi8vc2l0ZXMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9kZXYvSG9tZS9jaHJvbWl1bS1zZWN1cml0eS9kZXByZWNhdGluZy1wb3dlcmZ1bC1mZWF0dXJlcy1vbi1pbnNlY3VyZS1vcmlnaW5zKSlcclxuXHQvLyBTZWUgYExvY2F0ZSBvcHRpb25zYCBmb3IgbW9yZSBkZXRhaWxzLlxyXG5cdGxvY2F0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0dGltZW91dDogMTAwMDAsXHJcblx0XHRcdHdhdGNoOiBmYWxzZVxyXG5cdFx0XHQvLyBzZXRWaWV3OiBmYWxzZVxyXG5cdFx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG5cdFx0XHQvLyBtYXhpbXVtQWdlOiAwXHJcblx0XHRcdC8vIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gVXRpbC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0ICAgIG9uRXJyb3IgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTGF0TG5nKGxhdCwgbG5nKSxcclxuXHRcdCAgICBib3VuZHMgPSBsYXRsbmcudG9Cb3VuZHMocG9zLmNvb3Jkcy5hY2N1cmFjeSksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBoYW5kbGVyLmFkZFRvXHJcblx0Ly8gVE9ETyBBcHByb3BpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qZXNsaW50LWVuYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcblx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG5cdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcblx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBVdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvciBvdmVybGF5cyAoYFBhdGhgcyksIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG5cdFx0Ly8gUGFuZSBmb3IgdG9vbHRpcC5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGFuZXMubWFya2VyUGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGFuZXMuc2hhZG93UGFuZSwgJ2xlYWZsZXQtem9vbS1oaWRlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyB0aGF0IG1vZGlmeSBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBQb2ludCgwLCAwKSk7XHJcblxyXG5cdFx0dmFyIGxvYWRpbmcgPSAhdGhpcy5fbG9hZGVkO1xyXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcclxuXHRcdHpvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cHJlcmVzZXQnKTtcclxuXHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cdFx0dGhpc1xyXG5cdFx0XHQuX21vdmVTdGFydCh6b29tQ2hhbmdlZClcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgem9vbSBpcyBhYm91dCB0byBjaGFuZ2UgKGUuZy4gYmVmb3JlIHpvb20gYW5pbWF0aW9uKS5cclxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWV3IG9mIHRoZSBtYXAgc3RhcnRzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgZGF0YSkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IGNoYW5nZSBpbiB6b29tIGxldmVsLCBpbmNsdWRpbmcgem9vbVxyXG5cdFx0Ly8gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBtb3ZlbWVudCBvZiB0aGUgbWFwLCBpbmNsdWRpbmcgcGFuIGFuZFxyXG5cdFx0Ly8gZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVFbmQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21lbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaGFzIGNoYW5nZWQsIGFmdGVyIGFueSBhbmltYXRpb25zLlxyXG5cdFx0aWYgKHpvb21DaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgY2VudGVyIG9mIHRoZSBtYXAgc3RvcHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdG9wcGVkXHJcblx0XHQvLyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfc3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmx5VG9GcmFtZSk7XHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yYXdQYW5CeTogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdHRoaXMuX3RhcmdldHMgPSB7fTtcclxuXHRcdHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcCh0aGlzLl9jb250YWluZXIpXSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gRG9tRXZlbnQub2ZmIDogRG9tRXZlbnQub247XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAob3IgdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBkYmxjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIChvciBkb3VibGUtdGFwcykgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZWRvd246IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZXVwOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gb24gdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW92ZXI6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3V0OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW1vdmU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoaWxlIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgY29udGV4dG1lbnU6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHVzaGVzIHRoZSByaWdodCBtb3VzZSBidXR0b24gb24gdGhlIG1hcCwgcHJldmVudHNcclxuXHRcdC8vIGRlZmF1bHQgYnJvd3NlciBjb250ZXh0IG1lbnUgZnJvbSBzaG93aW5nIGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMgb25cclxuXHRcdC8vIHRoaXMgZXZlbnQuIEFsc28gZmlyZWQgb24gbW9iaWxlIHdoZW4gdGhlIHVzZXIgaG9sZHMgYSBzaW5nbGUgdG91Y2hcclxuXHRcdC8vIGZvciBhIHNlY29uZCAoYWxzbyBjYWxsZWQgbG9uZyBwcmVzcykuXHJcblx0XHQvLyBAZXZlbnQga2V5cHJlc3M6IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVET01FdmVudCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50cmFja1Jlc2l6ZSkge1xyXG5cdFx0XHRvbk9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QgJiYgdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0KHJlbW92ZSA/IHRoaXMub2ZmIDogdGhpcy5vbikuY2FsbCh0aGlzLCAnbW92ZWVuZCcsIHRoaXMuX29uTW92ZUVuZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgIWUuX3NpbXVsYXRlZCAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcblx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcblx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiBEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHtcclxuXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IERvbUV2ZW50LnNraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nIHx8IHR5cGUgPT09ICdrZXlwcmVzcycpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X21vdXNlRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddLFxyXG5cclxuXHRfZmlyZURPTUV2ZW50OiBmdW5jdGlvbiAoZSwgdHlwZSwgdGFyZ2V0cykge1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcclxuXHRcdFx0Ly8gRmlyZSBhIHN5bnRoZXRpYyAncHJlY2xpY2snIGV2ZW50IHdoaWNoIHByb3BhZ2F0ZXMgdXAgKG1haW5seSBmb3IgY2xvc2luZyBwb3B1cHMpLlxyXG5cdFx0XHQvLyBAZXZlbnQgcHJlY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgYmVmb3JlIG1vdXNlIGNsaWNrIG9uIHRoZSBtYXAgKHNvbWV0aW1lcyB1c2VmdWwgd2hlbiB5b3VcclxuXHRcdFx0Ly8gd2FudCBzb21ldGhpbmcgdG8gaGFwcGVuIG9uIGNsaWNrIGJlZm9yZSBhbnkgZXhpc3RpbmcgY2xpY2tcclxuXHRcdFx0Ly8gaGFuZGxlcnMgc3RhcnQgcnVubmluZykuXHJcblx0XHRcdHZhciBzeW50aCA9IFV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycpIHtcclxuXHRcdFx0dmFyIGlzTWFya2VyID0gKHRhcmdldC5vcHRpb25zICYmICdpY29uJyBpbiB0YXJnZXQub3B0aW9ucyk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0XHR0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGFyZ2V0LmdldExhdExuZygpKSA6IHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XHJcblx0XHRcdGRhdGEubGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoZGF0YS5jb250YWluZXJQb2ludCk7XHJcblx0XHRcdGRhdGEubGF0bG5nID0gaXNNYXJrZXIgPyB0YXJnZXQuZ2V0TGF0TG5nKCkgOiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhkYXRhLmxheWVyUG9pbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIFV0aWwuaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuXHRcdF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChvZmZzZXQucm91bmQoKS5lcXVhbHMoWzAsIDBdKSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9mbG9vcigpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBEb21VdGlsLlRSQU5TRk9STSxcclxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBjID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wcm94eSk7XHJcblx0XHRkZWxldGUgdGhpcy5fcHJveHk7XHJcblx0fSxcclxuXHJcblx0X2NhdGNoVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tICYmIGUucHJvcGVydHlOYW1lLmluZGV4T2YoJ3RyYW5zZm9ybScpID49IDApIHtcclxuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub3RoaW5nVG9BbmltYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKS5sZW5ndGg7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiBkaXNhYmxlZCwgbm90IHN1cHBvcnRlZCBvciB6b29tIGRpZmZlcmVuY2UgaXMgdG9vIGxhcmdlXHJcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh6b29tIC0gdGhpcy5fem9vbSkgPiB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZGl2aWRlQnkoMSAtIDEgLyBzY2FsZSk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBpZiB0aGUgem9vbSBvcmlnaW4gaXNuJ3Qgd2l0aGluIG9uZSBzY3JlZW4gZnJvbSB0aGUgY3VycmVudCBjZW50ZXIsIHVubGVzcyBmb3JjZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLl9tb3ZlU3RhcnQodHJ1ZSlcclxuXHRcdFx0ICAgIC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgc3RhcnRBbmltLCBub1VwZGF0ZSkge1xyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuXHRcdC8vIEZpcmVkIG9uIGV2ZXJ5IGZyYW1lIG9mIGEgem9vbSBhbmltYXRpb25cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG5cdH0sXHJcblxyXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xyXG5cclxuXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvTWFwLmpzIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi54ICsgdGhpcy5tYXgueCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueSArIHRoaXMubWF4LnkpIC8gMiwgcm91bmQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1pbi54LCB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcFJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0VG9wUmlnaHQ6IGZ1bmN0aW9uICgpIHsgLy8gLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMubWluICYmIHRoaXMubWF4KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMoY29ybmVyMTogUG9pbnQsIGNvcm5lcjI6IFBvaW50KVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHR3byBjb3JuZXJzIGNvb3JkaW5hdGUgcGFpcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgQm91bmRzKGEsIGIpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvQm91bmRzLmpzIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0VhcnRofSBmcm9tICcuL2Nycy9DUlMuRWFydGgnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcsIGFsdCkge1xyXG5cdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG5cdH1cclxuXHJcblx0Ly8gQHByb3BlcnR5IGxhdDogTnVtYmVyXHJcblx0Ly8gTGF0aXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubGF0ID0gK2xhdDtcclxuXHJcblx0Ly8gQHByb3BlcnR5IGxuZzogTnVtYmVyXHJcblx0Ly8gTG9uZ2l0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxuZyA9ICtsbmc7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBhbHQ6IE51bWJlclxyXG5cdC8vIEFsdGl0dWRlIGluIG1ldGVycyAob3B0aW9uYWwpXHJcblx0aWYgKGFsdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR0aGlzLmFsdCA9ICthbHQ7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmcucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyTGF0TG5nOiBMYXRMbmcsIG1heE1hcmdpbj86IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gYExhdExuZ2AgcG9pbnQgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gKHdpdGhpbiBhIHNtYWxsIG1hcmdpbiBvZiBlcnJvcikuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW0hhdmVyc2luZSBmb3JtdWxhXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL0xhdExuZy5qcyIsImltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi9MYXRMbmcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghY29ybmVyMSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIGxhdGxuZ3MgPSBjb3JuZXIyID8gW2Nvcm5lcjEsIGNvcm5lcjJdIDogY29ybmVyMTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnRcclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBleHRlbmQob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHNcclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRcdHN3MiA9IG9iajtcclxuXHRcdFx0bmUyID0gb2JqO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG5cdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcblx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQodG9MYXRMbmcob2JqKSB8fCB0b0xhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IExhdExuZyhzdzIubGF0LCBzdzIubG5nKTtcclxuXHRcdFx0dGhpcy5fbm9ydGhFYXN0ID0gbmV3IExhdExuZyhuZTIubGF0LCBuZTIubG5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3LmxhdCA9IE1hdGgubWluKHN3Mi5sYXQsIHN3LmxhdCk7XHJcblx0XHRcdHN3LmxuZyA9IE1hdGgubWluKHN3Mi5sbmcsIHN3LmxuZyk7XHJcblx0XHRcdG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XHJcblx0XHRcdG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYWQoYnVmZmVyUmF0aW86IE51bWJlcik6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYmlnZ2VyIGJvdW5kcyBjcmVhdGVkIGJ5IGV4dGVuZGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiBwZXJjZW50YWdlIGluIGVhY2ggZGlyZWN0aW9uLlxyXG5cdHBhZDogZnVuY3Rpb24gKGJ1ZmZlclJhdGlvKSB7XHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKHN3LmxhdCAtIGhlaWdodEJ1ZmZlciwgc3cubG5nIC0gd2lkdGhCdWZmZXIpLFxyXG5cdFx0ICAgICAgICBuZXcgTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldE5vcnRoKCksIHRoaXMuZ2V0V2VzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0U291dGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFdlc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgd2VzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldFNvdXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVhc3QoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZWFzdCBsb25naXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGgoKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGggbGF0aXR1ZGUgb2YgdGhlIGJvdW5kc1xyXG5cdGdldE5vcnRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zIChsYXRsbmc6IExhdExuZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTGF0TG5nIHx8ICdsYXQnIGluIG9iaikge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9MYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0XHRzdzIgPSBvYmouZ2V0U291dGhXZXN0KCk7XHJcblx0XHRcdG5lMiA9IG9iai5nZXROb3J0aEVhc3QoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN3MiA9IG5lMiA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKHN3Mi5sYXQgPj0gc3cubGF0KSAmJiAobmUyLmxhdCA8PSBuZS5sYXQpICYmXHJcblx0XHQgICAgICAgKHN3Mi5sbmcgPj0gc3cubG5nKSAmJiAobmUyLmxuZyA8PSBuZS5sbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRJbnRlcnNlY3RzID0gKG5lMi5sYXQgPj0gc3cubGF0KSAmJiAoc3cyLmxhdCA8PSBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ0ludGVyc2VjdHMgPSAobmUyLmxuZyA+PSBzdy5sbmcpICYmIChzdzIubG5nIDw9IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdEludGVyc2VjdHMgJiYgbG5nSW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdE92ZXJsYXBzID0gKG5lMi5sYXQgPiBzdy5sYXQpICYmIChzdzIubGF0IDwgbmUubGF0KSxcclxuXHRcdCAgICBsbmdPdmVybGFwcyA9IChuZTIubG5nID4gc3cubG5nKSAmJiAoc3cyLmxuZyA8IG5lLmxuZyk7XHJcblxyXG5cdFx0cmV0dXJuIGxhdE92ZXJsYXBzICYmIGxuZ092ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9CQm94U3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgd2l0aCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gYSAnc291dGh3ZXN0X2xuZyxzb3V0aHdlc3RfbGF0LG5vcnRoZWFzdF9sbmcsbm9ydGhlYXN0X2xhdCcgZm9ybWF0LiBVc2VmdWwgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gd2ViIHNlcnZpY2VzIHRoYXQgcmV0dXJuIGdlbyBkYXRhLlxyXG5cdHRvQkJveFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIFt0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSwgdGhpcy5nZXROb3J0aCgpXS5qb2luKCcsJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKSB0byB0aGUgZ2l2ZW4gYm91bmRzLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9MYXRMbmdCb3VuZHMuanMiLCJpbXBvcnQgeyBFbGVtZW50TWl4aW4gfSBmcm9tICcuL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmdcbiAqIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLCBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLFxuICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQHBvbHltZXJcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAqICAga2V5IG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsXG4gKiAgIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb25cbiAqL1xuY29uc3QgRWxlbWVudCA9IEVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCk7XG5leHBvcnQgeyBFbGVtZW50IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLk1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSwgZS5nLiBcIsKpIE1hcGJveFwiLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChVdGlsLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyB1bmlxdWUgZ2xvYmFsIGlkIGZvciBkZWR1cGluZyBtaXhpbnMuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBNaXhpbkZ1bmN0aW9uKCl7fVxuLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG5NaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluQXBwbGljYXRpb25zO1xuLyoqIEB0eXBlIHsoT2JqZWN0IHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbmV4cG9ydCBjb25zdCBkZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgbGV0IG1peGluQXBwbGljYXRpb25zID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIGlmICghbWl4aW5BcHBsaWNhdGlvbnMpIHtcbiAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnMgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgfVxuICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICBsZXQgbWl4aW5EZWR1cGVJZCA9IGRlZHVwZUlkKys7XG4gIGZ1bmN0aW9uIGRlZHVwaW5nTWl4aW4oYmFzZSkge1xuICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICBpZiAoYmFzZVNldCAmJiBiYXNlU2V0W21peGluRGVkdXBlSWRdKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgbGV0IG1hcCA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIGxldCBleHRlbmRlZCA9IG1hcC5nZXQoYmFzZSk7XG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgZXh0ZW5kZWQgPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8obWl4aW4pKGJhc2UpO1xuICAgICAgbWFwLnNldChiYXNlLCBleHRlbmRlZCk7XG4gICAgfVxuICAgIC8vIGNvcHkgaW5oZXJpdGVkIG1peGluIHNldCBmcm9tIHRoZSBleHRlbmRlZCBjbGFzcywgb3IgdGhlIGJhc2UgY2xhc3NcbiAgICAvLyBOT1RFOiB3ZSBhdm9pZCB1c2Ugb2YgU2V0IGhlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXIgKElFMTEpXG4gICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgbGV0IG1peGluU2V0ID0gT2JqZWN0LmNyZWF0ZSgvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCB8fCBiYXNlU2V0IHx8IG51bGwpO1xuICAgIG1peGluU2V0W21peGluRGVkdXBlSWRdID0gdHJ1ZTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfVxuXG4gIHJldHVybiBkZWR1cGluZ01peGluO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanMiLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0hhbmRsZXIuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8qKiBAdHlwZWRlZiB7e3J1bjogZnVuY3Rpb24oZnVuY3Rpb24oKSwgbnVtYmVyPSk6bnVtYmVyLCBjYW5jZWw6IGZ1bmN0aW9uKG51bWJlcil9fSAqL1xubGV0IEFzeW5jSW50ZXJmYWNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8vIE1pY3JvdGFzayBpbXBsZW1lbnRlZCB1c2luZyBNdXRhdGlvbiBPYnNlcnZlclxubGV0IG1pY3JvdGFza0N1cnJIYW5kbGUgPSAwO1xubGV0IG1pY3JvdGFza0xhc3RIYW5kbGUgPSAwO1xubGV0IG1pY3JvdGFza0NhbGxiYWNrcyA9IFtdO1xubGV0IG1pY3JvdGFza05vZGVDb250ZW50ID0gMDtcbmxldCBtaWNyb3Rhc2tOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xubmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG1pY3JvdGFza0ZsdXNoKS5vYnNlcnZlKG1pY3JvdGFza05vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0ZsdXNoKCkge1xuICBjb25zdCBsZW4gPSBtaWNyb3Rhc2tDYWxsYmFja3MubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IGNiID0gbWljcm90YXNrQ2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGU7IH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBtaWNyb3Rhc2tDYWxsYmFja3Muc3BsaWNlKDAsIGxlbik7XG4gIG1pY3JvdGFza0xhc3RIYW5kbGUgKz0gbGVuO1xufVxuXG5leHBvcnQgY29uc3QgdGltZU91dCA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdWItbW9kdWxlIHdpdGggdGhlIGFzeW5jIGludGVyZmFjZSBwcm92aWRpbmcgdGhlIHByb3ZpZGVkXG4gICAqIGRlbGF5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgY2FsbGJhY2tzIGluIG1zXG4gICAqIEByZXR1cm4ge0FzeW5jSW50ZXJmYWNlfSBBbiBhc3luYyB0aW1lb3V0IGludGVyZmFjZVxuICAgKi9cbiAgYWZ0ZXIoZGVsYXkpIHtcbiAgICByZXR1cm4gIHtcbiAgICAgIHJ1bihmbikgeyByZXR1cm4gc2V0VGltZW91dChmbiwgZGVsYXkpOyB9LFxuICAgICAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBpbiB0aGUgbmV4dCB0YXNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuOiB3aW5kb3cuc2V0VGltZW91dC5iaW5kKHdpbmRvdyksXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgdGltZU91dGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbn07XG5cbmV4cG9ydCBjb25zdCBhbmltYXRpb25GcmFtZSA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuYW5pbWF0aW9uRnJhbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW46IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpLFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsOiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG59O1xuXG5leHBvcnQgY29uc3QgaWRsZVBlcmlvZCA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmlkbGVQZXJpb2RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihJZGxlRGVhZGxpbmUpfSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihmbikge1xuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA/XG4gICAgICB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayhmbikgOlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZm4sIDE2KTtcbiAgfSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBpZGxlUGVyaW9kYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgP1xuICAgICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayhoYW5kbGUpIDpcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG1pY3JvVGFzayA9IHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgbWljcm90YXNrIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGNhbGxiYWNrKSB7XG4gICAgbWljcm90YXNrTm9kZS50ZXh0Q29udGVudCA9IG1pY3JvdGFza05vZGVDb250ZW50Kys7XG4gICAgbWljcm90YXNrQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBtaWNyb3Rhc2tDdXJySGFuZGxlKys7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBtaWNyb1Rhc2tgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICBjb25zdCBpZHggPSBoYW5kbGUgLSBtaWNyb3Rhc2tMYXN0SGFuZGxlO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaWYgKCFtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXN5bmMgaGFuZGxlOiAnICsgaGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIG1pY3JvdGFza0NhbGxiYWNrc1tpZHhdID0gbnVsbDtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXN5bmMuanMiLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbmV4cG9ydCB2YXIgRWFydGggPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgYSA9IE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0MikgK1xuXHRcdCAgICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCk7XG5cblx0XHRyZXR1cm4gdGhpcy5SICogTWF0aC5hY29zKE1hdGgubWluKGEsIDEpKTtcblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVhcnRoLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB9IGZyb20gJy4uL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBmbHVzaCBhcyBmbHVzaCQwLCBlbnF1ZXVlRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZmx1c2guanMnO1xuXG5jb25zdCBwID0gRWxlbWVudC5wcm90b3R5cGU7XG4vKipcbiAqIEBjb25zdCB7ZnVuY3Rpb24odGhpczpFbGVtZW50LCBzdHJpbmcpOiBib29sZWFufVxuICovXG5jb25zdCBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yID0gcC5tYXRjaGVzIHx8IHAubWF0Y2hlc1NlbGVjdG9yIHx8XG4gIHAubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHAubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5vTWF0Y2hlc1NlbGVjdG9yIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGBlbGVtZW50Lm1hdGNoZXNgIHNoaW0uXG4gKlxuICogQGZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvclxuICogQG1lbWJlcm9mIFBvbHltZXIuZG9tXG4gKiBAcGFyYW0geyFFbGVtZW50fSBub2RlIE5vZGUgdG8gY2hlY2sgc2VsZWN0b3IgYWdhaW5zdFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIG1hdGNoXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG5vZGUgbWF0Y2hlZCBzZWxlY3RvclxuICovXG5jb25zdCBtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xuICByZXR1cm4gbm9ybWFsaXplZE1hdGNoZXNTZWxlY3Rvci5jYWxsKG5vZGUsIHNlbGVjdG9yKTtcbn07XG5cbi8qKlxuICogTm9kZSBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICogYHRhcmdldGAgaXMgYSBgTm9kZWAuXG4gKi9cbmNsYXNzIERvbUFwaSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byBjcmVhdGUgYSBQb2x5bWVyLmRvbSBoZWxwZXIgb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBgUG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyYCB0aGF0XG4gICAqIGxpc3RlbnMgZm9yIG5vZGUgY2hhbmdlcyBvbiB0aGlzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCB3aGVuIGRpcmVjdCBvciBkaXN0cmlidXRlZCBjaGlsZHJlblxuICAgKiAgIG9mIHRoaXMgZWxlbWVudCBjaGFuZ2VzXG4gICAqIEByZXR1cm4ge1BvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcn0gT2JzZXJ2ZXIgaW5zdGFuY2VcbiAgICovXG4gIG9ic2VydmVOb2RlcyhjYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgRmxhdHRlbmVkTm9kZXNPYnNlcnZlcih0aGlzLm5vZGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbiBvYnNlcnZlciBwcmV2aW91c2x5IGNyZWF0ZWQgdmlhIGBvYnNlcnZlTm9kZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBvYnNlcnZlckhhbmRsZSBPYnNlcnZlciBpbnN0YW5jZVxuICAgKiAgIHRvIGRpc2Nvbm5lY3QuXG4gICAqL1xuICB1bm9ic2VydmVOb2RlcyhvYnNlcnZlckhhbmRsZSkge1xuICAgIG9ic2VydmVySGFuZGxlLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlZCBhcyBhIGJhY2t3YXJkcy1jb21wYXRpYmxlIEFQSSBvbmx5LiAgVGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgKi9cbiAgbm90aWZ5T2JzZXJ2ZXIoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG5vZGUgaXMgY29udGFpbmVkIHdpdGggdGhpcyBlbGVtZW50J3NcbiAgICogbGlnaHQtRE9NIGNoaWxkcmVuIG9yIHNoYWRvdyByb290LCBpbmNsdWRpbmcgYW55IG5lc3RlZCBzaGFkb3cgcm9vdHNcbiAgICogb2YgY2hpbGRyZW4gdGhlcmVpbi5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gdGVzdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBpcyBjb250YWluZWQgd2l0aGluXG4gICAqICAgdGhpcyBlbGVtZW50J3MgbGlnaHQgb3Igc2hhZG93IERPTS5cbiAgICovXG4gIGRlZXBDb250YWlucyhub2RlKSB7XG4gICAgaWYgKHRoaXMubm9kZS5jb250YWlucyhub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBuID0gbm9kZTtcbiAgICBsZXQgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIC8vIHdhbGsgZnJvbSBub2RlIHRvIGB0aGlzYCBvciBgZG9jdW1lbnRgXG4gICAgd2hpbGUgKG4gJiYgbiAhPT0gZG9jICYmIG4gIT09IHRoaXMubm9kZSkge1xuICAgICAgLy8gdXNlIGxvZ2ljYWwgcGFyZW50bm9kZSwgb3IgbmF0aXZlIFNoYWRvd1Jvb3QgaG9zdFxuICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgfVxuICAgIHJldHVybiBuID09PSB0aGlzLm5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vdCBub2RlIG9mIHRoaXMgbm9kZS4gIEVxdWl2YWxlbnQgdG8gYGdldFJvb2ROb2RlKClgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUb3AgbW9zdCBlbGVtZW50IGluIHRoZSBkb20gdHJlZSBpbiB3aGljaCB0aGUgbm9kZVxuICAgKiBleGlzdHMuIElmIHRoZSBub2RlIGlzIGNvbm5lY3RlZCB0byBhIGRvY3VtZW50IHRoaXMgaXMgZWl0aGVyIGFcbiAgICogc2hhZG93Um9vdCBvciB0aGUgZG9jdW1lbnQ7IG90aGVyd2lzZSwgaXQgbWF5IGJlIHRoZSBub2RlXG4gICAqIGl0c2VsZiBvciBhIG5vZGUgb3IgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBpdC5cbiAgICovXG4gIGdldE93bmVyUm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmdldFJvb3ROb2RlKCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHNsb3QgZWxlbWVudHMsIHJldHVybnMgdGhlIG5vZGVzIGFzc2lnbmVkIHRvIHRoZSBzbG90OyBvdGhlcndpc2VcbiAgICogYW4gZW1wdHkgYXJyYXkuIEl0IGlzIGVxdWl2YWxlbnQgdG8gYDxzbG90Pi5hZGRpZ25lZE5vZGVzKHtmbGF0dGVuOnRydWV9KWAuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBBcnJheSBvZiBhc3NpZ25lZCBub2Rlc1xuICAgKi9cbiAgZ2V0RGlzdHJpYnV0ZWROb2RlcygpIHtcbiAgICByZXR1cm4gKHRoaXMubm9kZS5sb2NhbE5hbWUgPT09ICdzbG90JykgP1xuICAgICAgdGhpcy5ub2RlLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KSA6XG4gICAgICBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBzbG90cyB0aGlzIGVsZW1lbnQgd2FzIGRpc3RyaWJ1dGVkIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MU2xvdEVsZW1lbnQ+fSBEZXNjcmlwdGlvblxuICAgKi9cbiAgZ2V0RGVzdGluYXRpb25JbnNlcnRpb25Qb2ludHMoKSB7XG4gICAgbGV0IGlwJCA9IFtdO1xuICAgIGxldCBuID0gdGhpcy5ub2RlLmFzc2lnbmVkU2xvdDtcbiAgICB3aGlsZSAobikge1xuICAgICAgaXAkLnB1c2gobik7XG4gICAgICBuID0gbi5hc3NpZ25lZFNsb3Q7XG4gICAgfVxuICAgIHJldHVybiBpcCQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYGltcG9ydE5vZGVgIG9uIHRoZSBgb3duZXJEb2N1bWVudGAgZm9yIHRoaXMgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gaW1wb3J0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVlcCBUcnVlIGlmIHRoZSBub2RlIHNob3VsZCBiZSBjbG9uZWQgZGVlcGx5IGR1cmluZ1xuICAgKiAgIGltcG9ydFxuICAgKiBAcmV0dXJuIHtOb2RlfSBDbG9uZSBvZiBnaXZlbiBub2RlIGltcG9ydGVkIHRvIHRoaXMgb3duZXIgZG9jdW1lbnRcbiAgICovXG4gIGltcG9ydE5vZGUobm9kZSwgZGVlcCkge1xuICAgIGxldCBkb2MgPSB0aGlzLm5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCA/IHRoaXMubm9kZSA6XG4gICAgICB0aGlzLm5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gZG9jLmltcG9ydE5vZGUobm9kZSwgZGVlcCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYSBmbGF0dGVuZWQgbGlzdCBvZiBhbGwgY2hpbGQgbm9kZXMgYW5kIG5vZGVzIGFzc2lnbmVkXG4gICAqIHRvIGNoaWxkIHNsb3RzLlxuICAgKi9cbiAgZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpIHtcbiAgICByZXR1cm4gRmxhdHRlbmVkTm9kZXNPYnNlcnZlci5nZXRGbGF0dGVuZWROb2Rlcyh0aGlzLm5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmaWx0ZXJlZCBsaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50cyBmb3IgdGhpcyBlbGVtZW50IGJhc2VkXG4gICAqIG9uIHRoZSBnaXZlbiBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIGZpbHRlciBub2RlcyBhZ2FpbnN0XG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn0gTGlzdCBvZiBmbGF0dGVuZWQgY2hpbGQgZWxlbWVudHNcbiAgICovXG4gIHF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgIGxldCBjJCA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgIGxldCBsaXN0ID0gW107XG4gICAgZm9yIChsZXQgaT0wLCBsPWMkLmxlbmd0aCwgYzsgKGk8bCkgJiYgKGM9YyRbaV0pOyBpKyspIHtcbiAgICAgIGlmICgoYy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpICYmXG4gICAgICAgICAgbWF0Y2hlc1NlbGVjdG9yKGMsIHNlbGVjdG9yKSkge1xuICAgICAgICBsaXN0LnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzaGFkb3cgcm9vdHMsIHJldHVybnMgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgd2l0aGluIHRoaXNcbiAgICogc2hhZG93IHJvb3QuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV8dW5kZWZpbmVkfSBDdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XG4gICAqL1xuICBnZXQgYWN0aXZlRWxlbWVudCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMubm9kZTtcbiAgICByZXR1cm4gbm9kZS5fYWN0aXZlRWxlbWVudCAhPT0gdW5kZWZpbmVkID8gbm9kZS5fYWN0aXZlRWxlbWVudCA6IG5vZGUuYWN0aXZlRWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3J3YXJkTWV0aG9kcyhwcm90bywgbWV0aG9kcykge1xuICBmb3IgKGxldCBpPTA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgcHJvdG9bbWV0aG9kXSA9IC8qKiBAdGhpcyB7RG9tQXBpfSAqLyBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVbbWV0aG9kXS5hcHBseSh0aGlzLm5vZGUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gIGZvciAobGV0IGk9MDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbmFtZSA9IHByb3BlcnRpZXNbaV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gIGZvciAobGV0IGk9MDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbmFtZSA9IHByb3BlcnRpZXNbaV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtEb21BcGl9ICovICh0aGlzKS5ub2RlW25hbWVdID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZm9yd2FyZE1ldGhvZHMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAnY2xvbmVOb2RlJywgJ2FwcGVuZENoaWxkJywgJ2luc2VydEJlZm9yZScsICdyZW1vdmVDaGlsZCcsXG4gICdyZXBsYWNlQ2hpbGQnLCAnc2V0QXR0cmlidXRlJywgJ3JlbW92ZUF0dHJpYnV0ZScsXG4gICdxdWVyeVNlbGVjdG9yJywgJ3F1ZXJ5U2VsZWN0b3JBbGwnXG5dKTtcblxuZm9yd2FyZFJlYWRPbmx5UHJvcGVydGllcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICdwYXJlbnROb2RlJywgJ2ZpcnN0Q2hpbGQnLCAnbGFzdENoaWxkJyxcbiAgJ25leHRTaWJsaW5nJywgJ3ByZXZpb3VzU2libGluZycsICdmaXJzdEVsZW1lbnRDaGlsZCcsXG4gICdsYXN0RWxlbWVudENoaWxkJywgJ25leHRFbGVtZW50U2libGluZycsICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJyxcbiAgJ2NoaWxkTm9kZXMnLCAnY2hpbGRyZW4nLCAnY2xhc3NMaXN0J1xuXSk7XG5cbmZvcndhcmRQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgJ3RleHRDb250ZW50JywgJ2lubmVySFRNTCdcbl0pO1xuXG5cbi8qKlxuICogRXZlbnQgQVBJIHdyYXBwZXIgY2xhc3MgcmV0dXJuZWQgZnJvbSBgUG9seW1lci5kb20uKHRhcmdldClgIHdoZW5cbiAqIGB0YXJnZXRgIGlzIGFuIGBFdmVudGAuXG4gKi9cbmNsYXNzIEV2ZW50QXBpIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgbm9kZSBvbiB0aGUgYGNvbXBvc2VkUGF0aGAgb2YgdGhpcyBldmVudC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIG5vZGUgdGhpcyBldmVudCB3YXMgZGlzcGF0Y2hlZCB0b1xuICAgKi9cbiAgZ2V0IHJvb3RUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9jYWwgKHJlLXRhcmdldGVkKSB0YXJnZXQgZm9yIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICovXG4gIGdldCBsb2NhbFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudC50YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYGNvbXBvc2VkUGF0aGAgZm9yIHRoaXMgZXZlbnQuXG4gICAqL1xuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBEb21BcGkgfTtcblxuZXhwb3J0IGNvbnN0IGRvbSA9IGZ1bmN0aW9uKG9iaikge1xuICBvYmogPSBvYmogfHwgZG9jdW1lbnQ7XG4gIGlmICghb2JqLl9fZG9tQXBpKSB7XG4gICAgbGV0IGhlbHBlcjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgIGhlbHBlciA9IG5ldyBFdmVudEFwaShvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWxwZXIgPSBuZXcgRG9tQXBpKG9iaik7XG4gICAgfVxuICAgIG9iai5fX2RvbUFwaSA9IGhlbHBlcjtcbiAgfVxuICByZXR1cm4gb2JqLl9fZG9tQXBpO1xufTtcblxuZXhwb3J0IHsgbWF0Y2hlc1NlbGVjdG9yIH07XG5leHBvcnQgeyBmbHVzaCQwIGFzIGZsdXNoIH07XG5leHBvcnQgeyBlbnF1ZXVlRGVib3VuY2VyIGFzIGFkZERlYm91bmNlciB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMiLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5leHBvcnQgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcyIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdHlwZUxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9LFxyXG5cdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gVXRpbC5leHRlbmQoe30sIGRhdGEsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQgPSAodGhpcy5fZmlyaW5nQ291bnQgKyAxKSB8fCAxO1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBsID0gbGlzdGVuZXJzW2ldO1xyXG5cdFx0XHRcdFx0bC5mbi5jYWxsKGwuY3R4IHx8IHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50LS07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIHByb3BhZ2F0ZSB0aGUgZXZlbnQgdG8gcGFyZW50cyAoc2V0IHdpdGggYWRkRXZlbnRQYXJlbnQpXHJcblx0XHRcdHRoaXMuX3Byb3BhZ2F0ZUV2ZW50KGV2ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxpc3RlbnModHlwZTogU3RyaW5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdGxpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBwcm9wYWdhdGUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvbmNlKOKApik6IHRoaXNcclxuXHQvLyBCZWhhdmVzIGFzIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKSwgZXhjZXB0IHRoZSBsaXN0ZW5lciB3aWxsIG9ubHkgZ2V0IGZpcmVkIG9uY2UgYW5kIHRoZW4gcmVtb3ZlZC5cclxuXHRvbmNlOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMub25jZSh0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdC8vIGFkZCBhIGxpc3RlbmVyIHRoYXQncyBleGVjdXRlZCBvbmNlIGFuZCByZW1vdmVkIGFmdGVyIHRoYXRcclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLm9uKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24odHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gZXZlbnQgcGFyZW50IC0gYW4gYEV2ZW50ZWRgIHRoYXQgd2lsbCByZWNlaXZlIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0YWRkRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50cyA9IHRoaXMuX2V2ZW50UGFyZW50cyB8fCB7fTtcclxuXHRcdHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildID0gb2JqO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBldmVudCBwYXJlbnQsIHNvIGl0IHdpbGwgc3RvcCByZWNlaXZpbmcgcHJvcGFnYXRlZCBldmVudHNcclxuXHRyZW1vdmVFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0dGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5maXJlKGUudHlwZSwgVXRpbC5leHRlbmQoe2xheWVyOiBlLnRhcmdldH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG5leHBvcnQgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0V2ZW50cy5qcyIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBVdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdFV0aWwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0VXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKFV0aWwuY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdFV0aWwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0aWYgKCFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0NsYXNzLmpzIiwiaW1wb3J0IHtQb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblxyXG4gKiBAYWthIEwuVHJhbnNmb3JtYXRpb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb246IGEgc2V0IG9mIGNvZWZmaWNpZW50cyBgYWAsIGBiYCwgYGNgLCBgZGBcclxuICogZm9yIHRyYW5zZm9ybWluZyBhIHBvaW50IG9mIGEgZm9ybSBgKHgsIHkpYCBpbnRvIGAoYSp4ICsgYiwgYyp5ICsgZClgIGFuZCBkb2luZ1xyXG4gKiB0aGUgcmV2ZXJzZS4gVXNlZCBieSBMZWFmbGV0IGluIGl0cyBwcm9qZWN0aW9ucyBjb2RlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdHJhbnNmb3JtYXRpb24gPSBMLnRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uKGEsIGIsIGMsIGQpIHtcclxuXHRpZiAoVXRpbC5pc0FycmF5KGEpKSB7XHJcblx0XHQvLyB1c2UgYXJyYXkgcHJvcGVydGllc1xyXG5cdFx0dGhpcy5fYSA9IGFbMF07XHJcblx0XHR0aGlzLl9iID0gYVsxXTtcclxuXHRcdHRoaXMuX2MgPSBhWzJdO1xyXG5cdFx0dGhpcy5fZCA9IGFbM107XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHRoaXMuX2EgPSBhO1xyXG5cdHRoaXMuX2IgPSBiO1xyXG5cdHRoaXMuX2MgPSBjO1xyXG5cdHRoaXMuX2QgPSBkO1xyXG59XHJcblxyXG5UcmFuc2Zvcm1hdGlvbi5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCB0cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIHRyYW5zZm9ybWVkIHBvaW50LCBvcHRpb25hbGx5IG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIHNjYWxlLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG5cclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFRyYW5zZm9ybWF0aW9uIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihjb2VmZmljaWVudHM6IEFycmF5KTogVHJhbnNmb3JtYXRpb25cclxuLy8gRXhwZWN0cyBhbiBjb2VmaWNpZW50cyBhcnJheSBvZiB0aGUgZm9ybVxyXG4vLyBgW2E6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcl1gLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbi5qcyIsIlxyXG5pbXBvcnQge0NsYXNzfSBmcm9tICcuLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICogQGluaGVyaXRzIENsYXNzXHJcbiAqXHJcbiAqIEwuQ29udHJvbCBpcyBhIGJhc2UgY2xhc3MgZm9yIGltcGxlbWVudGluZyBtYXAgY29udHJvbHMuIEhhbmRsZXMgcG9zaXRpb25pbmcuXHJcbiAqIEFsbCBvdGhlciBjb250cm9scyBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ29udHJvbCA9IENsYXNzLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcG9zaXRpb246IFN0cmluZyA9ICd0b3ByaWdodCdcclxuXHRcdC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCAob25lIG9mIHRoZSBtYXAgY29ybmVycykuIFBvc3NpYmxlIHZhbHVlcyBhcmUgYCd0b3BsZWZ0J2AsXHJcblx0XHQvLyBgJ3RvcHJpZ2h0J2AsIGAnYm90dG9tbGVmdCdgIG9yIGAnYm90dG9tcmlnaHQnYFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgTC5Db250cm9sIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldFBvc2l0aW9uOiBzdHJpbmdcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHQgKi9cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgY29udHJvbC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBjb250cm9sIHRvIHRoZSBnaXZlbiBtYXAuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMucmVtb3ZlKCk7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKSxcclxuXHRcdCAgICBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKCksXHJcblx0XHQgICAgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3JlZm9jdXNPbk1hcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIGlmIG1hcCBleGlzdHMgYW5kIGV2ZW50IGlzIG5vdCBhIGtleWJvYXJkIGV2ZW50XHJcblx0XHRpZiAodGhpcy5fbWFwICYmIGUgJiYgZS5zY3JlZW5YID4gMCAmJiBlLnNjcmVlblkgPiAwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgdmFyIGNvbnRyb2wgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQ29udHJvbChvcHRpb25zKTtcclxufTtcclxuXHJcbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcbiAqIEB1bmluaGVyaXRhYmxlXHJcbiAqXHJcbiAqIEV2ZXJ5IGNvbnRyb2wgc2hvdWxkIGV4dGVuZCBmcm9tIGBMLkNvbnRyb2xgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25BZGQobWFwOiBNYXApOiBIVE1MRWxlbWVudFxyXG4gKiBTaG91bGQgcmV0dXJuIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYGNvbnRyb2wuYWRkVG8obWFwKWBdKCNjb250cm9sLWFkZFRvKS5cclxuICpcclxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcClcclxuICogT3B0aW9uYWwgbWV0aG9kLiBTaG91bGQgY29udGFpbiBhbGwgY2xlYW4gdXAgY29kZSB0aGF0IHJlbW92ZXMgdGhlIGxpc3RlbmVycyBwcmV2aW91c2x5IGFkZGVkIGluIFtgb25BZGRgXSgjY29udHJvbC1vbmFkZCkuIENhbGxlZCBvbiBbYGNvbnRyb2wucmVtb3ZlKClgXSgjY29udHJvbC1yZW1vdmUpLlxyXG4gKi9cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuICovXHJcbk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIERvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ3RvcCcsICdyaWdodCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCdib3R0b20nLCAncmlnaHQnKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2NvbnRyb2xDb3JuZXJzKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb3JuZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRyb2xDb250YWluZXIpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb3JuZXJzO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRyb2xDb250YWluZXI7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuanMiLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvdWNofSBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbmV4cG9ydCB2YXIgUGF0aCA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQYXRoIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc3Ryb2tlOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gZHJhdyBzdHJva2UgYWxvbmcgdGhlIHBhdGguIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgYm9yZGVycyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdHN0cm9rZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gY29sb3I6IFN0cmluZyA9ICcjMzM4OGZmJ1xuXHRcdC8vIFN0cm9rZSBjb2xvclxuXHRcdGNvbG9yOiAnIzMzODhmZicsXG5cblx0XHQvLyBAb3B0aW9uIHdlaWdodDogTnVtYmVyID0gM1xuXHRcdC8vIFN0cm9rZSB3aWR0aCBpbiBwaXhlbHNcblx0XHR3ZWlnaHQ6IDMsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIFN0cm9rZSBvcGFjaXR5XG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gbGluZUNhcDogU3RyaW5nPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBlbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXApIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUNhcDogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gbGluZUpvaW46IFN0cmluZyA9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGNvcm5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVqb2luKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVKb2luOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoQXJyYXk6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBbZGFzaCBwYXR0ZXJuXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXkpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaEFycmF5OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBkYXNoT2Zmc2V0OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBbZGlzdGFuY2UgaW50byB0aGUgZGFzaCBwYXR0ZXJuIHRvIHN0YXJ0IHRoZSBkYXNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNob2Zmc2V0KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hPZmZzZXQ6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGw6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gV2hldGhlciB0byBmaWxsIHRoZSBwYXRoIHdpdGggY29sb3IuIFNldCBpdCB0byBgZmFsc2VgIHRvIGRpc2FibGUgZmlsbGluZyBvbiBwb2x5Z29ucyBvciBjaXJjbGVzLlxuXHRcdGZpbGw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsQ29sb3I6IFN0cmluZyA9ICpcblx0XHQvLyBGaWxsIGNvbG9yLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgdGhlIFtgY29sb3JgXSgjcGF0aC1jb2xvcikgb3B0aW9uXG5cdFx0ZmlsbENvbG9yOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsT3BhY2l0eTogTnVtYmVyID0gMC4yXG5cdFx0Ly8gRmlsbCBvcGFjaXR5LlxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxSdWxlOiBTdHJpbmcgPSAnZXZlbm9kZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW2hvdyB0aGUgaW5zaWRlIG9mIGEgc2hhcGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZmlsbC1ydWxlKSBpcyBkZXRlcm1pbmVkLlxuXHRcdGZpbGxSdWxlOiAnZXZlbm9kZCcsXG5cblx0XHQvLyBjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgcGF0aCB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IHRydWVcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgbGF5ZXIuIFNvbWV0aW1lcyB1c2VmdWwgYWZ0ZXIgeW91IGNoYW5nZWQgdGhlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHBhdGggdXNlcy5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgKyAodG91Y2ggPyAxMCA6IDApO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanMiLCJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbi8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuLy8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG4vLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4vLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwOi8vbW91cm5lci5naXRodWIuY29tL3NpbXBsaWZ5LWpzLykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbn1cclxuXHJcbi8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG5cdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHR2YXIgaSxcclxuXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXdQb2ludHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5mdW5jdGlvbiBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKF9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdHByZXYgPSBpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxufVxyXG5cclxudmFyIF9sYXN0Q29kZTtcclxuXHJcbi8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4vLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcbi8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4vLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRhID0gcDtcclxuXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YiA9IHA7XHJcblx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG5cdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHQgICAgeCwgeTtcclxuXHJcblx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1heC55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1pbi55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAyKSB7IC8vIHJpZ2h0XHJcblx0XHR4ID0gbWF4Lng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG5cdFx0eCA9IG1pbi54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuXHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0Y29kZSB8PSAxO1xyXG5cdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRjb2RlIHw9IDI7XHJcblx0fVxyXG5cclxuXHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG5cdFx0Y29kZSB8PSA0O1xyXG5cdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0Y29kZSB8PSA4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvZGU7XHJcbn1cclxuXHJcbi8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG5mdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG5cdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG5cdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcbmV4cG9ydCBmdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuXHR2YXIgeCA9IHAxLngsXHJcblx0ICAgIHkgPSBwMS55LFxyXG5cdCAgICBkeCA9IHAyLnggLSB4LFxyXG5cdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHQgICAgdDtcclxuXHJcblx0aWYgKGRvdCA+IDApIHtcclxuXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0aWYgKHQgPiAxKSB7XHJcblx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHR5ID0gcDIueTtcclxuXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuXHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHggPSBwLnggLSB4O1xyXG5cdGR5ID0gcC55IC0geTtcclxuXHJcblx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzKSB7XHJcblx0cmV0dXJuICFVdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2ZsYXQobGF0bG5ncykge1xyXG5cdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCB1c2Ugb2YgX2ZsYXQsIHBsZWFzZSB1c2UgTC5MaW5lVXRpbC5pc0ZsYXQgaW5zdGVhZC4nKTtcclxuXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG5sZXQgQUJTX1VSTCA9IC8oXlxcLyl8KF4jKXwoXltcXHctXFxkXSo6KS87XG5sZXQgd29ya2luZ1VSTDtcbmxldCByZXNvbHZlRG9jO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gVVJMIGFnYWluc3QgdGhlIHByb3ZpZGVkIGBiYXNlVXJpJy5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byByZXNvbHZlXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIFVSTFxuICovXG5mdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVSSSkge1xuICBpZiAodXJsICYmIEFCU19VUkwudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICAvLyBMYXp5IGZlYXR1cmUgZGV0ZWN0aW9uLlxuICBpZiAod29ya2luZ1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1ID0gbmV3IFVSTCgnYicsICdodHRwOi8vYScpO1xuICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICB3b3JraW5nVVJMID0gKHUuaHJlZiA9PT0gJ2h0dHA6Ly9hL2MlMjBkJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgZmFpbFxuICAgIH1cbiAgfVxuICBpZiAoIWJhc2VVUkkpIHtcbiAgICBiYXNlVVJJID0gZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgfVxuICBpZiAod29ya2luZ1VSTCkge1xuICAgIHJldHVybiAobmV3IFVSTCh1cmwsIGJhc2VVUkkpKS5ocmVmO1xuICB9XG4gIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICBpZiAoIXJlc29sdmVEb2MpIHtcbiAgICByZXNvbHZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd0ZW1wJyk7XG4gICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgcmVzb2x2ZURvYy5oZWFkLmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYmFzZSk7XG4gICAgcmVzb2x2ZURvYy5hbmNob3IgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICB9XG4gIHJlc29sdmVEb2MuYmFzZS5ocmVmID0gYmFzZVVSSTtcbiAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgcmV0dXJuIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgfHwgdXJsO1xuXG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYW55IHJlbGF0aXZlIFVSTCdzIGluIHRoZSBnaXZlbiBDU1MgdGV4dCBhZ2FpbnN0IHRoZSBwcm92aWRlZFxuICogYG93bmVyRG9jdW1lbnRgJ3MgYGJhc2VVUklgLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0IENTUyB0ZXh0IHRvIHByb2Nlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1MgdGV4dCB3aXRoIHJlc29sdmVkIFVSTCdzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSkge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKENTU19VUkxfUlgsIGZ1bmN0aW9uKG0sIHByZSwgdXJsLCBwb3N0KSB7XG4gICAgcmV0dXJuIHByZSArICdcXCcnICtcbiAgICAgIHJlc29sdmVVcmwodXJsLnJlcGxhY2UoL1tcIiddL2csICcnKSwgYmFzZVVSSSkgK1xuICAgICAgJ1xcJycgKyBwb3N0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gYHVybGAuIFRoZSBwYXRoIGluY2x1ZGVzIHRoZSB0cmFpbGluZ1xuICogYC9gIGZyb20gdGhlIHVybC5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgcGF0aFxuICovXG5mdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNzcyB9O1xuZXhwb3J0IHsgcmVzb2x2ZVVybCB9O1xuZXhwb3J0IHsgcGF0aEZyb21VcmwgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5pbmRleE9mKCcuJykgPj0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvb3QocGF0aCkge1xuICBsZXQgZG90SW5kZXggPSBwYXRoLmluZGV4T2YoJy4nKTtcbiAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGRvdEluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQW5jZXN0b3IoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgYmFzZS5zdGFydHNXaXRoKHBhdGggKyAnLicpO1xuICByZXR1cm4gYmFzZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpIHtcbiAgLy8gICAgIHBhdGguc3RhcnRzV2l0aChiYXNlICsgJy4nKTtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlICsgJy4nKSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShiYXNlLCBuZXdCYXNlLCBwYXRoKSB7XG4gIHJldHVybiBuZXdCYXNlICsgcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGJhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIChiYXNlID09PSBwYXRoKSB8fFxuICAgICAgICAgaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB8fFxuICAgICAgICAgaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8cGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGFyZ3MgPSBwYXRoW2ldLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgIGZvciAobGV0IGo9MDsgajxhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXJnc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHBhdGgpLnNwbGl0KCcuJyk7XG4gIH1cbiAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHJvb3QsIHBhdGgsIGluZm8pIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0xXSBhbmQgZGVyZWZlcmVuY2VcbiAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgcHJvcCA9IHByb3BbcGFydF07XG4gIH1cbiAgaWYgKGluZm8pIHtcbiAgICBpbmZvLnBhdGggPSBwYXJ0cy5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQocm9vdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgbGV0IGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMV07XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0yXSBhbmQgZGVyZWZlcmVuY2VcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0IHZhbHVlIHRvIG9iamVjdCBhdCBlbmQgb2YgcGF0aFxuICAgIHByb3BbbGFzdF0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTaW1wbGUgcHJvcGVydHkgc2V0XG4gICAgcHJvcFtwYXRoXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0RlZXAgPSBpc1BhdGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgJy4vbWl4aW4uanMnO1xuaW1wb3J0ICcuL2FzeW5jLmpzJztcblxuLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG5sZXQgQXN5bmNNb2R1bGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBAc3VtbWFyeSBDb2xsYXBzZSBtdWx0aXBsZSBjYWxsYmFja3MgaW50byBvbmUgaW52b2NhdGlvbiBhZnRlciBhIHRpbWVyLlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xuY2xhc3MgRGVib3VuY2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYXN5bmNNb2R1bGUgPSBudWxsO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjaGVkdWxlcjsgdGhhdCBpcywgYSBtb2R1bGUgd2l0aCB0aGUgQXN5bmMgaW50ZXJmYWNlLFxuICAgKiBhIGNhbGxiYWNrIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBydW4gZnVuY3Rpb25cbiAgICogZnJvbSB0aGUgYXN5bmMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0geyFBc3luY01vZHVsZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICovXG4gIHNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hc3luY01vZHVsZSA9IGFzeW5jTW9kdWxlO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZXIgPSB0aGlzLl9hc3luY01vZHVsZS5ydW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9hc3luY01vZHVsZS5jYW5jZWwodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmx1c2hlcyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICovXG4gIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFjdGl2ZS5cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lciAhPSBudWxsO1xuICB9XG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZXIgaWYgbm8gZGVib3VuY2VyIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICogb3IgaXQgY2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIG90aGVyd2lzZS4gVGhlIGZvbGxvd2luZ1xuICogZXhhbXBsZSBzaG93cyBob3cgYSBkZWJvdW5jZXIgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoaW4gYVxuICogbWljcm90YXNrIGFuZCBcImRlYm91bmNlZFwiIHN1Y2ggdGhhdCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gaXNcbiAqIGNhbGxlZCBvbmNlLiBBZGQgdGhpcyBtZXRob2QgdG8gYSBjdXN0b20gZWxlbWVudDpcbiAqXG4gKiBfZGVib3VuY2VXb3JrKCkge1xuICogICB0aGlzLl9kZWJvdW5jZUpvYiA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKHRoaXMuX2RlYm91bmNlSm9iLFxuICogICAgICAgUG9seW1lci5Bc3luYy5taWNyb1Rhc2ssICgpID0+IHtcbiAqICAgICB0aGlzLl9kb1dvcmsoKTtcbiAqICAgfSk7XG4gKiB9XG4gKlxuICogSWYgdGhlIGBfZGVib3VuY2VXb3JrYCBtZXRob2QgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiB0aGUgc2FtZVxuICogbWljcm90YXNrLCB0aGUgYF9kb1dvcmtgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBhdCB0aGUgbmV4dFxuICogbWljcm90YXNrIGNoZWNrcG9pbnQuXG4gKlxuICogTm90ZTogSW4gdGVzdGluZyBpdCBpcyBvZnRlbiBjb252ZW5pZW50IHRvIGF2b2lkIGFzeW5jaHJvbnkuIFRvIGFjY29tcGxpc2hcbiAqIHRoaXMgd2l0aCBhIGRlYm91bmNlciwgeW91IGNhbiB1c2UgYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcmAgYW5kXG4gKiBgUG9seW1lci5mbHVzaGAuIEZvciBleGFtcGxlLCBleHRlbmQgdGhlIGFib3ZlIGV4YW1wbGUgYnkgYWRkaW5nXG4gKiBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyKHRoaXMuX2RlYm91bmNlSm9iKWAgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGBfZGVib3VuY2VXb3JrYCBtZXRob2QuIFRoZW4gaW4gYSB0ZXN0LCBjYWxsIGBQb2x5bWVyLmZsdXNoYCB0byBlbnN1cmVcbiAqIHRoZSBkZWJvdW5jZXIgaGFzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge0RlYm91bmNlcj99IGRlYm91bmNlciBEZWJvdW5jZXIgb2JqZWN0LlxuICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZVxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayB0byBydW4uXG4gKiBAcmV0dXJuIHshRGVib3VuY2VyfSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdC5cbiAqL1xuICBzdGF0aWMgZGVib3VuY2UoZGVib3VuY2VyLCBhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZGVib3VuY2VyIGluc3RhbmNlb2YgRGVib3VuY2VyKSB7XG4gICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYm91bmNlciA9IG5ldyBEZWJvdW5jZXIoKTtcbiAgICB9XG4gICAgZGVib3VuY2VyLnNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBkZWJvdW5jZXI7XG4gIH1cbn1cblxuZXhwb3J0IHsgRGVib3VuY2VyIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwiaW1wb3J0IHsgQ2xhc3MgfSBmcm9tICcuL2NsYXNzLmpzJztcblxuZXhwb3J0IGNvbnN0IFBvbHltZXIgPSBmdW5jdGlvbihpbmZvKSB7XG4gIC8vIGlmIGlucHV0IGlzIGEgYGNsYXNzYCAoYWthIGEgZnVuY3Rpb24gd2l0aCBhIHByb3RvdHlwZSksIHVzZSB0aGUgcHJvdG90eXBlXG4gIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGBjb25zdHJ1Y3RvcmAgd2lsbCBuZXZlciBiZSBjYWxsZWRcbiAgbGV0IGtsYXNzO1xuICBpZiAodHlwZW9mIGluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBrbGFzcyA9IGluZm87XG4gIH0gZWxzZSB7XG4gICAga2xhc3MgPSBDbGFzcyhpbmZvKTtcbiAgfVxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoa2xhc3MuaXMsIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhrbGFzcykpO1xuICByZXR1cm4ga2xhc3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyIsImltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbiBmb3IgbWl4aW4gJiBiZWhhdmlvclxuZnVuY3Rpb24gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKGluc3QsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCBtdXRhYmxlRGF0YSkge1xuICBsZXQgaXNPYmplY3Q7XG4gIGlmIChtdXRhYmxlRGF0YSkge1xuICAgIGlzT2JqZWN0ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpO1xuICAgIC8vIFB1bGwgYG9sZGAgZm9yIE9iamVjdHMgZnJvbSB0ZW1wIGNhY2hlLCBidXQgdHJlYXQgYG51bGxgIGFzIGEgcHJpbWl0aXZlXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBvbGQgPSBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2ssIGJ1dCByZXR1cm4gZmFsc2UgZm9yIE5hTj09PU5hTlxuICBsZXQgc2hvdWxkQ2hhbmdlID0gKG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpO1xuICAvLyBPYmplY3RzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZlxuICAvLyB0dXJuKSwgd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmdcbiAgaWYgKGlzT2JqZWN0ICYmIHNob3VsZENoYW5nZSkge1xuICAgIGluc3QuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gc2hvdWxkQ2hhbmdlO1xufVxuXG5leHBvcnQgY29uc3QgTXV0YWJsZURhdGEgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICovXG4gIGNsYXNzIE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBNdXRhYmxlRGF0YS5wcm90b3R5cGUubXV0YWJsZURhdGEgPSBmYWxzZTtcblxuICByZXR1cm4gTXV0YWJsZURhdGE7XG5cbn0pO1xuXG5leHBvcnQgY29uc3QgT3B0aW9uYWxNdXRhYmxlRGF0YSA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBwb2x5bWVyXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAqL1xuICBjbGFzcyBPcHRpb25hbE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGB0aGlzLm11dGFibGVEYXRhYCBpcyB0cnVlIG9uIHRoaXMgaW5zdGFuY2UsIHRoaXMgbWV0aG9kXG4gICAgICogcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlXG4gICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRoaXMubXV0YWJsZURhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcHRpb25hbE11dGFibGVEYXRhO1xuXG59KTtcblxuLy8gRXhwb3J0IGZvciB1c2UgYnkgbGVnYWN5IGJlaGF2aW9yXG5NdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7c2V0T3B0aW9uc30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7cmV0aW5hfSBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggcG9wdXBzIHdpbGwgXCJvcGVuXCIsIHJlbGF0aXZlIHRvIHRoZSBpY29uIGFuY2hvci5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93VXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byB0aGUgaWNvbiBzaGFkb3cgaW1hZ2UuIElmIG5vdCBzcGVjaWZpZWQsIG5vIHNoYWRvdyBpbWFnZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1JldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dTaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBzaGFkb3cgaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgc2hhZG93IChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKSAodGhlIHNhbWVcclxuXHQgKiBhcyBpY29uQW5jaG9yIGlmIG5vdCBzcGVjaWZpZWQpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0ICogQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gYm90aCBpY29uIGFuZCBzaGFkb3cgaW1hZ2VzLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gcmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvSWNvbi5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5leHBvcnQgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0VXRpbC5zdGFtcCh0aGlzKTtcblx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5faW5pdENvbnRhaW5lcigpOyAvLyBkZWZpbmVkIGJ5IHJlbmRlcmVyIGltcGxlbWVudGF0aW9uc1xuXG5cdFx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSxcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoMC41ICsgdGhpcy5vcHRpb25zLnBhZGRpbmcpLFxuXHRcdCAgICBjdXJyZW50Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9jZW50ZXIsIHpvb20pLFxuXHRcdCAgICBkZXN0Q2VudGVyUG9pbnQgPSB0aGlzLl9tYXAucHJvamVjdChjZW50ZXIsIHpvb20pLFxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBkZXN0Q2VudGVyUG9pbnQuc3VidHJhY3QoY3VycmVudENlbnRlclBvaW50KSxcblxuXHRcdCAgICB0b3BMZWZ0T2Zmc2V0ID0gdmlld0hhbGYubXVsdGlwbHlCeSgtc2NhbGUpLmFkZChwb3NpdGlvbikuYWRkKHZpZXdIYWxmKS5zdWJ0cmFjdChjZW50ZXJPZmZzZXQpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcyIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlTWFya2VyID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ2lyY2xlTWFya2VyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyID0gMTBcblx0XHQvLyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBtYXJrZXIsIGluIHBpeGVsc1xuXHRcdHJhZGl1czogMTBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRMbmc6IExhdExuZyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYSBjaXJjbGUgbWFya2VyIHRvIGEgbmV3IGxvY2F0aW9uLlxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGVNYXJrZXIuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgcm9vdFBhdGggYXMgcm9vdFBhdGgkMCB9IGZyb20gJy4uL3V0aWxzL3NldHRpbmdzLmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwJDAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2hDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgY3NzRnJvbU1vZHVsZUltcG9ydHMsIGNzc0Zyb21UZW1wbGF0ZSB9IGZyb20gJy4uL3V0aWxzL3N0eWxlLWdhdGhlci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlVXJsIGFzIHJlc29sdmVVcmwkMCB9IGZyb20gJy4uL3V0aWxzL3Jlc29sdmUtdXJsLmpzJztcbmltcG9ydCB7IERvbU1vZHVsZSB9IGZyb20gJy4uL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcblxuZXhwb3J0IGNvbnN0IEVsZW1lbnRNaXhpbiA9IGRlZHVwaW5nTWl4aW4oYmFzZSA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgKi9cbiAgY29uc3QgcG9seW1lckVsZW1lbnRCYXNlID0gUHJvcGVydHlFZmZlY3RzKGJhc2UpO1xuXG4gIGxldCBjYXNlTWFwID0gY2FzZU1hcCQwO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgcHJvcGVydGllc2Agb2JqZWN0IHNwZWNpZmljYWxseSBvbiBga2xhc3NgLiBVc2UgZm9yOlxuICAgKiAoMSkgc3VwZXIgY2hhaW4gbWl4ZXMgdG9ndGhlciB0byBtYWtlIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgIHdoaWNoIGlzXG4gICAqIHRoZW4gdXNlZCB0byBtYWtlIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICAgKiAoMikgcHJvcGVydGllcyBlZmZlY3RzIGFuZCBvYnNlcnZlcnMgYXJlIGNyZWF0ZWQgZnJvbSBpdCBhdCBgZmluYWxpemVgIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBvd24gcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb3duUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fb3duUHJvcGVydGllcyA9XG4gICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCBrbGFzcykpID9cbiAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm9wZXJ0aWVzIDoge307XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX293blByb3BlcnRpZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYG9ic2VydmVyc2AgYXJyYXkgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3JcbiAgICogc2V0dGluZyB1cCBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgb3duIG9ic2VydmVycyBmb3IgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25PYnNlcnZlcnMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX293bk9ic2VydmVycyA9XG4gICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ29ic2VydmVycycsIGtsYXNzKSkgP1xuICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLm9ic2VydmVycyA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4ga2xhc3MuX19vd25PYnNlcnZlcnM7XG4gIH1cblxuICAvKipcbiAgICogTWl4ZXMgYHByb3BzYCBpbnRvIGBmbGF0dGVuZWRQcm9wc2AgYnV0IHVwZ3JhZGVzIHNob3J0aGFuZCB0eXBlXG4gICAqIHN5bnRheCB0byB7IHR5cGU6IFR5cGV9LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZmxhdHRlbmVkUHJvcHMgQmFnIHRvIGNvbGxlY3QgZmxhdHRlbmVkIHByb3BlcnRpZXMgaW50b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gYWRkIHRvIGBmbGF0dGVuZWRQcm9wc2BcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgaW5wdXQgYGZsYXR0ZW5lZFByb3BzYCBiYWdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZsYXR0ZW5Qcm9wZXJ0aWVzKGZsYXR0ZW5lZFByb3BzLCBwcm9wcykge1xuICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgIGxldCBvID0gcHJvcHNbcF07XG4gICAgICBpZiAodHlwZW9mIG8gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvID0geyB0eXBlOiBvIH07XG4gICAgICB9XG4gICAgICBmbGF0dGVuZWRQcm9wc1twXSA9IG87XG4gICAgfVxuICAgIHJldHVybiBmbGF0dGVuZWRQcm9wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgcHJvcGVydGllcyBtaXhlZCB0b2dldGhlciBmcm9tIHRoZSBjaGFpbiBvZiBhbGxcbiAgICogY29uc3RydWN0b3IncyBgY29uZmlnLnByb3BlcnRpZXNgLiBUaGlzIGxpc3QgaXMgdXNlZCB0byBjcmVhdGVcbiAgICogKDEpIG9ic2VydmVkQXR0cmlidXRlcyxcbiAgICogKDIpIGNsYXNzIHByb3BlcnR5IGRlZmF1bHQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgYSBwcm9wZXJ0eSBmb3Igc29tZSByZWFzb24/XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnRpZXMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyA9XG4gICAgICBmbGF0dGVuUHJvcGVydGllcyh7fSwgb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSk7XG4gICAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtsYXNzLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXNGb3JDbGFzcygvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyhzdXBlckN0b3IpKSksXG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2xhc3MuX19jbGFzc1Byb3BlcnRpZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgcHJvcGVydGllcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBUaGlzIGxpc3QgaXMgY3JlYXRlZCBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgaXQgaXMgYSBzdWJzZXQgb2ZcbiAgICogdGhlIGxpc3QgcmV0dXJuZWQgZnJvbSBgcHJvcGVydGllc0ZvckNsYXNzYC5cbiAgICogVGhpcyBsaXN0IGlzIHVzZWQgaW4gYF9pbml0aWFsaXplUHJvcGVydGllc2AgdG8gc2V0IHByb3BlcnR5IGRlZmF1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgKiAgIHRoYXQgaGF2ZSBkZWZhdWx0IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fY2xhc3NQcm9wZXJ0eURlZmF1bHRzJywga2xhc3MpKSkge1xuICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBudWxsO1xuICAgICAgbGV0IHByb3BzID0gcHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwcm9wc1twXTtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gaW5mbykge1xuICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzID0ga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgfHwge307XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHNbcF0gPSBpbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBga2xhc3NgIGhhcyBmaW5hbGl6ZWQuIENhbGxlZCBpbiBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFsbCBtZXRhcHJvZ3JhbW1pbmcgZm9yIHRoaXMgY2xhc3MgaGFzIGJlZW5cbiAgICogICBjb21wbGV0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGhhc0NsYXNzRmluYWxpemVkKGtsYXNzKSB7XG4gICAgcmV0dXJuIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZmluYWxpemVkJywga2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgYEVsZW1lbnRDbGFzcy5maW5hbGl6ZSgpYC4gRW5zdXJlcyB0aGlzIGBrbGFzc2AgYW5kXG4gICAqICphbGwgc3VwZXJjbGFzc2VzKiBhcmUgZmluYWxpemVkIGJ5IHRyYXZlcnNpbmcgdGhlIHByb3RvdHlwZSBjaGFpblxuICAgKiBhbmQgY2FsbGluZyBga2xhc3MuZmluYWxpemUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVDbGFzc0FuZFN1cGVyKGtsYXNzKSB7XG4gICAgbGV0IHByb3RvID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm90b3R5cGU7XG4gICAgbGV0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykuY29uc3RydWN0b3I7XG4gICAgaWYgKHN1cGVyQ3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb2x5bWVyRWxlbWVudCkge1xuICAgICAgc3VwZXJDdG9yLmZpbmFsaXplKCk7XG4gICAgfVxuICAgIGZpbmFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBga2xhc3NgIGJhc2VkIG9uIGEgc3RhaWMgYGtsYXNzLmNvbmZpZ2Agb2JqZWN0IGFuZFxuICAgKiBhIGB0ZW1wbGF0ZWAuIFRoaXMgaW5jbHVkZXMgY3JlYXRpbmcgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAqIGZvciBwcm9wZXJ0aWVzIGluIGBjb25maWdgIGFuZCB0aGUgYHRlbXBsYXRlYCBhcyB3ZWxsIGFzIHByZXBhcmluZyB0aGVcbiAgICogYHRlbXBsYXRlYCBmb3Igc3RhbXBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVDbGFzcyhrbGFzcykge1xuICAgIGtsYXNzLl9fZmluYWxpemVkID0gdHJ1ZTtcbiAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICBpZiAoa2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdpcycsIGtsYXNzKSkgJiYga2xhc3MuaXMpIHtcbiAgICAgIHJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgbGV0IHByb3BzID0gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZpbmFsaXplUHJvcGVydGllcyhwcm90bywgcHJvcHMpO1xuICAgIH1cbiAgICBsZXQgb2JzZXJ2ZXJzID0gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpO1xuICAgIGlmIChvYnNlcnZlcnMpIHtcbiAgICAgIGZpbmFsaXplT2JzZXJ2ZXJzKHByb3RvLCBvYnNlcnZlcnMsIHByb3BzKTtcbiAgICB9XG4gICAgLy8gbm90ZTogY3JlYXRlIFwid29ya2luZ1wiIHRlbXBsYXRlIHRoYXQgaXMgZmluYWxpemVkIGF0IGluc3RhbmNlIHRpbWVcbiAgICBsZXQgdGVtcGxhdGUgPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0LmlubmVySFRNTCA9IHRlbXBsYXRlO1xuICAgICAgICB0ZW1wbGF0ZSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHByb3RvLl90ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBwcm9wZXJ0aWVzYCBvYmplY3QuXG4gICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAqIHN1cHBvcnRpbmcsIG9ic2VydmVycywgcmVmbGVjdGluZyB0byBhdHRyaWJ1dGVzLCBjaGFuZ2Ugbm90aWZpY2F0aW9uLFxuICAgKiBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgcmVhZCBvbmx5IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICogICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgRmxhdHRlbmVkIGJhZyBvZiBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBmb3JcbiAgICogICAgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIHAsIHByb3BlcnRpZXNbcF0sIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBvYnNlcnZlcnNgIGFycmF5LlxuICAgKiBMZXZlcmFnZXMgYFByb3BlcnR5RWZmZWN0c2AgdG8gY3JlYXRlIG9ic2VydmVycy5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlcnMgRmxhdHRlbmVkIGFycmF5IG9mIG9ic2VydmVyIGRlc2NyaXB0b3JzIGZvclxuICAgKiAgIHRoaXMgY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGR5bmFtaWNGbnMgT2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgYW55IHByb3BlcnRpZXNcbiAgICogICB0aGF0IGFyZSBmdW5jdGlvbnMgYW5kIHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3Qgd2hlbiB0aGUgZnVuY3Rpb25cbiAgICogICByZWZlcmVuY2UgaXMgY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgZHluYW1pY0Zucykge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvdG8uX2NyZWF0ZU1ldGhvZE9ic2VydmVyKG9ic2VydmVyc1tpXSwgZHluYW1pY0Zucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZWZmZWN0cyBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogTm90ZSwgb25jZSBhIHByb3BlcnR5IGhhcyBiZWVuIHNldCB0b1xuICAgKiBgcmVhZE9ubHlgLCBgY29tcHV0ZWRgLCBgcmVmbGVjdFRvQXR0cmlidXRlYCwgb3IgYG5vdGlmeWBcbiAgICogdGhlc2UgdmFsdWVzIG1heSBub3QgYmUgY2hhbmdlZC4gRm9yIGV4YW1wbGUsIGEgc3ViY2xhc3MgY2Fubm90XG4gICAqIGFsdGVyIHRoZXNlIHNldHRpbmdzLiBIb3dldmVyLCBhZGRpdGlvbmFsIGBvYnNlcnZlcnNgIG1heSBiZSBhZGRlZFxuICAgKiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBUaGUgaW5mbyBvYmplY3Qgc2hvdWxkIG1heSBjb250YWluIHByb3BlcnR5IG1ldGFkYXRhIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICogYHR5cGVgOiB7ZnVuY3Rpb259IHR5cGUgdG8gd2hpY2ggYW4gYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBwcm9wZXJ0eVxuICAgKiBpcyBkZXNlcmlhbGl6ZWQuIE5vdGUgdGhlIHByb3BlcnR5IGlzIGNhbWVsLWNhc2VkIGZyb20gYSBkYXNoLWNhc2VkXG4gICAqIGF0dHJpYnV0ZS4gRm9yIGV4YW1wbGUsICdmb28tYmFyJyBhdHRyaWJ1dGUgaXMgZGVyc2lhbGl6ZWQgdG8gYVxuICAgKiBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJy5cbiAgICpcbiAgICogKiBgcmVhZE9ubHlgOiB7Ym9vbGVhbn0gY3JlYXRlcyBhIHJlYWRPbmx5IHByb3BlcnR5IGFuZFxuICAgKiBtYWtlcyBhIHByaXZhdGUgc2V0dGVyIGZvciB0aGUgcHJpdmF0ZSBvZiB0aGUgZm9ybSAnX3NldEZvbycgZm9yIGFcbiAgICogcHJvcGVydHkgJ2ZvbycsXG4gICAqXG4gICAqICogYGNvbXB1dGVkYDoge3N0cmluZ30gY3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBBIGNvbXB1dGVkIHByb3BlcnR5XG4gICAqIGFsc28gYXV0b21hdGljYWxseSBpcyBzZXQgdG8gYHJlYWRPbmx5OiB0cnVlYC4gVGhlIHZhbHVlIGlzIGNhbGN1bGF0ZWRcbiAgICogYnkgcnVubmluZyBhIG1ldGhvZCBhbmQgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuIEZvclxuICAgKiBleGFtcGxlICdjb21wdXRlKGZvbyknIHdpbGwgY29tcHV0ZSBhIGdpdmVuIHByb3BlcnR5IHdoZW4gdGhlXG4gICAqICdmb28nIHByb3BlcnR5IGNoYW5nZXMgYnkgZXhlY3V0aW5nIHRoZSAnY29tcHV0ZScgbWV0aG9kLiBUaGlzIG1ldGhvZFxuICAgKiBtdXN0IHJldHVybiB0aGUgY29tcHV0ZWQgdmFsdWUuXG4gICAqXG4gICAqICogYHJlZmxlY3RUb0F0dHJpdXRlYDoge2Jvb2xlYW59IElmIHRydWUsIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZWZsZWN0ZWRcbiAgICogdG8gYW4gYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuIE5vdGUsIHRoZSBhdHRyaWJ1dGUgaXMgZGFzaC1jYXNlZFxuICAgKiBzbyBhIHByb3BlcnR5IG5hbWVkICdmb29CYXInIGlzIHJlZmxlY3RlZCBhcyAnZm9vLWJhcicuXG4gICAqXG4gICAqICogYG5vdGlmeWA6IHtib29sZWFufSBzZW5kcyBhIG5vbi1idWJibGluZyBub3RpZmljYXRpb24gZXZlbnQgd2hlblxuICAgKiB0aGUgcHJvcGVydHkgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIGEgcHJvcGVydHkgbmFtZWQgJ2Zvbycgc2VuZHMgYW5cbiAgICogZXZlbnQgbmFtZWQgJ2Zvby1jaGFuZ2VkJyB3aXRoIGBldmVudC5kZXRhaWxgIHNldCB0byB0aGUgdmFsdWUgb2ZcbiAgICogdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiAqIG9ic2VydmVyOiB7c3RyaW5nfSBuYW1lIG9mIGEgbWV0aG9kIHRoYXQgcnVucyB3aGVuIHRoZSBwcm9wZXJ0eVxuICAgKiBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlICh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkuXG4gICAqXG4gICAqIE5vdGU6IFVzZXJzIG1heSB3YW50IGNvbnRyb2wgb3ZlciBtb2RpZnlpbmcgcHJvcGVydHlcbiAgICogZWZmZWN0cyB2aWEgc3ViY2xhc3NpbmcuIEZvciBleGFtcGxlLCBhIHVzZXIgbWlnaHQgd2FudCB0byBtYWtlIGFcbiAgICogcmVmbGVjdFRvQXR0cmlidXRlIHByb3BlcnR5IG5vdCBkbyBzbyBpbiBhIHN1YmNsYXNzLiBXZSd2ZSBjaG9zZW4gdG9cbiAgICogZGlzYWJsZSB0aGlzIGJlY2F1c2UgaXQgbGVhZHMgdG8gYWRkaXRpb25hbCBjb21wbGljYXRpb24uXG4gICAqIEZvciBleGFtcGxlLCBhIHJlYWRPbmx5IGVmZmVjdCBnZW5lcmF0ZXMgYSBzcGVjaWFsIHNldHRlci4gSWYgYSBzdWJjbGFzc1xuICAgKiBkaXNhYmxlcyB0aGUgZWZmZWN0LCB0aGUgc2V0dGVyIHdvdWxkIGZhaWwgdW5leHBlY3RlZGx5LlxuICAgKiBCYXNlZCBvbiBmZWVkYmFjaywgd2UgbWF5IHdhbnQgdG8gdHJ5IHRvIG1ha2UgZWZmZWN0cyBtb3JlIG1hbGxlYWJsZVxuICAgKiBhbmQvb3IgcHJvdmlkZSBhbiBhZHZhbmNlZCBhcGkgZm9yIG1hbmlwdWxhdGluZyB0aGVtLlxuICAgKiBBbHNvIGNvbnNpZGVyIGFkZGluZyB3YXJuaW5ncyB3aGVuIGFuIGVmZmVjdCBjYW5ub3QgYmUgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyBJbmZvIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNyZWF0ZSBwcm9wZXJ0eSBlZmZlY3RzLlxuICAgKiBTdXBwb3J0ZWQga2V5czpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFsbFByb3BzIEZsYXR0ZW5lZCBtYXAgb2YgYWxsIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzXG4gICAqICAgZWxlbWVudCAoaW5jbHVkaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKHByb3RvLCBuYW1lLCBpbmZvLCBhbGxQcm9wcykge1xuICAgIC8vIGNvbXB1dGVkIGZvcmNlcyByZWFkT25seS4uLlxuICAgIGlmIChpbmZvLmNvbXB1dGVkKSB7XG4gICAgICBpbmZvLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gTm90ZSwgc2luY2UgYWxsIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWRPbmx5LCB0aGlzIHByZXZlbnRzXG4gICAgLy8gYWRkaW5nIGFkZGl0aW9uYWwgY29tcHV0ZWQgcHJvcGVydHkgZWZmZWN0cyAod2hpY2ggbGVhZHMgdG8gYSBjb25mdXNpbmdcbiAgICAvLyBzZXR1cCB3aGVyZSBtdWx0aXBsZSB0cmlnZ2VycyBmb3Igc2V0dGluZyBhIHByb3BlcnR5KVxuICAgIC8vIFdoaWxlIHdlIGRvIGhhdmUgYGhhc0NvbXB1dGVkRWZmZWN0YCB0aGlzIGlzIHNldCBvbiB0aGUgcHJvcGVydHknc1xuICAgIC8vIGRlcGVuZGVuY2llcyByYXRoZXIgdGhhbiBpdHNlbGYuXG4gICAgaWYgKGluZm8uY29tcHV0ZWQgICYmICFwcm90by5faGFzUmVhZE9ubHlFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KG5hbWUsIGluZm8uY29tcHV0ZWQsIGFsbFByb3BzKTtcbiAgICB9XG4gICAgaWYgKGluZm8ucmVhZE9ubHkgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkobmFtZSwgIWluZm8uY29tcHV0ZWQpO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWZsZWN0VG9BdHRyaWJ1dGUgJiYgIXByb3RvLl9oYXNSZWZsZWN0RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGlmIChpbmZvLm5vdGlmeSAmJiAhcHJvdG8uX2hhc05vdGlmeUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICAvLyBhbHdheXMgYWRkIG9ic2VydmVyXG4gICAgaWYgKGluZm8ub2JzZXJ2ZXIpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKG5hbWUsIGluZm8ub2JzZXJ2ZXIsIGFsbFByb3BzW2luZm8ub2JzZXJ2ZXJdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhbiBlbGVtZW50IGBwcm90b2AgdG8gZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGB0ZW1wbGF0ZWAuXG4gICAqIFRoZSBlbGVtZW50IG5hbWUgYGlzYCBhbmQgZXh0ZW5kcyBgZXh0YCBtdXN0IGJlIHNwZWNpZmllZCBmb3IgU2hhZHlDU1NcbiAgICogc3R5bGUgc2NvcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByb2Nlc3MgYW5kIGJpbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgVVJMIGFnYWluc3Qgd2hpY2ggdG8gcmVzb2x2ZSB1cmxzIGluXG4gICAqICAgc3R5bGUgZWxlbWVudCBjc3NUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpcyBUYWcgbmFtZSAob3IgdHlwZSBleHRlbnNpb24gbmFtZSkgZm9yIHRoaXMgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZz19IGV4dCBGb3IgdHlwZSBleHRlbnNpb25zLCB0aGUgdGFnIG5hbWUgdGhhdCB3YXMgZXh0ZW5kZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmFsaXplVGVtcGxhdGUocHJvdG8sIHRlbXBsYXRlLCBiYXNlVVJJLCBpcywgZXh0KSB7XG4gICAgLy8gc3VwcG9ydCBgaW5jbHVkZT1cIm1vZHVsZS1uYW1lXCJgXG4gICAgbGV0IGNzc1RleHQgPVxuICAgICAgY3NzRnJvbU1vZHVsZUltcG9ydHMoaXMpICtcbiAgICAgIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSk7XG4gICAgaWYgKGNzc1RleHQpIHtcbiAgICAgIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gICAgICB0ZW1wbGF0ZS5jb250ZW50Lmluc2VydEJlZm9yZShzdHlsZSwgdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMsIGV4dCk7XG4gICAgfVxuICAgIHByb3RvLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKi9cbiAgY2xhc3MgUG9seW1lckVsZW1lbnQgZXh0ZW5kcyBwb2x5bWVyRWxlbWVudEJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzIFYxIEFQSS4gIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnNcbiAgICAgKiBhIGxpc3Qgb2YgZGFzaC1jYXNlZCBhdHRyaWJ1dGVzIGJhc2VkIG9uIGEgZmxhdHRlbmluZyBvZiBhbGwgcHJvcGVydGllc1xuICAgICAqIGRlY2xhcmVkIGluIGBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKWAgZm9yIHRoaXMgZWxlbWVudCBhbmQgYW55XG4gICAgICogc3VwZXJjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IE9ic2VydmVkIGF0dHJpYnV0ZSBsaXN0XG4gICAgICovXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vYnNlcnZlZEF0dHJpYnV0ZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgbGV0IHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGxpc3QucHVzaChjYW1lbFRvRGFzaENhc2UocHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXMgPSBsaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZSBpcyBjcmVhdGVkIHRvXG4gICAgICogZW5zdXJlIHRoYXQgY2xhc3MgZmluYWxpemF0aW9uIHdvcmsgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAqIE1heSBiZSBjYWxsZWQgYnkgdXNlcnMgdG8gZWFnZXJseSBwZXJmb3JtIGNsYXNzIGZpbmFsaXphdGlvbiB3b3JrXG4gICAgICogcHJpb3IgdG8gdGhlIGNyZWF0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQ2xhc3MgZmluYWxpemF0aW9uIHdvcmsgZ2VuZXJhbGx5IGluY2x1ZGVzIG1ldGEtcHJvZ3JhbW1pbmcgc3VjaCBhc1xuICAgICAqIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgYW55IHByb3BlcnR5IGVmZmVjdCBtZXRhZGF0YSBuZWVkZWQgZm9yXG4gICAgICogdGhlIGZlYXR1cmVzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgaWYgKCFoYXNDbGFzc0ZpbmFsaXplZCh0aGlzKSkge1xuICAgICAgICBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHN0YW1wZWQgaW50byB0aGlzIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKlxuICAgICAqIElmIGEgYHN0YXRpYyBnZXQgaXMoKWAgZ2V0dGVyIGlzIGRlZmluZWQsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICogd2lsbCByZXR1cm4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCBpbiBhIGBkb20tbW9kdWxlYCB3aG9zZSBgaWRgXG4gICAgICogbWF0Y2hlcyB0aGlzIGVsZW1lbnQncyBgaXNgLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZ2V0dGVyIHRvIHJldHVybiBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB0aGUgYGlzYCBnZXR0ZXIgaXMgdW5uZWNlc3NhcnkpLiBUaGUgdGVtcGxhdGUgcmV0dXJuZWRcbiAgICAgKiBtYXkgYmUgZWl0aGVyIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YCBvciBhIHN0cmluZyB0aGF0IHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHBhcnNlZCBpbnRvIGEgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2hlbiBzdWJjbGFzc2luZywgaWYgdGhlIHN1cGVyIGNsYXNzIG92ZXJyb2RlIHRoZSBkZWZhdWx0XG4gICAgICogaW1wbGVtZW50YXRpb24gYW5kIHRoZSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIHByb3ZpZGUgYW4gYWx0ZXJuYXRlXG4gICAgICogdGVtcGxhdGUgdmlhIGEgYGRvbS1tb2R1bGVgLCBpdCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgYW5kXG4gICAgICogcmV0dXJuIGBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJylgLlxuICAgICAqXG4gICAgICogSWYgYSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIG1vZGlmeSB0aGUgc3VwZXIgY2xhc3MgdGVtcGxhdGUsIGl0IHNob3VsZFxuICAgICAqIGNsb25lIGl0IHJhdGhlciB0aGFuIG1vZGlmeSBpdCBpbiBwbGFjZS4gIElmIHRoZSBnZXR0ZXIgZG9lcyBleHBlbnNpdmVcbiAgICAgKiB3b3JrIHN1Y2ggYXMgY2xvbmluZy9tb2RpZnlpbmcgYSB0ZW1wbGF0ZSwgaXQgc2hvdWxkIG1lbW9pemUgdGhlXG4gICAgICogdGVtcGxhdGUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2U6XG4gICAgICpcbiAgICAgKiAgIGxldCBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgY2xhc3MgTXlTdWJDbGFzcyBleHRlbmRzIE15U3VwZXJDbGFzcyB7XG4gICAgICogICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICogICAgICAgaWYgKCFtZW1vaXplZFRlbXBsYXRlKSB7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlID0gc3VwZXIudGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgICAgICAgbGV0IHN1YkNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgKiAgICAgICAgIHN1YkNvbnRlbnQudGV4dENvbnRlbnQgPSAnVGhpcyBjYW1lIGZyb20gTXlTdWJDbGFzcyc7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3ViQ29udGVudCk7XG4gICAgICogICAgICAgfVxuICAgICAqICAgICAgIHJldHVybiBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fHN0cmluZ30gVGVtcGxhdGUgdG8gYmUgc3RhbXBlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX3RlbXBsYXRlJywgdGhpcykpKSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gRG9tTW9kdWxlICYmIERvbU1vZHVsZS5pbXBvcnQoXG4gICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgLy8gbm90ZTogaW1wbGVtZW50ZWQgc28gYSBzdWJjbGFzcyBjYW4gcmV0cmlldmUgdGhlIHN1cGVyXG4gICAgICAgICAgLy8gdGVtcGxhdGU7IGNhbGwgdGhlIHN1cGVyIGltcGwgdGhpcyB3YXkgc28gdGhhdCBgdGhpc2AgcG9pbnRzXG4gICAgICAgICAgLy8gdG8gdGhlIHN1cGVyY2xhc3MuXG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IudGVtcGxhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0aCBtYXRjaGluZyB0aGUgdXJsIGZyb20gd2hpY2ggdGhlIGVsZW1lbnQgd2FzIGltcG9ydGVkLlxuICAgICAqIFRoaXMgcGF0aCBpcyB1c2VkIHRvIHJlc29sdmUgdXJsJ3MgaW4gdGVtcGxhdGUgc3R5bGUgY3NzVGV4dC5cbiAgICAgKiBUaGUgYGltcG9ydFBhdGhgIHByb3BlcnR5IGlzIGFsc28gc2V0IG9uIGVsZW1lbnQgaW5zdGFuY2VzIGFuZCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGNyZWF0ZSBiaW5kaW5ncyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IHBhdGguXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIHBhdGggbWF0Y2hpbmcgdGhlIHVybCBjb250YWluaW5nIGEgYGRvbS1tb2R1bGVgIGVsZW1lbnRcbiAgICAgKiBtYXRjaGluZyB0aGlzIGVsZW1lbnQncyBzdGF0aWMgYGlzYCBwcm9wZXJ0eS5cbiAgICAgKiBOb3RlLCB0aGlzIHBhdGggc2hvdWxkIGNvbnRhaW4gYSB0cmFpbGluZyBgL2AuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBpbXBvcnQgcGF0aCBmb3IgdGhpcyBlbGVtZW50IGNsYXNzXG4gICAgICovXG4gICAgc3RhdGljIGdldCBpbXBvcnRQYXRoKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19pbXBvcnRQYXRoJywgdGhpcykpKSB7XG4gICAgICAgICAgY29uc3QgbW9kdWxlID0gRG9tTW9kdWxlICYmIERvbU1vZHVsZS5pbXBvcnQoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKHRoaXMpLmlzKTtcbiAgICAgICAgICB0aGlzLl9pbXBvcnRQYXRoID0gbW9kdWxlID8gbW9kdWxlLmFzc2V0cGF0aCA6ICcnIHx8XG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IuaW1wb3J0UGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9pbXBvcnRQYXRoO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9cbiAgICAgIHRoaXMuX3RlbXBsYXRlO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLl9pbXBvcnRQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLnJvb3RQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLmltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge1N0YW1wZWRUZW1wbGF0ZSB8IEhUTUxFbGVtZW50IHwgU2hhZG93Um9vdH0gKi9cbiAgICAgIHRoaXMucm9vdDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFOb2RlPn0gKi9cbiAgICAgIHRoaXMuJDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGVuc3VyZSBjbGFzc1xuICAgICAqIG1ldGFwcm9ncmFtbWluZyByZWxhdGVkIHRvIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgZWZmZWN0cyBoYXNcbiAgICAgKiBjb21wbGV0ZWQgKGNhbGxzIGBmaW5hbGl6ZWApLlxuICAgICAqXG4gICAgICogSXQgYWxzbyBpbml0aWFsaXplcyBhbnkgcHJvcGVydHkgZGVmYXVsdHMgcHJvdmlkZWQgdmlhIGB2YWx1ZWAgaW5cbiAgICAgKiBgcHJvcGVydGllc2AgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpbnN0YW5jZUNvdW50Kys7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmZpbmFsaXplKCk7XG4gICAgICBjb25zdCBpbXBvcnRQYXRoID0gdGhpcy5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgLy8gbm90ZTogZmluYWxpemUgdGVtcGxhdGUgd2hlbiB3ZSBoYXZlIGFjY2VzcyB0byBgbG9jYWxOYW1lYCB0b1xuICAgICAgLy8gYXZvaWQgZGVwZW5kZW5jZSBvbiBgaXNgIGZvciBwb2x5ZmlsbGluZyBzdHlsaW5nLlxuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlICYmICF0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYmFzZVVSSSA9XG4gICAgICAgICAgaW1wb3J0UGF0aCA/IHJlc29sdmVVcmwkMChpbXBvcnRQYXRoKSA6ICcnO1xuICAgICAgICBmaW5hbGl6ZVRlbXBsYXRlKC8qKiBAdHlwZSB7IVBvbHltZXJFbGVtZW50fSAqLyh0aGlzLl9fcHJvdG9fXyksIHRoaXMuX3RlbXBsYXRlLCBiYXNlVVJJLFxuICAgICAgICAgIC8qKkB0eXBlIHshSFRNTEVsZW1lbnR9Ki8odGhpcykubG9jYWxOYW1lKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgLy8gc2V0IHBhdGggZGVmYXVsdHNcbiAgICAgIHRoaXMucm9vdFBhdGggPSByb290UGF0aCQwO1xuICAgICAgdGhpcy5pbXBvcnRQYXRoID0gaW1wb3J0UGF0aDtcbiAgICAgIC8vIGFwcGx5IHByb3BlcnR5IGRlZmF1bHRzLi4uXG4gICAgICBsZXQgcCQgPSBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAoIXAkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHAgaW4gcCQpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwJFtwXTtcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IGRlZmF1bHQgdmFsdWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBvd24gcHJvcGVydHksIHdoaWNoXG4gICAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIGBwcm9wZXJ0aWVzYCBwcm9wZXJ0eSB3aXRoIGRlZmF1bHQgYnV0IG5vIGVmZmVjdHMgaGFkXG4gICAgICAgIC8vIGEgcHJvcGVydHkgc2V0IChlLmcuIGJvdW5kKSBieSBpdHMgaG9zdCBiZWZvcmUgdXBncmFkZVxuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB0eXBlb2YgaW5mby52YWx1ZSA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIGluZm8udmFsdWUuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgICBpbmZvLnZhbHVlO1xuICAgICAgICAgIC8vIFNldCB2aWEgYF9zZXRQcm9wZXJ0eWAgaWYgdGhlcmUgaXMgYW4gYWNjZXNzb3IsIHRvIGVuYWJsZVxuICAgICAgICAgIC8vIGluaXRpYWxpemluZyByZWFkT25seSBwcm9wZXJ0eSBkZWZhdWx0c1xuICAgICAgICAgIGlmICh0aGlzLl9oYXNBY2Nlc3NvcihwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1twXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGVuYWJsZXMgdGhlIHByb3BlcnR5IGVmZmVjdHMgc3lzdGVtIGFuZFxuICAgICAqIGZsdXNoZXMgYW55IHBlbmRpbmcgcHJvcGVydGllcywgYW5kIHVwZGF0ZXMgc2hpbW1lZCBDU1MgcHJvcGVydGllc1xuICAgICAqIHdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcvY3VzdG9tIHByb3BlcnRpZXMgcG9seWZpbGwuXG4gICAgICpcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRWxlbWVudCgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcykpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGRpc2Nvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICB9XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5RWZmZWN0c2AncyBgX3JlYWR5Q2xpZW50c2AgY2FsbC4gQXR0YWNoZXNcbiAgICAgKiBlbGVtZW50IGRvbSBieSBjYWxsaW5nIGBfYXR0YWNoRG9tYCB3aXRoIHRoZSBkb20gc3RhbXBlZCBmcm9tIHRoZVxuICAgICAqIGVsZW1lbnQncyB0ZW1wbGF0ZSB2aWEgYF9zdGFtcFRlbXBsYXRlYC4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzXG4gICAgICogY2xpZW50IGRvbSB0byBiZSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCBwcmlvciB0byBhbnkgb2JzZXJ2ZXJzXG4gICAgICogcnVubmluZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fYXR0YWNoRG9tKC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlfSAqLyh0aGlzLnJvb3QpKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBzdXBlci5fcmVhZHlDbGllbnRzIGhlcmUgc2V0cyB0aGUgY2xpZW50cyBpbml0aWFsaXplZCBmbGFnLlxuICAgICAgLy8gV2UgbXVzdCB3YWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBjcmVhdGVkL2F0dGFjaGVkXG4gICAgICAvLyBzbyB0aGF0IHRoaXMgZmxhZyBjYW4gYmUgY2hlY2tlZCB0byBwcmV2ZW50IG5vdGlmaWNhdGlvbnMgZmlyZWRcbiAgICAgIC8vIGR1cmluZyB0aGlzIHByb2Nlc3MgZnJvbSBiZWluZyBoYW5kbGVkIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgIHN1cGVyLl9yZWFkeUNsaWVudHMoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuIGVsZW1lbnQncyBzdGFtcGVkIGRvbSB0byBpdHNlbGYuIEJ5IGRlZmF1bHQsXG4gICAgICogdGhpcyBtZXRob2QgY3JlYXRlcyBhIGBzaGFkb3dSb290YCBhbmQgYWRkcyB0aGUgZG9tIHRvIGl0LlxuICAgICAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFsbG93IGFuIGVsZW1lbnRcbiAgICAgKiB0byBwdXQgaXRzIGRvbSBpbiBhbm90aGVyIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUmV0dXJufVxuICAgICAqIEBwYXJhbSB7U3RhbXBlZFRlbXBsYXRlfSBkb20gdG8gYXR0YWNoIHRvIHRoZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge1NoYWRvd1Jvb3R9IG5vZGUgdG8gd2hpY2ggdGhlIGRvbSBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBfYXR0YWNoRG9tKGRvbSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkb3dSb290O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkb3dET00gbm90IGF2YWlsYWJsZS4gJyArXG4gICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogbW92ZSB0byBjb21waWxlLXRpbWUgY29uZGl0aW9uYWwgd2hlbiBzdXBwb3J0ZWRcbiAgICAgICAgJ1BvbHltZXIuRWxlbWVudCBjYW4gY3JlYXRlIGRvbSBhcyBjaGlsZHJlbiBpbnN0ZWFkIG9mIGluICcgK1xuICAgICAgICAnU2hhZG93RE9NIGJ5IHNldHRpbmcgYHRoaXMucm9vdCA9IHRoaXM7XFxgIGJlZm9yZSBcXGByZWFkeVxcYC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYXR0cmlidXRlcyBkZWNsYXJlZCBpbiBgcHJvcGVydGllc2AgbWV0YWRhdGEgYXJlXG4gICAgICogZGVzZXJpYWxpemVkIHVzaW5nIHRoZWlyIGB0eXBlYCBpbmZvcm1hdGlvbiB0byBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAqIHNhbWUgbmFtZS4gIFwiRGFzaC1jYXNlZFwiIGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsemVkIHRvIFwiY2FtZWxDYXNlXCJcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgbGV0IHR5cGUgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3RvcilbcHJvcGVydHldLnR5cGU7XG4gICAgICAgIGlmICghdGhpcy5faGFzUmVhZE9ubHlFZmZlY3QocHJvcGVydHkpKSB7XG4gICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICAgICAqIHNoaW1tZWQgc3R5bGVzIGluIHRoaXMgZWxlbWVudCAoYW5kIGl0cyBzdWJ0cmVlKSB0byBiZSB1cGRhdGVkXG4gICAgICogYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgICAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiBhcmUgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6IGB0aGlzLnVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAgICAgKlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgQmFnIG9mIGN1c3RvbSBwcm9wZXJ0eSBrZXkvdmFsdWVzIHRvXG4gICAgICogICBhcHBseSB0byB0aGlzIGVsZW1lbnQuXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICovXG4gICAgdXBkYXRlU3R5bGVzKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlU3VidHJlZSgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcyksIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJld3JpdGVzIGEgZ2l2ZW4gVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwuIFRoZSBiYXNlIFVSTCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgZG9jdW1lbnQgY29udGFpbmluZyB0aGUgYGRvbS1tb2R1bGVgIGZvclxuICAgICAqIHRoaXMgZWxlbWVudC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWUgVVJMIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAgKiBidW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlIE9wdGlvbmFsIGJhc2UgVVJMIHRvIHJlc29sdmUgYWdhaW5zdCwgZGVmYXVsdHNcbiAgICAgKiB0byB0aGUgZWxlbWVudCdzIGBpbXBvcnRQYXRoYFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV3cml0dGVuIFVSTCByZWxhdGl2ZSB0byBiYXNlXG4gICAgICovXG4gICAgcmVzb2x2ZVVybCh1cmwsIGJhc2UpIHtcbiAgICAgIGlmICghYmFzZSAmJiB0aGlzLmltcG9ydFBhdGgpIHtcbiAgICAgICAgYmFzZSA9IHJlc29sdmVVcmwkMCh0aGlzLmltcG9ydFBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVVcmwkMCh1cmwsIGJhc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGFkZCBtYXAgb2YgZHluYW1pYyBmdW5jdGlvbnMgb25cbiAgICAgKiB0ZW1wbGF0ZSBpbmZvLCBmb3IgY29uc3VtcHRpb24gYnkgYFByb3BlcnR5RWZmZWN0c2AgdGVtcGxhdGUgYmluZGluZ1xuICAgICAqIGNvZGUuIFRoaXMgbWFwIGRldGVybWluZXMgd2hpY2ggbWV0aG9kIHRlbXBsYXRlcyBzaG91bGQgaGF2ZSBhY2Nlc3NvcnNcbiAgICAgKiBjcmVhdGVkIGZvciB0aGVtLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyB8fCBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQb2x5bWVyRWxlbWVudDtcbn0pO1xuXG5leHBvcnQgbGV0IGluc3RhbmNlQ291bnQgPSAwO1xuZXhwb3J0IGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9yZWdMb2cocHJvdG90eXBlKSB7XG4gIGNvbnNvbGUubG9nKCdbJyArIHByb3RvdHlwZS5pcyArICddOiByZWdpc3RlcmVkJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcihwcm90b3R5cGUpIHtcbiAgcmVnaXN0cmF0aW9ucy5wdXNoKHByb3RvdHlwZSk7XG4gIHVuZGVmaW5lZCAmJiBfcmVnTG9nKHByb3RvdHlwZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkdW1wUmVnaXN0cmF0aW9ucygpIHtcbiAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKF9yZWdMb2cpO1xufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlU3R5bGVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZURvY3VtZW50KHByb3BzKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyBwYXRoRnJvbVVybCB9IGZyb20gJy4vcmVzb2x2ZS11cmwuanMnO1xuXG4vKipcbiAqIExlZ2FjeSBzZXR0aW5ncy5cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmNvbnN0IHNldHRpbmdzID0gdW5kZWZpbmVkIHx8IHt9O1xuZXhwb3J0IGNvbnN0IHVzZVNoYWRvdyA9ICEod2luZG93LlNoYWR5RE9NKTtcbmV4cG9ydCBjb25zdCB1c2VOYXRpdmVDU1NQcm9wZXJ0aWVzID0gQm9vbGVhbighd2luZG93LlNoYWR5Q1NTIHx8IHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MpO1xuZXhwb3J0IGNvbnN0IHVzZU5hdGl2ZUN1c3RvbUVsZW1lbnRzID0gISh3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayk7XG5leHBvcnQgeyBzZXR0aW5ncyBhcyBTZXR0aW5ncyB9O1xuXG4vKipcbiAqIEdsb2JhbGx5IHNldHRhYmxlIHByb3BlcnR5IHRoYXQgaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0b1xuICogYFBvbHltZXIuRWxlbWVudE1peGluYCBpbnN0YW5jZXMsIHVzZWZ1bCBmb3IgYmluZGluZyBpbiB0ZW1wbGF0ZXMgdG9cbiAqIG1ha2UgVVJMJ3MgcmVsYXRpdmUgdG8gYW4gYXBwbGljYXRpb24ncyByb290LiAgRGVmYXVsdHMgdG8gdGhlIG1haW5cbiAqIGRvY3VtZW50IFVSTCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHVzZXJzLiAgSXQgbWF5IGJlIHVzZWZ1bCB0byBzZXRcbiAqIGBQb2x5bWVyLnJvb3RQYXRoYCB0byBwcm92aWRlIGEgc3RhYmxlIGFwcGxpY2F0aW9uIG1vdW50IHBhdGggd2hlblxuICogdXNpbmcgY2xpZW50IHNpZGUgcm91dGluZy5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5sZXQgcm9vdFBhdGggPSB1bmRlZmluZWQgfHxcbiAgcGF0aEZyb21VcmwoZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbmV4cG9ydCB7IHJvb3RQYXRoIH07XG5cbmV4cG9ydCBjb25zdCBzZXRSb290UGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcm9vdFBhdGggPSBwYXRoO1xufTtcblxuLyoqXG4gKiBBIGdsb2JhbCBjYWxsYmFjayB1c2VkIHRvIHNhbml0aXplIGFueSB2YWx1ZSBiZWZvcmUgaW5zZXJ0aW5nIGl0IGludG8gdGhlIERPTS4gVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbiAqXG4gKiAgICAgUG9seW1lciA9IHtcbiAqICAgICAgIHNhbml0aXplRE9NVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBuYW1lLCB0eXBlLCBub2RlKSB7IC4uLiB9XG4gKiAgICAgfVxuICpcbiAqIFdoZXJlOlxuICpcbiAqIGB2YWx1ZWAgaXMgdGhlIHZhbHVlIHRvIHNhbml0aXplLlxuICogYG5hbWVgIGlzIHRoZSBuYW1lIG9mIGFuIGF0dHJpYnV0ZSBvciBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGhyZWYpLlxuICogYHR5cGVgIGluZGljYXRlcyB3aGVyZSB0aGUgdmFsdWUgaXMgYmVpbmcgaW5zZXJ0ZWQ6IG9uZSBvZiBwcm9wZXJ0eSwgYXR0cmlidXRlLCBvciB0ZXh0LlxuICogYG5vZGVgIGlzIHRoZSBub2RlIHdoZXJlIHRoZSB2YWx1ZSBpcyBiZWluZyBpbnNlcnRlZC5cbiAqXG4gKiBAdHlwZSB7KGZ1bmN0aW9uKCosc3RyaW5nLHN0cmluZyxOb2RlKToqKXx1bmRlZmluZWR9XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5sZXQgc2FuaXRpemVET01WYWx1ZSA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IHsgc2FuaXRpemVET01WYWx1ZSB9O1xuXG5leHBvcnQgY29uc3Qgc2V0U2FuaXRpemVET01WYWx1ZSA9IGZ1bmN0aW9uKG5ld1Nhbml0aXplRE9NVmFsdWUpIHtcbiAgc2FuaXRpemVET01WYWx1ZSA9IG5ld1Nhbml0aXplRE9NVmFsdWU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxuY29uc3QgY2FzZU1hcCA9IHt9O1xuY29uc3QgREFTSF9UT19DQU1FTCA9IC8tW2Etel0vZztcbmNvbnN0IENBTUVMX1RPX0RBU0ggPSAvKFtBLVpdKS9nO1xuXG5leHBvcnQgZnVuY3Rpb24gZGFzaFRvQ2FtZWxDYXNlKGRhc2gpIHtcbiAgcmV0dXJuIGNhc2VNYXBbZGFzaF0gfHwgKFxuICAgIGNhc2VNYXBbZGFzaF0gPSBkYXNoLmluZGV4T2YoJy0nKSA8IDAgPyBkYXNoIDogZGFzaC5yZXBsYWNlKERBU0hfVE9fQ0FNRUwsXG4gICAgICAobSkgPT4gbVsxXS50b1VwcGVyQ2FzZSgpXG4gICAgKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxUb0Rhc2hDYXNlKGNhbWVsKSB7XG4gIHJldHVybiBjYXNlTWFwW2NhbWVsXSB8fCAoXG4gICAgY2FzZU1hcFtjYW1lbF0gPSBjYW1lbC5yZXBsYWNlKENBTUVMX1RPX0RBU0gsICctJDEnKS50b0xvd2VyQ2FzZSgpXG4gICk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgeyByb290IGFzIHJvb3QkMCwgaXNBbmNlc3RvciwgaXNEZXNjZW5kYW50LCBnZXQgYXMgZ2V0JDAsIHRyYW5zbGF0ZSwgaXNQYXRoIGFzIGlzUGF0aCQwLCBzZXQgYXMgc2V0JDAsIG5vcm1hbGl6ZSB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuaW1wb3J0ICogYXMgY2FzZU1hcCBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjYW1lbFRvRGFzaENhc2UgYXMgY2FtZWxUb0Rhc2hDYXNlJDAsIGRhc2hUb0NhbWVsQ2FzZSB9IGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IFByb3BlcnR5QWNjZXNzb3JzIH0gZnJvbSAnLi9wcm9wZXJ0eS1hY2Nlc3NvcnMuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVTdGFtcCB9IGZyb20gJy4vdGVtcGxhdGUtc3RhbXAuanMnO1xuaW1wb3J0IHsgc2FuaXRpemVET01WYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3NldHRpbmdzLmpzJztcblxuLyoqIEBjb25zdCB7T2JqZWN0fSAqL1xuY29uc3QgQ2FzZU1hcCA9IGNhc2VNYXA7XG5cbi8vIE1vbm90b25pY2FsbHkgaW5jcmVhc2luZyB1bmlxdWUgSUQgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHMgdHJpZ2dlcmVkXG4vLyBmcm9tIG11bHRpcGxlIHByb3BlcnRpZXMgaW4gdGhlIHNhbWUgdHVyblxubGV0IGRlZHVwZUlkID0gMDtcblxuLyoqXG4gKiBQcm9wZXJ0eSBlZmZlY3QgdHlwZXM7IGVmZmVjdHMgYXJlIHN0b3JlZCBvbiB0aGUgcHJvdG90eXBlIHVzaW5nIHRoZXNlIGtleXNcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFRZUEVTID0ge1xuICBDT01QVVRFOiAnX19jb21wdXRlRWZmZWN0cycsXG4gIFJFRkxFQ1Q6ICdfX3JlZmxlY3RFZmZlY3RzJyxcbiAgTk9USUZZOiAnX19ub3RpZnlFZmZlY3RzJyxcbiAgUFJPUEFHQVRFOiAnX19wcm9wYWdhdGVFZmZlY3RzJyxcbiAgT0JTRVJWRTogJ19fb2JzZXJ2ZUVmZmVjdHMnLFxuICBSRUFEX09OTFk6ICdfX3JlYWRPbmx5J1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogbmFtZTogKHN0cmluZyB8IHVuZGVmaW5lZCksXG4gKiBzdHJ1Y3R1cmVkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZCksXG4gKiB3aWxkY2FyZDogKGJvb2xlYW4gfCB1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgRGF0YVRyaWdnZXI7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBpbmZvOiA/LFxuICogdHJpZ2dlcjogKCFEYXRhVHJpZ2dlciB8IHVuZGVmaW5lZCksXG4gKiBmbjogKCFGdW5jdGlvbiB8IHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBEYXRhRWZmZWN0OyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxubGV0IFByb3BlcnR5RWZmZWN0c1R5cGU7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCB0aGUgbW9kZWwgaGFzIGFuIG93bi1wcm9wZXJ0eSBtYXAgb2YgZWZmZWN0cyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKiBUaGUgbW9kZWwgbWF5IGJlIGEgcHJvdG90eXBlIG9yIGFuIGluc3RhbmNlLlxuICpcbiAqIFByb3BlcnR5IGVmZmVjdHMgYXJlIHN0b3JlZCBhcyBhcnJheXMgb2YgZWZmZWN0cyBieSBwcm9wZXJ0eSBpbiBhIG1hcCxcbiAqIGJ5IG5hbWVkIHR5cGUgb24gdGhlIG1vZGVsLiBlLmcuXG4gKlxuICogICBfX2NvbXB1dGVFZmZlY3RzOiB7XG4gKiAgICAgZm9vOiBbIC4uLiBdLFxuICogICAgIGJhcjogWyAuLi4gXVxuICogICB9XG4gKlxuICogSWYgdGhlIG1vZGVsIGRvZXMgbm90IHlldCBoYXZlIGFuIGVmZmVjdCBtYXAgZm9yIHRoZSB0eXBlLCBvbmUgaXMgY3JlYXRlZFxuICogYW5kIHJldHVybmVkLiAgSWYgaXQgZG9lcywgYnV0IGl0IGlzIG5vdCBhbiBvd24gcHJvcGVydHkgKGkuZS4gdGhlXG4gKiBwcm90b3R5cGUgaGFkIGVmZmVjdHMpLCB0aGUgdGhlIG1hcCBpcyBkZWVwbHkgY2xvbmVkIGFuZCB0aGUgY29weSBpc1xuICogc2V0IG9uIHRoZSBtb2RlbCBhbmQgcmV0dXJuZWQsIHJlYWR5IGZvciBuZXcgZWZmZWN0cyB0byBiZSBhZGRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBQcm9wZXJ0eSBlZmZlY3QgdHlwZVxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5zdXJlT3duRWZmZWN0TWFwKG1vZGVsLCB0eXBlKSB7XG4gIGxldCBlZmZlY3RzID0gbW9kZWxbdHlwZV07XG4gIGlmICghZWZmZWN0cykge1xuICAgIGVmZmVjdHMgPSBtb2RlbFt0eXBlXSA9IHt9O1xuICB9IGVsc2UgaWYgKCFtb2RlbC5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgIGVmZmVjdHMgPSBtb2RlbFt0eXBlXSA9IE9iamVjdC5jcmVhdGUobW9kZWxbdHlwZV0pO1xuICAgIGZvciAobGV0IHAgaW4gZWZmZWN0cykge1xuICAgICAgbGV0IHByb3RvRnggPSBlZmZlY3RzW3BdO1xuICAgICAgbGV0IGluc3RGeCA9IGVmZmVjdHNbcF0gPSBBcnJheShwcm90b0Z4Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8cHJvdG9GeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnN0RnhbaV0gPSBwcm90b0Z4W2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZWZmZWN0cztcbn1cblxuLy8gLS0gZWZmZWN0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogUnVucyBhbGwgZWZmZWN0cyBvZiBhIGdpdmVuIHR5cGUgZm9yIHRoZSBnaXZlbiBzZXQgb2YgcHJvcGVydHkgY2hhbmdlc1xuICogb24gYW4gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3Q9fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5FZmZlY3RzKGluc3QsIGVmZmVjdHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICBpZiAoZWZmZWN0cykge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICBsZXQgaWQgPSBkZWR1cGVJZCsrO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgaWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykpIHtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUnVucyBhIGxpc3Qgb2YgZWZmZWN0cyBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWR1cGVJZCBDb3VudGVyIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBOYW1lIG9mIGNoYW5nZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7Kn0gcHJvcHMgQ2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0geyp9IG9sZFByb3BzIE9sZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGRlZHVwZUlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgbGV0IHJhbiA9IGZhbHNlO1xuICBsZXQgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyByb290JDAocHJvcCkgOiBwcm9wO1xuICBsZXQgZnhzID0gZWZmZWN0c1tyb290UHJvcGVydHldO1xuICBpZiAoZnhzKSB7XG4gICAgZm9yIChsZXQgaT0wLCBsPWZ4cy5sZW5ndGgsIGZ4OyAoaTxsKSAmJiAoZng9ZnhzW2ldKTsgaSsrKSB7XG4gICAgICBpZiAoKCFmeC5pbmZvIHx8IGZ4LmluZm8ubGFzdFJ1biAhPT0gZGVkdXBlSWQpICYmXG4gICAgICAgICAgKCFoYXNQYXRocyB8fCBwYXRoTWF0Y2hlc1RyaWdnZXIocHJvcCwgZngudHJpZ2dlcikpKSB7XG4gICAgICAgIGlmIChmeC5pbmZvKSB7XG4gICAgICAgICAgZnguaW5mby5sYXN0UnVuID0gZGVkdXBlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnguZm4oaW5zdCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBmeC5pbmZvLCBoYXNQYXRocywgZXh0cmFBcmdzKTtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhbjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBwcm9wZXJ0eS9wYXRoIHRoYXQgaGFzIGNoYW5nZWQgbWF0Y2hlcyB0aGUgdHJpZ2dlclxuICogY3JpdGVyaWEgZm9yIGFuIGVmZmVjdC4gIEEgdHJpZ2dlciBpcyBhIGRlc2NyaXB0b3Igd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBzdHJ1Y3R1cmUsIHdoaWNoIG1hdGNoZXMgdGhlIGRlc2NyaXB0b3JzIHJldHVybmVkIGZyb20gYHBhcnNlQXJnYC5cbiAqIGUuZy4gZm9yIGBmb28uYmFyLipgOlxuICogYGBgXG4gKiB0cmlnZ2VyOiB7XG4gKiAgIG5hbWU6ICdhLmInLFxuICogICBzdHJ1Y3R1cmVkOiB0cnVlLFxuICogICB3aWxkY2FyZDogdHJ1ZVxuICogfVxuICogYGBgXG4gKiBJZiBubyB0cmlnZ2VyIGlzIGdpdmVuLCB0aGUgcGF0aCBpcyBkZWVtZWQgdG8gbWF0Y2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCBvciBwcm9wZXJ0eSB0aGF0IGNoYW5nZWRcbiAqIEBwYXJhbSB7RGF0YVRyaWdnZXJ9IHRyaWdnZXIgRGVzY3JpcHRvclxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcGF0aCBtYXRjaGVkIHRoZSB0cmlnZ2VyXG4gKi9cbmZ1bmN0aW9uIHBhdGhNYXRjaGVzVHJpZ2dlcihwYXRoLCB0cmlnZ2VyKSB7XG4gIGlmICh0cmlnZ2VyKSB7XG4gICAgbGV0IHRyaWdnZXJQYXRoID0gdHJpZ2dlci5uYW1lO1xuICAgIHJldHVybiAodHJpZ2dlclBhdGggPT0gcGF0aCkgfHxcbiAgICAgICh0cmlnZ2VyLnN0cnVjdHVyZWQgJiYgaXNBbmNlc3Rvcih0cmlnZ2VyUGF0aCwgcGF0aCkpIHx8XG4gICAgICAodHJpZ2dlci53aWxkY2FyZCAmJiBpc0Rlc2NlbmRhbnQodHJpZ2dlclBhdGgsIHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFwib2JzZXJ2ZXJcIiBlZmZlY3QuXG4gKlxuICogQ2FsbHMgdGhlIG1ldGhvZCB3aXRoIGBpbmZvLm1ldGhvZE5hbWVgIG9uIHRoZSBpbnN0YW5jZSwgcGFzc2luZyB0aGVcbiAqIG5ldyBhbmQgb2xkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk9ic2VydmVyRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IGZuID0gaW5zdFtpbmZvLm1ldGhvZE5hbWVdO1xuICBsZXQgY2hhbmdlZFByb3AgPSBpbmZvLnByb3BlcnR5O1xuICBpZiAoZm4pIHtcbiAgICBmbi5jYWxsKGluc3QsIGluc3QuX19kYXRhW2NoYW5nZWRQcm9wXSwgb2xkUHJvcHNbY2hhbmdlZFByb3BdKTtcbiAgfSBlbHNlIGlmICghaW5mby5keW5hbWljRm4pIHtcbiAgICBjb25zb2xlLndhcm4oJ29ic2VydmVyIG1ldGhvZCBgJyArIGluZm8ubWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSdW5zIFwibm90aWZ5XCIgZWZmZWN0cyBmb3IgYSBzZXQgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSB0aGUgZ2VuZXJpYyBgcnVuRWZmZWN0c2AgbWV0aG9kIGluIHRoYXQgaXRcbiAqIHdpbGwgZGlzcGF0Y2ggcGF0aCBub3RpZmljYXRpb24gZXZlbnRzIGluIHRoZSBjYXNlIHRoYXQgdGhlIHByb3BlcnR5XG4gKiBjaGFuZ2VkIHdhcyBhIHBhdGggYW5kIHRoZSByb290IHByb3BlcnR5IGZvciB0aGF0IHBhdGggZGlkbid0IGhhdmUgYVxuICogXCJub3RpZnlcIiBlZmZlY3QuICBUaGlzIGlzIHRvIG1haW50YWluIDEuMCBiZWhhdmlvciB0aGF0IGRpZCBub3QgcmVxdWlyZVxuICogYG5vdGlmeTogdHJ1ZWAgdG8gZW5zdXJlIG9iamVjdCBzdWItcHJvcGVydHkgbm90aWZpY2F0aW9ucyB3ZXJlXG4gKiBzZW50LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZnlQcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBub3RpZnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3RzKGluc3QsIG5vdGlmeVByb3BzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gIC8vIE5vdGlmeVxuICBsZXQgZnhzID0gaW5zdFtUWVBFUy5OT1RJRlldO1xuICBsZXQgbm90aWZpZWQ7XG4gIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gIC8vIFRyeSBub3JtYWwgbm90aWZ5IGVmZmVjdHM7IGlmIG5vbmUsIGZhbGwgYmFjayB0byB0cnkgcGF0aCBub3RpZmljYXRpb25cbiAgZm9yIChsZXQgcHJvcCBpbiBub3RpZnlQcm9wcykge1xuICAgIGlmIChub3RpZnlQcm9wc1twcm9wXSkge1xuICAgICAgaWYgKGZ4cyAmJiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZnhzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykpIHtcbiAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChoYXNQYXRocyAmJiBub3RpZnlQYXRoKGluc3QsIHByb3AsIHByb3BzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEZsdXNoIGhvc3QgaWYgd2UgYWN0dWFsbHkgbm90aWZpZWQgYW5kIGhvc3Qgd2FzIGJhdGNoaW5nXG4gIC8vIEFuZCB0aGUgaG9zdCBoYXMgYWxyZWFkeSBpbml0aWFsaXplZCBjbGllbnRzOyB0aGlzIHByZXZlbnRzXG4gIC8vIGFuIGlzc3VlIHdpdGggYSBob3N0IG9ic2VydmluZyBkYXRhIGNoYW5nZXMgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICBsZXQgaG9zdDtcbiAgaWYgKG5vdGlmaWVkICYmIChob3N0ID0gaW5zdC5fX2RhdGFIb3N0KSAmJiBob3N0Ll9pbnZhbGlkYXRlUHJvcGVydGllcykge1xuICAgIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgd2l0aCBwYXRoIGluZm9ybWF0aW9uIGluIHRoZSBkZXRhaWxcbiAqIG9iamVjdCB0byBpbmRpY2F0ZSBhIHN1Yi1wYXRoIG9mIHRoZSBwcm9wZXJ0eSB3YXMgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRoYXQgd2FzIGNoYW5nZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBhdGggd2FzIG5vdGlmaWVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlQYXRoKGluc3QsIHBhdGgsIHByb3BzKSB7XG4gIGxldCByb290UHJvcGVydHkgPSByb290JDAocGF0aCk7XG4gIGlmIChyb290UHJvcGVydHkgIT09IHBhdGgpIHtcbiAgICBsZXQgZXZlbnROYW1lID0gY2FtZWxUb0Rhc2hDYXNlJDAocm9vdFByb3BlcnR5KSArICctY2hhbmdlZCc7XG4gICAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBldmVudE5hbWUsIHByb3BzW3BhdGhdLCBwYXRoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRGlzcGF0Y2hlcyB7cHJvcGVydHl9LWNoYW5nZWQgZXZlbnRzIHRvIGluZGljYXRlIGEgcHJvcGVydHkgKG9yIHBhdGgpXG4gKiBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCAoJ3twcm9wZXJ0eX0tY2hhbmdlZCcpXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgY2hhbmdlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXRoIElmIGEgc3ViLXBhdGggb2YgdGhpcyBwcm9wZXJ0eSBjaGFuZ2VkLCB0aGUgcGF0aFxuICogICB0aGF0IGNoYW5nZWQgKG9wdGlvbmFsKS5cbiAqIEBwcml2YXRlXG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBldmVudE5hbWUsIHZhbHVlLCBwYXRoKSB7XG4gIGxldCBkZXRhaWwgPSB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHF1ZXVlUHJvcGVydHk6IHRydWVcbiAgfTtcbiAgaWYgKHBhdGgpIHtcbiAgICBkZXRhaWwucGF0aCA9IHBhdGg7XG4gIH1cbiAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKGluc3QpLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwgfSkpO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFwibm90aWZ5XCIgZWZmZWN0LlxuICpcbiAqIERpc3BhdGNoZXMgYSBub24tYnViYmxpbmcgZXZlbnQgbmFtZWQgYGluZm8uZXZlbnROYW1lYCBvbiB0aGUgaW5zdGFuY2VcbiAqIHdpdGggYSBkZXRhaWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5ldyBgdmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuTm90aWZ5RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzKSB7XG4gIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QkMChwcm9wZXJ0eSkgOiBwcm9wZXJ0eTtcbiAgbGV0IHBhdGggPSByb290UHJvcGVydHkgIT0gcHJvcGVydHkgPyBwcm9wZXJ0eSA6IG51bGw7XG4gIGxldCB2YWx1ZSA9IHBhdGggPyBnZXQkMChpbnN0LCBwYXRoKSA6IGluc3QuX19kYXRhW3Byb3BlcnR5XTtcbiAgaWYgKHBhdGggJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gcHJvcHNbcHJvcGVydHldOyAgLy8gc3BlY2lmaWNhbGx5IGZvciAuc3BsaWNlc1xuICB9XG4gIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgaW5mby5ldmVudE5hbWUsIHZhbHVlLCBwYXRoKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZ1bmN0aW9uIGZvciAyLXdheSBub3RpZmljYXRpb24gZXZlbnRzLiBSZWNlaXZlcyBjb250ZXh0XG4gKiBpbmZvcm1hdGlvbiBjYXB0dXJlZCBpbiB0aGUgYGFkZE5vdGlmeUxpc3RlbmVyYCBjbG9zdXJlIGZyb20gdGhlXG4gKiBgX19ub3RpZnlMaXN0ZW5lcnNgIG1ldGFkYXRhLlxuICpcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBub3RpZmllZCBwcm9wZXJ0eSB0byB0aGUgaG9zdCBwcm9wZXJ0eSBvciBwYXRoLiAgSWZcbiAqIHRoZSBldmVudCBjb250YWluZWQgcGF0aCBpbmZvcm1hdGlvbiwgdHJhbnNsYXRlIHRoYXQgcGF0aCB0byB0aGUgaG9zdFxuICogc2NvcGUncyBuYW1lIGZvciB0aGF0IHBhdGggZmlyc3QuXG4gKlxuICogQHBhcmFtIHtDdXN0b21FdmVudH0gZXZlbnQgTm90aWZpY2F0aW9uIGV2ZW50IChlLmcuICc8cHJvcGVydHk+LWNoYW5nZWQnKVxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBIb3N0IGVsZW1lbnQgaW5zdGFuY2UgaGFuZGxpbmcgdGhlIG5vdGlmaWNhdGlvbiBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGZyb21Qcm9wIENoaWxkIGVsZW1lbnQgcHJvcGVydHkgdGhhdCB3YXMgYm91bmRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b1BhdGggSG9zdCBwcm9wZXJ0eS9wYXRoIHRoYXQgd2FzIGJvdW5kXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG5lZ2F0ZSBXaGV0aGVyIHRoZSBiaW5kaW5nIHdhcyBuZWdhdGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb24oZXZlbnQsIGluc3QsIGZyb21Qcm9wLCB0b1BhdGgsIG5lZ2F0ZSkge1xuICBsZXQgdmFsdWU7XG4gIGxldCBkZXRhaWwgPSAvKiogQHR5cGUge09iamVjdH0gKi8oZXZlbnQuZGV0YWlsKTtcbiAgbGV0IGZyb21QYXRoID0gZGV0YWlsICYmIGRldGFpbC5wYXRoO1xuICBpZiAoZnJvbVBhdGgpIHtcbiAgICB0b1BhdGggPSB0cmFuc2xhdGUoZnJvbVByb3AsIHRvUGF0aCwgZnJvbVBhdGgpO1xuICAgIHZhbHVlID0gZGV0YWlsICYmIGRldGFpbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGV2ZW50LnRhcmdldFtmcm9tUHJvcF07XG4gIH1cbiAgdmFsdWUgPSBuZWdhdGUgPyAhdmFsdWUgOiB2YWx1ZTtcbiAgaWYgKCFpbnN0W1RZUEVTLlJFQURfT05MWV0gfHwgIWluc3RbVFlQRVMuUkVBRF9PTkxZXVt0b1BhdGhdKSB7XG4gICAgaWYgKGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCh0b1BhdGgsIHZhbHVlLCB0cnVlLCBCb29sZWFuKGZyb21QYXRoKSlcbiAgICAgICYmICghZGV0YWlsIHx8ICFkZXRhaWwucXVldWVQcm9wZXJ0eSkpIHtcbiAgICAgIGluc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJyZWZsZWN0XCIgZWZmZWN0LlxuICpcbiAqIFNldHMgdGhlIGF0dHJpYnV0ZSBuYW1lZCBgaW5mby5hdHRyTmFtZWAgdG8gdGhlIGdpdmVuIHByb3BlcnR5IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuUmVmbGVjdEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCB2YWx1ZSA9IGluc3QuX19kYXRhW3Byb3BlcnR5XTtcbiAgaWYgKHNhbml0aXplRE9NVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNhbml0aXplRE9NVmFsdWUodmFsdWUsIGluZm8uYXR0ck5hbWUsICdhdHRyaWJ1dGUnLCAvKiogQHR5cGUge05vZGV9ICovKGluc3QpKTtcbiAgfVxuICBpbnN0Ll9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBpbmZvLmF0dHJOYW1lLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogUnVucyBcImNvbXB1dGVkXCIgZWZmZWN0cyBmb3IgYSBzZXQgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSB0aGUgZ2VuZXJpYyBgcnVuRWZmZWN0c2AgbWV0aG9kIGluIHRoYXQgaXRcbiAqIGNvbnRpbnVlcyB0byBydW4gY29tcHV0ZWQgZWZmZWN0cyBiYXNlZCBvbiB0aGUgb3V0cHV0IG9mIGVhY2ggcGFzcyB1bnRpbFxuICogdGhlcmUgYXJlIG5vIG1vcmUgbmV3bHkgY29tcHV0ZWQgcHJvcGVydGllcy4gIFRoaXMgZW5zdXJlcyB0aGF0IGFsbFxuICogcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYnkgdGhlIGluaXRpYWwgc2V0IG9mIGNoYW5nZXMgYXJlXG4gKiBjb21wdXRlZCBiZWZvcmUgb3RoZXIgZWZmZWN0cyAoYmluZGluZyBwcm9wYWdhdGlvbiwgb2JzZXJ2ZXJzLCBhbmQgbm90aWZ5KVxuICogcnVuLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdHMoaW5zdCwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgbGV0IGNvbXB1dGVFZmZlY3RzID0gaW5zdFtUWVBFUy5DT01QVVRFXTtcbiAgaWYgKGNvbXB1dGVFZmZlY3RzKSB7XG4gICAgbGV0IGlucHV0UHJvcHMgPSBjaGFuZ2VkUHJvcHM7XG4gICAgd2hpbGUgKHJ1bkVmZmVjdHMoaW5zdCwgY29tcHV0ZUVmZmVjdHMsIGlucHV0UHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2xkUHJvcHMsIGluc3QuX19kYXRhT2xkKTtcbiAgICAgIE9iamVjdC5hc3NpZ24oY2hhbmdlZFByb3BzLCBpbnN0Ll9fZGF0YVBlbmRpbmcpO1xuICAgICAgaW5wdXRQcm9wcyA9IGluc3QuX19kYXRhUGVuZGluZztcbiAgICAgIGluc3QuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJjb21wdXRlZCBwcm9wZXJ0eVwiIGVmZmVjdCBieSBydW5uaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGVcbiAqIHZhbHVlcyBvZiB0aGUgYXJndW1lbnRzIHNwZWNpZmllZCBpbiB0aGUgYGluZm9gIG9iamVjdCBhbmQgc2V0dGluZyB0aGVcbiAqIHJldHVybiB2YWx1ZSB0byB0aGUgY29tcHV0ZWQgcHJvcGVydHkgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQ29tcHV0ZWRFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgcmVzdWx0ID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pO1xuICBsZXQgY29tcHV0ZWRQcm9wID0gaW5mby5tZXRob2RJbmZvO1xuICBpZiAoaW5zdC5fX2RhdGFIYXNBY2Nlc3NvciAmJiBpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yW2NvbXB1dGVkUHJvcF0pIHtcbiAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkoY29tcHV0ZWRQcm9wLCByZXN1bHQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGluc3RbY29tcHV0ZWRQcm9wXSA9IHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHBhdGggY2hhbmdlcyBiYXNlZCBvbiBwYXRoIGxpbmtzIHNldCB1cCB1c2luZyB0aGUgYGxpbmtQYXRoc2BcbiAqIEFQSS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aG9zZSBwcm9wcyBhcmUgY2hhbmdpbmdcbiAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PChzdHJpbmd8bnVtYmVyKT59IHBhdGggUGF0aCB0aGF0IGhhcyBjaGFuZ2VkXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIGNoYW5nZWQgcGF0aFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUxpbmtlZFBhdGhzKGluc3QsIHBhdGgsIHZhbHVlKSB7XG4gIGxldCBsaW5rcyA9IGluc3QuX19kYXRhTGlua2VkUGF0aHM7XG4gIGlmIChsaW5rcykge1xuICAgIGxldCBsaW5rO1xuICAgIGZvciAobGV0IGEgaW4gbGlua3MpIHtcbiAgICAgIGxldCBiID0gbGlua3NbYV07XG4gICAgICBpZiAoaXNEZXNjZW5kYW50KGEsIHBhdGgpKSB7XG4gICAgICAgIGxpbmsgPSB0cmFuc2xhdGUoYSwgYiwgcGF0aCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVzY2VuZGFudChiLCBwYXRoKSkge1xuICAgICAgICBsaW5rID0gdHJhbnNsYXRlKGIsIGEsIHBhdGgpO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyAtLSBiaW5kaW5ncyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQWRkcyBiaW5kaW5nIG1ldGFkYXRhIHRvIHRoZSBjdXJyZW50IGBub2RlSW5mb2AsIGFuZCBiaW5kaW5nIGVmZmVjdHNcbiAqIGZvciBhbGwgcGFydCBkZXBlbmRlbmNpZXMgdG8gYHRlbXBsYXRlSW5mb2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICogICBydW5uaW5nIG9uXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kIEJpbmRpbmcga2luZCwgZWl0aGVyICdwcm9wZXJ0eScsICdhdHRyaWJ1dGUnLCBvciAndGV4dCdcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgVGFyZ2V0IHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7IUFycmF5PCFCaW5kaW5nUGFydD59IHBhcnRzIEFycmF5IG9mIGJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmc9fSBsaXRlcmFsIExpdGVyYWwgdGV4dCBzdXJyb3VuZGluZyBiaW5kaW5nIHBhcnRzIChzcGVjaWZpZWRcbiAqICAgb25seSBmb3IgJ3Byb3BlcnR5JyBiaW5kaW5ncywgc2luY2UgdGhlc2UgbXVzdCBiZSBpbml0aWFsaXplZCBhcyBwYXJ0XG4gKiAgIG9mIGJvb3QtdXApXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRCaW5kaW5nKGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBraW5kLCB0YXJnZXQsIHBhcnRzLCBsaXRlcmFsKSB7XG4gIC8vIENyZWF0ZSBiaW5kaW5nIG1ldGFkYXRhIGFuZCBhZGQgdG8gbm9kZUluZm9cbiAgbm9kZUluZm8uYmluZGluZ3MgPSBub2RlSW5mby5iaW5kaW5ncyB8fCBbXTtcbiAgbGV0IC8qKiBCaW5kaW5nICovIGJpbmRpbmcgPSB7IGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwsIGlzQ29tcG91bmQ6IChwYXJ0cy5sZW5ndGggIT09IDEpIH07XG4gIG5vZGVJbmZvLmJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gIC8vIEFkZCBsaXN0ZW5lciBpbmZvIHRvIGJpbmRpbmcgbWV0YWRhdGFcbiAgaWYgKHNob3VsZEFkZExpc3RlbmVyKGJpbmRpbmcpKSB7XG4gICAgbGV0IHtldmVudCwgbmVnYXRlfSA9IGJpbmRpbmcucGFydHNbMF07XG4gICAgYmluZGluZy5saXN0ZW5lckV2ZW50ID0gZXZlbnQgfHwgKENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHRhcmdldCkgKyAnLWNoYW5nZWQnKTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyTmVnYXRlID0gbmVnYXRlO1xuICB9XG4gIC8vIEFkZCBcInByb3BhZ2F0ZVwiIHByb3BlcnR5IGVmZmVjdHMgdG8gdGVtcGxhdGVJbmZvXG4gIGxldCBpbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QubGVuZ3RoO1xuICBmb3IgKGxldCBpPTA7IGk8YmluZGluZy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1tpXTtcbiAgICBwYXJ0LmNvbXBvdW5kSW5kZXggPSBpO1xuICAgIGFkZEVmZmVjdEZvckJpbmRpbmdQYXJ0KGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIGJpbmRpbmcsIHBhcnQsIGluZGV4KTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyB0byB0aGUgZ2l2ZW4gYHRlbXBsYXRlSW5mb2AgZm9yIHRoZSBnaXZlbiBiaW5kaW5nXG4gKiBwYXJ0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAqICAgcnVubmluZyBvblxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBpbnRvIGBub2RlSW5mb0xpc3RgIGZvciB0aGlzIG5vZGVcbiAqL1xuZnVuY3Rpb24gYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpIHtcbiAgaWYgKCFwYXJ0LmxpdGVyYWwpIHtcbiAgICBpZiAoYmluZGluZy5raW5kID09PSAnYXR0cmlidXRlJyAmJiBiaW5kaW5nLnRhcmdldFswXSA9PT0gJy0nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBzZXQgYXR0cmlidXRlICcgKyBiaW5kaW5nLnRhcmdldCArXG4gICAgICAgICcgYmVjYXVzZSBcIi1cIiBpcyBub3QgYSB2YWxpZCBhdHRyaWJ1dGUgc3RhcnRpbmcgY2hhcmFjdGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkZXBlbmRlbmNpZXMgPSBwYXJ0LmRlcGVuZGVuY2llcztcbiAgICAgIGxldCBpbmZvID0geyBpbmRleCwgYmluZGluZywgcGFydCwgZXZhbHVhdG9yOiBjb25zdHJ1Y3RvciB9O1xuICAgICAgZm9yIChsZXQgaj0wOyBqPGRlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgdHJpZ2dlciA9IGRlcGVuZGVuY2llc1tqXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmlnZ2VyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdHJpZ2dlciA9IHBhcnNlQXJnKHRyaWdnZXIpO1xuICAgICAgICAgIHRyaWdnZXIud2lsZGNhcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cnVjdG9yLl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgdHJpZ2dlci5yb290UHJvcGVydHksIHtcbiAgICAgICAgICBmbjogcnVuQmluZGluZ0VmZmVjdCxcbiAgICAgICAgICBpbmZvLCB0cmlnZ2VyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFwiYmluZGluZ1wiIChwcm9wZXJ0eS9wYXRoIGJpbmRpbmcpIGVmZmVjdC5cbiAqXG4gKiBOb3RlIHRoYXQgYmluZGluZyBzeW50YXggaXMgb3ZlcnJpZGFibGUgdmlhIGBfcGFyc2VCaW5kaW5nc2AgYW5kXG4gKiBgX2V2YWx1YXRlQmluZGluZ2AuICBUaGlzIG1ldGhvZCB3aWxsIGNhbGwgYF9ldmFsdWF0ZUJpbmRpbmdgIGZvciBhbnlcbiAqIG5vbi1saXRlcmFsIHBhcnRzIHJldHVybmVkIGZyb20gYF9wYXJzZUJpbmRpbmdzYC4gIEhvd2V2ZXIsXG4gKiB0aGVyZSBpcyBubyBzdXBwb3J0IGZvciBfcGF0aF8gYmluZGluZ3MgdmlhIGN1c3RvbSBiaW5kaW5nIHBhcnRzLFxuICogYXMgdGhpcyBpcyBzcGVjaWZpYyB0byBQb2x5bWVyJ3MgcGF0aCBiaW5kaW5nIHN5bnRheC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHBhcmFtIHtBcnJheX0gbm9kZUxpc3QgTGlzdCBvZiBub2RlcyBhc3NvY2lhdGVkIHdpdGggYG5vZGVJbmZvTGlzdGAgdGVtcGxhdGVcbiAqICAgbWV0YWRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkJpbmRpbmdFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocywgbm9kZUxpc3QpIHtcbiAgbGV0IG5vZGUgPSBub2RlTGlzdFtpbmZvLmluZGV4XTtcbiAgbGV0IGJpbmRpbmcgPSBpbmZvLmJpbmRpbmc7XG4gIGxldCBwYXJ0ID0gaW5mby5wYXJ0O1xuICAvLyBTdWJwYXRoIG5vdGlmaWNhdGlvbjogdHJhbnNmb3JtIHBhdGggYW5kIHNldCB0byBjbGllbnRcbiAgLy8gZS5nLjogZm9vPVwie3tvYmouc3VifX1cIiwgcGF0aDogJ29iai5zdWIucHJvcCcsIHNldCAnZm9vLnByb3AnPW9iai5zdWIucHJvcFxuICBpZiAoaGFzUGF0aHMgJiYgcGFydC5zb3VyY2UgJiYgKHBhdGgubGVuZ3RoID4gcGFydC5zb3VyY2UubGVuZ3RoKSAmJlxuICAgICAgKGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSAmJiAhYmluZGluZy5pc0NvbXBvdW5kICYmXG4gICAgICBub2RlLl9fZGF0YUhhc0FjY2Vzc29yICYmIG5vZGUuX19kYXRhSGFzQWNjZXNzb3JbYmluZGluZy50YXJnZXRdKSB7XG4gICAgbGV0IHZhbHVlID0gcHJvcHNbcGF0aF07XG4gICAgcGF0aCA9IHRyYW5zbGF0ZShwYXJ0LnNvdXJjZSwgYmluZGluZy50YXJnZXQsIHBhdGgpO1xuICAgIGlmIChub2RlLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgaW5zdC5fZW5xdWV1ZUNsaWVudChub2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IHZhbHVlID0gaW5mby5ldmFsdWF0b3IuX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAvLyBQcm9wYWdhdGUgdmFsdWUgdG8gY2hpbGRcbiAgICBhcHBseUJpbmRpbmdWYWx1ZShpbnN0LCBub2RlLCBiaW5kaW5nLCBwYXJ0LCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYW4gXCJiaW5kaW5nXCIgKGJpbmRpbmcpIGVmZmVjdCB0byBhIG5vZGUsXG4gKiBlaXRoZXIgYXMgYSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugb3duaW5nIHRoZSBiaW5kaW5nIGVmZmVjdFxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRhcmdldCBub2RlIGZvciBiaW5kaW5nXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKSB7XG4gIHZhbHVlID0gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCk7XG4gIGlmIChzYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgdmFsdWUgPSBzYW5pdGl6ZURPTVZhbHVlKHZhbHVlLCBiaW5kaW5nLnRhcmdldCwgYmluZGluZy5raW5kLCBub2RlKTtcbiAgfVxuICBpZiAoYmluZGluZy5raW5kID09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gQXR0cmlidXRlIGJpbmRpbmdcbiAgICBpbnN0Ll92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovKG5vZGUpLCB2YWx1ZSwgYmluZGluZy50YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFByb3BlcnR5IGJpbmRpbmdcbiAgICBsZXQgcHJvcCA9IGJpbmRpbmcudGFyZ2V0O1xuICAgIGlmIChub2RlLl9fZGF0YUhhc0FjY2Vzc29yICYmIG5vZGUuX19kYXRhSGFzQWNjZXNzb3JbcHJvcF0pIHtcbiAgICAgIGlmICghbm9kZVtUWVBFUy5SRUFEX09OTFldIHx8ICFub2RlW1RZUEVTLlJFQURfT05MWV1bcHJvcF0pIHtcbiAgICAgICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB2YWx1ZSkpIHtcbiAgICAgICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlICB7XG4gICAgICBpbnN0Ll9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBcImJpbmRpbmdcIiBlZmZlY3QgdmFsdWUgYmFzZWQgb24gY29tcG91bmQgJiBuZWdhdGlvblxuICogZWZmZWN0IG1ldGFkYXRhLCBhcyB3ZWxsIGFzIGhhbmRsaW5nIGZvciBzcGVjaWFsLWNhc2UgcHJvcGVydGllc1xuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCB0b1xuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHsqfSBUcmFuc2Zvcm1lZCB2YWx1ZSB0byBzZXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVCaW5kaW5nVmFsdWUobm9kZSwgdmFsdWUsIGJpbmRpbmcsIHBhcnQpIHtcbiAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgIGxldCBzdG9yYWdlID0gbm9kZS5fX2RhdGFDb21wb3VuZFN0b3JhZ2VbYmluZGluZy50YXJnZXRdO1xuICAgIHN0b3JhZ2VbcGFydC5jb21wb3VuZEluZGV4XSA9IHZhbHVlO1xuICAgIHZhbHVlID0gc3RvcmFnZS5qb2luKCcnKTtcbiAgfVxuICBpZiAoYmluZGluZy5raW5kICE9PSAnYXR0cmlidXRlJykge1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgc2VyaWFsaXplIGB1bmRlZmluZWRgIHRvIGBcInVuZGVmaW5lZFwiYFxuICAgIGlmIChiaW5kaW5nLnRhcmdldCA9PT0gJ3RleHRDb250ZW50JyB8fFxuICAgICAgICAobm9kZS5sb2NhbE5hbWUgPT0gJ2lucHV0JyAmJiBiaW5kaW5nLnRhcmdldCA9PSAndmFsdWUnKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgYmluZGluZydzIG1ldGFkYXRhIG1lZXRzIGFsbCB0aGUgcmVxdWlyZW1lbnRzIHRvIGFsbG93XG4gKiAyLXdheSBiaW5kaW5nLCBhbmQgdGhlcmVmb3JlIGEgYDxwcm9wZXJ0eT4tY2hhbmdlZGAgZXZlbnQgbGlzdGVuZXIgc2hvdWxkIGJlXG4gKiBhZGRlZDpcbiAqIC0gdXNlZCBjdXJseSBicmFjZXNcbiAqIC0gaXMgYSBwcm9wZXJ0eSAobm90IGF0dHJpYnV0ZSkgYmluZGluZ1xuICogLSBpcyBub3QgYSB0ZXh0Q29udGVudCBiaW5kaW5nXG4gKiAtIGlzIG5vdCBjb21wb3VuZFxuICpcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiAyLXdheSBsaXN0ZW5lciBzaG91bGQgYmUgYWRkZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEFkZExpc3RlbmVyKGJpbmRpbmcpIHtcbiAgcmV0dXJuIEJvb2xlYW4oYmluZGluZy50YXJnZXQpICYmXG4gICAgICAgICBiaW5kaW5nLmtpbmQgIT0gJ2F0dHJpYnV0ZScgJiZcbiAgICAgICAgIGJpbmRpbmcua2luZCAhPSAndGV4dCcgJiZcbiAgICAgICAgICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgICAgIGJpbmRpbmcucGFydHNbMF0ubW9kZSA9PT0gJ3snO1xufVxuXG4vKipcbiAqIFNldHVwIGNvbXBvdW5kIGJpbmRpbmcgc3RvcmFnZSBzdHJ1Y3R1cmVzLCBub3RpZnkgbGlzdGVuZXJzLCBhbmQgZGF0YUhvc3RcbiAqIHJlZmVyZW5jZXMgb250byB0aGUgYm91bmQgbm9kZUxpc3QuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0aGF0IGJhcyBiZWVuIHByZXZpb3VzbHkgYm91bmRcbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwQmluZGluZ3MoaW5zdCwgdGVtcGxhdGVJbmZvKSB7XG4gIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIGRhdGFIb3N0LCBhbmQgbm90aWZ5IGxpc3RlbmVyc1xuICBsZXQge25vZGVMaXN0LCBub2RlSW5mb0xpc3R9ID0gdGVtcGxhdGVJbmZvO1xuICBpZiAobm9kZUluZm9MaXN0Lmxlbmd0aCkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVJbmZvTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGluZm8gPSBub2RlSW5mb0xpc3RbaV07XG4gICAgICBsZXQgbm9kZSA9IG5vZGVMaXN0W2ldO1xuICAgICAgbGV0IGJpbmRpbmdzID0gaW5mby5iaW5kaW5ncztcbiAgICAgIGlmIChiaW5kaW5ncykge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgIHNldHVwQ29tcG91bmRTdG9yYWdlKG5vZGUsIGJpbmRpbmcpO1xuICAgICAgICAgIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLl9fZGF0YUhvc3QgPSBpbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGBfX2RhdGFDb21wb3VuZFN0b3JhZ2VgIGxvY2FsIHN0b3JhZ2Ugb24gYSBib3VuZCBub2RlIHdpdGhcbiAqIGluaXRpYWwgbGl0ZXJhbCBkYXRhIGZvciBjb21wb3VuZCBiaW5kaW5ncywgYW5kIHNldHMgdGhlIGpvaW5lZFxuICogbGl0ZXJhbCBwYXJ0cyB0byB0aGUgYm91bmQgcHJvcGVydHkuXG4gKlxuICogV2hlbiBjaGFuZ2VzIHRvIGNvbXBvdW5kIHBhcnRzIG9jY3VyLCB0aGV5IGFyZSBmaXJzdCBzZXQgaW50byB0aGUgY29tcG91bmRcbiAqIHN0b3JhZ2UgYXJyYXkgZm9yIHRoYXQgcHJvcGVydHksIGFuZCB0aGVuIHRoZSBhcnJheSBpcyBqb2luZWQgdG8gcmVzdWx0IGluXG4gKiB0aGUgZmluYWwgdmFsdWUgc2V0IHRvIHRoZSBwcm9wZXJ0eS9hdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIEJvdW5kIG5vZGUgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHtCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwQ29tcG91bmRTdG9yYWdlKG5vZGUsIGJpbmRpbmcpIHtcbiAgaWYgKGJpbmRpbmcuaXNDb21wb3VuZCkge1xuICAgIC8vIENyZWF0ZSBjb21wb3VuZCBzdG9yYWdlIG1hcFxuICAgIGxldCBzdG9yYWdlID0gbm9kZS5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgfHxcbiAgICAgIChub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHt9KTtcbiAgICBsZXQgcGFydHMgPSBiaW5kaW5nLnBhcnRzO1xuICAgIC8vIENvcHkgbGl0ZXJhbHMgZnJvbSBwYXJ0cyBpbnRvIHN0b3JhZ2UgZm9yIHRoaXMgYmluZGluZ1xuICAgIGxldCBsaXRlcmFscyA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGo9MDsgajxwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgbGl0ZXJhbHNbal0gPSBwYXJ0c1tqXS5saXRlcmFsO1xuICAgIH1cbiAgICBsZXQgdGFyZ2V0ID0gYmluZGluZy50YXJnZXQ7XG4gICAgc3RvcmFnZVt0YXJnZXRdID0gbGl0ZXJhbHM7XG4gICAgLy8gQ29uZmlndXJlIHByb3BlcnRpZXMgd2l0aCB0aGVpciBsaXRlcmFsIHBhcnRzXG4gICAgaWYgKGJpbmRpbmcubGl0ZXJhbCAmJiBiaW5kaW5nLmtpbmQgPT0gJ3Byb3BlcnR5Jykge1xuICAgICAgbm9kZVt0YXJnZXRdID0gYmluZGluZy5saXRlcmFsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYSAyLXdheSBiaW5kaW5nIG5vdGlmaWNhdGlvbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbm9kZSBzcGVjaWZpZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBDaGlsZCBlbGVtZW50IHRvIGFkZCBsaXN0ZW5lciB0b1xuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBIb3N0IGVsZW1lbnQgaW5zdGFuY2UgdG8gaGFuZGxlIG5vdGlmaWNhdGlvbiBldmVudFxuICogQHBhcmFtIHtCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZE5vdGlmeUxpc3RlbmVyKG5vZGUsIGluc3QsIGJpbmRpbmcpIHtcbiAgaWYgKGJpbmRpbmcubGlzdGVuZXJFdmVudCkge1xuICAgIGxldCBwYXJ0ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5saXN0ZW5lckV2ZW50LCBmdW5jdGlvbihlKSB7XG4gICAgICBoYW5kbGVOb3RpZmljYXRpb24oZSwgaW5zdCwgYmluZGluZy50YXJnZXQsIHBhcnQuc291cmNlLCBwYXJ0Lm5lZ2F0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gLS0gZm9yIG1ldGhvZC1iYXNlZCBlZmZlY3RzIChjb21wbGV4T2JzZXJ2ZXIgJiBjb21wdXRlZCkgLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGVhY2ggYXJndW1lbnQgaW4gdGhlIG1ldGhvZCBzaWduYXR1cmUgKGFuZFxuICogb3B0aW9uYWxseSwgZm9yIHRoZSBtZXRob2QgbmFtZSBpZiBgZHluYW1pY2AgaXMgdHJ1ZSkgdGhhdCBjYWxscyB0aGVcbiAqIHByb3ZpZGVkIGVmZmVjdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHshTWV0aG9kU2lnbmF0dXJlfSBzaWcgTWV0aG9kIHNpZ25hdHVyZSBtZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBvZiBwcm9wZXJ0eSBlZmZlY3QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlZmZlY3RGbiBGdW5jdGlvbiB0byBydW4gd2hlbiBhcmd1bWVudHMgY2hhbmdlXG4gKiBAcGFyYW0geyo9fSBtZXRob2RJbmZvIEVmZmVjdC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBiZSBpbmNsdWRlZCBpblxuICogICBtZXRob2QgZWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nIHdoZXRoZXJcbiAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC4gTm90ZSxcbiAqICAgZGVmYXVsdHMgdG8gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIHN0YXRpYyAoc2lnLnN0YXRpYyBpcyB0cnVlKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZEVmZmVjdChtb2RlbCwgc2lnLCB0eXBlLCBlZmZlY3RGbiwgbWV0aG9kSW5mbywgZHluYW1pY0ZuKSB7XG4gIGR5bmFtaWNGbiA9IHNpZy5zdGF0aWMgfHwgKGR5bmFtaWNGbiAmJlxuICAgICh0eXBlb2YgZHluYW1pY0ZuICE9PSAnb2JqZWN0JyB8fCBkeW5hbWljRm5bc2lnLm1ldGhvZE5hbWVdKSk7XG4gIGxldCBpbmZvID0ge1xuICAgIG1ldGhvZE5hbWU6IHNpZy5tZXRob2ROYW1lLFxuICAgIGFyZ3M6IHNpZy5hcmdzLFxuICAgIG1ldGhvZEluZm8sXG4gICAgZHluYW1pY0ZuXG4gIH07XG4gIGZvciAobGV0IGk9MCwgYXJnOyAoaTxzaWcuYXJncy5sZW5ndGgpICYmIChhcmc9c2lnLmFyZ3NbaV0pOyBpKyspIHtcbiAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICBtb2RlbC5fYWRkUHJvcGVydHlFZmZlY3QoYXJnLnJvb3RQcm9wZXJ0eSwgdHlwZSwge1xuICAgICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm8sIHRyaWdnZXI6IGFyZ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChkeW5hbWljRm4pIHtcbiAgICBtb2RlbC5fYWRkUHJvcGVydHlFZmZlY3Qoc2lnLm1ldGhvZE5hbWUsIHR5cGUsIHtcbiAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mb1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgd2l0aCBhcmd1bWVudHMgbWFyc2hhbGVkIGZyb20gcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2VcbiAqIGJhc2VkIG9uIHRoZSBtZXRob2Qgc2lnbmF0dXJlIGNvbnRhaW5lZCBpbiB0aGUgZWZmZWN0IG1ldGFkYXRhLlxuICpcbiAqIE11bHRpLXByb3BlcnR5IG9ic2VydmVycywgY29tcHV0ZWQgcHJvcGVydGllcywgYW5kIGlubGluZSBjb21wdXRpbmdcbiAqIGZ1bmN0aW9ucyBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gaW52b2tlIHRoZSBtZXRob2QsIHRoZW4gdXNlIHRoZSByZXR1cm5cbiAqIHZhbHVlIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIG1ldGhvZCBpbnZvY2F0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAvLyB0byBmaW5kIG1ldGhvZHMuIEN1cnJlbnRseSB1c2VkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgbGV0IGNvbnRleHQgPSBpbnN0Ll9tZXRob2RIb3N0IHx8IGluc3Q7XG4gIGxldCBmbiA9IGNvbnRleHRbaW5mby5tZXRob2ROYW1lXTtcbiAgaWYgKGZuKSB7XG4gICAgbGV0IGFyZ3MgPSBtYXJzaGFsQXJncyhpbnN0Ll9fZGF0YSwgaW5mby5hcmdzLCBwcm9wZXJ0eSwgcHJvcHMpO1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIGlmICghaW5mby5keW5hbWljRm4pIHtcbiAgICBjb25zb2xlLndhcm4oJ21ldGhvZCBgJyArIGluZm8ubWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gIH1cbn1cblxuY29uc3QgZW1wdHlBcnJheSA9IFtdO1xuXG4vLyBSZWd1bGFyIGV4cHJlc3Npb25zIHVzZWQgZm9yIGJpbmRpbmdcbmNvbnN0IElERU5UICA9ICcoPzonICsgJ1thLXpBLVpfJF1bXFxcXHcuOiRcXFxcLSpdKicgKyAnKSc7XG5jb25zdCBOVU1CRVIgPSAnKD86JyArICdbLStdP1swLTldKlxcXFwuP1swLTldKyg/OltlRV1bLStdP1swLTldKyk/JyArICcpJztcbmNvbnN0IFNRVU9URV9TVFJJTkcgPSAnKD86JyArICdcXCcoPzpbXlxcJ1xcXFxcXFxcXXxcXFxcXFxcXC4pKlxcJycgKyAnKSc7XG5jb25zdCBEUVVPVEVfU1RSSU5HID0gJyg/OicgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcLikqXCInICsgJyknO1xuY29uc3QgU1RSSU5HID0gJyg/OicgKyBTUVVPVEVfU1RSSU5HICsgJ3wnICsgRFFVT1RFX1NUUklORyArICcpJztcbmNvbnN0IEFSR1VNRU5UID0gJyg/OignICsgSURFTlQgKyAnfCcgKyBOVU1CRVIgKyAnfCcgKyAgU1RSSU5HICsgJylcXFxccyonICsgJyknO1xuY29uc3QgQVJHVU1FTlRTID0gJyg/OicgKyBBUkdVTUVOVCArICcoPzosXFxcXHMqJyArIEFSR1VNRU5UICsgJykqJyArICcpJztcbmNvbnN0IEFSR1VNRU5UX0xJU1QgPSAnKD86JyArICdcXFxcKFxcXFxzKicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBBUkdVTUVOVFMgKyAnPycgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcKVxcXFxzKicgKyAnKSc7XG5jb25zdCBCSU5ESU5HID0gJygnICsgSURFTlQgKyAnXFxcXHMqJyArIEFSR1VNRU5UX0xJU1QgKyAnPycgKyAnKSc7IC8vIEdyb3VwIDNcbmNvbnN0IE9QRU5fQlJBQ0tFVCA9ICcoXFxcXFtcXFxcW3x7eyknICsgJ1xcXFxzKic7XG5jb25zdCBDTE9TRV9CUkFDS0VUID0gJyg/Ol1dfH19KSc7XG5jb25zdCBORUdBVEUgPSAnKD86KCEpXFxcXHMqKT8nOyAvLyBHcm91cCAyXG5jb25zdCBFWFBSRVNTSU9OID0gT1BFTl9CUkFDS0VUICsgTkVHQVRFICsgQklORElORyArIENMT1NFX0JSQUNLRVQ7XG5jb25zdCBiaW5kaW5nUmVnZXggPSBuZXcgUmVnRXhwKEVYUFJFU1NJT04sIFwiZ1wiKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzdHJpbmcgZnJvbSBiaW5kaW5nIHBhcnRzIG9mIGFsbCB0aGUgbGl0ZXJhbCBwYXJ0c1xuICpcbiAqIEBwYXJhbSB7IUFycmF5PEJpbmRpbmdQYXJ0Pn0gcGFydHMgQWxsIHBhcnRzIHRvIHN0cmluZ2lmeVxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgbWFkZSBmcm9tIHRoZSBsaXRlcmFsIHBhcnRzXG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHtcbiAgbGV0IHMgPSAnJztcbiAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGxpdGVyYWwgPSBwYXJ0c1tpXS5saXRlcmFsO1xuICAgIHMgKz0gbGl0ZXJhbCB8fCAnJztcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gZXhwcmVzc2lvbiBzdHJpbmcgZm9yIGEgbWV0aG9kIHNpZ25hdHVyZSwgYW5kIHJldHVybnMgYSBtZXRhZGF0YVxuICogZGVzY3JpYmluZyB0aGUgbWV0aG9kIGluIHRlcm1zIG9mIGBtZXRob2ROYW1lYCwgYHN0YXRpY2AgKHdoZXRoZXIgYWxsIHRoZVxuICogYXJndW1lbnRzIGFyZSBsaXRlcmFscyksIGFuZCBhbiBhcnJheSBvZiBgYXJnc2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byBwYXJzZVxuICogQHJldHVybiB7P01ldGhvZFNpZ25hdHVyZX0gVGhlIG1ldGhvZCBtZXRhZGF0YSBvYmplY3QgaWYgYSBtZXRob2QgZXhwcmVzc2lvbiB3YXNcbiAqICAgZm91bmQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXRob2QoZXhwcmVzc2lvbikge1xuICAvLyB0cmllcyB0byBtYXRjaCB2YWxpZCBqYXZhc2NyaXB0IHByb3BlcnR5IG5hbWVzXG4gIGxldCBtID0gZXhwcmVzc2lvbi5tYXRjaCgvKFteXFxzXSs/KVxcKChbXFxzXFxTXSopXFwpLyk7XG4gIGlmIChtKSB7XG4gICAgbGV0IG1ldGhvZE5hbWUgPSBtWzFdO1xuICAgIGxldCBzaWcgPSB7IG1ldGhvZE5hbWUsIHN0YXRpYzogdHJ1ZSwgYXJnczogZW1wdHlBcnJheSB9O1xuICAgIGlmIChtWzJdLnRyaW0oKSkge1xuICAgICAgLy8gcmVwbGFjZSBlc2NhcGVkIGNvbW1hcyB3aXRoIGNvbW1hIGVudGl0eSwgc3BsaXQgb24gdW4tZXNjYXBlZCBjb21tYXNcbiAgICAgIGxldCBhcmdzID0gbVsyXS5yZXBsYWNlKC9cXFxcLC9nLCAnJmNvbW1hOycpLnNwbGl0KCcsJyk7XG4gICAgICByZXR1cm4gcGFyc2VBcmdzKGFyZ3MsIHNpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaWc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgYW5kIHNldHMgdGhlIGBhcmdzYCBwcm9wZXJ0eSBvZiB0aGUgc3VwcGxpZWRcbiAqIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3QuIFNldHMgdGhlIGBzdGF0aWNgIHByb3BlcnR5IHRvIGZhbHNlIGlmIGFueVxuICogYXJndW1lbnQgaXMgYSBub24tbGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBhcmdMaXN0IEFycmF5IG9mIGFyZ3VtZW50IG5hbWVzXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICogQHJldHVybiB7IU1ldGhvZFNpZ25hdHVyZX0gVGhlIHVwZGF0ZWQgc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcmdzKGFyZ0xpc3QsIHNpZykge1xuICBzaWcuYXJncyA9IGFyZ0xpc3QubWFwKGZ1bmN0aW9uKHJhd0FyZykge1xuICAgIGxldCBhcmcgPSBwYXJzZUFyZyhyYXdBcmcpO1xuICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgIHNpZy5zdGF0aWMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbiAgfSwgdGhpcyk7XG4gIHJldHVybiBzaWc7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGluZGl2aWR1YWwgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFuIGFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAqXG4gKiAgIHtcbiAqICAgICB2YWx1ZTogJ3Byb3AnLCAgICAgICAgLy8gcHJvcGVydHkvcGF0aCBvciBsaXRlcmFsIHZhbHVlXG4gKiAgICAgbGl0ZXJhbDogZmFsc2UsICAgICAgIC8vIHdoZXRoZXIgYXJndW1lbnQgaXMgYSBsaXRlcmFsXG4gKiAgICAgc3RydWN0dXJlZDogZmFsc2UsICAgIC8vIHdoZXRoZXIgdGhlIHByb3BlcnR5IGlzIGEgcGF0aFxuICogICAgIHJvb3RQcm9wZXJ0eTogJ3Byb3AnLCAvLyB0aGUgcm9vdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aFxuICogICAgIHdpbGRjYXJkOiBmYWxzZSAgICAgICAvLyB3aGV0aGVyIHRoZSBhcmd1bWVudCB3YXMgYSB3aWxkY2FyZCAnLionIHBhdGhcbiAqICAgfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdBcmcgVGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAqIEByZXR1cm4geyFNZXRob2RBcmd9IEFyZ3VtZW50IG1ldGFkYXRhIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VBcmcocmF3QXJnKSB7XG4gIC8vIGNsZWFuIHVwIHdoaXRlc3BhY2VcbiAgbGV0IGFyZyA9IHJhd0FyZy50cmltKClcbiAgICAvLyByZXBsYWNlIGNvbW1hIGVudGl0eSB3aXRoIGNvbW1hXG4gICAgLnJlcGxhY2UoLyZjb21tYTsvZywgJywnKVxuICAgIC8vIHJlcGFpciBleHRyYSBlc2NhcGUgc2VxdWVuY2VzOyBub3RlIG9ubHkgY29tbWFzIHN0cmljdGx5IG5lZWRcbiAgICAvLyBlc2NhcGluZywgYnV0IHdlIGFsbG93IGFueSBvdGhlciBjaGFyIHRvIGJlIGVzY2FwZWQgc2luY2UgaXRzXG4gICAgLy8gbGlrZWx5IHVzZXJzIHdpbGwgZG8gdGhpc1xuICAgIC5yZXBsYWNlKC9cXFxcKC4pL2csICdcXCQxJylcbiAgICA7XG4gIC8vIGJhc2ljIGFyZ3VtZW50IGRlc2NyaXB0b3JcbiAgbGV0IGEgPSB7XG4gICAgbmFtZTogYXJnLFxuICAgIHZhbHVlOiAnJyxcbiAgICBsaXRlcmFsOiBmYWxzZVxuICB9O1xuICAvLyBkZXRlY3QgbGl0ZXJhbCB2YWx1ZSAobXVzdCBiZSBTdHJpbmcgb3IgTnVtYmVyKVxuICBsZXQgZmMgPSBhcmdbMF07XG4gIGlmIChmYyA9PT0gJy0nKSB7XG4gICAgZmMgPSBhcmdbMV07XG4gIH1cbiAgaWYgKGZjID49ICcwJyAmJiBmYyA8PSAnOScpIHtcbiAgICBmYyA9ICcjJztcbiAgfVxuICBzd2l0Y2goZmMpIHtcbiAgICBjYXNlIFwiJ1wiOlxuICAgIGNhc2UgJ1wiJzpcbiAgICAgIGEudmFsdWUgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgYS5saXRlcmFsID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgYS52YWx1ZSA9IE51bWJlcihhcmcpO1xuICAgICAgYS5saXRlcmFsID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIC8vIGlmIG5vdCBsaXRlcmFsLCBsb29rIGZvciBzdHJ1Y3R1cmVkIHBhdGhcbiAgaWYgKCFhLmxpdGVyYWwpIHtcbiAgICBhLnJvb3RQcm9wZXJ0eSA9IHJvb3QkMChhcmcpO1xuICAgIC8vIGRldGVjdCBzdHJ1Y3R1cmVkIHBhdGggKGhhcyBkb3RzKVxuICAgIGEuc3RydWN0dXJlZCA9IGlzUGF0aCQwKGFyZyk7XG4gICAgaWYgKGEuc3RydWN0dXJlZCkge1xuICAgICAgYS53aWxkY2FyZCA9IChhcmcuc2xpY2UoLTIpID09ICcuKicpO1xuICAgICAgaWYgKGEud2lsZGNhcmQpIHtcbiAgICAgICAgYS5uYW1lID0gYXJnLnNsaWNlKDAsIC0yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogR2F0aGVyIHRoZSBhcmd1bWVudCB2YWx1ZXMgZm9yIGEgbWV0aG9kIHNwZWNpZmllZCBpbiB0aGUgcHJvdmlkZWQgYXJyYXlcbiAqIG9mIGFyZ3VtZW50IG1ldGFkYXRhLlxuICpcbiAqIFRoZSBgcGF0aGAgYW5kIGB2YWx1ZWAgYXJndW1lbnRzIGFyZSB1c2VkIHRvIGZpbGwgaW4gd2lsZGNhcmQgZGVzY3JpcHRvclxuICogd2hlbiB0aGUgbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCBhcyBhIHJlc3VsdCBvZiBhIHBhdGggbm90aWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEluc3RhbmNlIGRhdGEgc3RvcmFnZSBvYmplY3QgdG8gcmVhZCBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7IUFycmF5PCFNZXRob2RBcmc+fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50IG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIG5hbWUgdGhhdCB0cmlnZ2VyZWQgdGhlIG1ldGhvZCBlZmZlY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gQXJyYXkgb2YgYXJndW1lbnQgdmFsdWVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYXJzaGFsQXJncyhkYXRhLCBhcmdzLCBwYXRoLCBwcm9wcykge1xuICBsZXQgdmFsdWVzID0gW107XG4gIGZvciAobGV0IGk9MCwgbD1hcmdzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICBsZXQgbmFtZSA9IGFyZy5uYW1lO1xuICAgIGxldCB2O1xuICAgIGlmIChhcmcubGl0ZXJhbCkge1xuICAgICAgdiA9IGFyZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZy5zdHJ1Y3R1cmVkKSB7XG4gICAgICAgIHYgPSBnZXQkMChkYXRhLCBuYW1lKTtcbiAgICAgICAgLy8gd2hlbiBkYXRhIGlzIG5vdCBzdG9yZWQgZS5nLiBgc3BsaWNlc2BcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHYgPSBwcm9wc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IGRhdGFbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcmcud2lsZGNhcmQpIHtcbiAgICAgIC8vIE9ubHkgc2VuZCB0aGUgYWN0dWFsIHBhdGggY2hhbmdlZCBpbmZvIGlmIHRoZSBjaGFuZ2UgdGhhdFxuICAgICAgLy8gY2F1c2VkIHRoZSBvYnNlcnZlciB0byBydW4gbWF0Y2hlZCB0aGUgd2lsZGNhcmRcbiAgICAgIGxldCBiYXNlQ2hhbmdlZCA9IChuYW1lLmluZGV4T2YocGF0aCArICcuJykgPT09IDApO1xuICAgICAgbGV0IG1hdGNoZXMgPSAocGF0aC5pbmRleE9mKG5hbWUpID09PSAwICYmICFiYXNlQ2hhbmdlZCk7XG4gICAgICB2YWx1ZXNbaV0gPSB7XG4gICAgICAgIHBhdGg6IG1hdGNoZXMgPyBwYXRoIDogbmFtZSxcbiAgICAgICAgdmFsdWU6IG1hdGNoZXMgPyBwcm9wc1twYXRoXSA6IHYsXG4gICAgICAgIGJhc2U6IHZcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlc1tpXSA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIGRhdGEgYXBpXG5cbi8qKlxuICogU2VuZHMgYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbnMgKGAuc3BsaWNlc2AgYW5kIGAubGVuZ3RoYClcbiAqXG4gKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3Jkc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgc3BsaWNlcykge1xuICBsZXQgc3BsaWNlc1BhdGggPSBwYXRoICsgJy5zcGxpY2VzJztcbiAgaW5zdC5ub3RpZnlQYXRoKHNwbGljZXNQYXRoLCB7IGluZGV4U3BsaWNlczogc3BsaWNlcyB9KTtcbiAgaW5zdC5ub3RpZnlQYXRoKHBhdGggKyAnLmxlbmd0aCcsIGFycmF5Lmxlbmd0aCk7XG4gIC8vIE51bGwgaGVyZSB0byBhbGxvdyBwb3RlbnRpYWxseSBsYXJnZSBzcGxpY2UgcmVjb3JkcyB0byBiZSBHQydlZC5cbiAgaW5zdC5fX2RhdGFbc3BsaWNlc1BhdGhdID0ge2luZGV4U3BsaWNlczogbnVsbH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNwbGljZSByZWNvcmQgYW5kIHNlbmRzIGFuIGFycmF5IHNwbGljZSBub3RpZmljYXRpb24gZm9yXG4gKiB0aGUgZGVzY3JpYmVkIG11dGF0aW9uXG4gKlxuICogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgbm9ybWFsaXplZCBwYXRoc1xuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdGhlIG11dGF0aW9ucyBvY2N1cnJlZCBvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gdGhlIGFycmF5IHRoYXQgd2FzIG11dGF0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0aGUgYXJyYXkgbXV0YXRpb24gb2NjdXJyZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlZENvdW50IE51bWJlciBvZiBhZGRlZCBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gcmVtb3ZlZCBBcnJheSBvZiByZW1vdmVkIGl0ZW1zXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlTcGxpY2UoaW5zdCwgYXJyYXksIHBhdGgsIGluZGV4LCBhZGRlZENvdW50LCByZW1vdmVkKSB7XG4gIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIFt7XG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnQsXG4gICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICBvYmplY3Q6IGFycmF5LFxuICAgIHR5cGU6ICdzcGxpY2UnXG4gIH1dKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIHVwcGVyLWNhc2VkIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTdHJpbmcgdG8gdXBwZXJjYXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFVwcGVyY2FzZWQgc3RyaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cHBlcihuYW1lKSB7XG4gIHJldHVybiBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbn1cblxuZXhwb3J0IGNvbnN0IFByb3BlcnR5RWZmZWN0cyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7c3VwZXJDbGFzc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNvbnN0IHByb3BlcnR5RWZmZWN0c0Jhc2UgPSBUZW1wbGF0ZVN0YW1wKFByb3BlcnR5QWNjZXNzb3JzKHN1cGVyQ2xhc3MpKTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgKiBAZXh0ZW5kcyB7cHJvcGVydHlFZmZlY3RzQmFzZX1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgUHJvcGVydHlFZmZlY3RzIGV4dGVuZHMgcHJvcGVydHlFZmZlY3RzQmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeTtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5O1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2U7XG4gICAgICAvKiogQHR5cGUge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfSAqL1xuICAgICAgdGhpcy5fX2RhdGFIb3N0O1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFUZW1wO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzSW5pdGlhbGl6ZWQ7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YTtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fY29tcHV0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19yZWZsZWN0RWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX25vdGlmeUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19wcm9wYWdhdGVFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fb2JzZXJ2ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19yZWFkT25seTtcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqL1xuICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICB9XG5cbiAgICBnZXQgUFJPUEVSVFlfRUZGRUNUX1RZUEVTKCkge1xuICAgICAgcmV0dXJuIFRZUEVTO1xuICAgIH1cblxuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgaG9zdFN0YWNrLnJlZ2lzdGVySG9zdCh0aGlzKTtcbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAvLyBNYXkgYmUgc2V0IG9uIGluc3RhbmNlIHByaW9yIHRvIHVwZ3JhZGVcbiAgICAgIHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlID0gdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgfHwgbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSG9zdCA9IHRoaXMuX19kYXRhSG9zdCB8fCBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFUZW1wID0ge307XG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gcHJvdmlkZSBhXG4gICAgICogbW9yZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24gb2YgaW5pdGlhbGl6aW5nIHByb3BlcnRpZXMgZnJvbVxuICAgICAqIHRoZSBwcm90b3R5cGUgb24gdGhlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgcHJvdG90eXBlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIHRoaXMuX19kYXRhID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBhdm9pZCBzZXR0aW5nXG4gICAgICogYF9zZXRQcm9wZXJ0eWAncyBgc2hvdWxkTm90aWZ5OiB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb24gdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIGxldCByZWFkT25seSA9IHRoaXNbVFlQRVMuUkVBRF9PTkxZXTtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKCFyZWFkT25seSB8fCAhcmVhZE9ubHlbcHJvcF0pIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB0aGlzLl9fZGF0YVBlbmRpbmcgfHwge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB0aGlzLl9fZGF0YU9sZCB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wXSA9IHRoaXMuX19kYXRhUGVuZGluZ1twcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvdG90eXBlIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBhZGRQcm9wZXJ0eUVmZmVjdGAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgdHlwZSA9PSBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgLy8gZWZmZWN0cyBhcmUgYWNjdW11bGF0ZWQgaW50byBhcnJheXMgcGVyIHByb3BlcnR5IGJhc2VkIG9uIHR5cGVcbiAgICAgIGxldCBlZmZlY3RzID0gZW5zdXJlT3duRWZmZWN0TWFwKHRoaXMsIHR5cGUpW3Byb3BlcnR5XTtcbiAgICAgIGlmICghZWZmZWN0cykge1xuICAgICAgICBlZmZlY3RzID0gdGhpc1t0eXBlXVtwcm9wZXJ0eV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIHByb3BlcnR5IGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGUgZWZmZWN0IHdhcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3QgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgX3JlbW92ZVByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIGxldCBlZmZlY3RzID0gZW5zdXJlT3duRWZmZWN0TWFwKHRoaXMsIHR5cGUpW3Byb3BlcnR5XTtcbiAgICAgIGxldCBpZHggPSBlZmZlY3RzLmluZGV4T2YoZWZmZWN0KTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBlZmZlY3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgcHJvcGVydHkgZWZmZWN0XG4gICAgICogb2YgYSBjZXJ0YWluIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUpIHtcbiAgICAgIGxldCBlZmZlY3RzID0gdGhpc1t0eXBlXTtcbiAgICAgIHJldHVybiBCb29sZWFuKGVmZmVjdHMgJiYgZWZmZWN0c1twcm9wZXJ0eV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWFkIG9ubHlcIlxuICAgICAqIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUmVhZE9ubHlFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVBRF9PTkxZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwibm90aWZ5XCJcbiAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNOb3RpZnlFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwicmVmbGVjdCB0byBhdHRyaWJ1dGVcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc1JlZmxlY3RFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcImNvbXB1dGVkXCJcbiAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNDb21wdXRlZEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5DT01QVVRFKTtcbiAgICB9XG5cbiAgICAvLyBSdW50aW1lIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBwZW5kaW5nIHByb3BlcnR5IG9yIHBhdGguICBJZiB0aGUgcm9vdCBwcm9wZXJ0eSBvZiB0aGUgcGF0aCBpblxuICAgICAqIHF1ZXN0aW9uIGhhZCBubyBhY2Nlc3NvciwgdGhlIHBhdGggaXMgc2V0LCBvdGhlcndpc2UgaXQgaXMgZW5xdWV1ZWRcbiAgICAgKiB2aWEgYF9zZXRQZW5kaW5nUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpc29sYXRlcyByZWxhdGl2ZWx5IGV4cGVuc2l2ZSBmdW5jdGlvbmFsaXR5IG5lY2Vzc2FyeVxuICAgICAqIGZvciB0aGUgcHVibGljIEFQSSAoYHNldGAsIGBzZXRQcm9wZXJ0aWVzYCwgYG5vdGlmeVBhdGhgLCBhbmQgcHJvcGVydHlcbiAgICAgKiBjaGFuZ2UgbGlzdGVuZXJzIHZpYSB7ey4uLn19IGJpbmRpbmdzKSwgc3VjaCB0aGF0IGl0IGlzIG9ubHkgZG9uZVxuICAgICAqIHdoZW4gcGF0aHMgZW50ZXIgdGhlIHN5c3RlbSwgYW5kIG5vdCBhdCBldmVyeSBwcm9wYWdhdGlvbiBzdGVwLiAgSXRcbiAgICAgKiBhbHNvIHNldHMgYSBgX19kYXRhSGFzUGF0aHNgIGZsYWcgb24gdGhlIGluc3RhbmNlIHdoaWNoIGlzIHVzZWQgdG9cbiAgICAgKiBmYXN0LXBhdGggc2xvd2VyIHBhdGgtbWF0Y2hpbmcgY29kZSBpbiB0aGUgcHJvcGVydHkgZWZmZWN0cyBob3N0IHBhdGhzLlxuICAgICAqXG4gICAgICogYHBhdGhgIGNhbiBiZSBhIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHBhdGggcGFydHMgYXMgYWNjZXB0ZWQgYnkgdGhlXG4gICAgICogcHVibGljIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PG51bWJlcnxzdHJpbmc+fSBwYXRoIFBhdGggdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgU2V0IHRvIHRydWUgaWYgdGhpcyBjaGFuZ2Ugc2hvdWxkXG4gICAgICogIGNhdXNlIGEgcHJvcGVydHkgbm90aWZpY2F0aW9uIGV2ZW50IGRpc3BhdGNoXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNQYXRoTm90aWZpY2F0aW9uIElmIHRoZSBwYXRoIGJlaW5nIHNldCBpcyBhIHBhdGhcbiAgICAgKiAgIG5vdGlmaWNhdGlvbiBvZiBhbiBhbHJlYWR5IGNoYW5nZWQgdmFsdWUsIGFzIG9wcG9zZWQgdG8gYSByZXF1ZXN0XG4gICAgICogICB0byBzZXQgYW5kIG5vdGlmeSB0aGUgY2hhbmdlLiAgSW4gdGhlIGxhdHRlciBgZmFsc2VgIGNhc2UsIGEgZGlydHlcbiAgICAgKiAgIGNoZWNrIGlzIHBlcmZvcm1lZCBhbmQgdGhlbiB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBwYXRoIGJlZm9yZVxuICAgICAqICAgZW5xdWV1aW5nIHRoZSBwZW5kaW5nIHByb3BlcnR5IGNoYW5nZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5L3BhdGggd2FzIGVucXVldWVkIGluXG4gICAgICogICB0aGUgcGVuZGluZyBjaGFuZ2VzIGJhZy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgc2hvdWxkTm90aWZ5LCBpc1BhdGhOb3RpZmljYXRpb24pIHtcbiAgICAgIGlmIChpc1BhdGhOb3RpZmljYXRpb24gfHxcbiAgICAgICAgICByb290JDAoQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGhbMF0gOiBwYXRoKSAhPT0gcGF0aCkge1xuICAgICAgICAvLyBEaXJ0eSBjaGVjayBjaGFuZ2VzIGJlaW5nIHNldCB0byBhIHBhdGggYWdhaW5zdCB0aGUgYWN0dWFsIG9iamVjdCxcbiAgICAgICAgLy8gc2luY2UgdGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHBhdGhzIGludG8gdGhlIHN5c3RlbTsgZnJvbSBoZXJlXG4gICAgICAgIC8vIHRoZSBvbmx5IGRpcnR5IGNoZWNrcyBhcmUgYWdhaW5zdCB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gZHVwbGljYXRlIHdvcmsgaW4gdGhlIHNhbWUgdHVybiBvbmx5LiBOb3RlLCBpZiB0aGlzIHdhcyBhIG5vdGlmaWNhdGlvblxuICAgICAgICAvLyBvZiBhIGNoYW5nZSBhbHJlYWR5IHNldCB0byBhIHBhdGggKGlzUGF0aE5vdGlmaWNhdGlvbjogdHJ1ZSksXG4gICAgICAgIC8vIHdlIGFsd2F5cyBsZXQgdGhlIGNoYW5nZSB0aHJvdWdoIGFuZCBza2lwIHRoZSBgc2V0YCBzaW5jZSBpdCB3YXNcbiAgICAgICAgLy8gYWxyZWFkeSBkaXJ0eSBjaGVja2VkIGF0IHRoZSBwb2ludCBvZiBlbnRyeSBhbmQgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gb2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICBpZiAoIWlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgICAgIGxldCBvbGQgPSBnZXQkMCh0aGlzLCBwYXRoKTtcbiAgICAgICAgICBwYXRoID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChzZXQkMCh0aGlzLCBwYXRoLCB2YWx1ZSkpO1xuICAgICAgICAgIC8vIFVzZSBwcm9wZXJ0eS1hY2Nlc3NvcidzIHNpbXBsZXIgZGlydHkgY2hlY2tcbiAgICAgICAgICBpZiAoIXBhdGggfHwgIXN1cGVyLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwYXRoLCB2YWx1ZSwgb2xkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpKSB7XG4gICAgICAgICAgY29tcHV0ZUxpbmtlZFBhdGhzKHRoaXMsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgJiYgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvcltwYXRoXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoLyoqQHR5cGV7c3RyaW5nfSovKHBhdGgpLCB2YWx1ZSwgc2hvdWxkTm90aWZ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW3BhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgdmFsdWUgdG8gYSBub24tUG9seW1lciBlbGVtZW50L25vZGUncyBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBtYWtlcyBhIGJlc3QtZWZmb3J0IGF0IGJpbmRpbmcgaW50ZXJvcDpcbiAgICAgKiBTb21lIG5hdGl2ZSBlbGVtZW50IHByb3BlcnRpZXMgaGF2ZSBzaWRlLWVmZmVjdHMgd2hlblxuICAgICAqIHJlLXNldHRpbmcgdGhlIHNhbWUgdmFsdWUgKGUuZy4gc2V0dGluZyBgPGlucHV0Pi52YWx1ZWAgcmVzZXRzIHRoZVxuICAgICAqIGN1cnNvciBwb3NpdGlvbiksIHNvIHdlIGRvIGEgZGlydHktY2hlY2sgYmVmb3JlIHNldHRpbmcgdGhlIHZhbHVlLlxuICAgICAqIEhvd2V2ZXIsIGZvciBiZXR0ZXIgaW50ZXJvcCB3aXRoIG5vbi1Qb2x5bWVyIGN1c3RvbSBlbGVtZW50cyB0aGF0XG4gICAgICogYWNjZXB0IG9iamVjdHMsIHdlIGV4cGxpY2l0bHkgcmUtc2V0IG9iamVjdCBjaGFuZ2VzIGNvbWluZyBmcm9tIHRoZVxuICAgICAqIFBvbHltZXIgd29ybGQgKHdoaWNoIG1heSBpbmNsdWRlIGRlZXAgb2JqZWN0IGNoYW5nZXMgd2l0aG91dCB0aGVcbiAgICAgKiB0b3AgcmVmZXJlbmNlIGNoYW5naW5nKSwgZXJyaW5nIG9uIHRoZSBzaWRlIG9mIHByb3ZpZGluZyBtb3JlXG4gICAgICogaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSBhbHRlcm5hdGUgYXBwcm9hY2hlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBzZXQgYSBwcm9wZXJ0eSBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFRoZSBwcm9wZXJ0eSB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgICAvLyBJdCBpcyBhIGp1ZGdtZW50IGNhbGwgdGhhdCByZXNldHRpbmcgcHJpbWl0aXZlcyBpc1xuICAgICAgLy8gXCJiYWRcIiBhbmQgcmVzZXR0aW5ncyBvYmplY3RzIGlzIGFsc28gXCJnb29kXCI7IGFsdGVybmF0aXZlbHkgd2UgY291bGRcbiAgICAgIC8vIGltcGxlbWVudCBhIHdoaXRlbGlzdCBvZiB0YWcgJiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBzaG91bGQgbmV2ZXJcbiAgICAgIC8vIGJlIHJlc2V0IChlLmcuIDxpbnB1dD4udmFsdWUgJiYgPHNlbGVjdD4udmFsdWUpXG4gICAgICBpZiAodmFsdWUgIT09IG5vZGVbcHJvcF0gfHwgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIG5vZGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBQcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gaW50cm9kdWNlIHNwZWNpYWxcbiAgICAgKiBkaXJ0eSBjaGVjayBsb2dpYyBkZXBlbmRpbmcgb24gdGhlIHByb3BlcnR5ICYgdmFsdWUgYmVpbmcgc2V0OlxuICAgICAqXG4gICAgICogMS4gQW55IHZhbHVlIHNldCB0byBhIHBhdGggKGUuZy4gJ29iai5wcm9wJzogNDIgb3IgJ29iai5wcm9wJzogey4uLn0pXG4gICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFUZW1wYFxuICAgICAqIDIuIE9iamVjdCBzZXQgdG8gc2ltcGxlIHByb3BlcnR5IChlLmcuICdwcm9wJzogey4uLn0pXG4gICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFUZW1wYCBhbmQgYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdFxuICAgICAqICAgIGBfX2RhdGFUZW1wYCBieSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBfc2hvdWxkUHJvcGVydHlDaGFuZ2VgXG4gICAgICogMy4gUHJpbWl0aXZlIHZhbHVlIHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiA0MilcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YWAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBgX19kYXRhYFxuICAgICAqXG4gICAgICogVGhlIGRpcnR5LWNoZWNrIGlzIGltcG9ydGFudCB0byBwcmV2ZW50IGN5Y2xlcyBkdWUgdG8gdHdvLXdheVxuICAgICAqIG5vdGlmaWNhdGlvbiwgYnV0IHBhdGhzIGFuZCBvYmplY3RzIGFyZSBvbmx5IGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBhbnlcbiAgICAgKiBwcmV2aW91cyB2YWx1ZSBzZXQgZHVyaW5nIHRoaXMgdHVybiB2aWEgYSBcInRlbXBvcmFyeSBjYWNoZVwiIHRoYXQgaXNcbiAgICAgKiBjbGVhcmVkIHdoZW4gdGhlIGxhc3QgYF9wcm9wZXJ0aWVzQ2hhZ2VkYCBleGl0cy4gVGhpcyBpcyBzbzpcbiAgICAgKiBhLiBhbnkgY2FjaGVkIGFycmF5IHBhdGhzIChlLmcuICdhcnJheS4zLnByb3AnKSBtYXkgYmUgaW52YWxpZGF0ZWRcbiAgICAgKiAgICBkdWUgdG8gYXJyYXkgbXV0YXRpb25zIGxpa2Ugc2hpZnQvdW5zaGlmdC9zcGxpY2U7IHRoaXMgaXMgZmluZVxuICAgICAqICAgIHNpbmNlIHBhdGggY2hhbmdlcyBhcmUgZGlydHktY2hlY2tlZCBhdCB1c2VyIGVudHJ5IHBvaW50cyBsaWtlIGBzZXRgXG4gICAgICogYi4gZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgb25seSBsYXN0cyBvbmUgdHVybiB0byBhbGxvdyB0aGUgdXNlclxuICAgICAqICAgIHRvIG11dGF0ZSB0aGUgb2JqZWN0IGluLXBsYWNlIGFuZCByZS1zZXQgaXQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eVxuICAgICAqICAgIGFuZCBoYXZlIGFsbCBzdWItcHJvcGVydGllcyByZS1wcm9wYWdhdGVkIGluIGEgc3Vic2VxdWVudCB0dXJuLlxuICAgICAqXG4gICAgICogVGhlIHRlbXAgY2FjaGUgaXMgbm90IG5lY2Vzc2FyaWx5IHN1ZmZpY2llbnQgdG8gcHJldmVudCBpbnZhbGlkIGFycmF5XG4gICAgICogcGF0aHMsIHNpbmNlIGEgc3BsaWNlIGNhbiBoYXBwZW4gZHVyaW5nIHRoZSBzYW1lIHR1cm4gKHdpdGggcGF0aG9sb2dpY2FsXG4gICAgICogdXNlciBjb2RlKTsgd2UgY291bGQgaW50cm9kdWNlIGEgXCJmaXh1cFwiIGZvciB0ZW1wb3JhcmlseSBjYWNoZWQgYXJyYXlcbiAgICAgKiBwYXRocyBpZiBuZWVkZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvaXNzdWVzLzQyMjdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkTm90aWZ5IFRydWUgaWYgcHJvcGVydHkgc2hvdWxkIGZpcmUgbm90aWZpY2F0aW9uXG4gICAgICogICBldmVudCAoYXBwbGllcyBvbmx5IGZvciBgbm90aWZ5OiB0cnVlYCBwcm9wZXJ0aWVzKVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCBzaG91bGROb3RpZnkpIHtcbiAgICAgIGxldCBpc1BhdGggPSB0aGlzLl9fZGF0YUhhc1BhdGhzICYmIGlzUGF0aCQwKHByb3BlcnR5KTtcbiAgICAgIGxldCBwcmV2UHJvcHMgPSBpc1BhdGggPyB0aGlzLl9fZGF0YVRlbXAgOiB0aGlzLl9fZGF0YTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIHByZXZQcm9wc1twcm9wZXJ0eV0pKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0ge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgb2xkIGlzIGNhcHR1cmVkIGZyb20gdGhlIGxhc3QgdHVyblxuICAgICAgICBpZiAoIShwcm9wZXJ0eSBpbiB0aGlzLl9fZGF0YU9sZCkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGF0aHMgYXJlIHN0b3JlZCBpbiB0ZW1wb3JhcnkgY2FjaGUgKGNsZWFyZWQgYXQgZW5kIG9mIHR1cm4pLFxuICAgICAgICAvLyB3aGljaCBpcyB1c2VkIGZvciBkaXJ0eS1jaGVja2luZywgYWxsIG90aGVycyBzdG9yZWQgaW4gX19kYXRhXG4gICAgICAgIGlmIChpc1BhdGgpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRlbXBbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsIGNoYW5nZXMgZ28gaW50byBwZW5kaW5nIHByb3BlcnR5IGJhZywgcGFzc2VkIHRvIF9wcm9wZXJ0aWVzQ2hhbmdlZFxuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIC8vIFRyYWNrIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgbm90aWZ5IHNlcGFyYXRlbHlcbiAgICAgICAgaWYgKGlzUGF0aCB8fCAodGhpc1tUWVBFUy5OT1RJRlldICYmIHRoaXNbVFlQRVMuTk9USUZZXVtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IHRoaXMuX19kYXRhVG9Ob3RpZnkgfHwge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeVtwcm9wZXJ0eV0gPSBzaG91bGROb3RpZnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIGFsbCBhY2Nlc3NvcnMgc2V0IGBzaG91bGROb3RpZnlgXG4gICAgICogdG8gdHJ1ZSwgZm9yIHBlci1wcm9wZXJ0eSBub3RpZmljYXRpb24gdHJhY2tpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JgJ3MgZGVmYXVsdCBhc3luYyBxdWV1aW5nIG9mXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGA6IGlmIGBfX2RhdGFSZWFkeWAgaXMgZmFsc2UgKGhhcyBub3QgeWV0IGJlZW5cbiAgICAgKiBtYW51YWxseSBmbHVzaGVkKSwgdGhlIGZ1bmN0aW9uIG5vLW9wczsgb3RoZXJ3aXNlIGZsdXNoZXNcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5xdWV1ZXMgdGhlIGdpdmVuIGNsaWVudCBvbiBhIGxpc3Qgb2YgcGVuZGluZyBjbGllbnRzLCB3aG9zZVxuICAgICAqIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlcyBjYW4gbGF0ZXIgYmUgZmx1c2hlZCB2aWEgYSBjYWxsIHRvXG4gICAgICogYF9mbHVzaENsaWVudHNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsaWVudCBQcm9wZXJ0eUVmZmVjdHMgY2xpZW50IHRvIGVucXVldWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2VucXVldWVDbGllbnQoY2xpZW50KSB7XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzID0gdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyB8fCBbXTtcbiAgICAgIGlmIChjbGllbnQgIT09IHRoaXMpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cy5wdXNoKGNsaWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBhbnkgY2xpZW50cyBwcmV2aW91c2x5IGVucXVldWVkIHZpYSBgX2VucXVldWVDbGllbnRgLCBjYXVzaW5nXG4gICAgICogdGhlaXIgYF9mbHVzaFByb3BlcnRpZXNgIG1ldGhvZCB0byBydW4uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZsdXNoQ2xpZW50cygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWFkeUNsaWVudHMoKTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgcG9pbnQgd2hlcmUgYWNjZXNzb3JzIGFyZSB0dXJuZWQgb247IGltcG9ydGFudGx5LFxuICAgICAgICAvLyB0aGlzIGlzIGFmdGVyIGNsaWVudHMgaGF2ZSBmdWxseSByZWFkaWVkLCBwcm92aWRpbmcgYSBndWFyYW50ZWVcbiAgICAgICAgLy8gdGhhdCBhbnkgcHJvcGVydHkgZWZmZWN0cyBvY2N1ciBvbmx5IGFmdGVyIGFsbCBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZW5hYmxlT3JGbHVzaENsaWVudHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiBXZSBlbnN1cmUgY2xpZW50cyBlaXRoZXIgZW5hYmxlIG9yIGZsdXNoIGFzIGFwcHJvcHJpYXRlLiBUaGlzXG4gICAgLy8gaGFuZGxlcyB0d28gY29ybmVyIGNhc2VzOlxuICAgIC8vICgxKSBjbGllbnRzIGZsdXNoIHByb3Blcmx5IHdoZW4gY29ubmVjdGVkL2VuYWJsZWQgYmVmb3JlIHRoZSBob3N0XG4gICAgLy8gZW5hYmxlczsgZS5nLlxuICAgIC8vICAgKGEpIFRlbXBsYXRpemUgc3RhbXBzIHdpdGggbm8gcHJvcGVydGllcyBhbmQgZG9lcyBub3QgZmx1c2ggYW5kXG4gICAgLy8gICAoYikgdGhlIGluc3RhbmNlIGlzIGluc2VydGVkIGludG8gZG9tIGFuZFxuICAgIC8vICAgKGMpIHRoZW4gdGhlIGluc3RhbmNlIGZsdXNoZXMuXG4gICAgLy8gKDIpIGNsaWVudHMgZW5hYmxlIHByb3Blcmx5IHdoZW4gbm90IGNvbm5lY3RlZC9lbmFibGVkIHdoZW4gdGhlIGhvc3RcbiAgICAvLyBmbHVzaGVzOyBlLmcuXG4gICAgLy8gICAoYSkgYSB0ZW1wbGF0ZSBpcyBydW50aW1lIHN0YW1wZWQgYW5kIG5vdCB5ZXQgY29ubmVjdGVkL2VuYWJsZWRcbiAgICAvLyAgIChiKSBhIGhvc3Qgc2V0cyBhIHByb3BlcnR5LCBjYXVzaW5nIHN0YW1wZWQgZG9tIHRvIGZsdXNoXG4gICAgLy8gICAoYykgdGhlIHN0YW1wZWQgZG9tIGVuYWJsZXMuXG4gICAgX19lbmFibGVPckZsdXNoQ2xpZW50cygpIHtcbiAgICAgIGxldCBjbGllbnRzID0gdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgIGlmIChjbGllbnRzKSB7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBjbGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGNsaWVudCA9IGNsaWVudHNbaV07XG4gICAgICAgICAgaWYgKCFjbGllbnQuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICAgICAgY2xpZW50Ll9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGllbnQuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgICAgY2xpZW50Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFueSBpbml0aWFsIHNldHVwIG9uIGNsaWVudCBkb20uIENhbGxlZCBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICogYF9mbHVzaFByb3BlcnRpZXNgIGNhbGwgb24gY2xpZW50IGRvbSBhbmQgYmVmb3JlIGFueSBlbGVtZW50XG4gICAgICogb2JzZXJ2ZXJzIGFyZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBiYWcgb2YgcHJvcGVydHkgY2hhbmdlcyB0byB0aGlzIGluc3RhbmNlLCBhbmRcbiAgICAgKiBzeW5jaHJvbm91c2x5IHByb2Nlc3NlcyBhbGwgZWZmZWN0cyBvZiB0aGUgcHJvcGVydGllcyBhcyBhIGJhdGNoLlxuICAgICAqXG4gICAgICogUHJvcGVydHkgbmFtZXMgbXVzdCBiZSBzaW1wbGUgcHJvcGVydGllcywgbm90IHBhdGhzLiAgQmF0Y2hlZFxuICAgICAqIHBhdGggcHJvcGFnYXRpb24gaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2Ygb25lIG9yIG1vcmUga2V5LXZhbHVlIHBhaXJzIHdob3NlIGtleSBpc1xuICAgICAqICAgYSBwcm9wZXJ0eSBhbmQgdmFsdWUgaXMgdGhlIG5ldyB2YWx1ZSB0byBzZXQgZm9yIHRoYXQgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gc2V0UmVhZE9ubHkgV2hlbiB0cnVlLCBhbnkgcHJpdmF0ZSB2YWx1ZXMgc2V0IGluXG4gICAgICogICBgcHJvcHNgIHdpbGwgYmUgc2V0LiBCeSBkZWZhdWx0LCBgc2V0UHJvcGVydGllc2Agd2lsbCBub3Qgc2V0XG4gICAgICogICBgcmVhZE9ubHk6IHRydWVgIHJvb3QgcHJvcGVydGllcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0UHJvcGVydGllcyhwcm9wcywgc2V0UmVhZE9ubHkpIHtcbiAgICAgIGZvciAobGV0IHBhdGggaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHNldFJlYWRPbmx5IHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV0gfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXVtwYXRoXSkge1xuICAgICAgICAgIC8vVE9ETyhrc2NoYWFmKTogZXhwbGljaXRseSBkaXNhbGxvdyBwYXRocyBpbiBzZXRQcm9wZXJ0eT9cbiAgICAgICAgICAvLyB3aWxkY2FyZCBvYnNlcnZlcnMgY3VycmVudGx5IG9ubHkgcGFzcyB0aGUgZmlyc3QgY2hhbmdlZCBwYXRoXG4gICAgICAgICAgLy8gaW4gdGhlIGBpbmZvYCBvYmplY3QsIGFuZCB5b3UgY291bGQgZG8gc29tZSBvZGQgdGhpbmdzIGJhdGNoaW5nXG4gICAgICAgICAgLy8gcGF0aHMsIGUuZy4geydmb28uYmFyJzogey4uLn0sICdmb28nOiBudWxsfVxuICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCBwcm9wc1twYXRoXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2Agc28gdGhhdCBwcm9wZXJ0eSBhY2Nlc3NvclxuICAgICAqIHNpZGUgZWZmZWN0cyBhcmUgbm90IGVuYWJsZWQgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBmdWxseSByZWFkeS5cbiAgICAgKiBBbHNvIGNhbGxzIGBfZmx1c2hDbGllbnRzYCBjYWxsYmFjayB0byBlbnN1cmUgY2xpZW50IGRvbSBpcyBlbmFibGVkXG4gICAgICogdGhhdCB3YXMgbm90IGVuYWJsZWQgYXMgYSByZXN1bHQgb2YgZmx1c2hpbmcgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgYHN1cGVyLnJlYWR5KClgIGlzIG5vdCBjYWxsZWQgaGVyZSBhcyBpdFxuICAgICAgLy8gaW1tZWRpYXRlbHkgdHVybnMgb24gYWNjZXNzb3JzLiBJbnN0ZWFkLCB3ZSB3YWl0IHVudGlsIGByZWFkeUNsaWVudHNgXG4gICAgICAvLyB0byBlbmFibGUgYWNjZXNzb3JzIHRvIHByb3ZpZGUgYSBndWFyYW50ZWUgdGhhdCBjbGllbnRzIGFyZSByZWFkeVxuICAgICAgLy8gYmVmb3JlIHByb2Nlc3NpbmcgYW55IGFjY2Vzc29ycyBzaWRlIGVmZmVjdHMuXG4gICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIC8vIElmIG5vIGRhdGEgd2FzIHBlbmRpbmcsIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aWxsIG5vdCBgZmx1c2hDbGllbnRzYFxuICAgICAgLy8gc28gZW5zdXJlIHRoaXMgaXMgZG9uZS5cbiAgICAgIGlmICghdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hDbGllbnRzKCk7XG4gICAgICB9XG4gICAgICAvLyBCZWZvcmUgcmVhZHksIGNsaWVudCBub3RpZmljYXRpb25zIGRvIG5vdCB0cmlnZ2VyIF9mbHVzaFByb3BlcnRpZXMuXG4gICAgICAvLyBUaGVyZWZvcmUgYSBmbHVzaCBpcyBuZWNlc3NhcnkgaGVyZSBpZiBkYXRhIGhhcyBiZWVuIHNldC5cbiAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlBY2Nlc3NvcnNgJ3MgcHJvcGVydGllcyBjaGFuZ2VkIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogUnVucyBlYWNoIGNsYXNzIG9mIGVmZmVjdHMgZm9yIHRoZSBiYXRjaCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgaW5cbiAgICAgKiBhIHNwZWNpZmljIG9yZGVyIChjb21wdXRlLCBwcm9wYWdhdGUsIHJlZmxlY3QsIG9ic2VydmUsIG5vdGlmeSkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBsZXQgYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoYW5nZWRQcm9wcyB8fCB7fSk7XG4gICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAvLyBpZiAod2luZG93LmRlYnVnKSB7IGRlYnVnZ2VyOyB9XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICBsZXQgaGFzUGF0aHMgPSB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgLy8gQ29tcHV0ZSBwcm9wZXJ0aWVzXG4gICAgICBydW5Db21wdXRlZEVmZmVjdHModGhpcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gQ2xlYXIgbm90aWZ5IHByb3BlcnRpZXMgcHJpb3IgdG8gcG9zc2libGUgcmVlbnRyeSAocHJvcGFnYXRlLCBvYnNlcnZlKSxcbiAgICAgIC8vIGJ1dCBhZnRlciBjb21wdXRpbmcgZWZmZWN0cyBoYXZlIGEgY2hhbmNlIHRvIGFkZCB0byB0aGVtXG4gICAgICBsZXQgbm90aWZ5UHJvcHMgPSB0aGlzLl9fZGF0YVRvTm90aWZ5O1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICAvLyBQcm9wYWdhdGUgcHJvcGVydGllcyB0byBjbGllbnRzXG4gICAgICB0aGlzLl9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMoY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gRmx1c2ggY2xpZW50c1xuICAgICAgdGhpcy5fZmx1c2hDbGllbnRzKCk7XG4gICAgICAvLyBSZWZsZWN0IHByb3BlcnRpZXNcbiAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5SRUZMRUNUXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gT2JzZXJ2ZSBwcm9wZXJ0aWVzXG4gICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuT0JTRVJWRV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIC8vIE5vdGlmeSBwcm9wZXJ0aWVzIHRvIGhvc3RcbiAgICAgIGlmIChub3RpZnlQcm9wcykge1xuICAgICAgICBydW5Ob3RpZnlFZmZlY3RzKHRoaXMsIG5vdGlmeVByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICB9XG4gICAgICAvLyBDbGVhciB0ZW1wb3JhcnkgY2FjaGUgYXQgZW5kIG9mIHR1cm5cbiAgICAgIGlmICh0aGlzLl9fZGF0YUNvdW50ZXIgPT0gMSkge1xuICAgICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwRW5kKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gcHJvcGFnYXRlIGFueSBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHN0YW1wZWQgdGVtcGxhdGUgbm9kZXNcbiAgICAgKiBtYW5hZ2VkIGJ5IHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMoY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAgIGlmICh0aGlzW1RZUEVTLlBST1BBR0FURV0pIHtcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlBST1BBR0FURV0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgd2hpbGUgKHRlbXBsYXRlSW5mbykge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsXG4gICAgICAgICAgaGFzUGF0aHMsIHRlbXBsYXRlSW5mby5ub2RlTGlzdCk7XG4gICAgICAgIHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzZXMgb25lIGRhdGEgcGF0aCBhcyBhbm90aGVyLCBzdWNoIHRoYXQgcGF0aCBub3RpZmljYXRpb25zIGZyb20gb25lXG4gICAgICogYXJlIHJvdXRlZCB0byB0aGUgb3RoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gdG8gVGFyZ2V0IHBhdGggdG8gbGluay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gZnJvbSBTb3VyY2UgcGF0aCB0byBsaW5rLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBsaW5rUGF0aHModG8sIGZyb20pIHtcbiAgICAgIHRvID0gbm9ybWFsaXplKHRvKTtcbiAgICAgIGZyb20gPSBub3JtYWxpemUoZnJvbSk7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRocyB8fCB7fTtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHNbdG9dID0gZnJvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZGF0YSBwYXRoIGFsaWFzIHByZXZpb3VzbHkgZXN0YWJsaXNoZWQgd2l0aCBgX2xpbmtQYXRoc2AuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGUgcGF0aCB0byB1bmxpbmsgc2hvdWxkIGJlIHRoZSB0YXJnZXQgKGB0b2ApIHVzZWQgd2hlblxuICAgICAqIGxpbmtpbmcgdGhlIHBhdGhzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggVGFyZ2V0IHBhdGggdG8gdW5saW5rLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bmxpbmtQYXRocyhwYXRoKSB7XG4gICAgICBwYXRoID0gbm9ybWFsaXplKHBhdGgpO1xuICAgICAgaWYgKHRoaXMuX19kYXRhTGlua2VkUGF0aHMpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX19kYXRhTGlua2VkUGF0aHNbcGF0aF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYW4gYXJyYXkgaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIHRoaXMuaXRlbXMgPSBbIHtuYW1lOiAnSmltJ30sIHtuYW1lOiAnVG9kZCd9LCB7bmFtZTogJ0JpbGwnfSBdO1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgICAgdGhpcy5pdGVtcy5zcGxpY2UoMSwgMSwge25hbWU6ICdTYW0nfSk7XG4gICAgICogICAgIHRoaXMuaXRlbXMucHVzaCh7bmFtZTogJ0JvYid9KTtcbiAgICAgKiAgICAgdGhpcy5ub3RpZnlTcGxpY2VzKCdpdGVtcycsIFtcbiAgICAgKiAgICAgICB7IGluZGV4OiAxLCByZW1vdmVkOiBbe25hbWU6ICdUb2RkJ31dLCBhZGRlZENvdW50OiAxLCBvYmVjdDogdGhpcy5pdGVtcywgdHlwZTogJ3NwbGljZScgfSxcbiAgICAgKiAgICAgICB7IGluZGV4OiAzLCByZW1vdmVkOiBbXSwgYWRkZWRDb3VudDogMSwgb2JqZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJ31cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNwbGljZXMgQXJyYXkgb2Ygc3BsaWNlIHJlY29yZHMgaW5kaWNhdGluZyBvcmRlcmVkXG4gICAgICogICBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgdG8gdGhlIGFycmF5LiBFYWNoIHJlY29yZCBzaG91bGQgaGF2ZSB0aGVcbiAgICAgKiAgIGZvbGxvd2luZyBmaWVsZHM6XG4gICAgICogICAgKiBpbmRleDogaW5kZXggYXQgd2hpY2ggdGhlIGNoYW5nZSBvY2N1cnJlZFxuICAgICAqICAgICogcmVtb3ZlZDogYXJyYXkgb2YgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGlzIGluZGV4XG4gICAgICogICAgKiBhZGRlZENvdW50OiBudW1iZXIgb2YgbmV3IGl0ZW1zIGFkZGVkIGF0IHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIG9iamVjdDogYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5IGluIHF1ZXN0aW9uXG4gICAgICogICAgKiB0eXBlOiB0aGUgc3RyaW5nIGxpdGVyYWwgJ3NwbGljZSdcbiAgICAgKlxuICAgICAqICAgTm90ZSB0aGF0IHNwbGljZSByZWNvcmRzIF9tdXN0XyBiZSBub3JtYWxpemVkIHN1Y2ggdGhhdCB0aGV5IGFyZVxuICAgICAqICAgcmVwb3J0ZWQgaW4gaW5kZXggb3JkZXIgKHJhdyByZXN1bHRzIGZyb20gYE9iamVjdC5vYnNlcnZlYCBhcmUgbm90XG4gICAgICogICBvcmRlcmVkIGFuZCBtdXN0IGJlIG5vcm1hbGl6ZWQvbWVyZ2VkIGJlZm9yZSBub3RpZnlpbmcpLlxuICAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIG5vdGlmeVNwbGljZXMocGF0aCwgc3BsaWNlcykge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbm90aWZ5U3BsaWNlcyh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzcGxpY2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHJlYWRpbmcgYSB2YWx1ZSBmcm9tIGEgcGF0aC5cbiAgICAgKlxuICAgICAqIE5vdGUsIGlmIGFueSBwYXJ0IGluIHRoZSBwYXRoIGlzIHVuZGVmaW5lZCwgdGhpcyBtZXRob2QgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgICh0aGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyB3aGVuIGRlcmVmZXJlbmNpbmcgdW5kZWZpbmVkXG4gICAgICogcGF0aHMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfCFBcnJheTwoc3RyaW5nfG51bWJlcik+KX0gcGF0aCBQYXRoIHRvIHRoZSB2YWx1ZVxuICAgICAqICAgdG8gcmVhZC4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYGZvby5iYXIuYmF6YClcbiAgICAgKiAgIG9yIGFuIGFycmF5IG9mIHBhdGggcGFydHMgKGUuZy4gYFsnZm9vLmJhcicsICdiYXonXWApLiAgTm90ZSB0aGF0XG4gICAgICogICBicmFja2V0ZWQgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQ7IHN0cmluZy1iYXNlZCBwYXRoIHBhcnRzXG4gICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICogICBpbmRpY2VzLCB0aGUgaW5kZXggbWF5IGJlIHVzZWQgYXMgYSBkb3R0ZWQgcGFydCBkaXJlY3RseVxuICAgICAqICAgKGUuZy4gYHVzZXJzLjEyLm5hbWVgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICogQHJldHVybiB7Kn0gVmFsdWUgYXQgdGhlIHBhdGgsIG9yIGB1bmRlZmluZWRgIGlmIGFueSBwYXJ0IG9mIHRoZSBwYXRoXG4gICAgICogICBpcyB1bmRlZmluZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldChwYXRoLCByb290KSB7XG4gICAgICByZXR1cm4gZ2V0JDAocm9vdCB8fCB0aGlzLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIHNldHRpbmcgYSB2YWx1ZSB0byBhIHBhdGggYW5kIG5vdGlmeWluZyBhbnlcbiAgICAgKiBlbGVtZW50cyBib3VuZCB0byB0aGUgc2FtZSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggZXhjZXB0IGZvciB0aGUgbGFzdCBpcyB1bmRlZmluZWQsXG4gICAgICogdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nICh0aGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyB3aGVuXG4gICAgICogZGVyZWZlcmVuY2luZyB1bmRlZmluZWQgcGF0aHMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfCFBcnJheTwoc3RyaW5nfG51bWJlcik+KX0gcGF0aCBQYXRoIHRvIHRoZSB2YWx1ZVxuICAgICAqICAgdG8gd3JpdGUuICBUaGUgcGF0aCBtYXkgYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChlLmcuIGAnZm9vLmJhci5iYXonYClcbiAgICAgKiAgIG9yIGFuIGFycmF5IG9mIHBhdGggcGFydHMgKGUuZy4gYFsnZm9vLmJhcicsICdiYXonXWApLiAgTm90ZSB0aGF0XG4gICAgICogICBicmFja2V0ZWQgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQ7IHN0cmluZy1iYXNlZCBwYXRoIHBhcnRzXG4gICAgICogICAqbXVzdCogYmUgc2VwYXJhdGVkIGJ5IGRvdHMuICBOb3RlIHRoYXQgd2hlbiBkZXJlZmVyZW5jaW5nIGFycmF5XG4gICAgICogICBpbmRpY2VzLCB0aGUgaW5kZXggbWF5IGJlIHVzZWQgYXMgYSBkb3R0ZWQgcGFydCBkaXJlY3RseVxuICAgICAqICAgKGUuZy4gYCd1c2Vycy4xMi5uYW1lJ2Agb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0IGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHJvb3QgUm9vdCBvYmplY3QgZnJvbSB3aGljaCB0aGUgcGF0aCBpcyBldmFsdWF0ZWQuXG4gICAgICogICBXaGVuIHNwZWNpZmllZCwgbm8gbm90aWZpY2F0aW9uIHdpbGwgb2NjdXIuXG4gICAgICogQHB1YmxpY1xuICAgICovXG4gICAgc2V0KHBhdGgsIHZhbHVlLCByb290KSB7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICBzZXQkMChyb290LCBwYXRoLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldWy8qKiBAdHlwZSB7c3RyaW5nfSAqLyhwYXRoKV0pIHtcbiAgICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gcHVzaCBvbnRvIGFycmF5XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBOZXcgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcHVzaChwYXRoLCAuLi5pdGVtcykge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0qLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnB1c2goLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgbGVuLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGVuZCBvZiBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnBvcGAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHBvcChwYXRoKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnBvcCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgYXJyYXkubGVuZ3RoLCAwLCBbcmV0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdGhlIHN0YXJ0IGluZGV4IHNwZWNpZmllZCwgcmVtb3ZlcyAwIG9yIG1vcmUgaXRlbXNcbiAgICAgKiBmcm9tIHRoZSBhcnJheSBhbmQgaW5zZXJ0cyAwIG9yIG1vcmUgbmV3IGl0ZW1zIGluIHRoZWlyIHBsYWNlLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IEluZGV4IGZyb20gd2hpY2ggdG8gc3RhcnQgcmVtb3ZpbmcvaW5zZXJ0aW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxldGVDb3VudCBOdW1iZXIgb2YgaXRlbXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGludG8gYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHJlbW92ZWQgaXRlbXMuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNwbGljZShwYXRoLCBzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoIDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgLy8gTm9ybWFsaXplIGZhbmN5IG5hdGl2ZSBzcGxpY2UgaGFuZGxpbmcgb2YgY3Jhenkgc3RhcnQgdmFsdWVzXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gYXJyYXkubGVuZ3RoIC0gTWF0aC5mbG9vcigtc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgbGV0IHJldCA9IGFycmF5LnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggfHwgcmV0Lmxlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgc3RhcnQsIGl0ZW1zLmxlbmd0aCwgcmV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnBvcGAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHsqfSBJdGVtIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNoaWZ0KHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkuc2hpZnQoKTtcbiAgICAgIGlmIChoYWRMZW5ndGgpIHtcbiAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIDAsIDAsIFtyZXRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBpdGVtcyBvbnRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucHVzaGAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIGluc2VydCBpbmZvIGFycmF5XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBOZXcgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdW5zaGlmdChwYXRoLCAuLi5pdGVtcykge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnVuc2hpZnQoLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgaXRlbXMubGVuZ3RoLCBbXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGF0IGEgcGF0aCBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtLnVzZXIubmFtZSA9ICdCb2InO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVBhdGgoJ2l0ZW0udXNlci5uYW1lJyk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFZhbHVlIGF0IHRoZSBwYXRoIChvcHRpb25hbCkuXG4gICAgICogQHB1YmxpY1xuICAgICovXG4gICAgbm90aWZ5UGF0aChwYXRoLCB2YWx1ZSkge1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICBsZXQgcHJvcFBhdGg7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIEdldCB2YWx1ZSBpZiBub3Qgc3VwcGxpZWRcbiAgICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgICB2YWx1ZSA9IGdldCQwKHRoaXMsIHBhdGgsIGluZm8pO1xuICAgICAgICBwcm9wUGF0aCA9IGluZm8ucGF0aDtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAvLyBOb3JtYWxpemUgcGF0aCBpZiBuZWVkZWRcbiAgICAgICAgcHJvcFBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wUGF0aCA9IC8qKiBAdHlwZXtzdHJpbmd9ICovKHBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wUGF0aCwgdmFsdWUsIHRydWUsIHRydWUpKSB7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVJlYWRPbmx5UHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgICAgaWYgKHByb3RlY3RlZFNldHRlcikge1xuICAgICAgICB0aGlzWydfc2V0JyArIHVwcGVyKHByb3BlcnR5KV0gPSAvKiogQHRoaXMge1Byb3BlcnR5RWZmZWN0c30gKi9mdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBvYnNlcnZlciBtZXRob2QgdG8gY2FsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGR5bmFtaWNGbiBXaGV0aGVyIHRoZSBtZXRob2QgbmFtZSBzaG91bGQgYmUgaW5jbHVkZWQgYXNcbiAgICAgKiAgIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgaW5mbyA9IHsgcHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbjogQm9vbGVhbihkeW5hbWljRm4pIH07XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuT0JTRVJWRSwge1xuICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBwcm9wZXJ0eX1cbiAgICAgIH0pO1xuICAgICAgaWYgKGR5bmFtaWNGbikge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChtZXRob2ROYW1lLCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgICAgZm46IHJ1bk9ic2VydmVyRWZmZWN0LCBpbmZvLCB0cmlnZ2VyOiB7bmFtZTogbWV0aG9kTmFtZX1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU1ldGhvZE9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgbGV0IHNpZyA9IHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pO1xuICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIG9ic2VydmVyIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZU1ldGhvZEVmZmVjdCh0aGlzLCBzaWcsIFRZUEVTLk9CU0VSVkUsIHJ1bk1ldGhvZEVmZmVjdCwgbnVsbCwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk5PVElGWSwge1xuICAgICAgICBmbjogcnVuTm90aWZ5RWZmZWN0LFxuICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgZXZlbnROYW1lOiBDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkgKyAnLWNoYW5nZWQnLFxuICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVmbGVjdGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgbGV0IGF0dHIgPSBDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSk7XG4gICAgICBpZiAoYXR0clswXSA9PT0gJy0nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUHJvcGVydHkgJyArIHByb3BlcnR5ICsgJyBjYW5ub3QgYmUgcmVmbGVjdGVkIHRvIGF0dHJpYnV0ZSAnICtcbiAgICAgICAgICBhdHRyICsgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIHN0YXJ0aW5nIGF0dHJpYnV0ZSBuYW1lLiBVc2UgYSBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIGZvciB0aGUgcHJvcGVydHkgdGhpc2VhZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNULCB7XG4gICAgICAgICAgZm46IHJ1blJlZmxlY3RFZmZlY3QsXG4gICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgYXR0ck5hbWU6IGF0dHJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVDb21wdXRlZFByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgbGV0IHNpZyA9IHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pO1xuICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGNvbXB1dGVkIGV4cHJlc3Npb24gJ1wiICsgZXhwcmVzc2lvbiArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZU1ldGhvZEVmZmVjdCh0aGlzLCBzaWcsIFRZUEVTLkNPTVBVVEUsIHJ1bkNvbXB1dGVkRWZmZWN0LCBwcm9wZXJ0eSwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvLyAtLSBzdGF0aWMgY2xhc3MgbWV0aG9kcyAtLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYW4gYWNjZXNzb3IgZXhpc3RzIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBhbmQgYWRkc1xuICAgICAqIHRvIGEgbGlzdCBvZiBcInByb3BlcnR5IGVmZmVjdHNcIiB0aGF0IHdpbGwgcnVuIHdoZW4gdGhlIGFjY2Vzc29yIGZvclxuICAgICAqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaXMgc2V0LiAgRWZmZWN0cyBhcmUgZ3JvdXBlZCBieSBcInR5cGVcIiwgd2hpY2hcbiAgICAgKiByb3VnaGx5IGNvcnJlc3BvbmRzIHRvIGEgcGhhc2UgaW4gZWZmZWN0IHByb2Nlc3NpbmcuICBUaGUgZWZmZWN0XG4gICAgICogbWV0YWRhdGEgc2hvdWxkIGJlIGluIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgKlxuICAgICAqICAgICB7XG4gICAgICogICAgICAgZm46IGVmZmVjdEZ1bmN0aW9uLCAvLyBSZWZlcmVuY2UgdG8gZnVuY3Rpb24gdG8gY2FsbCB0byBwZXJmb3JtIGVmZmVjdFxuICAgICAqICAgICAgIGluZm86IHsgLi4uIH0gICAgICAgLy8gRWZmZWN0IG1ldGFkYXRhIHBhc3NlZCB0byBmdW5jdGlvblxuICAgICAqICAgICAgIHRyaWdnZXI6IHsgICAgICAgICAgLy8gT3B0aW9uYWwgdHJpZ2dlcmluZyBtZXRhZGF0YTsgaWYgbm90IHByb3ZpZGVkXG4gICAgICogICAgICAgICBuYW1lOiBzdHJpbmcgICAgICAvLyB0aGUgcHJvcGVydHkgaXMgdHJlYXRlZCBhcyBhIHdpbGRjYXJkXG4gICAgICogICAgICAgICBzdHJ1Y3R1cmVkOiBib29sZWFuXG4gICAgICogICAgICAgICB3aWxkY2FyZDogYm9vbGVhblxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogRWZmZWN0cyBhcmUgY2FsbGVkIGZyb20gYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgaW4gdGhlIGZvbGxvd2luZyBvcmRlciBieVxuICAgICAqIHR5cGU6XG4gICAgICpcbiAgICAgKiAxLiBDT01QVVRFXG4gICAgICogMi4gUFJPUEFHQVRFXG4gICAgICogMy4gUkVGTEVDVFxuICAgICAqIDQuIE9CU0VSVkVcbiAgICAgKiA1LiBOT1RJRllcbiAgICAgKlxuICAgICAqIEVmZmVjdCBmdW5jdGlvbnMgYXJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICAgICAqXG4gICAgICogICAgIGVmZmVjdEZ1bmN0aW9uKGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpbmdsZS1wcm9wZXJ0eSBvYnNlcnZlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtdWx0aS1wcm9wZXJ0eSBcIm1ldGhvZCBvYnNlcnZlclwiIGJhc2VkIG9uIHRoZSBwcm92aWRlZFxuICAgICAqIGV4cHJlc3Npb24sIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZyBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0XG4gICAgICogZnVuY3Rpb24gc2lnbmF0dXJlOiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2AuICBFYWNoIGFyZ3VtZW50XG4gICAgICogc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBwcm9wZXJ0eSBvciBwYXRoIGluIHRoZSBjb250ZXh0IG9mIHRoaXNcbiAgICAgKiBwcm90b3R5cGUgKG9yIGluc3RhbmNlKSwgb3IgbWF5IGJlIGEgbGl0ZXJhbCBzdHJpbmcgb3IgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gZGlzcGF0Y2ggYDxwcm9wZXJ0eT4tY2hhbmdlZGBcbiAgICAgKiBldmVudHMgdG8gbm90aWZ5IG9mIGNoYW5nZXMgdG8gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWFkLW9ubHkgYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRvIHNldCB0aGUgcHJvcGVydHksIHVzZSB0aGUgcHJvdGVjdGVkIGBfc2V0UHJvcGVydHlgIEFQSS5cbiAgICAgKiBUbyBjcmVhdGUgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlciAoZS5nLiBgX3NldE15UHJvcCgpYCBmb3JcbiAgICAgKiBwcm9wZXJ0eSBgbXlQcm9wYCksIHBhc3MgYHRydWVgIGZvciBgcHJvdGVjdGVkU2V0dGVyYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIGlmIHRoZSBwcm9wZXJ0eSB3aWxsIGhhdmUgb3RoZXIgcHJvcGVydHkgZWZmZWN0cywgdGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LCBiZWZvcmUgYWRkaW5nIG90aGVyIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgKiAgIHdoZW4gYHRydWVgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvdGVjdGVkU2V0dGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXVzZXMgdGhlIHNldHRlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IHRvIHJlZmxlY3QgdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICogdG8gYSAoZGFzaC1jYXNlZCkgYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIHNldCB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAqIG1ldGhvZCBkZXNjcmliZWQgYnkgdGhlIGdpdmVuIGBleHByZXNzaW9uYCBlYWNoIHRpbWUgb25lIG9yIG1vcmVcbiAgICAgKiBhcmd1bWVudHMgdG8gdGhlIG1ldGhvZCBjaGFuZ2VzLiAgVGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIGEgc3RyaW5nXG4gICAgICogaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdCBmdW5jdGlvbiBzaWduYXR1cmU6XG4gICAgICogYCdtZXRob2ROYW1lKGFyZzEsIFsuLi4sIGFyZ25dKSdgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBjb21wdXRlZCBwcm9wZXJ0eSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICAgICAqICAgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkocHJvcGVydHksIGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSB0byBlbnN1cmUgYmluZGluZyBlZmZlY3RzIGFyZSBjcmVhdGVkXG4gICAgICogZm9yIHRoZW0sIGFuZCB0aGVuIGVuc3VyZXMgcHJvcGVydHkgYWNjZXNzb3JzIGFyZSBjcmVhdGVkIGZvciBhbnlcbiAgICAgKiBkZXBlbmRlbnQgcHJvcGVydGllcyBpbiB0aGUgdGVtcGxhdGUuICBCaW5kaW5nIGVmZmVjdHMgZm9yIGJvdW5kXG4gICAgICogdGVtcGxhdGVzIGFyZSBzdG9yZWQgaW4gYSBsaW5rZWQgbGlzdCBvbiB0aGUgaW5zdGFuY2Ugc28gdGhhdFxuICAgICAqIHRlbXBsYXRlcyBjYW4gYmUgZWZmaWNpZW50bHkgc3RhbXBlZCBhbmQgdW5zdGFtcGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSBjb250YWluaW5nIGJpbmRpbmdcbiAgICAgKiAgIGJpbmRpbmdzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGJpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8vIC0tIGJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGJpbmRUZW1wbGF0ZWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiB0aGUgcHJvdG90eXBlIChmb3IgcHJvdG90eXBpY2FsIHRlbXBsYXRlXG4gICAgICogYmluZGluZywgdG8gYXZvaWQgY3JlYXRpbmcgYWNjZXNzb3JzIGV2ZXJ5IGluc3RhbmNlKSBvbmNlIHBlciBwcm90b3R5cGUsXG4gICAgICogYW5kIHdpbGwgYmUgY2FsbGVkIHdpdGggYHJ1bnRpbWVCaW5kaW5nOiB0cnVlYCBieSBgX3N0YW1wVGVtcGxhdGVgIHRvXG4gICAgICogY3JlYXRlIGFuZCBsaW5rIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggYVxuICAgICAqIHBhcnRpY3VsYXIgc3RhbXBpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAqICAgYmluZGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbnN0YW5jZUJpbmRpbmcgV2hlbiBmYWxzZSAoZGVmYXVsdCksIHBlcmZvcm1zXG4gICAgICogICBcInByb3RvdHlwaWNhbFwiIGJpbmRpbmcgb2YgdGhlIHRlbXBsYXRlIGFuZCBvdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5XG4gICAgICogICBib3VuZCB0ZW1wbGF0ZSBmb3IgdGhlIGNsYXNzLiBXaGVuIHRydWUgKGFzIHBhc3NlZCBmcm9tXG4gICAgICogICBgX3N0YW1wVGVtcGxhdGVgKSwgdGhlIHRlbXBsYXRlIGluZm8gaXMgaW5zdGFuY2VkIGFuZCBsaW5rZWQgaW50b1xuICAgICAqICAgdGhlIGxpc3Qgb2YgYm91bmQgdGVtcGxhdGVzLlxuICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdDsgZm9yIGBydW50aW1lQmluZGluZ2AsXG4gICAgICogICB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBwcm90b3R5cGljYWwgdGVtcGxhdGUgaW5mb1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYmluZFRlbXBsYXRlKHRlbXBsYXRlLCBpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGxldCB3YXNQcmVCb3VuZCA9IHRoaXMuX190ZW1wbGF0ZUluZm8gPT0gdGVtcGxhdGVJbmZvO1xuICAgICAgLy8gT3B0aW1pemF0aW9uOiBzaW5jZSB0aGlzIGlzIGNhbGxlZCB0d2ljZSBmb3IgcHJvdG8tYm91bmQgdGVtcGxhdGVzLFxuICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byByZWNyZWF0ZSBhY2Nlc3NvcnMgaWYgdGhpcyB0ZW1wbGF0ZSB3YXMgcHJlLWJvdW5kXG4gICAgICBpZiAoIXdhc1ByZUJvdW5kKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cykge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnN0YW5jZUJpbmRpbmcpIHtcbiAgICAgICAgLy8gRm9yIGluc3RhbmNlLXRpbWUgYmluZGluZywgY3JlYXRlIGluc3RhbmNlIG9mIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICAgIC8vIGFuZCBsaW5rIGludG8gbGlzdCBvZiB0ZW1wbGF0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8oT2JqZWN0LmNyZWF0ZSh0ZW1wbGF0ZUluZm8pKTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLndhc1ByZUJvdW5kID0gd2FzUHJlQm91bmQ7XG4gICAgICAgIGlmICghd2FzUHJlQm91bmQgJiYgdGhpcy5fX3RlbXBsYXRlSW5mbykge1xuICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgfHwgdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IGxhc3QubmV4dFRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8gPSBsYXN0O1xuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwcm9wZXJ0eSBlZmZlY3QgdG8gdGhlIGdpdmVuIHRlbXBsYXRlIG1ldGFkYXRhLCB3aGljaCBpcyBydW5cbiAgICAgKiBhdCB0aGUgXCJwcm9wYWdhdGVcIiBzdGFnZSBvZiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCB3aGVuIHRoZSB0ZW1wbGF0ZVxuICAgICAqIGhhcyBiZWVuIGJvdW5kIHRvIHRoZSBlbGVtZW50IHZpYSBgX2JpbmRUZW1wbGF0ZWAuXG4gICAgICpcbiAgICAgKiBUaGUgYGVmZmVjdGAgb2JqZWN0IHNob3VsZCBtYXRjaCB0aGUgZm9ybWF0IGluIGBfYWRkUHJvcGVydHlFZmZlY3RgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSB0byBhZGQgZWZmZWN0IHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCBwcm9wLCBlZmZlY3QpIHtcbiAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgICAgIGhvc3RQcm9wc1twcm9wXSA9IHRydWU7XG4gICAgICBsZXQgZWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgPSB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzIHx8IHt9O1xuICAgICAgbGV0IHByb3BFZmZlY3RzID0gZWZmZWN0c1twcm9wXSA9IGVmZmVjdHNbcHJvcF0gfHwgW107XG4gICAgICBwcm9wRWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhbXBzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSBhbmQgcGVyZm9ybXMgaW5zdGFuY2UtdGltZSBzZXR1cCBmb3JcbiAgICAgKiBQb2x5bWVyIHRlbXBsYXRlIGZlYXR1cmVzLCBpbmNsdWRpbmcgZGF0YSBiaW5kaW5ncywgZGVjbGFyYXRpdmUgZXZlbnRcbiAgICAgKiBsaXN0ZW5lcnMsIGFuZCB0aGUgYHRoaXMuJGAgbWFwIG9mIGBpZGAncyB0byBub2Rlcy4gIEEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgKiBpcyByZXR1cm5lZCBjb250YWluaW5nIHRoZSBzdGFtcGVkIERPTSwgcmVhZHkgZm9yIGluc2VydGlvbiBpbnRvIHRoZVxuICAgICAqIERPTS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2U7IGhvd2V2ZXIgbm90ZSB0aGF0IGR1ZSB0b1xuICAgICAqIGBzaGFkeWNzc2AgcG9seWZpbGwgbGltaXRhdGlvbnMsIG9ubHkgc3R5bGVzIGZyb20gdGVtcGxhdGVzIHByZXBhcmVkXG4gICAgICogdXNpbmcgYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgd2lsbCBiZSBjb3JyZWN0bHkgcG9seWZpbGxlZCAoc2NvcGVkXG4gICAgICogdG8gdGhlIHNoYWRvdyByb290IGFuZCBzdXBwb3J0IENTUyBjdXN0b20gcHJvcGVydGllcyksIGFuZCBub3RlIHRoYXRcbiAgICAgKiBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCBtYXkgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgZWxlbWVudC4gQXMgc3VjaCxcbiAgICAgKiBhbnkgc3R5bGVzIHJlcXVpcmVkIGJ5IGluIHJ1bnRpbWUtc3RhbXBlZCB0ZW1wbGF0ZXMgbXVzdCBiZSBpbmNsdWRlZFxuICAgICAqIGluIHRoZSBtYWluIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBzdGFtcFxuICAgICAqIEByZXR1cm4geyFTdGFtcGVkVGVtcGxhdGV9IENsb25lZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAvLyBFbnN1cmVzIHRoYXQgY3JlYXRlZCBkb20gaXMgYF9lbnF1ZXVlQ2xpZW50YCdkIHRvIHRoaXMgZWxlbWVudCBzb1xuICAgICAgLy8gdGhhdCBpdCBjYW4gYmUgZmx1c2hlZCBvbiBuZXh0IGNhbGwgdG8gYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICBob3N0U3RhY2suYmVnaW5Ib3N0aW5nKHRoaXMpO1xuICAgICAgbGV0IGRvbSA9IHN1cGVyLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGhvc3RTdGFjay5lbmRIb3N0aW5nKHRoaXMpO1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi8odGhpcy5fYmluZFRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKSk7XG4gICAgICAvLyBBZGQgdGVtcGxhdGUtaW5zdGFuY2Utc3BlY2lmaWMgZGF0YSB0byBpbnN0YW5jZWQgdGVtcGxhdGVJbmZvXG4gICAgICB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QgPSBkb20ubm9kZUxpc3Q7XG4gICAgICAvLyBDYXB0dXJlIGNoaWxkIG5vZGVzIHRvIGFsbG93IHVuc3RhbXBpbmcgb2Ygbm9uLXByb3RvdHlwaWNhbCB0ZW1wbGF0ZXNcbiAgICAgIGlmICghdGVtcGxhdGVJbmZvLndhc1ByZUJvdW5kKSB7XG4gICAgICAgIGxldCBub2RlcyA9IHRlbXBsYXRlSW5mby5jaGlsZE5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IG49ZG9tLmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICAgIG5vZGVzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRvbS50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAvLyBTZXR1cCBjb21wb3VuZCBzdG9yYWdlLCAyLXdheSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdCBmb3IgYmluZGluZ3NcbiAgICAgIHNldHVwQmluZGluZ3ModGhpcywgdGVtcGxhdGVJbmZvKTtcbiAgICAgIC8vIEZsdXNoIHByb3BlcnRpZXMgaW50byB0ZW1wbGF0ZSBub2RlcyBpZiBhbHJlYWR5IGJvb3RlZFxuICAgICAgaWYgKHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzLCB0aGlzLl9fZGF0YSwgbnVsbCxcbiAgICAgICAgICBmYWxzZSwgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbmQgdW5iaW5kcyB0aGUgbm9kZXMgcHJldmlvdXNseSBjb250YWluZWQgaW4gdGhlIHByb3ZpZGVkXG4gICAgICogRG9jdW1lbnRGcmFnbWVudCByZXR1cm5lZCBmcm9tIGBfc3RhbXBUZW1wbGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFTdGFtcGVkVGVtcGxhdGV9IGRvbSBEb2N1bWVudEZyYWdtZW50IHByZXZpb3VzbHkgcmV0dXJuZWRcbiAgICAgKiAgIGZyb20gYF9zdGFtcFRlbXBsYXRlYCBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGVzIHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlbW92ZUJvdW5kRG9tKGRvbSkge1xuICAgICAgLy8gVW5saW5rIHRlbXBsYXRlIGluZm9cbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSBkb20udGVtcGxhdGVJbmZvO1xuICAgICAgaWYgKHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8gPVxuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9PSB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPSB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbyA9IG51bGw7XG4gICAgICAvLyBSZW1vdmUgc3RhbXBlZCBub2Rlc1xuICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYFRleHROb2RlYCdzJyBgdGV4dENvbnRlbnRgLiAgQSBgYmluZGluZ3NgXG4gICAgICogYXJyYXkgaXMgYWRkZWQgdG8gYG5vZGVJbmZvYCBhbmQgcG9wdWxhdGVkIHdpdGggYmluZGluZyBtZXRhZGF0YVxuICAgICAqIHdpdGggaW5mb3JtYXRpb24gY2FwdHVyaW5nIHRoZSBiaW5kaW5nIHRhcmdldCwgYW5kIGEgYHBhcnRzYCBhcnJheVxuICAgICAqIHdpdGggb25lIG9yIG1vcmUgbWV0YWRhdGEgb2JqZWN0cyBjYXB0dXJpbmcgdGhlIHNvdXJjZShzKSBvZiB0aGVcbiAgICAgKiBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCBub3RlZCA9IHN1cGVyLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKG5vZGUudGV4dENvbnRlbnQsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRleHRDb250ZW50IHdpdGggYW55IGxpdGVyYWwgcGFydHNcbiAgICAgICAgICAvLyBOT1RFOiBkZWZhdWx0IHRvIGEgc3BhY2UgaGVyZSBzbyB0aGUgdGV4dE5vZGUgcmVtYWluczsgc29tZSBicm93c2Vyc1xuICAgICAgICAgIC8vIChJRSkgZXZhY2lwYXRlIGFuIGVtcHR5IHRleHROb2RlIGZvbGxvd2luZyBjbG9uZU5vZGUvaW1wb3J0Tm9kZS5cbiAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykgfHwgJyAnO1xuICAgICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgJ3RleHQnLCAndGV4dENvbnRlbnQnLCBwYXJ0cyk7XG4gICAgICAgICAgbm90ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBhdHRyaWJ1dGVzLiAgQSBgYmluZGluZ3NgXG4gICAgICogYXJyYXkgaXMgYWRkZWQgdG8gYG5vZGVJbmZvYCBhbmQgcG9wdWxhdGVkIHdpdGggYmluZGluZyBtZXRhZGF0YVxuICAgICAqIHdpdGggaW5mb3JtYXRpb24gY2FwdHVyaW5nIHRoZSBiaW5kaW5nIHRhcmdldCwgYW5kIGEgYHBhcnRzYCBhcnJheVxuICAgICAqIHdpdGggb25lIG9yIG1vcmUgbWV0YWRhdGEgb2JqZWN0cyBjYXB0dXJpbmcgdGhlIHNvdXJjZShzKSBvZiB0aGVcbiAgICAgKiBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICBsZXQgcGFydHMgPSB0aGlzLl9wYXJzZUJpbmRpbmdzKHZhbHVlLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIC8vIEF0dHJpYnV0ZSBvciBwcm9wZXJ0eVxuICAgICAgICBsZXQgb3JpZ05hbWUgPSBuYW1lO1xuICAgICAgICBsZXQga2luZCA9ICdwcm9wZXJ0eSc7XG4gICAgICAgIGlmIChuYW1lW25hbWUubGVuZ3RoLTFdID09ICckJykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICBraW5kID0gJ2F0dHJpYnV0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdHRyaWJ1dGUgYmluZGluZ3Mgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICBsZXQgbGl0ZXJhbCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpO1xuICAgICAgICBpZiAobGl0ZXJhbCAmJiBraW5kID09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgbGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgYXR0cmlidXRlIGJlZm9yZSByZW1vdmluZywgc2luY2UgSUUgd29uJ3QgYWxsb3cgcmVtb3ZpbmdcbiAgICAgICAgLy8gYHZhbHVlYCBhdHRyaWJ1dGUgaWYgaXQgcHJldmlvdXNseSBoYWQgYSB2YWx1ZSAoY2FuJ3RcbiAgICAgICAgLy8gdW5jb25kaXRpb25hbGx5IHNldCAnJyBiZWZvcmUgcmVtb3Zpbmcgc2luY2UgYXR0cmlidXRlcyB3aXRoIGAkYFxuICAgICAgICAvLyBjYW4ndCBiZSBzZXQgdXNpbmcgc2V0QXR0cmlidXRlKVxuICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgb3JpZ05hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShvcmlnTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbm5vdGF0aW9uXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG9yaWdOYW1lKTtcbiAgICAgICAgLy8gQ2FzZSBoYWNrZXJ5OiBhdHRyaWJ1dGVzIGFyZSBsb3dlci1jYXNlLCBidXQgYmluZCB0YXJnZXRzXG4gICAgICAgIC8vIChwcm9wZXJ0aWVzKSBhcmUgY2FzZSBzZW5zaXRpdmUuIEdhbWJpdCBpcyB0byBtYXAgZGFzaC1jYXNlIHRvXG4gICAgICAgIC8vIGNhbWVsLWNhc2U6IGBmb28tYmFyYCBiZWNvbWVzIGBmb29CYXJgLlxuICAgICAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ3MgYXJlIGV4Y2VwdGVkLlxuICAgICAgICBpZiAoa2luZCA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgIG5hbWUgPSBkYXNoVG9DYW1lbENhc2UobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBraW5kLCBuYW1lLCBwYXJ0cywgbGl0ZXJhbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAqIGJpbmRpbmcgdGhlIHByb3BlcnRpZXMgdGhhdCBhIG5lc3RlZCB0ZW1wbGF0ZSBkZXBlbmRzIG9uIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAqIGFzIGBfaG9zdF88cHJvcGVydHk+YC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICAgIC8vIE1lcmdlIGhvc3QgcHJvcHMgaW50byBvdXRlciB0ZW1wbGF0ZSBhbmQgYWRkIGJpbmRpbmdzXG4gICAgICBsZXQgaG9zdFByb3BzID0gbm9kZUluZm8udGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICAgIGxldCBtb2RlID0gJ3snO1xuICAgICAgZm9yIChsZXQgc291cmNlIGluIGhvc3RQcm9wcykge1xuICAgICAgICBsZXQgcGFydHMgPSBbeyBtb2RlLCBzb3VyY2UsIGRlcGVuZGVuY2llczogW3NvdXJjZV0gfV07XG4gICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgJ3Byb3BlcnR5JywgJ19ob3N0XycgKyBzb3VyY2UsIHBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gcGFyc2UgdGV4dCBpbiBhIHRlbXBsYXRlIChlaXRoZXIgYXR0cmlidXRlIHZhbHVlcyBvclxuICAgICAqIHRleHRDb250ZW50KSBpbnRvIGJpbmRpbmcgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBBbnkgb3ZlcnJpZGVzIG9mIHRoaXMgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgYmluZGluZyBwYXJ0XG4gICAgICogbWV0YWRhdGEgIHJlcHJlc2VudGluZyBvbmUgb3IgbW9yZSBiaW5kaW5ncyBmb3VuZCBpbiB0aGUgcHJvdmlkZWQgdGV4dFxuICAgICAqIGFuZCBhbnkgXCJsaXRlcmFsXCIgdGV4dCBpbiBiZXR3ZWVuLiAgQW55IG5vbi1saXRlcmFsIHBhcnRzIHdpbGwgYmUgcGFzc2VkXG4gICAgICogdG8gYF9ldmFsdWF0ZUJpbmRpbmdgIHdoZW4gYW55IGRlcGVuZGVuY2llcyBjaGFuZ2UuICBUaGUgb25seSByZXF1aXJlZFxuICAgICAqIGZpZWxkcyBvZiBlYWNoIFwicGFydFwiIGluIHRoZSByZXR1cm5lZCBhcnJheSBhcmUgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIC0gYGRlcGVuZGVuY2llc2AgLSBBcnJheSBjb250YWluaW5nIHRyaWdnZXIgbWV0YWRhdGEgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgKiAgIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGJpbmRpbmcgdG8gdXBkYXRlXG4gICAgICogLSBgbGl0ZXJhbGAgLSBTdHJpbmcgY29udGFpbmluZyB0ZXh0IGlmIHRoZSBwYXJ0IHJlcHJlc2VudHMgYSBsaXRlcmFsO1xuICAgICAqICAgaW4gdGhpcyBjYXNlIG5vIGBkZXBlbmRlbmNpZXNgIGFyZSBuZWVkZWRcbiAgICAgKlxuICAgICAqIEFkZGl0aW9uYWwgbWV0YWRhdGEgZm9yIHVzZSBieSBgX2V2YWx1YXRlQmluZGluZ2AgbWF5IGJlIHByb3ZpZGVkIGluXG4gICAgICogZWFjaCBwYXJ0IG9iamVjdCBhcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgdHlwZXMgb2YgYmluZGluZ3NcbiAgICAgKiAob25lIG9yIG1vcmUgbWF5IGJlIGludGVybWl4ZWQgd2l0aCBsaXRlcmFsIHN0cmluZ3MpOlxuICAgICAqIC0gUHJvcGVydHkgYmluZGluZzogYFtbcHJvcF1dYFxuICAgICAqIC0gUGF0aCBiaW5kaW5nOiBgW1tvYmplY3QucHJvcF1dYFxuICAgICAqIC0gTmVnYXRlZCBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzOiBgW1shcHJvcF1dYCBvciBgW1shb2JqZWN0LnByb3BdXWBcbiAgICAgKiAtIFR3by13YXkgcHJvcGVydHkgb3IgcGF0aCBiaW5kaW5ncyAoc3VwcG9ydHMgbmVnYXRpb24pOlxuICAgICAqICAgYHt7cHJvcH19YCwgYHt7b2JqZWN0LnByb3B9fWAsIGB7eyFwcm9wfX1gIG9yIGB7eyFvYmplY3QucHJvcH19YFxuICAgICAqIC0gSW5saW5lIGNvbXB1dGVkIG1ldGhvZCAoc3VwcG9ydHMgbmVnYXRpb24pOlxuICAgICAqICAgYFtbY29tcHV0ZShhLCAnbGl0ZXJhbCcsIGIpXV1gLCBgW1shY29tcHV0ZShhLCAnbGl0ZXJhbCcsIGIpXV1gXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHRvIHBhcnNlIGZyb20gYXR0cmlidXRlIG9yIHRleHRDb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlSW5mbyBDdXJyZW50IHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogQHJldHVybiB7QXJyYXk8IUJpbmRpbmdQYXJ0Pn0gQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VCaW5kaW5ncyh0ZXh0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgICBsZXQgbTtcbiAgICAgIC8vIEV4YW1wbGU6IFwibGl0ZXJhbDF7e3Byb3B9fWxpdGVyYWwyW1shY29tcHV0ZShmb28sYmFyKV1dZmluYWxcIlxuICAgICAgLy8gUmVnZXggbWF0Y2hlczpcbiAgICAgIC8vICAgICAgICBJdGVyYXRpb24gMTogIEl0ZXJhdGlvbiAyOlxuICAgICAgLy8gbVsxXTogJ3t7JyAgICAgICAgICAnW1snXG4gICAgICAvLyBtWzJdOiAnJyAgICAgICAgICAgICchJ1xuICAgICAgLy8gbVszXTogJ3Byb3AnICAgICAgICAnY29tcHV0ZShmb28sYmFyKSdcbiAgICAgIHdoaWxlICgobSA9IGJpbmRpbmdSZWdleC5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgbGl0ZXJhbCBwYXJ0XG4gICAgICAgIGlmIChtLmluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7bGl0ZXJhbDogdGV4dC5zbGljZShsYXN0SW5kZXgsIG0uaW5kZXgpfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGJpbmRpbmcgcGFydFxuICAgICAgICBsZXQgbW9kZSA9IG1bMV1bMF07XG4gICAgICAgIGxldCBuZWdhdGUgPSBCb29sZWFuKG1bMl0pO1xuICAgICAgICBsZXQgc291cmNlID0gbVszXS50cmltKCk7XG4gICAgICAgIGxldCBjdXN0b21FdmVudCA9IGZhbHNlLCBub3RpZnlFdmVudCA9ICcnLCBjb2xvbiA9IC0xO1xuICAgICAgICBpZiAobW9kZSA9PSAneycgJiYgKGNvbG9uID0gc291cmNlLmluZGV4T2YoJzo6JykpID4gMCkge1xuICAgICAgICAgIG5vdGlmeUV2ZW50ID0gc291cmNlLnN1YnN0cmluZyhjb2xvbiArIDIpO1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgY29sb24pO1xuICAgICAgICAgIGN1c3RvbUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmF0dXJlID0gcGFyc2VNZXRob2Qoc291cmNlKTtcbiAgICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgLy8gSW5saW5lIGNvbXB1dGVkIGZ1bmN0aW9uXG4gICAgICAgICAgbGV0IHthcmdzLCBtZXRob2ROYW1lfSA9IHNpZ25hdHVyZTtcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8YXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBkeW5hbWljRm5zID0gdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnM7XG4gICAgICAgICAgaWYgKGR5bmFtaWNGbnMgJiYgZHluYW1pY0Zuc1ttZXRob2ROYW1lXSB8fCBzaWduYXR1cmUuc3RhdGljKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIHNpZ25hdHVyZS5keW5hbWljRm4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQcm9wZXJ0eSBvciBwYXRoXG4gICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2UsIG1vZGUsIG5lZ2F0ZSwgY3VzdG9tRXZlbnQsIHNpZ25hdHVyZSwgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgIGV2ZW50OiBub3RpZnlFdmVudFxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdEluZGV4ID0gYmluZGluZ1JlZ2V4Lmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBhIGZpbmFsIGxpdGVyYWwgcGFydFxuICAgICAgaWYgKGxhc3RJbmRleCAmJiBsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBsZXQgbGl0ZXJhbCA9IHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCk7XG4gICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICBsaXRlcmFsOiBsaXRlcmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHRvIGV2YWx1YXRlIGEgcHJldmlvdXNseSBwYXJzZWQgYmluZGluZyBwYXJ0IGJhc2VkIG9uIGEgc2V0IG9mXG4gICAgICogb25lIG9yIG1vcmUgY2hhbmdlZCBkZXBlbmRlbmNpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3RoaXN9IGluc3QgRWxlbWVudCB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHNjb3BlIGZvclxuICAgICAqICAgYmluZGluZyBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcGFyYW0ge0JpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggdGhhdCB0cmlnZ2VyZWQgdGhpcyBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gICAgICogQHJldHVybiB7Kn0gVmFsdWUgdGhlIGJpbmRpbmcgcGFydCBldmFsdWF0ZWQgdG9cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIF9ldmFsdWF0ZUJpbmRpbmcoaW5zdCwgcGFydCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgaWYgKHBhcnQuc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhbHVlID0gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgcGFydC5zaWduYXR1cmUpO1xuICAgICAgfSBlbHNlIGlmIChwYXRoICE9IHBhcnQuc291cmNlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0JDAoaW5zdCwgcGFydC5zb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhhc1BhdGhzICYmIGlzUGF0aCQwKHBhdGgpKSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXQkMChpbnN0LCBwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGluc3QuX19kYXRhW3BhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFydC5uZWdhdGUpIHtcbiAgICAgICAgdmFsdWUgPSAhdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gIH1cblxuICAvLyBtYWtlIGEgdHlwaW5nIGZvciBjbG9zdXJlIDpQXG4gIFByb3BlcnR5RWZmZWN0c1R5cGUgPSBQcm9wZXJ0eUVmZmVjdHM7XG5cbiAgcmV0dXJuIFByb3BlcnR5RWZmZWN0cztcbn0pO1xuXG4vKipcbiAqIEhlbHBlciBhcGkgZm9yIGVucXVlaW5nIGNsaWVudCBkb20gY3JlYXRlZCBieSBhIGhvc3QgZWxlbWVudC5cbiAqXG4gKiBCeSBkZWZhdWx0IGVsZW1lbnRzIGFyZSBmbHVzaGVkIHZpYSBgX2ZsdXNoUHJvcGVydGllc2Agd2hlblxuICogYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBjYWxsZWQuIEVsZW1lbnRzIGF0dGFjaCB0aGVpciBjbGllbnQgZG9tIHRvXG4gKiB0aGVtc2VsdmVzIGF0IGByZWFkeWAgdGltZSB3aGljaCByZXN1bHRzIGZyb20gdGhpcyBmaXJzdCBmbHVzaC5cbiAqIFRoaXMgcHJvdmlkZXMgYW4gb3JkZXJpbmcgZ3VhcmFudGVlIHRoYXQgdGhlIGNsaWVudCBkb20gYW4gZWxlbWVudFxuICogY3JlYXRlcyBpcyBmbHVzaGVkIGJlZm9yZSB0aGUgZWxlbWVudCBpdHNlbGYgKGkuZS4gY2xpZW50IGByZWFkeWBcbiAqIGZpcmVzIGJlZm9yZSBob3N0IGByZWFkeWApLlxuICpcbiAqIEhvd2V2ZXIsIGlmIGBfZmx1c2hQcm9wZXJ0aWVzYCBpcyBjYWxsZWQgKmJlZm9yZSogYW4gZWxlbWVudCBpcyBjb25uZWN0ZWQsXG4gKiBhcyBmb3IgZXhhbXBsZSBgVGVtcGxhdGl6ZWAgZG9lcywgdGhpcyBvcmRlcmluZyBndWFyYW50ZWUgY2Fubm90IGJlXG4gKiBzYXRpc2ZpZWQgYmVjYXVzZSBubyBlbGVtZW50cyBhcmUgY29ubmVjdGVkLiAoTm90ZTogQm91bmQgZWxlbWVudHMgdGhhdFxuICogcmVjZWl2ZSBkYXRhIGRvIGJlY29tZSBlbnF1ZXVlZCBjbGllbnRzIGFuZCBhcmUgcHJvcGVybHkgb3JkZXJlZCBidXRcbiAqIHVuYm91bmQgZWxlbWVudHMgYXJlIG5vdC4pXG4gKlxuICogVG8gbWFpbnRhaW4gdGhlIGRlc2lyZWQgXCJjbGllbnQgYmVmb3JlIGhvc3RcIiBvcmRlcmluZyBndWFyYW50ZWUgZm9yIHRoaXNcbiAqIGNhc2Ugd2UgcmVseSBvbiB0aGUgXCJob3N0IHN0YWNrLiBDbGllbnQgbm9kZXMgcmVnaXN0ZXJzIHRoZW1zZWx2ZXMgd2l0aFxuICogdGhlIGNyZWF0aW5nIGhvc3QgZWxlbWVudCB3aGVuIGNyZWF0ZWQuIFRoaXMgZW5zdXJlcyB0aGF0IGFsbCBjbGllbnQgZG9tXG4gKiBpcyByZWFkaWVkIGluIHRoZSBwcm9wZXIgb3JkZXIsIG1haW50YWluaW5nIHRoZSBkZXNpcmVkIGd1YXJhbnRlZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5sZXQgaG9zdFN0YWNrID0ge1xuXG4gIHN0YWNrOiBbXSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGFkZCB0byBob3N0U3RhY2tcbiAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICovXG4gIHJlZ2lzdGVySG9zdChpbnN0KSB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKSB7XG4gICAgICBsZXQgaG9zdCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV07XG4gICAgICBob3N0Ll9lbnF1ZXVlQ2xpZW50KGluc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGJlZ2luIGhvc3RpbmdcbiAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICovXG4gIGJlZ2luSG9zdGluZyhpbnN0KSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKGluc3QpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gZW5kIGhvc3RpbmdcbiAgICogQHRoaXMge2hvc3RTdGFja31cbiAgICovXG4gIGVuZEhvc3RpbmcoaW5zdCkge1xuICAgIGxldCBzdGFja0xlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIGlmIChzdGFja0xlbiAmJiB0aGlzLnN0YWNrW3N0YWNrTGVuLTFdID09IGluc3QpIHtcbiAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgbGV0IG5hdGl2ZVNoYWRvdyA9ICEod2luZG93WydTaGFkeURPTSddICYmIHdpbmRvd1snU2hhZHlET00nXVsnaW5Vc2UnXSk7XG5leHBvcnQgbGV0IG5hdGl2ZUNzc1ZhcmlhYmxlcztcblxuLyoqXG4gKiBAcGFyYW0geyhTaGFkeUNTU09wdGlvbnMgfCBTaGFkeUNTU0ludGVyZmFjZSk9fSBzZXR0aW5nc1xuICovXG5mdW5jdGlvbiBjYWxjQ3NzVmFyaWFibGVzKHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5nc1snc2hpbWNzc3Byb3BlcnRpZXMnXSkge1xuICAgIG5hdGl2ZUNzc1ZhcmlhYmxlcyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIGNocm9tZSA0OSBoYXMgc2VtaS13b3JraW5nIGNzcyB2YXJzLCBjaGVjayBpZiBib3gtc2hhZG93IHdvcmtzXG4gICAgLy8gc2FmYXJpIDkuMSBoYXMgYSByZWNhbGMgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU1NzgyXG4gICAgLy8gSG93ZXZlciwgc2hpbSBjc3MgY3VzdG9tIHByb3BlcnRpZXMgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggU2hhZHlET00gZW5hYmxlZCxcbiAgICAvLyBzbyBmYWxsIGJhY2sgb24gbmF0aXZlIGlmIHdlIGRvIG5vdCBkZXRlY3QgU2hhZHlET01cbiAgICAvLyBFZGdlIDE1OiBjdXN0b20gcHJvcGVydGllcyB1c2VkIGluIDo6YmVmb3JlIGFuZCA6OmFmdGVyIHdpbGwgYWxzbyBiZSB1c2VkIGluIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEyNDE0MjU3L1xuICAgIG5hdGl2ZUNzc1ZhcmlhYmxlcyA9IG5hdGl2ZVNoYWRvdyB8fCBCb29sZWFuKCFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLzYwMXxFZGdlXFwvMTUvKSAmJlxuICAgICAgd2luZG93LkNTUyAmJiBDU1Muc3VwcG9ydHMgJiYgQ1NTLnN1cHBvcnRzKCdib3gtc2hhZG93JywgJzAgMCAwIHZhcigtLWZvbyknKSk7XG4gIH1cbn1cblxuaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzICE9PSB1bmRlZmluZWQpIHtcbiAgbmF0aXZlQ3NzVmFyaWFibGVzID0gd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcztcbn0gZWxzZSBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gIGNhbGNDc3NWYXJpYWJsZXMod2luZG93LlNoYWR5Q1NTKTtcbiAgLy8gcmVzZXQgd2luZG93IHZhcmlhYmxlIHRvIGxldCBTaGFkeUNTUyBBUEkgdGFrZSBpdHMgcGxhY2VcbiAgd2luZG93LlNoYWR5Q1NTID0gdW5kZWZpbmVkO1xufSBlbHNlIHtcbiAgY2FsY0Nzc1ZhcmlhYmxlcyh3aW5kb3dbJ1dlYkNvbXBvbmVudHMnXSAmJiB3aW5kb3dbJ1dlYkNvbXBvbmVudHMnXVsnZmxhZ3MnXSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtc2V0dGluZ3MuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4vKlxuRXh0cmVtZWx5IHNpbXBsZSBjc3MgcGFyc2VyLiBJbnRlbmRlZCB0byBiZSBub3QgbW9yZSB0aGFuIHdoYXQgd2UgbmVlZFxuYW5kIGRlZmluaXRlbHkgbm90IG5lY2Vzc2FyaWx5IGNvcnJlY3QgPSkuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBAdW5yZXN0cmljdGVkICovXG5jbGFzcyBTdHlsZU5vZGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzWydzdGFydCddID0gMDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzWydlbmQnXSA9IDA7XG4gICAgLyoqIEB0eXBlIHtTdHlsZU5vZGV9ICovXG4gICAgdGhpc1sncHJldmlvdXMnXSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtTdHlsZU5vZGV9ICovXG4gICAgdGhpc1sncGFyZW50J10gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8U3R5bGVOb2RlPn0gKi9cbiAgICB0aGlzWydydWxlcyddID0gbnVsbDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzWydwYXJzZWRDc3NUZXh0J10gPSAnJztcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzWydjc3NUZXh0J10gPSAnJztcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpc1snYXRSdWxlJ10gPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzWyd0eXBlJ10gPSAwO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ2tleWZyYW1lc05hbWUnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3NlbGVjdG9yJ10gPSAnJztcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzWydwYXJzZWRTZWxlY3RvciddID0gJyc7XG4gIH1cbn1cblxuZXhwb3J0IHtTdHlsZU5vZGV9XG5cbi8vIGdpdmVuIGEgc3RyaW5nIG9mIGNzcywgcmV0dXJuIGEgc2ltcGxlIHJ1bGUgdHJlZVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UodGV4dCkge1xuICB0ZXh0ID0gY2xlYW4odGV4dCk7XG4gIHJldHVybiBwYXJzZUNzcyhsZXgodGV4dCksIHRleHQpO1xufVxuXG4vLyByZW1vdmUgc3R1ZmYgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGF0IG1heSBoaW5kZXIgcGFyc2luZ1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjbGVhbihjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoUlguY29tbWVudHMsICcnKS5yZXBsYWNlKFJYLnBvcnQsICcnKTtcbn1cblxuLy8gc3VwZXIgc2ltcGxlIHsuLi59IGxleGVyIHRoYXQgcmV0dXJucyBhIG5vZGUgdHJlZVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICBsZXQgcm9vdCA9IG5ldyBTdHlsZU5vZGUoKTtcbiAgcm9vdFsnc3RhcnQnXSA9IDA7XG4gIHJvb3RbJ2VuZCddID0gdGV4dC5sZW5ndGhcbiAgbGV0IG4gPSByb290O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHRleHQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRleHRbaV0gPT09IE9QRU5fQlJBQ0UpIHtcbiAgICAgIGlmICghblsncnVsZXMnXSkge1xuICAgICAgICBuWydydWxlcyddID0gW107XG4gICAgICB9XG4gICAgICBsZXQgcCA9IG47XG4gICAgICBsZXQgcHJldmlvdXMgPSBwWydydWxlcyddW3BbJ3J1bGVzJ10ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICAgIG4gPSBuZXcgU3R5bGVOb2RlKCk7XG4gICAgICBuWydzdGFydCddID0gaSArIDE7XG4gICAgICBuWydwYXJlbnQnXSA9IHA7XG4gICAgICBuWydwcmV2aW91cyddID0gcHJldmlvdXM7XG4gICAgICBwWydydWxlcyddLnB1c2gobik7XG4gICAgfSBlbHNlIGlmICh0ZXh0W2ldID09PSBDTE9TRV9CUkFDRSkge1xuICAgICAgblsnZW5kJ10gPSBpICsgMTtcbiAgICAgIG4gPSBuWydwYXJlbnQnXSB8fCByb290O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm9vdDtcbn1cblxuLy8gYWRkIHNlbGVjdG9ycy9jc3NUZXh0IHRvIG5vZGUgdHJlZVxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VDc3Mobm9kZSwgdGV4dCkge1xuICBsZXQgdCA9IHRleHQuc3Vic3RyaW5nKG5vZGVbJ3N0YXJ0J10sIG5vZGVbJ2VuZCddIC0gMSk7XG4gIG5vZGVbJ3BhcnNlZENzc1RleHQnXSA9IG5vZGVbJ2Nzc1RleHQnXSA9IHQudHJpbSgpO1xuICBpZiAobm9kZVsncGFyZW50J10pIHtcbiAgICBsZXQgc3MgPSBub2RlWydwcmV2aW91cyddID8gbm9kZVsncHJldmlvdXMnXVsnZW5kJ10gOiBub2RlWydwYXJlbnQnXVsnc3RhcnQnXTtcbiAgICB0ID0gdGV4dC5zdWJzdHJpbmcoc3MsIG5vZGVbJ3N0YXJ0J10gLSAxKTtcbiAgICB0ID0gX2V4cGFuZFVuaWNvZGVFc2NhcGVzKHQpO1xuICAgIHQgPSB0LnJlcGxhY2UoUlgubXVsdGlwbGVTcGFjZXMsICcgJyk7XG4gICAgLy8gVE9ETyhzb3J2ZWxsKTogYWQgaG9jOyBtYWtlIHNlbGVjdG9yIGluY2x1ZGUgb25seSBhZnRlciBsYXN0IDtcbiAgICAvLyBoZWxwcyB3aXRoIG1peGluIHN5bnRheFxuICAgIHQgPSB0LnN1YnN0cmluZyh0Lmxhc3RJbmRleE9mKCc7JykgKyAxKTtcbiAgICBsZXQgcyA9IG5vZGVbJ3BhcnNlZFNlbGVjdG9yJ10gPSBub2RlWydzZWxlY3RvciddID0gdC50cmltKCk7XG4gICAgbm9kZVsnYXRSdWxlJ10gPSAocy5pbmRleE9mKEFUX1NUQVJUKSA9PT0gMCk7XG4gICAgLy8gbm90ZSwgc3VwcG9ydCBhIHN1YnNldCBvZiBydWxlIHR5cGVzLi4uXG4gICAgaWYgKG5vZGVbJ2F0UnVsZSddKSB7XG4gICAgICBpZiAocy5pbmRleE9mKE1FRElBX1NUQVJUKSA9PT0gMCkge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5NRURJQV9SVUxFO1xuICAgICAgfSBlbHNlIGlmIChzLm1hdGNoKFJYLmtleWZyYW1lc1J1bGUpKSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLktFWUZSQU1FU19SVUxFO1xuICAgICAgICBub2RlWydrZXlmcmFtZXNOYW1lJ10gPVxuICAgICAgICAgIG5vZGVbJ3NlbGVjdG9yJ10uc3BsaXQoUlgubXVsdGlwbGVTcGFjZXMpLnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy5pbmRleE9mKFZBUl9TVEFSVCkgPT09IDApIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuTUlYSU5fUlVMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLlNUWUxFX1JVTEU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByJCA9IG5vZGVbJ3J1bGVzJ107XG4gIGlmIChyJCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gciQubGVuZ3RoLCByO1xuICAgICAgKGkgPCBsKSAmJiAociA9IHIkW2ldKTsgaSsrKSB7XG4gICAgICBwYXJzZUNzcyhyLCB0ZXh0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogY29udmVyc2lvbiBvZiBzb3J0IHVuaWNvZGUgZXNjYXBlcyB3aXRoIHNwYWNlcyBsaWtlIGBcXDMzIGAgKGFuZCBsb25nZXIpIGludG9cbiAqIGV4cGFuZGVkIGZvcm0gdGhhdCBkb2Vzbid0IHJlcXVpcmUgdHJhaWxpbmcgc3BhY2UgYFxcMDAwMDMzYFxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gX2V4cGFuZFVuaWNvZGVFc2NhcGVzKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXChbMC05YS1mXXsxLDZ9KVxccy9naSwgZnVuY3Rpb24oKSB7XG4gICAgbGV0IGNvZGUgPSBhcmd1bWVudHNbMV0sXG4gICAgICByZXBlYXQgPSA2IC0gY29kZS5sZW5ndGg7XG4gICAgd2hpbGUgKHJlcGVhdC0tKSB7XG4gICAgICBjb2RlID0gJzAnICsgY29kZTtcbiAgICB9XG4gICAgcmV0dXJuICdcXFxcJyArIGNvZGU7XG4gIH0pO1xufVxuXG4vKipcbiAqIHN0cmluZ2lmeSBwYXJzZWQgY3NzLlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHByZXNlcnZlUHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmc9fSB0ZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSwgcHJlc2VydmVQcm9wZXJ0aWVzLCB0ZXh0ID0gJycpIHtcbiAgLy8gY2FsYyBydWxlIGNzc1RleHRcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgaWYgKG5vZGVbJ2Nzc1RleHQnXSB8fCBub2RlWydydWxlcyddKSB7XG4gICAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgICBpZiAociQgJiYgIV9oYXNNaXhpblJ1bGVzKHIkKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSByJC5sZW5ndGgsIHI7XG4gICAgICAgIChpIDwgbCkgJiYgKHIgPSByJFtpXSk7IGkrKykge1xuICAgICAgICBjc3NUZXh0ID0gc3RyaW5naWZ5KHIsIHByZXNlcnZlUHJvcGVydGllcywgY3NzVGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1RleHQgPSBwcmVzZXJ2ZVByb3BlcnRpZXMgPyBub2RlWydjc3NUZXh0J10gOlxuICAgICAgICByZW1vdmVDdXN0b21Qcm9wcyhub2RlWydjc3NUZXh0J10pO1xuICAgICAgY3NzVGV4dCA9IGNzc1RleHQudHJpbSgpO1xuICAgICAgaWYgKGNzc1RleHQpIHtcbiAgICAgICAgY3NzVGV4dCA9ICcgICcgKyBjc3NUZXh0ICsgJ1xcbic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGVtaXQgcnVsZSBpZiB0aGVyZSBpcyBjc3NUZXh0XG4gIGlmIChjc3NUZXh0KSB7XG4gICAgaWYgKG5vZGVbJ3NlbGVjdG9yJ10pIHtcbiAgICAgIHRleHQgKz0gbm9kZVsnc2VsZWN0b3InXSArICcgJyArIE9QRU5fQlJBQ0UgKyAnXFxuJztcbiAgICB9XG4gICAgdGV4dCArPSBjc3NUZXh0O1xuICAgIGlmIChub2RlWydzZWxlY3RvciddKSB7XG4gICAgICB0ZXh0ICs9IENMT1NFX0JSQUNFICsgJ1xcblxcbic7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8U3R5bGVOb2RlPn0gcnVsZXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIF9oYXNNaXhpblJ1bGVzKHJ1bGVzKSB7XG4gIGxldCByID0gcnVsZXNbMF07XG4gIHJldHVybiBCb29sZWFuKHIpICYmIEJvb2xlYW4oclsnc2VsZWN0b3InXSkgJiYgclsnc2VsZWN0b3InXS5pbmRleE9mKFZBUl9TVEFSVCkgPT09IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcHMoY3NzVGV4dCkge1xuICBjc3NUZXh0ID0gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCk7XG4gIHJldHVybiByZW1vdmVDdXN0b21Qcm9wQXBwbHkoY3NzVGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BBc3NpZ25tZW50KGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHRcbiAgICAucmVwbGFjZShSWC5jdXN0b21Qcm9wLCAnJylcbiAgICAucmVwbGFjZShSWC5taXhpblByb3AsICcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wQXBwbHkoY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dFxuICAgIC5yZXBsYWNlKFJYLm1peGluQXBwbHksICcnKVxuICAgIC5yZXBsYWNlKFJYLnZhckFwcGx5LCAnJyk7XG59XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IHR5cGVzID0ge1xuICBTVFlMRV9SVUxFOiAxLFxuICBLRVlGUkFNRVNfUlVMRTogNyxcbiAgTUVESUFfUlVMRTogNCxcbiAgTUlYSU5fUlVMRTogMTAwMFxufVxuXG5jb25zdCBPUEVOX0JSQUNFID0gJ3snO1xuY29uc3QgQ0xPU0VfQlJBQ0UgPSAnfSc7XG5cbi8vIGhlbHBlciByZWdleHAnc1xuY29uc3QgUlggPSB7XG4gIGNvbW1lbnRzOiAvXFwvXFwqW14qXSpcXCorKFteLypdW14qXSpcXCorKSpcXC8vZ2ltLFxuICBwb3J0OiAvQGltcG9ydFteO10qOy9naW0sXG4gIGN1c3RvbVByb3A6IC8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/KD86WztcXG5dfCQpL2dpbSxcbiAgbWl4aW5Qcm9wOiAvKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qP3tbXn1dKj99KD86WztcXG5dfCQpPy9naW0sXG4gIG1peGluQXBwbHk6IC9AYXBwbHlcXHMqXFwoP1teKTtdKlxcKT9cXHMqKD86WztcXG5dfCQpPy9naW0sXG4gIHZhckFwcGx5OiAvW147Ol0qPzpbXjtdKj92YXJcXChbXjtdKlxcKSg/Ols7XFxuXXwkKT8vZ2ltLFxuICBrZXlmcmFtZXNSdWxlOiAvXkBbXlxcc10qa2V5ZnJhbWVzLyxcbiAgbXVsdGlwbGVTcGFjZXM6IC9cXHMrL2dcbn1cblxuY29uc3QgVkFSX1NUQVJUID0gJy0tJztcbmNvbnN0IE1FRElBX1NUQVJUID0gJ0BtZWRpYSc7XG5jb25zdCBBVF9TVEFSVCA9ICdAJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2Nzcy1wYXJzZS5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmV4cG9ydCBjb25zdCBWQVJfQVNTSUdOID0gLyg/Ol58WztcXHN7XVxccyopKC0tW1xcdy1dKj8pXFxzKjpcXHMqKD86KCg/OicoPzpcXFxcJ3wuKSo/J3xcIig/OlxcXFxcInwuKSo/XCJ8XFwoW14pXSo/XFwpfFtefTt7XSkrKXxcXHsoW159XSopXFx9KD86KD89WztcXHN9XSl8JCkpL2dpO1xuZXhwb3J0IGNvbnN0IE1JWElOX01BVENIID0gLyg/Ol58XFxXKylAYXBwbHlcXHMqXFwoPyhbXik7XFxuXSopXFwpPy9naTtcbmV4cG9ydCBjb25zdCBWQVJfQ09OU1VNRUQgPSAvKC0tW1xcdy1dKylcXHMqKFs6LDspXXwkKS9naTtcbmV4cG9ydCBjb25zdCBBTklNQVRJT05fTUFUQ0ggPSAvKGFuaW1hdGlvblxccyo6KXwoYW5pbWF0aW9uLW5hbWVcXHMqOikvO1xuZXhwb3J0IGNvbnN0IE1FRElBX01BVENIID0gL0BtZWRpYVxccyguKikvO1xuZXhwb3J0IGNvbnN0IElTX1ZBUiA9IC9eLS0vO1xuZXhwb3J0IGNvbnN0IEJSQUNLRVRFRCA9IC9cXHtbXn1dKlxcfS9nO1xuZXhwb3J0IGNvbnN0IEhPU1RfUFJFRklYID0gJyg/Ol58W14uI1s6XSknO1xuZXhwb3J0IGNvbnN0IEhPU1RfU1VGRklYID0gJygkfFsuOltcXFxccz4rfl0pJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2NvbW1vbi1yZWdleC5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgTUlYSU5fTUFUQ0gsIFZBUl9BU1NJR04gfSBmcm9tICcuL2NvbW1vbi1yZWdleC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAvLyByZW1vdmUgcHJldmlvdXMgcHJvcGVydGllc1xuICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAvLyBOT1RFOiBmb3IgYmMgd2l0aCBzaGltLCBkb24ndCBhcHBseSBudWxsIHZhbHVlcy5cbiAgICBpZiAocCA9PT0gbnVsbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwLCBwcm9wZXJ0aWVzW3BdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIC8qKlxuICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICovXG4gIGNvbnN0IHZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgfVxufVxuXG4vKipcbiAqIHJldHVybiB0cnVlIGlmIGBjc3NUZXh0YCBjb250YWlucyBhIG1peGluIGRlZmluaXRpb24gb3IgY29uc3VtcHRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0TWl4aW4oY3NzVGV4dCkge1xuICBjb25zdCBoYXMgPSBNSVhJTl9NQVRDSC50ZXN0KGNzc1RleHQpIHx8IFZBUl9BU1NJR04udGVzdChjc3NUZXh0KTtcbiAgLy8gcmVzZXQgc3RhdGUgb2YgdGhlIHJlZ2V4ZXNcbiAgTUlYSU5fTUFUQ0gubGFzdEluZGV4ID0gMDtcbiAgVkFSX0FTU0lHTi5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gaGFzO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgdGltZU91dCB9IGZyb20gJy4vYXN5bmMuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5cbi8vIGRldGVjdCBuYXRpdmUgdG91Y2ggYWN0aW9uIHN1cHBvcnRcbmxldCBIQVNfTkFUSVZFX1RBID0gdHlwZW9mIGRvY3VtZW50LmhlYWQuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdzdHJpbmcnO1xubGV0IEdFU1RVUkVfS0VZID0gJ19fcG9seW1lckdlc3R1cmVzJztcbmxldCBIQU5ETEVEX09CSiA9ICdfX3BvbHltZXJHZXN0dXJlc0hhbmRsZWQnO1xubGV0IFRPVUNIX0FDVElPTiA9ICdfX3BvbHltZXJHZXN0dXJlc1RvdWNoQWN0aW9uJztcbi8vIHJhZGl1cyBmb3IgdGFwIGFuZCB0cmFja1xubGV0IFRBUF9ESVNUQU5DRSA9IDI1O1xubGV0IFRSQUNLX0RJU1RBTkNFID0gNTtcbi8vIG51bWJlciBvZiBsYXN0IE4gdHJhY2sgcG9zaXRpb25zIHRvIGtlZXBcbmxldCBUUkFDS19MRU5HVEggPSAyO1xuXG4vLyBEaXNhYmxpbmcgXCJtb3VzZVwiIGhhbmRsZXJzIGZvciAyNTAwbXMgaXMgZW5vdWdoXG5sZXQgTU9VU0VfVElNRU9VVCA9IDI1MDA7XG5sZXQgTU9VU0VfRVZFTlRTID0gWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnY2xpY2snXTtcbi8vIGFuIGFycmF5IG9mIGJpdG1hc2sgdmFsdWVzIGZvciBtYXBwaW5nIE1vdXNlRXZlbnQud2hpY2ggdG8gTW91c2VFdmVudC5idXR0b25zXG5sZXQgTU9VU0VfV0hJQ0hfVE9fQlVUVE9OUyA9IFswLCAxLCA0LCAyXTtcbmxldCBNT1VTRV9IQVNfQlVUVE9OUyA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQoJ3Rlc3QnLCB7YnV0dG9uczogMX0pLmJ1dHRvbnMgPT09IDE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qIGVzbGludCBuby1lbXB0eTogW1wiZXJyb3JcIiwgeyBcImFsbG93RW1wdHlDYXRjaFwiOiB0cnVlIH1dICovXG4vLyBjaGVjayBmb3IgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnNcbmxldCBTVVBQT1JUU19QQVNTSVZFID0gZmFsc2U7XG4oZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgbGV0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge2dldDogZnVuY3Rpb24oKSB7U1VQUE9SVFNfUEFTU0lWRSA9IHRydWU7fX0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaChlKSB7fVxufSkoKTtcblxuLy8gQ2hlY2sgZm9yIHRvdWNoLW9ubHkgZGV2aWNlc1xubGV0IElTX1RPVUNIX09OTFkgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUCg/OltvYV1kfGhvbmUpfEFuZHJvaWQvKTtcblxubGV0IEdlc3R1cmVSZWNvZ25pemVyID0gZnVuY3Rpb24oKXt9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe307XG4vKiogQHR5cGUge2Z1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlZG93bjtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZW1vdmU7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2V1cDtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS50b3VjaHN0YXJ0O1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNobW92ZTtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS50b3VjaGVuZDtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5jbGljaztcblxuLy8gdG91Y2ggd2lsbCBtYWtlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbi8vIGBwcmV2ZW50RGVmYXVsdGAgb24gdG91Y2hlbmQgd2lsbCBjYW5jZWwgdGhlbSxcbi8vIGJ1dCB0aGlzIGJyZWFrcyBgPGlucHV0PmAgZm9jdXMgYW5kIGxpbmsgY2xpY2tzXG4vLyBkaXNhYmxlIG1vdXNlIGhhbmRsZXJzIGZvciBNT1VTRV9USU1FT1VUIG1zIGFmdGVyXG4vLyBhIHRvdWNoZW5kIHRvIGlnbm9yZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG5sZXQgbW91c2VDYW5jZWxsZXIgPSBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gIC8vIENoZWNrIGZvciBzb3VyY2VDYXBhYmlsaXRpZXMsIHVzZWQgdG8gZGlzdGluZ3Vpc2ggc3ludGhldGljIGV2ZW50c1xuICAvLyBpZiBtb3VzZUV2ZW50IGRpZCBub3QgY29tZSBmcm9tIGEgZGV2aWNlIHRoYXQgZmlyZXMgdG91Y2ggZXZlbnRzLFxuICAvLyBpdCB3YXMgbWFkZSBieSBhIHJlYWwgbW91c2UgYW5kIHNob3VsZCBiZSBjb3VudGVkXG4gIC8vIGh0dHA6Ly93aWNnLmdpdGh1Yi5pby9JbnB1dERldmljZUNhcGFiaWxpdGllcy8jZG9tLWlucHV0ZGV2aWNlY2FwYWJpbGl0aWVzLWZpcmVzdG91Y2hldmVudHNcbiAgbGV0IHNjID0gbW91c2VFdmVudC5zb3VyY2VDYXBhYmlsaXRpZXM7XG4gIGlmIChzYyAmJiAhc2MuZmlyZXNUb3VjaEV2ZW50cykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBza2lwIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgbW91c2VFdmVudFtIQU5ETEVEX09CSl0gPSB7c2tpcDogdHJ1ZX07XG4gIC8vIGRpc2FibGUgXCJnaG9zdCBjbGlja3NcIlxuICBpZiAobW91c2VFdmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgbGV0IHBhdGggPSBtb3VzZUV2ZW50LmNvbXBvc2VkUGF0aCAmJiBtb3VzZUV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGhbaV0gPT09IFBPSU5URVJTVEFURS5tb3VzZS50YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG1vdXNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFuPX0gc2V0dXAgVHJ1ZSB0byBhZGQsIGZhbHNlIHRvIHJlbW92ZS5cbiAqL1xuZnVuY3Rpb24gc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKHNldHVwKSB7XG4gIGxldCBldmVudHMgPSBJU19UT1VDSF9PTkxZID8gWydjbGljayddIDogTU9VU0VfRVZFTlRTO1xuICBmb3IgKGxldCBpID0gMCwgZW47IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBlbiA9IGV2ZW50c1tpXTtcbiAgICBpZiAoc2V0dXApIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZW4sIG1vdXNlQ2FuY2VsbGVyLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpZ25vcmVNb3VzZShlKSB7XG4gIGlmICghUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iKSB7XG4gICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKHRydWUpO1xuICB9XG4gIGxldCB1bnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcigpO1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS50YXJnZXQgPSBudWxsO1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IG51bGw7XG4gIH07XG4gIFBPSU5URVJTVEFURS5tb3VzZS50YXJnZXQgPSBlLmNvbXBvc2VkUGF0aCgpWzBdO1xuICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IgPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYlxuICAgICAgLCB0aW1lT3V0LmFmdGVyKE1PVVNFX1RJTUVPVVQpXG4gICAgICAsIHVuc2V0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2IGV2ZW50IHRvIHRlc3QgZm9yIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGhhcyBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gKi9cbmZ1bmN0aW9uIGhhc0xlZnRNb3VzZUJ1dHRvbihldikge1xuICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gIC8vIGV4aXQgZWFybHkgaWYgdGhlIGV2ZW50IGlzIG5vdCBhIG1vdXNlIGV2ZW50XG4gIGlmIChNT1VTRV9FVkVOVFMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gZXYuYnV0dG9uIGlzIG5vdCByZWxpYWJsZSBmb3IgbW91c2Vtb3ZlICgwIGlzIG92ZXJsb2FkZWQgYXMgYm90aCBsZWZ0IGJ1dHRvbiBhbmQgbm8gYnV0dG9ucylcbiAgLy8gaW5zdGVhZCB3ZSB1c2UgZXYuYnV0dG9ucyAoYml0bWFzayBvZiBidXR0b25zKSBvciBmYWxsIGJhY2sgdG8gZXYud2hpY2ggKGRlcHJlY2F0ZWQsIDAgZm9yIG5vIGJ1dHRvbnMsIDEgZm9yIGxlZnQgYnV0dG9uKVxuICBpZiAodHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAvLyBhbGxvdyB1bmRlZmluZWQgZm9yIHRlc3RpbmcgZXZlbnRzXG4gICAgbGV0IGJ1dHRvbnMgPSBldi5idXR0b25zID09PSB1bmRlZmluZWQgPyAxIDogZXYuYnV0dG9ucztcbiAgICBpZiAoKGV2IGluc3RhbmNlb2Ygd2luZG93Lk1vdXNlRXZlbnQpICYmICFNT1VTRV9IQVNfQlVUVE9OUykge1xuICAgICAgYnV0dG9ucyA9IE1PVVNFX1dISUNIX1RPX0JVVFRPTlNbZXYud2hpY2hdIHx8IDA7XG4gICAgfVxuICAgIC8vIGJ1dHRvbnMgaXMgYSBiaXRtYXNrLCBjaGVjayB0aGF0IHRoZSBsZWZ0IGJ1dHRvbiBiaXQgaXMgc2V0ICgxKVxuICAgIHJldHVybiBCb29sZWFuKGJ1dHRvbnMgJiAxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhbGxvdyB1bmRlZmluZWQgZm9yIHRlc3RpbmcgZXZlbnRzXG4gICAgbGV0IGJ1dHRvbiA9IGV2LmJ1dHRvbiA9PT0gdW5kZWZpbmVkID8gMCA6IGV2LmJ1dHRvbjtcbiAgICAvLyBldi5idXR0b24gaXMgMCBpbiBtb3VzZWRvd24vbW91c2V1cC9jbGljayBmb3IgbGVmdCBidXR0b24gYWN0aXZhdGlvblxuICAgIHJldHVybiBidXR0b24gPT09IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNDbGljayhldikge1xuICBpZiAoZXYudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgIC8vIGV2LmRldGFpbCBpcyAwIGZvciBIVE1MRWxlbWVudC5jbGljayBpbiBtb3N0IGJyb3dzZXJzXG4gICAgaWYgKGV2LmRldGFpbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGluIHRoZSB3b3JzdCBjYXNlLCBjaGVjayB0aGF0IHRoZSB4L3kgcG9zaXRpb24gb2YgdGhlIGNsaWNrIGlzIHdpdGhpblxuICAgIC8vIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnRcbiAgICAvLyBUaGFua3MgSUUgMTAgPjooXG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGV2KTtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnQgaXMgYW4gZWxlbWVudCBzbyB3ZSBjYW4gdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCxcbiAgICAvLyBpZiBub3QsIGp1c3QgYXNzdW1lIGl0IGlzIGEgc3ludGhldGljIGNsaWNrXG4gICAgaWYgKCF0Lm5vZGVUeXBlIHx8IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8odCkubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGJjciA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8odCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gdXNlIHBhZ2UgeC95IHRvIGFjY291bnQgZm9yIHNjcm9sbGluZ1xuICAgIGxldCB4ID0gZXYucGFnZVgsIHkgPSBldi5wYWdlWTtcbiAgICAvLyBldiBpcyBhIHN5bnRoZXRpYyBjbGljayBpZiB0aGUgcG9zaXRpb24gaXMgb3V0c2lkZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0YXJnZXRcbiAgICByZXR1cm4gISgoeCA+PSBiY3IubGVmdCAmJiB4IDw9IGJjci5yaWdodCkgJiYgKHkgPj0gYmNyLnRvcCAmJiB5IDw9IGJjci5ib3R0b20pKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmxldCBQT0lOVEVSU1RBVEUgPSB7XG4gIG1vdXNlOiB7XG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIG1vdXNlSWdub3JlSm9iOiBudWxsXG4gIH0sXG4gIHRvdWNoOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGlkOiAtMSxcbiAgICBzY3JvbGxEZWNpZGVkOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiBmaXJzdFRvdWNoQWN0aW9uKGV2KSB7XG4gIGxldCB0YSA9ICdhdXRvJztcbiAgbGV0IHBhdGggPSBldi5jb21wb3NlZFBhdGggJiYgZXYuY29tcG9zZWRQYXRoKCk7XG4gIGlmIChwYXRoKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG47IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuID0gcGF0aFtpXTtcbiAgICAgIGlmIChuW1RPVUNIX0FDVElPTl0pIHtcbiAgICAgICAgdGEgPSBuW1RPVUNIX0FDVElPTl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGE7XG59XG5cbmZ1bmN0aW9uIHRyYWNrRG9jdW1lbnQoc3RhdGVPYmosIG1vdmVmbiwgdXBmbikge1xuICBzdGF0ZU9iai5tb3ZlZm4gPSBtb3ZlZm47XG4gIHN0YXRlT2JqLnVwZm4gPSB1cGZuO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlZm4pO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdXBmbik7XG59XG5cbmZ1bmN0aW9uIHVudHJhY2tEb2N1bWVudChzdGF0ZU9iaikge1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdGF0ZU9iai5tb3ZlZm4pO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgc3RhdGVPYmoudXBmbik7XG4gIHN0YXRlT2JqLm1vdmVmbiA9IG51bGw7XG4gIHN0YXRlT2JqLnVwZm4gPSBudWxsO1xufVxuXG4vLyB1c2UgYSBkb2N1bWVudC13aWRlIHRvdWNoZW5kIGxpc3RlbmVyIHRvIHN0YXJ0IHRoZSBnaG9zdC1jbGljayBwcmV2ZW50aW9uIG1lY2hhbmlzbVxuLy8gVXNlIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBpZiBzdXBwb3J0ZWQsIHRvIG5vdCBhZmZlY3Qgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGlnbm9yZU1vdXNlLCBTVVBQT1JUU19QQVNTSVZFID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2UpO1xuXG5leHBvcnQgY29uc3QgZ2VzdHVyZXMgPSB7fTtcbmV4cG9ydCBjb25zdCByZWNvZ25pemVycyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVlcFRhcmdldEZpbmQoeCwgeSkge1xuICBsZXQgbm9kZSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gIGxldCBuZXh0ID0gbm9kZTtcbiAgLy8gdGhpcyBjb2RlIHBhdGggaXMgb25seSB0YWtlbiB3aGVuIG5hdGl2ZSBTaGFkb3dET00gaXMgdXNlZFxuICAvLyBpZiB0aGVyZSBpcyBhIHNoYWRvd3Jvb3QsIGl0IG1heSBoYXZlIGEgbm9kZSBhdCB4L3lcbiAgLy8gaWYgdGhlcmUgaXMgbm90IGEgc2hhZG93cm9vdCwgZXhpdCB0aGUgbG9vcFxuICB3aGlsZSAobmV4dCAmJiBuZXh0LnNoYWRvd1Jvb3QgJiYgIXdpbmRvdy5TaGFkeURPTSkge1xuICAgIC8vIGlmIHRoZXJlIGlzIGEgbm9kZSBhdCB4L3kgaW4gdGhlIHNoYWRvd3Jvb3QsIGxvb2sgZGVlcGVyXG4gICAgbGV0IG9sZE5leHQgPSBuZXh0O1xuICAgIG5leHQgPSBuZXh0LnNoYWRvd1Jvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAvLyBvbiBTYWZhcmksIGVsZW1lbnRGcm9tUG9pbnQgbWF5IHJldHVybiB0aGUgc2hhZG93Um9vdCBob3N0XG4gICAgaWYgKG9sZE5leHQgPT09IG5leHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmRPcmlnaW5hbFRhcmdldChldikge1xuICAvLyBzaGFkb3dkb21cbiAgaWYgKGV2LmNvbXBvc2VkUGF0aCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge0V2ZW50VGFyZ2V0fSAqLyhldi5jb21wb3NlZFBhdGgoKVswXSk7XG4gIH1cbiAgLy8gc2hhZHlkb21cbiAgcmV0dXJuIGV2LnRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9oYW5kbGVOYXRpdmUoZXYpIHtcbiAgbGV0IGhhbmRsZWQ7XG4gIGxldCB0eXBlID0gZXYudHlwZTtcbiAgbGV0IG5vZGUgPSBldi5jdXJyZW50VGFyZ2V0O1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoIWdvYmopIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGdzID0gZ29ialt0eXBlXTtcbiAgaWYgKCFncykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWV2W0hBTkRMRURfT0JKXSkge1xuICAgIGV2W0hBTkRMRURfT0JKXSA9IHt9O1xuICAgIGlmICh0eXBlLnNsaWNlKDAsIDUpID09PSAndG91Y2gnKSB7XG4gICAgICBldiA9IC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8oZXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAvLyBvbmx5IGhhbmRsZSB0aGUgZmlyc3QgZmluZ2VyXG4gICAgICAgIGlmIChldi50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIFBPSU5URVJTVEFURS50b3VjaC5pZCA9IHQuaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5pZCAhPT0gdC5pZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghSEFTX05BVElWRV9UQSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgICAgX2hhbmRsZVRvdWNoQWN0aW9uKGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVkID0gZXZbSEFORExFRF9PQkpdO1xuICAvLyB1c2VkIHRvIGlnbm9yZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gIGlmIChoYW5kbGVkLnNraXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gcmVzZXQgcmVjb2duaXplciBzdGF0ZVxuICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgIGlmIChyLmZsb3cgJiYgci5mbG93LnN0YXJ0LmluZGV4T2YoZXYudHlwZSkgPiAtMSAmJiByLnJlc2V0KSB7XG4gICAgICAgIHIucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZW5mb3JjZSBnZXN0dXJlIHJlY29nbml6ZXIgb3JkZXJcbiAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgIHIgPSByZWNvZ25pemVyc1tpXTtcbiAgICBpZiAoZ3Nbci5uYW1lXSAmJiAhaGFuZGxlZFtyLm5hbWVdKSB7XG4gICAgICBoYW5kbGVkW3IubmFtZV0gPSB0cnVlO1xuICAgICAgclt0eXBlXShldik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaGFuZGxlVG91Y2hBY3Rpb24oZXYpIHtcbiAgbGV0IHQgPSBldi5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgbGV0IHR5cGUgPSBldi50eXBlO1xuICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgUE9JTlRFUlNUQVRFLnRvdWNoLnggPSB0LmNsaWVudFg7XG4gICAgUE9JTlRFUlNUQVRFLnRvdWNoLnkgPSB0LmNsaWVudFk7XG4gICAgUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgIGlmIChQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IHRydWU7XG4gICAgbGV0IHRhID0gZmlyc3RUb3VjaEFjdGlvbihldik7XG4gICAgbGV0IHByZXZlbnQgPSBmYWxzZTtcbiAgICBsZXQgZHggPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueCAtIHQuY2xpZW50WCk7XG4gICAgbGV0IGR5ID0gTWF0aC5hYnMoUE9JTlRFUlNUQVRFLnRvdWNoLnkgLSB0LmNsaWVudFkpO1xuICAgIGlmICghZXYuY2FuY2VsYWJsZSkge1xuICAgICAgLy8gc2Nyb2xsaW5nIGlzIGhhcHBlbmluZ1xuICAgIH0gZWxzZSBpZiAodGEgPT09ICdub25lJykge1xuICAgICAgcHJldmVudCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0YSA9PT0gJ3Bhbi14Jykge1xuICAgICAgcHJldmVudCA9IGR5ID4gZHg7XG4gICAgfSBlbHNlIGlmICh0YSA9PT0gJ3Bhbi15Jykge1xuICAgICAgcHJldmVudCA9IGR4ID4gZHk7XG4gICAgfVxuICAgIGlmIChwcmV2ZW50KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2ZW50KCd0cmFjaycpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGlmIChnZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgX2FkZChub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICBpZiAoZ2VzdHVyZXNbZXZUeXBlXSkge1xuICAgIF9yZW1vdmUobm9kZSwgZXZUeXBlLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfYWRkKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICBsZXQgcmVjb2duaXplciA9IGdlc3R1cmVzW2V2VHlwZV07XG4gIGxldCBkZXBzID0gcmVjb2duaXplci5kZXBzO1xuICBsZXQgbmFtZSA9IHJlY29nbml6ZXIubmFtZTtcbiAgbGV0IGdvYmogPSBub2RlW0dFU1RVUkVfS0VZXTtcbiAgaWYgKCFnb2JqKSB7XG4gICAgbm9kZVtHRVNUVVJFX0tFWV0gPSBnb2JqID0ge307XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGRlcCwgZ2Q7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVwID0gZGVwc1tpXTtcbiAgICAvLyBkb24ndCBhZGQgbW91c2UgaGFuZGxlcnMgb24gaU9TIGJlY2F1c2UgdGhleSBjYXVzZSBncmF5IHNlbGVjdGlvbiBvdmVybGF5c1xuICAgIGlmIChJU19UT1VDSF9PTkxZICYmIE1PVVNFX0VWRU5UUy5pbmRleE9mKGRlcCkgPiAtMSAmJiBkZXAgIT09ICdjbGljaycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBnZCA9IGdvYmpbZGVwXTtcbiAgICBpZiAoIWdkKSB7XG4gICAgICBnb2JqW2RlcF0gPSBnZCA9IHtfY291bnQ6IDB9O1xuICAgIH1cbiAgICBpZiAoZ2QuX2NvdW50ID09PSAwKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZGVwLCBfaGFuZGxlTmF0aXZlKTtcbiAgICB9XG4gICAgZ2RbbmFtZV0gPSAoZ2RbbmFtZV0gfHwgMCkgKyAxO1xuICAgIGdkLl9jb3VudCA9IChnZC5fY291bnQgfHwgMCkgKyAxO1xuICB9XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldlR5cGUsIGhhbmRsZXIpO1xuICBpZiAocmVjb2duaXplci50b3VjaEFjdGlvbikge1xuICAgIHNldFRvdWNoQWN0aW9uKG5vZGUsIHJlY29nbml6ZXIudG91Y2hBY3Rpb24pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICBsZXQgcmVjb2duaXplciA9IGdlc3R1cmVzW2V2VHlwZV07XG4gIGxldCBkZXBzID0gcmVjb2duaXplci5kZXBzO1xuICBsZXQgbmFtZSA9IHJlY29nbml6ZXIubmFtZTtcbiAgbGV0IGdvYmogPSBub2RlW0dFU1RVUkVfS0VZXTtcbiAgaWYgKGdvYmopIHtcbiAgICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlcCA9IGRlcHNbaV07XG4gICAgICBnZCA9IGdvYmpbZGVwXTtcbiAgICAgIGlmIChnZCAmJiBnZFtuYW1lXSkge1xuICAgICAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAxKSAtIDE7XG4gICAgICAgIGdkLl9jb3VudCA9IChnZC5fY291bnQgfHwgMSkgLSAxO1xuICAgICAgICBpZiAoZ2QuX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGRlcCwgX2hhbmRsZU5hdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihyZWNvZykge1xuICByZWNvZ25pemVycy5wdXNoKHJlY29nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvZy5lbWl0cy5sZW5ndGg7IGkrKykge1xuICAgIGdlc3R1cmVzW3JlY29nLmVtaXRzW2ldXSA9IHJlY29nO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZFJlY29nbml6ZXJCeUV2ZW50KGV2TmFtZSkge1xuICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgIGZvciAobGV0IGogPSAwLCBuOyBqIDwgci5lbWl0cy5sZW5ndGg7IGorKykge1xuICAgICAgbiA9IHIuZW1pdHNbal07XG4gICAgICBpZiAobiA9PT0gZXZOYW1lKSB7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFRvdWNoQWN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gIGlmIChIQVNfTkFUSVZFX1RBKSB7XG4gICAgbm9kZS5zdHlsZS50b3VjaEFjdGlvbiA9IHZhbHVlO1xuICB9XG4gIG5vZGVbVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2ZpcmUodGFyZ2V0LCB0eXBlLCBkZXRhaWwpIHtcbiAgbGV0IGV2ID0gbmV3IEV2ZW50KHR5cGUsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgY29tcG9zZWQ6IHRydWUgfSk7XG4gIGV2LmRldGFpbCA9IGRldGFpbDtcbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuICAvLyBmb3J3YXJkIGBwcmV2ZW50RGVmYXVsdGAgaW4gYSBjbGVhbiB3YXlcbiAgaWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICBsZXQgcHJldmVudGVyID0gZGV0YWlsLnByZXZlbnRlciB8fCBkZXRhaWwuc291cmNlRXZlbnQ7XG4gICAgaWYgKHByZXZlbnRlciAmJiBwcmV2ZW50ZXIucHJldmVudERlZmF1bHQpIHtcbiAgICAgIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudChldk5hbWUpIHtcbiAgbGV0IHJlY29nbml6ZXIgPSBfZmluZFJlY29nbml6ZXJCeUV2ZW50KGV2TmFtZSk7XG4gIGlmIChyZWNvZ25pemVyLmluZm8pIHtcbiAgICByZWNvZ25pemVyLmluZm8ucHJldmVudCA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TW91c2VDYW5jZWxsZXIoKSB7XG4gIGlmIChQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IpIHtcbiAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IuZmx1c2goKTtcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG5yZWdpc3Rlcih7XG4gIG5hbWU6ICdkb3dudXAnLFxuICBkZXBzOiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJ10sXG4gIGZsb3c6IHtcbiAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsnZG93bicsICd1cCddLFxuXG4gIGluZm86IHtcbiAgICBtb3ZlZm46IG51bGwsXG4gICAgdXBmbjogbnVsbFxuICB9LFxuXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB1bnRyYWNrRG9jdW1lbnQodGhpcy5pbmZvKTtcbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICovXG4gIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG1vdmVmbiA9IGZ1bmN0aW9uIG1vdmVmbihlKSB7XG4gICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICBzZWxmLl9maXJlKCd1cCcsIHQsIGUpO1xuICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCB1cGZuID0gZnVuY3Rpb24gdXBmbihlKSB7XG4gICAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICB9XG4gICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICB9O1xuICAgIHRyYWNrRG9jdW1lbnQodGhpcy5pbmZvLCBtb3ZlZm4sIHVwZm4pO1xuICAgIHRoaXMuX2ZpcmUoJ2Rvd24nLCB0LCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5fZmlyZSgnZG93bicsIF9maW5kT3JpZ2luYWxUYXJnZXQoZSksIGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5fZmlyZSgndXAnLCBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpLCBlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmV2ZW50ZXJcbiAgICovXG4gIF9maXJlOiBmdW5jdGlvbih0eXBlLCB0YXJnZXQsIGV2ZW50LCBwcmV2ZW50ZXIpIHtcbiAgICBfZmlyZSh0YXJnZXQsIHR5cGUsIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgcHJldmVudGVyOiBwcmV2ZW50ZXIsXG4gICAgICBwcmV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBwcmV2ZW50KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblxucmVnaXN0ZXIoe1xuICBuYW1lOiAndHJhY2snLFxuICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICBkZXBzOiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddLFxuICBmbG93OiB7XG4gICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICBlbmQ6IFsnbW91c2V1cCcsICd0b3VjaGVuZCddXG4gIH0sXG4gIGVtaXRzOiBbJ3RyYWNrJ10sXG5cbiAgaW5mbzoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBzdGF0ZTogJ3N0YXJ0JyxcbiAgICBzdGFydGVkOiBmYWxzZSxcbiAgICBtb3ZlczogW10sXG4gICAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgICBhZGRNb3ZlOiBmdW5jdGlvbihtb3ZlKSB7XG4gICAgICBpZiAodGhpcy5tb3Zlcy5sZW5ndGggPiBUUkFDS19MRU5HVEgpIHtcbiAgICAgICAgdGhpcy5tb3Zlcy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tb3Zlcy5wdXNoKG1vdmUpO1xuICAgIH0sXG4gICAgbW92ZWZuOiBudWxsLFxuICAgIHVwZm46IG51bGwsXG4gICAgcHJldmVudDogZmFsc2VcbiAgfSxcblxuICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbmZvLnN0YXRlID0gJ3N0YXJ0JztcbiAgICB0aGlzLmluZm8uc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5mby5tb3ZlcyA9IFtdO1xuICAgIHRoaXMuaW5mby54ID0gMDtcbiAgICB0aGlzLmluZm8ueSA9IDA7XG4gICAgdGhpcy5pbmZvLnByZXZlbnQgPSBmYWxzZTtcbiAgICB1bnRyYWNrRG9jdW1lbnQodGhpcy5pbmZvKTtcbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzTW92ZWRFbm91Z2g6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAodGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5mby5zdGFydGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGR4ID0gTWF0aC5hYnModGhpcy5pbmZvLnggLSB4KTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyh0aGlzLmluZm8ueSAtIHkpO1xuICAgIHJldHVybiAoZHggPj0gVFJBQ0tfRElTVEFOQ0UgfHwgZHkgPj0gVFJBQ0tfRElTVEFOQ0UpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICovXG4gIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG1vdmVmbiA9IGZ1bmN0aW9uIG1vdmVmbihlKSB7XG4gICAgICBsZXQgeCA9IGUuY2xpZW50WCwgeSA9IGUuY2xpZW50WTtcbiAgICAgIGlmIChzZWxmLmhhc01vdmVkRW5vdWdoKHgsIHkpKSB7XG4gICAgICAgIC8vIGZpcnN0IG1vdmUgaXMgJ3N0YXJ0Jywgc3Vic2VxdWVudCBtb3ZlcyBhcmUgJ21vdmUnLCBtb3VzZXVwIGlzICdlbmQnXG4gICAgICAgIHNlbGYuaW5mby5zdGF0ZSA9IHNlbGYuaW5mby5zdGFydGVkID8gKGUudHlwZSA9PT0gJ21vdXNldXAnID8gJ2VuZCcgOiAndHJhY2snKSA6ICdzdGFydCc7XG4gICAgICAgIGlmIChzZWxmLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAvLyBpZiBhbmQgb25seSBpZiB0cmFja2luZywgYWx3YXlzIHByZXZlbnQgdGFwXG4gICAgICAgICAgcHJldmVudCgndGFwJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5pbmZvLmFkZE1vdmUoe3g6IHgsIHk6IHl9KTtcbiAgICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgICAvLyBhbHdheXMgX2ZpcmUgXCJlbmRcIlxuICAgICAgICAgIHNlbGYuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX2ZpcmUodCwgZSk7XG4gICAgICAgIHNlbGYuaW5mby5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCB1cGZuID0gZnVuY3Rpb24gdXBmbihlKSB7XG4gICAgICBpZiAoc2VsZi5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgICAgbW92ZWZuKGUpO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgdGhlIHRlbXBvcmFyeSBsaXN0ZW5lcnNcbiAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgIH07XG4gICAgLy8gYWRkIHRlbXBvcmFyeSBkb2N1bWVudCBsaXN0ZW5lcnMgYXMgbW91c2UgcmV0YXJnZXRzXG4gICAgdHJhY2tEb2N1bWVudCh0aGlzLmluZm8sIG1vdmVmbiwgdXBmbik7XG4gICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdGhpcy5pbmZvLnggPSBjdC5jbGllbnRYO1xuICAgIHRoaXMuaW5mby55ID0gY3QuY2xpZW50WTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaG1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBsZXQgeCA9IGN0LmNsaWVudFgsIHkgPSBjdC5jbGllbnRZO1xuICAgIGlmICh0aGlzLmhhc01vdmVkRW5vdWdoKHgsIHkpKSB7XG4gICAgICBpZiAodGhpcy5pbmZvLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgcHJldmVudCgndGFwJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgdGhpcy5fZmlyZSh0LCBjdCk7XG4gICAgICB0aGlzLmluZm8uc3RhdGUgPSAndHJhY2snO1xuICAgICAgdGhpcy5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIC8vIG9ubHkgdHJhY2tlbmQgaWYgdHJhY2sgd2FzIHN0YXJ0ZWQgYW5kIG5vdCBhYm9ydGVkXG4gICAgaWYgKHRoaXMuaW5mby5zdGFydGVkKSB7XG4gICAgICAvLyByZXNldCBzdGFydGVkIHN0YXRlIG9uIHVwXG4gICAgICB0aGlzLmluZm8uc3RhdGUgPSAnZW5kJztcbiAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiBjdC5jbGllbnRYLCB5OiBjdC5jbGllbnRZfSk7XG4gICAgICB0aGlzLl9maXJlKHQsIGN0LCBlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoXG4gICAqL1xuICBfZmlyZTogZnVuY3Rpb24odGFyZ2V0LCB0b3VjaCkge1xuICAgIGxldCBzZWNvbmRsYXN0ID0gdGhpcy5pbmZvLm1vdmVzW3RoaXMuaW5mby5tb3Zlcy5sZW5ndGggLSAyXTtcbiAgICBsZXQgbGFzdG1vdmUgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBkeCA9IGxhc3Rtb3ZlLnggLSB0aGlzLmluZm8ueDtcbiAgICBsZXQgZHkgPSBsYXN0bW92ZS55IC0gdGhpcy5pbmZvLnk7XG4gICAgbGV0IGRkeCwgZGR5ID0gMDtcbiAgICBpZiAoc2Vjb25kbGFzdCkge1xuICAgICAgZGR4ID0gbGFzdG1vdmUueCAtIHNlY29uZGxhc3QueDtcbiAgICAgIGRkeSA9IGxhc3Rtb3ZlLnkgLSBzZWNvbmRsYXN0Lnk7XG4gICAgfVxuICAgIF9maXJlKHRhcmdldCwgJ3RyYWNrJywge1xuICAgICAgc3RhdGU6IHRoaXMuaW5mby5zdGF0ZSxcbiAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICB5OiB0b3VjaC5jbGllbnRZLFxuICAgICAgZHg6IGR4LFxuICAgICAgZHk6IGR5LFxuICAgICAgZGR4OiBkZHgsXG4gICAgICBkZHk6IGRkeSxcbiAgICAgIHNvdXJjZUV2ZW50OiB0b3VjaCxcbiAgICAgIGhvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBUYXJnZXRGaW5kKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn0pO1xuXG5yZWdpc3Rlcih7XG4gIG5hbWU6ICd0YXAnLFxuICBkZXBzOiBbJ21vdXNlZG93bicsICdjbGljaycsICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJ10sXG4gIGZsb3c6IHtcbiAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgIGVuZDogWydjbGljaycsICd0b3VjaGVuZCddXG4gIH0sXG4gIGVtaXRzOiBbJ3RhcCddLFxuICBpbmZvOiB7XG4gICAgeDogTmFOLFxuICAgIHk6IE5hTixcbiAgICBwcmV2ZW50OiBmYWxzZVxuICB9LFxuICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbmZvLnggPSBOYU47XG4gICAgdGhpcy5pbmZvLnkgPSBOYU47XG4gICAgdGhpcy5pbmZvLnByZXZlbnQgPSBmYWxzZTtcbiAgfSxcbiAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgc2F2ZTogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuaW5mby54ID0gZS5jbGllbnRYO1xuICAgIHRoaXMuaW5mby55ID0gZS5jbGllbnRZO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICovXG4gIG1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHRoaXMuc2F2ZShlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgY2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICB0aGlzLmZvcndhcmQoZSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLnNhdmUoZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmZvcndhcmQoZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7RXZlbnQgfCBUb3VjaH0gZVxuICAgKiBAcGFyYW0ge0V2ZW50PX0gcHJldmVudGVyXG4gICAqL1xuICBmb3J3YXJkOiBmdW5jdGlvbihlLCBwcmV2ZW50ZXIpIHtcbiAgICBsZXQgZHggPSBNYXRoLmFicyhlLmNsaWVudFggLSB0aGlzLmluZm8ueCk7XG4gICAgbGV0IGR5ID0gTWF0aC5hYnMoZS5jbGllbnRZIC0gdGhpcy5pbmZvLnkpO1xuICAgIC8vIGZpbmQgb3JpZ2luYWwgdGFyZ2V0IGZyb20gYHByZXZlbnRlcmAgZm9yIFRvdWNoRXZlbnRzLCBvciBgZWAgZm9yIE1vdXNlRXZlbnRzXG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KChwcmV2ZW50ZXIgfHwgZSkpO1xuICAgIC8vIGR4LGR5IGNhbiBiZSBOYU4gaWYgYGNsaWNrYCBoYXMgYmVlbiBzaW11bGF0ZWQgYW5kIHRoZXJlIHdhcyBubyBgZG93bmAgZm9yIGBzdGFydGBcbiAgICBpZiAoaXNOYU4oZHgpIHx8IGlzTmFOKGR5KSB8fCAoZHggPD0gVEFQX0RJU1RBTkNFICYmIGR5IDw9IFRBUF9ESVNUQU5DRSkgfHwgaXNTeW50aGV0aWNDbGljayhlKSkge1xuICAgICAgLy8gcHJldmVudCB0YXBzIGZyb20gYmVpbmcgZ2VuZXJhdGVkIGlmIGFuIGV2ZW50IGhhcyBjYW5jZWxlZCB0aGVtXG4gICAgICBpZiAoIXRoaXMuaW5mby5wcmV2ZW50KSB7XG4gICAgICAgIF9maXJlKHQsICd0YXAnLCB7XG4gICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgIHk6IGUuY2xpZW50WSxcbiAgICAgICAgICBzb3VyY2VFdmVudDogZSxcbiAgICAgICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgZmluZE9yaWdpbmFsVGFyZ2V0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldDtcbmV4cG9ydCBjb25zdCBhZGQgPSBhZGRMaXN0ZW5lcjtcbmV4cG9ydCBjb25zdCByZW1vdmUgPSByZW1vdmVMaXN0ZW5lcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBkZWJvdW5jZXJRdWV1ZSA9IFtdO1xuXG5leHBvcnQgY29uc3QgZW5xdWV1ZURlYm91bmNlciA9IGZ1bmN0aW9uKGRlYm91bmNlcikge1xuICBkZWJvdW5jZXJRdWV1ZS5wdXNoKGRlYm91bmNlcik7XG59O1xuXG5mdW5jdGlvbiBmbHVzaERlYm91bmNlcnMoKSB7XG4gIGNvbnN0IGRpZEZsdXNoID0gQm9vbGVhbihkZWJvdW5jZXJRdWV1ZS5sZW5ndGgpO1xuICB3aGlsZSAoZGVib3VuY2VyUXVldWUubGVuZ3RoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRlYm91bmNlclF1ZXVlLnNoaWZ0KCkuZmx1c2goKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWRGbHVzaDtcbn1cblxuZXhwb3J0IGNvbnN0IGZsdXNoID0gZnVuY3Rpb24oKSB7XG4gIGxldCBzaGFkeURPTSwgZGVib3VuY2VycztcbiAgZG8ge1xuICAgIHNoYWR5RE9NID0gd2luZG93LlNoYWR5RE9NICYmIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pIHtcbiAgICAgIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbS5mbHVzaCgpO1xuICAgIH1cbiAgICBkZWJvdW5jZXJzID0gZmx1c2hEZWJvdW5jZXJzKCk7XG4gIH0gd2hpbGUgKHNoYWR5RE9NIHx8IGRlYm91bmNlcnMpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmx1c2guanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuLi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBNdXRhYmxlRGF0YSB9IGZyb20gJy4uL21peGlucy9tdXRhYmxlLWRhdGEuanMnO1xuXG4vLyBCYXNlIGNsYXNzIGZvciBIVE1MVGVtcGxhdGVFbGVtZW50IGV4dGVuc2lvbiB0aGF0IGhhcyBwcm9wZXJ0eSBlZmZlY3RzXG4vLyBtYWNoaW5lcnkgZm9yIHByb3BhZ2F0aW5nIGhvc3QgcHJvcGVydGllcyB0byBjaGlsZHJlbi4gVGhpcyBpcyBhbiBFUzVcbi8vIGNsYXNzIG9ubHkgYmVjYXVzZSBCYWJlbCAoaW5jb3JyZWN0bHkpIHJlcXVpcmVzIHN1cGVyKCkgaW4gdGhlIGNsYXNzXG4vLyBjb25zdHJ1Y3RvciBldmVuIHRob3VnaCBubyBgdGhpc2AgaXMgdXNlZCBhbmQgaXQgcmV0dXJucyBhbiBpbnN0YW5jZS5cbmxldCBuZXdJbnN0YW5jZSA9IG51bGw7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24oKSB7IHJldHVybiBuZXdJbnN0YW5jZTsgfVxuSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfVxufSk7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb259XG4gKi9cbmNvbnN0IERhdGFUZW1wbGF0ZSA9IFByb3BlcnR5RWZmZWN0cyhIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uKTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAqIEBleHRlbmRzIHtEYXRhVGVtcGxhdGV9XG4gKi9cbmNvbnN0IE11dGFibGVEYXRhVGVtcGxhdGUgPSBNdXRhYmxlRGF0YShEYXRhVGVtcGxhdGUpO1xuXG4vLyBBcHBsaWVzIGEgRGF0YVRlbXBsYXRlIHN1YmNsYXNzIHRvIGEgPHRlbXBsYXRlPiBpbnN0YW5jZVxuZnVuY3Rpb24gdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvcikge1xuICBuZXdJbnN0YW5jZSA9IHRlbXBsYXRlO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGVtcGxhdGUsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gIG5ldyBjb25zdHJ1Y3RvcigpO1xuICBuZXdJbnN0YW5jZSA9IG51bGw7XG59XG5cbi8vIEJhc2UgY2xhc3MgZm9yIFRlbXBsYXRlSW5zdGFuY2Unc1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAqL1xuY29uc3QgYmFzZSA9IFByb3BlcnR5RWZmZWN0cyhjbGFzcyB7fSk7XG5cbi8qKlxuICogQHBvbHltZXJcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gKiBAdW5yZXN0cmljdGVkXG4gKi9cbmNsYXNzIFRlbXBsYXRlSW5zdGFuY2VCYXNlIGV4dGVuZHMgYmFzZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX19kYXRhSG9zdCk7XG4gICAgLy8gU2F2ZSBsaXN0IG9mIHN0YW1wZWQgY2hpbGRyZW5cbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgZm9yIChsZXQgbiA9IHRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2gobik7XG4gICAgICBuLl9fdGVtcGxhdGl6ZUluc3RhbmNlID0gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX190ZW1wbGF0aXplT3duZXIuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSB7XG4gICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKHRydWUpO1xuICAgIH1cbiAgICAvLyBGbHVzaCBwcm9wcyBvbmx5IHdoZW4gcHJvcHMgYXJlIHBhc3NlZCBpZiBpbnN0YW5jZSBwcm9wcyBleGlzdFxuICAgIC8vIG9yIHdoZW4gdGhlcmUgaXNuJ3QgaW5zdGFuY2UgcHJvcHMuXG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgaWYgKChwcm9wcyAmJiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHx8ICFvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSB0aGUgZ2l2ZW4gYHByb3BzYCBieSBjYWxsaW5nIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC4gQWxzb1xuICAgKiBzZXRzIGFueSBwcm9wZXJ0aWVzIHN0b3JlZCBpbiBgX19ob3N0UHJvcHNgLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IG9mIHByb3BlcnR5IG5hbWUtdmFsdWUgcGFpcnMgdG8gc2V0LlxuICAgKi9cbiAgX2NvbmZpZ3VyZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgICBpZiAoaXByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaXByb3AsIHByb3BzW2lwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaHByb3AgaW4gdGhpcy5fX2hvc3RQcm9wcykge1xuICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KGhwcm9wLCB0aGlzLl9fZGF0YUhvc3RbJ19ob3N0XycgKyBocHJvcF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRm9yd2FyZHMgYSBob3N0IHByb3BlcnR5IHRvIHRoaXMgaW5zdGFuY2UuICBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICogY2FsbGVkIG9uIGluc3RhbmNlcyBmcm9tIHRoZSBgb3B0aW9ucy5mb3J3YXJkSG9zdFByb3BgIGNhbGxiYWNrXG4gICAqIHRvIHByb3BhZ2F0ZSBjaGFuZ2VzIG9mIGhvc3QgcHJvcGVydGllcyB0byBlYWNoIGluc3RhbmNlLlxuICAgKlxuICAgKiBOb3RlIHRoaXMgbWV0aG9kIGVucXVldWVzIHRoZSBjaGFuZ2UsIHdoaWNoIGFyZSBmbHVzaGVkIGFzIGEgYmF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG9yIHBhdGggbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBmb3J3YXJkXG4gICAqL1xuICBmb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3AsIHZhbHVlLCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMuX19kYXRhSG9zdC5fZW5xdWV1ZUNsaWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKHRoaXMuX21ldGhvZEhvc3QgJiYgdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zLnBhcmVudE1vZGVsKSB7XG4gICAgICAvLyBJZiB0aGlzIGluc3RhbmNlIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgcGFyZW50IG1vZGVsLCBkZWNvcmF0ZVxuICAgICAgLy8gZXZlbnRzIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UgYXMgYG1vZGVsYFxuICAgICAgdGhpcy5fbWV0aG9kSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgIGUubW9kZWwgPSB0aGlzO1xuICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBkZWxlZ2F0ZSB0byB0aGUgdGVtcGxhdGUncyBob3N0ICh3aGljaCBjb3VsZCBiZSlcbiAgICAgIC8vIGFub3RoZXIgdGVtcGxhdGUgaW5zdGFuY2VcbiAgICAgIGxldCB0ZW1wbGF0ZUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgIGlmICh0ZW1wbGF0ZUhvc3QpIHtcbiAgICAgICAgdGVtcGxhdGVIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTaG93cyBvciBoaWRlcyB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdG9wIGxldmVsIGNoaWxkIGVsZW1lbnRzLiBGb3JcbiAgICogdGV4dCBub2RlcywgYHRleHRDb250ZW50YCBpcyByZW1vdmVkIHdoaWxlIFwiaGlkZGVuXCIgYW5kIHJlcGxhY2VkIHdoZW5cbiAgICogXCJzaG93bi5cIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGUgU2V0IHRvIHRydWUgdG8gaGlkZSB0aGUgY2hpbGRyZW47XG4gICAqIHNldCB0byBmYWxzZSB0byBzaG93IHRoZW0uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zaG93SGlkZUNoaWxkcmVuKGhpZGUpIHtcbiAgICBsZXQgYyA9IHRoaXMuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaT0wOyBpPGMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gY1tpXTtcbiAgICAgIC8vIElnbm9yZSBub24tY2hhbmdlc1xuICAgICAgaWYgKEJvb2xlYW4oaGlkZSkgIT0gQm9vbGVhbihuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykpIHtcbiAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXyA9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBuLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4udGV4dENvbnRlbnQgPSBuLl9fcG9seW1lclRleHRDb250ZW50X187XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG4uc3R5bGUpIHtcbiAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgbi5fX3BvbHltZXJEaXNwbGF5X18gPSBuLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9IG4uX19wb2x5bWVyRGlzcGxheV9fO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbi5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gPSBoaWRlO1xuICAgICAgaWYgKG4uX3Nob3dIaWRlQ2hpbGRyZW4pIHtcbiAgICAgICAgbi5fc2hvd0hpZGVDaGlsZHJlbihoaWRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBkZWZhdWx0IHByb3BlcnR5LWVmZmVjdHMgaW1wbGVtZW50YXRpb24gdG8gaW50ZXJjZXB0XG4gICAqIHRleHRDb250ZW50IGJpbmRpbmdzIHdoaWxlIGNoaWxkcmVuIGFyZSBcImhpZGRlblwiIGFuZCBjYWNoZSBpblxuICAgKiBwcml2YXRlIHN0b3JhZ2UgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAobm9kZS5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gJiZcbiAgICAgICAgbm9kZS5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSAmJiBwcm9wID09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgIG5vZGUuX19wb2x5bWVyVGV4dENvbnRlbnRfXyA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmluZCB0aGUgcGFyZW50IG1vZGVsIG9mIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuICBUaGUgcGFyZW50IG1vZGVsXG4gICAqIGlzIGVpdGhlciBhbm90aGVyIHRlbXBsYXRpemUgaW5zdGFuY2UgdGhhdCBoYWQgb3B0aW9uIGBwYXJlbnRNb2RlbDogdHJ1ZWAsXG4gICAqIG9yIGVsc2UgdGhlIGhvc3QgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IFRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHBhcmVudE1vZGVsKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMuX19wYXJlbnRNb2RlbDtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIG1vZGVsID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gQSB0ZW1wbGF0ZSBpbnN0YW5jZSdzIGBfX2RhdGFIb3N0YCBpcyBhIDx0ZW1wbGF0ZT5cbiAgICAgICAgLy8gYG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdGAgaXMgdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICAgICAgICBtb2RlbCA9IG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgIH0gd2hpbGUgKChvcHRpb25zID0gbW9kZWwuX190ZW1wbGF0aXplT3B0aW9ucykgJiYgIW9wdGlvbnMucGFyZW50TW9kZWwpO1xuICAgICAgdGhpcy5fX3BhcmVudE1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxufVxuXG4vKiogQHR5cGUgeyFEYXRhVGVtcGxhdGV9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX19kYXRhSG9zdDtcbi8qKiBAdHlwZSB7IVRlbXBsYXRpemVPcHRpb25zfSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4vKiogQHR5cGUgeyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fbWV0aG9kSG9zdDtcbi8qKiBAdHlwZSB7IU9iamVjdH0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPd25lcjtcbi8qKiBAdHlwZSB7IU9iamVjdH0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2hvc3RQcm9wcztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICovXG5jb25zdCBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBNdXRhYmxlRGF0YShUZW1wbGF0ZUluc3RhbmNlQmFzZSk7XG5cbmZ1bmN0aW9uIGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKSB7XG4gIC8vIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIGJlIHRoZSBvd25lciBvZiB0aGUgb3V0ZXJtb3N0IHRlbXBsYXRlLlxuICAvLyBJbiBzaGFkb3cgZG9tLCB0aGlzIGlzIGFsd2F5cyBnZXRSb290Tm9kZSgpLmhvc3QsIGJ1dCB3ZSBjYW5cbiAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgLy8gYF9tZXRob2RIb3N0YCBhcyBsb25nIGFzIHRoZXJlIHdlcmUgYmluZGluZ3MgKG9yIGlkJ3MpIG9uIHRoaXNcbiAgLy8gaW5zdGFuY2UgY2F1c2luZyBpdCB0byBnZXQgYSBkYXRhSG9zdC5cbiAgbGV0IHRlbXBsYXRlSG9zdCA9IHRlbXBsYXRlLl9fZGF0YUhvc3Q7XG4gIHJldHVybiB0ZW1wbGF0ZUhvc3QgJiYgdGVtcGxhdGVIb3N0Ll9tZXRob2RIb3N0IHx8IHRlbXBsYXRlSG9zdDtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbi8qKlxuICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICovXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgLy8gQW5vbnltb3VzIGNsYXNzIGNyZWF0ZWQgYnkgdGhlIHRlbXBsYXRpemVcbiAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID9cbiAgICBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgOiBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICovXG4gIGxldCBrbGFzcyA9IGNsYXNzIGV4dGVuZHMgYmFzZSB7IH07XG4gIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zID0gb3B0aW9ucztcbiAga2xhc3MucHJvdG90eXBlLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgcmV0dXJuIGtsYXNzO1xufVxuXG4vKipcbiAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAqL1xuZnVuY3Rpb24gYWRkUHJvcGFnYXRlRWZmZWN0cyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gIGxldCB1c2VyRm9yd2FyZEhvc3RQcm9wID0gb3B0aW9ucy5mb3J3YXJkSG9zdFByb3A7XG4gIGlmICh1c2VyRm9yd2FyZEhvc3RQcm9wKSB7XG4gICAgLy8gUHJvdmlkZSBkYXRhIEFQSSBhbmQgcHJvcGVydHkgZWZmZWN0cyBvbiBtZW1vaXplZCB0ZW1wbGF0ZSBjbGFzc1xuICAgIGxldCBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcztcbiAgICBpZiAoIWtsYXNzKSB7XG4gICAgICBsZXQgYmFzZSA9IG9wdGlvbnMubXV0YWJsZURhdGEgPyBNdXRhYmxlRGF0YVRlbXBsYXRlIDogRGF0YVRlbXBsYXRlO1xuICAgICAga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MgPVxuICAgICAgICBjbGFzcyBUZW1wbGF0aXplZFRlbXBsYXRlIGV4dGVuZHMgYmFzZSB7fTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZSAtID5pbnN0YW5jZXMgZWZmZWN0c1xuICAgICAgLy8gYW5kIGhvc3QgPC0gdGVtcGxhdGUgZWZmZWN0c1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIGhvc3RQcm9wcykge1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KCdfaG9zdF8nICsgcHJvcCxcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLlBST1BBR0FURSxcbiAgICAgICAgICB7Zm46IGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChwcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKX0pO1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KCdfaG9zdF8nICsgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZ3JhZGVUZW1wbGF0ZSh0ZW1wbGF0ZSwga2xhc3MpO1xuICAgIC8vIE1peCBhbnkgcHJlLWJvdW5kIGRhdGEgaW50byBfX2RhdGE7IG5vIG5lZWQgdG8gZmx1c2ggdGhpcyB0b1xuICAgIC8vIGluc3RhbmNlcyBzaW5jZSB0aGV5IHB1bGwgZnJvbSB0aGUgdGVtcGxhdGUgYXQgaW5zdGFuY2UtdGltZVxuICAgIGlmICh0ZW1wbGF0ZS5fX2RhdGFQcm90bykge1xuICAgICAgLy8gTm90ZSwgZ2VuZXJhbGx5IGBfX2RhdGFQcm90b2AgY291bGQgYmUgY2hhaW5lZCwgYnV0IGl0J3MgZ3VhcmFudGVlZFxuICAgICAgLy8gdG8gbm90IGJlIHNpbmNlIHRoaXMgaXMgYSB2YW5pbGxhIHRlbXBsYXRlIHdlIGp1c3QgYWRkZWQgZWZmZWN0cyB0b1xuICAgICAgT2JqZWN0LmFzc2lnbih0ZW1wbGF0ZS5fX2RhdGEsIHRlbXBsYXRlLl9fZGF0YVByb3RvKTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgZGF0YSBmb3IgcGVyZm9ybWFuY2VcbiAgICB0ZW1wbGF0ZS5fX2RhdGFUZW1wID0ge307XG4gICAgdGVtcGxhdGUuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgdGVtcGxhdGUuX19kYXRhT2xkID0gbnVsbDtcbiAgICB0ZW1wbGF0ZS5fZW5hYmxlUHJvcGVydGllcygpO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChob3N0UHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9yd2FyZEhvc3RQcm9wKHRlbXBsYXRlLCBwcm9wLCBwcm9wcykge1xuICAgIHVzZXJGb3J3YXJkSG9zdFByb3AuY2FsbCh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgIHByb3Auc3Vic3RyaW5nKCdfaG9zdF8nLmxlbmd0aCksIHByb3BzW3Byb3BdKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTm90aWZ5RWZmZWN0cyhrbGFzcywgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgZm9yIChsZXQgaXByb3AgaW4gb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgZGVsZXRlIGhvc3RQcm9wc1tpcHJvcF07XG4gICAgbGV0IHVzZXJOb3RpZnlJbnN0YW5jZVByb3AgPSBvcHRpb25zLm5vdGlmeUluc3RhbmNlUHJvcDtcbiAgICBpZiAodXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChpcHJvcCxcbiAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgIHtmbjogY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0KGlwcm9wLCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKX0pO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5mb3J3YXJkSG9zdFByb3AgJiYgdGVtcGxhdGUuX19kYXRhSG9zdCkge1xuICAgIGZvciAobGV0IGhwcm9wIGluIGhvc3RQcm9wcykge1xuICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChocHJvcCxcbiAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgIHtmbjogY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKX0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaW5zdFByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgIHVzZXJOb3RpZnlJbnN0YW5jZVByb3AuY2FsbChpbnN0Ll9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgaW5zdCwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUhvc3RQcm9wKGluc3QsIHByb3AsIHByb3BzKSB7XG4gICAgaW5zdC5fX2RhdGFIb3N0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoJ19ob3N0XycgKyBwcm9wLCBwcm9wc1twcm9wXSwgdHJ1ZSwgdHJ1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXMgdGhhdCB1dGlsaXplXG4gKiBQb2x5bWVyJ3MgZGF0YS1iaW5kaW5nIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lciBmZWF0dXJlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBHZXQgYSB0ZW1wbGF0ZSBmcm9tIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAqICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gKiAgICAgLy8gUHJlcGFyZSB0aGUgdGVtcGxhdGVcbiAqICAgICBsZXQgVGVtcGxhdGVDbGFzcyA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlKTtcbiAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAqICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVDbGFzcyh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAqICAgICAvLyBJbnNlcnQgdGhlIGluc3RhbmNlJ3MgRE9NIHNvbWV3aGVyZSwgZS5nLiBlbGVtZW50J3Mgc2hhZG93IERPTVxuICogICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICogICAgIC8vIGluIHRoZSB0ZW1wbGF0ZVxuICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICpcbiAqIFRoZSBgb3B0aW9uc2AgZGljdGlvbmFyeSBwYXNzZWQgdG8gYHRlbXBsYXRpemVgIGFsbG93cyBmb3IgY3VzdG9taXppbmdcbiAqIGZlYXR1cmVzIG9mIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgY2xhc3MsIGluY2x1ZGluZyBob3cgb3V0ZXItc2NvcGUgaG9zdFxuICogcHJvcGVydGllcyBzaG91bGQgYmUgZm9yd2FyZGVkIGludG8gdGVtcGxhdGUgaW5zdGFuY2VzLCBob3cgYW55IGluc3RhbmNlXG4gKiBwcm9wZXJ0aWVzIGFkZGVkIGludG8gdGhlIHRlbXBsYXRlJ3Mgc2NvcGUgc2hvdWxkIGJlIG5vdGlmaWVkIG91dCB0b1xuICogdGhlIGhvc3QsIGFuZCB3aGV0aGVyIHRoZSBpbnN0YW5jZSBzaG91bGQgYmUgZGVjb3JhdGVkIGFzIGEgXCJwYXJlbnQgbW9kZWxcIlxuICogb2YgYW55IGV2ZW50IGhhbmRsZXJzLlxuICpcbiAqICAgICAvLyBDdXN0b216ZSBwcm9wZXJ0eSBmb3J3YXJkaW5nIGFuZCBldmVudCBtb2RlbCBkZWNvcmF0aW9uXG4gKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICogICAgICAgcGFyZW50TW9kZWw6IHRydWUsXG4gKiAgICAgICBpbnN0YW5jZVByb3BzOiB7Li4ufSxcbiAqICAgICAgIGZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpIHsuLi59LFxuICogICAgICAgbm90aWZ5SW5zdGFuY2VQcm9wKGluc3RhbmNlLCBwcm9wZXJ0eSwgdmFsdWUpIHsuLi59LFxuICogICAgIH0pO1xuICpcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXNcbiAqICAgdXRpbGl6aW5nIFBvbHltZXIgdGVtcGxhdGluZyBmZWF0dXJlcy5cbiAqL1xuXG5jb25zdCBUZW1wbGF0aXplID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFub255bW91cyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGNsYXNzIGJvdW5kIHRvIHRoZVxuICAgKiBgPHRlbXBsYXRlPmAgcHJvdmlkZWQuICBJbnN0YW5jaW5nIHRoZSBjbGFzcyB3aWxsIHJlc3VsdCBpbiB0aGVcbiAgICogdGVtcGxhdGUgYmVpbmcgc3RhbXBlZCBpbnRvIGRvY3VtZW50IGZyYWdtZW50IHN0b3JlZCBhcyB0aGUgaW5zdGFuY2Unc1xuICAgKiBgcm9vdGAgcHJvcGVydHksIGFmdGVyIHdoaWNoIGl0IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBUZW1wbGF0ZXMgbWF5IHV0aWxpemUgYWxsIFBvbHltZXIgZGF0YS1iaW5kaW5nIGZlYXR1cmVzIGFzIHdlbGwgYXNcbiAgICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLiAgRXZlbnQgbGlzdGVuZXJzIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gICAqIGZ1bmN0aW9ucyBpbiB0aGUgdGVtcGxhdGUgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGhvc3Qgb2YgdGhlIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUaGUgY29uc3RydWN0b3IgcmV0dXJuZWQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgZGljdGlvbmFyeSBvZiBpbml0aWFsXG4gICAqIHByb3BlcnR5IHZhbHVlcyB0byBwcm9wYWdhdGUgaW50byB0ZW1wbGF0ZSBiaW5kaW5ncy4gIEFkZGl0aW9uYWxseVxuICAgKiBob3N0IHByb3BlcnRpZXMgY2FuIGJlIGZvcndhcmRlZCBpbiwgYW5kIGluc3RhbmNlIHByb3BlcnRpZXMgY2FuIGJlXG4gICAqIG5vdGlmaWVkIG91dCBieSBwcm92aWRpbmcgb3B0aW9uYWwgY2FsbGJhY2tzIGluIHRoZSBgb3B0aW9uc2AgZGljdGlvbmFyeS5cbiAgICpcbiAgICogVmFsaWQgY29uZmlndXJhdGlvbiBpbiBgb3B0aW9uc2AgYXJlIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIC0gYGZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpYDogQ2FsbGVkIHdoZW4gYSBwcm9wZXJ0eSByZWZlcmVuY2VkXG4gICAqICAgaW4gdGhlIHRlbXBsYXRlIGNoYW5nZWQgb24gdGhlIHRlbXBsYXRlJ3MgaG9zdC4gQXMgdGhpcyBsaWJyYXJ5IGRvZXNcbiAgICogICBub3QgcmV0YWluIHJlZmVyZW5jZXMgdG8gdGVtcGxhdGVzIGluc3RhbmNlZCBieSB0aGUgdXNlciwgaXQgaXMgdGhlXG4gICAqICAgdGVtcGxhdGl6ZSBvd25lcidzIHJlc3BvbnNpYmlsaXR5IHRvIGZvcndhcmQgaG9zdCBwcm9wZXJ0eSBjaGFuZ2VzIGludG9cbiAgICogICB1c2VyLXN0YW1wZWQgaW5zdGFuY2VzLiAgVGhlIGBpbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWBcbiAgICogICAgbWV0aG9kIG9uIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgc2hvdWxkIGJlIGNhbGxlZCB0byBmb3J3YXJkIGhvc3RcbiAgICogICBwcm9wZXJ0aWVzIGludG8gdGhlIHRlbXBsYXRlIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcHJvcGVydHktY2hhbmdlZFxuICAgKiAgIG5vdGlmaWNhdGlvbnMuIEFueSBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdFxuICAgKiAgIGRlZmluZWQgaW4gYGluc3RhbmNlUHJvcHNgIHdpbGwgYmUgbm90aWZpZWQgdXAgdG8gdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICAgKiAgIGF1dG9tYXRpY2FsbHkuXG4gICAqIC0gYGluc3RhbmNlUHJvcHNgOiBEaWN0aW9uYXJ5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgd2lsbCBiZSBhZGRlZFxuICAgKiAgIHRvIHRoZSBpbnN0YW5jZSBieSB0aGUgdGVtcGxhdGl6ZSBvd25lci4gIFRoZXNlIHByb3BlcnRpZXMgc2hhZG93IGFueVxuICAgKiAgIGhvc3QgcHJvcGVydGllcywgYW5kIGNoYW5nZXMgd2l0aGluIHRoZSB0ZW1wbGF0ZSB0byB0aGVzZSBwcm9wZXJ0aWVzXG4gICAqICAgd2lsbCByZXN1bHQgaW4gYG5vdGlmeUluc3RhbmNlUHJvcGAgYmVpbmcgY2FsbGVkLlxuICAgKiAtIGBtdXRhYmxlRGF0YWA6IFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcCBzdHJpY3RcbiAgICogICBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZVxuICAgKiAgIFwiZGlydHlcIikuXG4gICAqIC0gYG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuXG4gICAqICAgYW4gaW5zdGFuY2UgcHJvcGVydHkgY2hhbmdlcy4gIFVzZXJzIG1heSBjaG9vc2UgdG8gY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogICBvbiBlLmcuIHRoZSBvd25lciB0byBub3RpZnkgdGhlIGNoYW5nZS5cbiAgICogLSBgcGFyZW50TW9kZWxgOiBXaGVuIGB0cnVlYCwgZXZlbnRzIGhhbmRsZWQgYnkgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqICAgKGBvbi1ldmVudD1cImhhbmRsZXJcImApIHdpbGwgYmUgZGVjb3JhdGVkIHdpdGggYSBgbW9kZWxgIHByb3BlcnR5IHBvaW50aW5nXG4gICAqICAgdG8gdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoYXQgc3RhbXBlZCBpdC4gIEl0IHdpbGwgYWxzbyBiZSByZXR1cm5lZFxuICAgKiAgIGZyb20gYGluc3RhbmNlLnBhcmVudE1vZGVsYCBpbiBjYXNlcyB3aGVyZSB0ZW1wbGF0ZSBpbnN0YW5jZSBuZXN0aW5nXG4gICAqICAgY2F1c2VzIGFuIGlubmVyIG1vZGVsIHRvIHNoYWRvdyBhbiBvdXRlciBtb2RlbC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjbGFzcyByZXR1cm5lZCBmcm9tIGB0ZW1wbGF0aXplYCBpcyBnZW5lcmF0ZWQgb25seSBvbmNlXG4gICAqIGZvciBhIGdpdmVuIGA8dGVtcGxhdGU+YCB1c2luZyBgb3B0aW9uc2AgZnJvbSB0aGUgZmlyc3QgY2FsbCBmb3IgdGhhdFxuICAgKiB0ZW1wbGF0ZSwgYW5kIHRoZSBjYWNoZWQgY2xhc3MgaXMgcmV0dXJuZWQgZm9yIGFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gICAqIGB0ZW1wbGF0aXplYCBmb3IgdGhhdCB0ZW1wbGF0ZS4gIEFzIHN1Y2gsIGBvcHRpb25zYCBjYWxsYmFja3Mgc2hvdWxkIG5vdFxuICAgKiBjbG9zZSBvdmVyIG93bmVyLXNwZWNpZmljIHByb3BlcnRpZXMgc2luY2Ugb25seSB0aGUgZmlyc3QgYG9wdGlvbnNgIGlzXG4gICAqIHVzZWQ7IHJhdGhlciwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgYm91bmQgdG8gdGhlIGBvd25lcmAsIGFuZCBzbyBjb250ZXh0XG4gICAqIG5lZWRlZCBmcm9tIHRoZSBjYWxsYmFja3MgKHN1Y2ggYXMgcmVmZXJlbmNlcyB0byBgaW5zdGFuY2VzYCBzdGFtcGVkKVxuICAgKiBzaG91bGQgYmUgc3RvcmVkIG9uIHRoZSBgb3duZXJgIHN1Y2ggdGhhdCB0aGV5IGNhbiBiZSByZXRyaWV2ZWQgdmlhIGB0aGlzYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byB0ZW1wbGF0aXplXG4gICAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBvd25lciBPd25lciBvZiB0aGUgdGVtcGxhdGUgaW5zdGFuY2VzO1xuICAgKiAgIGFueSBvcHRpb25hbCBjYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGlzIG93bmVyLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBkaWN0aW9uYXJ5IChzZWUgc3VtbWFyeSBmb3IgZGV0YWlscylcbiAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gR2VuZXJhdGVkIGNsYXNzIGJvdW5kIHRvIHRoZSB0ZW1wbGF0ZVxuICAgKiAgIHByb3ZpZGVkXG4gICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgKi9cbiAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgb3duZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovKG9wdGlvbnMgfHwge30pO1xuICAgIGlmICh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIDx0ZW1wbGF0ZT4gY2FuIG9ubHkgYmUgdGVtcGxhdGl6ZWQgb25jZScpO1xuICAgIH1cbiAgICB0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgIGxldCB0ZW1wbGF0ZUluZm8gPSBvd25lci5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgLy8gR2V0IG1lbW9pemVkIGJhc2UgY2xhc3MgZm9yIHRoZSBwcm90b3R5cGljYWwgdGVtcGxhdGUsIHdoaWNoXG4gICAgLy8gaW5jbHVkZXMgcHJvcGVydHkgZWZmZWN0cyBmb3IgYmluZGluZyB0ZW1wbGF0ZSAmIGZvcndhcmRpbmdcbiAgICBsZXQgYmFzZUNsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzO1xuICAgIGlmICghYmFzZUNsYXNzKSB7XG4gICAgICBiYXNlQ2xhc3MgPSBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzID0gYmFzZUNsYXNzO1xuICAgIH1cbiAgICAvLyBIb3N0IHByb3BlcnR5IGZvcndhcmRpbmcgbXVzdCBiZSBpbnN0YWxsZWQgb250byB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgIGFkZFByb3BhZ2F0ZUVmZmVjdHModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgLy8gU3ViY2xhc3MgYmFzZSBjbGFzcyBhbmQgYWRkIHJlZmVyZW5jZSBmb3IgdGhpcyBzcGVjaWZpYyB0ZW1wbGF0ZVxuICAgIGxldCBrbGFzcyA9IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2UgZXh0ZW5kcyBiYXNlQ2xhc3Mge307XG4gICAga2xhc3MucHJvdG90eXBlLl9tZXRob2RIb3N0ID0gZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpO1xuICAgIGtsYXNzLnByb3RvdHlwZS5fX2RhdGFIb3N0ID0gdGVtcGxhdGU7XG4gICAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAga2xhc3MucHJvdG90eXBlLl9faG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UpfSAqLyhrbGFzcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICogYFRlbXBsYXRlSW5zdGFuY2VCYXNlYCwgYW5kIHNob3VsZCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgZGF0YVxuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICBsZXQgbW9kZWwgPSBtb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgKiAgIGlmIChtb2RlbC5pbmRleCA8IDEwKSB7XG4gICAqICAgICBtb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRoZSBtb2RlbCB3aWxsIGJlIHJldHVybmVkIGZvclxuICAgKiAgIGVsZW1lbnRzIHN0YW1wZWQgZnJvbSB0aGlzIHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFRlbXBsYXRlIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGVcbiAgICogICBiaW5kaW5nIHNjb3BlIGZvciB0aGUgZWxlbWVudFxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KHRlbXBsYXRlLCBub2RlKSB7XG4gICAgbGV0IG1vZGVsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAvLyBBbiBlbGVtZW50IHdpdGggYSBfX3RlbXBsYXRpemVJbnN0YW5jZSBtYXJrcyB0aGUgdG9wIGJvdW5kYXJ5XG4gICAgICAvLyBvZiBhIHNjb3BlOyB3YWxrIHVwIHVudGlsIHdlIGZpbmQgb25lLCBhbmQgdGhlbiBlbnN1cmUgdGhhdFxuICAgICAgLy8gaXRzIF9fZGF0YUhvc3QgbWF0Y2hlcyBgdGhpc2AsIG1lYW5pbmcgdGhpcyBkb20tcmVwZWF0IHN0YW1wZWQgaXRcbiAgICAgIGlmICgobW9kZWwgPSBub2RlLl9fdGVtcGxhdGl6ZUluc3RhbmNlKSkge1xuICAgICAgICAvLyBGb3VuZCBhbiBlbGVtZW50IHN0YW1wZWQgYnkgYW5vdGhlciB0ZW1wbGF0ZTsga2VlcCB3YWxraW5nIHVwXG4gICAgICAgIC8vIGZyb20gaXRzIF9fZGF0YUhvc3RcbiAgICAgICAgaWYgKG1vZGVsLl9fZGF0YUhvc3QgIT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICBub2RlID0gbW9kZWwuX19kYXRhSG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0aWxsIGluIGEgdGVtcGxhdGUgc2NvcGUsIGtlZXAgZ29pbmcgdXAgdW50aWxcbiAgICAgICAgLy8gYSBfX3RlbXBsYXRpemVJbnN0YW5jZSBpcyBmb3VuZFxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuZXhwb3J0IHsgVGVtcGxhdGl6ZSB9O1xuZXhwb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvdGVtcGxhdGl6ZS5qcyIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgYXMgVGVtcGxhdGVJbnN0YW5jZUJhc2UkMCwgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgZW5xdWV1ZURlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5pbXBvcnQgeyBPcHRpb25hbE11dGFibGVEYXRhIH0gZnJvbSAnLi4vbWl4aW5zL211dGFibGUtZGF0YS5qcyc7XG5pbXBvcnQgeyBtYXRjaGVzLCB0cmFuc2xhdGUgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcbmltcG9ydCB7IHRpbWVPdXQsIG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcblxubGV0IFRlbXBsYXRlSW5zdGFuY2VCYXNlID0gVGVtcGxhdGVJbnN0YW5jZUJhc2UkMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gKi9cbmNvbnN0IGRvbVJlcGVhdEJhc2UgPSBPcHRpb25hbE11dGFibGVEYXRhKEVsZW1lbnQpO1xuXG4vKipcbiAqIFRoZSBgPGRvbS1yZXBlYXQ+YCBlbGVtZW50IHdpbGwgYXV0b21hdGljYWxseSBzdGFtcCBhbmQgYmluZHMgb25lIGluc3RhbmNlXG4gKiBvZiB0ZW1wbGF0ZSBjb250ZW50IHRvIGVhY2ggb2JqZWN0IGluIGEgdXNlci1wcm92aWRlZCBhcnJheS5cbiAqIGBkb20tcmVwZWF0YCBhY2NlcHRzIGFuIGBpdGVtc2AgcHJvcGVydHksIGFuZCBvbmUgaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlXG4gKiBpcyBzdGFtcGVkIGZvciBlYWNoIGl0ZW0gaW50byB0aGUgRE9NIGF0IHRoZSBsb2NhdGlvbiBvZiB0aGUgYGRvbS1yZXBlYXRgXG4gKiBlbGVtZW50LiAgVGhlIGBpdGVtYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCBvbiBlYWNoIGluc3RhbmNlJ3MgYmluZGluZ1xuICogc2NvcGUsIHRodXMgdGVtcGxhdGVzIHNob3VsZCBiaW5kIHRvIHN1Yi1wcm9wZXJ0aWVzIG9mIGBpdGVtYC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICpcbiAqICAgPHRlbXBsYXRlPlxuICpcbiAqICAgICA8ZGl2PiBFbXBsb3llZSBsaXN0OiA8L2Rpdj5cbiAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICogICAgIDwvdGVtcGxhdGU+XG4gKlxuICogICA8L3RlbXBsYXRlPlxuICpcbiAqICAgPHNjcmlwdD5cbiAqICAgICBQb2x5bWVyKHtcbiAqICAgICAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gKiAgICAgICByZWFkeTogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIHRoaXMuZW1wbG95ZWVzID0gW1xuICogICAgICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gKiAgICAgICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgPCAvc2NyaXB0PlxuICpcbiAqIDwvZG9tLW1vZHVsZT5cbiAqIGBgYFxuICpcbiAqIE5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gaXRlbXMgc3ViLXByb3BlcnRpZXMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGVtcGxhdGVcbiAqIGluc3RhbmNlcywgd2hpY2ggd2lsbCB1cGRhdGUgdmlhIHRoZSBub3JtYWwgc3RydWN0dXJlZCBkYXRhIG5vdGlmaWNhdGlvbiBzeXN0ZW0uXG4gKlxuICogTXV0YXRpb25zIHRvIHRoZSBgaXRlbXNgIGFycmF5IGl0c2VsZiBzaG91bGQgYmUgbWFkZSB1c2luZyB0aGUgQXJyYXlcbiAqIG11dGF0aW9uIEFQSSdzIG9uIGBQb2x5bWVyLkJhc2VgIChgcHVzaGAsIGBwb3BgLCBgc3BsaWNlYCwgYHNoaWZ0YCxcbiAqIGB1bnNoaWZ0YCksIGFuZCB0ZW1wbGF0ZSBpbnN0YW5jZXMgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgZGF0YSBpbiB0aGVcbiAqIGFycmF5LlxuICpcbiAqIEV2ZW50cyBjYXVnaHQgYnkgZXZlbnQgaGFuZGxlcnMgd2l0aGluIHRoZSBgZG9tLXJlcGVhdGAgdGVtcGxhdGUgd2lsbCBiZVxuICogZGVjb3JhdGVkIHdpdGggYSBgbW9kZWxgIHByb3BlcnR5LCB3aGljaCByZXByZXNlbnRzIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICogZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBQb2x5bWVyLkJhc2UsIGFuZCBzaG91bGRcbiAqIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIG9uIHRoZSBpbnN0YW5jZSwgZm9yIGV4YW1wbGVcbiAqIGBldmVudC5tb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO2AuXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgdGhlIG1vZGVsIGZvciBhIHRlbXBsYXRlIGluc3RhbmNlIGZvciBhbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAqIGEgYGRvbS1yZXBlYXRgIGNhbiBiZSBvYnRhaW5lZCB1c2luZyB0aGUgYG1vZGVsRm9yRWxlbWVudGAgQVBJIG9uIHRoZVxuICogYGRvbS1yZXBlYXRgIHRoYXQgc3RhbXBlZCBpdCwgZm9yIGV4YW1wbGVcbiAqIGB0aGlzLiQuZG9tUmVwZWF0Lm1vZGVsRm9yRWxlbWVudChldmVudC50YXJnZXQpLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAqIFRoaXMgbWF5IGJlIHVzZWZ1bCBmb3IgbWFuaXB1bGF0aW5nIGluc3RhbmNlIGRhdGEgb2YgZXZlbnQgdGFyZ2V0cyBvYnRhaW5lZFxuICogYnkgZXZlbnQgaGFuZGxlcnMgb24gcGFyZW50cyBvZiB0aGUgYGRvbS1yZXBlYXRgIChldmVudCBkZWxlZ2F0aW9uKS5cbiAqXG4gKiBBIHZpZXctc3BlY2lmaWMgZmlsdGVyL3NvcnQgbWF5IGJlIGFwcGxpZWQgdG8gZWFjaCBgZG9tLXJlcGVhdGAgYnkgc3VwcGx5aW5nIGFcbiAqIGBmaWx0ZXJgIGFuZC9vciBgc29ydGAgcHJvcGVydHkuICBUaGlzIG1heSBiZSBhIHN0cmluZyB0aGF0IG5hbWVzIGEgZnVuY3Rpb24gb25cbiAqIHRoZSBob3N0LCBvciBhIGZ1bmN0aW9uIG1heSBiZSBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgZGlyZWN0bHkuICBUaGUgZnVuY3Rpb25zXG4gKiBzaG91bGQgaW1wbGVtZW50ZWQgZm9sbG93aW5nIHRoZSBzdGFuZGFyZCBgQXJyYXlgIGZpbHRlci9zb3J0IEFQSS5cbiAqXG4gKiBJbiBvcmRlciB0byByZS1ydW4gdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9ucyBiYXNlZCBvbiBjaGFuZ2VzIHRvIHN1Yi1maWVsZHNcbiAqIG9mIGBpdGVtc2AsIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgbWF5IGJlIHNldCBhcyBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mXG4gKiBgaXRlbWAgc3ViLWZpZWxkcyB0aGF0IHNob3VsZCBjYXVzZSBhIHJlLWZpbHRlci9zb3J0IHdoZW4gbW9kaWZpZWQuICBJZlxuICogdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9uIGRlcGVuZHMgb24gcHJvcGVydGllcyBub3QgY29udGFpbmVkIGluIGBpdGVtc2AsXG4gKiB0aGUgdXNlciBzaG91bGQgb2JzZXJ2ZSBjaGFuZ2VzIHRvIHRob3NlIHByb3BlcnRpZXMgYW5kIGNhbGwgYHJlbmRlcmAgdG8gdXBkYXRlXG4gKiB0aGUgdmlldyBiYXNlZCBvbiB0aGUgZGVwZW5kZW5jeSBjaGFuZ2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGZvciBhbiBgZG9tLXJlcGVhdGAgd2l0aCBhIGZpbHRlciBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIGBgYGpzXG4gKiBpc0VuZ2luZWVyOiBmdW5jdGlvbihpdGVtKSB7XG4gKiAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSAnZW5naW5lZXInIHx8IGl0ZW0ubWFuYWdlci50eXBlID09ICdlbmdpbmVlcic7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGVuIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYXMgZm9sbG93czpcbiAqXG4gKiBgYGBodG1sXG4gKiA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCJcbiAqICAgICAgICAgICBmaWx0ZXI9XCJpc0VuZ2luZWVyXCIgb2JzZXJ2ZT1cInR5cGUgbWFuYWdlci50eXBlXCI+XG4gKiBgYGBcbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQHBvbHltZXJcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAZXh0ZW5kcyB7ZG9tUmVwZWF0QmFzZX1cbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3Igc3RhbXBpbmcgaW5zdGFuY2Ugb2YgYSB0ZW1wbGF0ZSBib3VuZCB0b1xuICogICBpdGVtcyBpbiBhbiBhcnJheS5cbiAqL1xuY2xhc3MgRG9tUmVwZWF0IGV4dGVuZHMgZG9tUmVwZWF0QmFzZSB7XG5cbiAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1yZXBlYXQnOyB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBET00gaXMgYWRkZWQgb3IgcmVtb3ZlZCBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgKiBgcmVuZGVyYC5cbiAgICAgKlxuICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICovXG4gICAgcmV0dXJuIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGl0ZW1zIGRldGVybWluaW5nIGhvdyBtYW55IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGVcbiAgICAgICAqIHRvIHN0YW1wIGFuZCB0aGF0IHRoYXQgZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZSBzaG91bGQgYmluZCB0by5cbiAgICAgICAqL1xuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXlcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIGFycmF5XG4gICAgICAgKiBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAgICovXG4gICAgICBhczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaXRlbSdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMuXG4gICAgICAgKiBOb3RlLCBmb3IgdGhlIGluZGV4IGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXksIHVzZSB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgKiBgaXRlbXNJbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAqL1xuICAgICAgaW5kZXhBczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaW5kZXgnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBhZGQgdG8gdGhlIGJpbmRpbmcgc2NvcGUgd2l0aCB0aGUgaW5kZXhcbiAgICAgICAqIG9mIHRoZSBpbnN0YW5jZSBpbiB0aGUgYHRoaXMuaXRlbXNgIGFycmF5LiBOb3RlLCBmb3IgdGhlIGluZGV4IG9mXG4gICAgICAgKiB0aGlzIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMsXG4gICAgICAgKiB1c2UgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXhBc2AgcHJvcGVydHkuXG4gICAgICAgKi9cbiAgICAgIGl0ZW1zSW5kZXhBczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaXRlbXNJbmRleCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBkZXRlcm1pbmUgdGhlIHNvcnQgb3JkZXIgb2YgdGhlIGl0ZW1zLiAgVGhpc1xuICAgICAgICogcHJvcGVydHkgc2hvdWxkIGVpdGhlciBiZSBwcm92aWRlZCBhcyBhIHN0cmluZywgaW5kaWNhdGluZyBhIG1ldGhvZFxuICAgICAgICogbmFtZSBvbiB0aGUgZWxlbWVudCdzIGhvc3QsIG9yIGVsc2UgYmUgYW4gYWN0dWFsIGZ1bmN0aW9uLiAgVGhlXG4gICAgICAgKiBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIHNvcnQgZnVuY3Rpb24gcGFzc2VkIHRvIGBBcnJheS5zb3J0YC5cbiAgICAgICAqIFVzaW5nIGEgc29ydCBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgKi9cbiAgICAgIHNvcnQ6IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIG9ic2VydmVyOiAnX19zb3J0Q2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbHRlciBpdGVtcyBvdXQgb2YgdGhlIHZpZXcuICBUaGlzXG4gICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LmZpbHRlcmAuXG4gICAgICAgKiBVc2luZyBhIGZpbHRlciBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgKi9cbiAgICAgIGZpbHRlcjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2ZpbHRlckNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHlcbiAgICAgICAqIHNob3VsZCBiZSBzZXQgdG8gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgbmFtZXMgb2YgaXRlbVxuICAgICAgICogc3ViLWZpZWxkcyB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgcmUtc29ydCBvciByZS1maWx0ZXIgd2hlbiBjaGFuZ2VkLlxuICAgICAgICogVGhlc2Ugc2hvdWxkIGdlbmVyYWxseSBiZSBmaWVsZHMgb2YgYGl0ZW1gIHRoYXQgdGhlIHNvcnQgb3IgZmlsdGVyXG4gICAgICAgKiBmdW5jdGlvbiBkZXBlbmRzIG9uLlxuICAgICAgICovXG4gICAgICBvYnNlcnZlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX29ic2VydmVDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHVzaW5nIGEgYGZpbHRlcmAgb3IgYHNvcnRgIGZ1bmN0aW9uLCB0aGUgYGRlbGF5YCBwcm9wZXJ0eVxuICAgICAgICogZGV0ZXJtaW5lcyBhIGRlYm91bmNlIHRpbWUgYWZ0ZXIgYSBjaGFuZ2UgdG8gb2JzZXJ2ZWQgaXRlbVxuICAgICAgICogcHJvcGVydGllcyB0aGF0IG11c3QgcGFzcyBiZWZvcmUgdGhlIGZpbHRlciBvciBzb3J0IGlzIHJlLXJ1bi5cbiAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIHJhdGUtbGltaXRpbmcgc2h1ZmZpbmcgb2YgdGhlIHZpZXcgd2hlblxuICAgICAgICogaXRlbSBjaGFuZ2VzIG1heSBiZSBmcmVxdWVudC5cbiAgICAgICAqL1xuICAgICAgZGVsYXk6IE51bWJlcixcblxuICAgICAgLyoqXG4gICAgICAgKiBDb3VudCBvZiBjdXJyZW50bHkgcmVuZGVyZWQgaXRlbXMgYWZ0ZXIgYGZpbHRlcmAgKGlmIGFueSkgaGFzIGJlZW4gYXBwbGllZC5cbiAgICAgICAqIElmIFwiY2h1bmtpbmcgbW9kZVwiIGlzIGVuYWJsZWQsIGByZW5kZXJlZEl0ZW1Db3VudGAgaXMgdXBkYXRlZCBlYWNoIHRpbWUgYVxuICAgICAgICogc2V0IG9mIHRlbXBsYXRlIGluc3RhbmNlcyBpcyByZW5kZXJlZC5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIHJlbmRlcmVkSXRlbUNvdW50OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmVzIGFuIGluaXRpYWwgY291bnQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIHRvIHJlbmRlciBhZnRlciBzZXR0aW5nXG4gICAgICAgKiB0aGUgYGl0ZW1zYCBhcnJheSwgYmVmb3JlIHRoZSBuZXh0IHBhaW50LCBhbmQgcHV0cyB0aGUgYGRvbS1yZXBlYXRgXG4gICAgICAgKiBpbnRvIFwiY2h1bmtpbmcgbW9kZVwiLiAgVGhlIHJlbWFpbmluZyBpdGVtcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJlbmRlcmVkXG4gICAgICAgKiBpbmNyZW1lbnRhbGx5IGF0IGVhY2ggYW5pbWF0aW9uIGZyYW1lIHRoZXJvZiB1bnRpbCBhbGwgaW5zdGFuY2VzIGhhdmVcbiAgICAgICAqIGJlZW4gcmVuZGVyZWQuXG4gICAgICAgKi9cbiAgICAgIGluaXRpYWxDb3VudDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIG9ic2VydmVyOiAnX19pbml0aWFsaXplQ2h1bmtpbmcnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gYGluaXRpYWxDb3VudGAgaXMgdXNlZCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIGEgZnJhbWUgcmF0ZSB0b1xuICAgICAgICogdGFyZ2V0IGJ5IHRocm90dGxpbmcgdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgcmVuZGVyZWQgZWFjaCBmcmFtZSB0b1xuICAgICAgICogbm90IGV4Y2VlZCB0aGUgYnVkZ2V0IGZvciB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUuICBTZXR0aW5nIHRoaXMgdG8gYVxuICAgICAgICogaGlnaGVyIG51bWJlciB3aWxsIGFsbG93IGxvd2VyIGxhdGVuY3kgYW5kIGhpZ2hlciB0aHJvdWdocHV0IGZvclxuICAgICAgICogdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIGJ1dCB3aWxsIHJlc3VsdCBpbiBhIGxvbmdlciB0aW1lIGZvciB0aGVcbiAgICAgICAqIHJlbWFpbmluZyBpdGVtcyB0byBjb21wbGV0ZSByZW5kZXJpbmcuXG4gICAgICAgKi9cbiAgICAgIHRhcmdldEZyYW1lcmF0ZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAyMFxuICAgICAgfSxcblxuICAgICAgX3RhcmdldEZyYW1lVGltZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlRnJhbWVUaW1lKHRhcmdldEZyYW1lcmF0ZSknXG4gICAgICB9XG5cbiAgICB9O1xuXG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICByZXR1cm4gWyAnX19pdGVtc0NoYW5nZWQoaXRlbXMuKiknIF07XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19pbnN0YW5jZXMgPSBbXTtcbiAgICB0aGlzLl9fbGltaXQgPSBJbmZpbml0eTtcbiAgICB0aGlzLl9fcG9vbCA9IFtdO1xuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgIHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeCA9IHt9O1xuICAgIHRoaXMuX19jaHVua0NvdW50ID0gbnVsbDtcbiAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IG51bGw7XG4gICAgdGhpcy5fX3NvcnRGbiA9IG51bGw7XG4gICAgdGhpcy5fX2ZpbHRlckZuID0gbnVsbDtcbiAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gbnVsbDtcbiAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gICAgdGhpcy5fX2lzRGV0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX19kZXRhY2hJbnN0YW5jZShpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIC8vIG9ubHkgcGVyZm9ybSBhdHRhY2htZW50IGlmIHRoZSBlbGVtZW50IHdhcyBwcmV2aW91c2x5IGRldGFjaGVkLlxuICAgIGlmICh0aGlzLl9faXNEZXRhY2hlZCkge1xuICAgICAgdGhpcy5fX2lzRGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9fYXR0YWNoSW5zdGFuY2UoaSwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2Vuc3VyZVRlbXBsYXRpemVkKCkge1xuICAgIC8vIFRlbXBsYXRpemluZyAoZ2VuZXJhdGluZyB0aGUgaW5zdGFuY2UgY29uc3RydWN0b3IpIG5lZWRzIHRvIHdhaXRcbiAgICAvLyB1bnRpbCByZWFkeSwgc2luY2Ugd29uJ3QgaGF2ZSBpdHMgdGVtcGxhdGUgY29udGVudCBoYW5kZWQgYmFjayB0b1xuICAgIC8vIGl0IHVudGlsIHRoZW5cbiAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1yZXBlYXQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRlbXBsYXRlIGluc3RhbmNlIHByb3BzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZm9yd2FyZGluZ1xuICAgICAgbGV0IGluc3RhbmNlUHJvcHMgPSB7fTtcbiAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5hc10gPSB0cnVlO1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmluZGV4QXNdID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5pdGVtc0luZGV4QXNdID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgIG11dGFibGVEYXRhOiB0aGlzLm11dGFibGVEYXRhLFxuICAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VQcm9wczogaW5zdGFuY2VQcm9wcyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBzZXRcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgICAgICovXG4gICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICBsZXQgaSQgPSB0aGlzLl9faW5zdGFuY2VzO1xuICAgICAgICAgIGZvciAobGV0IGk9MCwgaW5zdDsgKGk8aSQubGVuZ3RoKSAmJiAoaW5zdD1pJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgaW5zdC5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdCBJbnN0YW5jZSB0byBub3RpZnlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gbm90aWZ5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gbm90aWZ5XG4gICAgICAgICAqL1xuICAgICAgICBub3RpZnlJbnN0YW5jZVByb3A6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXModGhpcy5hcywgcHJvcCkpIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpbnN0W3RoaXMuaXRlbXNJbmRleEFzXTtcbiAgICAgICAgICAgIGlmIChwcm9wID09IHRoaXMuYXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGF0aCA9IHRyYW5zbGF0ZSh0aGlzLmFzLCAnaXRlbXMuJyArIGlkeCwgcHJvcCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVBhdGgocGF0aCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX19nZXRNZXRob2RIb3N0KCkge1xuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIGJlIHRoZSBvd25lciBvZiB0aGUgb3V0ZXJtb3N0IHRlbXBsYXRlLlxuICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gICAgLy8gYF9tZXRob2RIb3N0YCBhcyBsb25nIGFzIHRoZXJlIHdlcmUgYmluZGluZ3MgKG9yIGlkJ3MpIG9uIHRoaXNcbiAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgIHJldHVybiB0aGlzLl9fZGF0YUhvc3QuX21ldGhvZEhvc3QgfHwgdGhpcy5fX2RhdGFIb3N0O1xuICB9XG5cbiAgX19zb3J0Q2hhbmdlZChzb3J0KSB7XG4gICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgIHRoaXMuX19zb3J0Rm4gPSBzb3J0ICYmICh0eXBlb2Ygc29ydCA9PSAnZnVuY3Rpb24nID8gc29ydCA6XG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZEhvc3Rbc29ydF0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2ZpbHRlckNoYW5nZWQoZmlsdGVyKSB7XG4gICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgIHRoaXMuX19maWx0ZXJGbiA9IGZpbHRlciAmJiAodHlwZW9mIGZpbHRlciA9PSAnZnVuY3Rpb24nID8gZmlsdGVyIDpcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtmaWx0ZXJdLmFwcGx5KG1ldGhvZEhvc3QsIGFyZ3VtZW50cyk7IH0pO1xuICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgfVxuICB9XG5cbiAgX19jb21wdXRlRnJhbWVUaW1lKHJhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKDEwMDAvcmF0ZSk7XG4gIH1cblxuICBfX2luaXRpYWxpemVDaHVua2luZygpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsQ291bnQpIHtcbiAgICAgIHRoaXMuX19saW1pdCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSB0aGlzLmluaXRpYWxDb3VudDtcbiAgICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgX190cnlSZW5kZXJDaHVuaygpIHtcbiAgICAvLyBEZWJvdW5jZWQgc28gdGhhdCBtdWx0aXBsZSBjYWxscyB0aHJvdWdoIGBfcmVuZGVyYCBiZXR3ZWVuIGFuaW1hdGlvblxuICAgIC8vIGZyYW1lcyBvbmx5IHF1ZXVlIG9uZSBuZXcgckFGIChlLmcuIGFycmF5IG11dGF0aW9uICYgY2h1bmtlZCByZW5kZXIpXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5fX2xpbWl0IDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVxdWVzdFJlbmRlckNodW5rKTtcbiAgICB9XG4gIH1cblxuICBfX3JlcXVlc3RSZW5kZXJDaHVuaygpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuX19yZW5kZXJDaHVuaygpKTtcbiAgfVxuXG4gIF9fcmVuZGVyQ2h1bmsoKSB7XG4gICAgLy8gU2ltcGxlIGF1dG8gY2h1bmtTaXplIHRocm90dGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIGZlZWRiYWNrIGxvb3A6XG4gICAgLy8gbWVhc3VyZSBhY3R1YWwgdGltZSBiZXR3ZWVuIGZyYW1lcyBhbmQgc2NhbGUgY2h1bmsgY291bnQgYnkgcmF0aW9cbiAgICAvLyBvZiB0YXJnZXQvYWN0dWFsIGZyYW1lIHRpbWVcbiAgICBsZXQgY3VyckNodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGxldCByYXRpbyA9IHRoaXMuX3RhcmdldEZyYW1lVGltZSAvIChjdXJyQ2h1bmtUaW1lIC0gdGhpcy5fX2xhc3RDaHVua1RpbWUpO1xuICAgIHRoaXMuX19jaHVua0NvdW50ID0gTWF0aC5yb3VuZCh0aGlzLl9fY2h1bmtDb3VudCAqIHJhdGlvKSB8fCAxO1xuICAgIHRoaXMuX19saW1pdCArPSB0aGlzLl9fY2h1bmtDb3VudDtcbiAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IGN1cnJDaHVua1RpbWU7XG4gICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICB9XG5cbiAgX19vYnNlcnZlQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gdGhpcy5vYnNlcnZlICYmXG4gICAgICB0aGlzLm9ic2VydmUucmVwbGFjZSgnLionLCAnLicpLnNwbGl0KCcgJyk7XG4gIH1cblxuICBfX2l0ZW1zQ2hhbmdlZChjaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5pdGVtcyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLml0ZW1zKSkge1xuICAgICAgY29uc29sZS53YXJuKCdkb20tcmVwZWF0IGV4cGVjdGVkIGFycmF5IGZvciBgaXRlbXNgLCBmb3VuZCcsIHRoaXMuaXRlbXMpO1xuICAgIH1cbiAgICAvLyBJZiBwYXRoIHdhcyB0byBhbiBpdGVtIChlLmcuICdpdGVtcy4zJyBvciAnaXRlbXMuMy5mb28nKSwgZm9yd2FyZCB0aGVcbiAgICAvLyBwYXRoIHRvIHRoYXQgaW5zdGFuY2Ugc3luY2hyb25vdXNseSAocmV0dW5zIGZhbHNlIGZvciBub24taXRlbSBwYXRocylcbiAgICBpZiAoIXRoaXMuX19oYW5kbGVJdGVtUGF0aChjaGFuZ2UucGF0aCwgY2hhbmdlLnZhbHVlKSkge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYXJyYXkgd2FzIHJlc2V0ICgnaXRlbXMnKSBvciBzcGxpY2VkICgnaXRlbXMuc3BsaWNlcycpLFxuICAgICAgLy8gc28gcXVldWUgYSBmdWxsIHJlZnJlc2hcbiAgICAgIHRoaXMuX19pbml0aWFsaXplQ2h1bmtpbmcoKTtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2hhbmRsZU9ic2VydmVkUGF0aHMocGF0aCkge1xuICAgIGlmICh0aGlzLl9fb2JzZXJ2ZVBhdGhzKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgIGxldCBwYXRocyA9IHRoaXMuX19vYnNlcnZlUGF0aHM7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8cGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZihwYXRoc1tpXSkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlciwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOkRvbVJlcGVhdCl9IGZuIEZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IERlbGF5IGluIG1zIHRvIGRlYm91bmNlIGJ5LlxuICAgKi9cbiAgX19kZWJvdW5jZVJlbmRlcihmbiwgZGVsYXkgPSAwKSB7XG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICwgZGVsYXkgPiAwID8gdGltZU91dC5hZnRlcihkZWxheSkgOiBtaWNyb1Rhc2tcbiAgICAgICAgLCBmbi5iaW5kKHRoaXMpKTtcbiAgICBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgLy8gUXVldWUgdGhpcyByZXBlYXRlciwgdGhlbiBmbHVzaCBhbGwgaW4gb3JkZXJcbiAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgZmx1c2goKTtcbiAgfVxuXG4gIF9fcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5fX2Vuc3VyZVRlbXBsYXRpemVkKCkpIHtcbiAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fYXBwbHlGdWxsUmVmcmVzaCgpO1xuICAgIC8vIFJlc2V0IHRoZSBwb29sXG4gICAgLy8gVE9ETyhrc2NoYWFmKTogUmV1c2UgcG9vbCBhY3Jvc3MgdHVybnMgYW5kIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAvLyBOb3cgdGhhdCBvYmplY3RzL2FycmF5cyBhcmUgcmUtZXZhbHVhdGVkIHdoZW4gc2V0LCB3ZSBjYW4gc2FmZWx5XG4gICAgLy8gcmV1c2UgcG9vbGVkIGluc3RhbmNlcyBhY3Jvc3MgdHVybnMsIGhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBkZWNpZGVcbiAgICAvLyBzZW1hbnRpY3MgcmVnYXJkaW5nIGhvdyBsb25nIHRvIGhvbGQsIGhvdyBtYW55IHRvIGhvbGQsIGV0Yy5cbiAgICB0aGlzLl9fcG9vbC5sZW5ndGggPSAwO1xuICAgIC8vIFNldCByZW5kZXJlZCBpdGVtIGNvdW50XG4gICAgdGhpcy5fc2V0UmVuZGVyZWRJdGVtQ291bnQodGhpcy5fX2luc3RhbmNlcy5sZW5ndGgpO1xuICAgIC8vIE5vdGlmeSB1c2Vyc1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9KSk7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIG1vcmUgaXRlbXNcbiAgICB0aGlzLl9fdHJ5UmVuZGVyQ2h1bmsoKTtcbiAgfVxuXG4gIF9fYXBwbHlGdWxsUmVmcmVzaCgpIHtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zIHx8IFtdO1xuICAgIGxldCBpc250SWR4VG9JdGVtc0lkeCA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHhbaV0gPSBpO1xuICAgIH1cbiAgICAvLyBBcHBseSB1c2VyIGZpbHRlclxuICAgIGlmICh0aGlzLl9fZmlsdGVyRm4pIHtcbiAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4ID0gaXNudElkeFRvSXRlbXNJZHguZmlsdGVyKChpLCBpZHgsIGFycmF5KSA9PlxuICAgICAgICB0aGlzLl9fZmlsdGVyRm4oaXRlbXNbaV0sIGlkeCwgYXJyYXkpKTtcbiAgICB9XG4gICAgLy8gQXBwbHkgdXNlciBzb3J0XG4gICAgaWYgKHRoaXMuX19zb3J0Rm4pIHtcbiAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4LnNvcnQoKGEsIGIpID0+IHRoaXMuX19zb3J0Rm4oaXRlbXNbYV0sIGl0ZW1zW2JdKSk7XG4gICAgfVxuICAgIC8vIGl0ZW1zLT5pbnN0IG1hcCBrZXB0IGZvciBpdGVtIHBhdGggZm9yd2FyZGluZ1xuICAgIGNvbnN0IGl0ZW1zSWR4VG9JbnN0SWR4ID0gdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgbGV0IGluc3RJZHggPSAwO1xuICAgIC8vIEdlbmVyYXRlIGluc3RhbmNlcyBhbmQgYXNzaWduIGl0ZW1zXG4gICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbihpc250SWR4VG9JdGVtc0lkeC5sZW5ndGgsIHRoaXMuX19saW1pdCk7XG4gICAgZm9yICg7IGluc3RJZHg8bGltaXQ7IGluc3RJZHgrKykge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgbGV0IGl0ZW1JZHggPSBpc250SWR4VG9JdGVtc0lkeFtpbnN0SWR4XTtcbiAgICAgIGxldCBpdGVtID0gaXRlbXNbaXRlbUlkeF07XG4gICAgICBpdGVtc0lkeFRvSW5zdElkeFtpdGVtSWR4XSA9IGluc3RJZHg7XG4gICAgICBpZiAoaW5zdCAmJiBpbnN0SWR4IDwgdGhpcy5fX2xpbWl0KSB7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaW5kZXhBcywgaW5zdElkeCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2luc2VydEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGluc3RhbmNlcyBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgZm9yIChsZXQgaT10aGlzLl9faW5zdGFuY2VzLmxlbmd0aC0xOyBpPj1pbnN0SWR4OyBpLS0pIHtcbiAgICAgIHRoaXMuX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpKTtcbiAgICB9XG4gIH1cblxuICBfX2RldGFjaEluc3RhbmNlKGlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpZHhdO1xuICAgIGZvciAobGV0IGk9MDsgaTxpbnN0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZWwgPSBpbnN0LmNoaWxkcmVuW2ldO1xuICAgICAgaW5zdC5yb290LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICBfX2F0dGFjaEluc3RhbmNlKGlkeCwgcGFyZW50KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShpbnN0LnJvb3QsIHRoaXMpO1xuICB9XG5cbiAgX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpZHgpIHtcbiAgICBsZXQgaW5zdCA9IHRoaXMuX19kZXRhY2hJbnN0YW5jZShpZHgpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICB0aGlzLl9fcG9vbC5wdXNoKGluc3QpO1xuICAgIH1cbiAgICB0aGlzLl9faW5zdGFuY2VzLnNwbGljZShpZHgsIDEpO1xuICB9XG5cbiAgX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpIHtcbiAgICBsZXQgbW9kZWwgPSB7fTtcbiAgICBtb2RlbFt0aGlzLmFzXSA9IGl0ZW07XG4gICAgbW9kZWxbdGhpcy5pbmRleEFzXSA9IGluc3RJZHg7XG4gICAgbW9kZWxbdGhpcy5pdGVtc0luZGV4QXNdID0gaXRlbUlkeDtcbiAgICByZXR1cm4gbmV3IHRoaXMuX19jdG9yKG1vZGVsKTtcbiAgfVxuXG4gIF9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX3Bvb2wucG9wKCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIC8vIFRPRE8oa3NjaGFhZik6IElmIHRoZSBwb29sIGlzIHNoYXJlZCBhY3Jvc3MgdHVybnMsIGhvc3RQcm9wc1xuICAgICAgLy8gbmVlZCB0byBiZSByZS1zZXQgdG8gcmV1c2VkIGluc3RhbmNlcyBpbiBhZGRpdGlvbiB0byBpdGVtXG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5hcywgaXRlbSk7XG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdCA9IHRoaXMuX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlUm93ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4ICsgMV07XG4gICAgbGV0IGJlZm9yZU5vZGUgPSBiZWZvcmVSb3cgPyBiZWZvcmVSb3cuY2hpbGRyZW5bMF0gOiB0aGlzO1xuICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdC5yb290LCBiZWZvcmVOb2RlKTtcbiAgICB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdID0gaW5zdDtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIC8vIEltcGxlbWVudHMgZXh0ZW5zaW9uIHBvaW50IGZyb20gVGVtcGxhdGl6ZSBtaXhpblxuICBfc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pIHtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fX2luc3RhbmNlc1tpXS5fc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBhcyBhIHNpZGUgZWZmZWN0IG9mIGEgaG9zdCBpdGVtcy48a2V5Pi48cGF0aD4gcGF0aCBjaGFuZ2UsXG4gIC8vIHJlc3BvbnNpYmxlIGZvciBub3RpZnlpbmcgaXRlbS48cGF0aD4gY2hhbmdlcyB0byBpbnN0IGZvciBrZXlcbiAgX19oYW5kbGVJdGVtUGF0aChwYXRoLCB2YWx1ZSkge1xuICAgIGxldCBpdGVtc1BhdGggPSBwYXRoLnNsaWNlKDYpOyAvLyAnaXRlbXMuJy5sZW5ndGggPT0gNlxuICAgIGxldCBkb3QgPSBpdGVtc1BhdGguaW5kZXhPZignLicpO1xuICAgIGxldCBpdGVtc0lkeCA9IGRvdCA8IDAgPyBpdGVtc1BhdGggOiBpdGVtc1BhdGguc3Vic3RyaW5nKDAsIGRvdCk7XG4gICAgLy8gSWYgcGF0aCB3YXMgaW5kZXggaW50byBhcnJheS4uLlxuICAgIGlmIChpdGVtc0lkeCA9PSBwYXJzZUludChpdGVtc0lkeCwgMTApKSB7XG4gICAgICBsZXQgaXRlbVN1YlBhdGggPSBkb3QgPCAwID8gJycgOiBpdGVtc1BhdGguc3Vic3RyaW5nKGRvdCsxKTtcbiAgICAgIC8vIElmIHRoZSBwYXRoIGlzIG9ic2VydmVkLCBpdCB3aWxsIHRyaWdnZXIgYSBmdWxsIHJlZnJlc2hcbiAgICAgIHRoaXMuX19oYW5kbGVPYnNlcnZlZFBhdGhzKGl0ZW1TdWJQYXRoKTtcbiAgICAgIC8vIE5vdGUsIGV2ZW4gaWYgYSBydWxsIHJlZnJlc2ggaXMgdHJpZ2dlcmVkLCBhbHdheXMgZG8gdGhlIHBhdGhcbiAgICAgIC8vIG5vdGlmaWNhdGlvbiBiZWNhdXNlIHVubGVzcyBtdXRhYmxlRGF0YSBpcyB1c2VkIGZvciBkb20tcmVwZWF0XG4gICAgICAvLyBhbmQgYWxsIGVsZW1lbnRzIGluIHRoZSBpbnN0YW5jZSBzdWJ0cmVlLCBhIGZ1bGwgcmVmcmVzaCBtYXlcbiAgICAgIC8vIG5vdCB0cmlnZ2VyIHRoZSBwcm9wZXIgdXBkYXRlLlxuICAgICAgbGV0IGluc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHhbaXRlbXNJZHhdO1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgbGV0IGl0ZW1QYXRoID0gdGhpcy5hcyArIChpdGVtU3ViUGF0aCA/ICcuJyArIGl0ZW1TdWJQYXRoIDogJycpO1xuICAgICAgICAvLyBUaGlzIGlzIGVmZmVjdGl2ZWx5IGBub3RpZnlQYXRoYCwgYnV0IGF2b2lkcyBzb21lIG9mIHRoZSBvdmVyaGVhZFxuICAgICAgICAvLyBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoaXRlbVBhdGgsIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5XG4gICAqIHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgKlxuICAgKiBOb3RlLCB0byBtb2RpZnkgc3ViLXByb3BlcnRpZXMgb2YgdGhlIGl0ZW0sXG4gICAqIGBtb2RlbEZvckVsZW1lbnQoZWwpLnNldCgnaXRlbS48c3ViLXByb3A+JywgdmFsdWUpYFxuICAgKiBzaG91bGQgYmUgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpdGVtLlxuICAgKiBAcmV0dXJuIHsqfSBJdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGl0ZW1Gb3JFbGVtZW50KGVsKSB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmFzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnN0IGluZGV4IGZvciBhIGdpdmVuIGVsZW1lbnQgc3RhbXBlZCBieSB0aGlzIGBkb20tcmVwZWF0YC5cbiAgICogSWYgYHNvcnRgIGlzIHByb3ZpZGVkLCB0aGUgaW5kZXggd2lsbCByZWZsZWN0IHRoZSBzb3J0ZWQgb3JkZXIgKHJhdGhlclxuICAgKiB0aGFuIHRoZSBvcmlnaW5hbCBhcnJheSBvcmRlcikuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgaW5kZXguXG4gICAqIEByZXR1cm4geyp9IFJvdyBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQgKG5vdGUgdGhpcyBtYXlcbiAgICogICBub3QgY29ycmVzcG9uZCB0byB0aGUgYXJyYXkgaW5kZXggaWYgYSB1c2VyIGBzb3J0YCBpcyBhcHBsaWVkKS5cbiAgICovXG4gIGluZGV4Rm9yRWxlbWVudChlbCkge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMubW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2VbdGhpcy5pbmRleEFzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICogc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXNcbiAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkJhc2VgLCBhbmRcbiAgICogc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgIGxldCBtb2RlbCA9IG1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IE1vZGVsIHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICogICB0aGUgZWxlbWVudC5cbiAgICovXG4gIG1vZGVsRm9yRWxlbWVudChlbCkge1xuICAgIHJldHVybiBUZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLnRlbXBsYXRlLCBlbCk7XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tUmVwZWF0LmlzLCBEb21SZXBlYXQpO1xuXG5leHBvcnQgeyBEb21SZXBlYXQgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyc7XG5pbXBvcnQgeyBJcm9uQnV0dG9uU3RhdGVJbXBsIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVyUmlwcGxlQmVoYXZpb3IgPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgZWxlbWVudCB3aWxsIG5vdCBwcm9kdWNlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIGludGVyYWN0ZWRcbiAgICAgKiB3aXRoIHZpYSB0aGUgcG9pbnRlci5cbiAgICAgKi9cbiAgICBub2luazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIG9ic2VydmVyOiAnX25vaW5rQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIF9yaXBwbGVDb250YWluZXI6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgYSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQgaXMgYXZhaWxhYmxlIHdoZW4gdGhlIGVsZW1lbnQgaXNcbiAgICogZm9jdXNlZC5cbiAgICovXG4gIF9idXR0b25TdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBpbiBgSXJvbkJ1dHRvblN0YXRlYCwgZW5zdXJlc1xuICAgKiBhIHJpcHBsZSBlZmZlY3QgaXMgY3JlYXRlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGluIGEgYHByZXNzZWRgIHN0YXRlLlxuICAgKi9cbiAgX2Rvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIElyb25CdXR0b25TdGF0ZUltcGwuX2Rvd25IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhpcyBlbGVtZW50IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC4gRm9yIHN0YXJ0dXAgZWZmaWNpZW5jeVxuICAgKiB0aGUgcmlwcGxlIGVmZmVjdCBpcyBkeW5hbWljYWxseSBvbiBkZW1hbmQgd2hlbiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7IUV2ZW50PX0gb3B0VHJpZ2dlcmluZ0V2ZW50IChvcHRpb25hbCkgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gICAqIHJpcHBsZS5cbiAgICovXG4gIGVuc3VyZVJpcHBsZTogZnVuY3Rpb24ob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUgPSB0aGlzLl9jcmVhdGVSaXBwbGUoKTtcbiAgICAgIHRoaXMuX3JpcHBsZS5ub2luayA9IHRoaXMubm9pbms7XG4gICAgICB2YXIgcmlwcGxlQ29udGFpbmVyID0gdGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMucm9vdDtcbiAgICAgIGlmIChyaXBwbGVDb250YWluZXIpIHtcbiAgICAgICAgZG9tKHJpcHBsZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy5fcmlwcGxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRUcmlnZ2VyaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgcmlwcGxlIGNvbnRhaW5lclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gaG9zdCBpbnN0ZWFkIG9mIHRoZSByb290IGJlY2F1c2UgZGlzdHJpYnV0ZWQgdGV4dFxuICAgICAgICAvLyBub2RlcyBhcmUgbm90IHZhbGlkIGV2ZW50IHRhcmdldHNcbiAgICAgICAgdmFyIGRvbUNvbnRhaW5lciA9IGRvbSh0aGlzLl9yaXBwbGVDb250YWluZXIgfHwgdGhpcyk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBkb20ob3B0VHJpZ2dlcmluZ0V2ZW50KS5yb290VGFyZ2V0O1xuICAgICAgICBpZiAoZG9tQ29udGFpbmVyLmRlZXBDb250YWlucyggLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSkge1xuICAgICAgICAgIHRoaXMuX3JpcHBsZS51aURvd25BY3Rpb24ob3B0VHJpZ2dlcmluZ0V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50IHVzZWQgYnkgdGhpcyBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiByaXBwbGUgZWZmZWN0cy4gVGhlIGVsZW1lbnQncyByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQsIHdoZW5cbiAgICogbmVjZXNzYXJ5LCBhbmQgY2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIGZvcmNlIHRoZVxuICAgKiByaXBwbGUgdG8gYmUgY3JlYXRlZC5cbiAgICovXG4gIGdldFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcmlwcGxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBlbGVtZW50IGN1cnJlbnRseSBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX3JpcHBsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZWxlbWVudCdzIHJpcHBsZSBlZmZlY3QgdmlhIGNyZWF0aW5nIGEgYDxwYXBlci1yaXBwbGU+YC5cbiAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY3VzdG9taXplIHRoZSByaXBwbGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7IVBhcGVyUmlwcGxlRWxlbWVudH0gUmV0dXJucyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudC5cbiAgICovXG4gIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFQYXBlclJpcHBsZUVsZW1lbnR9ICovIChcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGFwZXItcmlwcGxlJykpO1xuICB9LFxuXG4gIF9ub2lua0NoYW5nZWQ6IGZ1bmN0aW9uKG5vaW5rKSB7XG4gICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIHRoaXMuX3JpcHBsZS5ub2luayA9IG5vaW5rO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyIsIlxyXG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExheWVyR3JvdXBcclxuICogQGFrYSBMLkxheWVyR3JvdXBcclxuICogQGluaGVyaXRzIExheWVyXHJcbiAqXHJcbiAqIFVzZWQgdG8gZ3JvdXAgc2V2ZXJhbCBsYXllcnMgYW5kIGhhbmRsZSB0aGVtIGFzIG9uZS4gSWYgeW91IGFkZCBpdCB0byB0aGUgbWFwLFxyXG4gKiBhbnkgbGF5ZXJzIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIG9uIHRoZSBtYXAgYXNcclxuICogd2VsbC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmxheWVyR3JvdXAoW21hcmtlcjEsIG1hcmtlcjJdKVxyXG4gKiBcdC5hZGRMYXllcihwb2x5bGluZSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllckdyb3VwID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcblx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG5cdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWFwLmFkZExheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXJzLnB1c2godGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5leHBvcnQgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXJHcm91cC5qcyIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG5cdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcblx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcclxuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcgYXMgbGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyRHJhZ30gZnJvbSAnLi9NYXJrZXIuRHJhZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFya2VyXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuTWFya2VyXHJcbiAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuXHRcdC8vIEljb24gaW5zdGFuY2UgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci5cclxuXHRcdC8vIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuXHRcdGljb246IG5ldyBJY29uRGVmYXVsdCgpLFxyXG5cclxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgY2FuIGJlIHRhYmJlZCB0byB3aXRoIGEga2V5Ym9hcmQgYW5kIGNsaWNrZWQgYnkgcHJlc3NpbmcgZW50ZXIuXHJcblx0XHRrZXlib2FyZDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRpdGxlOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGJyb3dzZXIgdG9vbHRpcCB0aGF0IGFwcGVhciBvbiBtYXJrZXIgaG92ZXIgKG5vIHRvb2x0aXAgYnkgZGVmYXVsdCkuXHJcblx0XHR0aXRsZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpY29uIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG5cdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxyXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogZmFsc2VcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqXHJcblx0ICogSW4gYWRkaXRpb24gdG8gW3NoYXJlZCBsYXllciBtZXRob2RzXSgjTGF5ZXIpIGxpa2UgYGFkZFRvKClgIGFuZCBgcmVtb3ZlKClgIGFuZCBbcG9wdXAgbWV0aG9kc10oI1BvcHVwKSBsaWtlIGJpbmRQb3B1cCgpIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5fem9vbUFuaW1hdGVkICYmIG1hcC5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZy5yZW1vdmVIb29rcygpO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMuZHJhZ2dpbmc7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHpvb206IHRoaXMudXBkYXRlLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMudXBkYXRlXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldExhdExuZyhsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvaW50LlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBpcyBtb3ZlZCB2aWEgW2BzZXRMYXRMbmdgXSgjbWFya2VyLXNldGxhdGxuZykgb3IgYnkgW2RyYWdnaW5nXSgjbWFya2VyLWRyYWdnaW5nKS4gT2xkIGFuZCBuZXcgY29vcmRpbmF0ZXMgYXJlIGluY2x1ZGVkIGluIGV2ZW50IGFyZ3VtZW50cyBhcyBgb2xkTGF0TG5nYCwgYGxhdGxuZ2AuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4T2Zmc2V0KG9mZnNldDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXggb2Zmc2V0XSgjbWFya2VyLXppbmRleG9mZnNldCkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY2xhc3NUb0FkZCA9ICdsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcclxuXHJcblx0XHR2YXIgaWNvbiA9IG9wdGlvbnMuaWNvbi5jcmVhdGVJY29uKHRoaXMuX2ljb24pLFxyXG5cdFx0ICAgIGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbHQpIHtcclxuXHRcdFx0XHRpY29uLmFsdCA9IG9wdGlvbnMuYWx0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MobmV3U2hhZG93LCBjbGFzc1RvQWRkKTtcclxuXHRcdFx0bmV3U2hhZG93LmFsdCA9ICcnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoJ3NoYWRvd1BhbmUnKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faWNvbik7XHJcblx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9zaGFkb3csIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fekluZGV4ID0gcG9zLnkgKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuX3Jlc2V0WkluZGV4KCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5faWNvbi5zdHlsZS56SW5kZXggPSB0aGlzLl96SW5kZXggKyBvZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAob3B0KSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBvcHQuem9vbSwgb3B0LmNlbnRlcikucm91bmQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEludGVyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pY29uLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cclxuXHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0aWYgKE1hcmtlckRyYWcpIHtcclxuXHRcdFx0dmFyIGRyYWdnYWJsZSA9IHRoaXMub3B0aW9ucy5kcmFnZ2FibGU7XHJcblx0XHRcdGlmICh0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdFx0ZHJhZ2dhYmxlID0gdGhpcy5kcmFnZ2luZy5lbmFibGVkKCk7XHJcblx0XHRcdFx0dGhpcy5kcmFnZ2luZy5kaXNhYmxlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9pY29uLCBvcGFjaXR5KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCh0aGlzLm9wdGlvbnMucmlzZU9mZnNldCk7XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0WkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoMCk7XHJcblx0fSxcclxuXHJcblx0X2dldFBvcHVwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5wb3B1cEFuY2hvciB8fCBbMCwgMF07XHJcblx0fSxcclxuXHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3IgfHwgWzAsIDBdO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvTWFya2VyLmpzIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG52YXIgRU5EID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG59O1xyXG52YXIgTU9WRSA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKERvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIEVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG5ld1BvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ld1BvaW50LnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKCh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSAmJiAodGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSkpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0fSxcclxuXHJcblx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBNT1ZFKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgTU9WRVtpXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBFTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcblxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRHJhZ2dhYmxlLmpzIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gJycuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSBvdmVybGF5IGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIG92ZXJsYXkgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yT3ZlcmxheVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuXHRcdC8vIFRoZSBleHBsaWNpdCBbekluZGV4XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleCkgb2YgdGhlIHRpbGUgbGF5ZXIuXHJcblx0XHR6SW5kZXg6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgaW1hZ2UuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Q6IHNldFpJbmRleCh2YWx1ZTogTnVtYmVyKSA6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IERvbVV0aWwuY3JlYXRlKCdpbWcnLFxyXG5cdFx0XHRcdCdsZWFmbGV0LWltYWdlLWxheWVyICcgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcgOiAnJykgK1xyXG5cdFx0XHRcdCAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0aW1nLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcblx0XHRpbWcub25sb2FkID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHRcdGltZy5vbmVycm9yID0gVXRpbC5iaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbmV4cG9ydCB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbmV4cG9ydCB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuXHRcdC8vIG9mIHRoZSBwb3B1cCB3aGVuIG9wZW5pbmcgaXQgb24gc29tZSBvdmVybGF5cy5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoRG9tVXRpbC5yZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgcG9wdXAuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgcG9wdXAuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gQWxpYXMgZm9yIFtnZXRDb250ZW50KCldKCNwb3B1cC1nZXRjb250ZW50KVxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIGluIGZyb250IG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0Rpdk92ZXJsYXkuanMiLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2Jhcid9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcGlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0LypcclxuXHRcdCBTZXQgcm9sZT1cInByZXNlbnRhdGlvblwiIHRvIGZvcmNlIHNjcmVlbiByZWFkZXJzIHRvIGlnbm9yZSB0aGlzXHJcblx0XHQgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhL3JvbGVzI3RleHRhbHRlcm5hdGl2ZWNvbXB1dGF0aW9uXHJcblx0XHQqL1xyXG5cdFx0dGlsZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEJyb3dzZXIucmV0aW5hID8gJ0AyeCcgOiAnJyxcclxuXHRcdFx0czogdGhpcy5fZ2V0U3ViZG9tYWluKGNvb3JkcyksXHJcblx0XHRcdHg6IGNvb3Jkcy54LFxyXG5cdFx0XHR5OiBjb29yZHMueSxcclxuXHRcdFx0ejogdGhpcy5fZ2V0Wm9vbUZvclVybCgpXHJcblx0XHR9O1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5fbWFwLm9wdGlvbnMuY3JzLmluZmluaXRlKSB7XHJcblx0XHRcdHZhciBpbnZlcnRlZFkgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2UubWF4LnkgLSBjb29yZHMueTtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy50bXMpIHtcclxuXHRcdFx0XHRkYXRhWyd5J10gPSBpbnZlcnRlZFk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVsnLXknXSA9IGludmVydGVkWTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIFV0aWwuZXh0ZW5kKGRhdGEsIHRoaXMub3B0aW9ucykpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSkge1xyXG5cdFx0Ly8gRm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzMzMzJcclxuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCAmJiB0aWxlLnNyYyAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGlsZS5zcmMgPSBlcnJvclVybDtcclxuXHRcdH1cclxuXHRcdGRvbmUoZSwgdGlsZSk7XHJcblx0fSxcclxuXHJcblx0X29uVGlsZVJlbW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUudGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tRm9yVXJsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxyXG5cdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tLFxyXG5cdFx0em9vbVJldmVyc2UgPSB0aGlzLm9wdGlvbnMuem9vbVJldmVyc2UsXHJcblx0XHR6b29tT2Zmc2V0ID0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0aWYgKHpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBtYXhab29tIC0gem9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gem9vbSArIHpvb21PZmZzZXQ7XHJcblx0fSxcclxuXHJcblx0X2dldFN1YmRvbWFpbjogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5hYnModGlsZVBvaW50LnggKyB0aWxlUG9pbnQueSkgJSB0aGlzLm9wdGlvbnMuc3ViZG9tYWlucy5sZW5ndGg7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnNbaW5kZXhdO1xyXG5cdH0sXHJcblxyXG5cdC8vIHN0b3BzIGxvYWRpbmcgYWxsIHRpbGVzIGluIHRoZSBiYWNrZ3JvdW5kIGxheWVyXHJcblx0X2Fib3J0TG9hZGluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIHRpbGU7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2ldLmNvb3Jkcy56ICE9PSB0aGlzLl90aWxlWm9vbSkge1xyXG5cdFx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1tpXS5lbDtcclxuXHJcblx0XHRcdFx0dGlsZS5vbmxvYWQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpbGUuY29tcGxldGUpIHtcclxuXHRcdFx0XHRcdHRpbGUuc3JjID0gVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL1RpbGVMYXllci5qcyIsImltcG9ydCB7VGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XHJcbmltcG9ydCB7ZXh0ZW5kLCBzZXRPcHRpb25zLCBnZXRQYXJhbVN0cmluZ30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtyZXRpbmF9IGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7RVBTRzQzMjZ9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVQU0c0MzI2JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXIuV01TXHJcbiAqIEBpbmhlcml0cyBUaWxlTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllci5XTVNcclxuICogVXNlZCB0byBkaXNwbGF5IFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMgYXMgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgVGlsZUxheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG5leHJhZCA9IEwudGlsZUxheWVyLndtcyhcImh0dHA6Ly9tZXNvbmV0LmFncm9uLmlhc3RhdGUuZWR1L2NnaS1iaW4vd21zL25leHJhZC9uMHIuY2dpXCIsIHtcclxuICogXHRsYXllcnM6ICduZXhyYWQtbjByLTkwMDkxMycsXHJcbiAqIFx0Zm9ybWF0OiAnaW1hZ2UvcG5nJyxcclxuICogXHR0cmFuc3BhcmVudDogdHJ1ZSxcclxuICogXHRhdHRyaWJ1dGlvbjogXCJXZWF0aGVyIGRhdGEgwqkgMjAxMiBJRU0gTmV4cmFkXCJcclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVGlsZUxheWVyV01TID0gVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBUaWxlTGF5ZXIuV01TIG9wdGlvbnNcclxuXHQvLyBJZiBhbnkgY3VzdG9tIG9wdGlvbnMgbm90IGRvY3VtZW50ZWQgaGVyZSBhcmUgdXNlZCwgdGhleSB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcblx0Ly8gV01TIHNlcnZlciBhcyBleHRyYSBwYXJhbWV0ZXJzIGluIGVhY2ggcmVxdWVzdCBVUkwuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcclxuXHQvLyBbbm9uLXN0YW5kYXJkIHZlbmRvciBXTVMgcGFyYW1ldGVyc10oaHR0cDovL2RvY3MuZ2Vvc2VydmVyLm9yZy9zdGFibGUvZW4vdXNlci9zZXJ2aWNlcy93bXMvdmVuZG9yLmh0bWwpLlxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyAqKihyZXF1aXJlZCkqKiBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgbGF5ZXJzIHRvIHNob3cuXHJcblx0XHRsYXllcnM6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3R5bGVzOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgV01TIHN0eWxlcy5cclxuXHRcdHN0eWxlczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBmb3JtYXQ6IFN0cmluZyA9ICdpbWFnZS9qcGVnJ1xyXG5cdFx0Ly8gV01TIGltYWdlIGZvcm1hdCAodXNlIGAnaW1hZ2UvcG5nJ2AgZm9yIGxheWVycyB3aXRoIHRyYW5zcGFyZW5jeSkuXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zcGFyZW50OiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIFdNUyBzZXJ2aWNlIHdpbGwgcmV0dXJuIGltYWdlcyB3aXRoIHRyYW5zcGFyZW5jeS5cclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHZlcnNpb246IFN0cmluZyA9ICcxLjEuMSdcclxuXHRcdC8vIFZlcnNpb24gb2YgdGhlIFdNUyBzZXJ2aWNlIHRvIHVzZVxyXG5cdFx0dmVyc2lvbjogJzEuMS4xJ1xyXG5cdH0sXHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY3JzOiBDUlMgPSBudWxsXHJcblx0XHQvLyBDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW0gdG8gdXNlIGZvciB0aGUgV01TIHJlcXVlc3RzLCBkZWZhdWx0cyB0b1xyXG5cdFx0Ly8gbWFwIENSUy4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB1cHBlcmNhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBXTVMgcmVxdWVzdCBwYXJhbWV0ZXIga2V5cyB3aWxsIGJlIHVwcGVyY2FzZS5cclxuXHRcdHVwcGVyY2FzZTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciB3bXNQYXJhbXMgPSBleHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyk7XHJcblxyXG5cdFx0Ly8gYWxsIGtleXMgdGhhdCBhcmUgbm90IFRpbGVMYXllciBvcHRpb25zIGdvIHRvIFdNUyBwYXJhbXNcclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHRpZiAoIShpIGluIHRoaXMub3B0aW9ucykpIHtcclxuXHRcdFx0XHR3bXNQYXJhbXNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gd21zUGFyYW1zLmhlaWdodCA9IG9wdGlvbnMudGlsZVNpemUgKiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgcmV0aW5hID8gMiA6IDEpO1xyXG5cclxuXHRcdHRoaXMud21zUGFyYW1zID0gd21zUGFyYW1zO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblxyXG5cdFx0dGhpcy5fY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XHJcblx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG5cdFx0VGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3JkcyksXHJcblx0XHQgICAgbncgPSB0aGlzLl9jcnMucHJvamVjdCh0aWxlQm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2Nycy5wcm9qZWN0KHRpbGVCb3VuZHMuZ2V0U291dGhFYXN0KCkpLFxyXG5cclxuXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gRVBTRzQzMjYgP1xyXG5cdFx0XHQgICAgW3NlLnksIG53LngsIG53LnksIHNlLnhdIDpcclxuXHRcdFx0ICAgIFtudy54LCBzZS55LCBzZS54LCBudy55XSkuam9pbignLCcpLFxyXG5cclxuXHRcdCAgICB1cmwgPSBUaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzQzMjYgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanMiLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAc2VjdGlvblxyXG4gKiBMZWFmbGV0IGNvbWVzIHdpdGggYSBzZXQgb2YgYWxyZWFkeSBkZWZpbmVkIFByb2plY3Rpb25zIG91dCBvZiB0aGUgYm94OlxyXG4gKlxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTG9uTGF0XHJcbiAqXHJcbiAqIEVxdWlyZWN0YW5ndWxhciwgb3IgUGxhdGUgQ2FycmVlIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IHNpbXBsZSBwcm9qZWN0aW9uLFxyXG4gKiBtb3N0bHkgdXNlZCBieSBHSVMgZW50aHVzaWFzdHMuIERpcmVjdGx5IG1hcHMgYHhgIGFzIGxvbmdpdHVkZSwgYW5kIGB5YCBhc1xyXG4gKiBsYXRpdHVkZS4gQWxzbyBzdWl0YWJsZSBmb3IgZmxhdCB3b3JsZHMsIGUuZy4gZ2FtZSBtYXBzLiBVc2VkIGJ5IHRoZVxyXG4gKiBgRVBTRzo0MzI2YCBhbmQgYFNpbXBsZWAgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZywgbGF0bG5nLmxhdCk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBvaW50LnksIHBvaW50LngpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTE4MCwgLTkwXSwgWzE4MCwgOTBdKVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTG9uTGF0LmpzIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFs0NS41MSwgLTEyMi42OF0sXG4gKiBcdFszNy43NywgLTEyMi40M10sXG4gKiBcdFszNC4wNCwgLTExOC4yXVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1s0NS41MSwgLTEyMi42OF0sXG4gKiBcdCBbMzcuNzcsIC0xMjIuNDNdLFxuICogXHQgWzM0LjA0LCAtMTE4LjJdXSxcbiAqIFx0W1s0MC43OCwgLTczLjkxXSxcbiAqIFx0IFs0MS44MywgLTg3LjYyXSxcbiAqIFx0IFszMi43NiwgLTk2LjcyXV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUG9seWxpbmUgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50LFxuXHRcdCAgICBwMSwgcDI7XG5cblx0XHRmb3IgKHZhciBqID0gMCwgakxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuX3BhcnRzW2pdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHAxID0gcG9pbnRzW2kgLSAxXTtcblx0XHRcdFx0cDIgPSBwb2ludHNbaV07XG5cblx0XHRcdFx0dmFyIHNxRGlzdCA9IGNsb3Nlc3QocCwgcDEsIHAyLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoc3FEaXN0IDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IHNxRGlzdDtcblx0XHRcdFx0XHRtaW5Qb2ludCA9IGNsb3Nlc3QocCwgcDEsIHAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWluUG9pbnQpIHtcblx0XHRcdG1pblBvaW50LmRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblBvaW50O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwb2x5bGluZS5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBoYWxmRGlzdCwgc2VnRGlzdCwgZGlzdCwgcDEsIHAyLCByYXRpbyxcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWxpbmUgY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcblx0XHR9XG5cblx0XHQvLyBUaGUgbGluZSBpcyBzbyBzbWFsbCBpbiB0aGUgY3VycmVudCB2aWV3IHRoYXQgYWxsIHBvaW50cyBhcmUgb24gdGhlIHNhbWUgcGl4ZWwuXG5cdFx0aWYgKGhhbGZEaXN0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb2ludHNbMF0pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcblx0XHRcdHNlZ0Rpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHRcdGRpc3QgKz0gc2VnRGlzdDtcblxuXHRcdFx0aWYgKGRpc3QgPiBoYWxmRGlzdCkge1xuXHRcdFx0XHRyYXRpbyA9IChkaXN0IC0gaGFsZkRpc3QpIC8gc2VnRGlzdDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoW1xuXHRcdFx0XHRcdHAyLnggLSByYXRpbyAqIChwMi54IC0gcDEueCksXG5cdFx0XHRcdFx0cDIueSAtIHJhdGlvICogKHAyLnkgLSBwMS55KVxuXHRcdFx0XHRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYWRkTGF0TG5nKGxhdGxuZzogTGF0TG5nLCBsYXRsbmdzPyBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0dmFyIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHRweEJvdW5kcy5taW4uX3N1YnRyYWN0KHApO1xuXHRcdFx0cHhCb3VuZHMubWF4Ll9hZGQocCk7XG5cdFx0XHR0aGlzLl9weEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdH1cblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IExpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAoTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBMaW5lVXRpbC5fZmxhdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlsaW5lLmpzIiwiaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCAqIGFzIFBvbHlVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvbHlVdGlsJztcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiBdO1xuICogYGBgXG4gKlxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBNdWx0aVBvbHlnb24gc2hhcGUuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbIC8vIGZpcnN0IHBvbHlnb25cbiAqICAgICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogICBdLFxuICogICBbIC8vIHNlY29uZCBwb2x5Z29uXG4gKiAgICAgW1s0MSwgLTExMS4wM10sWzQ1LCAtMTExLjA0XSxbNDUsIC0xMDQuMDVdLFs0MSwgLTEwNC4wNV1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFBvbHlnb24gPSBQb2x5bGluZS5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGggfHwgIXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RoO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXIsXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlnb24gY2VudHJvaWQgYWxnb3JpdGhtOyBvbmx5IHVzZXMgdGhlIGZpcnN0IHJpbmcgaWYgdGhlcmUgYXJlIG11bHRpcGxlXG5cblx0XHRhcmVhID0geCA9IHkgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbal07XG5cblx0XHRcdGYgPSBwMS55ICogcDIueCAtIHAyLnkgKiBwMS54O1xuXHRcdFx0eCArPSAocDEueCArIHAyLngpICogZjtcblx0XHRcdHkgKz0gKHAxLnkgKyBwMi55KSAqIGY7XG5cdFx0XHRhcmVhICs9IGYgKiAzO1xuXHRcdH1cblxuXHRcdGlmIChhcmVhID09PSAwKSB7XG5cdFx0XHQvLyBQb2x5Z29uIGlzIHNvIHNtYWxsIHRoYXQgYWxsIHBvaW50cyBhcmUgb24gc2FtZSBwaXhlbC5cblx0XHRcdGNlbnRlciA9IHBvaW50c1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2VudGVyID0gW3ggLyBhcmVhLCB5IC8gYXJlYV07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGNlbnRlcik7XG5cdH0sXG5cblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnZlcnRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyksXG5cdFx0ICAgIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHQvLyByZW1vdmUgbGFzdCBwb2ludCBpZiBpdCBlcXVhbHMgZmlyc3Qgb25lXG5cdFx0aWYgKGxlbiA+PSAyICYmIHJlc3VsdFswXSBpbnN0YW5jZW9mIExhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRQb2x5bGluZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcblx0XHRpZiAoTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKSA/IHRoaXMuX2xhdGxuZ3NbMF0gOiB0aGlzLl9sYXRsbmdzWzBdWzBdO1xuXHR9LFxuXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gcG9seWdvbnMgbmVlZCBhIGRpZmZlcmVudCBjbGlwcGluZyBhbGdvcml0aG0gc28gd2UgcmVkZWZpbmUgdGhhdFxuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHMsXG5cdFx0ICAgIHcgPSB0aGlzLm9wdGlvbnMud2VpZ2h0LFxuXHRcdCAgICBwID0gbmV3IFBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBCb3VuZHMoYm91bmRzLm1pbi5zdWJ0cmFjdChwKSwgYm91bmRzLm1heC5hZGQocCkpO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoLCBjbGlwcGVkOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNsaXBwZWQgPSBQb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9yaW5nc1tpXSwgYm91bmRzLCB0cnVlKTtcblx0XHRcdGlmIChjbGlwcGVkLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9wYXJ0cy5wdXNoKGNsaXBwZWQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMsIHRydWUpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxuXHRcdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvUG9seWdvbi5qcyIsImltcG9ydCB7IHJlc29sdmVDc3MgfSBmcm9tICcuL3Jlc29sdmUtdXJsLmpzJztcblxuY29uc3QgTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IgPSAnbGlua1tyZWw9aW1wb3J0XVt0eXBlfj1jc3NdJztcbmNvbnN0IElOQ0xVREVfQVRUUiA9ICdpbmNsdWRlJztcblxuZnVuY3Rpb24gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKSB7XG4gIGNvbnN0IC8qKiBQb2x5bWVyLkRvbU1vZHVsZSAqLyBQb2x5bWVyRG9tTW9kdWxlID0gY3VzdG9tRWxlbWVudHMuZ2V0KCdkb20tbW9kdWxlJyk7XG4gIGlmICghUG9seW1lckRvbU1vZHVsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBQb2x5bWVyRG9tTW9kdWxlLmltcG9ydChtb2R1bGVJZCk7XG59XG5cbi8qKiBAdHlwZWRlZiB7e2Fzc2V0cGF0aDogc3RyaW5nfX0gKi9cbmxldCB0ZW1wbGF0ZVdpdGhBc3NldFBhdGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21Nb2R1bGVzKG1vZHVsZUlkcykge1xuICBsZXQgbW9kdWxlcyA9IG1vZHVsZUlkcy50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgZm9yIChsZXQgaT0wOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNzc1RleHQgKz0gY3NzRnJvbU1vZHVsZShtb2R1bGVzW2ldKTtcbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21Nb2R1bGUobW9kdWxlSWQpIHtcbiAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICBpZiAobSAmJiBtLl9jc3NUZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBtb2R1bGUgaW1wb3J0czogPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPlxuICAgIGxldCBjc3NUZXh0ID0gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG0pO1xuICAgIC8vIGluY2x1ZGUgY3NzIGZyb20gdGhlIGZpcnN0IHRlbXBsYXRlIGluIHRoZSBtb2R1bGVcbiAgICBsZXQgdCA9IG0ucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICBpZiAodCkge1xuICAgICAgY3NzVGV4dCArPSBjc3NGcm9tVGVtcGxhdGUodCwgLyoqIEB0eXBlIHt0ZW1wbGF0ZVdpdGhBc3NldFBhdGh9ICovKG0pLmFzc2V0cGF0aCk7XG4gICAgfVxuICAgIG0uX2Nzc1RleHQgPSBjc3NUZXh0IHx8IG51bGw7XG4gIH1cbiAgaWYgKCFtKSB7XG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBzdHlsZSBkYXRhIGluIG1vZHVsZSBuYW1lZCcsIG1vZHVsZUlkKTtcbiAgfVxuICByZXR1cm4gbSAmJiBtLl9jc3NUZXh0IHx8ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKSB7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIC8vIGlmIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSwgZ2V0IGNvbnRlbnQgZnJvbSBpdHMgLmNvbnRlbnRcbiAgbGV0IGUkID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpO1xuICBmb3IgKGxldCBpPTA7IGkgPCBlJC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBlID0gZSRbaV07XG4gICAgLy8gc3VwcG9ydCBzdHlsZSBzaGFyaW5nIGJ5IGFsbG93aW5nIHN0eWxlcyB0byBcImluY2x1ZGVcIlxuICAgIC8vIG90aGVyIGRvbS1tb2R1bGVzIHRoYXQgY29udGFpbiBzdHlsaW5nXG4gICAgbGV0IGluY2x1ZGUgPSBlLmdldEF0dHJpYnV0ZShJTkNMVURFX0FUVFIpO1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBjc3NUZXh0ICs9IGNzc0Zyb21Nb2R1bGVzKGluY2x1ZGUpO1xuICAgIH1cbiAgICBlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSk7XG4gICAgY3NzVGV4dCArPSBiYXNlVVJJID9cbiAgICAgIHJlc29sdmVDc3MoZS50ZXh0Q29udGVudCwgYmFzZVVSSSkgOiBlLnRleHRDb250ZW50O1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpIHtcbiAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICByZXR1cm4gbSA/IF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtKSA6ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG1vZHVsZSkge1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBsZXQgcCQgPSBtb2R1bGUucXVlcnlTZWxlY3RvckFsbChNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUik7XG4gIGZvciAobGV0IGk9MDsgaSA8IHAkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHAgPSBwJFtpXTtcbiAgICBpZiAocC5pbXBvcnQpIHtcbiAgICAgIGxldCBpbXBvcnREb2MgPSBwLmltcG9ydDtcbiAgICAgIC8vIE5PVEU6IHBvbHlmaWxsIGFmZm9yZGFuY2UuXG4gICAgICAvLyB1bmRlciB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwsIHRoZXJlIHdpbGwgYmUgbm8gJ2JvZHknLFxuICAgICAgLy8gYnV0IHRoZSBpbXBvcnQgcHNldWRvLWRvYyBjYW4gYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgIGxldCBjb250YWluZXIgPSBpbXBvcnREb2MuYm9keSA/IGltcG9ydERvYy5ib2R5IDogaW1wb3J0RG9jO1xuICAgICAgY3NzVGV4dCArPVxuICAgICAgICByZXNvbHZlQ3NzKGNvbnRhaW5lci50ZXh0Q29udGVudCxcbiAgICAgICAgICBpbXBvcnREb2MuYmFzZVVSSSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVVybCwgcGF0aEZyb21VcmwgfSBmcm9tICcuLi91dGlscy9yZXNvbHZlLXVybC5qcyc7XG5cbmxldCBtb2R1bGVzID0ge307XG5sZXQgbGNNb2R1bGVzID0ge307XG5mdW5jdGlvbiBmaW5kTW9kdWxlKGlkKSB7XG4gIHJldHVybiBtb2R1bGVzW2lkXSB8fCBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2soaW5zdCkge1xuICBpZiAoaW5zdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKSB7XG4gICAgY29uc29sZS53YXJuKCdkb20tbW9kdWxlICVzIGhhcyBzdHlsZSBvdXRzaWRlIHRlbXBsYXRlJywgaW5zdC5pZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYGRvbS1tb2R1bGVgIGVsZW1lbnQgcmVnaXN0ZXJzIHRoZSBkb20gaXQgY29udGFpbnMgdG8gdGhlIG5hbWUgZ2l2ZW5cbiAqIGJ5IHRoZSBtb2R1bGUncyBpZCBhdHRyaWJ1dGUuIEl0IHByb3ZpZGVzIGEgdW5pZmllZCBkYXRhYmFzZSBvZiBkb21cbiAqIGFjY2Vzc2libGUgdmlhIGl0cyBzdGF0aWMgYGltcG9ydGAgQVBJLlxuICpcbiAqIEEga2V5IHVzZSBjYXNlIG9mIGBkb20tbW9kdWxlYCBpcyBmb3IgcHJvdmlkaW5nIGN1c3RvbSBlbGVtZW50IGA8dGVtcGxhdGU+YHNcbiAqIHZpYSBIVE1MIGltcG9ydHMgdGhhdCBhcmUgcGFyc2VkIGJ5IHRoZSBuYXRpdmUgSFRNTCBwYXJzZXIsIHRoYXQgY2FuIGJlXG4gKiByZWxvY2F0ZWQgZHVyaW5nIGEgYnVuZGxpbmcgcGFzcyBhbmQgc3RpbGwgbG9va2VkIHVwIGJ5IGBpZGAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgPGRvbS1tb2R1bGUgaWQ9XCJmb29cIj5cbiAqICAgICAgIDxpbWcgc3JjPVwic3R1ZmYucG5nXCI+XG4gKiAgICAgPC9kb20tbW9kdWxlPlxuICpcbiAqIFRoZW4gaW4gY29kZSBpbiBzb21lIG90aGVyIGxvY2F0aW9uIHRoYXQgY2Fubm90IGFjY2VzcyB0aGUgZG9tLW1vZHVsZSBhYm92ZVxuICpcbiAqICAgICBsZXQgaW1nID0gY3VzdG9tRWxlbWVudHMuZ2V0KCdkb20tbW9kdWxlJykuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBhIHJlZ2lzdHJ5IG9mIHJlbG9jYXRhYmxlIERPTSBjb250ZW50XG4gKiAgIGJ5IGBpZGAgdGhhdCBpcyBhZ25vc3RpYyB0byBidW5kbGluZy5cbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuY2xhc3MgRG9tTW9kdWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydpZCddOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGNzcyBgc2VsZWN0b3JgIGluIHRoZSBtb2R1bGVcbiAgICogcmVnaXN0ZXJlZCBieSBgaWRgLiBGb3IgZXhhbXBsZSwgdGhpcy5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgZG9tLW1vZHVsZSBpbiB3aGljaCB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VsZWN0b3IgVGhlIGNzcyBzZWxlY3RvciBieSB3aGljaCB0byBmaW5kIHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBlbGVtZW50IHdoaWNoIG1hdGNoZXMgYHNlbGVjdG9yYCBpbiB0aGVcbiAgICogbW9kdWxlIHJlZ2lzdGVyZWQgYXQgdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgKi9cbiAgc3RhdGljIGltcG9ydChpZCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGxldCBtID0gZmluZE1vZHVsZShpZCk7XG4gICAgICBpZiAobSAmJiBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFic29sdXRlIFVSTCBvZiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhpcyBgZG9tLW1vZHVsZWAuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgd2lsbCBkaWZmZXIgZnJvbSB0aGlzIGVsZW1lbnQncyBgb3duZXJEb2N1bWVudGAgaW4gdGhlXG4gICAqIGZvbGxvd2luZyB3YXlzOlxuICAgKiAtIFRha2VzIGludG8gYWNjb3VudCBhbnkgYGFzc2V0cGF0aGAgYXR0cmlidXRlIGFkZGVkIGR1cmluZyBidW5kbGluZ1xuICAgKiAgIHRvIGluZGljYXRlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgYnVuZGxlZCBsb2NhdGlvblxuICAgKiAtIFVzZXMgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsJ3MgYGltcG9ydEZvckVsZW1lbnRgIEFQSSB0byBlbnN1cmVcbiAgICogICB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IGRvY3VtZW50J3MgbG9jYXRpb24gc2luY2VcbiAgICogICBgb3duZXJEb2N1bWVudGAgaXMgbm90IGN1cnJlbnRseSBwb2x5ZmlsbGVkXG4gICAqL1xuICBnZXQgYXNzZXRwYXRoKCkge1xuICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFzc2V0cGF0aC5cbiAgICBpZiAoIXRoaXMuX19hc3NldHBhdGgpIHtcbiAgICAgIC8vIG5vdGU6IGFzc2V0cGF0aCBzZXQgdmlhIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoaXNcbiAgICAgIC8vIGVsZW1lbnQncyBsb2NhdGlvbjsgYWNjb21vZGF0ZSBwb2x5ZmlsbGVkIEhUTUxJbXBvcnRzXG4gICAgICBjb25zdCBvd25lciA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50ID9cbiAgICAgICAgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCh0aGlzKSB8fCBkb2N1bWVudCA6IHRoaXMub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IHVybCA9IHJlc29sdmVVcmwoXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdhc3NldHBhdGgnKSB8fCAnJywgb3duZXIuYmFzZVVSSSk7XG4gICAgICB0aGlzLl9fYXNzZXRwYXRoID0gcGF0aEZyb21VcmwodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19hc3NldHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBkb20tbW9kdWxlIGF0IGEgZ2l2ZW4gaWQuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZFxuICAgKiB3aGVuIGEgZG9tLW1vZHVsZSBpcyBpbXBlcmF0aXZlbHkgY3JlYXRlZC4gRm9yXG4gICAqIGV4YW1wbGUsIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykucmVnaXN0ZXIoJ2ZvbycpYC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCBUaGUgaWQgYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGRvbS1tb2R1bGUuXG4gICAqL1xuICByZWdpc3RlcihpZCkge1xuICAgIGlkID0gaWQgfHwgdGhpcy5pZDtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIC8vIHN0b3JlIGlkIHNlcGFyYXRlIGZyb20gbG93ZXJjYXNlZCBpZCBzbyB0aGF0XG4gICAgICAvLyBpbiBhbGwgY2FzZXMgbWl4ZWRDYXNlIGlkIHdpbGwgc3RvcmVkIGRpc3RpbmN0bHlcbiAgICAgIC8vIGFuZCBsb3dlcmNhc2UgdmVyc2lvbiBpcyBhIGZhbGxiYWNrXG4gICAgICBtb2R1bGVzW2lkXSA9IHRoaXM7XG4gICAgICBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuICAgICAgc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuRG9tTW9kdWxlLnByb3RvdHlwZVsnbW9kdWxlcyddID0gbW9kdWxlcztcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tbW9kdWxlJywgRG9tTW9kdWxlKTtcblxuZXhwb3J0IHsgRG9tTW9kdWxlIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMiLCJpbXBvcnQgJy4uLy4uLy4uLy4uL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2FwcGx5LXNoaW0uanMnO1xuaW1wb3J0IHsgRWxlbWVudE1peGluIH0gZnJvbSAnLi4vbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuaW1wb3J0IHsgR2VzdHVyZUV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnLi4vbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgeyBpbXBvcnRIcmVmIGFzIGltcG9ydEhyZWYkMCB9IGZyb20gJy4uL3V0aWxzL2ltcG9ydC1ocmVmLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvcmVuZGVyLXN0YXR1cy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL3VucmVzb2x2ZWQuanMnO1xuaW1wb3J0IHsgZG9tIGFzIGRvbSQwLCBtYXRjaGVzU2VsZWN0b3IgfSBmcm9tICcuL3BvbHltZXIuZG9tLmpzJztcbmltcG9ydCB7IHNldFRvdWNoQWN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvZ2VzdHVyZXMuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgdGltZU91dCwgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuaW1wb3J0IHsgZ2V0IGFzIGdldCQwIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5cbmxldCBzdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUztcblxuZXhwb3J0IGNvbnN0IExlZ2FjeUVsZW1lbnRNaXhpbiA9IGRlZHVwaW5nTWl4aW4oKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICovXG4gIGNvbnN0IGxlZ2FjeUVsZW1lbnRCYXNlID0gR2VzdHVyZUV2ZW50TGlzdGVuZXJzKEVsZW1lbnRNaXhpbihiYXNlKSk7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBzaW1wbGUgbmFtZXMgdG8gdG91Y2ggYWN0aW9uIG5hbWVzXG4gICAqIEBkaWN0XG4gICAqL1xuICBjb25zdCBESVJFQ1RJT05fTUFQID0ge1xuICAgICd4JzogJ3Bhbi14JyxcbiAgICAneSc6ICdwYW4teScsXG4gICAgJ25vbmUnOiAnbm9uZScsXG4gICAgJ2FsbCc6ICdhdXRvJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAZXh0ZW5kcyB7bGVnYWN5RWxlbWVudEJhc2V9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0xlZ2FjeUVsZW1lbnRNaXhpbn1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgTGVnYWN5RWxlbWVudCBleHRlbmRzIGxlZ2FjeUVsZW1lbnRCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucm9vdCA9IHRoaXM7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLmlzQXR0YWNoZWQ7XG4gICAgICAvKiogQHR5cGUge1dlYWtNYXA8IUVsZW1lbnQsICFPYmplY3Q8c3RyaW5nLCAhRnVuY3Rpb24+Pn0gKi9cbiAgICAgIHRoaXMuX19ib3VuZExpc3RlbmVycztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgRnVuY3Rpb24+fSAqL1xuICAgICAgdGhpcy5fZGVib3VuY2VycztcbiAgICAgIHRoaXMuY3JlYXRlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIHRoZSBgY29uc3RydWN0b3JgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGNyZWF0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGNvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIHdoaWNoIGFkZHMgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGF0dGFjaGVkYCBtZXRob2QuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgdGhpcy5pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYXR0YWNoZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgY29ubmVjdGVkQ2FsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGF0dGFjaGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgKiB3aGljaCBhZGRzIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBkZXRhY2hlZGAgbWV0aG9kLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kZXRhY2hlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBkaXNjb25uZWN0ZWRDYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgZGV0YWNoZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gb3ZlcnJpZGUgaW1wbGVtZW50YXRpb24gb2YgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2BcbiAgICAgKiB3aGljaCBhZGRzIHRoZSBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgYXR0cmlidXRlQ2hhbmdlZGAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGF0dHJpYnV0ZUNoYW5nZWRDaGFsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGltcGxlbWVudGF0aW9uIHRvXG4gICAgICogYWRkIHN1cHBvcnQgZm9yIGNsYXNzIGluaXRpYWxpemF0aW9uIHZpYSB0aGUgYF9yZWdpc3RlcmVkYCBjYWxsYmFjay5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBvbmx5IHdoZW4gdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdfX2hhc1JlZ2lzdGVyRmluaXNoZWQnKSkge1xuICAgICAgICBwcm90by5fX2hhc1JlZ2lzdGVyRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkKCk7XG4gICAgICB9XG4gICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIGFuIGVsZW1lbnQgaXMgaW5pdGlhbGl6aW5nLlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGNsYXNzIHJlZ2lzdHJhdGlvbiB0aW1lXG4gICAgICogd29yay4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBlbnN1cmUgdGhlIHdvcmsgaXMgcGVyZm9ybWVkXG4gICAgICogb25seSBvbmNlIGZvciB0aGUgY2xhc3MuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZWdpc3RlcmVkKCkge31cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGltcGxlbWVudGF0aW9uIHRvXG4gICAgICogYWRkIHN1cHBvcnQgZm9yIGluc3RhbGxpbmcgYGhvc3RBdHRyaWJ1dGVzYCBhbmQgYGxpc3RlbmVyc2AuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICAgIHRoaXMuX2FwcGx5TGlzdGVuZXJzKCk7XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYW4gZWxlbWVudCBoYXMgcmVxdWlyZWQgYXR0cmlidXRlcy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG8gc2V0IHRoZVxuICAgICAqIGVsZW1lbnQncyByZXF1aXJlZCBhdHRyaWJ1dGVzLiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIHN1cmVcbiAgICAgKiB0byBjaGVjayBhbmQgbm90IG92ZXJyaWRlIGV4aXN0aW5nIGF0dHJpYnV0ZXMgYWRkZWQgYnlcbiAgICAgKiB0aGUgdXNlciBvZiB0aGUgZWxlbWVudC4gVHlwaWNhbGx5LCBzZXR0aW5nIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxlZnRcbiAgICAgKiB0byB0aGUgZWxlbWVudCB1c2VyIGFuZCBub3QgZG9uZSBoZXJlOyByZWFzb25hYmxlIGV4Y2VwdGlvbnMgaW5jbHVkZVxuICAgICAqIHNldHRpbmcgYXJpYSByb2xlcyBhbmQgZm9jdXNhYmlsaXR5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5zdXJlQXR0cmlidXRlcygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGVsZW1lbnQgZXZlbnQgbGlzdGVuZXJzLiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudFxuICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0b1xuICAgICAqIGFkZCBhbnkgcmVxdWlyZWQgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogSW4gcGVyZm9ybWFuY2UgY3JpdGljYWwgZWxlbWVudHMsIHRoZSB3b3JrIGRvbmUgaGVyZSBzaG91bGQgYmUga2VwdFxuICAgICAqIHRvIGEgbWluaW11bSBzaW5jZSBpdCBpcyBkb25lIGJlZm9yZSB0aGUgZWxlbWVudCBpcyByZW5kZXJlZC4gSW5cbiAgICAgKiB0aGVzZSBlbGVtZW50cywgY29uc2lkZXIgYWRkaW5nIGxpc3RlbmVycyBhc3ljaHJvbm91c2x5IHNvIGFzIG5vdCB0b1xuICAgICAqIGJsb2NrIHJlbmRlci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2FwcGx5TGlzdGVuZXJzKCkge31cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuIFRvIGN1c3RvbWl6ZVxuICAgICAqIGhvdyBwcm9wZXJ0aWVzIGFyZSBzZXJpYWxpemVkIHRvIGF0dHJpYnV0ZXMgZm9yIGF0dHJpYnV0ZSBiaW5kaW5ncyBhbmRcbiAgICAgKiBgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlYCBwcm9wZXJ0aWVzIGFzIHdlbGwgYXMgdGhpcyBtZXRob2QsIG92ZXJyaWRlXG4gICAgICogdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGRlc2VyaWFsaXplXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTZXJpYWxpemVkIHZhbHVlXG4gICAgICovXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuICBUbyBjdXN0b21pemVcbiAgICAgKiBob3cgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWxpemVkIHRvIHByb3BlcnRpZXMgZm9yIGluXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG92ZXJyaWRlIGBfZGVzZXJpYWxpemVWYWx1ZWAgbWV0aG9kXG4gICAgICogcHJvdmlkZWQgYnkgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFN0cmluZyB0byBkZXNlcmlhbGl6ZVxuICAgICAqIEBwYXJhbSB7Kn0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG9cbiAgICAgKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSBkZXNlcmlhbGl6ZWQgdmFsdWUgaW4gdGhlIGB0eXBlYCBnaXZlbi5cbiAgICAgKi9cbiAgICBkZXNlcmlhbGl6ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgYSBwcm9wZXJ0eSB0byBpdHMgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHJlZmVjdC5cbiAgICAgKi9cbiAgICByZWZsZWN0UHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZVZhbHVlVG9BdHRyaWJ1dGUodmFsdWUsIGF0dHJpYnV0ZSwgbm9kZSkge1xuICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKSwgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBwcm9wZXJ0aWVzIChpbmNsdWRpbmcgYWNjZXNzb3IgZGVzY3JpcHRvcnMpIGZyb20gYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXBpIFNvdXJjZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwcm90b3R5cGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBleHRlbmQocHJvdG90eXBlLCBhcGkpIHtcbiAgICAgIGlmICghKHByb3RvdHlwZSAmJiBhcGkpKSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGUgfHwgYXBpO1xuICAgICAgfVxuICAgICAgbGV0IG4kID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXBpKTtcbiAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8biQubGVuZ3RoKSAmJiAobj1uJFtpXSk7IGkrKykge1xuICAgICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFwaSwgbik7XG4gICAgICAgIGlmIChwZCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG4sIHBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3RvdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogTm90ZSwgdGhpcyBtZXRob2QgdXNlcyBhIHNpbXBsZSBgZm9yLi4uaW5gIHN0cmF0ZWd5IGZvciBlbnVtZXJhdGluZ1xuICAgICAqIHByb3BlcnRpZXMuICBUbyBlbnN1cmUgb25seSBgb3duUHJvcGVydGllc2AgYXJlIGNvcGllZCBmcm9tIHNvdXJjZVxuICAgICAqIHRvIHRhcmdldCBhbmQgdGhhdCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbnMgYXJlIGNvcGllZCwgdXNlIGBleHRlbmRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFNvdXJjZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgZm9yIChsZXQgaSBpbiBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gc2V0IHRoZSBwcm90b3R5cGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgcHJvdG90eXBlIHRoYXQgd2lsbCBiZSBzZXQgb24gdGhlIGdpdmVuXG4gICAgICogYG9iamVjdGAuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBnaXZlbiBgb2JqZWN0YCB3aXRoIGl0cyBwcm90b3R5cGUgc2V0XG4gICAgICogdG8gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC5cbiAgICAgKi9cbiAgICBjaGFpbk9iamVjdChvYmplY3QsIHByb3RvdHlwZSkge1xuICAgICAgaWYgKG9iamVjdCAmJiBwcm90b3R5cGUgJiYgb2JqZWN0ICE9PSBwcm90b3R5cGUpIHtcbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyogKioqKiBCZWdpbiBUZW1wbGF0ZSAqKioqICovXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBjb250ZW50YCBvZiB0aGUgYHRlbXBsYXRlYCBzcGVjaWZpZWQgYW5kXG4gICAgICogcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIEhUTUwgdGVtcGxhdGUgZWxlbWVudCB0byBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBEb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBpbXBvcnRlZFxuICAgICAqICAgdGVtcGxhdGUgY29udGVudC5cbiAgICAqL1xuICAgIGluc3RhbmNlVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5fY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGxldCBkb20gPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovXG4gICAgICAgIChkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuXG4gICAgLyogKioqKiBCZWdpbiBFdmVudHMgKioqKiAqL1xuXG5cblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBjdXN0b20gZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBkZXRhaWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBOYW1lIG9mIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHsqPX0gZGV0YWlsIERldGFpbCB2YWx1ZSBjb250YWluaW5nIGV2ZW50LXNwZWNpZmljXG4gICAgICogICBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSB7eyBidWJibGVzOiAoYm9vbGVhbnx1bmRlZmluZWQpLCBjYW5jZWxhYmxlOiAoYm9vbGVhbnx1bmRlZmluZWQpLCBjb21wb3NlZDogKGJvb2xlYW58dW5kZWZpbmVkKSB9PX1cbiAgICAgKiAgb3B0aW9ucyBPYmplY3Qgc3BlY2lmeWluZyBvcHRpb25zLiAgVGhlc2UgbWF5IGluY2x1ZGU6XG4gICAgICogIGBidWJibGVzYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gYHRydWVgKSxcbiAgICAgKiAgYGNhbmNlbGFibGVgIChib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSksIGFuZFxuICAgICAqICBgbm9kZWAgb24gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnQgKEhUTUxFbGVtZW50LCBkZWZhdWx0cyB0byBgdGhpc2ApLlxuICAgICAqIEByZXR1cm4ge0V2ZW50fSBUaGUgbmV3IGV2ZW50IHRoYXQgd2FzIGZpcmVkLlxuICAgICAqL1xuICAgIGZpcmUodHlwZSwgZGV0YWlsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGRldGFpbCA9IChkZXRhaWwgPT09IG51bGwgfHwgZGV0YWlsID09PSB1bmRlZmluZWQpID8ge30gOiBkZXRhaWw7XG4gICAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnQodHlwZSwge1xuICAgICAgICBidWJibGVzOiBvcHRpb25zLmJ1YmJsZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmJ1YmJsZXMsXG4gICAgICAgIGNhbmNlbGFibGU6IEJvb2xlYW4ob3B0aW9ucy5jYW5jZWxhYmxlKSxcbiAgICAgICAgY29tcG9zZWQ6IG9wdGlvbnMuY29tcG9zZWQgPT09IHVuZGVmaW5lZCA/IHRydWU6IG9wdGlvbnMuY29tcG9zZWRcbiAgICAgIH0pO1xuICAgICAgZXZlbnQuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgdGhpcztcbiAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciBvbiBhIGdpdmVuIGVsZW1lbnQsXG4gICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBoYW5kbGVyIG1ldGhvZCBvbiBgdGhpc2AgdG8gY2FsbC5cbiAgICAgKi9cbiAgICBsaXN0ZW4obm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBsZXQgaGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzIHx8XG4gICAgICAgICh0aGlzLl9fYm91bmRMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpKTtcbiAgICAgIGxldCBibCA9IGhibC5nZXQobm9kZSk7XG4gICAgICBpZiAoIWJsKSB7XG4gICAgICAgIGJsID0ge307XG4gICAgICAgIGhibC5zZXQobm9kZSwgYmwpO1xuICAgICAgfVxuICAgICAgbGV0IGtleSA9IGV2ZW50TmFtZSArIG1ldGhvZE5hbWU7XG4gICAgICBpZiAoIWJsW2tleV0pIHtcbiAgICAgICAgYmxba2V5XSA9IHRoaXMuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUoXG4gICAgICAgICAgbm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYSBnaXZlbiBlbGVtZW50LFxuICAgICAqIGxhdGUgYm91bmQgdG8gYSBuYW1lZCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb20uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIHN0b3AgbGlzdGVuaW5nIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgaGFuZGxlciBtZXRob2Qgb24gYHRoaXNgIHRvIG5vdCBjYWxsXG4gICAgIGFueW1vcmUuXG4gICAgICovXG4gICAgdW5saXN0ZW4obm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBsZXQgYmwgPSB0aGlzLl9fYm91bmRMaXN0ZW5lcnMgJiYgdGhpcy5fX2JvdW5kTGlzdGVuZXJzLmdldChub2RlKTtcbiAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgbGV0IGhhbmRsZXIgPSBibCAmJiBibFtrZXldO1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIGJsW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHNjcm9sbGluZyBiZWhhdmlvciB0byBhbGwgZGlyZWN0aW9uLCBvbmUgZGlyZWN0aW9uLCBvciBub25lLlxuICAgICAqXG4gICAgICogVmFsaWQgc2Nyb2xsIGRpcmVjdGlvbnM6XG4gICAgICogICAtICdhbGwnOiBzY3JvbGwgaW4gYW55IGRpcmVjdGlvblxuICAgICAqICAgLSAneCc6IHNjcm9sbCBvbmx5IGluIHRoZSAneCcgZGlyZWN0aW9uXG4gICAgICogICAtICd5Jzogc2Nyb2xsIG9ubHkgaW4gdGhlICd5JyBkaXJlY3Rpb25cbiAgICAgKiAgIC0gJ25vbmUnOiBkaXNhYmxlIHNjcm9sbGluZyBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGRpcmVjdGlvbiBEaXJlY3Rpb24gdG8gYWxsb3cgc2Nyb2xsaW5nXG4gICAgICogRGVmYXVsdHMgdG8gYGFsbGAuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHNjcm9sbCBkaXJlY3Rpb24gc2V0dGluZy5cbiAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgc2V0U2Nyb2xsRGlyZWN0aW9uKGRpcmVjdGlvbiwgbm9kZSkge1xuICAgICAgc2V0VG91Y2hBY3Rpb24oIChub2RlIHx8IHRoaXMpLCBESVJFQ1RJT05fTUFQW2RpcmVjdGlvbl0gfHwgJ2F1dG8nKTtcbiAgICB9XG4gICAgLyogKioqKiBFbmQgRXZlbnRzICoqKiogKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBydW4gYHF1ZXJ5U2VsZWN0b3JgIG9uIHRoaXMgbG9jYWwgRE9NIHNjb3BlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxscyBgUG9seW1lci5kb20odGhpcy5yb290KS5xdWVyeVNlbGVjdG9yKHNsY3RyKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2xjdHIgU2VsZWN0b3IgdG8gcnVuIG9uIHRoaXMgbG9jYWwgRE9NIHNjb3BlXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gRWxlbWVudCBmb3VuZCBieSB0aGUgc2VsZWN0b3IsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgICQkKHNsY3RyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudCB3aG9zZSBsb2NhbCBkb20gd2l0aGluIHdoaWNoIHRoaXMgZWxlbWVudFxuICAgICAqIGlzIGNvbnRhaW5lZC4gVGhpcyBpcyBhIHNob3J0aGFuZCBmb3JcbiAgICAgKiBgdGhpcy5nZXRSb290Tm9kZSgpLmhvc3RgLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBkb21Ib3N0KCkge1xuICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3ROb2RlKCk7XG4gICAgICByZXR1cm4gKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSA/IC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3QgOiByb290O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlIHRoaXMgZWxlbWVudCB0byBkaXN0cmlidXRlIGl0cyBjaGlsZHJlbiB0byBpdHMgbG9jYWwgZG9tLlxuICAgICAqIFRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYXMgb2YgUG9seW1lciAyLjAuMiBhbmQgaXMgcHJvdmlkZWQgb25seVxuICAgICAqIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgICBkaXN0cmlidXRlQ29udGVudCgpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00gJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZE5vZGVzLiBUaGUgZWZmZWN0aXZlXG4gICAgICogY2hpbGROb2RlcyBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGROb2RlcyBleGNlcHQgdGhhdFxuICAgICAqIGFueSBgPGNvbnRlbnQ+YCBlbGVtZW50cyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZFxuICAgICAqIHRvIHRoZSBgPGNvbnRlbnQ+YCwgdGhlIHJlc3VsdCBvZiBpdHMgYGdldERpc3RyaWJ1dGVkTm9kZXNgIG1ldGhvZC5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZCBub2Rlcy5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8gKGRvbSQwKHRoaXMpKS5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0IG1hdGNoXG4gICAgICogYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZHJlbiBvciBlbGVtZW50cyBkaXN0cmlidXRlZCB0b1xuICAgICAqIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBlbGVtZW50cyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIHF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8gKGRvbSQwKHRoaXMpKS5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHRoZSBlZmZlY3RpdmUgY2hpbGRyZW4uIFRoZSBlZmZlY3RpdmVcbiAgICAgKiBjaGlsZHJlbiBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGRyZW4gZXhjZXB0IHRoYXRcbiAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAgICAgKiBkaXN0cmlidXRlZCB0byB0aGUgYDxjb250ZW50PmAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVDaGlsZHJlbigpIHtcbiAgICAgIGxldCBsaXN0ID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24oLyoqIEB0eXBlIHtOb2RlfSAqLyBuKSB7XG4gICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBvZiB0ZXh0IGNvbnRlbnQgdGhhdCBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAgICAgKiB0ZXh0IGNvbnRlbnQncyBvZiB0aGUgZWxlbWVudCdzIGVmZmVjdGl2ZSBjaGlsZE5vZGVzICh0aGUgZWxlbWVudHNcbiAgICAgKiByZXR1cm5lZCBieSA8YSBocmVmPVwiI2dldEVmZmVjdGl2ZUNoaWxkTm9kZXM+Z2V0RWZmZWN0aXZlQ2hpbGROb2RlczwvYT4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlVGV4dENvbnRlbnQoKSB7XG4gICAgICBsZXQgY24gPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIGxldCB0YyA9IFtdO1xuICAgICAgZm9yIChsZXQgaT0wLCBjOyAoYyA9IGNuW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmIChjLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgIHRjLnB1c2goYy50ZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0Yy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlZmZlY3RpdmUgY2hpbGROb2RlIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdFxuICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgKiB0byBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICogQHJldHVybiB7T2JqZWN0PE5vZGU+fSBGaXJzdCBlZmZlY3RpdmUgY2hpbGQgbm9kZSB0aGF0IG1hdGNoZXMgc2VsZWN0b3IuXG4gICAgICovXG4gICAgcXVlcnlFZmZlY3RpdmVDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgbGV0IGUkID0gdGhpcy5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuIGUkICYmIGUkWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVmZmVjdGl2ZSBjaGlsZE5vZGVzIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdFxuICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgKiB0byBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkIG5vZGVzIHRoYXQgbWF0Y2ggc2VsZWN0b3IuXG4gICAgICovXG4gICAgcXVlcnlBbGxFZmZlY3RpdmVDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB0byB0aGlzIGVsZW1lbnQncyBgPHNsb3Q+YC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBtb3JlIHRoYW4gb25lIGA8c2xvdD5gIGluIGl0cyBsb2NhbCBET00sXG4gICAgICogYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2xjdHIgQ1NTIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAqICAgYDxzbG90PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZSBgPHNsb3Q+YC5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50Q2hpbGROb2RlcyhzbGN0cikge1xuICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0ciB8fCAnc2xvdCcpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQgPyAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyhkb20kMChjb250ZW50KSkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudCBjaGlsZHJlbiBkaXN0cmlidXRlZCB0byB0aGlzIGVsZW1lbnQnc1xuICAgICAqIGA8c2xvdD5gLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBlbGVtZW50IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgYDxzbG90PmAgaW4gaXRzXG4gICAgICogbG9jYWwgRE9NLCBhbiBvcHRpb25hbCBzZWxlY3RvciBtYXkgYmUgcGFzc2VkIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAqIGNvbnRlbnQuICBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYGdldENvbnRlbnRDaGlsZE5vZGVzYCBpbiB0aGF0IG9ubHlcbiAgICAgKiBlbGVtZW50cyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgKiAgIGA8Y29udGVudD5gLiAgRGVmYXVsdHMgdG8gYGNvbnRlbnRgLlxuICAgICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlXG4gICAgICogICBgPHNsb3Q+YC5cbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBnZXRDb250ZW50Q2hpbGRyZW4oc2xjdHIpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0FycmF5PEhUTUxFbGVtZW50Pn0gKi8odGhpcy5nZXRDb250ZW50Q2hpbGROb2RlcyhzbGN0cikuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P05vZGV9IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG5vZGUgaXMgaW4gdGhpcyBlbGVtZW50J3MgbGlnaHQgRE9NIHRyZWUuXG4gICAgICovXG4gICAgaXNMaWdodERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMgIT09IG5vZGUgJiYgdGhpcy5jb250YWlucyhub2RlKSAmJlxuICAgICAgICAgIHRoaXMuZ2V0Um9vdE5vZGUoKSA9PT0gbm9kZS5nZXRSb290Tm9kZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhpcyBlbGVtZW50J3MgbG9jYWwgRE9NIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAqL1xuICAgIGlzTG9jYWxEZXNjZW5kYW50KG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBzaG91bGQgbm93IGJlIGhhbmRsZWQgYnkgU2hhZHlDc3MgbGlicmFyeS5cbiAgICBzY29wZVN1YnRyZWUoY29udGFpbmVyLCBzaG91bGRPYnNlcnZlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgY3NzIHByb3BlcnR5IG5hbWUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb21wdXRlZCBjc3MgcHJvcGVydHkgdmFsdWUgZm9yIHRoZSBnaXZlblxuICAgICAqIGBwcm9wZXJ0eWAuXG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gc3R5bGVJbnRlcmZhY2UuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvLyBkZWJvdW5jZVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgZGVib3VuY2VgIHRvIGNvbGxhcHNlIG11bHRpcGxlIHJlcXVlc3RzIGZvciBhIG5hbWVkIHRhc2sgaW50b1xuICAgICAqIG9uZSBpbnZvY2F0aW9uIHdoaWNoIGlzIG1hZGUgYWZ0ZXIgdGhlIHdhaXQgdGltZSBoYXMgZWxhcHNlZCB3aXRoXG4gICAgICogbm8gbmV3IHJlcXVlc3QuICBJZiBubyB3YWl0IHRpbWUgaXMgZ2l2ZW4sIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAgICAqIGF0IG1pY3JvdGFzayB0aW1pbmcgKGd1YXJhbnRlZWQgYmVmb3JlIHBhaW50KS5cbiAgICAgKlxuICAgICAqICAgICBkZWJvdW5jZWRDbGlja0FjdGlvbihlKSB7XG4gICAgICogICAgICAgLy8gd2lsbCBub3QgY2FsbCBgcHJvY2Vzc0NsaWNrYCBtb3JlIHRoYW4gb25jZSBwZXIgMTAwbXNcbiAgICAgKiAgICAgICB0aGlzLmRlYm91bmNlKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICB0aGlzLnByb2Nlc3NDbGljaygpO1xuICAgICAqICAgICAgIH0gMTAwKTtcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgU3RyaW5nIHRvIGluZGVudGlmeSB0aGUgZGVib3VuY2Ugam9iLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgKHdpdGggYHRoaXNgXG4gICAgICogICBjb250ZXh0KSB3aGVuIHRoZSB3YWl0IHRpbWUgZWxhcHNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBPcHRpb25hbCB3YWl0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIChtcykgYWZ0ZXIgdGhlXG4gICAgICogICBsYXN0IHNpZ25hbCB0aGF0IG11c3QgZWxhcHNlIGJlZm9yZSBpbnZva2luZyBgY2FsbGJhY2tgXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdCBvbiB3aGljaCBleGlzdHMgdGhlXG4gICAgICogZm9sbG93aW5nIG1ldGhvZHM6IGBpc0FjdGl2ZSgpYCByZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpc1xuICAgICAqIGFjdGl2ZTsgYGNhbmNlbCgpYCBjYW5jZWxzIHRoZSBkZWJvdW5jZXIgaWYgaXQgaXMgYWN0aXZlO1xuICAgICAqIGBmbHVzaCgpYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBkZWJvdW5jZWQgY2FsbGJhY2sgaWYgdGhlIGRlYm91bmNlclxuICAgICAqIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBkZWJvdW5jZShqb2JOYW1lLCBjYWxsYmFjaywgd2FpdCkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICByZXR1cm4gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXSA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV1cbiAgICAgICAgICAsIHdhaXQgPiAwID8gdGltZU91dC5hZnRlcih3YWl0KSA6IG1pY3JvVGFza1xuICAgICAgICAgICwgY2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgbmFtZWQgZGVib3VuY2VyIGlzIGFjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlIChoYXMgbm90IHlldCBmaXJlZCkuXG4gICAgICovXG4gICAgaXNEZWJvdW5jZXJBY3RpdmUoam9iTmFtZSkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgIHJldHVybiAhIShkZWJvdW5jZXIgJiYgZGVib3VuY2VyLmlzQWN0aXZlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNhbGxzIHRoZSBkZWJvdW5jZXIgYGNhbGxiYWNrYCBhbmQgaW5hY3RpdmF0ZXMgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICovXG4gICAgZmx1c2hEZWJvdW5jZXIoam9iTmFtZSkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgIGlmIChkZWJvdW5jZXIpIHtcbiAgICAgICAgZGVib3VuY2VyLmZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyLiAgVGhlIGBjYWxsYmFja2Agd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAqL1xuICAgIGNhbmNlbERlYm91bmNlcihqb2JOYW1lKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIGFzeW5jcm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0IChpZiBubyB3YWl0VGltZSBpcyBzcGVjaWZpZWQpLCBhc3luYyBjYWxsYmFja3MgYXJlIHJ1biBhdFxuICAgICAqIG1pY3JvdGFzayB0aW1pbmcsIHdoaWNoIHdpbGwgb2NjdXIgYmVmb3JlIHBhaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biwgYm91bmQgdG8gYHRoaXNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gd2FpdFRpbWUgVGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIHRoZVxuICAgICAqICAgYGNhbGxiYWNrYC4gIElmIHVuc3BlY2lmaWVkIG9yIDAsIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJ1biBhdCBtaWNyb3Rhc2tcbiAgICAgKiAgIHRpbWluZyAoYmVmb3JlIHBhaW50KS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgYXN5bmMgam9iLlxuICAgICAqL1xuICAgIGFzeW5jKGNhbGxiYWNrLCB3YWl0VGltZSkge1xuICAgICAgcmV0dXJuIHdhaXRUaW1lID4gMCA/IHRpbWVPdXQucnVuKGNhbGxiYWNrLmJpbmQodGhpcyksIHdhaXRUaW1lKSA6XG4gICAgICAgICAgfm1pY3JvVGFzay5ydW4oY2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCB3aXRoIGBhc3luY2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIG9yaWdpbmFsIGBhc3luY2AgY2FsbCB0b1xuICAgICAqICAgY2FuY2VsLlxuICAgICAqL1xuICAgIGNhbmNlbEFzeW5jKGhhbmRsZSkge1xuICAgICAgaGFuZGxlIDwgMCA/IG1pY3JvVGFzay5jYW5jZWwofmhhbmRsZSkgOlxuICAgICAgICAgIHRpbWVPdXQuY2FuY2VsKGhhbmRsZSk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYW4gZWxlbWVudCBhbmQgY29uZmlndXJpbmcgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIEhUTUwgZWxlbWVudCB0YWcgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydGllcyB0byBjb25maWd1cmUgb24gdGhlXG4gICAgICogICAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gTmV3bHkgY3JlYXRlZCBhbmQgY29uZmlndXJlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZSh0YWcsIHByb3BzKSB7XG4gICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmIChlbHQuc2V0UHJvcGVydGllcykge1xuICAgICAgICAgIGVsdC5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBuIGluIHByb3BzKSB7XG4gICAgICAgICAgICBlbHRbbl0gPSBwcm9wc1tuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBpbXBvcnRpbmcgYW4gSFRNTCBkb2N1bWVudCBpbXBlcmF0aXZlbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGA8bGluayByZWw9XCJpbXBvcnRcIj5gIGVsZW1lbnQgd2l0aFxuICAgICAqIHRoZSBwcm92aWRlZCBVUkwgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGRvY3VtZW50IHRvIHN0YXJ0IGxvYWRpbmcuXG4gICAgICogSW4gdGhlIGBvbmxvYWRgIGNhbGxiYWNrLCB0aGUgYGltcG9ydGAgcHJvcGVydHkgb2YgdGhlIGBsaW5rYFxuICAgICAqIGVsZW1lbnQgd2lsbCBjb250YWluIHRoZSBpbXBvcnRlZCBkb2N1bWVudCBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFVSTCB0byBkb2N1bWVudCB0byBsb2FkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ubG9hZCBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnQgc3VjY2Vzc2Z1bGx5XG4gICAgICogICBsb2FkZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25lcnJvciBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnRcbiAgICAgKiAgIHVuc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEFzeW5jIFRydWUgaWYgdGhlIGltcG9ydCBzaG91bGQgYmUgbG9hZGVkIGBhc3luY2AuXG4gICAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqIEByZXR1cm4ge0hUTUxMaW5rRWxlbWVudH0gVGhlIGxpbmsgZWxlbWVudCBmb3IgdGhlIFVSTCB0byBiZSBsb2FkZWQuXG4gICAgICovXG4gICAgaW1wb3J0SHJlZihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGxldCBsb2FkRm4gPSBvbmxvYWQgPyBvbmxvYWQuYmluZCh0aGlzKSA6IG51bGw7XG4gICAgICBsZXQgZXJyb3JGbiA9IG9uZXJyb3IgPyBvbmVycm9yLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgcmV0dXJuIGltcG9ydEhyZWYkMChocmVmLCBsb2FkRm4sIGVycm9yRm4sIG9wdEFzeW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmb3IgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcywgd2hpY2ggaXMgc29tZXRpbWVzIHN0aWxsXG4gICAgICogcHJlZml4ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gdGVzdC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gdGVzdCB0aGUgc2VsZWN0b3IgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGVsZW1lbnRNYXRjaGVzKHNlbGVjdG9yLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yKCAobm9kZSB8fCB0aGlzKSwgc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYW4gSFRNTCBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSFRNTCBhdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgYXR0cmlidXRlIG9uIG9yIG9mZi5cbiAgICAgKiAgICBXaGVuIHVuc3BlY2lmaWVkLCB0aGUgc3RhdGUgb2YgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJldmVyc2VkLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgdG9nZ2xlQXR0cmlidXRlKG5hbWUsIGJvb2wsIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBib29sID0gIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGEgQ1NTIGNsYXNzIG9uIG9yIG9mZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBjbGFzcyBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYm9vbCBCb29sZWFuIHRvIGZvcmNlIHRoZSBjbGFzcyBvbiBvciBvZmYuXG4gICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBjbGFzcyB3aWxsIGJlIHJldmVyc2VkLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgdG9nZ2xlQ2xhc3MobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGJvb2wgPSAhbm9kZS5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoYm9vbCkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zZm9ybWAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmb3JtVGV4dCBUcmFuc2Zvcm0gc2V0dGluZy5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0by5cbiAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2BcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtVGV4dCwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybVRleHQ7XG4gICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zbGF0ZTNkYFxuICAgICAqIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggWCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWSBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHogWiBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICogRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZTNkKHgsIHksIHosIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywnICsgeSArICcsJyArIHogKyAnKScsIG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5LCBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYXJyYXkgaXMgc3BlY2lmaWVkIGJ5IHBhdGgsIGEgY2hhbmdlIG5vdGlmaWNhdGlvbiBpc1xuICAgICAqIGdlbmVyYXRlZCwgc28gdGhhdCBvYnNlcnZlcnMsIGRhdGEgYmluZGluZ3MgYW5kIGNvbXB1dGVkXG4gICAgICogcHJvcGVydGllcyB3YXRjaGluZyB0aGF0IHBhdGggY2FuIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBhcnJheSBpcyBwYXNzZWQgZGlyZWN0bHksICoqbm8gY2hhbmdlXG4gICAgICogbm90aWZpY2F0aW9uIGlzIGdlbmVyYXRlZCoqLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IGFycmF5T3JQYXRoIFBhdGggdG8gYXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGl0ZW1cbiAgICAgKiAgIChvciB0aGUgYXJyYXkgaXRzZWxmKS5cbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgaXRlbSByZW1vdmVkLlxuICAgICAqL1xuICAgIGFycmF5RGVsZXRlKGFycmF5T3JQYXRoLCBpdGVtKSB7XG4gICAgICBsZXQgaW5kZXg7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheU9yUGF0aCkpIHtcbiAgICAgICAgaW5kZXggPSBhcnJheU9yUGF0aC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybiBhcnJheU9yUGF0aC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYXJyID0gZ2V0JDAodGhpcywgYXJyYXlPclBhdGgpO1xuICAgICAgICBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNwbGljZShhcnJheU9yUGF0aCwgaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBsb2dnaW5nXG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmxvZ2AvYHdhcm5gL2BlcnJvcmAgYXMgb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWwgT25lIG9mICdsb2cnLCAnd2FybicsICdlcnJvcidcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfbG9nZ2VyKGxldmVsLCBhcmdzKSB7XG4gICAgICAvLyBhY2NlcHQgWydmb28nLCAnYmFyJ10gYW5kIFtbJ2ZvbycsICdiYXInXV1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgfVxuICAgICAgc3dpdGNoKGxldmVsKSB7XG4gICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgY29uc29sZVtsZXZlbF0oLi4uYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS5sb2dgIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfbG9nKC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMuX2xvZ2dlcignbG9nJywgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS53YXJuYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX3dhcm4oLi4uYXJncykge1xuICAgICAgdGhpcy5fbG9nZ2VyKCd3YXJuJywgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS5lcnJvcmAgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF9lcnJvciguLi5hcmdzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIoJ2Vycm9yJywgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIG1lc3NhZ2UgdXNpbmcgdGhlIGVsZW1lbnQgdHlwZSBhbiBhIG1ldGhvZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgdG8gYXNzb2NpYXRlIHdpdGggbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBmb3IgYGNvbnNvbGVgXG4gICAgICogICBsb2dnaW5nLlxuICAgICAqL1xuICAgIF9sb2dmKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBbJ1slczo6JXNdJywgdGhpcy5pcywgbWV0aG9kTmFtZSwgLi4uYXJnc107XG4gICAgfVxuXG4gIH1cblxuICBMZWdhY3lFbGVtZW50LnByb3RvdHlwZS5pcyA9ICcnO1xuXG4gIHJldHVybiBMZWdhY3lFbGVtZW50O1xuXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2xlZ2FjeS1lbGVtZW50LW1peGluLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge25hdGl2ZVNoYWRvdywgbmF0aXZlQ3NzVmFyaWFibGVzfSBmcm9tICcuL3N0eWxlLXNldHRpbmdzLmpzJztcbmltcG9ydCB7cGFyc2UsIHN0cmluZ2lmeSwgdHlwZXMsIFN0eWxlTm9kZX0gZnJvbSAnLi9jc3MtcGFyc2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQge01FRElBX01BVENIfSBmcm9tICcuL2NvbW1vbi1yZWdleC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8U3R5bGVOb2RlfSBydWxlc1xuICogQHBhcmFtIHtmdW5jdGlvbihTdHlsZU5vZGUpPX0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ3NzVGV4dCAocnVsZXMsIGNhbGxiYWNrKSB7XG4gIGlmICghcnVsZXMpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBydWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBydWxlcyA9IHBhcnNlKHJ1bGVzKTtcbiAgfVxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBmb3JFYWNoUnVsZShydWxlcywgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBzdHJpbmdpZnkocnVsZXMsIG5hdGl2ZUNzc1ZhcmlhYmxlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGb3JTdHlsZShzdHlsZSkge1xuICBpZiAoIXN0eWxlWydfX2Nzc1J1bGVzJ10gJiYgc3R5bGUudGV4dENvbnRlbnQpIHtcbiAgICBzdHlsZVsnX19jc3NSdWxlcyddID0gcGFyc2Uoc3R5bGUudGV4dENvbnRlbnQpO1xuICB9XG4gIHJldHVybiBzdHlsZVsnX19jc3NSdWxlcyddIHx8IG51bGw7XG59XG5cbi8vIFRlc3RzIGlmIGEgcnVsZSBpcyBhIGtleWZyYW1lcyBzZWxlY3Rvciwgd2hpY2ggbG9va3MgYWxtb3N0IGV4YWN0bHlcbi8vIGxpa2UgYSBub3JtYWwgc2VsZWN0b3IgYnV0IGlzIG5vdCAoaXQgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCBzY29waW5nXG4vLyBmb3IgZXhhbXBsZSkuXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBydWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNLZXlmcmFtZXNTZWxlY3RvcihydWxlKSB7XG4gIHJldHVybiBCb29sZWFuKHJ1bGVbJ3BhcmVudCddKSAmJlxuICBydWxlWydwYXJlbnQnXVsndHlwZSddID09PSB0eXBlcy5LRVlGUkFNRVNfUlVMRTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtGdW5jdGlvbj19IHN0eWxlUnVsZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0ga2V5ZnJhbWVzUnVsZUNhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvbmx5QWN0aXZlUnVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hSdWxlKG5vZGUsIHN0eWxlUnVsZUNhbGxiYWNrLCBrZXlmcmFtZXNSdWxlQ2FsbGJhY2ssIG9ubHlBY3RpdmVSdWxlcykge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHNraXBSdWxlcyA9IGZhbHNlO1xuICBsZXQgdHlwZSA9IG5vZGVbJ3R5cGUnXTtcbiAgaWYgKG9ubHlBY3RpdmVSdWxlcykge1xuICAgIGlmICh0eXBlID09PSB0eXBlcy5NRURJQV9SVUxFKSB7XG4gICAgICBsZXQgbWF0Y2hNZWRpYSA9IG5vZGVbJ3NlbGVjdG9yJ10ubWF0Y2goTUVESUFfTUFUQ0gpO1xuICAgICAgaWYgKG1hdGNoTWVkaWEpIHtcbiAgICAgICAgLy8gaWYgcnVsZSBpcyBhIG5vbiBtYXRjaGluZyBAbWVkaWEgcnVsZSwgc2tpcCBzdWJydWxlc1xuICAgICAgICBpZiAoIXdpbmRvdy5tYXRjaE1lZGlhKG1hdGNoTWVkaWFbMV0pLm1hdGNoZXMpIHtcbiAgICAgICAgICBza2lwUnVsZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0eXBlID09PSB0eXBlcy5TVFlMRV9SVUxFKSB7XG4gICAgc3R5bGVSdWxlQ2FsbGJhY2sobm9kZSk7XG4gIH0gZWxzZSBpZiAoa2V5ZnJhbWVzUnVsZUNhbGxiYWNrICYmXG4gICAgdHlwZSA9PT0gdHlwZXMuS0VZRlJBTUVTX1JVTEUpIHtcbiAgICBrZXlmcmFtZXNSdWxlQ2FsbGJhY2sobm9kZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gdHlwZXMuTUlYSU5fUlVMRSkge1xuICAgIHNraXBSdWxlcyA9IHRydWU7XG4gIH1cbiAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgaWYgKHIkICYmICFza2lwUnVsZXMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ciQubGVuZ3RoLCByOyAoaTxsKSAmJiAocj1yJFtpXSk7IGkrKykge1xuICAgICAgZm9yRWFjaFJ1bGUociwgc3R5bGVSdWxlQ2FsbGJhY2ssIGtleWZyYW1lc1J1bGVDYWxsYmFjaywgb25seUFjdGl2ZVJ1bGVzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gYWRkIGEgc3RyaW5nIG9mIGNzc1RleHQgdG8gdGhlIGRvY3VtZW50LlxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IG1vbmlrZXJcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IGNvbnRleHROb2RlXG4gKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlDc3MoY3NzVGV4dCwgbW9uaWtlciwgdGFyZ2V0LCBjb250ZXh0Tm9kZSkge1xuICBsZXQgc3R5bGUgPSBjcmVhdGVTY29wZVN0eWxlKGNzc1RleHQsIG1vbmlrZXIpO1xuICBhcHBseVN0eWxlKHN0eWxlLCB0YXJnZXQsIGNvbnRleHROb2RlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9uaWtlclxuICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjb3BlU3R5bGUoY3NzVGV4dCwgbW9uaWtlcikge1xuICBsZXQgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJykpO1xuICBpZiAobW9uaWtlcikge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnc2NvcGUnLCBtb25pa2VyKTtcbiAgfVxuICBzdHlsZS50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBUcmFjayB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgYWRkZWQgc3R5bGUgZm9yIHBsYWNpbmcgcGxhY2Vob2xkZXJzXG4gKiBAdHlwZSB7Tm9kZX1cbiAqL1xubGV0IGxhc3RIZWFkQXBwbHlOb2RlID0gbnVsbDtcblxuLy8gaW5zZXJ0IGEgY29tbWVudCBub2RlIGFzIGEgc3R5bGluZyBwb3NpdGlvbiBwbGFjZWhvbGRlci5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vbmlrZXJcbiAqIEByZXR1cm4geyFDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZVBsYWNlSG9sZGVyKG1vbmlrZXIpIHtcbiAgbGV0IHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnIFNoYWR5IERPTSBzdHlsZXMgZm9yICcgK1xuICAgIG1vbmlrZXIgKyAnICcpO1xuICBsZXQgYWZ0ZXIgPSBsYXN0SGVhZEFwcGx5Tm9kZSA/XG4gICAgbGFzdEhlYWRBcHBseU5vZGVbJ25leHRTaWJsaW5nJ10gOiBudWxsO1xuICBsZXQgc2NvcGUgPSBkb2N1bWVudC5oZWFkO1xuICBzY29wZS5pbnNlcnRCZWZvcmUocGxhY2VIb2xkZXIsIGFmdGVyIHx8IHNjb3BlLmZpcnN0Q2hpbGQpO1xuICBsYXN0SGVhZEFwcGx5Tm9kZSA9IHBsYWNlSG9sZGVyO1xuICByZXR1cm4gcGxhY2VIb2xkZXI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHBhcmFtIHs/Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0gez9Ob2RlfSBjb250ZXh0Tm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZShzdHlsZSwgdGFyZ2V0LCBjb250ZXh0Tm9kZSkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwgZG9jdW1lbnQuaGVhZDtcbiAgbGV0IGFmdGVyID0gKGNvbnRleHROb2RlICYmIGNvbnRleHROb2RlLm5leHRTaWJsaW5nKSB8fFxuICAgIHRhcmdldC5maXJzdENoaWxkO1xuICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBhZnRlcik7XG4gIGlmICghbGFzdEhlYWRBcHBseU5vZGUpIHtcbiAgICBsYXN0SGVhZEFwcGx5Tm9kZSA9IHN0eWxlO1xuICB9IGVsc2Uge1xuICAgIC8vIG9ubHkgdXBkYXRlIGxhc3RIZWFkQXBwbHlOb2RlIGlmIHRoZSBuZXcgc3R5bGUgaXMgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIG9sZCBsYXN0SGVhZEFwcGx5Tm9kZVxuICAgIGxldCBwb3NpdGlvbiA9IHN0eWxlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGxhc3RIZWFkQXBwbHlOb2RlKTtcbiAgICBpZiAocG9zaXRpb24gPT09IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKSB7XG4gICAgICBsYXN0SGVhZEFwcGx5Tm9kZSA9IHN0eWxlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBidWlsZFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RhcmdldGVkQnVpbGQoYnVpbGRUeXBlKSB7XG4gIHJldHVybiBuYXRpdmVTaGFkb3cgPyBidWlsZFR5cGUgPT09ICdzaGFkb3cnIDogYnVpbGRUeXBlID09PSAnc2hhZHknO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENzc0J1aWxkVHlwZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY3NzLWJ1aWxkJyk7XG59XG5cbi8qKlxuICogV2FsayBmcm9tIHRleHRbc3RhcnRdIG1hdGNoaW5nIHBhcmVucyBhbmRcbiAqIHJldHVybnMgcG9zaXRpb24gb2YgdGhlIG91dGVyIGVuZCBwYXJlblxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdQYXJlbih0ZXh0LCBzdGFydCkge1xuICBsZXQgbGV2ZWwgPSAwO1xuICBmb3IgKGxldCBpPXN0YXJ0LCBsPXRleHQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRleHRbaV0gPT09ICcoJykge1xuICAgICAgbGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09ICcpJykge1xuICAgICAgaWYgKC0tbGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZyl9IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayhzdHIsIGNhbGxiYWNrKSB7XG4gIC8vIGZpbmQgJ3ZhcignXG4gIGxldCBzdGFydCA9IHN0ci5pbmRleE9mKCd2YXIoJyk7XG4gIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAvLyBubyB2YXI/LCBldmVyeXRoaW5nIGlzIHByZWZpeFxuICAgIHJldHVybiBjYWxsYmFjayhzdHIsICcnLCAnJywgJycpO1xuICB9XG4gIC8vJHtwcmVmaXh9dmFyKCR7aW5uZXJ9KSR7c3VmZml4fVxuICBsZXQgZW5kID0gZmluZE1hdGNoaW5nUGFyZW4oc3RyLCBzdGFydCArIDMpO1xuICBsZXQgaW5uZXIgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0ICsgNCwgZW5kKTtcbiAgbGV0IHByZWZpeCA9IHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpO1xuICAvLyBzdWZmaXggbWF5IGhhdmUgb3RoZXIgdmFyaWFibGVzXG4gIGxldCBzdWZmaXggPSBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayhzdHIuc3Vic3RyaW5nKGVuZCArIDEpLCBjYWxsYmFjayk7XG4gIGxldCBjb21tYSA9IGlubmVyLmluZGV4T2YoJywnKTtcbiAgLy8gdmFsdWUgYW5kIGZhbGxiYWNrIGFyZ3Mgc2hvdWxkIGJlIHRyaW1tZWQgdG8gbWF0Y2ggaW4gcHJvcGVydHkgbG9va3VwXG4gIGlmIChjb21tYSA9PT0gLTEpIHtcbiAgICAvLyB2YXJpYWJsZSwgbm8gZmFsbGJhY2tcbiAgICByZXR1cm4gY2FsbGJhY2socHJlZml4LCBpbm5lci50cmltKCksICcnLCBzdWZmaXgpO1xuICB9XG4gIC8vIHZhcigke3ZhbHVlfSwke2ZhbGxiYWNrfSlcbiAgbGV0IHZhbHVlID0gaW5uZXIuc3Vic3RyaW5nKDAsIGNvbW1hKS50cmltKCk7XG4gIGxldCBmYWxsYmFjayA9IGlubmVyLnN1YnN0cmluZyhjb21tYSArIDEpLnRyaW0oKTtcbiAgcmV0dXJuIGNhbGxiYWNrKHByZWZpeCwgdmFsdWUsIGZhbGxiYWNrLCBzdWZmaXgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbGVtZW50Q2xhc3NSYXcoZWxlbWVudCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBzZXRBdHRyaWJ1dGUgcHJvdmlkZWQgYnkgU2hhZHlET00gd2hlbiBzZXRBdHRyaWJ1dGUgaXMgcGF0Y2hlZFxuICBpZiAobmF0aXZlU2hhZG93KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvd1snU2hhZHlET00nXVsnbmF0aXZlTWV0aG9kcyddWydzZXRBdHRyaWJ1dGUnXS5jYWxsKGVsZW1lbnQsICdjbGFzcycsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCB8IHtpczogc3RyaW5nLCBleHRlbmRzOiBzdHJpbmd9fSBlbGVtZW50XG4gKiBAcmV0dXJuIHt7aXM6IHN0cmluZywgdHlwZUV4dGVuc2lvbjogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElzRXh0ZW5kcyhlbGVtZW50KSB7XG4gIGxldCBsb2NhbE5hbWUgPSBlbGVtZW50Wydsb2NhbE5hbWUnXTtcbiAgbGV0IGlzID0gJycsIHR5cGVFeHRlbnNpb24gPSAnJztcbiAgLypcbiAgTk9URTogdGVjaG5pY2FsbHksIHRoaXMgY2FuIGJlIHdyb25nIGZvciBjZXJ0YWluIHN2ZyBlbGVtZW50c1xuICB3aXRoIGAtYCBpbiB0aGUgbmFtZSBsaWtlIGA8Zm9udC1mYWNlPmBcbiAgKi9cbiAgaWYgKGxvY2FsTmFtZSkge1xuICAgIGlmIChsb2NhbE5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGlzID0gbG9jYWxOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlRXh0ZW5zaW9uID0gbG9jYWxOYW1lO1xuICAgICAgaXMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lzJykpIHx8ICcnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpcyA9IC8qKiBAdHlwZSB7P30gKi8oZWxlbWVudCkuaXM7XG4gICAgdHlwZUV4dGVuc2lvbiA9IC8qKiBAdHlwZSB7P30gKi8oZWxlbWVudCkuZXh0ZW5kcztcbiAgfVxuICByZXR1cm4ge2lzLCB0eXBlRXh0ZW5zaW9ufTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXV0aWwuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0IHshT2JqZWN0PHN0cmluZywgIUhUTUxUZW1wbGF0ZUVsZW1lbnQ+fVxuICovXG5jb25zdCB0ZW1wbGF0ZU1hcCA9IHt9O1xuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy90ZW1wbGF0ZS1tYXAuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7UHJvbWlzZTx2b2lkPn0gKi9cbmxldCByZWFkeVByb21pc2UgPSBudWxsO1xuXG4vKiogQHR5cGUgez9mdW5jdGlvbig/ZnVuY3Rpb24oKSl9ICovXG5sZXQgd2hlblJlYWR5ID0gd2luZG93WydIVE1MSW1wb3J0cyddICYmIHdpbmRvd1snSFRNTEltcG9ydHMnXVsnd2hlblJlYWR5J10gfHwgbnVsbDtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbigpfSAqL1xubGV0IHJlc29sdmVGbjtcblxuLyoqXG4gKiBAcGFyYW0gez9mdW5jdGlvbigpfSBjYWxsYmFja1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkb2N1bWVudFdhaXQoY2FsbGJhY2spIHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aGVuUmVhZHkpIHtcbiAgICAgIHdoZW5SZWFkeShjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZWFkeVByb21pc2UpIHtcbiAgICAgICAgcmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtyZXNvbHZlRm4gPSByZXNvbHZlfSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgcmVzb2x2ZUZuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWFkeVByb21pc2UudGhlbihmdW5jdGlvbigpeyBjYWxsYmFjayAmJiBjYWxsYmFjaygpOyB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvZG9jdW1lbnQtd2FpdC5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGRvY3VtZW50V2FpdCBmcm9tICcuL2RvY3VtZW50LXdhaXQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtIVE1MU3R5bGVFbGVtZW50IHwge2dldFN0eWxlOiBmdW5jdGlvbigpOkhUTUxTdHlsZUVsZW1lbnR9fVxuICovXG5leHBvcnQgbGV0IEN1c3RvbVN0eWxlUHJvdmlkZXI7XG5cbmNvbnN0IFNFRU5fTUFSS0VSID0gJ19fc2VlbkJ5U2hhZHlDU1MnO1xuY29uc3QgQ0FDSEVEX1NUWUxFID0gJ19fc2hhZHlDU1NDYWNoZWRTdHlsZSc7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gKi9cbmxldCB0cmFuc2Zvcm1GbiA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKCl9ICovXG5sZXQgdmFsaWRhdGVGbiA9IG51bGw7XG5cbi8qKlxuVGhpcyBpbnRlcmZhY2UgaXMgcHJvdmlkZWQgdG8gYWRkIGRvY3VtZW50LWxldmVsIDxzdHlsZT4gZWxlbWVudHMgdG8gU2hhZHlDU1MgZm9yIHByb2Nlc3NpbmcuXG5UaGVzZSBzdHlsZXMgbXVzdCBiZSBwcm9jZXNzZWQgYnkgU2hhZHlDU1MgdG8gc2ltdWxhdGUgU2hhZG93Um9vdCB1cHBlci1ib3VuZCBlbmNhcHN1bGF0aW9uIGZyb20gb3V0c2lkZSBzdHlsZXNcbkluIGFkZGl0aW9uLCB0aGVzZSBzdHlsZXMgbWF5IGFsc28gbmVlZCB0byBiZSBwcm9jZXNzZWQgZm9yIEBhcHBseSBydWxlcyBhbmQgQ1NTIEN1c3RvbSBQcm9wZXJ0aWVzXG5cblRvIGFkZCBkb2N1bWVudC1sZXZlbCBzdHlsZXMgdG8gU2hhZHlDU1MsIG9uZSBjYW4gY2FsbCBgU2hhZHlDU1MuYWRkRG9jdW1lbnRTdHlsZShzdHlsZUVsZW1lbnQpYCBvciBgU2hhZHlDU1MuYWRkRG9jdW1lbnRTdHlsZSh7Z2V0U3R5bGU6ICgpID0+IHN0eWxlRWxlbWVudH0pYFxuXG5JbiBhZGRpdGlvbiwgaWYgdGhlIHByb2Nlc3MgdXNlZCB0byBkaXNjb3ZlciBkb2N1bWVudC1sZXZlbCBzdHlsZXMgY2FuIGJlIHN5bmNocm9ub3VzbHkgZmx1c2hlZCwgb25lIHNob3VsZCBzZXQgYFNoYWR5Q1NTLmRvY3VtZW50U3R5bGVGbHVzaGAuXG5UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gY2FsY3VsYXRpbmcgc3R5bGVzLlxuXG5BbiBleGFtcGxlIHVzYWdlIG9mIHRoZSBkb2N1bWVudC1sZXZlbCBzdHlsaW5nIGFwaSBjYW4gYmUgZm91bmQgaW4gYGV4YW1wbGVzL2RvY3VtZW50LXN0eWxlLWxpYi5qc2BcblxuQHVucmVzdHJpY3RlZFxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbVN0eWxlSW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+fSAqL1xuICAgIHRoaXNbJ2N1c3RvbVN0eWxlcyddID0gW107XG4gICAgdGhpc1snZW5xdWV1ZWQnXSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZSBhIHZhbGlkYXRpb24gZm9yIG5ldyBjdXN0b20gc3R5bGVzIHRvIGJhdGNoIHN0eWxlIHJlY2FsY3VsYXRpb25zXG4gICAqL1xuICBlbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uKCkge1xuICAgIGlmICh0aGlzWydlbnF1ZXVlZCddIHx8ICF2YWxpZGF0ZUZuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXNbJ2VucXVldWVkJ10gPSB0cnVlO1xuICAgIGRvY3VtZW50V2FpdCh2YWxpZGF0ZUZuKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAgICovXG4gIGFkZEN1c3RvbVN0eWxlKHN0eWxlKSB7XG4gICAgaWYgKCFzdHlsZVtTRUVOX01BUktFUl0pIHtcbiAgICAgIHN0eWxlW1NFRU5fTUFSS0VSXSA9IHRydWU7XG4gICAgICB0aGlzWydjdXN0b21TdHlsZXMnXS5wdXNoKHN0eWxlKTtcbiAgICAgIHRoaXMuZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshQ3VzdG9tU3R5bGVQcm92aWRlcn0gY3VzdG9tU3R5bGVcbiAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAgICovXG4gIGdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoY3VzdG9tU3R5bGUpIHtcbiAgICBpZiAoY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXSkge1xuICAgICAgcmV0dXJuIGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV07XG4gICAgfVxuICAgIGxldCBzdHlsZTtcbiAgICBpZiAoY3VzdG9tU3R5bGVbJ2dldFN0eWxlJ10pIHtcbiAgICAgIHN0eWxlID0gY3VzdG9tU3R5bGVbJ2dldFN0eWxlJ10oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUgPSBjdXN0b21TdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+fVxuICAgKi9cbiAgcHJvY2Vzc1N0eWxlcygpIHtcbiAgICBjb25zdCBjcyA9IHRoaXNbJ2N1c3RvbVN0eWxlcyddO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1c3RvbVN0eWxlID0gY3NbaV07XG4gICAgICBpZiAoY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGN1c3RvbVN0eWxlKTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAvLyBIVE1MSW1wb3J0cyBwb2x5ZmlsbCBtYXkgaGF2ZSBjbG9uZWQgdGhlIHN0eWxlIGludG8gdGhlIG1haW4gZG9jdW1lbnQsXG4gICAgICAgIC8vIHdoaWNoIGlzIHJlZmVyZW5jZWQgd2l0aCBfX2FwcGxpZWRFbGVtZW50LlxuICAgICAgICBjb25zdCBzdHlsZVRvVHJhbnNmb3JtID0gLyoqIEB0eXBlIHshSFRNTFN0eWxlRWxlbWVudH0gKi8oc3R5bGVbJ19fYXBwbGllZEVsZW1lbnQnXSB8fCBzdHlsZSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Gbikge1xuICAgICAgICAgIHRyYW5zZm9ybUZuKHN0eWxlVG9UcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0gPSBzdHlsZVRvVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3M7XG4gIH1cbn1cblxuQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlWydhZGRDdXN0b21TdHlsZSddID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLmFkZEN1c3RvbVN0eWxlO1xuQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlWydnZXRTdHlsZUZvckN1c3RvbVN0eWxlJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZTtcbkN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZVsncHJvY2Vzc1N0eWxlcyddID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLnByb2Nlc3NTdHlsZXM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZSwge1xuICAndHJhbnNmb3JtQ2FsbGJhY2snOiB7XG4gICAgLyoqIEByZXR1cm4gez9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCl9ICovXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUZuO1xuICAgIH0sXG4gICAgLyoqIEBwYXJhbSB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gZm4gKi9cbiAgICBzZXQoZm4pIHtcbiAgICAgIHRyYW5zZm9ybUZuID0gZm47XG4gICAgfVxuICB9LFxuICAndmFsaWRhdGVDYWxsYmFjayc6IHtcbiAgICAvKiogQHJldHVybiB7P2Z1bmN0aW9uKCl9ICovXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRm47XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbigpfSBmblxuICAgICAqIEB0aGlzIHtDdXN0b21TdHlsZUludGVyZmFjZX1cbiAgICAgKi9cbiAgICBzZXQoZm4pIHtcbiAgICAgIGxldCBuZWVkc0VucXVldWUgPSBmYWxzZTtcbiAgICAgIGlmICghdmFsaWRhdGVGbikge1xuICAgICAgICBuZWVkc0VucXVldWUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVGbiA9IGZuO1xuICAgICAgaWYgKG5lZWRzRW5xdWV1ZSkge1xuICAgICAgICB0aGlzLmVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICB9XG59KVxuXG4vKiogQHR5cGVkZWYge3tcbiAqIGN1c3RvbVN0eWxlczogIUFycmF5PCFDdXN0b21TdHlsZVByb3ZpZGVyPixcbiAqIGFkZEN1c3RvbVN0eWxlOiBmdW5jdGlvbighQ3VzdG9tU3R5bGVQcm92aWRlciksXG4gKiBnZXRTdHlsZUZvckN1c3RvbVN0eWxlOiBmdW5jdGlvbighQ3VzdG9tU3R5bGVQcm92aWRlcik6IEhUTUxTdHlsZUVsZW1lbnQsXG4gKiBmaW5kU3R5bGVzOiBmdW5jdGlvbigpLFxuICogdHJhbnNmb3JtQ2FsbGJhY2s6ID9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCksXG4gKiB2YWxpZGF0ZUNhbGxiYWNrOiA/ZnVuY3Rpb24oKVxuICogfX1cbiAqL1xuZXhwb3J0IGxldCBDdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCAqIGFzIGdlc3R1cmVzJDAgZnJvbSAnLi4vdXRpbHMvZ2VzdHVyZXMuanMnO1xuXG4vKipcbiAqIEBjb25zdCB7UG9seW1lci5HZXN0dXJlc31cbiAqL1xuY29uc3QgZ2VzdHVyZXMgPSBnZXN0dXJlcyQwO1xuXG5leHBvcnQgY29uc3QgR2VzdHVyZUV2ZW50TGlzdGVuZXJzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgKi9cbiAgY2xhc3MgR2VzdHVyZUV2ZW50TGlzdGVuZXJzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZ2VzdHVyZXMuYWRkTGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSkge1xuICAgICAgICBzdXBlci5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWdlc3R1cmVzLnJlbW92ZUxpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgc3VwZXIuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEdlc3R1cmVFdmVudExpc3RlbmVycztcblxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxubGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xubGV0IGJlZm9yZVJlbmRlclF1ZXVlID0gW107XG5sZXQgYWZ0ZXJSZW5kZXJRdWV1ZSA9IFtdO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcbiAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgLy8gYmVmb3JlIG5leHQgcmVuZGVyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICAvLyBhZnRlciB0aGUgcmVuZGVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJ1blF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hRdWV1ZShxdWV1ZSkge1xuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgY2FsbE1ldGhvZChxdWV1ZS5zaGlmdCgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBydW5RdWV1ZShxdWV1ZSkge1xuICBmb3IgKGxldCBpPTAsIGw9cXVldWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2FsbE1ldGhvZChxdWV1ZS5zaGlmdCgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsTWV0aG9kKGluZm8pIHtcbiAgY29uc3QgY29udGV4dCA9IGluZm9bMF07XG4gIGNvbnN0IGNhbGxiYWNrID0gaW5mb1sxXTtcbiAgY29uc3QgYXJncyA9IGluZm9bMl07XG4gIHRyeSB7XG4gICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgd2hpbGUgKGJlZm9yZVJlbmRlclF1ZXVlLmxlbmd0aCB8fCBhZnRlclJlbmRlclF1ZXVlLmxlbmd0aCkge1xuICAgIGZsdXNoUXVldWUoYmVmb3JlUmVuZGVyUXVldWUpO1xuICAgIGZsdXNoUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gIH1cbiAgc2NoZWR1bGVkID0gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVOZXh0UmVuZGVyKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gIGlmICghc2NoZWR1bGVkKSB7XG4gICAgc2NoZWR1bGUoKTtcbiAgfVxuICBiZWZvcmVSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJOZXh0UmVuZGVyKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gIGlmICghc2NoZWR1bGVkKSB7XG4gICAgc2NoZWR1bGUoKTtcbiAgfVxuICBhZnRlclJlbmRlclF1ZXVlLnB1c2goW2NvbnRleHQsIGNhbGxiYWNrLCBhcmdzXSk7XG59XG5cbmV4cG9ydCB7IGZsdXNoIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVTcGxpY2VzIH0gZnJvbSAnLi9hcnJheS1zcGxpY2UuanMnO1xuaW1wb3J0IHsgbWljcm9UYXNrIH0gZnJvbSAnLi9hc3luYy5qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBub2RlYCBpcyBhIHNsb3QgZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBOb2RlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGBub2RlYCBpcyBhIHNsb3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU2xvdChub2RlKSB7XG4gIHJldHVybiAobm9kZS5sb2NhbE5hbWUgPT09ICdzbG90Jyk7XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBsaXN0ZW5zIGZvciBjaGFuZ2VzIChhZGRpdGlvbnMgb3IgcmVtb3ZhbHMpIHRvXG4gKiBcImZsYXR0ZW5lZCBub2Rlc1wiIG9uIGEgZ2l2ZW4gYG5vZGVgLiBUaGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgY29uc2lzdHNcbiAqIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBgPHNsb3Q+YCBlbGVtZW50cyxcbiAqIHRoZSBleHBhbmRlZCBmbGF0dGVuZWQgbGlzdCBvZiBgYXNzaWduZWROb2Rlc2AuXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9ic2VydmVkIG5vZGUgaGFzIGNoaWxkcmVuIGA8YT48L2E+PHNsb3Q+PC9zbG90PjxiPjwvYj5gXG4gKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gKiBub2RlcyBsaXN0IGlzIGA8YT48L2E+PGRpdj48L2Rpdj48Yj48L2I+YC4gSWYgdGhlIGA8c2xvdD5gIGhhcyBvdGhlclxuICogYDxzbG90PmAgZWxlbWVudHMgYXNzaWduZWQgdG8gaXQsIHRoZXNlIGFyZSBmbGF0dGVuZWQgYXMgd2VsbC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgYGNhbGxiYWNrYCBpcyBjYWxsZWQgd2hlbmV2ZXIgYW55IGNoYW5nZSB0byB0aGlzIGxpc3RcbiAqIG9mIGZsYXR0ZW5lZCBub2RlcyBvY2N1cnMsIHdoZXJlIGFuIGFkZGl0aW9uIG9yIHJlbW92YWwgb2YgYSBub2RlIGlzXG4gKiBjb25zaWRlcmVkIGEgY2hhbmdlLiBUaGUgYGNhbGxiYWNrYCBpcyBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIGFuIG9iamVjdFxuICogY29udGFpbmluZyBhbiBhcnJheSBvZiBhbnkgYGFkZGVkTm9kZXNgIGFuZCBgcmVtb3ZlZE5vZGVzYC5cbiAqXG4gKiBOb3RlOiB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIGFzeW5jaHJvbm91cyB0byBhbnkgY2hhbmdlc1xuICogYXQgYSBtaWNyb3Rhc2sgY2hlY2twb2ludC4gVGhpcyBpcyBiZWNhdXNlIG9ic2VydmF0aW9uIGlzIHBlcmZvcm1lZCB1c2luZ1xuICogYE11dGF0aW9uT2JzZXJ2ZXJgIGFuZCB0aGUgYDxzbG90PmAgZWxlbWVudCdzIGBzbG90Y2hhbmdlYCBldmVudCB3aGljaFxuICogYXJlIGFzeW5jaHJvbm91cy5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ2xhc3MgdGhhdCBsaXN0ZW5zIGZvciBjaGFuZ2VzIChhZGRpdGlvbnMgb3IgcmVtb3ZhbHMpIHRvXG4gKiBcImZsYXR0ZW5lZCBub2Rlc1wiIG9uIGEgZ2l2ZW4gYG5vZGVgLlxuICovXG5jbGFzcyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIHtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgZm9yIHRoZSBnaXZlbiBgbm9kZWAuXG4gICAqIFRoaXMgbGlzdCBjb25zaXN0cyBvZiBhIG5vZGUncyBjaGlsZHJlbiBhbmQsIGZvciBhbnkgY2hpbGRyZW5cbiAgICogdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsIHRoZSBleHBhbmRlZCBmbGF0dGVuZWQgbGlzdCBvZiBgYXNzaWduZWROb2Rlc2AuXG4gICAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAgICogYW5kIHRoZSBgPHNsb3Q+YCBoYXMgb25lIGA8ZGl2PmAgYXNzaWduZWQgdG8gaXQsIHRoZW4gdGhlIGZsYXR0ZW5lZFxuICAgKiBub2RlcyBsaXN0IGlzIGA8YT48L2E+PGRpdj48L2Rpdj48Yj48L2I+YC4gSWYgdGhlIGA8c2xvdD5gIGhhcyBvdGhlclxuICAgKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxTbG90RWxlbWVudH0gbm9kZSBUaGUgbm9kZSBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgKi9cbiAgc3RhdGljIGdldEZsYXR0ZW5lZE5vZGVzKG5vZGUpIHtcbiAgICBpZiAoaXNTbG90KG5vZGUpKSB7XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MU2xvdEVsZW1lbnR9ICovIChub2RlKS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykubWFwKG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNTbG90KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqLyAobm9kZSkuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgICAgIH1cbiAgICAgIH0pLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXQgTm9kZSBvbiB3aGljaCB0byBsaXN0ZW4gZm9yIGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZXJlIGFyZSBhZGRpdGlvbnNcbiAgICogb3IgcmVtb3ZhbHMgZnJvbSB0aGUgdGFyZ2V0J3MgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMuXG4gICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAvKiogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAvKiogQHR5cGUge011dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLl9lZmZlY3RpdmVOb2RlcyA9IFtdO1xuICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKCl9ICovXG4gICAgdGhpcy5fYm91bmRTY2hlZHVsZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhbiBvYnNlcnZlci4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlblxuICAgKiBhIGBGbGF0dGVuZWROb2Rlc09ic2VydmVyYCBpcyBjcmVhdGVkLiBJdCBzaG91bGQgb25seSBiZSBjYWxsZWQgdG9cbiAgICogcmUtYWN0aXZhdGUgYW4gb2JzZXJ2ZXIgdGhhdCBoYXMgYmVlbiBkZWFjdGl2YXRlZCB2aWEgdGhlIGBkaXNjb25uZWN0YCBtZXRob2QuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIGlmIChpc1Nsb3QodGhpcy5fdGFyZ2V0KSkge1xuICAgICAgdGhpcy5fbGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saXN0ZW5TbG90cyh0aGlzLl90YXJnZXQuY2hpbGRyZW4pO1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSkge1xuICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPVxuICAgICAgICAgIFNoYWR5RE9NLm9ic2VydmVDaGlsZHJlbih0aGlzLl90YXJnZXQsIChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPVxuICAgICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5vYnNlcnZlKHRoaXMuX3RhcmdldCwge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBmbGF0dGVuZWQgbm9kZXMgb2JzZXJ2ZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogdGhlIG9ic2VydmVyIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCB3aGVuIGNoYW5nZXMgdG8gZmxhdHRlbmVkIG5vZGVzXG4gICAqIG9jY3VyLiBUaGUgYGNvbm5lY3RgIG1ldGhvZCBtYXkgYmUgc3Vic2VxdWVudGx5IGNhbGxlZCB0byByZWFjdGl2YXRlXG4gICAqIHRoZSBvYnNlcnZlci5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICB0aGlzLl91bmxpc3RlblNsb3RzKFt0aGlzLl90YXJnZXRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyh0aGlzLl90YXJnZXQuY2hpbGRyZW4pO1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgU2hhZHlET00udW5vYnNlcnZlQ2hpbGRyZW4odGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKTtcbiAgICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB9XG5cbiAgX3NjaGVkdWxlKCkge1xuICAgIGlmICghdGhpcy5fc2NoZWR1bGVkKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgbWljcm9UYXNrLnJ1bigoKSA9PiB0aGlzLmZsdXNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIF9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG5cbiAgX3Byb2Nlc3NTbG90TXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIGlmIChtdXRhdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbXV0YXRpb24gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgIGlmIChtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuU2xvdHMobXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11dGF0aW9uLnJlbW92ZWROb2Rlcykge1xuICAgICAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMobXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGVzIHRoZSBvYnNlcnZlciBjYXVzaW5nIGFueSBwZW5kaW5nIGNoYW5nZXMgdG8gYmUgaW1tZWRpYXRlbHlcbiAgICogZGVsaXZlcmVkIHRoZSBvYnNlcnZlciBjYWxsYmFjay4gQnkgZGVmYXVsdCB0aGVzZSBjaGFuZ2VzIGFyZSBkZWxpdmVyZWRcbiAgICogYXN5bmNocm9ub3VzbHkgYXQgdGhlIG5leHQgbWljcm90YXNrIGNoZWNrcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbnkgcGVuZGluZyBjaGFuZ2VzIGNhdXNlZCB0aGUgb2JzZXJ2ZXJcbiAgICogY2FsbGJhY2sgdG8gcnVuLlxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TaGFkeURPTSkge1xuICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NTbG90TXV0YXRpb25zKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICB9XG4gICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgbGV0IGluZm8gPSB7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGFkZGVkTm9kZXM6IFtdLFxuICAgICAgcmVtb3ZlZE5vZGVzOiBbXVxuICAgIH07XG4gICAgbGV0IG5ld05vZGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRGbGF0dGVuZWROb2Rlcyh0aGlzLl90YXJnZXQpO1xuICAgIGxldCBzcGxpY2VzID0gY2FsY3VsYXRlU3BsaWNlcyhuZXdOb2RlcyxcbiAgICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzKTtcbiAgICAvLyBwcm9jZXNzIHJlbW92YWxzXG4gICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgZm9yIChsZXQgaj0wLCBuOyAoaiA8IHMucmVtb3ZlZC5sZW5ndGgpICYmIChuPXMucmVtb3ZlZFtqXSk7IGorKykge1xuICAgICAgICBpbmZvLnJlbW92ZWROb2Rlcy5wdXNoKG4pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm9jZXNzIGFkZHNcbiAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqPXMuaW5kZXg7IGogPCBzLmluZGV4ICsgcy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgaW5mby5hZGRlZE5vZGVzLnB1c2gobmV3Tm9kZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1cGRhdGUgY2FjaGVcbiAgICB0aGlzLl9lZmZlY3RpdmVOb2RlcyA9IG5ld05vZGVzO1xuICAgIGxldCBkaWRGbHVzaCA9IGZhbHNlO1xuICAgIGlmIChpbmZvLmFkZGVkTm9kZXMubGVuZ3RoIHx8IGluZm8ucmVtb3ZlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgZGlkRmx1c2ggPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuX3RhcmdldCwgaW5mbyk7XG4gICAgfVxuICAgIHJldHVybiBkaWRGbHVzaDtcbiAgfVxuXG4gIF9saXN0ZW5TbG90cyhub2RlTGlzdCkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgaWYgKGlzU2xvdChuKSkge1xuICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLl9ib3VuZFNjaGVkdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdW5saXN0ZW5TbG90cyhub2RlTGlzdCkge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG5vZGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IG5vZGVMaXN0W2ldO1xuICAgICAgaWYgKGlzU2xvdChuKSkge1xuICAgICAgICBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nsb3RjaGFuZ2UnLCB0aGlzLl9ib3VuZFNjaGVkdWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgeyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxuZnVuY3Rpb24gbmV3U3BsaWNlKGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50KSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudFxuICB9O1xufVxuXG5jb25zdCBFRElUX0xFQVZFID0gMDtcbmNvbnN0IEVESVRfVVBEQVRFID0gMTtcbmNvbnN0IEVESVRfQUREID0gMjtcbmNvbnN0IEVESVRfREVMRVRFID0gMztcblxuLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyAqYmFzZWQqIG9uIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgTGV2ZW5zaHRlaW5cbi8vIFwiZWRpdFwiIGRpc3RhbmNlLiBUaGUgb25lIGNoYW5nZSBpcyB0aGF0IFwidXBkYXRlc1wiIGFyZSB0cmVhdGVkIGFzIHR3b1xuLy8gZWRpdHMgLSBub3Qgb25lLiBXaXRoIEFycmF5IHNwbGljZXMsIGFuIHVwZGF0ZSBpcyByZWFsbHkgYSBkZWxldGVcbi8vIGZvbGxvd2VkIGJ5IGFuIGFkZC4gQnkgcmV0YWluaW5nIHRoaXMsIHdlIG9wdGltaXplIGZvciBcImtlZXBpbmdcIiB0aGVcbi8vIG1heGltdW0gYXJyYXkgaXRlbXMgaW4gdGhlIG9yaWdpbmFsIGFycmF5LiBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgICd4eHh4MTIzJyAtPiAnMTIzeXl5eSdcbi8vXG4vLyBXaXRoIDEtZWRpdCB1cGRhdGVzLCB0aGUgc2hvcnRlc3QgcGF0aCB3b3VsZCBiZSBqdXN0IHRvIHVwZGF0ZSBhbGwgc2V2ZW5cbi8vIGNoYXJhY3RlcnMuIFdpdGggMi1lZGl0IHVwZGF0ZXMsIHdlIGRlbGV0ZSA0LCBsZWF2ZSAzLCBhbmQgYWRkIDQuIFRoaXNcbi8vIGxlYXZlcyB0aGUgc3Vic3RyaW5nICcxMjMnIGludGFjdC5cbmZ1bmN0aW9uIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgLy8gXCJEZWxldGlvblwiIGNvbHVtbnNcbiAgbGV0IHJvd0NvdW50ID0gb2xkRW5kIC0gb2xkU3RhcnQgKyAxO1xuICBsZXQgY29sdW1uQ291bnQgPSBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ICsgMTtcbiAgbGV0IGRpc3RhbmNlcyA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgLy8gXCJBZGRpdGlvblwiIHJvd3MuIEluaXRpYWxpemUgbnVsbCBjb2x1bW4uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGRpc3RhbmNlc1tpXSA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XG4gICAgZGlzdGFuY2VzW2ldWzBdID0gaTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgbnVsbCByb3dcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgaisrKVxuICAgIGRpc3RhbmNlc1swXVtqXSA9IGo7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPCBjb2x1bW5Db3VudDsgaisrKSB7XG4gICAgICBpZiAoZXF1YWxzKGN1cnJlbnRbY3VycmVudFN0YXJ0ICsgaiAtIDFdLCBvbGRbb2xkU3RhcnQgKyBpIC0gMV0pKVxuICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaSAtIDFdW2pdICsgMTtcbiAgICAgICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaV1baiAtIDFdICsgMTtcbiAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gbm9ydGggPCB3ZXN0ID8gbm9ydGggOiB3ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXN0YW5jZXM7XG59XG5cbi8vIFRoaXMgc3RhcnRzIGF0IHRoZSBmaW5hbCB3ZWlnaHQsIGFuZCB3YWxrcyBcImJhY2t3YXJkXCIgYnkgZmluZGluZ1xuLy8gdGhlIG1pbmltdW0gcHJldmlvdXMgd2VpZ2h0IHJlY3Vyc2l2ZWx5IHVudGlsIHRoZSBvcmlnaW4gb2YgdGhlIHdlaWdodFxuLy8gbWF0cml4LlxuZnVuY3Rpb24gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKGRpc3RhbmNlcykge1xuICBsZXQgaSA9IGRpc3RhbmNlcy5sZW5ndGggLSAxO1xuICBsZXQgaiA9IGRpc3RhbmNlc1swXS5sZW5ndGggLSAxO1xuICBsZXQgY3VycmVudCA9IGRpc3RhbmNlc1tpXVtqXTtcbiAgbGV0IGVkaXRzID0gW107XG4gIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgIGlmIChpID09IDApIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgai0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChqID09IDApIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgaS0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBub3J0aFdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1bal07XG4gICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2ldW2ogLSAxXTtcblxuICAgIGxldCBtaW47XG4gICAgaWYgKHdlc3QgPCBub3J0aClcbiAgICAgIG1pbiA9IHdlc3QgPCBub3J0aFdlc3QgPyB3ZXN0IDogbm9ydGhXZXN0O1xuICAgIGVsc2VcbiAgICAgIG1pbiA9IG5vcnRoIDwgbm9ydGhXZXN0ID8gbm9ydGggOiBub3J0aFdlc3Q7XG5cbiAgICBpZiAobWluID09IG5vcnRoV2VzdCkge1xuICAgICAgaWYgKG5vcnRoV2VzdCA9PSBjdXJyZW50KSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9MRUFWRSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfVVBEQVRFKTtcbiAgICAgICAgY3VycmVudCA9IG5vcnRoV2VzdDtcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGotLTtcbiAgICB9IGVsc2UgaWYgKG1pbiA9PSB3ZXN0KSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgIGktLTtcbiAgICAgIGN1cnJlbnQgPSB3ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgIGotLTtcbiAgICAgIGN1cnJlbnQgPSBub3J0aDtcbiAgICB9XG4gIH1cblxuICBlZGl0cy5yZXZlcnNlKCk7XG4gIHJldHVybiBlZGl0cztcbn1cblxuLyoqXG4gKiBTcGxpY2UgUHJvamVjdGlvbiBmdW5jdGlvbnM6XG4gKlxuICogQSBzcGxpY2UgbWFwIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGEgcHJldmlvdXMgYXJyYXkgb2YgaXRlbXNcbiAqIHdhcyB0cmFuc2Zvcm1lZCBpbnRvIGEgbmV3IGFycmF5IG9mIGl0ZW1zLiBDb25jZXB0dWFsbHkgaXQgaXMgYSBsaXN0IG9mXG4gKiB0dXBsZXMgb2ZcbiAqXG4gKiAgIDxpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudD5cbiAqXG4gKiB3aGljaCBhcmUga2VwdCBpbiBhc2NlbmRpbmcgaW5kZXggb3JkZXIgb2YuIFRoZSB0dXBsZSByZXByZXNlbnRzIHRoYXQgYXRcbiAqIHRoZSB8aW5kZXh8LCB8cmVtb3ZlZHwgc2VxdWVuY2Ugb2YgaXRlbXMgd2VyZSByZW1vdmVkLCBhbmQgY291bnRpbmcgZm9yd2FyZFxuICogZnJvbSB8aW5kZXh8LCB8YWRkZWRDb3VudHwgaXRlbXMgd2VyZSBhZGRlZC5cbiAqL1xuXG4vKipcbiAqIExhY2tpbmcgaW5kaXZpZHVhbCBzcGxpY2UgbXV0YXRpb24gaW5mb3JtYXRpb24sIHRoZSBtaW5pbWFsIHNldCBvZlxuICogc3BsaWNlcyBjYW4gYmUgc3ludGhlc2l6ZWQgZ2l2ZW4gdGhlIHByZXZpb3VzIHN0YXRlIGFuZCBmaW5hbCBzdGF0ZSBvZiBhblxuICogYXJyYXkuIFRoZSBiYXNpYyBhcHByb2FjaCBpcyB0byBjYWxjdWxhdGUgdGhlIGVkaXQgZGlzdGFuY2UgbWF0cml4IGFuZFxuICogY2hvb3NlIHRoZSBzaG9ydGVzdCBwYXRoIHRocm91Z2ggaXQuXG4gKlxuICogQ29tcGxleGl0eTogTyhsICogcClcbiAqICAgbDogVGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBhcnJheVxuICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBvbGQgYXJyYXlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjdXJyZW50IFRoZSBjdXJyZW50IFwiY2hhbmdlZFwiIGFycmF5IGZvciB3aGljaCB0b1xuICogY2FsY3VsYXRlIHNwbGljZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRFbmQgRW5kaW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtBcnJheX0gb2xkIFRoZSBvcmlnaW5hbCBcInVuY2hhbmdlZFwiIGFycmF5IHRvIGNvbXBhcmUgYGN1cnJlbnRgXG4gKiBhZ2FpbnN0IHRvIGRldGVybWluZSBzcGxpY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9sZFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgb2xkYCBhcnJheSBmb3JcbiAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2xkRW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3BsaWNlIHJlY29yZCBvYmplY3RzLiBFYWNoIG9mIHRoZXNlXG4gKiBjb250YWluczogYGluZGV4YCB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIHNwbGljZSBvY2N1cnJlZDsgYHJlbW92ZWRgXG4gKiB0aGUgYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgbG9jYXRpb247IGBhZGRlZENvdW50YCB0aGUgbnVtYmVyXG4gKiBvZiBpdGVtcyBhZGRlZCBhdCB0aGlzIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBjYWxjU3BsaWNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gIGxldCBwcmVmaXhDb3VudCA9IDA7XG4gIGxldCBzdWZmaXhDb3VudCA9IDA7XG4gIGxldCBzcGxpY2U7XG5cbiAgbGV0IG1pbkxlbmd0aCA9IE1hdGgubWluKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQsIG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgaWYgKGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZFN0YXJ0ID09IDApXG4gICAgcHJlZml4Q291bnQgPSBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGgpO1xuXG4gIGlmIChjdXJyZW50RW5kID09IGN1cnJlbnQubGVuZ3RoICYmIG9sZEVuZCA9PSBvbGQubGVuZ3RoKVxuICAgIHN1ZmZpeENvdW50ID0gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoIC0gcHJlZml4Q291bnQpO1xuXG4gIGN1cnJlbnRTdGFydCArPSBwcmVmaXhDb3VudDtcbiAgb2xkU3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gIGN1cnJlbnRFbmQgLT0gc3VmZml4Q291bnQ7XG4gIG9sZEVuZCAtPSBzdWZmaXhDb3VudDtcblxuICBpZiAoY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZEVuZCAtIG9sZFN0YXJ0ID09IDApXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmIChjdXJyZW50U3RhcnQgPT0gY3VycmVudEVuZCkge1xuICAgIHNwbGljZSA9IG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCAwKTtcbiAgICB3aGlsZSAob2xkU3RhcnQgPCBvbGRFbmQpXG4gICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRTdGFydCsrXSk7XG5cbiAgICByZXR1cm4gWyBzcGxpY2UgXTtcbiAgfSBlbHNlIGlmIChvbGRTdGFydCA9PSBvbGRFbmQpXG4gICAgcmV0dXJuIFsgbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQpIF07XG5cbiAgbGV0IG9wcyA9IHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhcbiAgICAgIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSk7XG5cbiAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICBsZXQgc3BsaWNlcyA9IFtdO1xuICBsZXQgaW5kZXggPSBjdXJyZW50U3RhcnQ7XG4gIGxldCBvbGRJbmRleCA9IG9sZFN0YXJ0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaChvcHNbaV0pIHtcbiAgICAgIGNhc2UgRURJVF9MRUFWRTpcbiAgICAgICAgaWYgKHNwbGljZSkge1xuICAgICAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgICAgICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFRElUX1VQREFURTpcbiAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9BREQ6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFRElUX0RFTEVURTpcbiAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNwbGljZSkge1xuICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICB9XG4gIHJldHVybiBzcGxpY2VzO1xufVxuXG5mdW5jdGlvbiBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFyY2hMZW5ndGg7IGkrKylcbiAgICBpZiAoIWVxdWFscyhjdXJyZW50W2ldLCBvbGRbaV0pKVxuICAgICAgcmV0dXJuIGk7XG4gIHJldHVybiBzZWFyY2hMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICBsZXQgaW5kZXgxID0gY3VycmVudC5sZW5ndGg7XG4gIGxldCBpbmRleDIgPSBvbGQubGVuZ3RoO1xuICBsZXQgY291bnQgPSAwO1xuICB3aGlsZSAoY291bnQgPCBzZWFyY2hMZW5ndGggJiYgZXF1YWxzKGN1cnJlbnRbLS1pbmRleDFdLCBvbGRbLS1pbmRleDJdKSlcbiAgICBjb3VudCsrO1xuXG4gIHJldHVybiBjb3VudDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU3BsaWNlcyhjdXJyZW50LCBwcmV2aW91cykge1xuICByZXR1cm4gY2FsY1NwbGljZXMoY3VycmVudCwgMCwgY3VycmVudC5sZW5ndGgsIHByZXZpb3VzLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKSB7XG4gIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHByZXZpb3VzVmFsdWU7XG59XG5cbmV4cG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuXG4gICAgICAvKiBNYXRlcmlhbCBEZXNpZ24gY29sb3IgcGFsZXR0ZSBmb3IgR29vZ2xlIHByb2R1Y3RzICovXG5cbiAgICAgIC0tZ29vZ2xlLXJlZC0xMDA6ICNmNGM3YzM7XG4gICAgICAtLWdvb2dsZS1yZWQtMzAwOiAjZTY3YzczO1xuICAgICAgLS1nb29nbGUtcmVkLTUwMDogI2RiNDQzNztcbiAgICAgIC0tZ29vZ2xlLXJlZC03MDA6ICNjNTM5Mjk7XG5cbiAgICAgIC0tZ29vZ2xlLWJsdWUtMTAwOiAjYzZkYWZjO1xuICAgICAgLS1nb29nbGUtYmx1ZS0zMDA6ICM3YmFhZjc7XG4gICAgICAtLWdvb2dsZS1ibHVlLTUwMDogIzQyODVmNDtcbiAgICAgIC0tZ29vZ2xlLWJsdWUtNzAwOiAjMzM2N2Q2O1xuXG4gICAgICAtLWdvb2dsZS1ncmVlbi0xMDA6ICNiN2UxY2Q7XG4gICAgICAtLWdvb2dsZS1ncmVlbi0zMDA6ICM1N2JiOGE7XG4gICAgICAtLWdvb2dsZS1ncmVlbi01MDA6ICMwZjlkNTg7XG4gICAgICAtLWdvb2dsZS1ncmVlbi03MDA6ICMwYjgwNDM7XG5cbiAgICAgIC0tZ29vZ2xlLXllbGxvdy0xMDA6ICNmY2U4YjI7XG4gICAgICAtLWdvb2dsZS15ZWxsb3ctMzAwOiAjZjdjYjRkO1xuICAgICAgLS1nb29nbGUteWVsbG93LTUwMDogI2Y0YjQwMDtcbiAgICAgIC0tZ29vZ2xlLXllbGxvdy03MDA6ICNmMDkzMDA7XG5cbiAgICAgIC0tZ29vZ2xlLWdyZXktMTAwOiAjZjVmNWY1O1xuICAgICAgLS1nb29nbGUtZ3JleS0zMDA6ICNlMGUwZTA7XG4gICAgICAtLWdvb2dsZS1ncmV5LTUwMDogIzllOWU5ZTtcbiAgICAgIC0tZ29vZ2xlLWdyZXktNzAwOiAjNjE2MTYxO1xuXG4gICAgICAvKiBNYXRlcmlhbCBEZXNpZ24gY29sb3IgcGFsZXR0ZSBmcm9tIG9ubGluZSBzcGVjIGRvY3VtZW50ICovXG5cbiAgICAgIC0tcGFwZXItcmVkLTUwOiAjZmZlYmVlO1xuICAgICAgLS1wYXBlci1yZWQtMTAwOiAjZmZjZGQyO1xuICAgICAgLS1wYXBlci1yZWQtMjAwOiAjZWY5YTlhO1xuICAgICAgLS1wYXBlci1yZWQtMzAwOiAjZTU3MzczO1xuICAgICAgLS1wYXBlci1yZWQtNDAwOiAjZWY1MzUwO1xuICAgICAgLS1wYXBlci1yZWQtNTAwOiAjZjQ0MzM2O1xuICAgICAgLS1wYXBlci1yZWQtNjAwOiAjZTUzOTM1O1xuICAgICAgLS1wYXBlci1yZWQtNzAwOiAjZDMyZjJmO1xuICAgICAgLS1wYXBlci1yZWQtODAwOiAjYzYyODI4O1xuICAgICAgLS1wYXBlci1yZWQtOTAwOiAjYjcxYzFjO1xuICAgICAgLS1wYXBlci1yZWQtYTEwMDogI2ZmOGE4MDtcbiAgICAgIC0tcGFwZXItcmVkLWEyMDA6ICNmZjUyNTI7XG4gICAgICAtLXBhcGVyLXJlZC1hNDAwOiAjZmYxNzQ0O1xuICAgICAgLS1wYXBlci1yZWQtYTcwMDogI2Q1MDAwMDtcblxuICAgICAgLS1wYXBlci1waW5rLTUwOiAjZmNlNGVjO1xuICAgICAgLS1wYXBlci1waW5rLTEwMDogI2Y4YmJkMDtcbiAgICAgIC0tcGFwZXItcGluay0yMDA6ICNmNDhmYjE7XG4gICAgICAtLXBhcGVyLXBpbmstMzAwOiAjZjA2MjkyO1xuICAgICAgLS1wYXBlci1waW5rLTQwMDogI2VjNDA3YTtcbiAgICAgIC0tcGFwZXItcGluay01MDA6ICNlOTFlNjM7XG4gICAgICAtLXBhcGVyLXBpbmstNjAwOiAjZDgxYjYwO1xuICAgICAgLS1wYXBlci1waW5rLTcwMDogI2MyMTg1YjtcbiAgICAgIC0tcGFwZXItcGluay04MDA6ICNhZDE0NTc7XG4gICAgICAtLXBhcGVyLXBpbmstOTAwOiAjODgwZTRmO1xuICAgICAgLS1wYXBlci1waW5rLWExMDA6ICNmZjgwYWI7XG4gICAgICAtLXBhcGVyLXBpbmstYTIwMDogI2ZmNDA4MTtcbiAgICAgIC0tcGFwZXItcGluay1hNDAwOiAjZjUwMDU3O1xuICAgICAgLS1wYXBlci1waW5rLWE3MDA6ICNjNTExNjI7XG5cbiAgICAgIC0tcGFwZXItcHVycGxlLTUwOiAjZjNlNWY1O1xuICAgICAgLS1wYXBlci1wdXJwbGUtMTAwOiAjZTFiZWU3O1xuICAgICAgLS1wYXBlci1wdXJwbGUtMjAwOiAjY2U5M2Q4O1xuICAgICAgLS1wYXBlci1wdXJwbGUtMzAwOiAjYmE2OGM4O1xuICAgICAgLS1wYXBlci1wdXJwbGUtNDAwOiAjYWI0N2JjO1xuICAgICAgLS1wYXBlci1wdXJwbGUtNTAwOiAjOWMyN2IwO1xuICAgICAgLS1wYXBlci1wdXJwbGUtNjAwOiAjOGUyNGFhO1xuICAgICAgLS1wYXBlci1wdXJwbGUtNzAwOiAjN2IxZmEyO1xuICAgICAgLS1wYXBlci1wdXJwbGUtODAwOiAjNmExYjlhO1xuICAgICAgLS1wYXBlci1wdXJwbGUtOTAwOiAjNGExNDhjO1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTEwMDogI2VhODBmYztcbiAgICAgIC0tcGFwZXItcHVycGxlLWEyMDA6ICNlMDQwZmI7XG4gICAgICAtLXBhcGVyLXB1cnBsZS1hNDAwOiAjZDUwMGY5O1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTcwMDogI2FhMDBmZjtcblxuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS01MDogI2VkZTdmNjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtMTAwOiAjZDFjNGU5O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS0yMDA6ICNiMzlkZGI7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTMwMDogIzk1NzVjZDtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNDAwOiAjN2U1N2MyO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS01MDA6ICM2NzNhYjc7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTYwMDogIzVlMzViMTtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNzAwOiAjNTEyZGE4O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS04MDA6ICM0NTI3YTA7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTkwMDogIzMxMWI5MjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTEwMDogI2IzODhmZjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTIwMDogIzdjNGRmZjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTQwMDogIzY1MWZmZjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTcwMDogIzYyMDBlYTtcblxuICAgICAgLS1wYXBlci1pbmRpZ28tNTA6ICNlOGVhZjY7XG4gICAgICAtLXBhcGVyLWluZGlnby0xMDA6ICNjNWNhZTk7XG4gICAgICAtLXBhcGVyLWluZGlnby0yMDA6ICM5ZmE4ZGE7XG4gICAgICAtLXBhcGVyLWluZGlnby0zMDA6ICM3OTg2Y2I7XG4gICAgICAtLXBhcGVyLWluZGlnby00MDA6ICM1YzZiYzA7XG4gICAgICAtLXBhcGVyLWluZGlnby01MDA6ICMzZjUxYjU7XG4gICAgICAtLXBhcGVyLWluZGlnby02MDA6ICMzOTQ5YWI7XG4gICAgICAtLXBhcGVyLWluZGlnby03MDA6ICMzMDNmOWY7XG4gICAgICAtLXBhcGVyLWluZGlnby04MDA6ICMyODM1OTM7XG4gICAgICAtLXBhcGVyLWluZGlnby05MDA6ICMxYTIzN2U7XG4gICAgICAtLXBhcGVyLWluZGlnby1hMTAwOiAjOGM5ZWZmO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTIwMDogIzUzNmRmZTtcbiAgICAgIC0tcGFwZXItaW5kaWdvLWE0MDA6ICMzZDVhZmU7XG4gICAgICAtLXBhcGVyLWluZGlnby1hNzAwOiAjMzA0ZmZlO1xuXG4gICAgICAtLXBhcGVyLWJsdWUtNTA6ICNlM2YyZmQ7XG4gICAgICAtLXBhcGVyLWJsdWUtMTAwOiAjYmJkZWZiO1xuICAgICAgLS1wYXBlci1ibHVlLTIwMDogIzkwY2FmOTtcbiAgICAgIC0tcGFwZXItYmx1ZS0zMDA6ICM2NGI1ZjY7XG4gICAgICAtLXBhcGVyLWJsdWUtNDAwOiAjNDJhNWY1O1xuICAgICAgLS1wYXBlci1ibHVlLTUwMDogIzIxOTZmMztcbiAgICAgIC0tcGFwZXItYmx1ZS02MDA6ICMxZTg4ZTU7XG4gICAgICAtLXBhcGVyLWJsdWUtNzAwOiAjMTk3NmQyO1xuICAgICAgLS1wYXBlci1ibHVlLTgwMDogIzE1NjVjMDtcbiAgICAgIC0tcGFwZXItYmx1ZS05MDA6ICMwZDQ3YTE7XG4gICAgICAtLXBhcGVyLWJsdWUtYTEwMDogIzgyYjFmZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1hMjAwOiAjNDQ4YWZmO1xuICAgICAgLS1wYXBlci1ibHVlLWE0MDA6ICMyOTc5ZmY7XG4gICAgICAtLXBhcGVyLWJsdWUtYTcwMDogIzI5NjJmZjtcblxuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTUwOiAjZTFmNWZlO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTEwMDogI2IzZTVmYztcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS0yMDA6ICM4MWQ0ZmE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtMzAwOiAjNGZjM2Y3O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTQwMDogIzI5YjZmNjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS01MDA6ICMwM2E5ZjQ7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNjAwOiAjMDM5YmU1O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTcwMDogIzAyODhkMTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS04MDA6ICMwMjc3YmQ7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtOTAwOiAjMDE1NzliO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWExMDA6ICM4MGQ4ZmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtYTIwMDogIzQwYzRmZjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hNDAwOiAjMDBiMGZmO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWE3MDA6ICMwMDkxZWE7XG5cbiAgICAgIC0tcGFwZXItY3lhbi01MDogI2UwZjdmYTtcbiAgICAgIC0tcGFwZXItY3lhbi0xMDA6ICNiMmViZjI7XG4gICAgICAtLXBhcGVyLWN5YW4tMjAwOiAjODBkZWVhO1xuICAgICAgLS1wYXBlci1jeWFuLTMwMDogIzRkZDBlMTtcbiAgICAgIC0tcGFwZXItY3lhbi00MDA6ICMyNmM2ZGE7XG4gICAgICAtLXBhcGVyLWN5YW4tNTAwOiAjMDBiY2Q0O1xuICAgICAgLS1wYXBlci1jeWFuLTYwMDogIzAwYWNjMTtcbiAgICAgIC0tcGFwZXItY3lhbi03MDA6ICMwMDk3YTc7XG4gICAgICAtLXBhcGVyLWN5YW4tODAwOiAjMDA4MzhmO1xuICAgICAgLS1wYXBlci1jeWFuLTkwMDogIzAwNjA2NDtcbiAgICAgIC0tcGFwZXItY3lhbi1hMTAwOiAjODRmZmZmO1xuICAgICAgLS1wYXBlci1jeWFuLWEyMDA6ICMxOGZmZmY7XG4gICAgICAtLXBhcGVyLWN5YW4tYTQwMDogIzAwZTVmZjtcbiAgICAgIC0tcGFwZXItY3lhbi1hNzAwOiAjMDBiOGQ0O1xuXG4gICAgICAtLXBhcGVyLXRlYWwtNTA6ICNlMGYyZjE7XG4gICAgICAtLXBhcGVyLXRlYWwtMTAwOiAjYjJkZmRiO1xuICAgICAgLS1wYXBlci10ZWFsLTIwMDogIzgwY2JjNDtcbiAgICAgIC0tcGFwZXItdGVhbC0zMDA6ICM0ZGI2YWM7XG4gICAgICAtLXBhcGVyLXRlYWwtNDAwOiAjMjZhNjlhO1xuICAgICAgLS1wYXBlci10ZWFsLTUwMDogIzAwOTY4ODtcbiAgICAgIC0tcGFwZXItdGVhbC02MDA6ICMwMDg5N2I7XG4gICAgICAtLXBhcGVyLXRlYWwtNzAwOiAjMDA3OTZiO1xuICAgICAgLS1wYXBlci10ZWFsLTgwMDogIzAwNjk1YztcbiAgICAgIC0tcGFwZXItdGVhbC05MDA6ICMwMDRkNDA7XG4gICAgICAtLXBhcGVyLXRlYWwtYTEwMDogI2E3ZmZlYjtcbiAgICAgIC0tcGFwZXItdGVhbC1hMjAwOiAjNjRmZmRhO1xuICAgICAgLS1wYXBlci10ZWFsLWE0MDA6ICMxZGU5YjY7XG4gICAgICAtLXBhcGVyLXRlYWwtYTcwMDogIzAwYmZhNTtcblxuICAgICAgLS1wYXBlci1ncmVlbi01MDogI2U4ZjVlOTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tMTAwOiAjYzhlNmM5O1xuICAgICAgLS1wYXBlci1ncmVlbi0yMDA6ICNhNWQ2YTc7XG4gICAgICAtLXBhcGVyLWdyZWVuLTMwMDogIzgxYzc4NDtcbiAgICAgIC0tcGFwZXItZ3JlZW4tNDAwOiAjNjZiYjZhO1xuICAgICAgLS1wYXBlci1ncmVlbi01MDA6ICM0Y2FmNTA7XG4gICAgICAtLXBhcGVyLWdyZWVuLTYwMDogIzQzYTA0NztcbiAgICAgIC0tcGFwZXItZ3JlZW4tNzAwOiAjMzg4ZTNjO1xuICAgICAgLS1wYXBlci1ncmVlbi04MDA6ICMyZTdkMzI7XG4gICAgICAtLXBhcGVyLWdyZWVuLTkwMDogIzFiNWUyMDtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTEwMDogI2I5ZjZjYTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTIwMDogIzY5ZjBhZTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTQwMDogIzAwZTY3NjtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTcwMDogIzAwYzg1MztcblxuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi01MDogI2YxZjhlOTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tMTAwOiAjZGNlZGM4O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi0yMDA6ICNjNWUxYTU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTMwMDogI2FlZDU4MTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNDAwOiAjOWNjYzY1O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi01MDA6ICM4YmMzNGE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTYwMDogIzdjYjM0MjtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNzAwOiAjNjg5ZjM4O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi04MDA6ICM1NThiMmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTkwMDogIzMzNjkxZTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTEwMDogI2NjZmY5MDtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTIwMDogI2IyZmY1OTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTQwMDogIzc2ZmYwMztcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTcwMDogIzY0ZGQxNztcblxuICAgICAgLS1wYXBlci1saW1lLTUwOiAjZjlmYmU3O1xuICAgICAgLS1wYXBlci1saW1lLTEwMDogI2YwZjRjMztcbiAgICAgIC0tcGFwZXItbGltZS0yMDA6ICNlNmVlOWM7XG4gICAgICAtLXBhcGVyLWxpbWUtMzAwOiAjZGNlNzc1O1xuICAgICAgLS1wYXBlci1saW1lLTQwMDogI2Q0ZTE1NztcbiAgICAgIC0tcGFwZXItbGltZS01MDA6ICNjZGRjMzk7XG4gICAgICAtLXBhcGVyLWxpbWUtNjAwOiAjYzBjYTMzO1xuICAgICAgLS1wYXBlci1saW1lLTcwMDogI2FmYjQyYjtcbiAgICAgIC0tcGFwZXItbGltZS04MDA6ICM5ZTlkMjQ7XG4gICAgICAtLXBhcGVyLWxpbWUtOTAwOiAjODI3NzE3O1xuICAgICAgLS1wYXBlci1saW1lLWExMDA6ICNmNGZmODE7XG4gICAgICAtLXBhcGVyLWxpbWUtYTIwMDogI2VlZmY0MTtcbiAgICAgIC0tcGFwZXItbGltZS1hNDAwOiAjYzZmZjAwO1xuICAgICAgLS1wYXBlci1saW1lLWE3MDA6ICNhZWVhMDA7XG5cbiAgICAgIC0tcGFwZXIteWVsbG93LTUwOiAjZmZmZGU3O1xuICAgICAgLS1wYXBlci15ZWxsb3ctMTAwOiAjZmZmOWM0O1xuICAgICAgLS1wYXBlci15ZWxsb3ctMjAwOiAjZmZmNTlkO1xuICAgICAgLS1wYXBlci15ZWxsb3ctMzAwOiAjZmZmMTc2O1xuICAgICAgLS1wYXBlci15ZWxsb3ctNDAwOiAjZmZlZTU4O1xuICAgICAgLS1wYXBlci15ZWxsb3ctNTAwOiAjZmZlYjNiO1xuICAgICAgLS1wYXBlci15ZWxsb3ctNjAwOiAjZmRkODM1O1xuICAgICAgLS1wYXBlci15ZWxsb3ctNzAwOiAjZmJjMDJkO1xuICAgICAgLS1wYXBlci15ZWxsb3ctODAwOiAjZjlhODI1O1xuICAgICAgLS1wYXBlci15ZWxsb3ctOTAwOiAjZjU3ZjE3O1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTEwMDogI2ZmZmY4ZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LWEyMDA6ICNmZmZmMDA7XG4gICAgICAtLXBhcGVyLXllbGxvdy1hNDAwOiAjZmZlYTAwO1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTcwMDogI2ZmZDYwMDtcblxuICAgICAgLS1wYXBlci1hbWJlci01MDogI2ZmZjhlMTtcbiAgICAgIC0tcGFwZXItYW1iZXItMTAwOiAjZmZlY2IzO1xuICAgICAgLS1wYXBlci1hbWJlci0yMDA6ICNmZmUwODI7XG4gICAgICAtLXBhcGVyLWFtYmVyLTMwMDogI2ZmZDU0ZjtcbiAgICAgIC0tcGFwZXItYW1iZXItNDAwOiAjZmZjYTI4O1xuICAgICAgLS1wYXBlci1hbWJlci01MDA6ICNmZmMxMDc7XG4gICAgICAtLXBhcGVyLWFtYmVyLTYwMDogI2ZmYjMwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItNzAwOiAjZmZhMDAwO1xuICAgICAgLS1wYXBlci1hbWJlci04MDA6ICNmZjhmMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLTkwMDogI2ZmNmYwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItYTEwMDogI2ZmZTU3ZjtcbiAgICAgIC0tcGFwZXItYW1iZXItYTIwMDogI2ZmZDc0MDtcbiAgICAgIC0tcGFwZXItYW1iZXItYTQwMDogI2ZmYzQwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItYTcwMDogI2ZmYWIwMDtcblxuICAgICAgLS1wYXBlci1vcmFuZ2UtNTA6ICNmZmYzZTA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS0xMDA6ICNmZmUwYjI7XG4gICAgICAtLXBhcGVyLW9yYW5nZS0yMDA6ICNmZmNjODA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS0zMDA6ICNmZmI3NGQ7XG4gICAgICAtLXBhcGVyLW9yYW5nZS00MDA6ICNmZmE3MjY7XG4gICAgICAtLXBhcGVyLW9yYW5nZS01MDA6ICNmZjk4MDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS02MDA6ICNmYjhjMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS03MDA6ICNmNTdjMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS04MDA6ICNlZjZjMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS05MDA6ICNlNjUxMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hMTAwOiAjZmZkMTgwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTIwMDogI2ZmYWI0MDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLWE0MDA6ICNmZjkxMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hNzAwOiAjZmY2NTAwO1xuXG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTUwOiAjZmJlOWU3O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS0xMDA6ICNmZmNjYmM7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTIwMDogI2ZmYWI5MTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtMzAwOiAjZmY4YTY1O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS00MDA6ICNmZjcwNDM7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTUwMDogI2ZmNTcyMjtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNjAwOiAjZjQ1MTFlO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS03MDA6ICNlNjRhMTk7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTgwMDogI2Q4NDMxNTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtOTAwOiAjYmYzNjBjO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hMTAwOiAjZmY5ZTgwO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hMjAwOiAjZmY2ZTQwO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hNDAwOiAjZmYzZDAwO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwOiAjZGQyYzAwO1xuXG4gICAgICAtLXBhcGVyLWJyb3duLTUwOiAjZWZlYmU5O1xuICAgICAgLS1wYXBlci1icm93bi0xMDA6ICNkN2NjYzg7XG4gICAgICAtLXBhcGVyLWJyb3duLTIwMDogI2JjYWFhNDtcbiAgICAgIC0tcGFwZXItYnJvd24tMzAwOiAjYTE4ODdmO1xuICAgICAgLS1wYXBlci1icm93bi00MDA6ICM4ZDZlNjM7XG4gICAgICAtLXBhcGVyLWJyb3duLTUwMDogIzc5NTU0ODtcbiAgICAgIC0tcGFwZXItYnJvd24tNjAwOiAjNmQ0YzQxO1xuICAgICAgLS1wYXBlci1icm93bi03MDA6ICM1ZDQwMzc7XG4gICAgICAtLXBhcGVyLWJyb3duLTgwMDogIzRlMzQyZTtcbiAgICAgIC0tcGFwZXItYnJvd24tOTAwOiAjM2UyNzIzO1xuXG4gICAgICAtLXBhcGVyLWdyZXktNTA6ICNmYWZhZmE7XG4gICAgICAtLXBhcGVyLWdyZXktMTAwOiAjZjVmNWY1O1xuICAgICAgLS1wYXBlci1ncmV5LTIwMDogI2VlZWVlZTtcbiAgICAgIC0tcGFwZXItZ3JleS0zMDA6ICNlMGUwZTA7XG4gICAgICAtLXBhcGVyLWdyZXktNDAwOiAjYmRiZGJkO1xuICAgICAgLS1wYXBlci1ncmV5LTUwMDogIzllOWU5ZTtcbiAgICAgIC0tcGFwZXItZ3JleS02MDA6ICM3NTc1NzU7XG4gICAgICAtLXBhcGVyLWdyZXktNzAwOiAjNjE2MTYxO1xuICAgICAgLS1wYXBlci1ncmV5LTgwMDogIzQyNDI0MjtcbiAgICAgIC0tcGFwZXItZ3JleS05MDA6ICMyMTIxMjE7XG5cbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTUwOiAjZWNlZmYxO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktMTAwOiAjY2ZkOGRjO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktMjAwOiAjYjBiZWM1O1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktMzAwOiAjOTBhNGFlO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNDAwOiAjNzg5MDljO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNTAwOiAjNjA3ZDhiO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNjAwOiAjNTQ2ZTdhO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNzAwOiAjNDU1YTY0O1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktODAwOiAjMzc0NzRmO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktOTAwOiAjMjYzMjM4O1xuXG4gICAgICAvKiBvcGFjaXR5IGZvciBkYXJrIHRleHQgb24gYSBsaWdodCBiYWNrZ3JvdW5kICovXG4gICAgICAtLWRhcmstZGl2aWRlci1vcGFjaXR5OiAwLjEyO1xuICAgICAgLS1kYXJrLWRpc2FibGVkLW9wYWNpdHk6IDAuMzg7IC8qIG9yIGhpbnQgdGV4dCBvciBpY29uICovXG4gICAgICAtLWRhcmstc2Vjb25kYXJ5LW9wYWNpdHk6IDAuNTQ7XG4gICAgICAtLWRhcmstcHJpbWFyeS1vcGFjaXR5OiAwLjg3O1xuXG4gICAgICAvKiBvcGFjaXR5IGZvciBsaWdodCB0ZXh0IG9uIGEgZGFyayBiYWNrZ3JvdW5kICovXG4gICAgICAtLWxpZ2h0LWRpdmlkZXItb3BhY2l0eTogMC4xMjtcbiAgICAgIC0tbGlnaHQtZGlzYWJsZWQtb3BhY2l0eTogMC4zOyAvKiBvciBoaW50IHRleHQgb3IgaWNvbiAqL1xuICAgICAgLS1saWdodC1zZWNvbmRhcnktb3BhY2l0eTogMC43O1xuICAgICAgLS1saWdodC1wcmltYXJ5LW9wYWNpdHk6IDEuMDtcblxuICAgIH1cblxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2NvbG9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkExMXlLZXlzQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4vaXJvbi1jb250cm9sLXN0YXRlLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQnV0dG9uU3RhdGVJbXBsID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBob2xkaW5nIGRvd24gdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBwcmVzc2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICBvYnNlcnZlcjogJ19wcmVzc2VkQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiB0b2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgd2l0aCBlYWNoIHRhcCBvciBwcmVzc1xuICAgICAqIG9mIHRoZSBzcGFjZWJhci5cbiAgICAgKi9cbiAgICB0b2dnbGVzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gaXMgYSB0b2dnbGUgYW5kIGlzIGN1cnJlbnRseSBpbiB0aGUgYWN0aXZlIHN0YXRlLlxuICAgICAqL1xuICAgIGFjdGl2ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSBiZWluZyBwcmVzc2VkIGJ5IGEgXCJwb2ludGVyLFwiIHdoaWNoXG4gICAgICogaXMgbG9vc2VseSBkZWZpbmVkIGFzIG1vdXNlIG9yIHRvdWNoIGlucHV0IChidXQgc3BlY2lmaWNhbGx5IGV4Y2x1ZGluZ1xuICAgICAqIGtleWJvYXJkIGlucHV0KS5cbiAgICAgKi9cbiAgICBwb2ludGVyRG93bjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGlucHV0IGRldmljZSB0aGF0IGNhdXNlZCB0aGUgZWxlbWVudCB0byByZWNlaXZlIGZvY3VzXG4gICAgICogd2FzIGEga2V5Ym9hcmQuXG4gICAgICovXG4gICAgcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmlhIGF0dHJpYnV0ZSB0byBiZSBzZXQgaWYgdGhlIGJ1dHRvbiBpcyBhIHRvZ2dsZSBhbmQgaW4gdGhlXG4gICAgICogYWN0aXZlIHN0YXRlLlxuICAgICAqL1xuICAgIGFyaWFBY3RpdmVBdHRyaWJ1dGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnYXJpYS1wcmVzc2VkJyxcbiAgICAgIG9ic2VydmVyOiAnX2FyaWFBY3RpdmVBdHRyaWJ1dGVDaGFuZ2VkJ1xuICAgIH1cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICBkb3duOiAnX2Rvd25IYW5kbGVyJyxcbiAgICB1cDogJ191cEhhbmRsZXInLFxuICAgIHRhcDogJ190YXBIYW5kbGVyJ1xuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfZm9jdXNDaGFuZ2VkKGZvY3VzZWQpJyxcbiAgICAnX2FjdGl2ZUNoYW5nZWQoYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSdcbiAgXSxcblxuICBrZXlCaW5kaW5nczoge1xuICAgICdlbnRlcjprZXlkb3duJzogJ19hc3luY0NsaWNrJyxcbiAgICAnc3BhY2U6a2V5ZG93bic6ICdfc3BhY2VLZXlEb3duSGFuZGxlcicsXG4gICAgJ3NwYWNlOmtleXVwJzogJ19zcGFjZUtleVVwSGFuZGxlcicsXG4gIH0sXG5cbiAgX21vdXNlRXZlbnRSZTogL15tb3VzZS8sXG5cbiAgX3RhcEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnRvZ2dsZXMpIHtcbiAgICAgLy8gYSB0YXAgaXMgbmVlZGVkIHRvIHRvZ2dsZSB0aGUgYWN0aXZlIHN0YXRlXG4gICAgICB0aGlzLl91c2VyQWN0aXZhdGUoIXRoaXMuYWN0aXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgX2ZvY3VzQ2hhbmdlZDogZnVuY3Rpb24oZm9jdXNlZCkge1xuICAgIHRoaXMuX2RldGVjdEtleWJvYXJkRm9jdXMoZm9jdXNlZCk7XG5cbiAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICBfZGV0ZWN0S2V5Ym9hcmRGb2N1czogZnVuY3Rpb24oZm9jdXNlZCkge1xuICAgIHRoaXMuX3NldFJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQoIXRoaXMucG9pbnRlckRvd24gJiYgZm9jdXNlZCk7XG4gIH0sXG5cbiAgLy8gdG8gZW11bGF0ZSBuYXRpdmUgY2hlY2tib3gsIChkZS0pYWN0aXZhdGlvbnMgZnJvbSBhIHVzZXIgaW50ZXJhY3Rpb24gZmlyZVxuICAvLyAnY2hhbmdlJyBldmVudHNcbiAgX3VzZXJBY3RpdmF0ZTogZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlICE9PSBhY3RpdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICB9XG4gIH0sXG5cbiAgX2Rvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuX3NldFBvaW50ZXJEb3duKHRydWUpO1xuICAgIHRoaXMuX3NldFByZXNzZWQodHJ1ZSk7XG4gICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZChmYWxzZSk7XG4gIH0sXG5cbiAgX3VwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0UG9pbnRlckRvd24oZmFsc2UpO1xuICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAqL1xuICBfc3BhY2VLZXlEb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIga2V5Ym9hcmRFdmVudCA9IGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50O1xuICAgIHZhciB0YXJnZXQgPSBkb20oa2V5Ym9hcmRFdmVudCkubG9jYWxUYXJnZXQ7XG5cbiAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIHRoaXMgaXMgY29taW5nIGZyb20gYSBmb2N1c2VkIGxpZ2h0IGNoaWxkLCBzaW5jZSB0aGF0XG4gICAgLy8gZWxlbWVudCB3aWxsIGRlYWwgd2l0aCBpdC5cbiAgICBpZiAodGhpcy5pc0xpZ2h0RGVzY2VuZGFudCgvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKVxuICAgICAgcmV0dXJuO1xuXG4gICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGtleWJvYXJkRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgKi9cbiAgX3NwYWNlS2V5VXBIYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgdmFyIHRhcmdldCA9IGRvbShrZXlib2FyZEV2ZW50KS5sb2NhbFRhcmdldDtcblxuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAvLyBlbGVtZW50IHdpbGwgZGVhbCB3aXRoIGl0LlxuICAgIGlmICh0aGlzLmlzTGlnaHREZXNjZW5kYW50KC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAodGhpcy5wcmVzc2VkKSB7XG4gICAgICB0aGlzLl9hc3luY0NsaWNrKCk7XG4gICAgfVxuICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICB9LFxuXG4gIC8vIHRyaWdnZXIgY2xpY2sgYXN5bmNocm9ub3VzbHksIHRoZSBhc3luY2hyb255IGlzIHVzZWZ1bCB0byBhbGxvdyBvbmVcbiAgLy8gZXZlbnQgaGFuZGxlciB0byB1bndpbmQgYmVmb3JlIHRyaWdnZXJpbmcgYW5vdGhlciBldmVudFxuICBfYXN5bmNDbGljazogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2xpY2soKTtcbiAgICB9LCAxKTtcbiAgfSxcblxuICAvLyBhbnkgb2YgdGhlc2UgY2hhbmdlcyBhcmUgY29uc2lkZXJlZCBhIGNoYW5nZSB0byBidXR0b24gc3RhdGVcblxuICBfcHJlc3NlZENoYW5nZWQ6IGZ1bmN0aW9uKHByZXNzZWQpIHtcbiAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgfSxcblxuICBfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQ6IGZ1bmN0aW9uKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmIChvbGRWYWx1ZSAmJiBvbGRWYWx1ZSAhPSB2YWx1ZSAmJiB0aGlzLmhhc0F0dHJpYnV0ZShvbGRWYWx1ZSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG9sZFZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2FjdGl2ZUNoYW5nZWQ6IGZ1bmN0aW9uKGFjdGl2ZSwgYXJpYUFjdGl2ZUF0dHJpYnV0ZSkge1xuICAgIGlmICh0aGlzLnRvZ2dsZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmFyaWFBY3RpdmVBdHRyaWJ1dGUpO1xuICAgIH1cbiAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgfSxcblxuICBfY29udHJvbFN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX3NldFByZXNzZWQoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkQnV0dG9uU3RhdGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gcHJvdmlkZSBob29rIGZvciBmb2xsb3ctb24gYmVoYXZpb3JzIHRvIHJlYWN0IHRvIGJ1dHRvbi1zdGF0ZVxuXG4gIF9jaGFuZ2VkQnV0dG9uU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9idXR0b25TdGF0ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCgpOyAvLyBhYnN0cmFjdFxuICAgIH1cbiAgfVxuXG59O1xuXG5leHBvcnQgY29uc3QgSXJvbkJ1dHRvblN0YXRlID0gW1xuICBJcm9uQTExeUtleXNCZWhhdmlvcixcbiAgSXJvbkJ1dHRvblN0YXRlSW1wbFxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5cbi8qKlxuICogQ2hyb21lIHVzZXMgYW4gb2xkZXIgdmVyc2lvbiBvZiBET00gTGV2ZWwgMyBLZXlib2FyZCBFdmVudHNcbiAqXG4gKiBNb3N0IGtleXMgYXJlIGxhYmVsZWQgYXMgdGV4dCwgYnV0IHNvbWUgYXJlIFVuaWNvZGUgY29kZXBvaW50cy5cbiAqIFZhbHVlcyB0YWtlbiBmcm9tOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA3L1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDA3MTIyMS9rZXlzZXQuaHRtbCNLZXlTZXQtU2V0XG4gKi9cbnZhciBLRVlfSURFTlRJRklFUiA9IHtcbiAgJ1UrMDAwOCc6ICdiYWNrc3BhY2UnLFxuICAnVSswMDA5JzogJ3RhYicsXG4gICdVKzAwMUInOiAnZXNjJyxcbiAgJ1UrMDAyMCc6ICdzcGFjZScsXG4gICdVKzAwN0YnOiAnZGVsJ1xufTtcblxuLyoqXG4gKiBTcGVjaWFsIHRhYmxlIGZvciBLZXlib2FyZEV2ZW50LmtleUNvZGUuXG4gKiBLZXlib2FyZEV2ZW50LmtleUlkZW50aWZpZXIgaXMgYmV0dGVyLCBhbmQgS2V5Qm9hcmRFdmVudC5rZXkgaXMgZXZlbiBiZXR0ZXJcbiAqIHRoYW4gdGhhdC5cbiAqXG4gKiBWYWx1ZXMgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQua2V5Q29kZSNWYWx1ZV9vZl9rZXlDb2RlXG4gKi9cbnZhciBLRVlfQ09ERSA9IHtcbiAgODogJ2JhY2tzcGFjZScsXG4gIDk6ICd0YWInLFxuICAxMzogJ2VudGVyJyxcbiAgMjc6ICdlc2MnLFxuICAzMzogJ3BhZ2V1cCcsXG4gIDM0OiAncGFnZWRvd24nLFxuICAzNTogJ2VuZCcsXG4gIDM2OiAnaG9tZScsXG4gIDMyOiAnc3BhY2UnLFxuICAzNzogJ2xlZnQnLFxuICAzODogJ3VwJyxcbiAgMzk6ICdyaWdodCcsXG4gIDQwOiAnZG93bicsXG4gIDQ2OiAnZGVsJyxcbiAgMTA2OiAnKidcbn07XG5cbi8qKlxuICogTU9ESUZJRVJfS0VZUyBtYXBzIHRoZSBzaG9ydCBuYW1lIGZvciBtb2RpZmllciBrZXlzIHVzZWQgaW4gYSBrZXlcbiAqIGNvbWJvIHN0cmluZyB0byB0aGUgcHJvcGVydHkgbmFtZSB0aGF0IHJlZmVyZW5jZXMgdGhvc2Ugc2FtZSBrZXlzXG4gKiBpbiBhIEtleWJvYXJkRXZlbnQgaW5zdGFuY2UuXG4gKi9cbnZhciBNT0RJRklFUl9LRVlTID0ge1xuICAnc2hpZnQnOiAnc2hpZnRLZXknLFxuICAnY3RybCc6ICdjdHJsS2V5JyxcbiAgJ2FsdCc6ICdhbHRLZXknLFxuICAnbWV0YSc6ICdtZXRhS2V5J1xufTtcblxuLyoqXG4gKiBLZXlib2FyZEV2ZW50LmtleSBpcyBtb3N0bHkgcmVwcmVzZW50ZWQgYnkgcHJpbnRhYmxlIGNoYXJhY3RlciBtYWRlIGJ5XG4gKiB0aGUga2V5Ym9hcmQsIHdpdGggdW5wcmludGFibGUga2V5cyBsYWJlbGVkIG5pY2VseS5cbiAqXG4gKiBIb3dldmVyLCBvbiBPUyBYLCBBbHQrY2hhciBjYW4gbWFrZSBhIFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgZm9sbG93cyBhblxuICogQXBwbGUtc3BlY2lmaWMgbWFwcGluZy4gSW4gdGhpcyBjYXNlLCB3ZSBmYWxsIGJhY2sgdG8gLmtleUNvZGUuXG4gKi9cbnZhciBLRVlfQ0hBUiA9IC9bYS16MC05Kl0vO1xuXG4vKipcbiAqIE1hdGNoZXMgYSBrZXlJZGVudGlmaWVyIHN0cmluZy5cbiAqL1xudmFyIElERU5UX0NIQVIgPSAvVVxcKy87XG5cbi8qKlxuICogTWF0Y2hlcyBhcnJvdyBrZXlzIGluIEdlY2tvIDI3LjArXG4gKi9cbnZhciBBUlJPV19LRVkgPSAvXmFycm93LztcblxuLyoqXG4gKiBNYXRjaGVzIHNwYWNlIGtleXMgZXZlcnl3aGVyZSAobm90YWJseSBpbmNsdWRpbmcgSUUxMCdzIGV4Y2VwdGlvbmFsIG5hbWVcbiAqIGBzcGFjZWJhcmApLlxuICovXG52YXIgU1BBQ0VfS0VZID0gL15zcGFjZShiYXIpPy87XG5cbi8qKlxuICogTWF0Y2hlcyBFU0Mga2V5LlxuICpcbiAqIFZhbHVlIGZyb206IGh0dHA6Ly93M2MuZ2l0aHViLmlvL3VpZXZlbnRzLWtleS8ja2V5LUVzY2FwZVxuICovXG52YXIgRVNDX0tFWSA9IC9eZXNjYXBlJC87XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgS2V5Qm9hcmRFdmVudC5rZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBMaW1pdHMgdGhlIHRyYW5zZm9ybWF0aW9uIHRvXG4gKiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUtleShrZXksIG5vU3BlY2lhbENoYXJzKSB7XG4gIHZhciB2YWxpZEtleSA9ICcnO1xuICBpZiAoa2V5KSB7XG4gICAgdmFyIGxLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobEtleSA9PT0gJyAnIHx8IFNQQUNFX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICB2YWxpZEtleSA9ICdzcGFjZSc7XG4gICAgfSBlbHNlIGlmIChFU0NfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgIHZhbGlkS2V5ID0gJ2VzYyc7XG4gICAgfSBlbHNlIGlmIChsS2V5Lmxlbmd0aCA9PSAxKSB7XG4gICAgICBpZiAoIW5vU3BlY2lhbENoYXJzIHx8IEtFWV9DSEFSLnRlc3QobEtleSkpIHtcbiAgICAgICAgdmFsaWRLZXkgPSBsS2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQVJST1dfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgIHZhbGlkS2V5ID0gbEtleS5yZXBsYWNlKCdhcnJvdycsICcnKTtcbiAgICB9IGVsc2UgaWYgKGxLZXkgPT0gJ211bHRpcGx5Jykge1xuICAgICAgLy8gbnVtcGFkICcqJyBjYW4gbWFwIHRvIE11bHRpcGx5IG9uIElFL1dpbmRvd3NcbiAgICAgIHZhbGlkS2V5ID0gJyonO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxpZEtleTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtS2V5SWRlbnRpZmllcihrZXlJZGVudCkge1xuICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgaWYgKGtleUlkZW50KSB7XG4gICAgaWYgKGtleUlkZW50IGluIEtFWV9JREVOVElGSUVSKSB7XG4gICAgICB2YWxpZEtleSA9IEtFWV9JREVOVElGSUVSW2tleUlkZW50XTtcbiAgICB9IGVsc2UgaWYgKElERU5UX0NIQVIudGVzdChrZXlJZGVudCkpIHtcbiAgICAgIGtleUlkZW50ID0gcGFyc2VJbnQoa2V5SWRlbnQucmVwbGFjZSgnVSsnLCAnMHgnKSwgMTYpO1xuICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUlkZW50KS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZEtleSA9IGtleUlkZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxpZEtleTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtS2V5Q29kZShrZXlDb2RlKSB7XG4gIHZhciB2YWxpZEtleSA9ICcnO1xuICBpZiAoTnVtYmVyKGtleUNvZGUpKSB7XG4gICAgaWYgKGtleUNvZGUgPj0gNjUgJiYga2V5Q29kZSA8PSA5MCkge1xuICAgICAgLy8gYXNjaWkgYS16XG4gICAgICAvLyBsb3dlcmNhc2UgaXMgMzIgb2Zmc2V0IGZyb20gdXBwZXJjYXNlXG4gICAgICB2YWxpZEtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBrZXlDb2RlKTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gMTEyICYmIGtleUNvZGUgPD0gMTIzKSB7XG4gICAgICAvLyBmdW5jdGlvbiBrZXlzIGYxLWYxMlxuICAgICAgdmFsaWRLZXkgPSAnZicgKyAoa2V5Q29kZSAtIDExMiArIDEpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSA0OCAmJiBrZXlDb2RlIDw9IDU3KSB7XG4gICAgICAvLyB0b3AgMC05IGtleXNcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nKGtleUNvZGUgLSA0OCk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDk2ICYmIGtleUNvZGUgPD0gMTA1KSB7XG4gICAgICAvLyBudW0gcGFkIDAtOVxuICAgICAgdmFsaWRLZXkgPSBTdHJpbmcoa2V5Q29kZSAtIDk2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRLZXkgPSBLRVlfQ09ERVtrZXlDb2RlXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkS2V5O1xufVxuXG4vKipcbiAgKiBDYWxjdWxhdGVzIHRoZSBub3JtYWxpemVkIGtleSBmb3IgYSBLZXlib2FyZEV2ZW50LlxuICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0ga2V5RXZlbnRcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub1NwZWNpYWxDaGFyc10gU2V0IHRvIHRydWUgdG8gbGltaXQga2V5RXZlbnQua2V5XG4gICogdHJhbnNmb3JtYXRpb24gdG8gYWxwaGEtbnVtZXJpYyBjaGFycy4gVGhpcyBpcyB1c2VmdWwgd2l0aCBrZXlcbiAgKiBjb21iaW5hdGlvbnMgbGlrZSBzaGlmdCArIDIsIHdoaWNoIG9uIEZGIGZvciBNYWNPUyBwcm9kdWNlc1xuICAqIGtleUV2ZW50LmtleSA9IEBcbiAgKiBUbyBnZXQgMiByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gdHJ1ZVxuICAqIFRvIGdldCBAIHJldHVybmVkLCBzZXQgbm9TcGVjaWFsQ2hhcnMgPSBmYWxzZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVkS2V5Rm9yRXZlbnQoa2V5RXZlbnQsIG5vU3BlY2lhbENoYXJzKSB7XG4gIC8vIEZhbGwgYmFjayBmcm9tIC5rZXksIHRvIC5kZXRhaWwua2V5IGZvciBhcnRpZmljYWwga2V5Ym9hcmQgZXZlbnRzLFxuICAvLyBhbmQgdGhlbiB0byBkZXByZWNhdGVkIC5rZXlJZGVudGlmaWVyIGFuZCAua2V5Q29kZS5cbiAgaWYgKGtleUV2ZW50LmtleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1LZXkoa2V5RXZlbnQua2V5LCBub1NwZWNpYWxDaGFycyk7XG4gIH1cbiAgaWYgKGtleUV2ZW50LmRldGFpbCAmJiBrZXlFdmVudC5kZXRhaWwua2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUtleShrZXlFdmVudC5kZXRhaWwua2V5LCBub1NwZWNpYWxDaGFycyk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUtleUlkZW50aWZpZXIoa2V5RXZlbnQua2V5SWRlbnRpZmllcikgfHxcbiAgICB0cmFuc2Zvcm1LZXlDb2RlKGtleUV2ZW50LmtleUNvZGUpIHx8ICcnO1xufVxuXG5mdW5jdGlvbiBrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ibywgZXZlbnQpIHtcbiAgLy8gRm9yIGNvbWJvcyB3aXRoIG1vZGlmaWVycyB3ZSBzdXBwb3J0IG9ubHkgYWxwaGEtbnVtZXJpYyBrZXlzXG4gIHZhciBrZXlFdmVudCA9IG5vcm1hbGl6ZWRLZXlGb3JFdmVudChldmVudCwga2V5Q29tYm8uaGFzTW9kaWZpZXJzKTtcbiAgcmV0dXJuIGtleUV2ZW50ID09PSBrZXlDb21iby5rZXkgJiZcbiAgICAoIWtleUNvbWJvLmhhc01vZGlmaWVycyB8fCAoXG4gICAgICAhIWV2ZW50LnNoaWZ0S2V5ID09PSAhIWtleUNvbWJvLnNoaWZ0S2V5ICYmXG4gICAgICAhIWV2ZW50LmN0cmxLZXkgPT09ICEha2V5Q29tYm8uY3RybEtleSAmJlxuICAgICAgISFldmVudC5hbHRLZXkgPT09ICEha2V5Q29tYm8uYWx0S2V5ICYmXG4gICAgICAhIWV2ZW50Lm1ldGFLZXkgPT09ICEha2V5Q29tYm8ubWV0YUtleSlcbiAgICApO1xufVxuXG5mdW5jdGlvbiBwYXJzZUtleUNvbWJvU3RyaW5nKGtleUNvbWJvU3RyaW5nKSB7XG4gIGlmIChrZXlDb21ib1N0cmluZy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tYm86IGtleUNvbWJvU3RyaW5nLFxuICAgICAga2V5OiBrZXlDb21ib1N0cmluZyxcbiAgICAgIGV2ZW50OiAna2V5ZG93bidcbiAgICB9O1xuICB9XG4gIHJldHVybiBrZXlDb21ib1N0cmluZy5zcGxpdCgnKycpLnJlZHVjZShmdW5jdGlvbihwYXJzZWRLZXlDb21ibywga2V5Q29tYm9QYXJ0KSB7XG4gICAgdmFyIGV2ZW50UGFydHMgPSBrZXlDb21ib1BhcnQuc3BsaXQoJzonKTtcbiAgICB2YXIga2V5TmFtZSA9IGV2ZW50UGFydHNbMF07XG4gICAgdmFyIGV2ZW50ID0gZXZlbnRQYXJ0c1sxXTtcblxuICAgIGlmIChrZXlOYW1lIGluIE1PRElGSUVSX0tFWVMpIHtcbiAgICAgIHBhcnNlZEtleUNvbWJvW01PRElGSUVSX0tFWVNba2V5TmFtZV1dID0gdHJ1ZTtcbiAgICAgIHBhcnNlZEtleUNvbWJvLmhhc01vZGlmaWVycyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZEtleUNvbWJvLmtleSA9IGtleU5hbWU7XG4gICAgICBwYXJzZWRLZXlDb21iby5ldmVudCA9IGV2ZW50IHx8ICdrZXlkb3duJztcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkS2V5Q29tYm87XG4gIH0sIHtcbiAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcuc3BsaXQoJzonKS5zaGlmdCgpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKSB7XG4gIHJldHVybiBldmVudFN0cmluZy50cmltKCkuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oa2V5Q29tYm9TdHJpbmcpIHtcbiAgICByZXR1cm4gcGFyc2VLZXlDb21ib1N0cmluZyhrZXlDb21ib1N0cmluZyk7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgSXJvbkExMXlLZXlzQmVoYXZpb3IgPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgRXZlbnRUYXJnZXQgdGhhdCB3aWxsIGJlIGZpcmluZyByZWxldmFudCBLZXlib2FyZEV2ZW50cy4gU2V0IGl0IHRvXG4gICAgICogYG51bGxgIHRvIGRpc2FibGUgdGhlIGxpc3RlbmVycy5cbiAgICAgKiBAdHlwZSB7P0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGtleUV2ZW50VGFyZ2V0OiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGlzIHByb3BlcnR5IHdpbGwgY2F1c2UgdGhlIGltcGxlbWVudGluZyBlbGVtZW50IHRvXG4gICAgICogYXV0b21hdGljYWxseSBzdG9wIHByb3BhZ2F0aW9uIG9uIGFueSBoYW5kbGVkIEtleWJvYXJkRXZlbnRzLlxuICAgICAqL1xuICAgIHN0b3BLZXlib2FyZEV2ZW50UHJvcGFnYXRpb246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgX2JvdW5kS2V5SGFuZGxlcnM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFdlIHVzZSB0aGlzIGR1ZSB0byBhIGxpbWl0YXRpb24gaW4gSUUxMCB3aGVyZSBpbnN0YW5jZXMgd2lsbCBoYXZlXG4gICAgLy8gb3duIHByb3BlcnRpZXMgb2YgZXZlcnl0aGluZyBvbiB0aGUgXCJwcm90b3R5cGVcIi5cbiAgICBfaW1wZXJhdGl2ZUtleUJpbmRpbmdzOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19yZXNldEtleUV2ZW50TGlzdGVuZXJzKGtleUV2ZW50VGFyZ2V0LCBfYm91bmRLZXlIYW5kbGVycyknXG4gIF0sXG5cblxuICAvKipcbiAgICogVG8gYmUgdXNlZCB0byBleHByZXNzIHdoYXQgY29tYmluYXRpb24gb2Yga2V5cyAgd2lsbCB0cmlnZ2VyIHRoZSByZWxhdGl2ZVxuICAgKiBjYWxsYmFjay4gZS5nLiBga2V5QmluZGluZ3M6IHsgJ2VzYyc6ICdfb25Fc2NQcmVzc2VkJ31gXG4gICAqIEB0eXBlIHshT2JqZWN0fVxuICAgKi9cbiAga2V5QmluZGluZ3M6IHt9LFxuXG4gIHJlZ2lzdGVyZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbiBiZSB1c2VkIHRvIGltcGVyYXRpdmVseSBhZGQgYSBrZXkgYmluZGluZyB0byB0aGUgaW1wbGVtZW50aW5nXG4gICAqIGVsZW1lbnQuIFRoaXMgaXMgdGhlIGltcGVyYXRpdmUgZXF1aXZhbGVudCBvZiBkZWNsYXJpbmcgYSBrZXliaW5kaW5nXG4gICAqIGluIHRoZSBga2V5QmluZGluZ3NgIHByb3RvdHlwZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50U3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyTmFtZVxuICAgKi9cbiAgYWRkT3duS2V5QmluZGluZzogZnVuY3Rpb24oZXZlbnRTdHJpbmcsIGhhbmRsZXJOYW1lKSB7XG4gICAgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSA9IGhhbmRsZXJOYW1lO1xuICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgIHRoaXMuX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICAvKipcbiAgICogV2hlbiBjYWxsZWQsIHdpbGwgcmVtb3ZlIGFsbCBpbXBlcmF0aXZlbHktYWRkZWQga2V5IGJpbmRpbmdzLlxuICAgKi9cbiAgcmVtb3ZlT3duS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5ncyA9IHt9O1xuICAgIHRoaXMuX3ByZXBLZXlCaW5kaW5ncygpO1xuICAgIHRoaXMuX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEga2V5Ym9hcmQgZXZlbnQgbWF0Y2hlcyBgZXZlbnRTdHJpbmdgLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAga2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzOiBmdW5jdGlvbihldmVudCwgZXZlbnRTdHJpbmcpIHtcbiAgICB2YXIga2V5Q29tYm9zID0gcGFyc2VFdmVudFN0cmluZyhldmVudFN0cmluZyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlDb21ib3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ib3NbaV0sIGV2ZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIF9jb2xsZWN0S2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlCaW5kaW5ncyA9IHRoaXMuYmVoYXZpb3JzLm1hcChmdW5jdGlvbihiZWhhdmlvcikge1xuICAgICAgcmV0dXJuIGJlaGF2aW9yLmtleUJpbmRpbmdzO1xuICAgIH0pO1xuXG4gICAgaWYgKGtleUJpbmRpbmdzLmluZGV4T2YodGhpcy5rZXlCaW5kaW5ncykgPT09IC0xKSB7XG4gICAgICBrZXlCaW5kaW5ncy5wdXNoKHRoaXMua2V5QmluZGluZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlCaW5kaW5ncztcbiAgfSxcblxuICBfcHJlcEtleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9rZXlCaW5kaW5ncyA9IHt9O1xuXG4gICAgdGhpcy5fY29sbGVjdEtleUJpbmRpbmdzKCkuZm9yRWFjaChmdW5jdGlvbihrZXlCaW5kaW5ncykge1xuICAgICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4ga2V5QmluZGluZ3MpIHtcbiAgICAgICAgdGhpcy5fYWRkS2V5QmluZGluZyhldmVudFN0cmluZywga2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGZvciAodmFyIGV2ZW50U3RyaW5nIGluIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5ncykge1xuICAgICAgdGhpcy5fYWRkS2V5QmluZGluZyhldmVudFN0cmluZywgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSk7XG4gICAgfVxuXG4gICAgLy8gR2l2ZSBwcmVjZWRlbmNlIHRvIGNvbWJvcyB3aXRoIG1vZGlmaWVycyB0byBiZSBjaGVja2VkIGZpcnN0LlxuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiB0aGlzLl9rZXlCaW5kaW5ncykge1xuICAgICAgdGhpcy5fa2V5QmluZGluZ3NbZXZlbnROYW1lXS5zb3J0KGZ1bmN0aW9uIChrYjEsIGtiMikge1xuICAgICAgICB2YXIgYjEgPSBrYjFbMF0uaGFzTW9kaWZpZXJzO1xuICAgICAgICB2YXIgYjIgPSBrYjJbMF0uaGFzTW9kaWZpZXJzO1xuICAgICAgICByZXR1cm4gKGIxID09PSBiMikgPyAwIDogYjEgPyAtMSA6IDE7XG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICBfYWRkS2V5QmluZGluZzogZnVuY3Rpb24oZXZlbnRTdHJpbmcsIGhhbmRsZXJOYW1lKSB7XG4gICAgcGFyc2VFdmVudFN0cmluZyhldmVudFN0cmluZykuZm9yRWFjaChmdW5jdGlvbihrZXlDb21ibykge1xuICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdID1cbiAgICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdIHx8IFtdO1xuXG4gICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0ucHVzaChbXG4gICAgICAgIGtleUNvbWJvLFxuICAgICAgICBoYW5kbGVyTmFtZVxuICAgICAgXSk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9LFxuXG4gIF9saXN0ZW5LZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmtleUV2ZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuX2tleUJpbmRpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGtleUJpbmRpbmdzID0gdGhpcy5fa2V5QmluZGluZ3NbZXZlbnROYW1lXTtcbiAgICAgIHZhciBib3VuZEtleUhhbmRsZXIgPSB0aGlzLl9vbktleUJpbmRpbmdFdmVudC5iaW5kKHRoaXMsIGtleUJpbmRpbmdzKTtcblxuICAgICAgdGhpcy5fYm91bmRLZXlIYW5kbGVycy5wdXNoKFt0aGlzLmtleUV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcl0pO1xuXG4gICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXIpO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5SGFuZGxlclR1cGxlO1xuICAgIHZhciBrZXlFdmVudFRhcmdldDtcbiAgICB2YXIgZXZlbnROYW1lO1xuICAgIHZhciBib3VuZEtleUhhbmRsZXI7XG5cbiAgICB3aGlsZSAodGhpcy5fYm91bmRLZXlIYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIC8vIE15IGtpbmdkb20gZm9yIGJsb2NrLXNjb3BlIGJpbmRpbmcgYW5kIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudC4uXG4gICAgICBrZXlIYW5kbGVyVHVwbGUgPSB0aGlzLl9ib3VuZEtleUhhbmRsZXJzLnBvcCgpO1xuICAgICAga2V5RXZlbnRUYXJnZXQgPSBrZXlIYW5kbGVyVHVwbGVbMF07XG4gICAgICBldmVudE5hbWUgPSBrZXlIYW5kbGVyVHVwbGVbMV07XG4gICAgICBib3VuZEtleUhhbmRsZXIgPSBrZXlIYW5kbGVyVHVwbGVbMl07XG5cbiAgICAgIGtleUV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXIpO1xuICAgIH1cbiAgfSxcblxuICBfb25LZXlCaW5kaW5nRXZlbnQ6IGZ1bmN0aW9uKGtleUJpbmRpbmdzLCBldmVudCkge1xuICAgIGlmICh0aGlzLnN0b3BLZXlib2FyZEV2ZW50UHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGV2ZW50IGhhcyBiZWVuIGFscmVhZHkgcHJldmVudGVkLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlCaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleUNvbWJvID0ga2V5QmluZGluZ3NbaV1bMF07XG4gICAgICB2YXIgaGFuZGxlck5hbWUgPSBrZXlCaW5kaW5nc1tpXVsxXTtcbiAgICAgIGlmIChrZXlDb21ib01hdGNoZXNFdmVudChrZXlDb21ibywgZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJLZXlIYW5kbGVyKGtleUNvbWJvLCBoYW5kbGVyTmFtZSwgZXZlbnQpO1xuICAgICAgICAvLyBleGl0IHRoZSBsb29wIGlmIGV2ZW50RGVmYXVsdCB3YXMgcHJldmVudGVkXG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF90cmlnZ2VyS2V5SGFuZGxlcjogZnVuY3Rpb24oa2V5Q29tYm8sIGhhbmRsZXJOYW1lLCBrZXlib2FyZEV2ZW50KSB7XG4gICAgdmFyIGRldGFpbCA9IE9iamVjdC5jcmVhdGUoa2V5Q29tYm8pO1xuICAgIGRldGFpbC5rZXlib2FyZEV2ZW50ID0ga2V5Ym9hcmRFdmVudDtcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoa2V5Q29tYm8uZXZlbnQsIHtcbiAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXNbaGFuZGxlck5hbWVdLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkNvbnRyb2xTdGF0ZSA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgZWxlbWVudCBjdXJyZW50bHkgaGFzIGZvY3VzLlxuICAgICAqL1xuICAgIGZvY3VzZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgdXNlciBjYW5ub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICBvYnNlcnZlcjogJ19kaXNhYmxlZENoYW5nZWQnLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIF9vbGRUYWJJbmRleDoge1xuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcblxuICAgIF9ib3VuZEZvY3VzQmx1ckhhbmRsZXI6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNCbHVySGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfX2hhbmRsZUV2ZW50UmV0YXJnZXRpbmc6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5zaGFkb3dSb290ICYmICFFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX2NoYW5nZWRDb250cm9sU3RhdGUoZm9jdXNlZCwgZGlzYWJsZWQpJ1xuICBdLFxuXG4gIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmRGb2N1c0JsdXJIYW5kbGVyLCB0cnVlKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICB9LFxuXG4gIF9mb2N1c0JsdXJIYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIEluIFBvbHltZXIgMi4wLCB0aGUgbGlicmFyeSB0YWtlcyBjYXJlIG9mIHJldGFyZ2V0aW5nIGV2ZW50cy5cbiAgICBpZiAoRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOT1RFKGNkYXRhKTogIGlmIHdlIGFyZSBpbiBTaGFkb3dET00gbGFuZCwgYGV2ZW50LnRhcmdldGAgd2lsbFxuICAgIC8vIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWUgdG8gcmV0YXJnZXRpbmc7IGlmIHdlIGFyZSBub3QgaW5cbiAgICAvLyBTaGFkb3dET00gbGFuZCwgYGV2ZW50LnRhcmdldGAgd2lsbCBldmVudHVhbGx5IGJlY29tZSBgdGhpc2AgZHVlXG4gICAgLy8gdG8gdGhlIHNlY29uZCBjb25kaXRpb25hbCB3aGljaCBmaXJlcyBhIHN5bnRoZXRpYyBldmVudCAodGhhdCBpcyBhbHNvXG4gICAgLy8gaGFuZGxlZCkuIEluIGVpdGhlciBjYXNlLCB3ZSBjYW4gZGlzcmVnYXJkIGBldmVudC5wYXRoYC5cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGV2ZW50LnR5cGUgPT09ICdmb2N1cycpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fX2hhbmRsZUV2ZW50UmV0YXJnZXRpbmcpIHtcbiAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUge05vZGV9ICovKGRvbShldmVudCkubG9jYWxUYXJnZXQpO1xuICAgICAgaWYgKCF0aGlzLmlzTGlnaHREZXNjZW5kYW50KHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50LnR5cGUsIHtzb3VyY2VFdmVudDogZXZlbnR9LCB7XG4gICAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgICBidWJibGVzOiBldmVudC5idWJibGVzLFxuICAgICAgICAgIGNhbmNlbGFibGU6IGV2ZW50LmNhbmNlbGFibGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9kaXNhYmxlZENoYW5nZWQ6IGZ1bmN0aW9uKGRpc2FibGVkLCBvbGQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIGRpc2FibGVkID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgdGhpcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gZGlzYWJsZWQgPyAnbm9uZScgOiAnJztcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX29sZFRhYkluZGV4ID0gdGhpcy50YWJJbmRleDtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQoZmFsc2UpO1xuICAgICAgdGhpcy50YWJJbmRleCA9IC0xO1xuICAgICAgdGhpcy5ibHVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vbGRUYWJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRhYkluZGV4ID0gdGhpcy5fb2xkVGFiSW5kZXg7XG4gICAgfVxuICB9LFxuXG4gIF9jaGFuZ2VkQ29udHJvbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAvLyBfY29udHJvbFN0YXRlQ2hhbmdlZCBpcyBhYnN0cmFjdCwgZm9sbG93LW9uIGJlaGF2aW9ycyBtYXkgaW1wbGVtZW50IGl0XG4gICAgaWYgKHRoaXMuX2NvbnRyb2xTdGF0ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2xTdGF0ZUNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge1NwaGVyaWNhbE1lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzg1N1xyXG4gKlxyXG4gKiBUaGUgbW9zdCBjb21tb24gQ1JTIGZvciBvbmxpbmUgbWFwcywgdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWxcclxuICogdGlsZSBwcm92aWRlcnMuIFVzZXMgU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uIFNldCBpbiBieSBkZWZhdWx0IGluXHJcbiAqIE1hcCdzIGBjcnNgIG9wdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEVQU0czODU3ID0gVXRpbC5leHRlbmQoe30sIEVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6Mzg1NycsXHJcblx0cHJvamVjdGlvbjogU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBTcGhlcmljYWxNZXJjYXRvci5SKTtcclxuXHRcdHJldHVybiB0b1RyYW5zZm9ybWF0aW9uKHNjYWxlLCAwLjUsIC1zY2FsZSwgMC41KTtcclxuXHR9KCkpXHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBFUFNHOTAwOTEzID0gVXRpbC5leHRlbmQoe30sIEVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHMzg1Ny5qcyIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBTcGhlcmljYWxNZXJjYXRvciA9IHtcclxuXHJcblx0UjogNjM3ODEzNyxcclxuXHRNQVhfTEFUSVRVREU6IDg1LjA1MTEyODc3OTgsXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICBtYXggPSB0aGlzLk1BWF9MQVRJVFVERSxcclxuXHRcdCAgICBsYXQgPSBNYXRoLm1heChNYXRoLm1pbihtYXgsIGxhdGxuZy5sYXQpLCAtbWF4KSxcclxuXHRcdCAgICBzaW4gPSBNYXRoLnNpbihsYXQgKiBkKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IDYzNzgxMzcgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IuanMiLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5leHBvcnQgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4vLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4vLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHR9XG5cblx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG59XG5cblxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5VdGlsLmpzIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bicsXG4gICAgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJyxcbiAgICBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJyxcbiAgICBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCcsXG4gICAgVEFHX1dISVRFX0xJU1QgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXSxcblxuICAgIF9wb2ludGVycyA9IHt9LFxuICAgIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gRG9tRXZlbnQuRG91YmxlVGFwIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhpc1xuZXhwb3J0IHZhciBfcG9pbnRlcnNDb3VudCA9IDA7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0X2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0X2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uRG93biA9IFV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUucG9pbnRlclR5cGUgIT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuXHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdC8vIHRoZSBjb250cm9scyB3aWxsIHN0b3Agd29ya2luZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBvZiB0YWcgbmFtZXMgdGhhdFxuXHRcdFx0Ly8gbmVlZCB0aGVzZSBldmVudHMuIEZvciBvdGhlciB0YXJnZXQgdGFncywgd2UgcHJldmVudCBkZWZhdWx0IG9uIHRoZSBldmVudC5cblx0XHRcdGlmIChUQUdfV0hJVEVfTElTVC5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIDwgMCkge1xuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fSk7XG5cblx0b2JqWydfbGVhZmxldF90b3VjaHN0YXJ0JyArIGlkXSA9IG9uRG93bjtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRfcG9pbnRlcnNDb3VudCsrO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcblx0X3BvaW50ZXJzQ291bnQtLTtcbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcikge1xuXHRlLnRvdWNoZXMgPSBbXTtcblx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcblx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHR9XG5cdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0aGFuZGxlcihlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gZG9uJ3QgZmlyZSB0b3VjaCBtb3ZlcyB3aGVuIG1vdXNlIGlzbid0IGRvd25cblx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgZS5idXR0b25zID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaG1vdmUnICsgaWRdID0gb25Nb3ZlO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvblVwID0gZnVuY3Rpb24gKGUpIHtcblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIG9uVXAsIGZhbHNlKTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIG9uVXAsIGZhbHNlKTtcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tRXZlbnQuUG9pbnRlci5qcyIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqIGZ4LnJ1bihlbCwgWzMwMCwgNTAwXSwgMC41KTtcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Qb3NBbmltYXRpb24uanMiLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBtaW5pY2xhc3MgSWNvbi5EZWZhdWx0IChJY29uKVxuICogQGFrYSBMLkljb24uRGVmYXVsdFxuICogQHNlY3Rpb25cbiAqXG4gKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gKiByZWxlYXNlcy5cbiAqXG4gKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICogKHdoaWNoIGlzIGEgc2V0IG9mIGBJY29uIG9wdGlvbnNgKS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAqIGBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5pY29uYCB3aXRoIHlvdXIgb3duIGljb24gaW5zdGVhZC5cbiAqL1xuXG5leHBvcnQgdmFyIEljb25EZWZhdWx0ID0gSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcblx0XHRpY29uUmV0aW5hVXJsOiAnbWFya2VyLWljb24tMngucG5nJyxcblx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcblx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoIUljb25EZWZhdWx0LmltYWdlUGF0aCkge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGFic29sdXRlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgYWJzb2x1dGUgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuXHRcdGlmIChwYXRoID09PSBudWxsIHx8IHBhdGguaW5kZXhPZigndXJsJykgIT09IDApIHtcblx0XHRcdHBhdGggPSAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXnVybFxcKFtcXFwiXFwnXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXFxcIlxcJ10/XFwpJC8sICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aDtcblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xuaW1wb3J0IHtCb3hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkJveFpvb20nO1xuTWFwLkJveFpvb20gPSBCb3hab29tO1xuaW1wb3J0IHtEb3VibGVDbGlja1pvb219IGZyb20gJy4vaGFuZGxlci9NYXAuRG91YmxlQ2xpY2tab29tJztcbk1hcC5Eb3VibGVDbGlja1pvb20gPSBEb3VibGVDbGlja1pvb207XG5pbXBvcnQge0RyYWd9IGZyb20gJy4vaGFuZGxlci9NYXAuRHJhZyc7XG5NYXAuRHJhZyA9IERyYWc7XG5pbXBvcnQge0tleWJvYXJkfSBmcm9tICcuL2hhbmRsZXIvTWFwLktleWJvYXJkJztcbk1hcC5LZXlib2FyZCA9IEtleWJvYXJkO1xuaW1wb3J0IHtTY3JvbGxXaGVlbFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tJztcbk1hcC5TY3JvbGxXaGVlbFpvb20gPSBTY3JvbGxXaGVlbFpvb207XG5pbXBvcnQge1RhcH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXAnO1xuTWFwLlRhcCA9IFRhcDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaW5kZXguanMiLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHRleHQgYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuXHJcblx0c2V0UHJlZml4OiBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMucHJlZml4ID0gcHJlZml4O1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGF0dHJpYnV0aW9uIHRleHQgKGUuZy4gYCdWZWN0b3IgZGF0YSAmY29weTsgTWFwYm94J2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiBhdHRyaWJ1dGlvbkNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbYXR0cmlidXRpb24gY29udHJvbF0oI2NvbnRyb2wtYXR0cmlidXRpb24pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0bmV3IEF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbmV4cG9ydCB2YXIgYXR0cmlidXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzIiwiaW1wb3J0IHtDb250cm9sLCBjb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0IHtMYXllcnMsIGxheWVyc30gZnJvbSAnLi9Db250cm9sLkxheWVycyc7XG5pbXBvcnQge1pvb20sIHpvb219IGZyb20gJy4vQ29udHJvbC5ab29tJztcbmltcG9ydCB7U2NhbGUsIHNjYWxlfSBmcm9tICcuL0NvbnRyb2wuU2NhbGUnO1xuaW1wb3J0IHtBdHRyaWJ1dGlvbiwgYXR0cmlidXRpb259IGZyb20gJy4vQ29udHJvbC5BdHRyaWJ1dGlvbic7XG5cbkNvbnRyb2wuTGF5ZXJzID0gTGF5ZXJzO1xuQ29udHJvbC5ab29tID0gWm9vbTtcbkNvbnRyb2wuU2NhbGUgPSBTY2FsZTtcbkNvbnRyb2wuQXR0cmlidXRpb24gPSBBdHRyaWJ1dGlvbjtcblxuY29udHJvbC5sYXllcnMgPSBsYXllcnM7XG5jb250cm9sLnpvb20gPSB6b29tO1xuY29udHJvbC5zY2FsZSA9IHNjYWxlO1xuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuXG5leHBvcnQge0NvbnRyb2wsIGNvbnRyb2x9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL2luZGV4LmpzIiwiZXhwb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XG5leHBvcnQge0xheWVyR3JvdXAsIGxheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XG5leHBvcnQge0ZlYXR1cmVHcm91cCwgZmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5pbXBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb24sIGdlb21ldHJ5VG9MYXllciwgY29vcmRzVG9MYXRMbmcsIGNvb3Jkc1RvTGF0TG5ncywgbGF0TG5nVG9Db29yZHMsIGxhdExuZ3NUb0Nvb3JkcywgZ2V0RmVhdHVyZSwgYXNGZWF0dXJlfSBmcm9tICcuL0dlb0pTT04nO1xuR2VvSlNPTi5nZW9tZXRyeVRvTGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXI7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmc7XG5HZW9KU09OLmNvb3Jkc1RvTGF0TG5ncyA9IGNvb3Jkc1RvTGF0TG5ncztcbkdlb0pTT04ubGF0TG5nVG9Db29yZHMgPSBsYXRMbmdUb0Nvb3Jkcztcbkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzID0gbGF0TG5nc1RvQ29vcmRzO1xuR2VvSlNPTi5nZXRGZWF0dXJlID0gZ2V0RmVhdHVyZTtcbkdlb0pTT04uYXNGZWF0dXJlID0gYXNGZWF0dXJlO1xuZXhwb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29ufTtcblxuZXhwb3J0IHtJbWFnZU92ZXJsYXksIGltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xuZXhwb3J0IHtWaWRlb092ZXJsYXksIHZpZGVvT3ZlcmxheX0gZnJvbSAnLi9WaWRlb092ZXJsYXknO1xuXG5leHBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5leHBvcnQge1BvcHVwLCBwb3B1cH0gZnJvbSAnLi9Qb3B1cCc7XG5leHBvcnQge1Rvb2x0aXAsIHRvb2x0aXB9IGZyb20gJy4vVG9vbHRpcCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vbWFya2VyL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdGlsZS9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3ZlY3Rvci9pbmRleCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL2luZGV4LmpzIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG5leHBvcnQgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdHRpbGVTaXplOiAyNTYsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcblx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG5cdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcblx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcblx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRlbiBieSBjbGFzc2VzIGV4dGVuZGluZyBgR3JpZExheWVyYC5cblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBgY29vcmRzYC4gSWYgdGhlIGBkb25lYCBjYWxsYmFja1xuXHQvLyBpcyBzcGVjaWZpZWQsIGl0IG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGZpbmlzaGVkIGxvYWRpbmcgYW5kIGRyYXdpbmcuXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQG1ldGhvZCBnZXRUaWxlU2l6ZTogUG9pbnRcblx0Ly8gTm9ybWFsaXplcyB0aGUgW3RpbGVTaXplIG9wdGlvbl0oI2dyaWRsYXllci10aWxlc2l6ZSkgaW50byBhIHBvaW50LiBVc2VkIGJ5IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QuXG5cdGdldFRpbGVTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XG5cdFx0cmV0dXJuIHMgaW5zdGFuY2VvZiBQb2ludCA/IHMgOiBuZXcgUG9pbnQocywgcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuXHRcdH1cblx0fSxcblxuXHRfc2V0QXV0b1pJbmRleDogZnVuY3Rpb24gKGNvbXBhcmUpIHtcblx0XHQvLyBnbyB0aHJvdWdoIGFsbCBvdGhlciBsYXllcnMgb2YgdGhlIHNhbWUgcGFuZSwgc2V0IHpJbmRleCB0byBtYXggKyAxIChmcm9udCkgb3IgbWluIC0gMSAoYmFjaylcblxuXHRcdHZhciBsYXllcnMgPSB0aGlzLmdldFBhbmUoKS5jaGlsZHJlbixcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKC1JbmZpbml0eSwgSW5maW5pdHkpOyAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGgsIHpJbmRleDsgaSA8IGxlbjsgaSsrKSB7XG5cblx0XHRcdHpJbmRleCA9IGxheWVyc1tpXS5zdHlsZS56SW5kZXg7XG5cblx0XHRcdGlmIChsYXllcnNbaV0gIT09IHRoaXMuX2NvbnRhaW5lciAmJiB6SW5kZXgpIHtcblx0XHRcdFx0ZWRnZVpJbmRleCA9IGNvbXBhcmUoZWRnZVpJbmRleCwgK3pJbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzRmluaXRlKGVkZ2VaSW5kZXgpKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gZWRnZVpJbmRleCArIGNvbXBhcmUoLTEsIDEpO1xuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBJRSBkb2Vzbid0IGluaGVyaXQgZmlsdGVyIG9wYWNpdHkgcHJvcGVybHksIHNvIHdlJ3JlIGZvcmNlZCB0byBzZXQgaXQgb24gdGlsZXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcblx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG5cdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIGZhZGUpO1xuXHRcdFx0aWYgKGZhZGUgPCAxKSB7XG5cdFx0XHRcdG5leHRGcmFtZSA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR3aWxsUHJ1bmUgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX29uT3BhcXVlVGlsZSh0aWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdpbGxQcnVuZSAmJiAhdGhpcy5fbm9QcnVuZSkgeyB0aGlzLl9wcnVuZVRpbGVzKCk7IH1cblxuXHRcdGlmIChuZXh0RnJhbWUpIHtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk9wYXF1ZVRpbGU6IFV0aWwuZmFsc2VGbixcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtbGF5ZXIgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX3RpbGVab29tLFxuXHRcdCAgICBtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XG5cblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHRpZiAodGhpcy5fbGV2ZWxzW3pdLmVsLmNoaWxkcmVuLmxlbmd0aCB8fCB6ID09PSB6b29tKSB7XG5cdFx0XHRcdHRoaXMuX2xldmVsc1t6XS5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tIC0gTWF0aC5hYnMoem9vbSAtIHopO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZUxldmVsKHopO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG5cdFx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG5cdFx0XHRsZXZlbC5lbCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0bGV2ZWwuZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbTtcblxuXHRcdFx0bGV2ZWwub3JpZ2luID0gbWFwLnByb2plY3QobWFwLnVucHJvamVjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSksIHpvb20pLnJvdW5kKCk7XG5cdFx0XHRsZXZlbC56b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybShsZXZlbCwgbWFwLmdldENlbnRlcigpLCBtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdFx0Ly8gZm9yY2UgdGhlIGJyb3dzZXIgdG8gY29uc2lkZXIgdGhlIG5ld2x5IGFkZGVkIGVsZW1lbnQgZm9yIHRyYW5zaXRpb25cblx0XHRcdFV0aWwuZmFsc2VGbihsZXZlbC5lbC5vZmZzZXRXaWR0aCk7XG5cblx0XHRcdHRoaXMuX29uQ3JlYXRlTGV2ZWwobGV2ZWwpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cblx0XHRyZXR1cm4gbGV2ZWw7XG5cdH0sXG5cblx0X29uVXBkYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25SZW1vdmVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vbkNyZWF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXksIHRpbGU7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3Jkcztcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdHRoaXMuX29uUmVtb3ZlTGV2ZWwoeik7XG5cdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdH1cblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXG5cdFx0dGhpcy5fdGlsZVpvb20gPSBudWxsO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKE1hdGgucm91bmQoem9vbSkpO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKCF0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV0pIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcblxuXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKG53LCBzZSk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ub1dyYXApIHtcblx0XHRcdG1hcC53cmFwTGF0TG5nQm91bmRzKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDc4XG5cdFx0aWYgKEJyb3dzZXIuYW5kcm9pZCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMpIHtcblx0XHRcdHRpbGUuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzLCBudWxsLCB0aWxlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zKTtcblxuXHRcdC8vIHNhdmUgdGlsZSBpbiBjYWNoZVxuXHRcdHRoaXMuX3RpbGVzW2tleV0gPSB7XG5cdFx0XHRlbDogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzLFxuXHRcdFx0Y3VycmVudDogdHJ1ZVxuXHRcdH07XG5cblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGlsZSk7XG5cdFx0Ly8gQGV2ZW50IHRpbGVsb2Fkc3RhcnQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlcXVlc3RlZCBhbmQgc3RhcnRzIGxvYWRpbmcuXG5cdFx0dGhpcy5maXJlKCd0aWxlbG9hZHN0YXJ0Jywge1xuXHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0fSk7XG5cdH0sXG5cblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAoZXJyKSB7XG5cdFx0XHQvLyBAZXZlbnQgdGlsZWVycm9yOiBUaWxlRXJyb3JFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBsb2FkaW5nIGEgdGlsZS5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWVycm9yJywge1xuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0aWYgKCF0aWxlKSB7IHJldHVybjsgfVxuXG5cdFx0dGlsZS5sb2FkZWQgPSArbmV3IERhdGUoKTtcblx0XHRpZiAodGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZhZGVGcmFtZSk7XG5cdFx0XHR0aGlzLl9mYWRlRnJhbWUgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3BydW5lVGlsZXMoKTtcblx0XHR9XG5cblx0XHRpZiAoIWVycikge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG5cdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG5cdFx0XHRpZiAoQnJvd3Nlci5pZWx0OSB8fCAhdGhpcy5fbWFwLl9mYWRlQW5pbWF0ZWQpIHtcblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJpdCBtb3JlIHRoYW4gMC4yIHNlY3MgKHRoZSBkdXJhdGlvbiBvZiB0aGUgdGlsZSBmYWRlLWluKVxuXHRcdFx0XHQvLyB0byB0cmlnZ2VyIGEgcHJ1bmluZy5cblx0XHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyksIDI1MCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRUaWxlUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSkuc3VidHJhY3QodGhpcy5fbGV2ZWwub3JpZ2luKTtcblx0fSxcblxuXHRfd3JhcENvb3JkczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBuZXdDb29yZHMgPSBuZXcgUG9pbnQoXG5cdFx0XHR0aGlzLl93cmFwWCA/IFV0aWwud3JhcE51bShjb29yZHMueCwgdGhpcy5fd3JhcFgpIDogY29vcmRzLngsXG5cdFx0XHR0aGlzLl93cmFwWSA/IFV0aWwud3JhcE51bShjb29yZHMueSwgdGhpcy5fd3JhcFkpIDogY29vcmRzLnkpO1xuXHRcdG5ld0Nvb3Jkcy56ID0gY29vcmRzLno7XG5cdFx0cmV0dXJuIG5ld0Nvb3Jkcztcblx0fSxcblxuXHRfcHhCb3VuZHNUb1RpbGVSYW5nZTogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGdyaWRMYXllcihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgR3JpZExheWVyKG9wdGlvbnMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL0dyaWRMYXllci5qcyIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgQ2FudmFzXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5DYW52YXNcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y2FudmFzKSwgQ2FudmFzIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgSUU4LCBhbmQgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcyBtaWdodFxuICogbm90IGRpc3BsYXkgcHJvcGVybHkgaW4gc29tZSBlZGdlIGNhc2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIENhbnZhcyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLmNhbnZhcygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIENhbnZhcyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLmNhbnZhcyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDYW52YXMgPSBSZW5kZXJlci5leHRlbmQoe1xuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gUmVuZGVyZXIucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXHRcdGV2ZW50cy52aWV3cHJlcmVzZXQgPSB0aGlzLl9vblZpZXdQcmVSZXNldDtcblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vblZpZXdQcmVSZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFNldCBhIGZsYWcgc28gdGhhdCBhIHZpZXdwcmVyZXNldCttb3ZlZW5kK3ZpZXdyZXNldCBvbmx5IHVwZGF0ZXMmcmVkcmF3cyBvbmNlXG5cdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IHRydWU7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKTtcblxuXHRcdC8vIFJlZHJhdyB2ZWN0b3JzIHNpbmNlIGNhbnZhcyBpcyBjbGVhcmVkIHVwb24gcmVtb3ZhbCxcblx0XHQvLyBpbiBjYXNlIG9mIHJlbW92aW5nIHRoZSByZW5kZXJlciBpdHNlbGYgZnJvbSB0aGUgbWFwLlxuXHRcdHRoaXMuX2RyYXcoKTtcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlbW92ZScsIFV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3VzZU1vdmUsIDMyLCB0aGlzKSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblxuXHRcdHRoaXMuX2N0eCA9IGNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuXHR9LFxuXG5cdF9kZXN0cm95Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX2N0eDtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbGF5ZXI7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHR9XG5cdFx0dGhpcy5fcmVkcmF3KCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZHJhd25MYXllcnMgPSB7fTtcblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIG0gPSBCcm93c2VyLnJldGluYSA/IDIgOiAxO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblxuXHRcdC8vIHNldCBjYW52YXMgc2l6ZSAoYWxzbyBjbGVhcmluZyBpdCk7IHVzZSBkb3VibGUgc2l6ZSBvbiByZXRpbmFcblx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuXHRcdGNvbnRhaW5lci5oZWlnaHQgPSBtICogc2l6ZS55O1xuXHRcdGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG5cdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cblx0XHRpZiAoQnJvd3Nlci5yZXRpbmEpIHtcblx0XHRcdHRoaXMuX2N0eC5zY2FsZSgyLCAyKTtcblx0XHR9XG5cblx0XHQvLyB0cmFuc2xhdGUgc28gd2UgdXNlIHRoZSBzYW1lIHBhdGggY29vcmRpbmF0ZXMgYWZ0ZXIgY2FudmFzIGVsZW1lbnQgbW92ZXNcblx0XHR0aGlzLl9jdHgudHJhbnNsYXRlKC1iLm1pbi54LCAtYi5taW4ueSk7XG5cblx0XHQvLyBUZWxsIHBhdGhzIHRvIHJlZHJhdyB0aGVtc2VsdmVzXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyk7XG5cblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykge1xuXHRcdFx0dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblxuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlciA9IHtcblx0XHRcdGxheWVyOiBsYXllcixcblx0XHRcdHByZXY6IHRoaXMuX2RyYXdMYXN0LFxuXHRcdFx0bmV4dDogbnVsbFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX2RyYXdMYXN0KSB7IHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjsgfVxuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gdGhpcy5fZHJhd0ZpcnN0IHx8IHRoaXMuX2RyYXdMYXN0O1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRkZWxldGUgbGF5ZXIuX29yZGVyO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tMLnN0YW1wKGxheWVyKV07XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gUmVkcmF3IHRoZSB1bmlvbiBvZiB0aGUgbGF5ZXIncyBvbGQgcGl4ZWxcblx0XHQvLyBib3VuZHMgYW5kIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0Ly8gVGhlIHJlZHJhdyB3aWxsIGV4dGVuZCB0aGUgcmVkcmF3IGJvdW5kc1xuXHRcdC8vIHdpdGggdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR0aGlzLl91cGRhdGVEYXNoQXJyYXkobGF5ZXIpO1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVEYXNoQXJyYXk6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5vcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoJywnKSxcblx0XHRcdCAgICBkYXNoQXJyYXkgPSBbXSxcblx0XHRcdCAgICBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKE51bWJlcihwYXJ0c1tpXSkpO1xuXHRcdFx0fVxuXHRcdFx0bGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jb250YWluZXIud2lkdGgsIHRoaXMuX2NvbnRhaW5lci5oZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBhcnRzW2ldW2pdO1xuXHRcdFx0XHRjdHhbaiA/ICdsaW5lVG8nIDogJ21vdmVUbyddKHAueCwgcC55KTtcblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogMSBmaWxsL3N0cm9rZSBmb3IgYWxsIGZlYXR1cmVzIHdpdGggZXF1YWwgc3R5bGUgaW5zdGVhZCBvZiAxIGZvciBlYWNoIGZlYXR1cmVcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdGlmICghdGhpcy5fZHJhd2luZyB8fCBsYXllci5fZW1wdHkoKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHgsXG5cdFx0ICAgIHIgPSBsYXllci5fcmFkaXVzLFxuXHRcdCAgICBzID0gKGxheWVyLl9yYWRpdXNZIHx8IHIpIC8gcjtcblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXSA9IGxheWVyO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc2NhbGUoMSwgcyk7XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblx0fSxcblxuXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG5cdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVyLCBjbGlja2VkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSAmJiAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbGlja2VkTGF5ZXIpICB7XG5cdFx0XHREb21FdmVudC5mYWtlU3RvcChlKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2xpY2tlZExheWVyXSwgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaWdubGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpZ25sZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcyIsImltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5pbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVhcnRoJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogTWF0aC5tYXgoTWF0aC5yb3VuZChwLnggLSBtYXAucHJvamVjdChbbGF0MiwgbG5nIC0gbG5nUl0pLngpLCAxKTtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBNYXRoLm1heChNYXRoLnJvdW5kKHAueSAtIHRvcC55KSwgMSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxhdGxuZzIgPSBjcnMudW5wcm9qZWN0KGNycy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsIDBdKSk7XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gdGhpcy5fcG9pbnQueCAtIG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nMikueDtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50LCBhbmQgYW4gb3B0aW9ucyBvYmplY3Rcbi8vIHdoaWNoIGNvbnRhaW5zIHRoZSBjaXJjbGUgcmFkaXVzLlxuLy8gQGFsdGVybmF0aXZlXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgcmFkaXVzOiBOdW1iZXIsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIE9ic29sZXRlIHdheSBvZiBpbnN0YW50aWF0aW5nIGEgY2lyY2xlLCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGNvZGUuXG4vLyBEbyBub3QgdXNlIGluIG5ldyBhcHBsaWNhdGlvbnMgb3IgcGx1Z2lucy5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DaXJjbGUuanMiLCJpbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuL0xpbmVVdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnZW1hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBlcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvUG9seVV0aWwuanMiLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7c3RhbXB9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3N2Z0NyZWF0ZSwgcG9pbnRzVG9QYXRofSBmcm9tICcuL1NWRy5VdGlsJztcbmV4cG9ydCB7cG9pbnRzVG9QYXRofTtcbmltcG9ydCB7dm1sTWl4aW4sIHZtbENyZWF0ZX0gZnJvbSAnLi9TVkcuVk1MJztcblxuZXhwb3J0IHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IGxheWVyLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gbGF5ZXIuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdFx0YXJjICsgKHIgKiAyKSArICcsMCAnICtcblx0XHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cbmlmIChCcm93c2VyLnZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXIgKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IE1hcmtlcihsYXRsbmcpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2gocG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTWFya2VyKGxhdGxuZykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChsYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbi8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRcdGNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBfY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhdGxuZ3M7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmcsIHByZWNpc2lvbikge1xyXG5cdHByZWNpc2lvbiA9IHR5cGVvZiBwcmVjaXNpb24gPT09ICdudW1iZXInID8gcHJlY2lzaW9uIDogNjtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuXHRcdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbildO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3M6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjbG9zZWQ/OiBCb29sZWFuKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuLy8gYGNsb3NlZGAgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaXJzdCBwb2ludCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gY2xvc2UgdGhlIGZlYXR1cmUsIG9ubHkgdXNlZCB3aGVuIGBsZXZlbHNEZWVwYCBpcyAwLiBGYWxzZSBieSBkZWZhdWx0LlxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkLCBwcmVjaXNpb24pIDpcclxuXHRcdFx0bGF0TG5nVG9Db29yZHMobGF0bG5nc1tpXSwgcHJlY2lzaW9uKSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRjb29yZHMucHVzaChjb29yZHNbMF0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvb3JkcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZlYXR1cmUobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0cmV0dXJuIGxheWVyLmZlYXR1cmUgP1xyXG5cdFx0XHRVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDpcclxuXHRcdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuUG9seWdvbi5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBob2xlcyA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRpZiAoIWhvbGVzKSB7XHJcblx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludChwcmVjaXNpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xyXG5cdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcblx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4vLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuLy8gW0dlb0pTT04gZm9ybWF0XShodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWwpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5leHBvcnQgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0dlb0pTT04uanMiLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIFRha2VzIGludG8gYWNjb3VudCB0aGF0IEVhcnRoIGlzIGEgZ2VvaWQsIG5vdCBhIHBlcmZlY3Qgc3BoZXJlLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yLmpzIiwiaW1wb3J0IHsgRWxlbWVudCBhcyBQb2x5bWVyRWxlbWVudCB9IGZyb20gJy4uLy4uL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCAnLi4vLi4vQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uLmpzJztcblxuaW1wb3J0IHsgRmVhdHVyZUdyb3VwIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvRmVhdHVyZUdyb3VwLmpzJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLmpzJztcbmltcG9ydCBpY29uIGZyb20gJy4uLy4uL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24ucG5nJztcbmltcG9ydCBpY29uU2hhZG93IGZyb20gJy4uLy4uL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmcnO1xuXG5pbXBvcnQgeyBMZWFmbGV0TWFwIH0gZnJvbSAnLi4vLi4vQGdnY2l0eS9sZWFmbGV0LW1hcC9sZWFmbGV0LW1hcC5qcyc7XG5pbXBvcnQgeyBMZWFmbGV0V01TR3JvdXAgfSBmcm9tICcuLi8uLi9AZ2djaXR5L2xlYWZsZXQtd21zL2xlYWZsZXQtd21zLWdyb3VwLmpzJztcbmltcG9ydCB7IExlYWZsZXRUaWxlTGF5ZXIgfSBmcm9tICcuLi8uLi9AZ2djaXR5L2xlYWZsZXQtdGlsZS1sYXllci9sZWFmbGV0LXRpbGUtbGF5ZXIuanMnO1xuaW1wb3J0IHsgTGVhZmxldEdlb0pTT04gfSBmcm9tICcuLi8uLi9AZ2djaXR5L2xlYWZsZXQtZ2VvanNvbi9sZWFmbGV0LWdlb2pzb24tcG9pbnRzLmpzJztcblxudmFyIHlhbWwgPSByZXF1aXJlKCcuLi8uLi9qcy15YW1sL2Rpc3QvanMteWFtbC5taW4uanMnKTtcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL2FwcC50ZW1wbGF0ZS5odG1sJztcblxuZXhwb3J0IGNsYXNzIEdHTWFwVmlld2VyIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3RcbiAgICAgIH0sXG4gICAgICBiYXNlU291cmNlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhc2VGb3JtYXQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWRPdmVybGF5OiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfb3ZlcmxheUNoYW5nZWQnXG4gICAgICB9LFxuICAgICAgd21zR3JvdXBzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB2YWx1ZTogW11cbiAgICAgIH0sXG4gICAgICBnZW9qc29uTGF5ZXJzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB2YWx1ZTogW11cbiAgICAgIH0sXG4gICAgICBiYXNlTWFwczoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcbiAgICAgIG92ZXJsYXlNYXBzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5XG4gICAgICB9LFxuICAgICAgc2VhcmNoTWFya2Vyczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICBvYnNlcnZlcjogJ19tYXJrTWFwJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9tYXJrZXJzR3JvdXAgPSBuZXcgRmVhdHVyZUdyb3VwKFtdKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICBmZXRjaCh0aGlzLmNvbmZpZykudGhlbihyID0+IHIudGV4dCgpKVxuICAgICAgLnRoZW4odGhpcy5pbml0aWFsaXplTWFwLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplU2VhcmNoKCk7XG4gIH1cblxuICBpbml0aWFsaXplTWFwKHJlc3BvbnNlKSB7XG4gICAgbGV0IHJqc29uID0geWFtbC5zYWZlTG9hZChyZXNwb25zZSk7XG5cbiAgICB0aGlzLmJhc2VNYXBzID0gcmpzb24uYmFzZU1hcHM7XG4gICAgdGhpcy5vdmVybGF5TWFwcyA9IHJqc29uLm92ZXJsYXlNYXBzO1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGdyb3VwcyBvZiBsYXllcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3ZlcmxheU1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsID0gdGhpcy5vdmVybGF5TWFwc1tpXS5sYXllcnM7XG4gICAgICB0aGlzLm92ZXJsYXlNYXBzW2ldLmZsYXR0ZW5lZExheWVycyA9IFtdO1xuXG4gICAgICAvLyBpdGVyYXRlIHRocm91Z2ggbGF5ZXIgaW50ZXJhY3Rpb24gdHlwZXMgKGFsd2F5cyBvbiwgZXhjbHVzaXZlcywgb3B0aW9uYWxzKVxuICAgICAgZm9yIChsZXQgdCBpbiBsKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheU1hcHNbaV0uZmxhdHRlbmVkTGF5ZXJzID0gdGhpcy5vdmVybGF5TWFwc1tpXS5mbGF0dGVuZWRMYXllcnMuY29uY2F0KGxbdF0pO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBhbGwgbGF5ZXJzXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbFt0XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxbdF1bal0uaW50ZXJhY3Rpb24gPSB0O1xuXG4gICAgICAgICAgLy8gYWx3YXlzIG9uIGxheWVycyBzaG91bGQgYWx3YXlzIGJlIHZpc2libGVcbiAgICAgICAgICBpZiAodCA9PT0gJ2Fsd2F5c09uJykge1xuICAgICAgICAgICAgbFt0XVtqXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGb3IgY29udmVuaWVuY2UsIGFsbG93IHNvdXJjZSB0byBiZSBnbG9iYWxseSBkZWZpbmVkLCBidXQgcHJvcGFnYXRlIGl0IGhlcmUuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGxbdF1bal0udHlwZSA9PT0gJ3dtcycgfHwgbFt0XVtqXS50eXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAmJiBsW3RdW2pdLnNvdXJjZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsW3RdW2pdLnR5cGUgPSAnd21zJztcbiAgICAgICAgICAgIGxbdF1bal0uc291cmNlID0gcmpzb24ud21zRGVmYXVsdFNvdXJjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGSVhNRTogaGFja3kgaGFyZGNvZGVkIGluaXRpYWwgdmlld1xuICAgIHRoaXMuX3NlbGVjdGVkQmFzZW1hcCA9IDA7XG4gICAgdGhpcy5iYXNlU291cmNlID0gdGhpcy5iYXNlTWFwc1swXS5zb3VyY2U7XG4gICAgdGhpcy5iYXNlRm9ybWF0ID0gdGhpcy5iYXNlTWFwc1swXS5mb3JtYXQ7XG4gICAgdGhpcy5iYXNlTGF5ZXJzID0gdGhpcy5iYXNlTWFwc1swXS5sYXllcnM7XG5cbiAgICB0aGlzLm92ZXJsYXlTZWxlY3QoKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTZWFyY2goKSB7XG4gICAgdGhpcy5fbWFya2Vyc0dyb3VwLmFkZFRvKHRoaXMubWFwKTtcblxuICAgIGpRdWVyeSgnI3NlYXJjaCcsIHRoaXMuc2hhZG93Um9vdCkuYXV0b2NvbXBsZXRlKHtcbiAgICAgIHByZXZlbnRCYWRRdWVyaWVzOiBmYWxzZSxcbiAgICAgIGRlZmVyUmVxdWVzdEJ5OiAyMDAsXG4gICAgICBtaW5DaGFyczogMyxcbiAgICAgIHNlcnZpY2VVcmw6ICcvL3d3dy5jaS5nYXJkZW4tZ3JvdmUuY2EudXMvbWFwcy9hcGkvYWRkcmVzc2VzL3NlYXJjaCcsXG4gICAgICBwYXJhbU5hbWU6ICdxJyxcbiAgICAgIC8vIHBhcmFtczogeyBsaW1pdDogMTAgfSxcbiAgICAgIHRyYW5zZm9ybVJlc3VsdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBhZGRyZXNzZXMgPSBKU09OLnBhcnNlKHJlc3BvbnNlKS5hZGRyZXNzZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VnZ2VzdGlvbnM6IGFkZHJlc3Nlcy5tYXAoZCA9PiAoeyB2YWx1ZTogZC5hZGRyZXNzLCBkYXRhOiBkIH0pKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TZWFyY2hTdGFydDogKCkgPT4gdGhpcy5zZXQoJ3NlYXJjaE1ha2VycycsIFtdKSxcbiAgICAgIG9uU2VhcmNoQ29tcGxldGU6IChxLCBzKSA9PiB0aGlzLnNldCgnc2VhcmNoTWFya2VycycsIHMubWFwKCBvYmogPT4gW29iai5kYXRhLmxhdGl0dWRlLCBvYmouZGF0YS5sb25naXR1ZGVdICkpLFxuICAgICAgb25TZWxlY3Q6IG9iaiA9PiB0aGlzLnNldCgnc2VhcmNoTWFya2VycycsIFtbb2JqLmRhdGEubGF0aXR1ZGUsIG9iai5kYXRhLmxvbmdpdHVkZV1dKVxuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlTGF5ZXIoZXZlbnQpIHtcbiAgICAvLyBGaXJzdCBzYXZlIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgbGV0IGN1cnJWaXNpYmxlID0gZXZlbnQubW9kZWwubGF5ZXIudmlzaWJsZTtcblxuICAgIGlmIChldmVudC5tb2RlbC5sYXllci5pbnRlcmFjdGlvbiA9PT0gJ2V4Y2x1c2l2ZXMnKSB7XG4gICAgICAvLyBUdXJuIGFsbCBleGNsdXNpdmUgbGF5ZXJzIG9mZlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkT3ZlcmxheS5sYXllcnMuZXhjbHVzaXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNldCgnc2VsZWN0ZWRPdmVybGF5LmxheWVycy5leGNsdXNpdmVzLicgKyBpICsgJy52aXNpYmxlJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdG9nZ2xlIG9uIG9yaWdpbmFsIHN0YXRlXG4gICAgZXZlbnQubW9kZWwuc2V0KCdsYXllci52aXNpYmxlJywgIWN1cnJWaXNpYmxlKTtcblxuICAgIHRoaXMuX3BhcnNlTGF5ZXJzKHRoaXMuc2VsZWN0ZWRPdmVybGF5KTtcbiAgfVxuXG4gIG92ZXJsYXlTZWxlY3QoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkT3ZlcmxheSA9IChldmVudCkgPyBldmVudC5tb2RlbC5pdGVtIDogdGhpcy5vdmVybGF5TWFwc1swXTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkT3ZlcmxheS5yZXNldFZpZXdPblNlbGVjdCkge1xuICAgICAgdGhpcy5tYXAuZmx5VG8odGhpcy5zZWxlY3RlZE92ZXJsYXkuaW5pdGlhbENlbnRlciwgdGhpcy5zZWxlY3RlZE92ZXJsYXkuaW5pdGlhbFpvb20pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWEU6IEFjaHR1bmchIFViZXIgaGFja3khISFcbiAgc3dpdGNoQmFzZW1hcChldmVudCkge1xuICAgIGxldCBpZHggPSArK3RoaXMuX3NlbGVjdGVkQmFzZW1hcCAlIDI7XG4gICAgdGhpcy5iYXNlU291cmNlID0gdGhpcy5iYXNlTWFwc1tpZHhdLnNvdXJjZTtcbiAgICB0aGlzLmJhc2VGb3JtYXQgPSB0aGlzLmJhc2VNYXBzW2lkeF0uZm9ybWF0O1xuICAgIHRoaXMuYmFzZUxheWVycyA9IHRoaXMuYmFzZU1hcHNbaWR4XS5sYXllcnM7XG5cbiAgICBpZiAoaWR4ID09PSAxKSB7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi92ZWN0b3IucG5nKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi9hZXJpYWwucG5nKVwiO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUxheWVyc01lbnUoKSB7XG4gICAgbGV0IGxheWVyc01lbnUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignbWFpbiNsYXllcnMtbWVudScpO1xuICAgIGxheWVyc01lbnUuY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpO1xuICB9XG5cbiAgX3BhcnNlTGF5ZXJzKG92ZXJsYXkpIHtcbiAgICBsZXQgbGF5ZXJzID0gb3ZlcmxheS5mbGF0dGVuZWRMYXllcnM7XG4gICAgbGV0IHdtc0xheWVycyA9IHt9O1xuXG4gICAgLy8gcmVzZXRcbiAgICB0aGlzLnNldCgnd21zR3JvdXBzJywgW10pO1xuICAgIHRoaXMuc2V0KCdnZW9qc29uTGF5ZXJzJywgW10pO1xuXG4gICAgbGF5ZXJzXG4gICAgICAuZmlsdGVyKGwgPT4gbC52aXNpYmxlKVxuICAgICAgLmZvckVhY2gobCA9PiB7XG4gICAgICAgIGlmIChsLnR5cGUgPT09ICd3bXMnKSB7XG4gICAgICAgICAgLy8gZ3JvdXAgdGhlIHNvdXJjZXNcbiAgICAgICAgICB3bXNMYXllcnNbbC5zb3VyY2VdID0gd21zTGF5ZXJzW2wuc291cmNlXSB8fCBbXTtcbiAgICAgICAgICB3bXNMYXllcnNbbC5zb3VyY2VdLnB1c2gobC5tYWNoaW5lTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobC50eXBlID09PSAnZ2VvanNvbicpIHtcbiAgICAgICAgICB0aGlzLnB1c2goJ2dlb2pzb25MYXllcnMnLCBsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAvLyBmbGF0dGVuZWQgdGhlIGdyb3VwZWQgV01TIHNvdXJjZXNcbiAgICBmb3IgKGxldCBzIGluIHdtc0xheWVycykge1xuICAgICAgdGhpcy5wdXNoKCd3bXNHcm91cHMnLCB7IHNvdXJjZTogcywgbGF5ZXJzOiB3bXNMYXllcnNbc10gfSk7XG4gICAgfVxuICB9XG5cbiAgX21hcmtNYXAobWFya2Vyc0Nvb3Jkcykge1xuICAgIHRoaXMuX21hcmtlcnNHcm91cC5jbGVhckxheWVycygpO1xuICAgIGlmIChtYXJrZXJzQ29vcmRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgbWFya2Vyc0Nvb3Jkcy5mb3JFYWNoKG0gPT4ge1xuICAgICAgdGhpcy5fbWFya2Vyc0dyb3VwXG4gICAgICAuYWRkTGF5ZXIobmV3IE1hcmtlcihtLCB7IGljb246IG5ldyBJY29uKHsgaWNvblVybDogaWNvbiwgc2hhZG93VXJsOiBpY29uU2hhZG93IH0pfSkpXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKG1hcmtlcnNDb29yZHMubGVuZ3RoID09PSAxKSB0aGlzLm1hcC5mbHlUbyhtYXJrZXJzQ29vcmRzWzBdKTtcbiAgICBlbHNlIHRoaXMubWFwLmZpdEJvdW5kcyh0aGlzLl9tYXJrZXJzR3JvdXAuZ2V0Qm91bmRzKCkpO1xuICB9XG5cbiAgX2lzQ3VycmVudEV4Y2x1c2l2ZShsYXllcikge1xuICAgIHJldHVybiBsYXllci52aXNpYmxlO1xuICB9XG5cbiAgX2lzQ3VycmVudE92ZXJsYXkoc2VsZWN0ZWQsIGl0ZW0pIHtcbiAgICByZXR1cm4gc2VsZWN0ZWQgPT09IGl0ZW07XG4gIH1cblxuICBfb3ZlcmxheUNoYW5nZWQobmV3T3ZlcmxheSkge1xuICAgIHRoaXMuX3BhcnNlTGF5ZXJzKG5ld092ZXJsYXkpO1xuICB9XG5cbiAgX292ZXJsYXlMYXllcnNTaG93KHNlbGVjdGVkLCBpdGVtKSB7XG4gICAgaWYgKHNlbGVjdGVkID09PSBpdGVtKSByZXR1cm4gXCJjb2xsYXBzZSBzaG93XCI7XG4gICAgcmV0dXJuIFwiY29sbGFwc2VcIjtcbiAgfVxuXG4gIF9vdmVybGF5SXRlbUNsYXNzKHNlbGVjdGVkLCBpdGVtKSB7XG4gICAgbGV0IGRlZmF1bHRDbGFzcyA9IFwib3ZlcmxheS1pdGVtIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtc3RhcnRcIjtcbiAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW0pIHJldHVybiBkZWZhdWx0Q2xhc3MgKyAnIHNlbGVjdGVkJztcbiAgICByZXR1cm4gZGVmYXVsdENsYXNzO1xuICB9XG5cbiAgLy8gRklYTUU6IG1ha2UgdGhpcyBsZXNzIGhhcmRjb2RleVxuICBkb3dubG9hZExheWVyKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIC8vIGlmIG1vZGFsIGlzIG5vdCBhbHJlYWR5IGZvdW5kIGluIGxpZ2h0IERPTSwgcHVsbCBmcm9tIHNoYWRvdyBET01cbiAgICBsZXQgZG9tID0gKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkb3dubG9hZC1tb2RhbCcpKSA/IGRvY3VtZW50IDogdGhpcy5zaGFkb3dSb290O1xuXG4gICAgbGV0IGxheWVyID0gZXZlbnQubW9kZWwubGF5ZXI7XG4gICAgLy8gRklYTUU6IGhhcmRjb2RlZCB1cmxcbiAgICBsZXQgZG93bmxvYWRVUkwgPSBgaHR0cHM6Ly93d3cuY2kuZ2FyZGVuLWdyb3ZlLmNhLnVzL2dlb3NlcnZlci9naXMvb3dzP3NlcnZpY2U9V0ZTJnZlcnNpb249MS4wLjAmcmVxdWVzdD1HZXRGZWF0dXJlJnR5cGVOYW1lPSR7bGF5ZXIubWFjaGluZU5hbWV9YDtcblxuICAgIGpRdWVyeSgnI2xheWVyLW5hbWUnLCBkb20pLmh0bWwobGF5ZXIubmFtZSk7XG4gICAgalF1ZXJ5KCcjZ2VvanNvbi1kb3dubG9hZCcsIGRvbSkuYXR0cignaHJlZicsIGRvd25sb2FkVVJMICsgJyZvdXRwdXRGb3JtYXQ9YXBwbGljYXRpb24vanNvbicpO1xuICAgIGpRdWVyeSgnI2Nzdi1kb3dubG9hZCcsIGRvbSkuYXR0cignaHJlZicsIGRvd25sb2FkVVJMICsgJyZvdXRwdXRGb3JtYXQ9Y3N2Jyk7XG4gICAgalF1ZXJ5KCcja21sLWRvd25sb2FkJywgZG9tKS5hdHRyKCdocmVmJywgZG93bmxvYWRVUkwgKyAnJm91dHB1dEZvcm1hdD1hcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWwnKTtcbiAgICBqUXVlcnkoJyNzaGFwZWZpbGUtZG93bmxvYWQnLCBkb20pLmF0dHIoJ2hyZWYnLCBkb3dubG9hZFVSTCArICcmb3V0cHV0Rm9ybWF0PVNIQVBFLVpJUCcpO1xuICAgIGpRdWVyeSgnI2Rvd25sb2FkLW1vZGFsJywgZG9tKS5tb2RhbCgpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZ2ctbWFwLXZpZXdlcicsIEdHTWFwVmlld2VyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9nZy1tYXAtdmlld2VyLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwJDAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuXG5sZXQgY2FzZU1hcCA9IGNhc2VNYXAkMDtcblxubGV0IG1pY3JvdGFzayA9IG1pY3JvVGFzaztcblxuLy8gU2F2ZSBtYXAgb2YgbmF0aXZlIHByb3BlcnRpZXM7IHRoaXMgZm9ybXMgYSBibGFja2xpc3Qgb3IgcHJvcGVydGllc1xuLy8gdGhhdCB3b24ndCBoYXZlIHRoZWlyIHZhbHVlcyBcInNhdmVkXCIgYnkgYHNhdmVBY2Nlc3NvclZhbHVlYCwgc2luY2Vcbi8vIHJlYWRpbmcgZnJvbSBhbiBIVE1MRWxlbWVudCBhY2Nlc3NvciBmcm9tIHRoZSBjb250ZXh0IG9mIGEgcHJvdG90eXBlIHRocm93c1xuY29uc3QgbmF0aXZlUHJvcGVydGllcyA9IHt9O1xubGV0IHByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xud2hpbGUgKHByb3RvKSB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgZm9yIChsZXQgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmF0aXZlUHJvcGVydGllc1twcm9wc1tpXV0gPSB0cnVlO1xuICB9XG4gIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNhdmUgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aFxuICogYW4gYWNjZXNzb3IuIElmIHRoZSBgbW9kZWxgIGlzIGEgcHJvdG90eXBlLCB0aGUgdmFsdWVzIHdpbGwgYmUgc2F2ZWRcbiAqIGluIGBfX2RhdGFQcm90b2AsIGFuZCBpdCdzIHVwIHRvIHRoZSB1c2VyIChvciBkb3duc3RyZWFtIG1peGluKSB0b1xuICogZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aGVzZSB2YWx1ZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3NvcnMuXG4gKiBJZiBgbW9kZWxgIGlzIGFscmVhZHkgYW4gaW5zdGFuY2UgKGl0IGhhcyBhIGBfX2RhdGFgIHByb3BlcnR5KSwgdGhlblxuICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGFzIGEgcGVuZGluZyBwcm9wZXJ0eSwgbWVhbmluZyB0aGUgdXNlciBzaG91bGRcbiAqIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgIHRvIHRha2UgZWZmZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmVBY2Nlc3NvclZhbHVlKG1vZGVsLCBwcm9wZXJ0eSkge1xuICAvLyBEb24ndCByZWFkL3N0b3JlIHZhbHVlIGZvciBhbnkgbmF0aXZlIHByb3BlcnRpZXMgc2luY2UgdGhleSBjb3VsZCB0aHJvd1xuICBpZiAoIW5hdGl2ZVByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgbGV0IHZhbHVlID0gbW9kZWxbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobW9kZWwuX19kYXRhKSB7XG4gICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBpbnN0YW5jZTsgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBJdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhbGwgX2ZsdXNoUHJvcGVydGllc1xuICAgICAgICBtb2RlbC5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gcHJvdG87IHNhdmUgcHJvdG8ncyB2YWx1ZSBmb3IgaW5zdGFuY2UtdGltZSB1c2VcbiAgICAgICAgaWYgKCFtb2RlbC5fX2RhdGFQcm90bykge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YVByb3RvJywgbW9kZWwpKSkge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0gT2JqZWN0LmNyZWF0ZShtb2RlbC5fX2RhdGFQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuX19kYXRhUHJvdG9bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUFjY2Vzc29ycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29ycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHN0YW5kYXJkXG4gICAgICogc3RhdGljIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQXR0cmlidXRlIG5hbWVzIGFyZSBtYXBwZWQgdG8gcHJvcGVydHkgbmFtZXMgdXNpbmcgdGhlIGBkYXNoLWNhc2VgIHRvXG4gICAgICogYGNhbWVsQ2FzZWAgY29udmVudGlvblxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKCkge1xuICAgICAgbGV0IGEkID0gdGhpcy5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBhJC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlBY2Nlc3NvcihjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhJFtpXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19zZXJpYWxpemluZztcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhSW52YWxpZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVByb3RvO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHM7XG4gICAgICB0aGlzLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgbmF0aXZlIEN1c3RvbSBFbGVtZW50cyBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0b1xuICAgICAqIHNldCBhbiBhdHRyaWJ1dGUgdmFsdWUgdG8gYSBwcm9wZXJ0eSB2aWEgYF9hdHRyaWJ1dGVUb1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlIHRoYXQgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIE5ldyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKlxuICAgICAqIFByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwZXJmb3JtaW5nIGFueSBzZXR1cCB3b3JrIHByaW9yXG4gICAgICogdG8gaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSBhY2Nlc3NvciBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhID0ge307XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyh0aGlzLl9fZGF0YVByb3RvKTtcbiAgICAgICAgdGhpcy5fX2RhdGFQcm90byA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBDYXB0dXJlIGluc3RhbmNlIHByb3BlcnRpZXM7IHRoZXNlIHdpbGwgYmUgc2V0IGludG8gYWNjZXNzb3JzXG4gICAgICAvLyBkdXJpbmcgZmlyc3QgZmx1c2guIERvbid0IHNldCB0aGVtIGhlcmUsIHNpbmNlIHdlIHdhbnRcbiAgICAgIC8vIHRoZXNlIHRvIG92ZXJ3cml0ZSBkZWZhdWx0cy9jb25zdHJ1Y3RvciBhc3NpZ25tZW50c1xuICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wc1twXSA9IHRoaXNbcF07XG4gICAgICAgICAgZGVsZXRlIHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgaW5zdGFuY2UgdGltZSB3aXRoIGJhZyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqIGJ5IGFjY2Vzc29ycyBvbiB0aGUgcHJvdG90eXBlIHdoZW4gYWNjZXNzb3JzIHdlcmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICogc2V0dGVyIGF0IGluc3RhbmNlIHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwLCBwcm9wc1twXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IHJlYWR5IHRpbWUgd2l0aCBiYWcgb2YgaW5zdGFuY2UgcHJvcGVydGllcyB0aGF0IG92ZXJ3cm90ZVxuICAgICAqIGFjY2Vzc29ycyB3aGVuIHRoZSBlbGVtZW50IHVwZ3JhZGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgKiBzZXR0ZXIgYXQgcmVhZHkgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBJZiBpdCBkb2VzIG5vdCxcbiAgICAgKiBhc3NpZ25zIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGVuc3VyZSBpcyBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGFuIGF0dHJpYnV0ZSB0byBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG9cbiAgICAgKiBhIHR5cGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSB0eXBlIHRvIGRlc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgIC8vIERvbid0IGRlc2VyaWFsaXplIGJhY2sgdG8gcHJvcGVydHkgaWYgY3VycmVudGx5IHJlZmxlY3RpbmdcbiAgICAgIGlmICghdGhpcy5fX3NlcmlhbGl6aW5nKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICovXG4gICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyB0aGlzW3Byb3BlcnR5XSA6IHZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsXG4gICAgICAgIGF0dHJpYnV0ZSB8fCBjYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkpO1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgdHlwZWRcbiAgICAgKiB2YWx1ZSB0byBhIHN0cmluZy4gIElmIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCAodGhpcyBpcyB0aGUgZGVmYXVsdCBmb3IgYm9vbGVhblxuICAgICAqIHR5cGUgYGZhbHNlYCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICBsZXQgc3RyID0gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiBzZXR0aW5nIEpTIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAqIEhUTUwgYXR0cmlidXRlcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTdHJpbmcgc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBfc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnJyA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHJlYWRpbmcgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzIHRvXG4gICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gIE5vdGUsXG4gICAgICogdGhlIGB0eXBlYCBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGB0eXBlYCBmaWVsZCBwcm92aWRlZCBpbiB0aGVcbiAgICAgKiBgcHJvcGVydGllc2AgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIGFuZCBpc1xuICAgICAqIGJ5IGNvbnZlbnRpb24gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoZSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgaXMgdXNlZCBhcyBhIHNlbnRpbmVsIHZhbHVlIHRvXG4gICAgICogaW5kaWNhdGUgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvLlxuICAgICAqIEByZXR1cm4geyp9IFR5cGVkIHZhbHVlIGRlc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgKi9cbiAgICAgIGxldCBvdXRWYWx1ZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICBvdXRWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgIG91dFZhbHVlID0gKHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IG5vbi1KU09OIGxpdGVyYWxzIGxpa2UgU3RyaW5ncyBhbmQgTnVtYmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBQb2x5bWVyOjpBdHRyaWJ1dGVzOiBjb3VsZG4ndCBkZWNvZGUgQXJyYXkgYXMgSlNPTjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgIG91dFZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRWYWx1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldHRlci9nZXR0ZXIgcGFpciBmb3IgdGhlIG5hbWVkIHByb3BlcnR5IHdpdGggaXRzIG93blxuICAgICAqIGxvY2FsIHN0b3JhZ2UuICBUaGUgZ2V0dGVyIHJldHVybnMgdGhlIHZhbHVlIGluIHRoZSBsb2NhbCBzdG9yYWdlLFxuICAgICAqIGFuZCB0aGUgc2V0dGVyIGNhbGxzIGBfc2V0UHJvcGVydHlgLCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlXG4gICAgICogZm9yIHRoZSBwcm9wZXJ0eSBhbmQgZW5xdWV1ZXMgYSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuICBDYWxsaW5nXG4gICAgICogdGhpcyBtZXRob2QgbWF5IG92ZXJ3cml0ZSBhIHByb3BlcnR5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb25cbiAgICAgKiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGJ5IGNyZWF0aW5nIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvblxuICAgICAqIGEgcHJvdG90eXBlLCBhbnkgb3ZlcndyaXR0ZW4gdmFsdWVzIGFyZSBzYXZlZCBpbiBgX19kYXRhUHJvdG9gLFxuICAgICAqIGFuZCBpdCBpcyB1cCB0byB0aGUgc3ViY2xhc3NlciB0byBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRob3NlXG4gICAgICogcHJvcGVydGllcyBiYWNrIGludG8gdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uIGFuIGluc3RhbmNlLFxuICAgICAqIHRoZSBvdmVyd3JpdHRlbiB2YWx1ZSBpcyBzZXQgdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YCwgYW5kIHRoZVxuICAgICAqIHVzZXIgc2hvdWxkIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICogZm9yIHRoZSB2YWx1ZXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWFkT25seSBXaGVuIHRydWUsIG5vIHNldHRlciBpcyBjcmVhdGVkOyB0aGVcbiAgICAgKiAgIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kYXRhSGFzQWNjZXNzb3InKSkge1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldKSB7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgc2F2ZUFjY2Vzc29yVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgIHNldDogcmVhZE9ubHkgPyBmdW5jdGlvbigpIHt9IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlicmFyeSBjcmVhdGVkIGFuIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gYWNjZXNzb3Igd2FzIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBfaGFzQWNjZXNzb3IocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHkgKHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWApXG4gICAgICogYW5kIGVucXVldWVzIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5LCByZWNvcmRzIHRoZSBwcmV2aW91cyB2YWx1ZSxcbiAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgc2V0IG9mIFwicGVuZGluZyBjaGFuZ2VzXCIgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay4gIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVucXVldWUgdGhlXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgbGV0IG9sZCA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YU9sZCAmJiAhKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fX2RhdGFQZW5kaW5nICYmIChwcm9wIGluIHRoaXMuX19kYXRhUGVuZGluZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBwcm9wZXJ0aWVzIGFzIGludmFsaWQsIGFuZCBlbnF1ZXVlcyBhbiBhc3luY1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFJbnZhbGlkICYmIHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgbWljcm90YXNrLnJ1bigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdG8gZW5hYmxlIHByb3BlcnR5IGFjY2Vzc29yIHByb2Nlc3NpbmcuIEJlZm9yZSB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCBhY2Nlc3NvciB2YWx1ZXMgd2lsbCBiZSBzZXQgYnV0IHNpZGUgZWZmZWN0cyBhcmVcbiAgICAgKiBxdWV1ZWQuIFdoZW4gY2FsbGVkLCBhbnkgcGVuZGluZyBzaWRlIGVmZmVjdHMgb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgICogRm9yIGVsZW1lbnRzLCBnZW5lcmFsbHkgYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBhIG5vcm1hbCBzcG90IHRvIGRvIHNvLlxuICAgICAqIEl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyBhcyBpdCBvbmx5IHR1cm5zIG9uXG4gICAgICogcHJvcGVydHkgYWNjZXNzb3JzIG9uY2UuXG4gICAgICovXG4gICAgX2VuYWJsZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpO1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHNldCBvZlxuICAgICAqIHBlbmRpbmcgY2hhbmdlcyAoYW5kIG9sZCB2YWx1ZXMgcmVjb3JkZWQgd2hlbiBwZW5kaW5nIGNoYW5nZXMgd2VyZVxuICAgICAqIHNldCksIGFuZCByZXNldHMgdGhlIHBlbmRpbmcgc2V0IG9mIGNoYW5nZXMuIEdlbmVyYWxseSwgdGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgbm90IGJlIGNhbGxlZCBpbiB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZyAmJiB0aGlzLl9fZGF0YU9sZCkge1xuICAgICAgICBsZXQgY2hhbmdlZFByb3BzID0gdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0NoYW5nZWQodGhpcy5fX2RhdGEsIGNoYW5nZWRQcm9wcywgdGhpcy5fX2RhdGFPbGQpO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgY2FsbGJhY2sgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHByb3BlcnRpZXMgYXJlIGJlaW5nIGZsdXNoZWQuXG4gICAgICogUHJpb3IgdG8gYHJlYWR5YCwgYWxsIHByb3BlcnR5IHNldHMgdGhyb3VnaCBhY2Nlc3NvcnMgYXJlIHF1ZXVlZCBhbmRcbiAgICAgKiB0aGVpciBlZmZlY3RzIGFyZSBmbHVzaGVkIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYmVoYXZpb3IgdGhhdCBpc1xuICAgICAqIGRlcGVuZGVudCBvbiB0aGUgZWxlbWVudCBoYXZpbmcgaXRzIHByb3BlcnRpZXMgaW5pdGlhbGl6ZWQsIGUuZy5cbiAgICAgKiBmcm9tIGRlZmF1bHRzIChpbml0aWFsaXplZCBmcm9tIGBjb25zdHJ1Y3RvcmAsIGBfaW5pdGlhbGl6ZVByb3BlcnRpZXNgKSxcbiAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3IgdmFsdWVzIHByb3BhZ2F0ZWQgZnJvbSBob3N0IGUuZy4gdmlhXG4gICAgICogYmluZGluZ3MuICBgc3VwZXIucmVhZHkoKWAgbXVzdCBiZSBjYWxsZWQgdG8gZW5zdXJlIHRoZSBkYXRhIHN5c3RlbVxuICAgICAqIGJlY29tZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgLy8gUnVuIG5vcm1hbCBmbHVzaFxuICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYW55IHByb3BlcnRpZXMgd2l0aCBhY2Nlc3NvcnMgY3JlYXRlZCB2aWFcbiAgICAgKiBgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3JgIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHZhbHVlIHNob3VsZCBiZVxuICAgICAqIGNvbnNpZGVyZWQgYXMgYSBjaGFuZ2UgYW5kIGNhdXNlIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAqIHRvIGJlIGVucXVldWVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIHByaW1pdGl2ZSB0eXBlcyBpZiBhXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrIGZhaWxzLCBhbmQgcmV0dXJucyBgdHJ1ZWAgZm9yIGFsbCBPYmplY3QvQXJyYXlzLlxuICAgICAqIFRoZSBtZXRob2QgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGBOYU5gLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZS5nLiBwcm92aWRlIHN0cmljdGVyIGNoZWNraW5nIGZvclxuICAgICAqIE9iamVjdHMvQXJyYXlzIHdoZW4gdXNpbmcgaW1tdXRhYmxlIHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiAgIGFuZCBlbnF1ZXVlIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgKG9sZCAhPT0gdmFsdWUgJiZcbiAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyAob2xkPT1OYU4sIHZhbHVlPT1OYU4pIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgICAgICAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSlcbiAgICAgICk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvcnM7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIDEueCBiYWNrd2FyZHMtY29tcGF0aWJsZSBhdXRvLXdyYXBwZXIgZm9yIHRlbXBsYXRlIHR5cGUgZXh0ZW5zaW9uc1xuLy8gVGhpcyBpcyBhIGNsZWFyIGxheWVyaW5nIHZpb2xhdGlvbiBhbmQgZ2l2ZXMgZmF2b3JlZC1uYXRpb24gc3RhdHVzIHRvXG4vLyBkb20taWYgYW5kIGRvbS1yZXBlYXQgdGVtcGxhdGVzLiAgVGhpcyBpcyBhIGNvbmNlaXQgd2UncmUgY2hvb3NpbmcgdG8ga2VlcFxuLy8gYS4pIHRvIGVhc2UgMS54IGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGR1ZSB0byBsb3NzIG9mIGBpc2AsIGFuZFxuLy8gYi4pIHRvIG1haW50YWluIGlmL3JlcGVhdCBjYXBhYmlsaXR5IGluIHBhcnNlci1jb25zdHJhaW5lZCBlbGVtZW50c1xuLy8gICAgIChlLmcuIHRhYmxlLCBzZWxlY3QpIGluIGxpZXUgb2YgbmF0aXZlIENFIHR5cGUgZXh0ZW5zaW9ucyB3aXRob3V0XG4vLyAgICAgbWFzc2l2ZSBuZXcgaW52ZW50aW9uIGluIHRoaXMgc3BhY2UgKGUuZy4gZGlyZWN0aXZlIHN5c3RlbSlcbmNvbnN0IHRlbXBsYXRlRXh0ZW5zaW9ucyA9IHtcbiAgJ2RvbS1pZic6IHRydWUsXG4gICdkb20tcmVwZWF0JzogdHJ1ZVxufTtcbmZ1bmN0aW9uIHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKSB7XG4gIGxldCBpcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpO1xuICBpZiAoaXMgJiYgdGVtcGxhdGVFeHRlbnNpb25zW2lzXSkge1xuICAgIGxldCB0ID0gbm9kZTtcbiAgICB0LnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICBub2RlID0gdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXMpO1xuICAgIHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgdCk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0KTtcbiAgICB3aGlsZSh0LmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSwgdC5hdHRyaWJ1dGVzWzBdLnZhbHVlKTtcbiAgICAgIHQucmVtb3ZlQXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8pIHtcbiAgLy8gcmVjdXJzaXZlbHkgYXNjZW5kIHRyZWUgdW50aWwgd2UgaGl0IHJvb3RcbiAgbGV0IHBhcmVudCA9IG5vZGVJbmZvLnBhcmVudEluZm8gJiYgZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mby5wYXJlbnRJbmZvKTtcbiAgLy8gdW53aW5kIHRoZSBzdGFjaywgcmV0dXJuaW5nIHRoZSBpbmRleGVkIG5vZGUgYXQgZWFjaCBsZXZlbFxuICBpZiAocGFyZW50KSB7XG4gICAgLy8gbm90ZTogbWFyZ2luYWxseSBmYXN0ZXIgdGhhbiBpbmRleGluZyB2aWEgY2hpbGROb2Rlc1xuICAgIC8vIChodHRwOi8vanNwZXJmLmNvbS9jaGlsZG5vZGVzLWxvb2t1cClcbiAgICBmb3IgKGxldCBuPXBhcmVudC5maXJzdENoaWxkLCBpPTA7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG5vZGVJbmZvLnBhcmVudEluZGV4ID09PSBpKyspIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByb290O1xuICB9XG59XG5cbi8vIGNvbnN0cnVjdCBgJGAgbWFwIChmcm9tIGlkIGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlJZFRvTWFwKGluc3QsIG1hcCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmlkKSB7XG4gICAgbWFwW25vZGVJbmZvLmlkXSA9IG5vZGU7XG4gIH1cbn1cblxuLy8gaW5zdGFsbCBldmVudCBsaXN0ZW5lcnMgKGZyb20gZXZlbnQgYW5ub3RhdGlvbnMpXG5mdW5jdGlvbiBhcHBseUV2ZW50TGlzdGVuZXIoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmV2ZW50cyAmJiBub2RlSW5mby5ldmVudHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaj0wLCBlJD1ub2RlSW5mby5ldmVudHMsIGU7IChqPGUkLmxlbmd0aCkgJiYgKGU9ZSRbal0pOyBqKyspIHtcbiAgICAgIGluc3QuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZS5uYW1lLCBlLnZhbHVlLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcHVzaCBjb25maWd1cmF0aW9uIHJlZmVyZW5jZXMgYXQgY29uZmlndXJlIHRpbWVcbmZ1bmN0aW9uIGFwcGx5VGVtcGxhdGVDb250ZW50KGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby50ZW1wbGF0ZUluZm8pIHtcbiAgICBub2RlLl90ZW1wbGF0ZUluZm8gPSBub2RlSW5mby50ZW1wbGF0ZUluZm87XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gIGNvbnRleHQgPSBjb250ZXh0Ll9tZXRob2RIb3N0IHx8IGNvbnRleHQ7XG4gIGxldCBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChjb250ZXh0W21ldGhvZE5hbWVdKSB7XG4gICAgICBjb250ZXh0W21ldGhvZE5hbWVdKGUsIGUuZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lciBtZXRob2QgYCcgKyBtZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW5kbGVyO1xufVxuXG5leHBvcnQgY29uc3QgVGVtcGxhdGVTdGFtcCA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAqL1xuICBjbGFzcyBUZW1wbGF0ZVN0YW1wIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAvKipcbiAgICAgKiBTY2FucyBhIHRlbXBsYXRlIHRvIHByb2R1Y2UgdGVtcGxhdGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBUZW1wbGF0ZS1zcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIHRoZSBvYmplY3QgcmV0dXJuZWQsIGFuZCBub2RlLVxuICAgICAqIHNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gb2JqZWN0cyBpbiBpdHMgZmxhdHRlbmVkIGBub2RlSW5mb0xpc3RgXG4gICAgICogYXJyYXkuICBPbmx5IG5vZGVzIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IHdlcmUgcGFyc2VkIGFzIG5vZGVzIG9mXG4gICAgICogaW50ZXJlc3QgY29udGFpbiBhbiBvYmplY3QgaW4gYG5vZGVJbmZvTGlzdGAuICBFYWNoIGBub2RlSW5mb2Agb2JqZWN0XG4gICAgICogY29udGFpbnMgYW4gYGluZGV4YCAoYGNoaWxkTm9kZXNgIGluZGV4IGluIHBhcmVudCkgYW5kIG9wdGlvbmFsbHlcbiAgICAgKiBgcGFyZW50YCwgd2hpY2ggcG9pbnRzIHRvIG5vZGUgaW5mbyBvZiBpdHMgcGFyZW50IChpbmNsdWRpbmcgaXRzIGluZGV4KS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZCBoYXMgdGhlIGZvbGxvd2luZ1xuICAgICAqIHN0cnVjdHVyZSAobWFueSBmaWVsZHMgb3B0aW9uYWwpOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgLy8gRmxhdHRlbmVkIGxpc3Qgb2Ygbm9kZSBtZXRhZGF0YSAoZm9yIG5vZGVzIHRoYXQgZ2VuZXJhdGVkIG1ldGFkYXRhKVxuICAgICAqICAgICBub2RlSW5mb0xpc3Q6IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICAvLyBgaWRgIGF0dHJpYnV0ZSBmb3IgYW55IG5vZGVzIHdpdGggaWQncyBmb3IgZ2VuZXJhdGluZyBgJGAgbWFwXG4gICAgICogICAgICAgICBpZDoge3N0cmluZ30sXG4gICAgICogICAgICAgICAvLyBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIG1ldGFkYXRhXG4gICAgICogICAgICAgICBldmVudHM6IFtcbiAgICAgKiAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgIG5hbWU6IHtzdHJpbmd9LCAgIC8vIGV2ZW50IG5hbWVcbiAgICAgKiAgICAgICAgICAgICB2YWx1ZToge3N0cmluZ30sICAvLyBoYW5kbGVyIG1ldGhvZCBuYW1lXG4gICAgICogICAgICAgICAgIH0sIC4uLlxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIC8vIE5vdGVzIHdoZW4gdGhlIHRlbXBsYXRlIGNvbnRhaW5lZCBhIGA8c2xvdD5gIGZvciBzaGFkeSBET01cbiAgICAgKiAgICAgICAgIC8vIG9wdGltaXphdGlvbiBwdXJwb3Nlc1xuICAgICAqICAgICAgICAgaGFzSW5zZXJ0aW9uUG9pbnQ6IHtib29sZWFufSxcbiAgICAgKiAgICAgICAgIC8vIEZvciBuZXN0ZWQgYDx0ZW1wbGF0ZT5gYCBub2RlcywgbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICB0ZW1wbGF0ZUluZm86IHtvYmplY3R9LCAvLyBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIC8vIE1ldGFkYXRhIHRvIGFsbG93IGVmZmljaWVudCByZXRyaWV2YWwgb2YgaW5zdGFuY2VkIG5vZGVcbiAgICAgKiAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRhZGF0YVxuICAgICAqICAgICAgICAgcGFyZW50SW5mbzoge251bWJlcn0sICAgLy8gcmVmZXJlbmNlIHRvIHBhcmVudCBub2RlSW5mbz5cbiAgICAgKiAgICAgICAgIHBhcmVudEluZGV4OiB7bnVtYmVyfSwgIC8vIGluZGV4IGluIHBhcmVudCdzIGBjaGlsZE5vZGVzYCBjb2xsZWN0aW9uXG4gICAgICogICAgICAgICBpbmZvSW5kZXg6IHtudW1iZXJ9LCAgICAvLyBpbmRleCBvZiB0aGlzIGBub2RlSW5mb2AgaW4gYHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3RgXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAgLy8gV2hlbiB0cnVlLCB0aGUgdGVtcGxhdGUgaGFkIHRoZSBgc3RyaXAtd2hpdGVzcGFjZWAgYXR0cmlidXRlXG4gICAgICogICAgIC8vIG9yIHdhcyBuZXN0ZWQgaW4gYSB0ZW1wbGF0ZSB3aXRoIHRoYXQgc2V0dGluZ1xuICAgICAqICAgICBzdHJpcFdoaXRlc3BhY2U6IHtib29sZWFufSxcbiAgICAgKiAgICAgLy8gRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGlzIG1vdmVkIGludG9cbiAgICAgKiAgICAgLy8gYSBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgaGVyZTsgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gdG9cbiAgICAgKiAgICAgLy8gYXZvaWQgdGhlIGNvc3Qgb2YgbmVzdGVkIHRlbXBsYXRlIGNsb25pbmdcbiAgICAgKiAgICAgY29udGVudDoge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICogICB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBraWNrcyBvZmYgYSByZWN1cnNpdmUgdHJlZXdhbGsgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgIF9wYXJzZVRlbXBsYXRlIDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgICBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlICA8LS0tLS0tLS0tLS0tfC0tK1xuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUgLS0rICB8XG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzIC0tLS0tLS0tLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzXG4gICAgICogICAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG1ldGFkYXRhIGFib3V0IHRlbXBsYXRlc1xuICAgICAqIHRvIGVpdGhlciBgdGVtcGxhdGVJbmZvYCBvciBgbm9kZUluZm9gLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSBiZSBkZXN0cnVjdGl2ZSB0byB0aGUgdGVtcGxhdGUsIGluIHRoYXRcbiAgICAgKiBlLmcuIGV2ZW50IGFubm90YXRpb25zIG1heSBiZSByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIHRoZVxuICAgICAqIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mbz19IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZyb20gdGhlIG91dGVyXG4gICAgICogICB0ZW1wbGF0ZSwgZm9yIHBhcnNpbmcgbmVzdGVkIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFBhcnNlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgb3V0ZXJUZW1wbGF0ZUluZm8pIHtcbiAgICAgIC8vIHNpbmNlIGEgdGVtcGxhdGUgbWF5IGJlIHJlLXVzZWQsIG1lbW8taXplIG1ldGFkYXRhXG4gICAgICBpZiAoIXRlbXBsYXRlLl90ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlLl90ZW1wbGF0ZUluZm8gPSB7fTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdCA9IFtdO1xuICAgICAgICB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlID1cbiAgICAgICAgICAob3V0ZXJUZW1wbGF0ZUluZm8gJiYgb3V0ZXJUZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlKSB8fFxuICAgICAgICAgIHRlbXBsYXRlLmhhc0F0dHJpYnV0ZSgnc3RyaXAtd2hpdGVzcGFjZScpO1xuICAgICAgICB0aGlzLl9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCB7cGFyZW50OiBudWxsfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbztcbiAgICB9XG5cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUodGVtcGxhdGUuY29udGVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYW5kIGFkZHMgdGVtcGxhdGUgYW5kIG5vZGUgbWV0YWRhdGEgYmFzZWQgb25cbiAgICAgKiB0aGUgY3VycmVudCBub2RlLCBhbmQgaXRzIGBjaGlsZE5vZGVzYCBhbmQgYGF0dHJpYnV0ZXNgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBub2RlIG9yIHRlbXBsYXRlIHNwZWNpZmljXG4gICAgICogbWV0YWRhdGEgYmFzZWQgb24gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCBub3RlZDtcbiAgICAgIGxldCBlbGVtZW50ID0gLyoqIEB0eXBlIEVsZW1lbnQgKi8obm9kZSk7XG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ByZXNlcnZlLWNvbnRlbnQnKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICAvLyBGb3IgU2hhZHlEb20gb3B0aW1pemF0aW9uLCBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgICB0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlcyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY2hpbGQgbm9kZXMgZm9yIHRoZSBnaXZlbiByb290IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIHdyYXBzIHdoaXRlbGlzdGVkIGxlZ2FjeSB0ZW1wbGF0ZSBleHRlbnNpb25zXG4gICAgICogKGBpcz1cImRvbS1pZlwiYCBhbmQgYGlzPVwiZG9tLXJlcGVhdFwiYCkgd2l0aCB0aGVpciBlcXVpdmFsZW50IGVsZW1lbnRcbiAgICAgKiB3cmFwcGVycywgY29sbGFwc2VzIHRleHQgbm9kZXMsIGFuZCBzdHJpcHMgd2hpdGVzcGFjZSBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAqIGlmIHRoZSBgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVzcGFjZWAgc2V0dGluZyB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgUm9vdCBub2RlIHdob3NlIGBjaGlsZE5vZGVzYCB3aWxsIGJlIHBhcnNlZFxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2Rlcyhyb290LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBmb3IgKGxldCBub2RlPXJvb3QuZmlyc3RDaGlsZCwgcGFyZW50SW5kZXg9MCwgbmV4dDsgbm9kZTsgbm9kZT1uZXh0KSB7XG4gICAgICAgIC8vIFdyYXAgdGVtcGxhdGVzXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgbm9kZSA9IHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb2xsYXBzZSBhZGphY2VudCB0ZXh0Tm9kZXM6IGZpeGVzIGFuIElFIGlzc3VlIHRoYXQgY2FuIGNhdXNlXG4gICAgICAgIC8vIHRleHQgbm9kZXMgdG8gYmUgaW5leHBsaWNhYmx5IHNwbGl0ID0oXG4gICAgICAgIC8vIG5vdGUgdGhhdCByb290Lm5vcm1hbGl6ZSgpIHNob3VsZCB3b3JrIGJ1dCBkb2VzIG5vdCBzbyB3ZSBkbyB0aGlzXG4gICAgICAgIC8vIG1hbnVhbGx5LlxuICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgbGV0IC8qKiBOb2RlICovIG4gPSBuZXh0O1xuICAgICAgICAgIHdoaWxlIChuICYmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkpIHtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgKz0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIG5leHQgPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgICAgIG4gPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvcHRpb25hbGx5IHN0cmlwIHdoaXRlc3BhY2VcbiAgICAgICAgICBpZiAodGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSAmJiAhbm9kZS50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkSW5mbyA9IHsgcGFyZW50SW5kZXgsIHBhcmVudEluZm86IG5vZGVJbmZvIH07XG4gICAgICAgIGlmICh0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIGNoaWxkSW5mbykpIHtcbiAgICAgICAgICBjaGlsZEluZm8uaW5mb0luZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5wdXNoKC8qKiBAdHlwZSB7IU5vZGVJbmZvfSAqLyhjaGlsZEluZm8pKSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IGlmIG5vdCByZW1vdmVkXG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiBuZXN0ZWQgYDx0ZW1wbGF0ZT5gLlxuICAgICAqXG4gICAgICogTmVzdGVkIHRlbXBsYXRlIGluZm8gaXMgc3RvcmVkIGFzIGB0ZW1wbGF0ZUluZm9gIGluIHRoZSBjdXJyZW50IG5vZGUnc1xuICAgICAqIGBub2RlSW5mb2AuIGB0ZW1wbGF0ZS5jb250ZW50YCBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gYHRlbXBsYXRlSW5mb2AuXG4gICAgICogSXQgd2lsbCB0aGVuIGJlIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgaG9zdCB0byBzZXQgaXQgYmFjayB0byB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBhbmQgZm9yIHVzZXJzIHN0YW1waW5nIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gdXNlIHRoZVxuICAgICAqIGBfY29udGVudEZvclRlbXBsYXRlYCBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGNvbnRlbnQgZm9yIHRoaXMgdGVtcGxhdGVcbiAgICAgKiAoYW4gb3B0aW1pemF0aW9uIHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2UgKGEgPHRlbXBsYXRlPilcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gb3V0ZXJUZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiAgIHRoYXQgaW5jbHVkZXMgdGhlIHRlbXBsYXRlIGBub2RlYFxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9wYXJzZVRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvKTtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgPVxuICAgICAgICBub2RlLmNvbnRlbnQub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUuY29udGVudCk7XG4gICAgICBub2RlSW5mby50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGVzIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIGZvciBub2RlcyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIC8vIE1ha2UgY29weSBvZiBvcmlnaW5hbCBhdHRyaWJ1dGUgbGlzdCwgc2luY2UgdGhlIG9yZGVyIG1heSBjaGFuZ2VcbiAgICAgIC8vIGFzIGF0dHJpYnV0ZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkXG4gICAgICBsZXQgbm90ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBhdHRycyA9IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgIGZvciAobGV0IGk9YXR0cnMubGVuZ3RoLTEsIGE7IChhPWF0dHJzW2ldKTsgaS0tKSB7XG4gICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgYS5uYW1lLCBhLnZhbHVlKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzaW5nbGUgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGUgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0b1xuICAgICAqIGBub2RlSW5mb2AgZm9yIGF0dHJpYnV0ZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGFkZHMgbWV0YWRhdGEgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqIGFuZCBgaWRgIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIC8vIGV2ZW50cyAob24tKilcbiAgICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpID09PSAnb24tJykge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgbm9kZUluZm8uZXZlbnRzID0gbm9kZUluZm8uZXZlbnRzIHx8IFtdO1xuICAgICAgICBub2RlSW5mby5ldmVudHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZS5zbGljZSgzKSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBzdGF0aWMgaWRcbiAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgbm9kZUluZm8uaWQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYGNvbnRlbnRgIGRvY3VtZW50IGZyYWdtZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIFBvbHltZXIgcGVyZm9ybXMgYW4gb3B0aW1pemF0aW9uIHRvIGNhY2hlIG5lc3RlZFxuICAgICAqIHRlbXBsYXRlIGNvbnRlbnQgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBkZWVwbHkgbmVzdGVkIHRlbXBsYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCByZXRyaWV2ZXMgdGhlIGNhY2hlZCBjb250ZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byByZXRyaWV2ZSBgY29udGVudGAgZm9yXG4gICAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH0gQ29udGVudCBmcmFnbWVudFxuICAgICAqL1xuICAgIHN0YXRpYyBfY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50V2l0aEluZm99ICovICh0ZW1wbGF0ZSkuX3RlbXBsYXRlSW5mbztcbiAgICAgIHJldHVybiAodGVtcGxhdGVJbmZvICYmIHRlbXBsYXRlSW5mby5jb250ZW50KSB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgY29udGVudCBhbmQgcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogY29udGFpbmluZyB0aGUgY2xvbmVkIGRvbS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWQgKG9uY2UgYW5kIG1lbW9pemVkKSB1c2luZyB0aGlzIGxpYnJhcnknc1xuICAgICAqIHRlbXBsYXRlIHBhcnNpbmcgZmVhdHVyZXMsIGFuZCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHZhbHVlLWFkZGVkXG4gICAgICogZmVhdHVyZXM6XG4gICAgICogKiBBZGRzIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICogKiBHZW5lcmF0ZXMgYW4gXCJpZCBtYXBcIiBmb3IgYWxsIG5vZGVzIHdpdGggaWQncyB1bmRlciBgJGAgb24gcmV0dXJuZWRcbiAgICAgKiAgIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogKiBQYXNzZXMgdGVtcGxhdGUgaW5mbyBpbmNsdWRpbmcgYGNvbnRlbnRgIGJhY2sgdG8gdGVtcGxhdGVzIGFzXG4gICAgICogICBgX3RlbXBsYXRlSW5mb2AgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGRlZXAgdGVtcGxhdGVcbiAgICAgKiAgIGNsb25pbmcpXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIG1lbW9pemVkIHRlbXBsYXRlIHBhcnNpbmcgcHJvY2VzcyBpcyBkZXN0cnVjdGl2ZSB0byB0aGVcbiAgICAgKiB0ZW1wbGF0ZTogYXR0cmlidXRlcyBmb3IgYmluZGluZ3MgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAgICAgKiByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIG5vdGVzLCBhbmQgYW55IG5lc3RlZCBgPHRlbXBsYXRlPi5jb250ZW50YFxuICAgICAqIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBub3RlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAqL1xuICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAvLyBQb2x5ZmlsbCBzdXBwb3J0OiBib290c3RyYXAgdGhlIHRlbXBsYXRlIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuXG4gICAgICBpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbnRlbnQgJiZcbiAgICAgICAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCAmJiBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKSB7XG4gICAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUodGVtcGxhdGUpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IG5vZGVJbmZvID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdDtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICAgIGxldCBkb20gPSAvKiogQHR5cGUgRG9jdW1lbnRGcmFnbWVudCAqLyAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICAvLyBOT1RFOiBTaGFkeURvbSBvcHRpbWl6YXRpb24gaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgIGRvbS5fX25vSW5zZXJ0aW9uUG9pbnQgPSAhdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50O1xuICAgICAgbGV0IG5vZGVzID0gZG9tLm5vZGVMaXN0ID0gbmV3IEFycmF5KG5vZGVJbmZvLmxlbmd0aCk7XG4gICAgICBkb20uJCA9IHt9O1xuICAgICAgZm9yIChsZXQgaT0wLCBsPW5vZGVJbmZvLmxlbmd0aCwgaW5mbzsgKGk8bCkgJiYgKGluZm89bm9kZUluZm9baV0pOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXSA9IGZpbmRUZW1wbGF0ZU5vZGUoZG9tLCBpbmZvKTtcbiAgICAgICAgYXBwbHlJZFRvTWFwKHRoaXMsIGRvbS4kLCBub2RlLCBpbmZvKTtcbiAgICAgICAgYXBwbHlUZW1wbGF0ZUNvbnRlbnQodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICAgIGFwcGx5RXZlbnRMaXN0ZW5lcih0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiogQHR5cGUgeyFTdGFtcGVkVGVtcGxhdGV9ICovKGRvbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBieSBtZXRob2QgbmFtZSBmb3IgdGhlIGV2ZW50IHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgaGFuZGxlciBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIHRoZSBtZXRob2RcbiAgICAgKiBuYW1lIGF0IGhhbmRsaW5nIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgbGlzdGVuZXIgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Kj19IGNvbnRleHQgQ29udGV4dCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIChkZWZhdWx0c1xuICAgICAqICAgdG8gYG5vZGVgKVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBHZW5lcmF0ZWQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqL1xuICAgIF9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbm9kZTtcbiAgICAgIGxldCBoYW5kbGVyID0gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byBhZGRcbiAgICAgKi9cbiAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gVGVtcGxhdGVTdGFtcDtcblxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0LmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL2NvbG9yLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuanMnO1xuaW1wb3J0IHsgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHsgYWZ0ZXJOZXh0UmVuZGVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5qcyc7XG5pbXBvcnQgeyBzZXRUb3VjaEFjdGlvbiB9IGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL2dlc3R1cmVzLmpzJztcbmltcG9ydCB7IFBhcGVyUmlwcGxlQmVoYXZpb3IgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8ZG9tLW1vZHVsZSBpZD1cInBhcGVyLXRvZ2dsZS1idXR0b25cIj5cbiAgPHRlbXBsYXRlIHN0cmlwLXdoaXRlc3BhY2U9XCJcIj5cblxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaG9yaXpvbnRhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoOmZvY3VzKSB7XG4gICAgICAgIG91dGxpbmU6bm9uZTtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1iYXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIG9wYWNpdHk6IDAuNDtcbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciBsaW5lYXIgLjA4cztcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtYmFyLWNvbG9yLCAjMDAwMDAwKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1iYXI7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC0zcHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIGhlaWdodDogMjBweDtcbiAgICAgICAgd2lkdGg6IDIwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgICAgICB0cmFuc2l0aW9uOiAtd2Via2l0LXRyYW5zZm9ybSBsaW5lYXIgLjA4cywgYmFja2dyb3VuZC1jb2xvciBsaW5lYXIgLjA4cztcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIGxpbmVhciAuMDhzLCBiYWNrZ3JvdW5kLWNvbG9yIGxpbmVhciAuMDhzO1xuICAgICAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1idXR0b24tY29sb3IsIHZhcigtLXBhcGVyLWdyZXktNTApKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1idXR0b247XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtYnV0dG9uLmRyYWdnaW5nIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBub25lO1xuICAgICAgICB0cmFuc2l0aW9uOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbY2hlY2tlZF06bm90KFtkaXNhYmxlZF0pKSAudG9nZ2xlLWJhciB7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJhci1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1iYXI7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIC50b2dnbGUtYmFyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzAwMDtcbiAgICAgICAgb3BhY2l0eTogMC4xMjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdKSAudG9nZ2xlLWJ1dHRvbiB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTZweCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDE2cHgsIDApO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbY2hlY2tlZF06bm90KFtkaXNhYmxlZF0pKSAudG9nZ2xlLWJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1idXR0b24tY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAudG9nZ2xlLWJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNiZGJkYmQ7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtaW5rIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC0xNHB4O1xuICAgICAgICBsZWZ0OiAtMTRweDtcbiAgICAgICAgcmlnaHQ6IGF1dG87XG4gICAgICAgIGJvdHRvbTogYXV0bztcbiAgICAgICAgd2lkdGg6IDQ4cHg7XG4gICAgICAgIGhlaWdodDogNDhweDtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWluay1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtaW5rO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbY2hlY2tlZF0pIC50b2dnbGUtaW5rIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1pbmstY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtaW5rO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWNvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMzZweDtcbiAgICAgICAgaGVpZ2h0OiAxNHB4O1xuICAgICAgICAvKiBUaGUgdG9nZ2xlIGJ1dHRvbiBoYXMgYW4gYWJzb2x1dGUgcG9zaXRpb24gb2YgLTNweDsgVGhlIGV4dHJhIDFweFxuICAgICAgICAvKiBhY2NvdW50cyBmb3IgdGhlIHRvZ2dsZSBidXR0b24gc2hhZG93IGJveC4gKi9cbiAgICAgICAgbWFyZ2luOiA0cHggMXB4O1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWxhYmVsIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgICAgIHBhZGRpbmctbGVmdDogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1sYWJlbC1zcGFjaW5nLCA4cHgpO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tbGFiZWwtY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICAvKiBpbnZhbGlkIHN0YXRlICovXG4gICAgICA6aG9zdChbaW52YWxpZF0pIC50b2dnbGUtYmFyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1pbnZhbGlkLWJhci1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2ludmFsaWRdKSAudG9nZ2xlLWJ1dHRvbiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24taW52YWxpZC1idXR0b24tY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkgLnRvZ2dsZS1pbmsge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1pbnZhbGlkLWluay1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBjbGFzcz1cInRvZ2dsZS1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgaWQ9XCJ0b2dnbGVCYXJcIiBjbGFzcz1cInRvZ2dsZS1iYXJcIj48L2Rpdj5cbiAgICAgIDxkaXYgaWQ9XCJ0b2dnbGVCdXR0b25cIiBjbGFzcz1cInRvZ2dsZS1idXR0b25cIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0b2dnbGUtbGFiZWxcIj48c2xvdD48L3Nsb3Q+PC9kaXY+XG5cbiAgPC90ZW1wbGF0ZT5cblxuICBcbjwvZG9tLW1vZHVsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuUG9seW1lcih7XG4gIGlzOiAncGFwZXItdG9nZ2xlLWJ1dHRvbicsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yXG4gIF0sXG5cbiAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAnYXJpYS1wcmVzc2VkJzogJ2ZhbHNlJyxcbiAgICB0YWJpbmRleDogMFxuICB9LFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGV2ZW50IGlyb24tY2hhbmdlXG4gICAgICovXG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgdHJhY2s6ICdfb250cmFjaydcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgYWZ0ZXJOZXh0UmVuZGVyKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VG91Y2hBY3Rpb24odGhpcywgJ3Bhbi15Jyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgX29udHJhY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrID0gZXZlbnQuZGV0YWlsO1xuICAgIGlmICh0cmFjay5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgdGhpcy5fdHJhY2tTdGFydCh0cmFjayk7XG4gICAgfSBlbHNlIGlmICh0cmFjay5zdGF0ZSA9PT0gJ3RyYWNrJykge1xuICAgICAgdGhpcy5fdHJhY2tNb3ZlKHRyYWNrKTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrLnN0YXRlID09PSAnZW5kJykge1xuICAgICAgdGhpcy5fdHJhY2tFbmQodHJhY2spO1xuICAgIH1cbiAgfSxcblxuICBfdHJhY2tTdGFydDogZnVuY3Rpb24odHJhY2spIHtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuJC50b2dnbGVCYXIub2Zmc2V0V2lkdGggLyAyO1xuICAgIC8qXG4gICAgICoga2VlcCBhbiB0cmFjay1vbmx5IGNoZWNrIHN0YXRlIHRvIGtlZXAgdGhlIGRyYWdnaW5nIGJlaGF2aW9yIHNtb290aFxuICAgICAqIHdoaWxlIHRvZ2dsaW5nIGFjdGl2YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5fdHJhY2tDaGVja2VkID0gdGhpcy5jaGVja2VkO1xuICAgIHRoaXMuJC50b2dnbGVCdXR0b24uY2xhc3NMaXN0LmFkZCgnZHJhZ2dpbmcnKTtcbiAgfSxcblxuICBfdHJhY2tNb3ZlOiBmdW5jdGlvbih0cmFjaykge1xuICAgIHZhciBkeCA9IHRyYWNrLmR4O1xuICAgIHRoaXMuX3ggPSBNYXRoLm1pbih0aGlzLl93aWR0aCxcbiAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy5fdHJhY2tDaGVja2VkID8gdGhpcy5fd2lkdGggKyBkeCA6IGR4KSk7XG4gICAgdGhpcy50cmFuc2xhdGUzZCh0aGlzLl94ICsgJ3B4JywgMCwgMCwgdGhpcy4kLnRvZ2dsZUJ1dHRvbik7XG4gICAgdGhpcy5fdXNlckFjdGl2YXRlKHRoaXMuX3ggPiAodGhpcy5fd2lkdGggLyAyKSk7XG4gIH0sXG5cbiAgX3RyYWNrRW5kOiBmdW5jdGlvbih0cmFjaykge1xuICAgIHRoaXMuJC50b2dnbGVCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ2dpbmcnKTtcbiAgICB0aGlzLnRyYW5zZm9ybSgnJywgdGhpcy4kLnRvZ2dsZUJ1dHRvbik7XG4gIH0sXG5cbiAgLy8gY3VzdG9taXplIHRoZSBlbGVtZW50J3MgcmlwcGxlXG4gIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3JpcHBsZUNvbnRhaW5lciA9IHRoaXMuJC50b2dnbGVCdXR0b247XG4gICAgdmFyIHJpcHBsZSA9IFBhcGVyUmlwcGxlQmVoYXZpb3IuX2NyZWF0ZVJpcHBsZSgpO1xuICAgIHJpcHBsZS5pZCA9ICdpbmsnO1xuICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ3JlY2VudGVycycsICcnKTtcbiAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnY2lyY2xlJywgJ3RvZ2dsZS1pbmsnKTtcbiAgICByZXR1cm4gcmlwcGxlO1xuICB9XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci10b2dnbGUtYnV0dG9uL3BhcGVyLXRvZ2dsZS1idXR0b24uanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBcHBseVNoaW0gZnJvbSAnLi4vc3JjL2FwcGx5LXNoaW0uanMnO1xuaW1wb3J0IHRlbXBsYXRlTWFwIGZyb20gJy4uL3NyYy90ZW1wbGF0ZS1tYXAuanMnO1xuaW1wb3J0IHtnZXRJc0V4dGVuZHMsIHRvQ3NzVGV4dH0gZnJvbSAnLi4vc3JjL3N0eWxlLXV0aWwuanMnO1xuaW1wb3J0ICogYXMgQXBwbHlTaGltVXRpbHMgZnJvbSAnLi4vc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMnO1xuaW1wb3J0IGRvY3VtZW50V2FpdCBmcm9tICcuLi9zcmMvZG9jdW1lbnQtd2FpdC5qcyc7XG5pbXBvcnQge2dldENvbXB1dGVkU3R5bGVWYWx1ZSwgdXBkYXRlTmF0aXZlUHJvcGVydGllc30gZnJvbSAnLi4vc3JjL2NvbW1vbi11dGlscy5qcyc7XG5pbXBvcnQge0N1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlfSBmcm9tICcuLi9zcmMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7bmF0aXZlQ3NzVmFyaWFibGVzLCBuYXRpdmVTaGFkb3d9IGZyb20gJy4uL3NyYy9zdHlsZS1zZXR0aW5ncy5qcyc7XG5cbi8qKiBAY29uc3Qge0FwcGx5U2hpbX0gKi9cbmNvbnN0IGFwcGx5U2hpbSA9IG5ldyBBcHBseVNoaW0oKTtcblxuY2xhc3MgQXBwbHlTaGltSW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHs/Q3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2V9ICovXG4gICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSA9IG51bGw7XG4gICAgZG9jdW1lbnRXYWl0KCgpID0+IHtcbiAgICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgfSk7XG4gICAgYXBwbHlTaGltWydpbnZhbGlkQ2FsbGJhY2snXSA9IEFwcGx5U2hpbVV0aWxzLmludmFsaWRhdGU7XG4gIH1cbiAgZW5zdXJlKCkge1xuICAgIGlmICh0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG4gICAgaWYgKHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3RyYW5zZm9ybUNhbGxiYWNrJ10gPSAoc3R5bGUpID0+IHtcbiAgICAgICAgYXBwbHlTaGltLnRyYW5zZm9ybUN1c3RvbVN0eWxlKHN0eWxlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWyd2YWxpZGF0ZUNhbGxiYWNrJ10gPSAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2VucXVldWVkJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqL1xuICBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV0gPSB0ZW1wbGF0ZTtcbiAgICBsZXQgYXN0ID0gYXBwbHlTaGltLnRyYW5zZm9ybVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSk7XG4gICAgLy8gc2F2ZSBvcmlnaW5hbCBzdHlsZSBhc3QgdG8gdXNlIGZvciByZXZhbGlkYXRpbmcgaW5zdGFuY2VzXG4gICAgdGVtcGxhdGVbJ19zdHlsZUFzdCddID0gYXN0O1xuICB9XG4gIGZsdXNoQ3VzdG9tU3R5bGVzKCkge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgaWYgKCF0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdHlsZXMgPSB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydwcm9jZXNzU3R5bGVzJ10oKTtcbiAgICBpZiAoIXRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2VucXVldWVkJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBsZXQgY3MgPSBzdHlsZXNbaV07XG4gICAgICBsZXQgc3R5bGUgPSB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydnZXRTdHlsZUZvckN1c3RvbVN0eWxlJ10oY3MpO1xuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGFwcGx5U2hpbS50cmFuc2Zvcm1DdXN0b21TdHlsZShzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2VucXVldWVkJ10gPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICovXG4gIHN0eWxlU3VidHJlZShlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBsZXQgc2hhZG93Q2hpbGRyZW4gPSBlbGVtZW50LnNoYWRvd1Jvb3QuY2hpbGRyZW4gfHwgZWxlbWVudC5zaGFkb3dSb290LmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYWRvd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHNoYWRvd0NoaWxkcmVuW2ldKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4gfHwgZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnN0eWxlU3VidHJlZSgvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhjaGlsZHJlbltpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgc3R5bGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIGxldCB7aXN9ID0gZ2V0SXNFeHRlbmRzKGVsZW1lbnQpO1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2lzXTtcbiAgICBpZiAodGVtcGxhdGUgJiYgIUFwcGx5U2hpbVV0aWxzLnRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkpIHtcbiAgICAgIC8vIG9ubHkgcmV2YWxpZGF0ZSB0ZW1wbGF0ZSBvbmNlXG4gICAgICBpZiAoIUFwcGx5U2hpbVV0aWxzLnRlbXBsYXRlSXNWYWxpZGF0aW5nKHRlbXBsYXRlKSkge1xuICAgICAgICB0aGlzLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMpO1xuICAgICAgICBBcHBseVNoaW1VdGlscy5zdGFydFZhbGlkYXRpbmdUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGUgdGhpcyBlbGVtZW50IGluc3RhbmNlXG4gICAgICBsZXQgcm9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8ocm9vdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKTtcbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgLy8gcmV1c2UgdGhlIHRlbXBsYXRlJ3Mgc3R5bGUgYXN0LCBpdCBoYXMgYWxsIHRoZSBvcmlnaW5hbCBjc3MgdGV4dFxuICAgICAgICAgIHN0eWxlWydfX2Nzc1J1bGVzJ10gPSB0ZW1wbGF0ZVsnX3N0eWxlQXN0J107XG4gICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0b0Nzc1RleHQodGVtcGxhdGVbJ19zdHlsZUFzdCddKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICovXG4gIHN0eWxlRG9jdW1lbnQocHJvcGVydGllcykge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgdGhpcy5zdHlsZVN1YnRyZWUoZG9jdW1lbnQuYm9keSwgcHJvcGVydGllcyk7XG4gIH1cbn1cblxuaWYgKCF3aW5kb3cuU2hhZHlDU1MgfHwgIXdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSkge1xuICBjb25zdCBhcHBseVNoaW1JbnRlcmZhY2UgPSBuZXcgQXBwbHlTaGltSW50ZXJmYWNlKCk7XG4gIGxldCBDdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUyAmJiB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG5cbiAgd2luZG93LlNoYWR5Q1NTID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbGVtZW50RXh0ZW5kc1xuICAgICAqL1xuICAgIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUsIGVsZW1lbnRFeHRlbmRzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnN0eWxlU3VidHJlZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBzdHlsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2Uuc3R5bGVFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZURvY3VtZW50KHByb3BlcnRpZXMpIHtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnN0eWxlRG9jdW1lbnQocHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpO1xuICAgIH0sXG4gICAgbmF0aXZlQ3NzOiBuYXRpdmVDc3NWYXJpYWJsZXMsXG4gICAgbmF0aXZlU2hhZG93OiBuYXRpdmVTaGFkb3dcbiAgfTtcblxuICBpZiAoQ3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBDdXN0b21TdHlsZUludGVyZmFjZTtcbiAgfVxufVxuXG53aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltID0gYXBwbHlTaGltO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvYXBwbHktc2hpbS5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG4vKlxuICogVGhlIGFwcGx5IHNoaW0gc2ltdWxhdGVzIHRoZSBiZWhhdmlvciBvZiBgQGFwcGx5YCBwcm9wb3NlZCBhdFxuICogaHR0cHM6Ly90YWJhdGtpbnMuZ2l0aHViLmlvL3NwZWNzL2Nzcy1hcHBseS1ydWxlLy5cbiAqIFRoZSBhcHByb2FjaCBpcyB0byBjb252ZXJ0IGEgcHJvcGVydHkgbGlrZSB0aGlzOlxuICpcbiAqICAgIC0tZm9vOiB7Y29sb3I6IHJlZDsgYmFja2dyb3VuZDogYmx1ZTt9XG4gKlxuICogdG8gdGhpczpcbiAqXG4gKiAgICAtLWZvb18tX2NvbG9yOiByZWQ7XG4gKiAgICAtLWZvb18tX2JhY2tncm91bmQ6IGJsdWU7XG4gKlxuICogVGhlbiB3aGVyZSBgQGFwcGx5IC0tZm9vYCBpcyB1c2VkLCB0aGF0IGlzIGNvbnZlcnRlZCB0bzpcbiAqXG4gKiAgICBjb2xvcjogdmFyKC0tZm9vXy1fY29sb3IpO1xuICogICAgYmFja2dyb3VuZDogdmFyKC0tZm9vXy1fYmFja2dyb3VuZCk7XG4gKlxuICogVGhpcyBhcHByb2FjaCBnZW5lcmFsbHkgd29ya3MgYnV0IHRoZXJlIGFyZSBzb21lIGlzc3VlcyBhbmQgbGltaXRhdGlvbnMuXG4gKiBDb25zaWRlciwgZm9yIGV4YW1wbGUsIHRoYXQgc29tZXdoZXJlICpiZXR3ZWVuKiB3aGVyZSBgLS1mb29gIGlzIHNldCBhbmQgdXNlZCxcbiAqIGFub3RoZXIgZWxlbWVudCBzZXRzIGl0IHRvOlxuICpcbiAqICAgIC0tZm9vOiB7IGJvcmRlcjogMnB4IHNvbGlkIHJlZDsgfVxuICpcbiAqIFdlIG11c3Qgbm93IGVuc3VyZSB0aGF0IHRoZSBjb2xvciBhbmQgYmFja2dyb3VuZCBmcm9tIHRoZSBwcmV2aW91cyBzZXR0aW5nXG4gKiBkbyBub3QgYXBwbHkuIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IGNoYW5naW5nIHRoZSBwcm9wZXJ0eSBzZXQgdG8gdGhpczpcbiAqXG4gKiAgICAtLWZvb18tX2JvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAqICAgIC0tZm9vXy1fY29sb3I6IGluaXRpYWw7XG4gKiAgICAtLWZvb18tX2JhY2tncm91bmQ6IGluaXRpYWw7XG4gKlxuICogVGhpcyB3b3JrcyBidXQgaW50cm9kdWNlcyBvbmUgbmV3IGlzc3VlLlxuICogQ29uc2lkZXIgdGhpcyBzZXR1cCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGBAYXBwbHlgIGlzIHVzZWQ6XG4gKlxuICogICAgYmFja2dyb3VuZDogb3JhbmdlO1xuICogICAgYEBhcHBseWAgLS1mb287XG4gKlxuICogSW4gdGhpcyBjYXNlIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgdW5zZXQgKGluaXRpYWwpIHJhdGhlciB0aGFuIHRoZSBkZXNpcmVkXG4gKiBgb3JhbmdlYC4gV2UgYWRkcmVzcyB0aGlzIGJ5IGFsdGVyaW5nIHRoZSBwcm9wZXJ0eSBzZXQgdG8gdXNlIGEgZmFsbGJhY2tcbiAqIHZhbHVlIGxpa2UgdGhpczpcbiAqXG4gKiAgICBjb2xvcjogdmFyKC0tZm9vXy1fY29sb3IpO1xuICogICAgYmFja2dyb3VuZDogdmFyKC0tZm9vXy1fYmFja2dyb3VuZCwgb3JhbmdlKTtcbiAqICAgIGJvcmRlcjogdmFyKC0tZm9vXy1fYm9yZGVyKTtcbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGRlZmF1bHQgaXMgcmV0YWluZWQgaW4gdGhlIHByb3BlcnR5IHNldCBhbmQgdGhlIGBiYWNrZ3JvdW5kYCBpc1xuICogdGhlIGRlc2lyZWQgYG9yYW5nZWAuIFRoaXMgbGVhZHMgdXMgdG8gYSBsaW1pdGF0aW9uLlxuICpcbiAqIExpbWl0YXRpb24gMTpcblxuICogT25seSBwcm9wZXJ0aWVzIGluIHRoZSBydWxlIHdoZXJlIHRoZSBgQGFwcGx5YFxuICogaXMgdXNlZCBhcmUgY29uc2lkZXJlZCBhcyBkZWZhdWx0IHZhbHVlcy5cbiAqIElmIGFub3RoZXIgcnVsZSBtYXRjaGVzIHRoZSBlbGVtZW50IGFuZCBzZXRzIGBiYWNrZ3JvdW5kYCB3aXRoXG4gKiBsZXNzIHNwZWNpZmljaXR5IHRoYW4gdGhlIHJ1bGUgaW4gd2hpY2ggYEBhcHBseWAgYXBwZWFycyxcbiAqIHRoZSBgYmFja2dyb3VuZGAgd2lsbCBub3QgYmUgc2V0LlxuICpcbiAqIExpbWl0YXRpb24gMjpcbiAqXG4gKiBXaGVuIHVzaW5nIFBvbHltZXIncyBgdXBkYXRlU3R5bGVzYCBhcGksIG5ldyBwcm9wZXJ0aWVzIG1heSBub3QgYmUgc2V0IGZvclxuICogYEBhcHBseWAgcHJvcGVydGllcy5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2ZvckVhY2hSdWxlLCBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjaywgcnVsZXNGb3JTdHlsZSwgdG9Dc3NUZXh0fSBmcm9tICcuL3N0eWxlLXV0aWwuanMnO1xuaW1wb3J0IHtNSVhJTl9NQVRDSCwgVkFSX0FTU0lHTn0gZnJvbSAnLi9jb21tb24tcmVnZXguanMnO1xuaW1wb3J0IHtkZXRlY3RNaXhpbn0gZnJvbSAnLi9jb21tb24tdXRpbHMuanMnO1xuaW1wb3J0IHtTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5jb25zdCBBUFBMWV9OQU1FX0NMRUFOID0gLztcXHMqL207XG5jb25zdCBJTklUSUFMX0lOSEVSSVQgPSAvXlxccyooaW5pdGlhbCl8KGluaGVyaXQpXFxzKiQvO1xuXG4vLyBzZXBhcmF0b3IgdXNlZCBiZXR3ZWVuIG1peGluLW5hbWUgYW5kIG1peGluLXByb3BlcnR5LW5hbWUgd2hlbiBwcm9kdWNpbmcgcHJvcGVydGllc1xuLy8gTk9URTogcGxhaW4gJy0nIG1heSBjYXVzZSBjb2xsaXNpb25zIGluIHVzZXIgc3R5bGVzXG5jb25zdCBNSVhJTl9WQVJfU0VQID0gJ18tXyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5sZXQgUHJvcGVydHlFbnRyeTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEB0eXBlZGVmIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmxldCBEZXBlbmRhbnRzRW50cnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqIEB0eXBlZGVmIHt7XG4gKiAgICBwcm9wZXJ0aWVzOiBQcm9wZXJ0eUVudHJ5LFxuICogICAgZGVwZW5kYW50czogRGVwZW5kYW50c0VudHJ5XG4gKiB9fVxuICovXG5sZXQgTWl4aW5NYXBFbnRyeTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vLyBtYXAgb2YgbWl4aW4gdG8gcHJvcGVydHkgbmFtZXNcbi8vIC0tZm9vOiB7Ym9yZGVyOiAycHh9IC0+IHtwcm9wZXJ0aWVzOiB7KC0tZm9vLCBbJ2JvcmRlciddKX0sIGRlcGVuZGFudHM6IHsnZWxlbWVudC1uYW1lJzogcHJvdG99fVxuY2xhc3MgTWl4aW5NYXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhTWl4aW5NYXBFbnRyeT59ICovXG4gICAgdGhpcy5fbWFwID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RW50cnl9IHByb3BzXG4gICAqL1xuICBzZXQobmFtZSwgcHJvcHMpIHtcbiAgICBuYW1lID0gbmFtZS50cmltKCk7XG4gICAgdGhpcy5fbWFwW25hbWVdID0ge1xuICAgICAgcHJvcGVydGllczogcHJvcHMsXG4gICAgICBkZXBlbmRhbnRzOiB7fVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7TWl4aW5NYXBFbnRyeX1cbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgbmFtZSA9IG5hbWUudHJpbSgpO1xuICAgIHJldHVybiB0aGlzLl9tYXBbbmFtZV0gfHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgbWFya2VkIGludmFsaWRcbiAqIEB0eXBlIHs/ZnVuY3Rpb24oc3RyaW5nKX1cbiAqL1xubGV0IGludmFsaWRDYWxsYmFjayA9IG51bGw7XG5cbi8qKiBAdW5yZXN0cmljdGVkICovXG5jbGFzcyBBcHBseVNoaW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7SFRNTE1ldGFFbGVtZW50fSAqL1xuICAgIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWl4aW5NYXAoKTtcbiAgfVxuICAvKipcbiAgICogcmV0dXJuIHRydWUgaWYgYGNzc1RleHRgIGNvbnRhaW5zIGEgbWl4aW4gZGVmaW5pdGlvbiBvciBjb25zdW1wdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZGV0ZWN0TWl4aW4oY3NzVGV4dCkge1xuICAgIHJldHVybiBkZXRlY3RNaXhpbihjc3NUZXh0KTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAgICovXG4gIHRyYW5zZm9ybVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSkge1xuICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyh0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xuICAgIC8qKiBAdHlwZSB7U3R5bGVOb2RlfSAqL1xuICAgIGxldCBhc3QgPSBudWxsO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgYXN0ID0gdGhpcy50cmFuc2Zvcm1TdHlsZShzdHlsZSwgZWxlbWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXN0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICogQHJldHVybiB7U3R5bGVOb2RlfVxuICAgKi9cbiAgdHJhbnNmb3JtU3R5bGUoc3R5bGUsIGVsZW1lbnROYW1lID0gJycpIHtcbiAgICBsZXQgYXN0ID0gcnVsZXNGb3JTdHlsZShzdHlsZSk7XG4gICAgdGhpcy50cmFuc2Zvcm1SdWxlcyhhc3QsIGVsZW1lbnROYW1lKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRvQ3NzVGV4dChhc3QpO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gICAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAgICovXG4gIHRyYW5zZm9ybUN1c3RvbVN0eWxlKHN0eWxlKSB7XG4gICAgbGV0IGFzdCA9IHJ1bGVzRm9yU3R5bGUoc3R5bGUpO1xuICAgIGZvckVhY2hSdWxlKGFzdCwgKHJ1bGUpID0+IHtcbiAgICAgIGlmIChydWxlWydzZWxlY3RvciddID09PSAnOnJvb3QnKSB7XG4gICAgICAgIHJ1bGVbJ3NlbGVjdG9yJ10gPSAnaHRtbCc7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZm9ybVJ1bGUocnVsZSk7XG4gICAgfSlcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRvQ3NzVGV4dChhc3QpO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3R5bGVOb2RlfSBydWxlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICovXG4gIHRyYW5zZm9ybVJ1bGVzKHJ1bGVzLCBlbGVtZW50TmFtZSkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudE5hbWU7XG4gICAgZm9yRWFjaFJ1bGUocnVsZXMsIChyKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybVJ1bGUocik7XG4gICAgfSk7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFTdHlsZU5vZGV9IHJ1bGVcbiAgICovXG4gIHRyYW5zZm9ybVJ1bGUocnVsZSkge1xuICAgIHJ1bGVbJ2Nzc1RleHQnXSA9IHRoaXMudHJhbnNmb3JtQ3NzVGV4dChydWxlWydwYXJzZWRDc3NUZXh0J10pO1xuICAgIC8vIDpyb290IHdhcyBvbmx5IHVzZWQgZm9yIHZhcmlhYmxlIGFzc2lnbm1lbnQgaW4gcHJvcGVydHkgc2hpbSxcbiAgICAvLyBidXQgZ2VuZXJhdGVzIGludmFsaWQgc2VsZWN0b3JzIHdpdGggcmVhbCBwcm9wZXJ0aWVzLlxuICAgIC8vIHJlcGxhY2Ugd2l0aCBgOmhvc3QgPiAqYCwgd2hpY2ggc2VydmVzIHRoZSBzYW1lIGVmZmVjdFxuICAgIGlmIChydWxlWydzZWxlY3RvciddID09PSAnOnJvb3QnKSB7XG4gICAgICBydWxlWydzZWxlY3RvciddID0gJzpob3N0ID4gKic7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0cmFuc2Zvcm1Dc3NUZXh0KGNzc1RleHQpIHtcbiAgICAvLyBwcm9kdWNlIHZhcmlhYmxlc1xuICAgIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoVkFSX0FTU0lHTiwgKG1hdGNoVGV4dCwgcHJvcGVydHlOYW1lLCB2YWx1ZVByb3BlcnR5LCB2YWx1ZU1peGluKSA9PlxuICAgICAgdGhpcy5fcHJvZHVjZUNzc1Byb3BlcnRpZXMobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pKTtcbiAgICAvLyBjb25zdW1lIG1peGluc1xuICAgIHJldHVybiB0aGlzLl9jb25zdW1lQ3NzUHJvcGVydGllcyhjc3NUZXh0KTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9nZXRJbml0aWFsVmFsdWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmICghdGhpcy5fbWVhc3VyZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gLyoqIEB0eXBlIHtIVE1MTWV0YUVsZW1lbnR9ICovKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKSk7XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FwcGx5LXNoaW0tbWVhc3VyZScsICcnKTtcbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50LnN0eWxlLmFsbCA9ICdpbml0aWFsJztcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5fbWVhc3VyZUVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fbWVhc3VyZUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICB9XG4gIC8qKlxuICAgKiByZXBsYWNlIG1peGluIGNvbnN1bXB0aW9uIHdpdGggdmFyaWFibGUgY29uc3VtcHRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKHRleHQpIHtcbiAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuICAgIGxldCBtID0gbnVsbDtcbiAgICAvLyBsb29wIG92ZXIgdGV4dCB1bnRpbCBhbGwgbWl4aW5zIHdpdGggZGVmaW50aW9ucyBoYXZlIGJlZW4gYXBwbGllZFxuICAgIHdoaWxlKChtID0gTUlYSU5fTUFUQ0guZXhlYyh0ZXh0KSkpIHtcbiAgICAgIGxldCBtYXRjaFRleHQgPSBtWzBdO1xuICAgICAgbGV0IG1peGluTmFtZSA9IG1bMV07XG4gICAgICBsZXQgaWR4ID0gbS5pbmRleDtcbiAgICAgIC8vIGNvbGxlY3QgcHJvcGVydGllcyBiZWZvcmUgYXBwbHkgdG8gYmUgXCJkZWZhdWx0c1wiIGlmIG1peGluIG1pZ2h0IG92ZXJyaWRlIHRoZW1cbiAgICAgIC8vIG1hdGNoIGluY2x1ZGVzIGEgXCJwcmVmaXhcIiwgc28gZmluZCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgQGFwcGx5XG4gICAgICBsZXQgYXBwbHlQb3MgPSBpZHggKyBtYXRjaFRleHQuaW5kZXhPZignQGFwcGx5Jyk7XG4gICAgICBsZXQgYWZ0ZXJBcHBseVBvcyA9IGlkeCArIG1hdGNoVGV4dC5sZW5ndGg7XG4gICAgICAvLyBmaW5kIHByb3BzIGRlZmluZWQgYmVmb3JlIHRoaXMgQGFwcGx5XG4gICAgICBsZXQgdGV4dEJlZm9yZUFwcGx5ID0gdGV4dC5zbGljZSgwLCBhcHBseVBvcyk7XG4gICAgICBsZXQgdGV4dEFmdGVyQXBwbHkgPSB0ZXh0LnNsaWNlKGFmdGVyQXBwbHlQb3MpO1xuICAgICAgbGV0IGRlZmF1bHRzID0gdGhpcy5fY3NzVGV4dFRvTWFwKHRleHRCZWZvcmVBcHBseSk7XG4gICAgICBsZXQgcmVwbGFjZW1lbnQgPSB0aGlzLl9hdEFwcGx5VG9Dc3NQcm9wZXJ0aWVzKG1peGluTmFtZSwgZGVmYXVsdHMpO1xuICAgICAgLy8gdXNlIHJlZ2V4IG1hdGNoIHBvc2l0aW9uIHRvIHJlcGxhY2UgbWl4aW4sIGtlZXAgbGluZWFyIHByb2Nlc3NpbmcgdGltZVxuICAgICAgdGV4dCA9IGAke3RleHRCZWZvcmVBcHBseX0ke3JlcGxhY2VtZW50fSR7dGV4dEFmdGVyQXBwbHl9YDtcbiAgICAgIC8vIG1vdmUgcmVnZXggc2VhcmNoIHRvIF9hZnRlcl8gcmVwbGFjZW1lbnRcbiAgICAgIE1JWElOX01BVENILmxhc3RJbmRleCA9IGlkeCArIHJlcGxhY2VtZW50Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIHByb2R1Y2UgdmFyaWFibGUgY29uc3VtcHRpb24gYXQgdGhlIHNpdGUgb2YgbWl4aW4gY29uc3VtcHRpb25cbiAgICogYEBhcHBseWAgLS1mb287IC0+IGZvciBhbGwgcHJvcHMgKCR7cHJvcG5hbWV9OiB2YXIoLS1mb29fLV8ke3Byb3BuYW1lfSwgJHtmYWxsYmFja1twcm9wbmFtZV19fSkpXG4gICAqIEV4YW1wbGU6XG4gICAqICBib3JkZXI6IHZhcigtLWZvb18tX2JvcmRlcik7IHBhZGRpbmc6IHZhcigtLWZvb18tX3BhZGRpbmcsIDJweClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1peGluTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZmFsbGJhY2tzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9hdEFwcGx5VG9Dc3NQcm9wZXJ0aWVzKG1peGluTmFtZSwgZmFsbGJhY2tzKSB7XG4gICAgbWl4aW5OYW1lID0gbWl4aW5OYW1lLnJlcGxhY2UoQVBQTFlfTkFNRV9DTEVBTiwgJycpO1xuICAgIGxldCB2YXJzID0gW107XG4gICAgbGV0IG1peGluRW50cnkgPSB0aGlzLl9tYXAuZ2V0KG1peGluTmFtZSk7XG4gICAgLy8gaWYgd2UgZGVwZW5kIG9uIGEgbWl4aW4gYmVmb3JlIGl0IGlzIGNyZWF0ZWRcbiAgICAvLyBtYWtlIGEgc2VudGluZWwgZW50cnkgaW4gdGhlIG1hcCB0byBhZGQgdGhpcyBlbGVtZW50IGFzIGEgZGVwZW5kZW5jeSBmb3Igd2hlbiBpdCBpcyBkZWZpbmVkLlxuICAgIGlmICghbWl4aW5FbnRyeSkge1xuICAgICAgdGhpcy5fbWFwLnNldChtaXhpbk5hbWUsIHt9KTtcbiAgICAgIG1peGluRW50cnkgPSB0aGlzLl9tYXAuZ2V0KG1peGluTmFtZSk7XG4gICAgfVxuICAgIGlmIChtaXhpbkVudHJ5KSB7XG4gICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgbWl4aW5FbnRyeS5kZXBlbmRhbnRzW3RoaXMuX2N1cnJlbnRFbGVtZW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgcCwgcGFydHMsIGY7XG4gICAgICBmb3IgKHAgaW4gbWl4aW5FbnRyeS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGYgPSBmYWxsYmFja3MgJiYgZmFsbGJhY2tzW3BdO1xuICAgICAgICBwYXJ0cyA9IFtwLCAnOiB2YXIoJywgbWl4aW5OYW1lLCBNSVhJTl9WQVJfU0VQLCBwXTtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKCcsJywgZik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaCgnKScpO1xuICAgICAgICB2YXJzLnB1c2gocGFydHMuam9pbignJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFycy5qb2luKCc7ICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGxldCBtYXRjaCA9IElOSVRJQUxfSU5IRVJJVC5leGVjKHZhbHVlKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAvLyBpbml0aWFsXG4gICAgICAgIC8vIHJlcGxhY2UgYGluaXRpYWxgIHdpdGggdGhlIGNvbmNyZXRlIGluaXRpYWwgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9nZXRJbml0aWFsVmFsdWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbmhlcml0XG4gICAgICAgIC8vIHdpdGggdGhpcyBwdXJwb3NmdWxseSBpbGxlZ2FsIHZhbHVlLCB0aGUgdmFyaWFibGUgd2lsbCBiZSBpbnZhbGlkIGF0XG4gICAgICAgIC8vIGNvbXB1dGUgdGltZSAoaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy12YXJpYWJsZXMvI2ludmFsaWQtYXQtY29tcHV0ZWQtdmFsdWUtdGltZSlcbiAgICAgICAgLy8gYW5kIGZvciBpbmhlcml0aW5nIHZhbHVlcywgd2lsbCBiZWhhdmUgc2ltaWxhcmx5XG4gICAgICAgIC8vIHdlIGNhbm5vdCBzdXBwb3J0IHRoZSBzYW1lIGJlaGF2aW9yIGZvciBub24gaW5oZXJpdGluZyB2YWx1ZXMgbGlrZSAnYm9yZGVyJ1xuICAgICAgICB2YWx1ZSA9ICdhcHBseS1zaGltLWluaGVyaXQnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogXCJwYXJzZVwiIGEgbWl4aW4gZGVmaW5pdGlvbiBpbnRvIGEgbWFwIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgKiBjc3NUZXh0VG9NYXAoJ2JvcmRlcjogMnB4IHNvbGlkIGJsYWNrJykgLT4gKCdib3JkZXInLCAnMnB4IHNvbGlkIGJsYWNrJylcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBfY3NzVGV4dFRvTWFwKHRleHQpIHtcbiAgICBsZXQgcHJvcHMgPSB0ZXh0LnNwbGl0KCc7Jyk7XG4gICAgbGV0IHByb3BlcnR5LCB2YWx1ZTtcbiAgICBsZXQgb3V0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDAsIHAsIHNwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHAgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwKSB7XG4gICAgICAgIHNwID0gcC5zcGxpdCgnOicpO1xuICAgICAgICAvLyBpZ25vcmUgbGluZXMgdGhhdCBhcmVuJ3QgZGVmaW5pdGlvbnMgbGlrZSBAbWVkaWFcbiAgICAgICAgaWYgKHNwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHNwWzBdLnRyaW0oKTtcbiAgICAgICAgICAvLyBzb21lIHByb3BlcnRpZXMgbWF5IGhhdmUgJzonIGluIHRoZSB2YWx1ZSwgbGlrZSBkYXRhIHVybHNcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0KHByb3BlcnR5LCBzcC5zbGljZSgxKS5qb2luKCc6JykpO1xuICAgICAgICAgIG91dFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWl4aW5NYXBFbnRyeX0gbWl4aW5FbnRyeVxuICAgKi9cbiAgX2ludmFsaWRhdGVNaXhpbkVudHJ5KG1peGluRW50cnkpIHtcbiAgICBpZiAoIWludmFsaWRDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBlbGVtZW50TmFtZSBpbiBtaXhpbkVudHJ5LmRlcGVuZGFudHMpIHtcbiAgICAgIGlmIChlbGVtZW50TmFtZSAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgaW52YWxpZENhbGxiYWNrKGVsZW1lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoVGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVQcm9wZXJ0eVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlTWl4aW5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX3Byb2R1Y2VDc3NQcm9wZXJ0aWVzKG1hdGNoVGV4dCwgcHJvcGVydHlOYW1lLCB2YWx1ZVByb3BlcnR5LCB2YWx1ZU1peGluKSB7XG4gICAgLy8gaGFuZGxlIGNhc2Ugd2hlcmUgcHJvcGVydHkgdmFsdWUgaXMgYSBtaXhpblxuICAgIGlmICh2YWx1ZVByb3BlcnR5KSB7XG4gICAgICAvLyBmb3JtOiAtLW1peGluMjogdmFyKC0tbWl4aW4xKSwgd2hlcmUgLS1taXhpbjEgaXMgaW4gdGhlIG1hcFxuICAgICAgcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2sodmFsdWVQcm9wZXJ0eSwgKHByZWZpeCwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuX21hcC5nZXQodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWVNaXhpbiA9IGBAYXBwbHkgJHt2YWx1ZX07YFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZU1peGluKSB7XG4gICAgICByZXR1cm4gbWF0Y2hUZXh0O1xuICAgIH1cbiAgICBsZXQgbWl4aW5Bc1Byb3BlcnRpZXMgPSB0aGlzLl9jb25zdW1lQ3NzUHJvcGVydGllcyh2YWx1ZU1peGluKTtcbiAgICBsZXQgcHJlZml4ID0gbWF0Y2hUZXh0LnNsaWNlKDAsIG1hdGNoVGV4dC5pbmRleE9mKCctLScpKTtcbiAgICBsZXQgbWl4aW5WYWx1ZXMgPSB0aGlzLl9jc3NUZXh0VG9NYXAobWl4aW5Bc1Byb3BlcnRpZXMpO1xuICAgIGxldCBjb21iaW5lZFByb3BzID0gbWl4aW5WYWx1ZXM7XG4gICAgbGV0IG1peGluRW50cnkgPSB0aGlzLl9tYXAuZ2V0KHByb3BlcnR5TmFtZSk7XG4gICAgbGV0IG9sZFByb3BzID0gbWl4aW5FbnRyeSAmJiBtaXhpbkVudHJ5LnByb3BlcnRpZXM7XG4gICAgaWYgKG9sZFByb3BzKSB7XG4gICAgICAvLyBOT1RFOiBzaW5jZSB3ZSB1c2UgbWl4aW4sIHRoZSBtYXAgb2YgcHJvcGVydGllcyBpcyB1cGRhdGVkIGhlcmVcbiAgICAgIC8vIGFuZCB0aGlzIGlzIHdoYXQgd2Ugd2FudC5cbiAgICAgIGNvbWJpbmVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUob2xkUHJvcHMpLCBtaXhpblZhbHVlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQocHJvcGVydHlOYW1lLCBjb21iaW5lZFByb3BzKTtcbiAgICB9XG4gICAgbGV0IG91dCA9IFtdO1xuICAgIGxldCBwLCB2O1xuICAgIC8vIHNldCB2YXJpYWJsZXMgZGVmaW5lZCBieSBjdXJyZW50IG1peGluXG4gICAgbGV0IG5lZWRUb0ludmFsaWRhdGUgPSBmYWxzZTtcbiAgICBmb3IgKHAgaW4gY29tYmluZWRQcm9wcykge1xuICAgICAgdiA9IG1peGluVmFsdWVzW3BdO1xuICAgICAgLy8gaWYgcHJvcGVydHkgbm90IGRlZmluZWQgYnkgY3VycmVudCBtaXhpbiwgc2V0IGluaXRpYWxcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdiA9ICdpbml0aWFsJztcbiAgICAgIH1cbiAgICAgIGlmIChvbGRQcm9wcyAmJiAhKHAgaW4gb2xkUHJvcHMpKSB7XG4gICAgICAgIG5lZWRUb0ludmFsaWRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2goYCR7cHJvcGVydHlOYW1lfSR7TUlYSU5fVkFSX1NFUH0ke3B9OiAke3Z9YCk7XG4gICAgfVxuICAgIGlmIChuZWVkVG9JbnZhbGlkYXRlKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlTWl4aW5FbnRyeShtaXhpbkVudHJ5KTtcbiAgICB9XG4gICAgaWYgKG1peGluRW50cnkpIHtcbiAgICAgIG1peGluRW50cnkucHJvcGVydGllcyA9IGNvbWJpbmVkUHJvcHM7XG4gICAgfVxuICAgIC8vIGJlY2F1c2UgdGhlIG1peGluTWFwIGlzIGdsb2JhbCwgdGhlIG1peGluIG1pZ2h0IGNvbmZsaWN0IHdpdGhcbiAgICAvLyBhIGRpZmZlcmVudCBzY29wZSdzIHNpbXBsZSB2YXJpYWJsZSBkZWZpbml0aW9uOlxuICAgIC8vIEV4YW1wbGU6XG4gICAgLy8gc29tZSBzdHlsZSBzb21ld2hlcmU6XG4gICAgLy8gLS1taXhpbjE6eyAuLi4gfVxuICAgIC8vIC0tbWl4aW4yOiB2YXIoLS1taXhpbjEpO1xuICAgIC8vIHNvbWUgb3RoZXIgZWxlbWVudDpcbiAgICAvLyAtLW1peGluMTogMTBweCBzb2xpZCByZWQ7XG4gICAgLy8gLS1mb286IHZhcigtLW1peGluMSk7XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBsZWF2ZSB0aGUgb3JpZ2luYWwgdmFyaWFibGUgZGVmaW5pdGlvbiBpbiBwbGFjZS5cbiAgICBpZiAodmFsdWVQcm9wZXJ0eSkge1xuICAgICAgcHJlZml4ID0gYCR7bWF0Y2hUZXh0fTske3ByZWZpeH1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJlZml4fSR7b3V0LmpvaW4oJzsgJyl9O2A7XG4gIH1cbn1cblxuLyogZXhwb3J0cyAqL1xuQXBwbHlTaGltLnByb3RvdHlwZVsnZGV0ZWN0TWl4aW4nXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUuZGV0ZWN0TWl4aW47XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1TdHlsZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1TdHlsZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybUN1c3RvbVN0eWxlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybUN1c3RvbVN0eWxlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtUnVsZXMnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtUnVsZXM7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1SdWxlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVJ1bGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1UZW1wbGF0ZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1UZW1wbGF0ZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ19zZXBhcmF0b3InXSA9IE1JWElOX1ZBUl9TRVA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbHlTaGltLnByb3RvdHlwZSwgJ2ludmFsaWRDYWxsYmFjaycsIHtcbiAgLyoqIEByZXR1cm4gez9mdW5jdGlvbihzdHJpbmcpfSAqL1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIGludmFsaWRDYWxsYmFjaztcbiAgfSxcbiAgLyoqIEBwYXJhbSB7P2Z1bmN0aW9uKHN0cmluZyl9IGNiICovXG4gIHNldChjYikge1xuICAgIGludmFsaWRDYWxsYmFjayA9IGNiO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQXBwbHlTaGltO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0uanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgdGVtcGxhdGVNYXAgZnJvbSAnLi90ZW1wbGF0ZS1tYXAuanMnO1xuaW1wb3J0IHtTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKlxuICogVXRpbGl0aWVzIGZvciBoYW5kbGluZyBpbnZhbGlkYXRpbmcgYXBwbHktc2hpbSBtaXhpbnMgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gKlxuICogVGhlIGludmFsaWRhdGlvbiBzdHJhdGVneSBpbnZvbHZlcyBrZWVwaW5nIHRyYWNrIG9mIHRoZSBcImN1cnJlbnRcIiB2ZXJzaW9uIG9mIGEgdGVtcGxhdGUncyBtaXhpbnMsIGFuZCB1cGRhdGluZyB0aGF0IGNvdW50IHdoZW4gYSBtaXhpbiBpcyBpbnZhbGlkYXRlZC5cbiAqIFRoZSB0ZW1wbGF0ZVxuICovXG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IENVUlJFTlRfVkVSU0lPTiA9ICdfYXBwbHlTaGltQ3VycmVudFZlcnNpb24nO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBORVhUX1ZFUlNJT04gPSAnX2FwcGx5U2hpbU5leHRWZXJzaW9uJztcblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgVkFMSURBVElOR19WRVJTSU9OID0gJ19hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbic7XG5cbi8qKlxuICogQGNvbnN0IHtQcm9taXNlPHZvaWQ+fVxuICovXG5jb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZW1lbnROYW1lKXtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBpZiAodGVtcGxhdGUpIHtcbiAgICBpbnZhbGlkYXRlVGVtcGxhdGUodGVtcGxhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIG1hcmsgYSB0ZW1wbGF0ZSBpbnZhbGlkXG4gKiBhbmQgc2lnbmFsIHRoYXQgdGhlIHN0eWxlIGluc2lkZSBtdXN0IGJlIHJlZ2VuZXJhdGVkLlxuICpcbiAqIFVzZSBgc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGVgIHRvIGJlZ2luIGFuIGFzeW5jaHJvbm91cyB2YWxpZGF0aW9uIGN5Y2xlLlxuICogRHVyaW5nIHRoYXQgY3ljbGUsIGNhbGwgYHRlbXBsYXRlSXNWYWxpZGF0aW5nYCB0byBzZWUgaWYgdGhlIHRlbXBsYXRlIG11c3RcbiAqIGJlIHJldmFsaWRhdGVkXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgLy8gZGVmYXVsdCB0aGUgY3VycmVudCB2ZXJzaW9uIHRvIDBcbiAgdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSA9IHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gfHwgMDtcbiAgLy8gZW5zdXJlIHRoZSBcInZhbGlkYXRpbmcgZm9yXCIgZmxhZyBleGlzdHNcbiAgdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSA9IHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gfHwgMDtcbiAgLy8gaW5jcmVtZW50IHRoZSBuZXh0IHZlcnNpb25cbiAgdGVtcGxhdGVbTkVYVF9WRVJTSU9OXSA9ICh0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dIHx8IDApICsgMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkKGVsZW1lbnROYW1lKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgaWYgKHRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkge1xuICByZXR1cm4gdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSA9PT0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkYXRpbmcoZWxlbWVudE5hbWUpIHtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBpZiAodGVtcGxhdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVJc1ZhbGlkYXRpbmcodGVtcGxhdGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRlbXBsYXRlIGlzIGN1cnJlbnRseSBpbnZhbGlkIGFuZCBgc3RhcnRWYWxpZGF0aW5nYCBoYXMgYmVlbiBjYWxsZWQgc2luY2UgdGhlIGxhc3QgaW52YWxpZGF0aW9uLlxuICogSWYgZmFsc2UsIHRoZSB0ZW1wbGF0ZSBtdXN0IGJlIHZhbGlkYXRlZC5cbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSkge1xuICByZXR1cm4gIXRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkgJiYgdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSA9PT0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbn1cblxuLyoqXG4gKiB0aGUgdGVtcGxhdGUgaXMgbWFya2VkIGFzIGB2YWxpZGF0aW5nYCBmb3Igb25lIG1pY3JvdGFzayBzbyB0aGF0IGFsbCBpbnN0YW5jZXNcbiAqIGZvdW5kIGluIHRoZSB0cmVlIGNyYXdsIG9mIGBhcHBseVN0eWxlYCB3aWxsIHVwZGF0ZSB0aGVtc2VsdmVzLFxuICogYnV0IHRoZSB0ZW1wbGF0ZSB3aWxsIG9ubHkgYmUgdXBkYXRlZCBvbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VmFsaWRhdGluZyhlbGVtZW50TmFtZSkge1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIHN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKTtcbn1cblxuLyoqXG4gKiBCZWdpbiBhbiBhc3luY2hyb25vdXMgaW52YWxpZGF0aW9uIGN5Y2xlLlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGV2ZXJ5IHZhbGlkYXRpb24gb2YgYSB0ZW1wbGF0ZVxuICpcbiAqIEFmdGVyIG9uZSBtaWNyb3Rhc2ssIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIG1hcmtlZCBhcyB2YWxpZCB1bnRpbCB0aGUgbmV4dCBjYWxsIHRvIGBpbnZhbGlkYXRlVGVtcGxhdGVgXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAvLyByZW1lbWJlciB0aGF0IHRoZSBjdXJyZW50IFwibmV4dCB2ZXJzaW9uXCIgaXMgdGhlIHJlYXNvbiBmb3IgdGhpcyB2YWxpZGF0aW9uIGN5Y2xlXG4gIHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xuICAvLyBob3dldmVyLCB0aGVyZSBvbmx5IG5lZWRzIHRvIGJlIG9uZSBhc3luYyB0YXNrIHRvIGNsZWFyIHRoZSBjb3VudGVyc1xuICBpZiAoIXRlbXBsYXRlLl92YWxpZGF0aW5nKSB7XG4gICAgdGVtcGxhdGUuX3ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIC8vIHN5bmMgdGhlIGN1cnJlbnQgdmVyc2lvbiB0byBsZXQgZnV0dXJlIGludmFsaWRhdGlvbnMgY2F1c2UgYSByZWZyZXNoIGN5Y2xlXG4gICAgICB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbiAgICAgIHRlbXBsYXRlLl92YWxpZGF0aW5nID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudHNBcmVJbnZhbGlkKCkge1xuICBmb3IgKGxldCBlbGVtZW50TmFtZSBpbiB0ZW1wbGF0ZU1hcCkge1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgICBpZiAoIXRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvYXBwbHktc2hpbS11dGlscy5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxuLy8gcnVuIGEgY2FsbGJhY2sgd2hlbiBIVE1MSW1wb3J0cyBhcmUgcmVhZHkgb3IgaW1tZWRpYXRlbHkgaWZcbi8vIHRoaXMgYXBpIGlzIG5vdCBhdmFpbGFibGUuXG5mdW5jdGlvbiB3aGVuSW1wb3J0c1JlYWR5KGNiKSB7XG4gIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcbiAgICBIVE1MSW1wb3J0cy53aGVuUmVhZHkoY2IpO1xuICB9IGVsc2Uge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGltcG9ydEhyZWYgPSBmdW5jdGlvbihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7XG4gIGxldCBsaW5rID0gLyoqIEB0eXBlIHtIVE1MTGlua0VsZW1lbnR9ICovXG4gICAgKGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcignbGlua1tocmVmPVwiJyArIGhyZWYgKyAnXCJdW2ltcG9ydC1ocmVmXScpKTtcbiAgaWYgKCFsaW5rKSB7XG4gICAgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpKTtcbiAgICBsaW5rLnJlbCA9ICdpbXBvcnQnO1xuICAgIGxpbmsuaHJlZiA9IGhyZWY7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoJ2ltcG9ydC1ocmVmJywgJycpO1xuICB9XG4gIC8vIGFsd2F5cyBlbnN1cmUgbGluayBoYXMgYGFzeW5jYCBhdHRyaWJ1dGUgaWYgdXNlciBzcGVjaWZpZWQgb25lLFxuICAvLyBldmVuIGlmIGl0IHdhcyBwcmV2aW91c2x5IG5vdCBhc3luYy4gVGhpcyBpcyBjb25zaWRlcmVkIGxlc3MgY29uZnVzaW5nLlxuICBpZiAob3B0QXN5bmMpIHtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZSgnYXN5bmMnLCAnJyk7XG4gIH1cbiAgLy8gTk9URTogdGhlIGxpbmsgbWF5IG5vdyBiZSBpbiAzIHN0YXRlczogKDEpIHBlbmRpbmcgaW5zZXJ0aW9uLFxuICAvLyAoMikgaW5mbGlnaHQsICgzKSBhbHJlYWR5IGxhb2RlZC4gSW4gZWFjaCBjYXNlLCB3ZSBuZWVkIHRvIGFkZFxuICAvLyBldmVudCBsaXN0ZW5lcnMgdG8gcHJvY2VzcyBjYWxsYmFja3MuXG4gIGxldCBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgICBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gIH07XG4gIGxldCBsb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGNsZWFudXAoKTtcbiAgICAvLyBJbiBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCBsb2FkLCBjYWNoZSB0aGUgbG9hZCBldmVudCBvbiB0aGUgbGluayBzb1xuICAgIC8vIHRoYXQgaXQgY2FuIGJlIHVzZWQgdG8gc2hvcnQtY2lyY3VpdCB0aGlzIG1ldGhvZCBpbiB0aGUgZnV0dXJlIHdoZW5cbiAgICAvLyBpdCBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBocmVmIHBhcmFtLlxuICAgIGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkID0gdHJ1ZTtcbiAgICBpZiAob25sb2FkKSB7XG4gICAgICB3aGVuSW1wb3J0c1JlYWR5KCgpID0+IHtcbiAgICAgICAgb25sb2FkKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgbGV0IGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGNsZWFudXAoKTtcbiAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yLCByZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgZG9jdW1lbnQgc28gdGhhdCBpdFxuICAgIC8vIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGFnYWluIHRoZSBuZXh0IHRpbWUgYGltcG9ydEhyZWZgIGlzXG4gICAgLy8gY2FsbGVkLlxuICAgIGlmIChsaW5rLnBhcmVudE5vZGUpIHtcbiAgICAgIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICB9XG4gICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgIHdoZW5JbXBvcnRzUmVhZHkoKCkgPT4ge1xuICAgICAgICBvbmVycm9yKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgbGluay5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgbGluay5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICBpZiAobGluay5wYXJlbnROb2RlID09IG51bGwpIHtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAvLyBpZiB0aGUgbGluayBhbHJlYWR5IGxvYWRlZCwgZGlzcGF0Y2ggYSBmYWtlIGxvYWQgZXZlbnRcbiAgLy8gc28gdGhhdCBsaXN0ZW5lcnMgYXJlIGNhbGxlZCBhbmQgZ2V0IGEgcHJvcGVyIGV2ZW50IGFyZ3VtZW50LlxuICB9IGVsc2UgaWYgKGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkKSB7XG4gICAgbGluay5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbG9hZCcpKTtcbiAgfVxuICByZXR1cm4gbGluaztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ltcG9ydC1ocmVmLmpzIiwiZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoJ3VucmVzb2x2ZWQnKTtcbn1cblxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICByZXNvbHZlKCk7XG59IGVsc2Uge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHJlc29sdmUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy91bnJlc29sdmVkLmpzIiwiaW1wb3J0IHsgTGVnYWN5RWxlbWVudE1peGluIH0gZnJvbSAnLi9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgeyBEb21Nb2R1bGUgfSBmcm9tICcuLi9lbGVtZW50cy9kb20tbW9kdWxlLmpzJztcblxubGV0IG1ldGFQcm9wcyA9IHtcbiAgYXR0YWNoZWQ6IHRydWUsXG4gIGRldGFjaGVkOiB0cnVlLFxuICByZWFkeTogdHJ1ZSxcbiAgY3JlYXRlZDogdHJ1ZSxcbiAgYmVmb3JlUmVnaXN0ZXI6IHRydWUsXG4gIHJlZ2lzdGVyZWQ6IHRydWUsXG4gIGF0dHJpYnV0ZUNoYW5nZWQ6IHRydWUsXG4gIC8vIG1ldGEgb2JqZWN0c1xuICBiZWhhdmlvcnM6IHRydWVcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIFwibGVnYWN5XCIgYmVoYXZpb3Igb3IgYXJyYXkgb2YgYmVoYXZpb3JzIHRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsIGF1dG9tYXRpY2FsbHkgYWxzbyBhcHBseSB0aGUgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYFxuICogdG8gZW5zdXJlIHRoYXQgYW55IGxlZ2FjeSBiZWhhdmlvcnMgY2FuIHJlbHkgb24gbGVnYWN5IFBvbHltZXIgQVBJIG9uXG4gKiB0aGUgdW5kZXJseWluZyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7IShPYmplY3R8QXJyYXkpfSBiZWhhdmlvcnMgQmVoYXZpb3Igb2JqZWN0IG9yIGFycmF5IG9mIGJlaGF2aW9ycy5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fGZ1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IGtsYXNzIEVsZW1lbnQgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBSZXR1cm5zIGEgbmV3IEVsZW1lbnQgY2xhc3MgZXh0ZW5kZWQgYnkgdGhlXG4gKiBwYXNzZWQgaW4gYGJlaGF2aW9yc2AgYW5kIGFsc28gYnkgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYC5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0cywgY2hlY2tUeXBlc31cbiAqL1xuZnVuY3Rpb24gbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICBpZiAoIWJlaGF2aW9ycykge1xuICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhrbGFzcyk7XG4gIH1cbiAgLy8gTk9URTogZW5zdXJlIHRoZSBiYWhldmlvciBpcyBleHRlbmRpbmcgYSBjbGFzcyB3aXRoXG4gIC8vIGxlZ2FjeSBlbGVtZW50IGFwaS4gVGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgYmVoYXZpb3JzIGV4cGVjdCB0byBiZSBhYmxlXG4gIC8vIHRvIGFjY2VzcyAxLnggbGVnYWN5IGFwaS5cbiAga2xhc3MgPSBMZWdhY3lFbGVtZW50TWl4aW4oa2xhc3MpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYmVoYXZpb3JzKSkge1xuICAgIGJlaGF2aW9ycyA9IFtiZWhhdmlvcnNdO1xuICB9XG4gIGxldCBzdXBlckJlaGF2aW9ycyA9IGtsYXNzLnByb3RvdHlwZS5iZWhhdmlvcnM7XG4gIC8vIGdldCBmbGF0dGVuZWQsIGRlZHVwZWQgbGlzdCBvZiBiZWhhdmlvcnMgKm5vdCogYWxyZWFkeSBvbiBzdXBlciBjbGFzc1xuICBiZWhhdmlvcnMgPSBmbGF0dGVuQmVoYXZpb3JzKGJlaGF2aW9ycywgbnVsbCwgc3VwZXJCZWhhdmlvcnMpO1xuICAvLyBtaXhpbiBuZXcgYmVoYXZpb3JzXG4gIGtsYXNzID0gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpO1xuICBpZiAoc3VwZXJCZWhhdmlvcnMpIHtcbiAgICBiZWhhdmlvcnMgPSBzdXBlckJlaGF2aW9ycy5jb25jYXQoYmVoYXZpb3JzKTtcbiAgfVxuICAvLyBTZXQgYmVoYXZpb3JzIG9uIHByb3RvdHlwZSBmb3IgQkMuLi5cbiAga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycyA9IGJlaGF2aW9ycztcbiAgcmV0dXJuIGtsYXNzO1xufVxuXG4vLyBOT1RFOlxuLy8gMS54XG4vLyBCZWhhdmlvcnMgd2VyZSBtaXhlZCBpbiAqaW4gcmV2ZXJzZSBvcmRlciogYW5kIGRlLWR1cGVkIG9uIHRoZSBmbHkuXG4vLyBUaGUgcnVsZSB3YXMgdGhhdCBiZWhhdmlvciBwcm9wZXJ0aWVzIHdlcmUgY29waWVkIG9udG8gdGhlIGVsZW1lbnRcbi8vIHByb3RvdHlwZSBpZiBhbmQgb25seSBpZiB0aGUgcHJvcGVydHkgZGlkIG5vdCBhbHJlYWR5IGV4aXN0LlxuLy8gR2l2ZW46IFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgcHJvcGVydHkgY29weSBvcmRlciB3YXM6XG4vLyAoMSksIEIsICgyKSwgQSwgKDMpIEMuIFRoaXMgbWVhbnMgcHJvdG90eXBlIHByb3BlcnRpZXMgd2luIG92ZXJcbi8vIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpbiBvdmVyIEMuIFRoaXMgbWlycm9ycyB3aGF0IHdvdWxkIGhhcHBlblxuLy8gd2l0aCBpbmhlcml0YW5jZSBpZiBlbGVtZW50IGV4dGVuZGVkIEIgZXh0ZW5kZWQgQSBleHRlbmRlZCBDLlxuLy9cbi8vIEFnYWluIGdpdmVuLCBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHRoZSByZXN1bHRpbmdcbi8vIGBiZWhhdmlvcnNgIGFycmF5IHdhcyBbQywgQSwgQl0uXG4vLyBCZWhhdmlvciBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGNhbGxlZCBpbiBiZWhhdmlvciBhcnJheSBvcmRlclxuLy8gZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnQsIGUuZy4gKDEpIEMuY3JlYXRlZCwgKDIpIEEuY3JlYXRlZCxcbi8vICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWQuIFRoZXJlIHdhcyBubyBzdXBwb3J0IGZvclxuLy8gc3VwZXIsIGFuZCBcInN1cGVyLWJlaGF2aW9yXCIgbWV0aG9kcyB3ZXJlIGNhbGxhYmxlIG9ubHkgYnkgbmFtZSkuXG4vL1xuLy8gMi54XG4vLyBCZWhhdmlvcnMgYXJlIG1hZGUgaW50byBwcm9wZXIgbWl4aW5zIHdoaWNoIGxpdmUgaW4gdGhlXG4vLyBlbGVtZW50J3MgcHJvdG90eXBlIGNoYWluLiBCZWhhdmlvcnMgYXJlIHBsYWNlZCBpbiB0aGUgZWxlbWVudCBwcm90b3R5cGVcbi8vIGVsZGVzdCB0byB5b3VuZ2VzdCBhbmQgZGUtZHVwZWQgeW91bmdlc3QgdG8gb2xkZXN0OlxuLy8gU28sIGZpcnN0IFtBLCBCLCBDLCBBLCBCXSBiZWNvbWVzIFtDLCBBLCBCXSB0aGVuLFxuLy8gdGhlIGVsZW1lbnQgcHJvdG90eXBlIGJlY29tZXMgKG9sZGVzdCkgKDEpIFBvbHltZXIuRWxlbWVudCwgKDIpIGNsYXNzKEMpLFxuLy8gKDMpIGNsYXNzKEEpLCAoNCkgY2xhc3MoQiksICg1KSBjbGFzcyhQb2x5bWVyKHsuLi59KSkuXG4vLyBSZXN1bHQ6XG4vLyBUaGlzIG1lYW5zIGVsZW1lbnQgcHJvcGVydGllcyB3aW4gb3ZlciBCIHByb3BlcnRpZXMgd2luIG92ZXIgQSB3aW5cbi8vIG92ZXIgQy4gKHNhbWUgYXMgMS54KVxuLy8gSWYgbGlmZWN5Y2xlIGlzIGNhbGxlZCAoc3VwZXIgdGhlbiBtZSksIG9yZGVyIGlzXG4vLyAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLCAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkXG4vLyAoYWdhaW4gc2FtZSBhcyAxLngpXG5mdW5jdGlvbiBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICBmb3IgKGxldCBpPTA7IGk8YmVoYXZpb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGIgPSBiZWhhdmlvcnNbaV07XG4gICAgaWYgKGIpIHtcbiAgICAgIGtsYXNzID0gQXJyYXkuaXNBcnJheShiKSA/IF9taXhpbkJlaGF2aW9ycyhiLCBrbGFzcykgOlxuICAgICAgICBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oYiwga2xhc3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2xhc3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYmVoYXZpb3JzIExpc3Qgb2YgYmVoYXZpb3JzIHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge0FycmF5PX0gbGlzdCBUYXJnZXQgbGlzdCB0byBmbGF0dGVuIGJlaGF2aW9ycyBpbnRvLlxuICogQHBhcmFtIHtBcnJheT19IGV4Y2x1ZGUgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZXhjbHVkZSBmcm9tIHRoZSBsaXN0LlxuICogQHJldHVybiB7IUFycmF5fSBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBiZWhhdmlvcnMuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBsaXN0LCBleGNsdWRlKSB7XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICBmb3IgKGxldCBpPWJlaGF2aW9ycy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICBpZiAoYikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgZmxhdHRlbkJlaGF2aW9ycyhiLCBsaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZHVwXG4gICAgICAgIGlmIChsaXN0LmluZGV4T2YoYikgPCAwICYmICghZXhjbHVkZSB8fCBleGNsdWRlLmluZGV4T2YoYikgPCAwKSkge1xuICAgICAgICAgIGxpc3QudW5zaGlmdChiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2JlaGF2aW9yIGlzIG51bGwsIGNoZWNrIGZvciBtaXNzaW5nIG9yIDQwNCBpbXBvcnQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gUG9seW1lciBpbmZvIG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBCYXNlIGJhc2UgY2xhc3MgdG8gZXh0ZW5kIHdpdGggaW5mbyBvYmplY3RcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEdlbmVyYXRlZCBjbGFzc1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIEJhc2UpIHtcblxuICBjbGFzcyBQb2x5bWVyR2VuZXJhdGVkIGV4dGVuZHMgQmFzZSB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4gaW5mby5wcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgcmV0dXJuIGluZm8ub2JzZXJ2ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIGZvciB0aGlzIGNsYXNzXG4gICAgICovXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgIC8vIGdldCB0ZW1wbGF0ZSBmaXJzdCBmcm9tIGFueSBpbXBlcmF0aXZlIHNldCBpbiBgaW5mby5fdGVtcGxhdGVgXG4gICAgICByZXR1cm4gaW5mby5fdGVtcGxhdGUgfHxcbiAgICAgICAgLy8gbmV4dCBsb29rIGluIGRvbS1tb2R1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWxlbWVudCdzIGlzLlxuICAgICAgICBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKSB8fFxuICAgICAgICAvLyBuZXh0IGxvb2sgZm9yIHN1cGVyY2xhc3MgdGVtcGxhdGUgKG5vdGU6IHVzZSBzdXBlcmNsYXNzIHN5bWJvbFxuICAgICAgICAvLyB0byBlbnN1cmUgY29ycmVjdCBgdGhpcy5pc2ApXG4gICAgICAgIEJhc2UudGVtcGxhdGUgfHxcbiAgICAgICAgLy8gZmluYWxseSBmYWxsIGJhY2sgdG8gYF90ZW1wbGF0ZWAgaW4gZWxlbWVudCdzIHByb3RveXBlLlxuICAgICAgICB0aGlzLnByb3RvdHlwZS5fdGVtcGxhdGUgfHxcbiAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICBjcmVhdGVkKCkge1xuICAgICAgc3VwZXIuY3JlYXRlZCgpO1xuICAgICAgaWYgKGluZm8uY3JlYXRlZCkge1xuICAgICAgICBpbmZvLmNyZWF0ZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVnaXN0ZXJlZCgpIHtcbiAgICAgIHN1cGVyLl9yZWdpc3RlcmVkKCk7XG4gICAgICAvKiBOT1RFOiBgYmVmb3JlUmVnaXN0ZXJgIGlzIGNhbGxlZCBoZXJlIGZvciBiYywgYnV0IHRoZSBiZWhhdmlvclxuICAgICAgIGlzIGRpZmZlcmVudCB0aGFuIGluIDEueC4gSW4gMS4wLCB0aGUgbWV0aG9kIHdhcyBjYWxsZWQgKmFmdGVyKlxuICAgICAgIG1peGluZyBwcm90b3R5cGVzIHRvZ2V0aGVyIGJ1dCAqYmVmb3JlKiBwcm9jZXNzaW5nIG9mIG1ldGEtb2JqZWN0cy5cbiAgICAgICBIb3dldmVyLCBkeW5hbWljIGVmZmVjdHMgY2FuIHN0aWxsIGJlIHNldCBoZXJlIGFuZCBjYW4gYmUgZG9uZSBlaXRoZXJcbiAgICAgICBpbiBgYmVmb3JlUmVnaXN0ZXJgIG9yIGByZWdpc3RlcmVkYC4gSXQgaXMgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldFxuICAgICAgIGBpc2AgaW4gYGJlZm9yZVJlZ2lzdGVyYCBhcyB5b3UgY291bGQgaW4gMS54LlxuICAgICAgKi9cbiAgICAgIGlmIChpbmZvLmJlZm9yZVJlZ2lzdGVyKSB7XG4gICAgICAgIGluZm8uYmVmb3JlUmVnaXN0ZXIuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ucmVnaXN0ZXJlZCkge1xuICAgICAgICBpbmZvLnJlZ2lzdGVyZWQuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hcHBseUxpc3RlbmVycygpIHtcbiAgICAgIHN1cGVyLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgaWYgKGluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGwgaW4gaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKHRoaXMsIGwsIGluZm8ubGlzdGVuZXJzW2xdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdGU6IGV4Y2VwdGlvbiB0byBcInN1cGVyIHRoZW4gbWVcIiBydWxlO1xuICAgIC8vIGRvIHdvcmsgYmVmb3JlIGNhbGxpbmcgc3VwZXIgc28gdGhhdCBzdXBlciBhdHRyaWJ1dGVzXG4gICAgLy8gb25seSBhcHBseSBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7XG4gICAgICBpZiAoaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKGxldCBhIGluIGluZm8uaG9zdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB0aGlzLl9lbnN1cmVBdHRyaWJ1dGUoYSwgaW5mby5ob3N0QXR0cmlidXRlc1thXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1cGVyLl9lbnN1cmVBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgcmVhZHkoKSB7XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgaWYgKGluZm8ucmVhZHkpIHtcbiAgICAgICAgaW5mby5yZWFkeS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dGFjaGVkKCkge1xuICAgICAgc3VwZXIuYXR0YWNoZWQoKTtcbiAgICAgIGlmIChpbmZvLmF0dGFjaGVkKSB7XG4gICAgICAgIGluZm8uYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZXRhY2hlZCgpIHtcbiAgICAgIHN1cGVyLmRldGFjaGVkKCk7XG4gICAgICBpZiAoaW5mby5kZXRhY2hlZCkge1xuICAgICAgICBpbmZvLmRldGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgaWYgKGluZm8uYXR0cmlidXRlQ2hhbmdlZCkge1xuICAgICAgICBpbmZvLmF0dHJpYnV0ZUNoYW5nZWQuY2FsbCh0aGlzLCBuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgIH1cbiAgIH1cbiAgfVxuXG4gIFBvbHltZXJHZW5lcmF0ZWQuZ2VuZXJhdGVkRnJvbSA9IGluZm87XG5cbiAgZm9yIChsZXQgcCBpbiBpbmZvKSB7XG4gICAgLy8gTk9URTogY2Fubm90IGNvcHkgYG1ldGFQcm9wc2AgbWV0aG9kcyBvbnRvIHByb3RvdHlwZSBhdCBsZWFzdCBiZWNhdXNlXG4gICAgLy8gYHN1cGVyLnJlYWR5YCBtdXN0IGJlIGNhbGxlZCBhbmQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSB1c2VyIGZuLlxuICAgIGlmICghKHAgaW4gbWV0YVByb3BzKSkge1xuICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmZvLCBwKTtcbiAgICAgIGlmIChwZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9seW1lckdlbmVyYXRlZC5wcm90b3R5cGUsIHAsIHBkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUG9seW1lckdlbmVyYXRlZDtcbn1cblxuZXhwb3J0IGNvbnN0IENsYXNzID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoIWluZm8pIHtcbiAgICBjb25zb2xlLndhcm4oJ1BvbHltZXIuQ2xhc3MgcmVxdWlyZXMgYGluZm9gIGFyZ3VtZW50Jyk7XG4gIH1cbiAgbGV0IGtsYXNzID0gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIGluZm8uYmVoYXZpb3JzID9cbiAgICAvLyBub3RlOiBtaXhpbkJlaGF2aW9ycyBlbnN1cmVzIGBMZWdhY3lFbGVtZW50TWl4aW5gLlxuICAgIG1peGluQmVoYXZpb3JzKGluZm8uYmVoYXZpb3JzLCBIVE1MRWxlbWVudCkgOlxuICAgIExlZ2FjeUVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCkpO1xuICAvLyBkZWNvcmF0ZSBrbGFzcyB3aXRoIHJlZ2lzdHJhdGlvbiBpbmZvXG4gIGtsYXNzLmlzID0gaW5mby5pcztcbiAgcmV0dXJuIGtsYXNzO1xufTtcblxuZXhwb3J0IHsgbWl4aW5CZWhhdmlvcnMgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmpzIiwiaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgYXMgVGVtcGxhdGVJbnN0YW5jZUJhc2UkMCwgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuXG5sZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgX3RlbXBsYXRpemVyVGVtcGxhdGU6IEhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gKiAgIF9wYXJlbnRNb2RlbDogYm9vbGVhbixcbiAqICAgX2luc3RhbmNlUHJvcHM6IE9iamVjdCxcbiAqICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBGdW5jdGlvbixcbiAqICAgX25vdGlmeUluc3RhbmNlUHJvcFYyOiBGdW5jdGlvbixcbiAqICAgY3RvcjogVGVtcGxhdGVJbnN0YW5jZUJhc2VcbiAqIH19XG4gKi9cbmxldCBUZW1wbGF0aXplclVzZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBUaGUgYFBvbHltZXIuVGVtcGxhdGl6ZXJgIGJlaGF2aW9yIGFkZHMgbWV0aG9kcyB0byBnZW5lcmF0ZSBpbnN0YW5jZXMgb2ZcbiAqIHRlbXBsYXRlcyB0aGF0IGFyZSBlYWNoIG1hbmFnZWQgYnkgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2BcbiAqIGluc3RhbmNlIHdoZXJlIGRhdGEtYmluZGluZ3MgaW4gdGhlIHN0YW1wZWQgdGVtcGxhdGUgY29udGVudCBhcmUgYm91bmQgdG9cbiAqIGFjY2Vzc29ycyBvbiBpdHNlbGYuXG4gKlxuICogVGhpcyBiZWhhdmlvciBpcyBwcm92aWRlZCBpbiBQb2x5bWVyIDIueCBhcyBhIGh5YnJpZC1lbGVtZW50IGNvbnZlbmllbmNlXG4gKiBvbmx5LiAgRm9yIG5vbi1oeWJyaWQgdXNhZ2UsIHRoZSBgUG9seW1lci5UZW1wbGF0aXplYCBsaWJyYXJ5XG4gKiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICogICAgIHRoaXMudGVtcGxhdGl6ZSh0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gKiAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5zdGFtcCh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAqICAgICAvLyBJbnNlcnQgdGhlIGluc3RhbmNlJ3MgRE9NIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAqICAgICBQb2x5bWVyLmRvbSh0aGlzKS5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICogICAgIC8vIGluIHRoZSB0ZW1wbGF0ZVxuICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICpcbiAqIFVzZXJzIG9mIGBUZW1wbGF0aXplcmAgbWF5IG5lZWQgdG8gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3RcbiAqIEFQSSdzIHRvIGRldGVybWluZSBob3cgcHJvcGVydGllcyBhbmQgcGF0aHMgZnJvbSB0aGUgaG9zdCBzaG91bGQgYmVcbiAqIGZvcndhcmRlZCBpbnRvIHRvIGluc3RhbmNlczpcbiAqXG4gKiAgICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSlcbiAqXG4gKiBMaWtld2lzZSwgdXNlcnMgbWF5IGltcGxlbWVudCB0aGVzZSBhZGRpdGlvbmFsIGFic3RyYWN0IEFQSSdzIHRvIGRldGVybWluZVxuICogaG93IGluc3RhbmNlLXNwZWNpZmljIHByb3BlcnRpZXMgdGhhdCBjaGFuZ2Ugb24gdGhlIGluc3RhbmNlIHNob3VsZCBiZVxuICogZm9yd2FyZGVkIG91dCB0byB0aGUgaG9zdCwgaWYgbmVjZXNzYXJ5LlxuICpcbiAqICAgICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKVxuICpcbiAqIEluIG9yZGVyIHRvIGRldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBpbnN0YW5jZS1zcGVjaWZpYyBhbmQgcmVxdWlyZVxuICogY3VzdG9tIG5vdGlmaWNhdGlvbiB2aWEgYF9ub3RpZnlJbnN0YW5jZVByb3BgLCBkZWZpbmUgYW4gYF9pbnN0YW5jZVByb3BzYFxuICogb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgZWFjaCBpbnN0YW5jZSBwcm9wLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgX2luc3RhbmNlUHJvcHM6IHtcbiAqICAgICAgIGl0ZW06IHRydWUsXG4gKiAgICAgICBpbmRleDogdHJ1ZVxuICogICAgIH1cbiAqXG4gKiBBbnkgcHJvcGVydGllcyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiBfaW5zdGFuY2VQcm9wXG4gKiB3aWxsIGJlIGZvcndhcmRlZCBvdXQgdG8gdGhlIFRlbXBsYXRpemUgYG93bmVyYCBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFVzZXJzIG1heSBhbHNvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIGFic3RyYWN0IGZ1bmN0aW9uIHRvIHNob3cgb3JcbiAqIGhpZGUgYW55IERPTSBnZW5lcmF0ZWQgdXNpbmcgYHN0YW1wYDpcbiAqXG4gKiAgICAgX3Nob3dIaWRlQ2hpbGRyZW46IGZ1bmN0aW9uKHNob3VsZEhpZGUpXG4gKlxuICogTm90ZSB0aGF0IHNvbWUgY2FsbGJhY2tzIGFyZSBzdWZmaXhlZCB3aXRoIGBWMmAgaW4gdGhlIFBvbHltZXIgMi54IGJlaGF2aW9yXG4gKiBhcyB0aGUgaW1wbGVtZW50YXRpb25zIHdpbGwgbmVlZCB0byBkaWZmZXIgZnJvbSB0aGUgY2FsbGJhY2tzIHJlcXVpcmVkXG4gKiBieSB0aGUgMS54IFRlbXBsYXRpemVyIEFQSSBkdWUgdG8gY2hhbmdlcyBpbiB0aGUgYFRlbXBsYXRlSW5zdGFuY2VgIEFQSVxuICogYmV0d2VlbiB2ZXJzaW9ucyAxLnggYW5kIDIueC5cbiAqXG4gKiBAcG9seW1lckJlaGF2aW9yXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5sZXQgVGVtcGxhdGl6ZXIgPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBhbm9ueW1vdXMgYFRlbXBsYXRlSW5zdGFuY2VgIGNsYXNzIChzdG9yZWQgYXMgYHRoaXMuY3RvcmApXG4gICAqIGZvciB0aGUgcHJvdmlkZWQgdGVtcGxhdGUuICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uY2UgcGVyXG4gICAqIHRlbXBsYXRlIHRvIHByZXBhcmUgYW4gZWxlbWVudCBmb3Igc3RhbXBpbmcgdGhlIHRlbXBsYXRlLCBmb2xsb3dlZFxuICAgKiBieSBgc3RhbXBgIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwcmVwYXJlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG11dGFibGVEYXRhIFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcFxuICAgKiAgIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0b1xuICAgKiAgIGJlIFwiZGlydHlcIikuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgbXV0YWJsZURhdGEpIHtcbiAgICB0aGlzLl90ZW1wbGF0aXplclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgdGhpcy5jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICBtdXRhYmxlRGF0YTogQm9vbGVhbihtdXRhYmxlRGF0YSksXG4gICAgICBwYXJlbnRNb2RlbDogdGhpcy5fcGFyZW50TW9kZWwsXG4gICAgICBpbnN0YW5jZVByb3BzOiB0aGlzLl9pbnN0YW5jZVByb3BzLFxuICAgICAgZm9yd2FyZEhvc3RQcm9wOiB0aGlzLl9mb3J3YXJkSG9zdFByb3BWMixcbiAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogdGhpcy5fbm90aWZ5SW5zdGFuY2VQcm9wVjJcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLiAgVGhlIG9iamVjdFxuICAgKiByZXR1cm5lZCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYW5vbnltb3VzIGNsYXNzIGdlbmVyYXRlZCBieSBgdGVtcGxhdGl6ZWBcbiAgICogd2hvc2UgYHJvb3RgIHByb3BlcnR5IGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBuZXdseSBjbG9uZWRcbiAgICogdGVtcGxhdGUgY29udGVudCwgYW5kIHdoaWNoIGhhcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgY29ycmVzcG9uZGluZyB0b1xuICAgKiBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGVtcGxhdGUgYmluZGluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gbW9kZWwgT2JqZWN0IGNvbnRhaW5pbmcgaW5pdGlhbCBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICogICBwb3B1bGF0ZSBpbnRvIHRoZSB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW5zdGFuY2Ugb2ZcbiAgICogdGhlIHRlbXBsYXRlIHByZXBhcmVkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICovXG4gIHN0YW1wKG1vZGVsKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IobW9kZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgKGBUZW1wbGF0ZUluc3RhbmNlYCkgYXNzb2NpYXRlZCB3aXRoXG4gICAqIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGVcbiAgICogaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXMgY29udGFpbmVkIGluLiAgQSB0ZW1wbGF0ZSBtb2RlbCBzaG91bGQgYmUgdXNlZFxuICAgKiB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgKiAgIHRoZSBlbGVtZW50LlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIFRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUsIGVsKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgVGVtcGxhdGl6ZXIgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IFByb3BlcnR5RWZmZWN0cyB9IGZyb20gJy4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcbmltcG9ydCB7IE9wdGlvbmFsTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcbmltcG9ydCB7IEdlc3R1cmVFdmVudExpc3RlbmVycyB9IGZyb20gJy4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SFRNTEVsZW1lbnR9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICovXG5jb25zdCBkb21CaW5kQmFzZSA9XG4gIEdlc3R1cmVFdmVudExpc3RlbmVycyhcbiAgICBPcHRpb25hbE11dGFibGVEYXRhKFxuICAgICAgUHJvcGVydHlFZmZlY3RzKEhUTUxFbGVtZW50KSkpO1xuXG4vKipcbiAqIEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YSBiaW5kaW5nLFxuICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGRlZmluaW5nXG4gKiBhIG5ldyBjdXN0b20gZWxlbWVudC5cbiAqXG4gKiBgPHRlbXBsYXRlPmAgdGFncyB1dGlsaXppbmcgYmluZGluZ3MgbWF5IGJlIHdyYXBwZWQgd2l0aCB0aGUgYDxkb20tYmluZD5gXG4gKiBlbGVtZW50LCB3aGljaCB3aWxsIGltbWVkaWF0ZWx5IHN0YW1wIHRoZSB3cmFwcGVkIHRlbXBsYXRlIGludG8gdGhlIG1haW5cbiAqIGRvY3VtZW50IGFuZCBiaW5kIGVsZW1lbnRzIHRvIHRoZSBgZG9tLWJpbmRgIGVsZW1lbnQgaXRzZWxmIGFzIHRoZVxuICogYmluZGluZyBzY29wZS5cbiAqXG4gKiBAcG9seW1lclxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzXG4gKiBAZXh0ZW5kcyB7ZG9tQmluZEJhc2V9XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhXG4gKiAgIGJpbmRpbmcsIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycywgZXRjLikgaW4gdGhlIG1haW4gZG9jdW1lbnQuXG4gKi9cbmNsYXNzIERvbUJpbmQgZXh0ZW5kcyBkb21CaW5kQmFzZSB7XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ211dGFibGUtZGF0YSddOyB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuJCA9IG51bGw7XG4gICAgdGhpcy5fX2NoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFzc3VtZXMgb25seSBvbmUgb2JzZXJ2ZWQgYXR0cmlidXRlXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm11dGFibGVEYXRhID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9fcmVtb3ZlQ2hpbGRyZW4oKTtcbiAgfVxuXG4gIF9faW5zZXJ0Q2hpbGRyZW4oKSB7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnJvb3QsIHRoaXMpO1xuICB9XG5cbiAgX19yZW1vdmVDaGlsZHJlbigpIHtcbiAgICBpZiAodGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBUaGlzIGlzIHR5cGljYWxseSBvbmx5XG4gICAqIG5lY2Vzc2FyeSB0byBjYWxsIGlmIEhUTUxJbXBvcnRzIHdpdGggdGhlIGFzeW5jIGF0dHJpYnV0ZSBhcmUgdXNlZC5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgdGVtcGxhdGU7XG4gICAgaWYgKCF0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgIHRlbXBsYXRlID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyh0ZW1wbGF0ZSB8fCB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1iaW5kIHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIHRoaXMuJCA9IHRoaXMucm9vdC4kO1xuICAgICAgdGhpcy5fX2NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGxldCBuPXRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy5fX2NoaWxkcmVuW3RoaXMuX19jaGlsZHJlbi5sZW5ndGhdID0gbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gICAgdGhpcy5fX2luc2VydENoaWxkcmVuKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH0pKTtcbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLWJpbmQnLCBEb21CaW5kKTtcblxuZXhwb3J0IHsgRG9tQmluZCB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5qcyIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgZW5xdWV1ZURlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuLi91dGlscy9hc3luYy5qcyc7XG5pbXBvcnQgeyByb290IGFzIHJvb3QkMCB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuXG4vKipcbiAqIFRoZSBgPGRvbS1pZj5gIGVsZW1lbnQgd2lsbCBzdGFtcCBhIGxpZ2h0LWRvbSBgPHRlbXBsYXRlPmAgY2hpbGQgd2hlblxuICogdGhlIGBpZmAgcHJvcGVydHkgYmVjb21lcyB0cnV0aHksIGFuZCB0aGUgdGVtcGxhdGUgY2FuIHVzZSBQb2x5bWVyXG4gKiBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGZlYXR1cmVzIHdoZW4gdXNlZCBpbiB0aGUgY29udGV4dCBvZlxuICogYSBQb2x5bWVyIGVsZW1lbnQncyB0ZW1wbGF0ZS5cbiAqXG4gKiBXaGVuIGBpZmAgYmVjb21lcyBmYWxzZXksIHRoZSBzdGFtcGVkIGNvbnRlbnQgaXMgaGlkZGVuIGJ1dCBub3RcbiAqIHJlbW92ZWQgZnJvbSBkb20uIFdoZW4gYGlmYCBzdWJzZXF1ZW50bHkgYmVjb21lcyB0cnV0aHkgYWdhaW4sIHRoZSBjb250ZW50XG4gKiBpcyBzaW1wbHkgcmUtc2hvd24uIFRoaXMgYXBwcm9hY2ggaXMgdXNlZCBkdWUgdG8gaXRzIGZhdm9yYWJsZSBwZXJmb3JtYW5jZVxuICogY2hhcmFjdGVyaXN0aWNzOiB0aGUgZXhwZW5zZSBvZiBjcmVhdGluZyB0ZW1wbGF0ZSBjb250ZW50IGlzIHBhaWQgb25seVxuICogb25jZSBhbmQgbGF6aWx5LlxuICpcbiAqIFNldCB0aGUgYHJlc3RhbXBgIHByb3BlcnR5IHRvIHRydWUgdG8gZm9yY2UgdGhlIHN0YW1wZWQgY29udGVudCB0byBiZVxuICogY3JlYXRlZCAvIGRlc3Ryb3llZCB3aGVuIHRoZSBgaWZgIGNvbmRpdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQGV4dGVuZHMgUG9seW1lci5FbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBjb25kaXRpb25hbGx5IHN0YW1wcyBhbmQgaGlkZXMgb3IgcmVtb3Zlc1xuICogICB0ZW1wbGF0ZSBjb250ZW50IGJhc2VkIG9uIGEgYm9vbGVhbiBmbGFnLlxuICovXG5jbGFzcyBEb21JZiBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdkb20taWYnOyB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkL2hpZGRlbiBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAgICogYHJlbmRlcmAuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyB0ZW1wbGF0ZSBzaG91bGQgc3RhbXAuXG4gICAgICAgKi9cbiAgICAgIGlmOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0cnVlLCBlbGVtZW50cyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET00gYW5kIGRpc2NhcmRlZCB3aGVuIGBpZmBcbiAgICAgICAqIGJlY29tZXMgZmFsc2UgYW5kIHJlLWNyZWF0ZWQgYW5kIGFkZGVkIGJhY2sgdG8gdGhlIERPTSB3aGVuIGBpZmBcbiAgICAgICAqIGJlY29tZXMgdHJ1ZS4gIEJ5IGRlZmF1bHQsIHN0YW1wZWQgZWxlbWVudHMgd2lsbCBiZSBoaWRkZW4gYnV0IGxlZnRcbiAgICAgICAqIGluIHRoZSBET00gd2hlbiBgaWZgIGJlY29tZXMgZmFsc2UsIHdoaWNoIGlzIGdlbmVyYWxseSByZXN1bHRzXG4gICAgICAgKiBpbiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgKi9cbiAgICAgIHJlc3RhbXA6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgfVxuXG4gICAgfTtcblxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gbnVsbDtcbiAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RJZiA9IGZhbHNlO1xuICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgfVxuXG4gIF9fZGVib3VuY2VSZW5kZXIoKSB7XG4gICAgLy8gUmVuZGVyIGlzIGFzeW5jIGZvciAyIHJlYXNvbnM6XG4gICAgLy8gMS4gVG8gZWxpbWluYXRlIGRvbSBjcmVhdGlvbiB0cmFzaGluZyBpZiB1c2VyIGNvZGUgdGhyYXNoZXMgYGlmYCBpbiB0aGVcbiAgICAvLyAgICBzYW1lIHR1cm4uIFRoaXMgd2FzIG1vcmUgY29tbW9uIGluIDEueCB3aGVyZSBhIGNvbXBvdW5kIGNvbXB1dGVkXG4gICAgLy8gICAgcHJvcGVydHkgY291bGQgcmVzdWx0IGluIHRoZSByZXN1bHQgY2hhbmdpbmcgbXVsdGlwbGUgdGltZXMsIGJ1dCBpc1xuICAgIC8vICAgIG1pdGlnYXRlZCB0byBhIGxhcmdlIGV4dGVudCBieSBiYXRjaGVkIHByb3BlcnR5IHByb2Nlc3NpbmcgaW4gMi54LlxuICAgIC8vIDIuIFRvIGF2b2lkIGRvdWJsZSBvYmplY3QgcHJvcGFnYXRpb24gd2hlbiBhIGJhZyBpbmNsdWRpbmcgdmFsdWVzIGJvdW5kXG4gICAgLy8gICAgdG8gdGhlIGBpZmAgcHJvcGVydHkgYXMgd2VsbCBhcyBvbmUgb3IgbW9yZSBob3N0UHJvcHMgY291bGQgZW5xdWV1ZVxuICAgIC8vICAgIHRoZSA8ZG9tLWlmPiB0byBmbHVzaCBiZWZvcmUgdGhlIDx0ZW1wbGF0ZT4ncyBob3N0IHByb3BlcnR5XG4gICAgLy8gICAgZm9yd2FyZGluZy4gSW4gdGhhdCBzY2VuYXJpbyBjcmVhdGluZyBhbiBpbnN0YW5jZSB3b3VsZCByZXN1bHQgaW5cbiAgICAvLyAgICB0aGUgaG9zdCBwcm9wcyBiZWluZyBzZXQgb25jZSwgYW5kIHRoZW4gdGhlIGVucXVldWVkIGNoYW5nZXMgb24gdGhlXG4gICAgLy8gICAgdGVtcGxhdGUgd291bGQgc2V0IHByb3BlcnRpZXMgYSBzZWNvbmQgdGltZSwgcG90ZW50aWFsbHkgY2F1c2luZyBhblxuICAgIC8vICAgIG9iamVjdCB0byBiZSBzZXQgdG8gYW4gaW5zdGFuY2UgbW9yZSB0aGFuIG9uY2UuICBDcmVhdGluZyB0aGVcbiAgICAvLyAgICBpbnN0YW5jZSBhc3luYyBmcm9tIGZsdXNoaW5nIGRhdGEgZW5zdXJlcyB0aGlzIGRvZXNuJ3QgaGFwcGVuLiBJZlxuICAgIC8vICAgIHdlIHdhbnRlZCBhIHN5bmMgb3B0aW9uIGluIHRoZSBmdXR1cmUsIHNpbXBseSBoYXZpbmcgPGRvbS1pZj4gZmx1c2hcbiAgICAvLyAgICAob3IgY2xlYXIpIGl0cyB0ZW1wbGF0ZSdzIHBlbmRpbmcgaG9zdCBwcm9wZXJ0aWVzIGJlZm9yZSBjcmVhdGluZ1xuICAgIC8vICAgIHRoZSBpbnN0YW5jZSB3b3VsZCBhbHNvIGF2b2lkIHRoZSBwcm9ibGVtLlxuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlclxuICAgICAgICAsIG1pY3JvVGFza1xuICAgICAgICAsICgpID0+IHRoaXMuX19yZW5kZXIoKSk7XG4gICAgZW5xdWV1ZURlYm91bmNlcih0aGlzLl9fcmVuZGVyRGVib3VuY2VyKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUgfHxcbiAgICAgICAgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcbiAgICAgICAgICF0aGlzLnBhcmVudE5vZGUuaG9zdCkpIHtcbiAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBpZiAodGhpcy5pZikge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgZmx1c2goKTtcbiAgfVxuXG4gIF9fcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICBpZiAoIXRoaXMuX19lbnN1cmVJbnN0YW5jZSgpKSB7XG4gICAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlc3RhbXApIHtcbiAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZXN0YW1wICYmIHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZiAhPSB0aGlzLl9sYXN0SWYpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICB9KSk7XG4gICAgICB0aGlzLl9sYXN0SWYgPSB0aGlzLmlmO1xuICAgIH1cbiAgfVxuXG4gIF9fZW5zdXJlSW5zdGFuY2UoKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgLy8gR3VhcmQgYWdhaW5zdCBlbGVtZW50IGJlaW5nIGRldGFjaGVkIHdoaWxlIHJlbmRlciB3YXMgcXVldWVkXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20taWYgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgLy8gZG9tLWlmIHRlbXBsYXRpemVyIGluc3RhbmNlcyByZXF1aXJlIGBtdXRhYmxlOiB0cnVlYCwgYXNcbiAgICAgICAgICAvLyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIHJlbGllcyBvbiB0aGF0IGJlaGF2aW9yIHRvIHN5bmMgb2JqZWN0c1xuICAgICAgICAgIG11dGFibGVEYXRhOiB0cnVlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIGZvcndhcmRcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHByb3BlcnR5XG4gICAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAgICovXG4gICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5zdGFuY2UgYnV0IGFyZSBzcXVlbGNoaW5nIGhvc3QgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBmb3J3YXJkaW5nIGR1ZSB0byBpZiBiZWluZyBmYWxzZSwgbm90ZSB0aGUgaW52YWxpZGF0ZWRcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHNvIGBfX3N5bmNIb3N0UHJvcGVydGllc2AgY2FuIHN5bmMgdGhlbSB0aGUgbmV4dFxuICAgICAgICAgICAgICAgIC8vIHRpbWUgYGlmYCBiZWNvbWVzIHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHNbcm9vdCQwKHByb3ApXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlID0gbmV3IHRoaXMuX19jdG9yKCk7XG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX19pbnN0YW5jZS5yb290LCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19zeW5jSG9zdFByb3BlcnRpZXMoKTtcbiAgICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IGNhc2Ugd2hlcmUgZG9tLWlmIHdhcyByZS1hdHRhY2hlZCBpbiBuZXcgcG9zaXRpb25cbiAgICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGxhc3RDaGlsZCAhPT0gYyRbYyQubGVuZ3RoLTFdKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX19zeW5jSG9zdFByb3BlcnRpZXMoKSB7XG4gICAgbGV0IHByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcztcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcCwgdGhpcy5fX2RhdGFIb3N0W3Byb3BdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2luc3RhbmNlLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cblxuICBfX3RlYXJkb3duSW5zdGFuY2UoKSB7XG4gICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgaWYgKGMkICYmIGMkLmxlbmd0aCkge1xuICAgICAgICAvLyB1c2UgZmlyc3QgY2hpbGQgcGFyZW50LCBmb3IgY2FzZSB3aGVuIGRvbS1pZiBtYXkgaGF2ZSBiZWVuIGRldGFjaGVkXG4gICAgICAgIGxldCBwYXJlbnQgPSBjJFswXS5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfc2hvd0hpZGVDaGlsZHJlbigpIHtcbiAgICBsZXQgaGlkZGVuID0gdGhpcy5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gfHwgIXRoaXMuaWY7XG4gICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgdGhpcy5fX2luc3RhbmNlLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgfVxuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKERvbUlmLmlzLCBEb21JZik7XG5cbmV4cG9ydCB7IERvbUlmIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1pZi5qcyIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfSBmcm9tICcuLi91dGlscy9hcnJheS1zcGxpY2UuanMnO1xuaW1wb3J0IHsgRWxlbWVudE1peGluIH0gZnJvbSAnLi4vbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuXG4vKipcbiAqIEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICogbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGEgYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZVxuICogbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdCkgZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlXG4gKiBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtcyBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gKlxuICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogQHBvbHltZXJcbiAqIEBtaXhpbkZ1bmN0aW9uXG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5XG4gKi9cbmxldCBBcnJheVNlbGVjdG9yTWl4aW4gPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICovXG4gIGxldCBlbGVtZW50QmFzZSA9IEVsZW1lbnRNaXhpbihzdXBlckNsYXNzKTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBBcnJheVNlbGVjdG9yTWl4aW4gZXh0ZW5kcyBlbGVtZW50QmFzZSB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZnJvbSB3aGljaCBzZWxlY3Rpb24gd2lsbCBiZSBtYWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgdHJ1ZWAsIG11bHRpcGxlIGl0ZW1zIG1heSBiZSBzZWxlY3RlZCBhdCBvbmNlIChpbiB0aGlzIGNhc2UsXG4gICAgICAgICAqIGBzZWxlY3RlZGAgaXMgYW4gYXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zKS4gIFdoZW4gYGZhbHNlYCxcbiAgICAgICAgICogb25seSBvbmUgaXRlbSBtYXkgYmUgc2VsZWN0ZWQgYXQgYSB0aW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGk6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIHRydWUsIHRoaXMgaXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhbnkgc2VsZWN0ZWQuXG4gICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAdHlwZSB7PyhPYmplY3R8QXJyYXk8IU9iamVjdD4pfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgdHJ1ZWAsIGNhbGxpbmcgYHNlbGVjdGAgb24gYW4gaXRlbSB0aGF0IGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICogd2lsbCBkZXNlbGVjdCB0aGUgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbJ19fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtcy4qKSddO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBudWxsO1xuICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG51bGw7XG4gICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBudWxsO1xuICAgIH1cblxuICAgIF9fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtc0luZm8pIHtcbiAgICAgIGxldCBwYXRoID0gaXRlbXNJbmZvLnBhdGg7XG4gICAgICBpZiAocGF0aCA9PSAnaXRlbXMnKSB7XG4gICAgICAgIC8vIENhc2UgMSAtIGl0ZW1zIGFycmF5IGNoYW5nZWQsIHNvIGRpZmYgYWdhaW5zdCBwcmV2aW91cyBhcnJheSBhbmRcbiAgICAgICAgLy8gZGVzZWxlY3QgYW55IHJlbW92ZWQgaXRlbXMgYW5kIGFkanVzdCBzZWxlY3RlZCBpbmRpY2VzXG4gICAgICAgIGxldCBuZXdJdGVtcyA9IGl0ZW1zSW5mby5iYXNlIHx8IFtdO1xuICAgICAgICBsZXQgbGFzdEl0ZW1zID0gdGhpcy5fX2xhc3RJdGVtcztcbiAgICAgICAgbGV0IGxhc3RNdWx0aSA9IHRoaXMuX19sYXN0TXVsdGk7XG4gICAgICAgIGlmIChtdWx0aSAhPT0gbGFzdE11bHRpKSB7XG4gICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SXRlbXMpIHtcbiAgICAgICAgICBsZXQgc3BsaWNlcyA9IGNhbGN1bGF0ZVNwbGljZXMobmV3SXRlbXMsIGxhc3RJdGVtcyk7XG4gICAgICAgICAgdGhpcy5fX2FwcGx5U3BsaWNlcyhzcGxpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbGFzdEl0ZW1zID0gbmV3SXRlbXM7XG4gICAgICAgIHRoaXMuX19sYXN0TXVsdGkgPSBtdWx0aTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNJbmZvLnBhdGggPT0gJ2l0ZW1zLnNwbGljZXMnKSB7XG4gICAgICAgIC8vIENhc2UgMiAtIGdvdCBzcGVjaWZpYyBzcGxpY2UgaW5mb3JtYXRpb24gZGVzY3JpYmluZyB0aGUgYXJyYXkgbXV0YXRpb246XG4gICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKGl0ZW1zSW5mby52YWx1ZS5pbmRleFNwbGljZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSAzIC0gYW4gYXJyYXkgZWxlbWVudCB3YXMgY2hhbmdlZCwgc28gZGVzZWxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIGl0ZW0gZm9yIHRoYXQgaW5kZXggaWYgaXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWRcbiAgICAgICAgbGV0IHBhcnQgPSBwYXRoLnNsaWNlKCdpdGVtcy4nLmxlbmd0aCk7XG4gICAgICAgIGxldCBpZHggPSBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgICAgIGlmICgocGFydC5pbmRleE9mKCcuJykgPCAwKSAmJiBwYXJ0ID09IGlkeCkge1xuICAgICAgICAgIHRoaXMuX19kZXNlbGVjdENoYW5nZWRJZHgoaWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9fYXBwbHlTcGxpY2VzKHNwbGljZXMpIHtcbiAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX19zZWxlY3RlZE1hcDtcbiAgICAgIC8vIEFkanVzdCBzZWxlY3RlZCBpbmRpY2VzIGFuZCBtYXJrIHJlbW92YWxzXG4gICAgICBmb3IgKGxldCBpPTA7IGk8c3BsaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcyA9IHNwbGljZXNbaV07XG4gICAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpZHggPCBzLmluZGV4KSB7XG4gICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICB9IGVsc2UgaWYgKGlkeCA+PSBzLmluZGV4ICsgcy5yZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gYWRqdXN0IGluZGV4XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgaWR4ICsgcy5hZGRlZENvdW50IC0gcy5yZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpbmRleFxuICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KGl0ZW0sIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8cy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgICBsZXQgaWR4ID0gcy5pbmRleCArIGo7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkLmhhcyh0aGlzLml0ZW1zW2lkeF0pKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQodGhpcy5pdGVtc1tpZHhdLCBpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGxpbmtlZCBwYXRoc1xuICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgaXRlbXMgYXJyYXlcbiAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0ZWQuZGVsZXRlKGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpZHgrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX191cGRhdGVMaW5rcygpIHtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdpdGVtcy4nICsgaWR4LCAnc2VsZWN0ZWQuJyArIHNpZHgrKyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkJywgJ2l0ZW1zLicgKyBpZHgpO1xuICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZEl0ZW0nLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAvLyBVbmJpbmQgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0ge307XG4gICAgICAvLyBUaGUgc2VsZWN0ZWQgbWFwIHN0b3JlcyAzIHBpZWNlcyBvZiBpbmZvcm1hdGlvbjpcbiAgICAgIC8vIGtleTogaXRlbXMgYXJyYXkgb2JqZWN0XG4gICAgICAvLyB2YWx1ZTogaXRlbXMgYXJyYXkgaW5kZXhcbiAgICAgIC8vIG9yZGVyOiBzZWxlY3RlZCBhcnJheSBpbmRleFxuICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLm11bHRpID8gW10gOiBudWxsO1xuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2VsZWN0ZWRNYXAuaGFzKGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzSW5kZXhTZWxlY3RlZChpZHgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU2VsZWN0ZWQodGhpcy5pdGVtc1tpZHhdKTtcbiAgICB9XG5cbiAgICBfX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpIHtcbiAgICAgIGxldCBzaWR4ID0gdGhpcy5fX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KTtcbiAgICAgIGlmIChzaWR4ID49IDApIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHNpZHggPT0gaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCkge1xuICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1snaXRlbXMuJyArIGlkeF07XG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNlbGVjdGVkLnNsaWNlKCdzZWxlY3RlZC4nLmxlbmd0aCksIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAqL1xuICAgIGRlc2VsZWN0KGl0ZW0pIHtcbiAgICAgIGxldCBpZHggPSB0aGlzLl9fc2VsZWN0ZWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5kZWxldGUoaXRlbSk7XG4gICAgICAgIGxldCBzaWR4O1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGluZGV4IGlmIGl0IGlzIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAqL1xuICAgIGRlc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICB0aGlzLmRlc2VsZWN0KHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbS4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdChpdGVtKSB7XG4gICAgICB0aGlzLnNlbGVjdEluZGV4KHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXguICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICogZGVzZWxlY3QgdGhlIGl0ZW0gaWYgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdEluZGV4KGlkeCkge1xuICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICBpZiAoIXRoaXMubXVsdGkpIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuc2V0KGl0ZW0sIGlkeCk7XG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMucHVzaCgnc2VsZWN0ZWQnLCBpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9nZ2xlKSB7XG4gICAgICAgIHRoaXMuZGVzZWxlY3RJbmRleChpZHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEFycmF5U2VsZWN0b3JNaXhpbjtcblxufSk7XG5cbmV4cG9ydCB7IEFycmF5U2VsZWN0b3JNaXhpbiB9O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAqL1xubGV0IGJhc2VBcnJheVNlbGVjdG9yID0gQXJyYXlTZWxlY3Rvck1peGluKEVsZW1lbnQpO1xuXG4vKipcbiAqIEVsZW1lbnQgaW1wbGVtZW50aW5nIHRoZSBgUG9seW1lci5BcnJheVNlbGVjdG9yYCBtaXhpbiwgd2hpY2ggcmVjb3Jkc1xuICogZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGEgbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGFcbiAqIGBzZWxlY3RlZGAgYXJyYXkgc3VjaCB0aGF0IHBhdGggY2hhbmdlcyB0byB0aGUgbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdClcbiAqIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZSBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtc1xuICogaW4gdGhlIHNlbGVjdGVkIGFycmF5IGFuZCB2aWNlLXZlcnNhLlxuICpcbiAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICogYHNlbGVjdChpdGVtKWAgYW5kIGBkZXNlbGVjdChpdGVtKWAgQVBJLCB1cGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHByb3BlcnR5XG4gKiB3aGljaCBtYXkgYmUgYm91bmQgdG8gb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLCBhbmQgYW55IGNoYW5nZXMgdG9cbiAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gKiBgaXRlbXNgIGFycmF5LiAgV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCBgc2VsZWN0ZWRgIGlzIGEgcHJvcGVydHlcbiAqIHJlcHJlc2VudGluZyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtLiAgV2hlbiBgbXVsdGlgIGlzIHRydWUsIGBzZWxlY3RlZGBcbiAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gKlxuICogICA8dGVtcGxhdGU+XG4gKlxuICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpZD1cImVtcGxveWVlTGlzdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiPlxuICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGJ1dHRvbiBvbi1jbGljaz1cInRvZ2dsZVNlbGVjdGlvblwiPlNlbGVjdDwvYnV0dG9uPlxuICogICAgIDwvdGVtcGxhdGU+XG4gKlxuICogICAgIDxhcnJheS1zZWxlY3RvciBpZD1cInNlbGVjdG9yXCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCIgc2VsZWN0ZWQ9XCJ7e3NlbGVjdGVkfX1cIiBtdWx0aSB0b2dnbGU+PC9hcnJheS1zZWxlY3Rvcj5cbiAqXG4gKiAgICAgPGRpdj4gU2VsZWN0ZWQgZW1wbG95ZWVzOiA8L2Rpdj5cbiAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e3NlbGVjdGVkfX1cIj5cbiAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgIDwvdGVtcGxhdGU+XG4gKlxuICogPC9kb20tbW9kdWxlPlxuICogYGBgXG4gKlxuICogYGBganNcbiAqIFBvbHltZXIoe1xuICogICBpczogJ2VtcGxveWVlLWxpc3QnLFxuICogICByZWFkeSgpIHtcbiAqICAgICB0aGlzLmVtcGxveWVlcyA9IFtcbiAqICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gKiAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAqICAgICAgICAgLi4uXG4gKiAgICAgXTtcbiAqICAgfSxcbiAqICAgdG9nZ2xlU2VsZWN0aW9uKGUpIHtcbiAqICAgICBsZXQgaXRlbSA9IHRoaXMuJC5lbXBsb3llZUxpc3QuaXRlbUZvckVsZW1lbnQoZS50YXJnZXQpO1xuICogICAgIHRoaXMuJC5zZWxlY3Rvci5zZWxlY3QoaXRlbSk7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBvbHltZXJcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyB7YmFzZUFycmF5U2VsZWN0b3J9XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuQXJyYXlTZWxlY3Rvck1peGluXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBsaW5rcyBwYXRocyBiZXR3ZWVuIGFuIGlucHV0IGBpdGVtc2AgYXJyYXkgYW5kXG4gKiAgIGFuIG91dHB1dCBgc2VsZWN0ZWRgIGl0ZW0gb3IgYXJyYXkgYmFzZWQgb24gY2FsbHMgdG8gaXRzIHNlbGVjdGlvbiBBUEkuXG4gKi9cbmNsYXNzIEFycmF5U2VsZWN0b3IgZXh0ZW5kcyBiYXNlQXJyYXlTZWxlY3RvciB7XG4gIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdhcnJheS1zZWxlY3Rvcic7IH1cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShBcnJheVNlbGVjdG9yLmlzLCBBcnJheVNlbGVjdG9yKTtcbmV4cG9ydCB7IEFycmF5U2VsZWN0b3IgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuanMiLCJpbXBvcnQgJy4uLy4uLy4uLy4uL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMnO1xuaW1wb3J0IHsgY3NzRnJvbU1vZHVsZXMgfSBmcm9tICcuLi91dGlscy9zdHlsZS1nYXRoZXIuanMnO1xuXG5jb25zdCBhdHRyID0gJ2luY2x1ZGUnO1xuXG5jb25zdCBDdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcblxuLyoqXG4gKiBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuIHRha2VcbiAqIGFkdmFudGFnZSBvZiBbc2hhZHkgRE9NXShodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWNzcykgc2hpbXNcbiAqIGZvciBzdHlsZSBlbmNhcHN1bGF0aW9uLCBjdXN0b20gcHJvcGVydGllcywgYW5kIGN1c3RvbSBtaXhpbnMuXG4gKlxuICogLSBEb2N1bWVudCBzdHlsZXMgZGVmaW5lZCBpbiBhIGA8Y3VzdG9tLXN0eWxlPmAgYXJlIHNoaW1tZWQgdG8gZW5zdXJlIHRoZXlcbiAqICAgZG8gbm90IGxlYWsgaW50byBsb2NhbCBET00gd2hlbiBydW5uaW5nIG9uIGJyb3dzZXJzIHdpdGhvdXQgbmF0aXZlXG4gKiAgIFNoYWRvdyBET00uXG4gKiAtIEN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBiZSBkZWZpbmVkIGluIGEgYDxjdXN0b20tc3R5bGU+YC4gVXNlIHRoZSBgaHRtbGAgc2VsZWN0b3JcbiAqICAgdG8gZGVmaW5lIGN1c3RvbSBwcm9wZXJ0aWVzIHRoYXQgYXBwbHkgdG8gYWxsIGN1c3RvbSBlbGVtZW50cy5cbiAqIC0gQ3VzdG9tIG1peGlucyBjYW4gYmUgZGVmaW5lZCBpbiBhIGA8Y3VzdG9tLXN0eWxlPmAsIGlmIHlvdSBpbXBvcnQgdGhlIG9wdGlvbmFsXG4gKiAgIFthcHBseSBzaGltXShodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWNzcyNhYm91dC1hcHBseXNoaW0pXG4gKiAgIChgc2hhZHljc3MvYXBwbHktc2hpbS5odG1sYCkuXG4gKlxuICogVG8gdXNlOlxuICpcbiAqIC0gSW1wb3J0IGBjdXN0b20tc3R5bGUuaHRtbGAuXG4gKiAtIFBsYWNlIGEgYDxjdXN0b20tc3R5bGU+YCBlbGVtZW50IGluIHRoZSBtYWluIGRvY3VtZW50LCB3cmFwcGluZyBhbiBpbmxpbmUgYDxzdHlsZT5gIHRhZyB0aGF0XG4gKiAgIGNvbnRhaW5zIHRoZSBDU1MgcnVsZXMgeW91IHdhbnQgdG8gc2hpbS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIDwhLS0gaW1wb3J0IGFwcGx5IHNoaW0tLW9ubHkgcmVxdWlyZWQgaWYgdXNpbmcgbWl4aW5zIC0tPlxuICogPGxpbmsgcmVsPVwiaW1wb3J0IGhyZWY9XCJib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbFwiPlxuICogPCEtLSBpbXBvcnQgY3VzdG9tLXN0eWxlIGVsZW1lbnQgLS0+XG4gKiA8bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbFwiPlxuICogLi4uXG4gKiA8Y3VzdG9tLXN0eWxlPlxuICogICA8c3R5bGU+XG4gKiAgICAgaHRtbCB7XG4gKiAgICAgICAtLWN1c3RvbS1jb2xvcjogYmx1ZTtcbiAqICAgICAgIC0tY3VzdG9tLW1peGluOiB7XG4gKiAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICogICAgICAgICBjb2xvcjogcmVkO1xuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgIDwvc3R5bGU+XG4gKiA8L2N1c3RvbS1zdHlsZT5cbiAqIGBgYFxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW5cbiAqICAgdGFrZSBhZHZhbnRhZ2Ugb2YgUG9seW1lcidzIHN0eWxlIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0aWVzIHNoaW1zLlxuICovXG5jbGFzcyBDdXN0b21TdHlsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgQ3VzdG9tU3R5bGVJbnRlcmZhY2UuYWRkQ3VzdG9tU3R5bGUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpZ2h0LURPTSBgPHN0eWxlPmAgY2hpbGQgdGhpcyBlbGVtZW50IHdyYXBzLiAgVXBvbiBmaXJzdFxuICAgKiBjYWxsIGFueSBzdHlsZSBtb2R1bGVzIHJlZmVyZW5jZWQgdmlhIHRoZSBgaW5jbHVkZWAgYXR0cmlidXRlIHdpbGwgYmVcbiAgICogY29uY2F0ZW5hdGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c3R5bGU+YC5cbiAgICpcbiAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH0gVGhpcyBlbGVtZW50J3MgbGlnaHQtRE9NIGA8c3R5bGU+YFxuICAgKi9cbiAgZ2V0U3R5bGUoKSB7XG4gICAgaWYgKHRoaXMuX3N0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xuICAgIGlmICghc3R5bGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIGNvbnN0IGluY2x1ZGUgPSBzdHlsZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSkgKyBzdHlsZS50ZXh0Q29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG59XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2N1c3RvbS1zdHlsZScsIEN1c3RvbVN0eWxlKTtcbmV4cG9ydCB7IEN1c3RvbVN0eWxlIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEN1c3RvbVN0eWxlSW50ZXJmYWNlIGZyb20gJy4uL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzJztcbmltcG9ydCB7Z2V0Q29tcHV0ZWRTdHlsZVZhbHVlLCB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzfSBmcm9tICcuLi9zcmMvY29tbW9uLXV0aWxzLmpzJztcbmltcG9ydCB7bmF0aXZlQ3NzVmFyaWFibGVzLCBuYXRpdmVTaGFkb3d9IGZyb20gJy4uL3NyYy9zdHlsZS1zZXR0aW5ncy5qcyc7XG5cbmNvbnN0IGN1c3RvbVN0eWxlSW50ZXJmYWNlID0gbmV3IEN1c3RvbVN0eWxlSW50ZXJmYWNlKCk7XG5cbmlmICghd2luZG93LlNoYWR5Q1NTKSB7XG4gIHdpbmRvdy5TaGFkeUNTUyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbGVtZW50RXh0ZW5kc1xuICAgICAqL1xuICAgIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUsIGVsZW1lbnRFeHRlbmRzKSB7fSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICAgIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHN0eWxlRWxlbWVudChlbGVtZW50KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgICBjdXN0b21TdHlsZUludGVyZmFjZS5wcm9jZXNzU3R5bGVzKCk7XG4gICAgICB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGRvY3VtZW50LmJvZHksIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgICB9LFxuICAgIG5hdGl2ZUNzczogbmF0aXZlQ3NzVmFyaWFibGVzLFxuICAgIG5hdGl2ZVNoYWRvdzogbmF0aXZlU2hhZG93XG4gIH1cbn1cblxud2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlID0gY3VzdG9tU3R5bGVJbnRlcmZhY2U7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzIiwiaW1wb3J0IHsgTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcblxubGV0IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcbihcbiAgLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXG4gIChmdW5jdGlvbigpIHtcbiAgbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZTtcbn0pKSgpO1xuXG5leHBvcnQgY29uc3QgTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0cnVlKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IE9wdGlvbmFsTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICogZm9yIHRoaXMgZWxlbWVudC4gIFdoZW4gdHJ1ZSwgT2JqZWN0cyBhbmQgQXJyYXlzIHdpbGwgc2tpcCBkaXJ0eVxuICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBtdXRhYmxlRGF0YTogQm9vbGVhblxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBza2lwIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZ1xuICAgKiBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgKlxuICAgKiBQdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGAgY2FjaGVcbiAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgKiBAdGhpcyB7dGhpc31cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGN1c3RvbS1zdHlsZT5cbiAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgaHRtbCB7XG5cbiAgICAgIC0tbGF5b3V0OiB7XG4gICAgICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1pbmxpbmU6IHtcbiAgICAgICAgZGlzcGxheTogLW1zLWlubGluZS1mbGV4Ym94O1xuICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWlubGluZS1mbGV4O1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWhvcml6b250YWw6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1ob3Jpem9udGFsLXJldmVyc2U6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC12ZXJ0aWNhbDoge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXZlcnRpY2FsLXJldmVyc2U6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC13cmFwOiB7XG4gICAgICAgIC1tcy1mbGV4LXdyYXA6IHdyYXA7XG4gICAgICAgIC13ZWJraXQtZmxleC13cmFwOiB3cmFwO1xuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC13cmFwLXJldmVyc2U6IHtcbiAgICAgICAgLW1zLWZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xuICAgICAgICAtd2Via2l0LWZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xuICAgICAgICBmbGV4LXdyYXA6IHdyYXAtcmV2ZXJzZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtYXV0bzoge1xuICAgICAgICAtbXMtZmxleDogMSAxIGF1dG87XG4gICAgICAgIC13ZWJraXQtZmxleDogMSAxIGF1dG87XG4gICAgICAgIGZsZXg6IDEgMSBhdXRvO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC1ub25lOiB7XG4gICAgICAgIC1tcy1mbGV4OiBub25lO1xuICAgICAgICAtd2Via2l0LWZsZXg6IG5vbmU7XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4OiB7XG4gICAgICAgIC1tcy1mbGV4OiAxIDEgMC4wMDAwMDAwMDFweDtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICAtd2Via2l0LWZsZXgtYmFzaXM6IDAuMDAwMDAwMDAxcHg7XG4gICAgICAgIGZsZXgtYmFzaXM6IDAuMDAwMDAwMDAxcHg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTI6IHtcbiAgICAgICAgLW1zLWZsZXg6IDI7XG4gICAgICAgIC13ZWJraXQtZmxleDogMjtcbiAgICAgICAgZmxleDogMjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMzoge1xuICAgICAgICAtbXMtZmxleDogMztcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAzO1xuICAgICAgICBmbGV4OiAzO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC00OiB7XG4gICAgICAgIC1tcy1mbGV4OiA0O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDQ7XG4gICAgICAgIGZsZXg6IDQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTU6IHtcbiAgICAgICAgLW1zLWZsZXg6IDU7XG4gICAgICAgIC13ZWJraXQtZmxleDogNTtcbiAgICAgICAgZmxleDogNTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNjoge1xuICAgICAgICAtbXMtZmxleDogNjtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA2O1xuICAgICAgICBmbGV4OiA2O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC03OiB7XG4gICAgICAgIC1tcy1mbGV4OiA3O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDc7XG4gICAgICAgIGZsZXg6IDc7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTg6IHtcbiAgICAgICAgLW1zLWZsZXg6IDg7XG4gICAgICAgIC13ZWJraXQtZmxleDogODtcbiAgICAgICAgZmxleDogODtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtOToge1xuICAgICAgICAtbXMtZmxleDogOTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA5O1xuICAgICAgICBmbGV4OiA5O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0xMDoge1xuICAgICAgICAtbXMtZmxleDogMTA7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTA7XG4gICAgICAgIGZsZXg6IDEwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0xMToge1xuICAgICAgICAtbXMtZmxleDogMTE7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTE7XG4gICAgICAgIGZsZXg6IDExO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0xMjoge1xuICAgICAgICAtbXMtZmxleDogMTI7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTI7XG4gICAgICAgIGZsZXg6IDEyO1xuICAgICAgfTtcblxuICAgICAgLyogYWxpZ25tZW50IGluIGNyb3NzIGF4aXMgKi9cblxuICAgICAgLS1sYXlvdXQtc3RhcnQ6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IHN0YXJ0O1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlcjoge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1lbmQ6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGVuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWJhc2VsaW5lOiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBiYXNlbGluZTtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogYmFzZWxpbmU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcbiAgICAgIH07XG5cbiAgICAgIC8qIGFsaWdubWVudCBpbiBtYWluIGF4aXMgKi9cblxuICAgICAgLS1sYXlvdXQtc3RhcnQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IHN0YXJ0O1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZW5kLWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBlbmQ7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWFyb3VuZC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogZGlzdHJpYnV0ZTtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazoganVzdGlmeTtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlci1jZW50ZXI6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ7XG4gICAgICB9O1xuXG4gICAgICAvKiBzZWxmIGFsaWdubWVudCAqL1xuXG4gICAgICAtLWxheW91dC1zZWxmLXN0YXJ0OiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLWNlbnRlcjoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24tc2VsZjogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1lbmQ6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtc3RyZXRjaDoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1iYXNlbGluZToge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogYmFzZWxpbmU7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogYmFzZWxpbmU7XG4gICAgICAgIGFsaWduLXNlbGY6IGJhc2VsaW5lO1xuICAgICAgfTtcblxuICAgICAgLyogbXVsdGktbGluZSBhbGlnbm1lbnQgaW4gbWFpbiBheGlzICovXG5cbiAgICAgIC0tbGF5b3V0LXN0YXJ0LWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBzdGFydDsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWVuZC1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogZW5kOyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogZmxleC1lbmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogZmxleC1lbmQ7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBjZW50ZXI7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1iZXR3ZWVuLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBqdXN0aWZ5OyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYXJvdW5kLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBkaXN0cmlidXRlOyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgfTtcblxuICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAgICBPdGhlciBMYXlvdXRcbiAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIC0tbGF5b3V0LWJsb2NrOiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaW52aXNpYmxlOiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtcmVsYXRpdmU6IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml0OiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2Nyb2xsOiB7XG4gICAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mdWxsYmxlZWQ6IHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgfTtcblxuICAgICAgLyogZml4ZWQgcG9zaXRpb24gKi9cblxuICAgICAgLS1sYXlvdXQtZml4ZWQtdG9wOiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLXJpZ2h0OiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml4ZWQtYm90dG9tOiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLWxlZnQ6IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH07XG5cbiAgICB9XG4gIDwvc3R5bGU+XG48L2N1c3RvbS1zdHlsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4vY29sb3IuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuICAgICAgLypcbiAgICAgICAqIFlvdSBjYW4gdXNlIHRoZXNlIGdlbmVyaWMgdmFyaWFibGVzIGluIHlvdXIgZWxlbWVudHMgZm9yIGVhc3kgdGhlbWluZy5cbiAgICAgICAqIEZvciBleGFtcGxlLCBpZiBhbGwgeW91ciBlbGVtZW50cyB1c2UgXFxgLS1wcmltYXJ5LXRleHQtY29sb3JcXGAgYXMgaXRzIG1haW5cbiAgICAgICAqIGNvbG9yLCB0aGVuIHN3aXRjaGluZyBmcm9tIGEgbGlnaHQgdG8gYSBkYXJrIHRoZW1lIGlzIGp1c3QgYSBtYXR0ZXIgb2ZcbiAgICAgICAqIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiBcXGAtLXByaW1hcnktdGV4dC1jb2xvclxcYCBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAgICovXG4gICAgICAtLXByaW1hcnktdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcik7XG4gICAgICAtLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcik7XG4gICAgICAtLXNlY29uZGFyeS10ZXh0LWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3IpO1xuICAgICAgLS1kaXNhYmxlZC10ZXh0LWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1kaXNhYmxlZC1jb2xvcik7XG4gICAgICAtLWRpdmlkZXItY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3IpO1xuICAgICAgLS1lcnJvci1jb2xvcjogdmFyKC0tcGFwZXItZGVlcC1vcmFuZ2UtYTcwMCk7XG5cbiAgICAgIC8qXG4gICAgICAgKiBQcmltYXJ5IGFuZCBhY2NlbnQgY29sb3JzLiBBbHNvIHNlZSBjb2xvci5odG1sIGZvciBtb3JlIGNvbG9ycy5cbiAgICAgICAqL1xuICAgICAgLS1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wYXBlci1pbmRpZ28tNTAwKTtcbiAgICAgIC0tbGlnaHQtcHJpbWFyeS1jb2xvcjogdmFyKC0tcGFwZXItaW5kaWdvLTEwMCk7XG4gICAgICAtLWRhcmstcHJpbWFyeS1jb2xvcjogdmFyKC0tcGFwZXItaW5kaWdvLTcwMCk7XG5cbiAgICAgIC0tYWNjZW50LWNvbG9yOiB2YXIoLS1wYXBlci1waW5rLWEyMDApO1xuICAgICAgLS1saWdodC1hY2NlbnQtY29sb3I6IHZhcigtLXBhcGVyLXBpbmstYTEwMCk7XG4gICAgICAtLWRhcmstYWNjZW50LWNvbG9yOiB2YXIoLS1wYXBlci1waW5rLWE0MDApO1xuXG5cbiAgICAgIC8qXG4gICAgICAgKiBNYXRlcmlhbCBEZXNpZ24gTGlnaHQgYmFja2dyb3VuZCB0aGVtZVxuICAgICAgICovXG4gICAgICAtLWxpZ2h0LXRoZW1lLWJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XG4gICAgICAtLWxpZ2h0LXRoZW1lLWJhc2UtY29sb3I6ICMwMDAwMDA7XG4gICAgICAtLWxpZ2h0LXRoZW1lLXRleHQtY29sb3I6IHZhcigtLXBhcGVyLWdyZXktOTAwKTtcbiAgICAgIC0tbGlnaHQtdGhlbWUtc2Vjb25kYXJ5LWNvbG9yOiAjNzM3MzczOyAgLyogZm9yIHNlY29uZGFyeSB0ZXh0IGFuZCBpY29ucyAqL1xuICAgICAgLS1saWdodC10aGVtZS1kaXNhYmxlZC1jb2xvcjogIzliOWI5YjsgIC8qIGRpc2FibGVkL2hpbnQgdGV4dCAqL1xuICAgICAgLS1saWdodC10aGVtZS1kaXZpZGVyLWNvbG9yOiAjZGJkYmRiO1xuXG4gICAgICAvKlxuICAgICAgICogTWF0ZXJpYWwgRGVzaWduIERhcmsgYmFja2dyb3VuZCB0aGVtZVxuICAgICAgICovXG4gICAgICAtLWRhcmstdGhlbWUtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItZ3JleS05MDApO1xuICAgICAgLS1kYXJrLXRoZW1lLWJhc2UtY29sb3I6ICNmZmZmZmY7XG4gICAgICAtLWRhcmstdGhlbWUtdGV4dC1jb2xvcjogI2ZmZmZmZjtcbiAgICAgIC0tZGFyay10aGVtZS1zZWNvbmRhcnktY29sb3I6ICNiY2JjYmM7ICAvKiBmb3Igc2Vjb25kYXJ5IHRleHQgYW5kIGljb25zICovXG4gICAgICAtLWRhcmstdGhlbWUtZGlzYWJsZWQtY29sb3I6ICM2NDY0NjQ7ICAvKiBkaXNhYmxlZC9oaW50IHRleHQgKi9cbiAgICAgIC0tZGFyay10aGVtZS1kaXZpZGVyLWNvbG9yOiAjM2MzYzNjO1xuXG4gICAgICAvKlxuICAgICAgICogRGVwcmVjYXRlZCB2YWx1ZXMgYmVjYXVzZSBvZiB0aGVpciBjb25mdXNpbmcgbmFtZXMuXG4gICAgICAgKi9cbiAgICAgIC0tdGV4dC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1kYXJrLXRoZW1lLXRleHQtY29sb3IpO1xuICAgICAgLS1kZWZhdWx0LXByaW1hcnktY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IpO1xuICAgIH1cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsLCBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yL2lyb24tY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBhcGVySW5reUZvY3VzQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwgPSB7XG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgdGhlIGVsZW1lbnQncyBjaGVja2VkIHN0YXRlIHdpdGggaXRzIHJpcHBsZSBlZmZlY3QuXG4gICAqL1xuICBfY2hlY2tlZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbC5fY2hlY2tlZENoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tlZCkge1xuICAgICAgICB0aGlzLl9yaXBwbGUuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3luY2hyb25pemVzIHRoZSBlbGVtZW50J3MgYGFjdGl2ZWAgYW5kIGBjaGVja2VkYCBzdGF0ZS5cbiAgICovXG4gIF9idXR0b25TdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIFBhcGVyUmlwcGxlQmVoYXZpb3IuX2J1dHRvblN0YXRlQ2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9IHRoaXMuYWN0aXZlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IFtcbiAgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvcixcbiAgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IsXG4gIFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uVmFsaWRhdGFibGVCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uRm9ybUVsZW1lbnRCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQGV2ZW50IGlyb24tY2hhbmdlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHN0YXRlLCBgdHJ1ZWAgaXMgY2hlY2tlZCBhbmQgYGZhbHNlYCBpcyB1bmNoZWNrZWQuXG4gICAgICovXG4gICAgY2hlY2tlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX2NoZWNrZWRDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSB3aXRoIGVhY2ggdGFwIG9yIHByZXNzXG4gICAgICogb2YgdGhlIHNwYWNlYmFyLlxuICAgICAqL1xuICAgIHRvZ2dsZXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKiBPdmVycmlkZW4gZnJvbSBQb2x5bWVyLklyb25Gb3JtRWxlbWVudEJlaGF2aW9yICovXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnb24nLFxuICAgICAgb2JzZXJ2ZXI6ICdfdmFsdWVDaGFuZ2VkJ1xuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX3JlcXVpcmVkQ2hhbmdlZChyZXF1aXJlZCknXG4gIF0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gVXNlZCBieSBgaXJvbi1mb3JtYCB0byBoYW5kbGUgdGhlIGNhc2UgdGhhdCBhbiBlbGVtZW50IHdpdGggdGhpcyBiZWhhdmlvclxuICAgIC8vIGRvZXNuJ3QgaGF2ZSBhIHJvbGUgb2YgJ2NoZWNrYm94JyBvciAncmFkaW8nLCBidXQgc2hvdWxkIHN0aWxsIG9ubHkgYmVcbiAgICAvLyBpbmNsdWRlZCB3aGVuIHRoZSBmb3JtIGlzIHNlcmlhbGl6ZWQgaWYgYHRoaXMuY2hlY2tlZCA9PT0gdHJ1ZWAuXG4gICAgdGhpcy5faGFzSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBlbGVtZW50IGlzIHJlcXVpcmVkIGFuZCBub3QgY2hlY2tlZCwgYW5kIHRydWUgb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0geyo9fSBfdmFsdWUgSWdub3JlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBgcmVxdWlyZWRgIGlzIGZhbHNlIG9yIGlmIGBjaGVja2VkYCBpcyB0cnVlLlxuICAgKi9cbiAgX2dldFZhbGlkaXR5OiBmdW5jdGlvbihfdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCB8fCAhdGhpcy5yZXF1aXJlZCB8fCB0aGlzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXJpYS1yZXF1aXJlZCBsYWJlbCB3aGVuIGByZXF1aXJlZGAgaXMgY2hhbmdlZC5cbiAgICovXG4gIF9yZXF1aXJlZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlcXVpcmVkKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1yZXF1aXJlZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXJlcXVpcmVkJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGaXJlIGBpcm9uLWNoYW5nZWRgIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcy5cbiAgICovXG4gIF9jaGVja2VkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hY3RpdmUgPSB0aGlzLmNoZWNrZWQ7XG4gICAgdGhpcy5maXJlKCdpcm9uLWNoYW5nZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldCB2YWx1ZSB0byAnb24nIGlmIGl0IGlzIHNldCB0byBgdW5kZWZpbmVkYC5cbiAgICovXG4gIF92YWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgdGhpcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy52YWx1ZSA9ICdvbic7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IgPSBbXG4gIElyb25Gb3JtRWxlbWVudEJlaGF2aW9yLFxuICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvcixcbiAgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25NZXRhIH0gZnJvbSAnLi4vaXJvbi1tZXRhL2lyb24tbWV0YS5qcyc7XG5leHBvcnQgbGV0IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSA9IG51bGw7XG5cbmV4cG9ydCBjb25zdCBJcm9uVmFsaWRhdGFibGVCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgdmFsaWRhdG9yIHRvIHVzZS5cbiAgICAgKi9cbiAgICB2YWxpZGF0b3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBsYXN0IGNhbGwgdG8gYHZhbGlkYXRlYCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIGludmFsaWQ6IHtcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBvYnNlcnZlcjogJ19pbnZhbGlkQ2hhbmdlZCdcbiAgICB9LFxuICB9LFxuXG4gIHJlZ2lzdGVyZWQ6IGZ1bmN0aW9uKCkge1xuICAgIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSA9IG5ldyBJcm9uTWV0YSh7dHlwZTogJ3ZhbGlkYXRvcid9KTtcbiAgfSxcblxuICBfaW52YWxpZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qIFJlY29tcHV0ZSB0aGlzIGV2ZXJ5IHRpbWUgaXQncyBuZWVkZWQsIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBpZiB0aGVcbiAgICogdW5kZXJseWluZyBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEgaGFzIGNoYW5nZWQuICovXG4gIGdldCBfdmFsaWRhdG9yKCkge1xuICAgIHJldHVybiBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEgJiZcbiAgICAgICAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhLmJ5S2V5KHRoaXMudmFsaWRhdG9yKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsaWRhdG9yIGB2YWxpZGF0b3JgIGV4aXN0cy5cbiAgICovXG4gIGhhc1ZhbGlkYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvciAhPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQsIGFuZCB1cGRhdGVzIGBpbnZhbGlkYC4gSWYgeW91IHdhbnRcbiAgICogeW91ciBlbGVtZW50IHRvIGhhdmUgY3VzdG9tIHZhbGlkYXRpb24gbG9naWMsIGRvIG5vdCBvdmVycmlkZSB0aGlzIG1ldGhvZDtcbiAgICogb3ZlcnJpZGUgYF9nZXRWYWxpZGl0eSh2YWx1ZSlgIGluc3RlYWQuXG5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIERlcHJlY2F0ZWQ6IFRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQuIEJ5IGRlZmF1bHQsXG4gICAqIGl0IGlzIHBhc3NlZCB0byB0aGUgdmFsaWRhdG9yJ3MgYHZhbGlkYXRlKClgIGZ1bmN0aW9uLCBpZiBhIHZhbGlkYXRvciBpcyBzZXQuXG4gICAqIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZCwgdGhlbiB0aGUgZWxlbWVudCdzIGB2YWx1ZWAgcHJvcGVydHlcbiAgICogaXMgdXNlZCwgaWYgaXQgZXhpc3RzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuXG4gICAqL1xuICB2YWxpZGF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGFuIGVsZW1lbnQgdGhhdCBhbHNvIGhhcyBhIHZhbHVlIHByb3BlcnR5LCBhbmQgdGhlcmUgd2FzXG4gICAgLy8gbm8gZXhwbGljaXQgdmFsdWUgYXJndW1lbnQgcGFzc2VkLCB1c2UgdGhlIGVsZW1lbnQncyBwcm9wZXJ0eSBpbnN0ZWFkLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMuaW52YWxpZCA9ICF0aGlzLl9nZXRWYWxpZGl0eSh0aGlzLnZhbHVlKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLmludmFsaWQgPSAhdGhpcy5fZ2V0VmFsaWRpdHkodmFsdWUpO1xuICAgIHJldHVybiAhdGhpcy5pbnZhbGlkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC4gIEJ5IGRlZmF1bHQsIGl0IGlzIHBhc3NlZFxuICAgKiB0byB0aGUgdmFsaWRhdG9yJ3MgYHZhbGlkYXRlKClgIGZ1bmN0aW9uLCBpZiBhIHZhbGlkYXRvciBpcyBzZXQuIFlvdVxuICAgKiBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91IHdhbnQgdG8gaW1wbGVtZW50IGN1c3RvbSB2YWxpZGl0eVxuICAgKiBsb2dpYyBmb3IgeW91ciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHZhbGlkYXRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLlxuICAgKi9cblxuICBfZ2V0VmFsaWRpdHk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaGFzVmFsaWRhdG9yKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IudmFsaWRhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgUG9seW1lciBhcyBQb2x5bWVyJDAgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3t0eXBlOiAoc3RyaW5nfG51bGwpLCBrZXk6IChzdHJpbmd8bnVsbCksIHZhbHVlOiAqfX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBJcm9uTWV0YShvcHRpb25zKSB7XG4gIHRoaXMudHlwZSA9IChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgfHwgJ2RlZmF1bHQnO1xuICB0aGlzLmtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXk7XG4gIGlmICgndmFsdWUnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgfVxufVxuXG5Jcm9uTWV0YS50eXBlcyA9IHt9O1xuXG5Jcm9uTWV0YS5wcm90b3R5cGUgPSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgIHJldHVybiBJcm9uTWV0YS50eXBlc1t0eXBlXSAmJiBJcm9uTWV0YS50eXBlc1t0eXBlXVtrZXldO1xuICAgIH1cbiAgfSxcblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgIHR5cGUgPSBJcm9uTWV0YS50eXBlc1t0eXBlXSA9IElyb25NZXRhLnR5cGVzW3R5cGVdIHx8IHt9O1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHR5cGVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXQgbGlzdCgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoSXJvbk1ldGEudHlwZXNbdGhpcy50eXBlXSkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gbWV0YURhdGFzW3RoaXMudHlwZV1ba2V5XTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICBieUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG5cbmV4cG9ydCB7IElyb25NZXRhIH07XG5cbnZhciBtZXRhRGF0YXMgPSBJcm9uTWV0YS50eXBlcztcblxuUG9seW1lciQwKHtcblxuICBpczogJ2lyb24tbWV0YScsXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbWV0YS1kYXRhLiAgQWxsIG1ldGEtZGF0YSBvZiB0aGUgc2FtZSB0eXBlIGlzIHN0b3JlZFxuICAgICAqIHRvZ2V0aGVyLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdkZWZhdWx0JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGtleSB1c2VkIHRvIHN0b3JlIGB2YWx1ZWAgdW5kZXIgdGhlIGB0eXBlYCBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAga2V5OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRhLWRhdGEgdG8gc3RvcmUgb3IgcmV0cmlldmUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgYHZhbHVlYCBpcyBzZXQgdG8gdGhlIGlyb24tbWV0YSBpbnN0YW5jZSBpdHNlbGYuXG4gICAgICovXG4gICAgIHNlbGY6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBvYnNlcnZlcjogJ19zZWxmQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgX19tZXRhOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVNZXRhKHR5cGUsIGtleSwgdmFsdWUpJ1xuICAgIH1cbiAgfSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIGhpZGRlbjogdHJ1ZVxuICB9LFxuXG4gIF9fY29tcHV0ZU1ldGE6IGZ1bmN0aW9uKHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgbWV0YSA9IG5ldyBJcm9uTWV0YSh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAga2V5OiBrZXlcbiAgICB9KTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICBtZXRhLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gbWV0YS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfSxcblxuICBnZXQgbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX21ldGEgJiYgdGhpcy5fX21ldGEubGlzdDtcbiAgfSxcblxuICBfc2VsZkNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICBpZiAoc2VsZikge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbWV0YSBkYXRhIHZhbHVlIGJ5IGtleS5cbiAgICpcbiAgICogQG1ldGhvZCBieUtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGEtZGF0YSB0byBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gbmV3IElyb25NZXRhKHtcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGtleToga2V5XG4gICAgfSkudmFsdWU7XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25Gb3JtRWxlbWVudEJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGFkZGVkIHRvIGFuIGBpcm9uLWZvcm1gLlxuICAgICAqXG4gICAgICogQGV2ZW50IGlyb24tZm9ybS1lbGVtZW50LXJlZ2lzdGVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSBhbiBgaXJvbi1mb3JtYC5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWZvcm0tZWxlbWVudC11bnJlZ2lzdGVyXG4gICAgICovXG4gICAgIFxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgdmFsdWU6IHtcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBtYXJrIHRoZSBpbnB1dCBhcyByZXF1aXJlZC4gSWYgdXNlZCBpbiBhIGZvcm0sIGFcbiAgICAgKiBjdXN0b20gZWxlbWVudCB0aGF0IHVzZXMgdGhpcyBiZWhhdmlvciBzaG91bGQgYWxzbyB1c2VcbiAgICAgKiBQb2x5bWVyLklyb25WYWxpZGF0YWJsZUJlaGF2aW9yIGFuZCBkZWZpbmUgYSBjdXN0b20gdmFsaWRhdGlvbiBtZXRob2QuXG4gICAgICogT3RoZXJ3aXNlLCBhIGByZXF1aXJlZGAgZWxlbWVudCB3aWxsIGFsd2F5cyBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICAgICAqIEl0J3MgYWxzbyBzdHJvbmdseSByZWNvbW1lbmRlZCB0byBwcm92aWRlIGEgdmlzdWFsIHN0eWxlIGZvciB0aGUgZWxlbWVudFxuICAgICAqIHdoZW4gaXRzIHZhbHVlIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm0gdGhhdCB0aGUgZWxlbWVudCBpcyByZWdpc3RlcmVkIHRvLlxuICAgICAqL1xuICAgIF9wYXJlbnRGb3JtOiB7XG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IEVsZW1lbnQgPyBudWxsIDogZnVuY3Rpb24oKSB7XG4gICAgLy8gTm90ZTogdGhlIGlyb24tZm9ybSB0aGF0IHRoaXMgZWxlbWVudCBiZWxvbmdzIHRvIHdpbGwgc2V0IHRoaXNcbiAgICAvLyBlbGVtZW50J3MgX3BhcmVudEZvcm0gcHJvcGVydHkgd2hlbiBoYW5kbGluZyB0aGlzIGV2ZW50LlxuICAgIHRoaXMuZmlyZSgnaXJvbi1mb3JtLWVsZW1lbnQtcmVnaXN0ZXInKTtcbiAgfSxcblxuICBkZXRhY2hlZDogRWxlbWVudCA/IG51bGwgOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50Rm9ybSkge1xuICAgICAgdGhpcy5fcGFyZW50Rm9ybS5maXJlKCdpcm9uLWZvcm0tZWxlbWVudC11bnJlZ2lzdGVyJywge3RhcmdldDogdGhpc30pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25CdXR0b25TdGF0ZSB9IGZyb20gJy4uL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmpzJztcbmltcG9ydCB7IFBhcGVyUmlwcGxlQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uQ29udHJvbFN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsID0ge1xuICBvYnNlcnZlcnM6IFtcbiAgICAnX2ZvY3VzZWRDaGFuZ2VkKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpJ1xuICBdLFxuXG4gIF9mb2N1c2VkQ2hhbmdlZDogZnVuY3Rpb24ocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgIGlmIChyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgdGhpcy5fcmlwcGxlLmhvbGREb3duID0gcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpcHBsZSA9IFBhcGVyUmlwcGxlQmVoYXZpb3IuX2NyZWF0ZVJpcHBsZSgpO1xuICAgIHJpcHBsZS5pZCA9ICdpbmsnO1xuICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NlbnRlcicsICcnKTtcbiAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnY2lyY2xlJyk7XG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IFBhcGVySW5reUZvY3VzQmVoYXZpb3IgPSBbXG4gIElyb25CdXR0b25TdGF0ZSxcbiAgSXJvbkNvbnRyb2xTdGF0ZSxcbiAgUGFwZXJSaXBwbGVCZWhhdmlvcixcbiAgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkExMXlLZXlzQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblxudmFyIFV0aWxpdHkgPSB7XG4gIGRpc3RhbmNlOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciB4RGVsdGEgPSAoeDEgLSB4Mik7XG4gICAgdmFyIHlEZWx0YSA9ICh5MSAtIHkyKTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoeERlbHRhICogeERlbHRhICsgeURlbHRhICogeURlbHRhKTtcbiAgfSxcblxuICBub3c6IHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID9cbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh3aW5kb3cucGVyZm9ybWFuY2UpIDogRGF0ZS5ub3dcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEVsZW1lbnRNZXRyaWNzKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy53aWR0aCA9IHRoaXMuYm91bmRpbmdSZWN0LndpZHRoO1xuICB0aGlzLmhlaWdodCA9IHRoaXMuYm91bmRpbmdSZWN0LmhlaWdodDtcblxuICB0aGlzLnNpemUgPSBNYXRoLm1heCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59XG5cbkVsZW1lbnRNZXRyaWNzLnByb3RvdHlwZSA9IHtcbiAgZ2V0IGJvdW5kaW5nUmVjdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSxcblxuICBmdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0b3BMZWZ0ID0gVXRpbGl0eS5kaXN0YW5jZSh4LCB5LCAwLCAwKTtcbiAgICB2YXIgdG9wUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIDApO1xuICAgIHZhciBib3R0b21MZWZ0ID0gVXRpbGl0eS5kaXN0YW5jZSh4LCB5LCAwLCB0aGlzLmhlaWdodCk7XG4gICAgdmFyIGJvdHRvbVJpZ2h0ID0gVXRpbGl0eS5kaXN0YW5jZSh4LCB5LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmlwcGxlKGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5jb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmNvbG9yO1xuXG4gIHRoaXMud2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLndhdmVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy53YXZlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3I7XG4gIHRoaXMud2F2ZS5jbGFzc0xpc3QuYWRkKCd3YXZlJyk7XG4gIHRoaXMud2F2ZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCd3YXZlLWNvbnRhaW5lcicpO1xuICBkb20odGhpcy53YXZlQ29udGFpbmVyKS5hcHBlbmRDaGlsZCh0aGlzLndhdmUpO1xuXG4gIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG59XG5cblJpcHBsZS5NQVhfUkFESVVTID0gMzAwO1xuXG5SaXBwbGUucHJvdG90eXBlID0ge1xuICBnZXQgcmVjZW50ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQucmVjZW50ZXJzO1xuICB9LFxuXG4gIGdldCBjZW50ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jZW50ZXI7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlRG93bkVsYXBzZWQoKSB7XG4gICAgdmFyIGVsYXBzZWQ7XG5cbiAgICBpZiAoIXRoaXMubW91c2VEb3duU3RhcnQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGVsYXBzZWQgPSBVdGlsaXR5Lm5vdygpIC0gdGhpcy5tb3VzZURvd25TdGFydDtcblxuICAgIGlmICh0aGlzLm1vdXNlVXBTdGFydCkge1xuICAgICAgZWxhcHNlZCAtPSB0aGlzLm1vdXNlVXBFbGFwc2VkO1xuICAgIH1cblxuICAgIHJldHVybiBlbGFwc2VkO1xuICB9LFxuXG4gIGdldCBtb3VzZVVwRWxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZVVwU3RhcnQgP1xuICAgICAgVXRpbGl0eS5ub3cgKCkgLSB0aGlzLm1vdXNlVXBTdGFydCA6IDA7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlRG93bkVsYXBzZWRTZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkVsYXBzZWQgLyAxMDAwO1xuICB9LFxuXG4gIGdldCBtb3VzZVVwRWxhcHNlZFNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VVcEVsYXBzZWQgLyAxMDAwO1xuICB9LFxuXG4gIGdldCBtb3VzZUludGVyYWN0aW9uU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZURvd25FbGFwc2VkU2Vjb25kcyArIHRoaXMubW91c2VVcEVsYXBzZWRTZWNvbmRzO1xuICB9LFxuXG4gIGdldCBpbml0aWFsT3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmluaXRpYWxPcGFjaXR5O1xuICB9LFxuXG4gIGdldCBvcGFjaXR5RGVjYXlWZWxvY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm9wYWNpdHlEZWNheVZlbG9jaXR5O1xuICB9LFxuXG4gIGdldCByYWRpdXMoKSB7XG4gICAgdmFyIHdpZHRoMiA9IHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAqIHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0MiA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgKiB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0O1xuICAgIHZhciB3YXZlUmFkaXVzID0gTWF0aC5taW4oXG4gICAgICBNYXRoLnNxcnQod2lkdGgyICsgaGVpZ2h0MiksXG4gICAgICBSaXBwbGUuTUFYX1JBRElVU1xuICAgICkgKiAxLjEgKyA1O1xuXG4gICAgdmFyIGR1cmF0aW9uID0gMS4xIC0gMC4yICogKHdhdmVSYWRpdXMgLyBSaXBwbGUuTUFYX1JBRElVUyk7XG4gICAgdmFyIHRpbWVOb3cgPSB0aGlzLm1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzIC8gZHVyYXRpb247XG4gICAgdmFyIHNpemUgPSB3YXZlUmFkaXVzICogKDEgLSBNYXRoLnBvdyg4MCwgLXRpbWVOb3cpKTtcblxuICAgIHJldHVybiBNYXRoLmFicyhzaXplKTtcbiAgfSxcblxuICBnZXQgb3BhY2l0eSgpIHtcbiAgICBpZiAoIXRoaXMubW91c2VVcFN0YXJ0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsT3BhY2l0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgdGhpcy5pbml0aWFsT3BhY2l0eSAtIHRoaXMubW91c2VVcEVsYXBzZWRTZWNvbmRzICogdGhpcy5vcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICk7XG4gIH0sXG5cbiAgZ2V0IG91dGVyT3BhY2l0eSgpIHtcbiAgICAvLyBMaW5lYXIgaW5jcmVhc2UgaW4gYmFja2dyb3VuZCBvcGFjaXR5LCBjYXBwZWQgYXQgdGhlIG9wYWNpdHlcbiAgICAvLyBvZiB0aGUgd2F2ZWZyb250ICh3YXZlT3BhY2l0eSkuXG4gICAgdmFyIG91dGVyT3BhY2l0eSA9IHRoaXMubW91c2VVcEVsYXBzZWRTZWNvbmRzICogMC4zO1xuICAgIHZhciB3YXZlT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihvdXRlck9wYWNpdHksIHdhdmVPcGFjaXR5KVxuICAgICk7XG4gIH0sXG5cbiAgZ2V0IGlzT3BhY2l0eUZ1bGx5RGVjYXllZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5IDwgMC4wMSAmJlxuICAgICAgdGhpcy5yYWRpdXMgPj0gTWF0aC5taW4odGhpcy5tYXhSYWRpdXMsIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgfSxcblxuICBnZXQgaXNSZXN0aW5nQXRNYXhSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eSA+PSB0aGlzLmluaXRpYWxPcGFjaXR5ICYmXG4gICAgICB0aGlzLnJhZGl1cyA+PSBNYXRoLm1pbih0aGlzLm1heFJhZGl1cywgUmlwcGxlLk1BWF9SQURJVVMpO1xuICB9LFxuXG4gIGdldCBpc0FuaW1hdGlvbkNvbXBsZXRlKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlVXBTdGFydCA/XG4gICAgICB0aGlzLmlzT3BhY2l0eUZ1bGx5RGVjYXllZCA6IHRoaXMuaXNSZXN0aW5nQXRNYXhSYWRpdXM7XG4gIH0sXG5cbiAgZ2V0IHRyYW5zbGF0aW9uRnJhY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKFxuICAgICAgMSxcbiAgICAgIHRoaXMucmFkaXVzIC8gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKiAyIC8gTWF0aC5zcXJ0KDIpXG4gICAgKTtcbiAgfSxcblxuICBnZXQgeE5vdygpIHtcbiAgICBpZiAodGhpcy54RW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy54U3RhcnQgKyB0aGlzLnRyYW5zbGF0aW9uRnJhY3Rpb24gKiAodGhpcy54RW5kIC0gdGhpcy54U3RhcnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnhTdGFydDtcbiAgfSxcblxuICBnZXQgeU5vdygpIHtcbiAgICBpZiAodGhpcy55RW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy55U3RhcnQgKyB0aGlzLnRyYW5zbGF0aW9uRnJhY3Rpb24gKiAodGhpcy55RW5kIC0gdGhpcy55U3RhcnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnlTdGFydDtcbiAgfSxcblxuICBnZXQgaXNNb3VzZURvd24oKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duU3RhcnQgJiYgIXRoaXMubW91c2VVcFN0YXJ0O1xuICB9LFxuXG4gIHJlc2V0SW50ZXJhY3Rpb25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tYXhSYWRpdXMgPSAwO1xuICAgIHRoaXMubW91c2VEb3duU3RhcnQgPSAwO1xuICAgIHRoaXMubW91c2VVcFN0YXJ0ID0gMDtcblxuICAgIHRoaXMueFN0YXJ0ID0gMDtcbiAgICB0aGlzLnlTdGFydCA9IDA7XG4gICAgdGhpcy54RW5kID0gMDtcbiAgICB0aGlzLnlFbmQgPSAwO1xuICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IDA7XG5cbiAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3MgPSBuZXcgRWxlbWVudE1ldHJpY3ModGhpcy5lbGVtZW50KTtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NhbGU7XG4gICAgdmFyIHRyYW5zbGF0ZVN0cmluZztcbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuXG4gICAgdGhpcy53YXZlLnN0eWxlLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICBzY2FsZSA9IHRoaXMucmFkaXVzIC8gKHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplIC8gMik7XG4gICAgZHggPSB0aGlzLnhOb3cgLSAodGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC8gMik7XG4gICAgZHkgPSB0aGlzLnlOb3cgLSAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDIpO1xuXG5cbiAgICAvLyAyZCB0cmFuc2Zvcm0gZm9yIHNhZmFyaSBiZWNhdXNlIG9mIGJvcmRlci1yYWRpdXMgYW5kIG92ZXJmbG93OmhpZGRlbiBjbGlwcGluZyBidWcuXG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTk4NTM4XG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGR4ICsgJ3B4LCAnICsgZHkgKyAncHgpJztcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCcgKyBkeCArICdweCwgJyArIGR5ICsgJ3B4LCAwKSc7XG4gICAgdGhpcy53YXZlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgnICsgc2NhbGUgKyAnLCcgKyBzY2FsZSArICcpJztcbiAgICB0aGlzLndhdmUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlM2QoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnLDEpJztcbiAgfSxcblxuICAvKiogQHBhcmFtIHtFdmVudD19IGV2ZW50ICovXG4gIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHhDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgIHZhciB5Q2VudGVyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDI7XG5cbiAgICB0aGlzLnJlc2V0SW50ZXJhY3Rpb25TdGF0ZSgpO1xuICAgIHRoaXMubW91c2VEb3duU3RhcnQgPSBVdGlsaXR5Lm5vdygpO1xuXG4gICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICB0aGlzLnhTdGFydCA9IHhDZW50ZXI7XG4gICAgICB0aGlzLnlTdGFydCA9IHlDZW50ZXI7XG4gICAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSBVdGlsaXR5LmRpc3RhbmNlKFxuICAgICAgICB0aGlzLnhTdGFydCwgdGhpcy55U3RhcnQsIHRoaXMueEVuZCwgdGhpcy55RW5kXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnhTdGFydCA9IGV2ZW50ID9cbiAgICAgICAgICBldmVudC5kZXRhaWwueCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QubGVmdCA6XG4gICAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMueVN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgIGV2ZW50LmRldGFpbC55IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLmJvdW5kaW5nUmVjdC50b3AgOlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLyAyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlY2VudGVycykge1xuICAgICAgdGhpcy54RW5kID0geENlbnRlcjtcbiAgICAgIHRoaXMueUVuZCA9IHlDZW50ZXI7XG4gICAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSBVdGlsaXR5LmRpc3RhbmNlKFxuICAgICAgICB0aGlzLnhTdGFydCwgdGhpcy55U3RhcnQsIHRoaXMueEVuZCwgdGhpcy55RW5kXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMubWF4UmFkaXVzID0gdGhpcy5jb250YWluZXJNZXRyaWNzLmZ1cnRoZXN0Q29ybmVyRGlzdGFuY2VGcm9tKFxuICAgICAgdGhpcy54U3RhcnQsXG4gICAgICB0aGlzLnlTdGFydFxuICAgICk7XG5cbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUudG9wID1cbiAgICAgICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLmxlZnQgPVxuICAgICAgKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuXG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLndpZHRoID0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKyAncHgnO1xuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSArICdweCc7XG4gIH0sXG5cbiAgLyoqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCAqL1xuICB1cEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm1vdXNlVXBTdGFydCA9IFV0aWxpdHkubm93KCk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICBkb20odGhpcy53YXZlQ29udGFpbmVyLnBhcmVudE5vZGUpLnJlbW92ZUNoaWxkKFxuICAgICAgdGhpcy53YXZlQ29udGFpbmVyXG4gICAgKTtcbiAgfVxufTtcblxuUG9seW1lcih7XG4gIF90ZW1wbGF0ZTogYFxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogaW5oZXJpdDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuXG4gICAgICAgIC8qIFNlZSBQb2x5bWVyRWxlbWVudHMvcGFwZXItYmVoYXZpb3JzL2lzc3Vlcy8zNC4gT24gbm9uLUNocm9tZSBicm93c2VycyxcbiAgICAgICAgICogY3JlYXRpbmcgYSBub2RlICh3aXRoIGEgcG9zaXRpb246YWJzb2x1dGUpIGluIHRoZSBtaWRkbGUgb2YgYW4gZXZlbnRcbiAgICAgICAgICogaGFuZGxlciBcImludGVycnVwdHNcIiB0aGF0IGV2ZW50IGhhbmRsZXIgKHdoaWNoIGhhcHBlbnMgd2hlbiB0aGVcbiAgICAgICAgICogcmlwcGxlIGlzIGNyZWF0ZWQgb24gZGVtYW5kKSAqL1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2FuaW1hdGluZ10pIHtcbiAgICAgICAgLyogVGhpcyByZXNvbHZlcyBhIHJlbmRlcmluZyBpc3N1ZSBpbiBDaHJvbWUgKGFzIG9mIDQwKSB3aGVyZSB0aGVcbiAgICAgICAgICAgcmlwcGxlIGlzIG5vdCBwcm9wZXJseSBjbGlwcGVkIGJ5IGl0cyBwYXJlbnQgKHdoaWNoIG1heSBoYXZlXG4gICAgICAgICAgIHJvdW5kZWQgY29ybmVycykuIFNlZTogaHR0cDovL2pzYmluLmNvbS90ZW1leGEvNFxuXG4gICAgICAgICAgIE5vdGU6IFdlIG9ubHkgYXBwbHkgdGhpcyBzdHlsZSBjb25kaXRpb25hbGx5LiBPdGhlcndpc2UsIHRoZSBicm93c2VyXG4gICAgICAgICAgIHdpbGwgY3JlYXRlIGEgbmV3IGNvbXBvc2l0aW5nIGxheWVyIGZvciBldmVyeSByaXBwbGUgZWxlbWVudCBvbiB0aGVcbiAgICAgICAgICAgcGFnZSwgYW5kIHRoYXQgd291bGQgYmUgYmFkLiAqL1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZCxcbiAgICAgICN3YXZlcyxcbiAgICAgIC53YXZlLWNvbnRhaW5lcixcbiAgICAgIC53YXZlIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgfVxuXG4gICAgICAjYmFja2dyb3VuZCxcbiAgICAgIC53YXZlIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgIH1cblxuICAgICAgI3dhdmVzLFxuICAgICAgLndhdmUge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuXG4gICAgICAud2F2ZS1jb250YWluZXIsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLmNpcmNsZSkgI2JhY2tncm91bmQsXG4gICAgICA6aG9zdCguY2lyY2xlKSAjd2F2ZXMge1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5jaXJjbGUpIC53YXZlLWNvbnRhaW5lciB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgaWQ9XCJiYWNrZ3JvdW5kXCI+PC9kaXY+XG4gICAgPGRpdiBpZD1cIndhdmVzXCI+PC9kaXY+XG5gLFxuXG4gIGlzOiAncGFwZXItcmlwcGxlJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBJcm9uQTExeUtleXNCZWhhdmlvclxuICBdLFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5pdGlhbCBvcGFjaXR5IHNldCBvbiB0aGUgd2F2ZS5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgaW5pdGlhbE9wYWNpdHlcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjI1XG4gICAgICovXG4gICAgaW5pdGlhbE9wYWNpdHk6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHZhbHVlOiAwLjI1XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhvdyBmYXN0IChvcGFjaXR5IHBlciBzZWNvbmQpIHRoZSB3YXZlIGZhZGVzIG91dC5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgb3BhY2l0eURlY2F5VmVsb2NpdHlcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjhcbiAgICAgKi9cbiAgICBvcGFjaXR5RGVjYXlWZWxvY2l0eToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDAuOFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCByaXBwbGVzIHdpbGwgZXhoaWJpdCBhIGdyYXZpdGF0aW9uYWwgcHVsbCB0b3dhcmRzXG4gICAgICogdGhlIGNlbnRlciBvZiB0aGVpciBjb250YWluZXIgYXMgdGhleSBmYWRlIGF3YXkuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIHJlY2VudGVyc1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHJlY2VudGVyczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCByaXBwbGVzIHdpbGwgY2VudGVyIGluc2lkZSBpdHMgY29udGFpbmVyXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIHJlY2VudGVyc1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGNlbnRlcjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2YgdGhlIHZpc3VhbCByaXBwbGVzLlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSByaXBwbGVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuICAgIHJpcHBsZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiB0aGVyZSBhcmUgdmlzaWJsZSByaXBwbGVzIGFuaW1hdGluZyB3aXRoaW4gdGhlXG4gICAgICogZWxlbWVudC5cbiAgICAgKi9cbiAgICBhbmltYXRpbmc6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgcmVtYWluIGluIHRoZSBcImRvd25cIiBzdGF0ZSB1bnRpbCBgaG9sZERvd25gXG4gICAgICogaXMgc2V0IHRvIGZhbHNlIGFnYWluLlxuICAgICAqL1xuICAgIGhvbGREb3duOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgb2JzZXJ2ZXI6ICdfaG9sZERvd25DaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgcmlwcGxlIHdpbGwgbm90IGdlbmVyYXRlIGEgcmlwcGxlIGVmZmVjdFxuICAgICAqIHZpYSBwb2ludGVyIGludGVyYWN0aW9uLlxuICAgICAqIENhbGxpbmcgcmlwcGxlJ3MgaW1wZXJhdGl2ZSBhcGkgbGlrZSBgc2ltdWxhdGVkUmlwcGxlYCB3aWxsXG4gICAgICogc3RpbGwgZ2VuZXJhdGUgdGhlIHJpcHBsZSBlZmZlY3QuXG4gICAgICovXG4gICAgbm9pbms6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgX2FuaW1hdGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG5cbiAgICBfYm91bmRBbmltYXRlOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZS5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXQgdGFyZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlFdmVudFRhcmdldDtcbiAgfSxcblxuICBrZXlCaW5kaW5nczoge1xuICAgICdlbnRlcjprZXlkb3duJzogJ19vbkVudGVyS2V5ZG93bicsXG4gICAgJ3NwYWNlOmtleWRvd24nOiAnX29uU3BhY2VLZXlkb3duJyxcbiAgICAnc3BhY2U6a2V5dXAnOiAnX29uU3BhY2VLZXl1cCdcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gU2V0IHVwIGExMXlLZXlzQmVoYXZpb3IgdG8gbGlzdGVuIHRvIGtleSBldmVudHMgb24gdGhlIHRhcmdldCxcbiAgICAvLyBzbyB0aGF0IHNwYWNlIGFuZCBlbnRlciBhY3RpdmF0ZSB0aGUgcmlwcGxlIGV2ZW4gaWYgdGhlIHRhcmdldCBkb2Vzbid0XG4gICAgLy8gaGFuZGxlIGtleSBldmVudHMuIFRoZSBrZXkgaGFuZGxlcnMgZGVhbCB3aXRoIGBub2lua2AgdGhlbXNlbHZlcy5cbiAgICBpZiAodGhpcy5wYXJlbnROb2RlLm5vZGVUeXBlID09IDExKSB7IC8vIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVcbiAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQgPSBkb20odGhpcykuZ2V0T3duZXJSb290KCkuaG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgdmFyIGtleUV2ZW50VGFyZ2V0ID0gLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovICh0aGlzLmtleUV2ZW50VGFyZ2V0KTtcbiAgICB0aGlzLmxpc3RlbihrZXlFdmVudFRhcmdldCwgJ3VwJywgJ3VpVXBBY3Rpb24nKTtcbiAgICB0aGlzLmxpc3RlbihrZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ3VwJywgJ3VpVXBBY3Rpb24nKTtcbiAgICB0aGlzLnVubGlzdGVuKHRoaXMua2V5RXZlbnRUYXJnZXQsICdkb3duJywgJ3VpRG93bkFjdGlvbicpO1xuICAgIHRoaXMua2V5RXZlbnRUYXJnZXQgPSBudWxsO1xuICB9LFxuXG4gIGdldCBzaG91bGRLZWVwQW5pbWF0aW5nICgpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnJpcHBsZXNbaW5kZXhdLmlzQW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHNpbXVsYXRlZFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kb3duQWN0aW9uKG51bGwpO1xuXG4gICAgLy8gUGxlYXNlIHNlZSBwb2x5bWVyL3BvbHltZXIjMTMwNVxuICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnVwQWN0aW9uKCk7XG4gICAgfSwgMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3Zva2VzIGEgcmlwcGxlIGRvd24gZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIHVpRG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubm9pbmspIHtcbiAgICAgIHRoaXMuZG93bkFjdGlvbihldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSBkb3duIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICogKm5vdCogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAqL1xuICBkb3duQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLmhvbGREb3duICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJpcHBsZSA9IHRoaXMuYWRkUmlwcGxlKCk7XG5cbiAgICByaXBwbGUuZG93bkFjdGlvbihldmVudCk7XG5cbiAgICBpZiAoIXRoaXMuX2FuaW1hdGluZykge1xuICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuYW5pbWF0ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgdXAgZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIHVpVXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm5vaW5rKSB7XG4gICAgICB0aGlzLnVwQWN0aW9uKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICogKm5vdCogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAqL1xuICB1cEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5ob2xkRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmlwcGxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJpcHBsZSkge1xuICAgICAgcmlwcGxlLnVwQWN0aW9uKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2FuaW1hdGluZyA9IHRydWU7XG4gICAgdGhpcy5hbmltYXRlKCk7XG4gIH0sXG5cbiAgb25BbmltYXRpb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbnVsbDtcbiAgICB0aGlzLmZpcmUoJ3RyYW5zaXRpb25lbmQnKTtcbiAgfSxcblxuICBhZGRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByaXBwbGUgPSBuZXcgUmlwcGxlKHRoaXMpO1xuXG4gICAgZG9tKHRoaXMuJC53YXZlcykuYXBwZW5kQ2hpbGQocmlwcGxlLndhdmVDb250YWluZXIpO1xuICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJpcHBsZS5jb2xvcjtcbiAgICB0aGlzLnJpcHBsZXMucHVzaChyaXBwbGUpO1xuXG4gICAgdGhpcy5fc2V0QW5pbWF0aW5nKHRydWUpO1xuXG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfSxcblxuICByZW1vdmVSaXBwbGU6IGZ1bmN0aW9uKHJpcHBsZSkge1xuICAgIHZhciByaXBwbGVJbmRleCA9IHRoaXMucmlwcGxlcy5pbmRleE9mKHJpcHBsZSk7XG5cbiAgICBpZiAocmlwcGxlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yaXBwbGVzLnNwbGljZShyaXBwbGVJbmRleCwgMSk7XG5cbiAgICByaXBwbGUucmVtb3ZlKCk7XG5cbiAgICBpZiAoIXRoaXMucmlwcGxlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3NldEFuaW1hdGluZyhmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIGNvbmZsaWN0cyB3aXRoIEVsZW1lbnQjYW50aW1hdGUoKS5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvYW5pbWF0ZVxuICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2FuaW1hdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5kZXg7XG4gICAgdmFyIHJpcHBsZTtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucmlwcGxlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHJpcHBsZSA9IHRoaXMucmlwcGxlc1tpbmRleF07XG5cbiAgICAgIHJpcHBsZS5kcmF3KCk7XG5cbiAgICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHkgPSByaXBwbGUub3V0ZXJPcGFjaXR5O1xuXG4gICAgICBpZiAocmlwcGxlLmlzT3BhY2l0eUZ1bGx5RGVjYXllZCAmJiAhcmlwcGxlLmlzUmVzdGluZ0F0TWF4UmFkaXVzKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmlwcGxlKHJpcHBsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEtlZXBBbmltYXRpbmcgJiYgdGhpcy5yaXBwbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vbkFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYm91bmRBbmltYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uRW50ZXJLZXlkb3duOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICAgIHRoaXMuYXN5bmModGhpcy51aVVwQWN0aW9uLCAxKTtcbiAgfSxcblxuICBfb25TcGFjZUtleWRvd246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gIH0sXG5cbiAgX29uU3BhY2VLZXl1cDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51aVVwQWN0aW9uKCk7XG4gIH0sXG5cbiAgLy8gbm90ZTogaG9sZERvd24gZG9lcyBub3QgcmVzcGVjdCBub2luayBzaW5jZSBpdCBjYW4gYmUgYSBmb2N1cyBiYXNlZFxuICAvLyBlZmZlY3QuXG4gIF9ob2xkRG93bkNoYW5nZWQ6IGZ1bmN0aW9uKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgaWYgKG9sZFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXdWYWwpIHtcbiAgICAgIHRoaXMuZG93bkFjdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwQWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcy5cbiAgVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gd2FpdCB1bnRpbFxuICB0aGUgcmlwcGxlIGFuaW1hdGlvbiBmaW5pc2hlcyB0byBwZXJmb3JtIHNvbWUgYWN0aW9uLlxuXG4gIEBldmVudCB0cmFuc2l0aW9uZW5kXG4gIEBwYXJhbSB7e25vZGU6IE9iamVjdH19IGRldGFpbCBDb250YWlucyB0aGUgYW5pbWF0ZWQgbm9kZS5cbiAgKi9cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmpzIiwiaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge19wb2ludGVyc0NvdW50fSBmcm9tICcuL0RvbUV2ZW50LlBvaW50ZXInO1xyXG5cclxuLypcclxuICogRXh0ZW5kcyB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSB3aXRoIGRvdWJsZSB0YXAgc3VwcG9ydCBmb3IgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbnZhciBfdG91Y2hzdGFydCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nIDogQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JyxcclxuICAgIF90b3VjaGVuZCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVydXAnIDogJ3RvdWNoZW5kJyxcclxuICAgIF9wcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0dmFyIGxhc3QsIHRvdWNoLFxyXG5cdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHQgICAgZGVsYXkgPSAyNTA7XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XHJcblx0XHR2YXIgY291bnQ7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRpZiAoKCFCcm93c2VyLmVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGNvdW50ID0gX3BvaW50ZXJzQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3VudCA9IGUudG91Y2hlcy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvdW50ID4gMSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSxcclxuXHRcdCAgICBkZWx0YSA9IG5vdyAtIChsYXN0IHx8IG5vdyk7XHJcblxyXG5cdFx0dG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRsYXN0ID0gbm93O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRpZiAoZG91YmxlVGFwICYmICF0b3VjaC5jYW5jZWxCdWJibGUpIHtcclxuXHRcdFx0aWYgKEJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdGlmICgoIUJyb3dzZXIuZWRnZSkgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH1cclxuXHRcdFx0XHQvLyB3b3JrIGFyb3VuZCAudHlwZSBiZWluZyByZWFkb25seSB3aXRoIE1TUG9pbnRlciogZXZlbnRzXHJcblx0XHRcdFx0dmFyIG5ld1RvdWNoID0ge30sXHJcblx0XHRcdFx0ICAgIHByb3AsIGk7XHJcblxyXG5cdFx0XHRcdGZvciAoaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0cHJvcCA9IHRvdWNoW2ldO1xyXG5cdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZCh0b3VjaCkgOiBwcm9wO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0b3VjaCA9IG5ld1RvdWNoO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRoYW5kbGVyKHRvdWNoKTtcclxuXHRcdFx0bGFzdCA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdID0gb25Ub3VjaFN0YXJ0O1xyXG5cdG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdID0gb25Ub3VjaEVuZDtcclxuXHRvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoX3RvdWNoZW5kLCBvblRvdWNoRW5kLCBmYWxzZSk7XHJcblxyXG5cdC8vIE9uIHNvbWUgcGxhdGZvcm1zIChub3RhYmx5LCBjaHJvbWU8NTUgb24gd2luMTAgKyB0b3VjaHNjcmVlbiArIG1vdXNlKSxcclxuXHQvLyB0aGUgYnJvd3NlciBkb2Vzbid0IGZpcmUgdG91Y2hlbmQvcG9pbnRlcnVwIGV2ZW50cyBidXQgZG9lcyBmaXJlXHJcblx0Ly8gbmF0aXZlIGRibGNsaWNrcy4gU2VlICM0MTI3LlxyXG5cdC8vIEVkZ2UgMTQgYWxzbyBmaXJlcyBuYXRpdmUgZGJsY2xpY2tzLCBidXQgb25seSBmb3IgcG9pbnRlclR5cGUgbW91c2UsIHNlZSAjNTE4MC5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCkge1xyXG5cdHZhciB0b3VjaHN0YXJ0ID0gb2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSxcclxuXHQgICAgdG91Y2hlbmQgPSBvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSxcclxuXHQgICAgZGJsY2xpY2sgPSBvYmpbX3ByZSArICdkYmxjbGljaycgKyBpZF07XHJcblxyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0LCBmYWxzZSk7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoZW5kLCB0b3VjaGVuZCwgZmFsc2UpO1xyXG5cdGlmICghQnJvd3Nlci5lZGdlKSB7XHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBkYmxjbGljaywgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tRXZlbnQuRG91YmxlVGFwLmpzIiwiaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi4vLi4vZG9tL0RyYWdnYWJsZSc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuTWFya2VyRHJhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgTC5NYXJrZXIgdG8gbWFrZSB0aGUgbWFya2VycyBkcmFnZ2FibGUuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcmtlclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gaGFuZGxlcnNcbiAqXG4gKiBJbnRlcmFjdGlvbiBoYW5kbGVycyBhcmUgcHJvcGVydGllcyBvZiBhIG1hcmtlciBpbnN0YW5jZSB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2ggYXMgZHJhZ2dpbmcgKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIG1hcmtlci5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbiAqIE1hcmtlciBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuIE9ubHkgdmFsaWQgd2hlbiB0aGUgbWFya2VyIGlzIG9uIHRoZSBtYXAgKE90aGVyd2lzZSBzZXQgW2BtYXJrZXIub3B0aW9ucy5kcmFnZ2FibGVgXSgjbWFya2VyLWRyYWdnYWJsZSkpLlxuICovXG5cbmV4cG9ydCB2YXIgTWFya2VyRHJhZyA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHRoaXMuX21hcmtlciA9IG1hcmtlcjtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpY29uID0gdGhpcy5fbWFya2VyLl9pY29uO1xuXG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoaWNvbiwgaWNvbiwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcblx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHR9LCB0aGlzKS5lbmFibGUoKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXJrZXIuX2ljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0XHR9XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGxhdGxuZyA9IG1hcmtlci5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcblxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cblx0XHRpZiAoc2hhZG93KSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XG5cdFx0fVxuXG5cdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5sYXRsbmcgPSBsYXRsbmc7XG5cdFx0ZS5vbGRMYXRMbmcgPSB0aGlzLl9vbGRMYXRMbmc7XG5cblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXG5cdFx0bWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvTWFya2VyLkRyYWcuanMiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIyMjczZTNkOGFkOTI2NGI3ZGFhNWJkYmY4ZTZiNDdmOC5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmdcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI0NGE1MjZlZWQyNTgyMjI1MTVhYTIxZWFmZmQxNGE5Ni5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZ1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IE1hcCB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL21hcCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGlvbiB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5BdHRyaWJ1dGlvbi5qcydcblxuLy8gTmVlZCB0aGVzZSBzaWRlIGVmZmVjdHNcbmltcG9ydCAnLi4vLi4vbGVhZmxldC9zcmMvY29udHJvbCc7XG5pbXBvcnQgJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyJztcblxuZXhwb3J0IGNsYXNzIExlYWZsZXRNYXAgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldEAxLjIuMC9kaXN0L2xlYWZsZXQuY3NzXCIgLz5cblxuICAgICAgPCEtLSBGSVhNRTogRmlndXJlIG91dCBTaGFkb3cgRE9NIHNvIHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGluY2x1ZGVkIGhlcmUgLS0+XG4gICAgICA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXQubWFya2VyY2x1c3RlckAxLjMuMC9kaXN0L01hcmtlckNsdXN0ZXIuY3NzXCIgbWVkaWE9XCJzY3JlZW5cIj5cbiAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldC5tYXJrZXJjbHVzdGVyQDEuMy4wL2Rpc3QvTWFya2VyQ2x1c3Rlci5EZWZhdWx0LmNzc1wiIG1lZGlhPVwic2NyZWVuXCI+XG5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgI21hcCB7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgIEBhcHBseSAoLS1sZWFmbGV0LW1hcC1jb21wb25lbnQpXG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgaWQ9XCJtYXBcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFwOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuICAgICAgbGF0aXR1ZGU6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgbG9uZ2l0dWRlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIHpvb206IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgbWluWm9vbToge1xuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXhab29tOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIHpvb21Db250cm9sOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0aW9uUHJlZml4OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIF9jaGlsZHJlbk9ic2VydmVyOiBPYmplY3RcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aGlzLiQubWFwLCB7XG4gICAgICBjZW50ZXI6IFt0aGlzLmxhdGl0dWRlLCB0aGlzLmxvbmdpdHVkZV0sXG4gICAgICB6b29tOiB0aGlzLnpvb20sXG4gICAgICB6b29tQ29udHJvbDogdGhpcy56b29tQ29udHJvbCxcbiAgICAgIGluZXJ0aWFEZWNlbGVyYXRpb246IDMwMDAsXG4gICAgICBpbmVydGlhTWF4U3BlZWQ6IDMwMDAsXG4gICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IGZhbHNlLFxuICAgICAgbWluWm9vbTogdGhpcy5taW5ab29tLFxuICAgICAgbWF4Wm9vbTogdGhpcy5tYXhab29tXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5hdHRyaWJ1dGlvblByZWZpeCkge1xuICAgICAgbGV0IGF0dHJDb250cm9sID0gbmV3IEF0dHJpYnV0aW9uKHsgcHJlZml4OiB0aGlzLmF0dHJpYnV0aW9uUHJlZml4IH0pO1xuICAgICAgdGhpcy5tYXAuYWRkQ29udHJvbChhdHRyQ29udHJvbCk7XG4gICAgfVxuXG4gICAgbGV0IHNsb3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc2xvdCcpO1xuICAgIHRoaXMuX2NoaWxkcmVuT2JzZXJ2ZXIgPSBuZXcgRmxhdHRlbmVkTm9kZXNPYnNlcnZlcihzbG90LCB0aGlzLl9iaW5kRGVwZW5kZW5jaWVzLmJpbmQodGhpcykpO1xuICB9XG4gIFxuICAvKiBTaGl0dHkgd2F5IG9mIHBhc3NpbmcgdmFsdWUgdG8gY2hpbGRyZW4gKi9cbiAgX2JpbmREZXBlbmRlbmNpZXMoe2FkZGVkTm9kZXN9KSB7XG4gICAgYWRkZWROb2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgbi5tYXAgPSB0aGlzLm1hcDtcbiAgICB9KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xlYWZsZXQtbWFwJywgTGVhZmxldE1hcCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL3Zhci93d3cvbG9jYWxob3N0L2h0ZG9jcy9AZ2djaXR5L2xlYWZsZXQtbWFwL2xlYWZsZXQtbWFwLmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG5cdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG5cdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuQm94Wm9vbS5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIUJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuZXhwb3J0IHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IGxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdGlmICh0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tYXBcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4vLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQge29uLCBvZmYsIHN0b3B9IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuXG4vKlxuICogTC5NYXAuS2V5Ym9hcmQgaXMgaGFuZGxpbmcga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2l0aCB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEtleWJvYXJkIE5hdmlnYXRpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24ga2V5Ym9hcmQ6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIE1ha2VzIHRoZSBtYXAgZm9jdXNhYmxlIGFuZCBhbGxvd3MgdXNlcnMgdG8gbmF2aWdhdGUgdGhlIG1hcCB3aXRoIGtleWJvYXJkXG5cdC8vIGFycm93cyBhbmQgYCtgL2AtYCBrZXlzLlxuXHRrZXlib2FyZDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIGtleWJvYXJkUGFuRGVsdGE6IE51bWJlciA9IDgwXG5cdC8vIEFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIHdoZW4gcHJlc3NpbmcgYW4gYXJyb3cga2V5LlxuXHRrZXlib2FyZFBhbkRlbHRhOiA4MFxufSk7XG5cbmV4cG9ydCB2YXIgS2V5Ym9hcmQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cblx0a2V5Q29kZXM6IHtcblx0XHRsZWZ0OiAgICBbMzddLFxuXHRcdHJpZ2h0OiAgIFszOV0sXG5cdFx0ZG93bjogICAgWzQwXSxcblx0XHR1cDogICAgICBbMzhdLFxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXG5cdFx0em9vbU91dDogWzE4OSwgMTA5LCA1NCwgMTczXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cblx0XHR0aGlzLl9zZXRQYW5EZWx0YShtYXAub3B0aW9ucy5rZXlib2FyZFBhbkRlbHRhKTtcblx0XHR0aGlzLl9zZXRab29tRGVsdGEobWFwLm9wdGlvbnMuem9vbURlbHRhKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xuXHRcdGlmIChjb250YWluZXIudGFiSW5kZXggPD0gMCkge1xuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xuXHRcdH1cblxuXHRcdG9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRvZmYodGhpcy5fbWFwLl9jb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9mZih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9mb2N1c2VkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxuXHRcdCAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XG5cblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXG5cdFx0d2luZG93LnNjcm9sbFRvKGxlZnQsIHRvcCk7XG5cdH0sXG5cblx0X29uRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZm9jdXMnKTtcblx0fSxcblxuXHRfb25CbHVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XG5cdH0sXG5cblx0X3NldFBhbkRlbHRhOiBmdW5jdGlvbiAocGFuRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3BhbktleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmxlZnRbaV1dID0gWy0xICogcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5yaWdodC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuRGVsdGEsIDBdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5kb3duLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLmRvd25baV1dID0gWzAsIHBhbkRlbHRhXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMudXBbaV1dID0gWzAsIC0xICogcGFuRGVsdGFdO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbURlbHRhOiBmdW5jdGlvbiAoem9vbURlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21Jbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tSW5baV1dID0gem9vbURlbHRhO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21PdXRbaV1dID0gLXpvb21EZWx0YTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblxuXHRcdFx0aWYgKG1hcC5fcGFuQW5pbSAmJiBtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuXHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcgJiYgbWFwLl9wb3B1cCkge1xuXHRcdFx0bWFwLmNsb3NlUG9wdXAoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBLZXlib2FyZCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5LZXlib2FyZC5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNld2hlZWwgb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHNjcm9sbFdoZWVsWm9vbTogQm9vbGVhbnxTdHJpbmcgPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC4gSWYgcGFzc2VkIGAnY2VudGVyJ2AsXG5cdC8vIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0c2Nyb2xsV2hlZWxab29tOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxEZWJvdW5jZVRpbWU6IE51bWJlciA9IDQwXG5cdC8vIExpbWl0cyB0aGUgcmF0ZSBhdCB3aGljaCBhIHdoZWVsIGNhbiBmaXJlIChpbiBtaWxsaXNlY29uZHMpLiBCeSBkZWZhdWx0XG5cdC8vIHVzZXIgY2FuJ3Qgem9vbSB2aWEgd2hlZWwgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIDQwIG1zLlxuXHR3aGVlbERlYm91bmNlVGltZTogNDAsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbFB4UGVyWm9vbUxldmVsOiBOdW1iZXIgPSA2MFxuXHQvLyBIb3cgbWFueSBzY3JvbGwgcGl4ZWxzIChhcyByZXBvcnRlZCBieSBbTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhXSgjZG9tZXZlbnQtZ2V0d2hlZWxkZWx0YSkpXG5cdC8vIG1lYW4gYSBjaGFuZ2Ugb2Ygb25lIGZ1bGwgem9vbSBsZXZlbC4gU21hbGxlciB2YWx1ZXMgd2lsbCBtYWtlIHdoZWVsLXpvb21pbmdcblx0Ly8gZmFzdGVyIChhbmQgdmljZSB2ZXJzYSkuXG5cdHdoZWVsUHhQZXJab29tTGV2ZWw6IDYwXG59KTtcblxuZXhwb3J0IHZhciBTY3JvbGxXaGVlbFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuU2Nyb2xsV2hlZWxab29tLmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cblxuLypcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdGFwOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBFbmFibGVzIG1vYmlsZSBoYWNrcyBmb3Igc3VwcG9ydGluZyBpbnN0YW50IHRhcHMgKGZpeGluZyAyMDBtcyBjbGlja1xuXHQvLyBkZWxheSBvbiBpT1MvQW5kcm9pZCkgYW5kIHRvdWNoIGhvbGRzIChmaXJlZCBhcyBgY29udGV4dG1lbnVgIGV2ZW50cykuXG5cdHRhcDogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcCA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcykgeyByZXR1cm47IH1cblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcblxuXHRcdC8vIGRvbid0IHNpbXVsYXRlIGNsaWNrIG9yIHRyYWNrIGxvbmdwcmVzcyBpZiBtb3JlIHRoYW4gMSB0b3VjaFxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcblx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XG5cdFx0aWYgKGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcblx0XHR0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX29uVXAoKTtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcyksIDEwMDApO1xuXG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vkb3duJywgZmlyc3QpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2V1cCcsIGZpcnN0KTtcblxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NsaWNrJywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfaXNUYXBWYWxpZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcykgPD0gdGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlO1xuXHR9LFxuXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xuXHRcdHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZW1vdmUnLCBmaXJzdCk7XG5cdH0sXG5cblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG5cdFx0dmFyIHNpbXVsYXRlZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcblx0XHRlLnRhcmdldC5fc2ltdWxhdGVkQ2xpY2sgPSB0cnVlO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXG5cdFx0ICAgICAgICB0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsXG5cdFx0ICAgICAgICBlLnNjcmVlblgsIGUuc2NyZWVuWSxcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxuXHRcdCAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcDogSGFuZGxlclxuLy8gTW9iaWxlIHRvdWNoIGhhY2tzIChxdWljayB0YXAgYW5kIHRvdWNoIGhvbGQpIGhhbmRsZXIuXG5pZiAoQnJvd3Nlci50b3VjaCAmJiAhQnJvd3Nlci5wb2ludGVyKSB7XG5cdE1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0YXAnLCBUYXApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuVGFwLmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0b3VjaFpvb206IEJvb2xlYW58U3RyaW5nID0gKlxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB0b3VjaC1kcmFnZ2luZyB3aXRoIHR3byBmaW5nZXJzLiBJZlxuXHQvLyBwYXNzZWQgYCdjZW50ZXInYCwgaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZlxuXHQvLyB3aGVyZSB0aGUgdG91Y2ggZXZlbnRzIChmaW5nZXJzKSB3ZXJlLiBFbmFibGVkIGZvciB0b3VjaC1jYXBhYmxlIHdlYlxuXHQvLyBicm93c2VycyBleGNlcHQgZm9yIG9sZCBBbmRyb2lkcy5cblx0dG91Y2hab29tOiBCcm93c2VyLnRvdWNoICYmICFCcm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBUb3VjaFpvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgdGhpcyk7XG5cdH0sXG5cblx0X29uVG91Y2hTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgbWFwLl9hbmltYXRpbmdab29tIHx8IHRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKTtcblxuXHRcdHRoaXMuX2NlbnRlclBvaW50ID0gbWFwLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSAhPT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcgPSBtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhwMS5hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0dGhpcy5fc3RhcnRab29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5fem9vbWluZyA9IHRydWU7XG5cblx0XHRtYXAuX3N0b3AoKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8ICF0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgcDEgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzBdKSxcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS50b3VjaGVzWzFdKSxcblx0XHQgICAgc2NhbGUgPSBwMS5kaXN0YW5jZVRvKHAyKSAvIHRoaXMuX3N0YXJ0RGlzdDtcblxuXHRcdHRoaXMuX3pvb20gPSBtYXAuZ2V0U2NhbGVab29tKHNjYWxlLCB0aGlzLl9zdGFydFpvb20pO1xuXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMgJiYgKFxuXHRcdFx0KHRoaXMuX3pvb20gPCBtYXAuZ2V0TWluWm9vbSgpICYmIHNjYWxlIDwgMSkgfHxcblx0XHRcdCh0aGlzLl96b29tID4gbWFwLmdldE1heFpvb20oKSAmJiBzY2FsZSA+IDEpKSkge1xuXHRcdFx0dGhpcy5fem9vbSA9IG1hcC5fbGltaXRab29tKHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9zdGFydExhdExuZztcblx0XHRcdGlmIChzY2FsZSA9PT0gMSkgeyByZXR1cm47IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IGRlbHRhIGZyb20gcGluY2ggdG8gY2VudGVyLCBzbyBjZW50ZXJMYXRMbmcgaXMgZGVsdGEgYXBwbGllZCB0byBpbml0aWFsIHBpbmNoTGF0TG5nXG5cdFx0XHR2YXIgZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRcdGlmIChzY2FsZSA9PT0gMSAmJiBkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR0aGlzLl9jZW50ZXIgPSBtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KHRoaXMuX3BpbmNoU3RhcnRMYXRMbmcsIHRoaXMuX3pvb20pLnN1YnRyYWN0KGRlbHRhKSwgdGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0bWFwLl9tb3ZlU3RhcnQodHJ1ZSk7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IFV0aWwuYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0pO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKG1vdmVGbiwgdGhpcywgdHJ1ZSk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaEVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbW92ZWQgfHwgIXRoaXMuX3pvb21pbmcpIHtcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG5cblx0XHQvLyBQaW5jaCB1cGRhdGVzIEdyaWRMYXllcnMnIGxldmVscyBvbmx5IHdoZW4gem9vbVNuYXAgaXMgb2ZmLCBzbyB6b29tU25hcCBiZWNvbWVzIG5vVXBkYXRlLlxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHR0aGlzLl9tYXAuX2FuaW1hdGVab29tKHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSksIHRydWUsIHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fbWFwLl9yZXNldFZpZXcodGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0b3VjaFpvb206IEhhbmRsZXJcbi8vIFRvdWNoIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBUb3VjaFpvb20pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9sYXllcnMtY29udHJvbC8pKS4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBiYXNlTGF5ZXJzID0ge1xyXG4gKiBcdFwiTWFwYm94XCI6IG1hcGJveCxcclxuICogXHRcIk9wZW5TdHJlZXRNYXBcIjogb3NtXHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBvdmVybGF5cyA9IHtcclxuICogXHRcIk1hcmtlclwiOiBtYXJrZXIsXHJcbiAqIFx0XCJSb2Fkc1wiOiByb2Fkc0xheWVyXHJcbiAqIH07XHJcbiAqXHJcbiAqIEwuY29udHJvbC5sYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMpLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgYGJhc2VMYXllcnNgIGFuZCBgb3ZlcmxheXNgIHBhcmFtZXRlcnMgYXJlIG9iamVjdCBsaXRlcmFscyB3aXRoIGxheWVyIG5hbWVzIGFzIGtleXMgYW5kIGBMYXllcmAgb2JqZWN0cyBhcyB2YWx1ZXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcclxuICogICAgIFwiPHNvbWVOYW1lMT5cIjogbGF5ZXIxLFxyXG4gKiAgICAgXCI8c29tZU5hbWUyPlwiOiBsYXllcjJcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGxheWVyIG5hbWVzIGNhbiBjb250YWluIEhUTUwsIHdoaWNoIGFsbG93cyB5b3UgdG8gYWRkIGFkZGl0aW9uYWwgc3R5bGluZyB0byB0aGUgaXRlbXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHtcIjxpbWcgc3JjPSdteS1sYXllci1pY29uJyAvPiA8c3BhbiBjbGFzcz0nbXktbGF5ZXItaXRlbSc+TXkgTGF5ZXI8L3NwYW4+XCI6IG15TGF5ZXJ9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTGF5ZXJzID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkxheWVycyBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjb2xsYXBzZWQ6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYmUgY29sbGFwc2VkIGludG8gYW4gaWNvbiBhbmQgZXhwYW5kZWQgb24gbW91c2UgaG92ZXIgb3IgdG91Y2guXHJcblx0XHRjb2xsYXBzZWQ6IHRydWUsXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9aSW5kZXg6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIHdpbGwgYXNzaWduIHpJbmRleGVzIGluIGluY3JlYXNpbmcgb3JkZXIgdG8gYWxsIG9mIGl0cyBsYXllcnMgc28gdGhhdCB0aGUgb3JkZXIgaXMgcHJlc2VydmVkIHdoZW4gc3dpdGNoaW5nIHRoZW0gb24vb2ZmLlxyXG5cdFx0YXV0b1pJbmRleDogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGhpZGVTaW5nbGVCYXNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGJhc2UgbGF5ZXJzIGluIHRoZSBjb250cm9sIHdpbGwgYmUgaGlkZGVuIHdoZW4gdGhlcmUgaXMgb25seSBvbmUuXHJcblx0XHRoaWRlU2luZ2xlQmFzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzb3J0TGF5ZXJzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgbGF5ZXJzLiBXaGVuIGBmYWxzZWAsIGxheWVycyB3aWxsIGtlZXAgdGhlIG9yZGVyXHJcblx0XHQvLyBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgdG8gdGhlIGNvbnRyb2wuXHJcblx0XHRzb3J0TGF5ZXJzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRGdW5jdGlvbjogRnVuY3Rpb24gPSAqXHJcblx0XHQvLyBBIFtjb21wYXJlIGZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KVxyXG5cdFx0Ly8gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHNvcnRpbmcgdGhlIGxheWVycywgd2hlbiBgc29ydExheWVyc2AgaXMgYHRydWVgLlxyXG5cdFx0Ly8gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGJvdGggdGhlIGBMLkxheWVyYCBpbnN0YW5jZXMgYW5kIHRoZWlyIG5hbWVzLCBhcyBpblxyXG5cdFx0Ly8gYHNvcnRGdW5jdGlvbihsYXllckEsIGxheWVyQiwgbmFtZUEsIG5hbWVCKWAuXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBpdCBzb3J0cyBsYXllcnMgYWxwaGFiZXRpY2FsbHkgYnkgdGhlaXIgbmFtZS5cclxuXHRcdHNvcnRGdW5jdGlvbjogZnVuY3Rpb24gKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpIHtcclxuXHRcdFx0cmV0dXJuIG5hbWVBIDwgbmFtZUIgPyAtMSA6IChuYW1lQiA8IG5hbWVBID8gMSA6IDApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9uKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Q29udHJvbC5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xyXG5cdFx0Ly8gVHJpZ2dlciBleHBhbmQgYWZ0ZXIgTGF5ZXJzIENvbnRyb2wgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byBET00gc28gdGhhdCBpcyBub3cgaGFzIGFuIGFjdHVhbCBoZWlnaHQuXHJcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHR0aGlzLl9mb3JtLnN0eWxlLmhlaWdodCA9IG51bGw7XHJcblx0XHR2YXIgYWNjZXB0YWJsZUhlaWdodCA9IHRoaXMuX21hcC5nZXRTaXplKCkueSAtICh0aGlzLl9jb250YWluZXIub2Zmc2V0VG9wICsgNTApO1xyXG5cdFx0aWYgKGFjY2VwdGFibGVIZWlnaHQgPCB0aGlzLl9mb3JtLmNsaWVudEhlaWdodCkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2Zvcm0sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0XHR0aGlzLl9mb3JtLnN0eWxlLmhlaWdodCA9IGFjY2VwdGFibGVIZWlnaHQgKyAncHgnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBjb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xyXG5cclxuXHRcdC8vIG1ha2VzIHRoaXMgd29yayBvbiBJRSB0b3VjaCBkZXZpY2VzIGJ5IHN0b3BwaW5nIGl0IGZyb20gZmlyaW5nIGEgbW91c2VvdXQgZXZlbnQgd2hlbiB0aGUgdG91Y2ggaXMgcmVsZWFzZWRcclxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCB0cnVlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblxyXG5cdFx0dmFyIGZvcm0gPSB0aGlzLl9mb3JtID0gRG9tVXRpbC5jcmVhdGUoJ2Zvcm0nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcclxuXHJcblx0XHRpZiAoY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHJcblx0XHRcdGlmICghQnJvd3Nlci5hbmRyb2lkKSB7XHJcblx0XHRcdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCB7XHJcblx0XHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLmV4cGFuZCxcclxuXHRcdFx0XHRcdG1vdXNlbGVhdmU6IHRoaXMuY29sbGFwc2VcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lICsgJy10b2dnbGUnLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIERvbUV2ZW50LnN0b3ApO1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLmV4cGFuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBmb3JtKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIGZvcm0pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBmb3JtKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlhZGQ6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIHNlbGVjdGVkIHRocm91Z2ggdGhlIFtsYXllciBjb250cm9sXSgjY29udHJvbC1sYXllcnMpLlxyXG5cdFx0Ly8gQGV2ZW50IG92ZXJsYXlyZW1vdmU6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhbiBvdmVybGF5IGlzIGRlc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICtcclxuXHRcdFx0XHRuYW1lICsgJ1wiJyArIChjaGVja2VkID8gJyBjaGVja2VkPVwiY2hlY2tlZFwiJyA6ICcnKSArICcvPic7XHJcblxyXG5cdFx0dmFyIHJhZGlvRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdHJhZGlvRnJhZ21lbnQuaW5uZXJIVE1MID0gcmFkaW9IdG1sO1xyXG5cclxuXHRcdHJldHVybiByYWRpb0ZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblx0fSxcclxuXHJcblx0X2FkZEl0ZW06IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyksXHJcblx0XHQgICAgY2hlY2tlZCA9IHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpLFxyXG5cdFx0ICAgIGlucHV0O1xyXG5cclxuXHRcdGlmIChvYmoub3ZlcmxheSkge1xyXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XHJcblx0XHRcdGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xyXG5cdFx0XHRpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XHJcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzJywgY2hlY2tlZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLnB1c2goaW5wdXQpO1xyXG5cdFx0aW5wdXQubGF5ZXJJZCA9IFV0aWwuc3RhbXAob2JqLmxheWVyKTtcclxuXHJcblx0XHREb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0Ly8gSGVscHMgZnJvbSBwcmV2ZW50aW5nIGxheWVyIGNvbnRyb2wgZmxpY2tlciB3aGVuIGNoZWNrYm94ZXMgYXJlIGRpc2FibGVkXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yNzcxXHJcblx0XHR2YXIgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaG9sZGVyKTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChpbnB1dCk7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LCBsYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cclxuXHRcdFx0aWYgKGlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdHJlbW92ZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWdmaXggaXNzdWUgMjMxODogU2hvdWxkIHJlbW92ZSBhbGwgb2xkIGxheWVycyBiZWZvcmUgcmVhZGRpbmcgbmV3IG9uZXNcclxuXHRcdGZvciAoaSA9IDA7IGkgPCByZW1vdmVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9tYXAuaGFzTGF5ZXIocmVtb3ZlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBhZGRlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX21hcC5oYXNMYXllcihhZGRlZExheWVyc1tpXSkpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIoYWRkZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX3JlZm9jdXNPbk1hcCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja0Rpc2FibGVkTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaW5wdXRzID0gdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5leHBhbmQoKTtcclxuXHR9LFxyXG5cclxuXHRfY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHJlbW92ZSBtZSBpbiAxLjEuXHJcblx0XHRyZXR1cm4gdGhpcy5jb2xsYXBzZSgpO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG5leHBvcnQgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuTGF5ZXJzLmpzIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnKydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRleHQ6ICcrJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRpdGxlOiBTdHJpbmcgPSAnWm9vbSBpbidcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UaXRsZTogJ1pvb20gaW4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRleHQ6IFN0cmluZyA9ICcmI3gyMjEyOydcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJyYjeDIyMTI7JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUaXRsZTogU3RyaW5nID0gJ1pvb20gb3V0J1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGl0bGU6ICdab29tIG91dCdcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dmFyIHpvb21OYW1lID0gJ2xlYWZsZXQtY29udHJvbC16b29tJyxcclxuXHRcdCAgICBjb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHR0aGlzLl96b29tSW5CdXR0b24gID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbUluVGV4dCwgb3B0aW9ucy56b29tSW5UaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLWluJywgIGNvbnRhaW5lciwgdGhpcy5fem9vbUluKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tT3V0VGV4dCwgb3B0aW9ucy56b29tT3V0VGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1vdXQnLCBjb250YWluZXIsIHRoaXMuX3pvb21PdXQpO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRtYXAub24oJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub2ZmKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfem9vbUluOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPCB0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tSW4odGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tT3V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9kaXNhYmxlZCAmJiB0aGlzLl9tYXAuX3pvb20gPiB0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdHRoaXMuX21hcC56b29tT3V0KHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoaHRtbCwgdGl0bGUsIGNsYXNzTmFtZSwgY29udGFpbmVyLCBmbikge1xyXG5cdFx0dmFyIGxpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogV2lsbCBmb3JjZSBzY3JlZW4gcmVhZGVycyBsaWtlIFZvaWNlT3ZlciB0byByZWFkIHRoaXMgYXMgXCJab29tIGluIC0gYnV0dG9uXCJcclxuXHRcdCAqL1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcclxuXHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihsaW5rKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIERvbUV2ZW50LnN0b3ApO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgZm4sIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gem9vbUNvbnRyb2w6IEJvb2xlYW4gPSB0cnVlXHJcbi8vIFdoZXRoZXIgYSBbem9vbSBjb250cm9sXSgjY29udHJvbC16b29tKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHpvb21Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IFpvb20oKTtcclxuXHRcdHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLlpvb21cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnpvb20ob3B0aW9uczogQ29udHJvbC5ab29tIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSB6b29tIGNvbnRyb2xcclxuZXhwb3J0IHZhciB6b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFpvb20ob3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLlpvb20uanMiLCJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3RoaXMub3B0aW9ucy5tYXhXaWR0aCwgeV0pKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHRpZiAodGhpcy5vcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU1ldHJpYyhtYXhNZXRlcnMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmltcGVyaWFsICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlSW1wZXJpYWwobWF4TWV0ZXJzKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtZXRlcnMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNZXRlcnMpLFxuXHRcdCAgICBsYWJlbCA9IG1ldGVycyA8IDEwMDAgPyBtZXRlcnMgKyAnIG0nIDogKG1ldGVycyAvIDEwMDApICsgJyBrbSc7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9tU2NhbGUsIGxhYmVsLCBtZXRlcnMgLyBtYXhNZXRlcnMpO1xuXHR9LFxuXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdHZhciBtYXhGZWV0ID0gbWF4TWV0ZXJzICogMy4yODA4Mzk5LFxuXHRcdCAgICBtYXhNaWxlcywgbWlsZXMsIGZlZXQ7XG5cblx0XHRpZiAobWF4RmVldCA+IDUyODApIHtcblx0XHRcdG1heE1pbGVzID0gbWF4RmVldCAvIDUyODA7XG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgbWlsZXMgKyAnIG1pJywgbWlsZXMgLyBtYXhNaWxlcyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBmZWV0ICsgJyBmdCcsIGZlZXQgLyBtYXhGZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlOiBmdW5jdGlvbiAoc2NhbGUsIHRleHQsIHJhdGlvKSB7XG5cdFx0c2NhbGUuc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAqIHJhdGlvKSArICdweCc7XG5cdFx0c2NhbGUuaW5uZXJIVE1MID0gdGV4dDtcblx0fSxcblxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcblx0XHR2YXIgcG93MTAgPSBNYXRoLnBvdygxMCwgKE1hdGguZmxvb3IobnVtKSArICcnKS5sZW5ndGggLSAxKSxcblx0XHQgICAgZCA9IG51bSAvIHBvdzEwO1xuXG5cdFx0ZCA9IGQgPj0gMTAgPyAxMCA6XG5cdFx0ICAgIGQgPj0gNSA/IDUgOlxuXHRcdCAgICBkID49IDMgPyAzIDpcblx0XHQgICAgZCA+PSAyID8gMiA6IDE7XG5cblx0XHRyZXR1cm4gcG93MTAgKiBkO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuc2NhbGUob3B0aW9ucz86IENvbnRyb2wuU2NhbGUgb3B0aW9ucylcbi8vIENyZWF0ZXMgYW4gc2NhbGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IHZhciBzY2FsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgU2NhbGUob3B0aW9ucyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuU2NhbGUuanMiLCJpbXBvcnQge0ltYWdlT3ZlcmxheX0gZnJvbSAnLi9JbWFnZU92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFZpZGVvT3ZlcmxheVxyXG4gKiBAYWthIEwuVmlkZW9PdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbWFnZU92ZXJsYXlcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgdmlkZW8gcGxheWVyIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXHJcbiAqXHJcbiAqIEEgdmlkZW8gb3ZlcmxheSB1c2VzIHRoZSBbYDx2aWRlbz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8pXHJcbiAqIEhUTUw1IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB2aWRlb1VybCA9ICdodHRwczovL3d3dy5tYXBib3guY29tL2JpdGVzLzAwMTg4L3BhdHJpY2lhX25hc2Eud2VibScsXHJcbiAqIFx0dmlkZW9Cb3VuZHMgPSBbWyAzMiwgLTEzMF0sIFsgMTMsIC0xMDBdXTtcclxuICogTC5WaWRlb092ZXJsYXkodmlkZW9VcmwsIHZpZGVvQm91bmRzICkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBWaWRlb092ZXJsYXkgPSBJbWFnZU92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFZpZGVvT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvcGxheTogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkZWQuXHJcblx0XHRhdXRvcGxheTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxvb3A6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyB3aWxsIGxvb3AgYmFjayB0byB0aGUgYmVnaW5uaW5nIHdoZW4gcGxheWVkLlxyXG5cdFx0bG9vcDogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ1ZJREVPJztcclxuXHRcdHZhciB2aWQgPSB0aGlzLl9pbWFnZSA9IHdhc0VsZW1lbnRTdXBwbGllZCA/IHRoaXMuX3VybCA6IERvbVV0aWwuY3JlYXRlKCd2aWRlbycpO1xyXG5cclxuXHRcdHZpZC5jbGFzcyA9IHZpZC5jbGFzcyB8fCAnJztcclxuXHRcdHZpZC5jbGFzcyArPSAnbGVhZmxldC1pbWFnZS1sYXllciAnICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnIDogJycpO1xyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcblx0XHR2aWQub25sb2FkZWRkYXRhID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICghVXRpbC5pc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi92ZWN0b3IvUGF0aCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9wdXBcclxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcclxuICogQGFrYSBMLlBvcHVwXHJcbiAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICogb3BlbiBwb3B1cHMgd2hpbGUgbWFraW5nIHN1cmUgdGhhdCBvbmx5IG9uZSBwb3B1cCBpcyBvcGVuIGF0IG9uZSB0aW1lXHJcbiAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICogYGBgXHJcbiAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gKiBIZXJlJ3MgYSBtb3JlIGNvbXBsaWNhdGVkIHdheSB0byBvcGVuIGEgcG9wdXAgb24gYSBtYXA6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb3B1cCA9IEwucG9wdXAoKVxyXG4gKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxyXG4gKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICogXHQub3Blbk9uKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbmV4cG9ydCB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcblx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcblx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG5cdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIHNhbWUgYXMgYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcblx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgIT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHdyYXBwZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuXHRcdERvbUV2ZW50Lm9uKHdyYXBwZXIsICdjb250ZXh0bWVudScsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBEb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcclxuXHJcblx0XHRcdERvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuIHx8ICh0aGlzLl9tYXAuX3BhbkFuaW0gJiYgdGhpcy5fbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KERvbVV0aWwuZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFBvcHVwKSB7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHBvcHVwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xyXG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcclxuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XHJcblx0XHRcdGxheWVyID0gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXRsbmcpIHtcclxuXHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyID8gbGF5ZXIuZ2V0Q2VudGVyKCkgOiBsYXllci5nZXRMYXRMbmcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdC8vIHNldCBwb3B1cCBzb3VyY2UgdG8gdGhpcyBsYXllclxyXG5cdFx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gbGF5ZXI7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIHBvcHVwIChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcclxuXHRcdFx0dGhpcy5fcG9wdXAudXBkYXRlKCk7XHJcblxyXG5cdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXHJcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXAsIGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuX2Nsb3NlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvZ2dsZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxyXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9tYXApIHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCh0YXJnZXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcHJldmVudCBtYXAgY2xpY2tcclxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XHJcblxyXG5cdFx0Ly8gaWYgdGhpcyBpbmhlcml0cyBmcm9tIFBhdGggaXRzIGEgdmVjdG9yIGFuZCB3ZSBjYW4ganVzdFxyXG5cdFx0Ly8gb3BlbiB0aGUgcG9wdXAgYXQgdGhlIG5ldyBsb2NhdGlvblxyXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgUGF0aCkge1xyXG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChlLmxheWVyIHx8IGUudGFyZ2V0LCBlLmxhdGxuZyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlcndpc2UgdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxyXG5cdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG5cdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkgJiYgdGhpcy5fcG9wdXAuX3NvdXJjZSA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9wZW5Qb3B1cChsYXllciwgZS5sYXRsbmcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9Qb3B1cC5qcyIsIlxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBUb29sdGlwXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxuICogQGFrYSBMLlRvb2x0aXBcbiAqIFVzZWQgdG8gZGlzcGxheSBzbWFsbCB0ZXh0cyBvbiB0b3Agb2YgbWFwIGxheWVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogTm90ZSBhYm91dCB0b29sdGlwIG9mZnNldC4gTGVhZmxldCB0YWtlcyB0d28gb3B0aW9ucyBpbiBjb25zaWRlcmF0aW9uXG4gKiBmb3IgY29tcHV0aW5nIHRvb2x0aXAgb2Zmc2V0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5leHBvcnQgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGV2ZW50cy5cblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0dGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGlzIG9wZW5lZCBpbiB0aGUgbWFwLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaW4gdGhlIG1hcCBpcyBjbG9zZWQuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSk7XG5cblx0XHRpZiAodGhpcy5fc291cmNlKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAoQnJvd3Nlci50b3VjaCAmJiAhdGhpcy5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VUb29sdGlwKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcblx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cdH0sXG5cblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge30sXG5cblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge30sXG5cblx0X3NldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLFxuXHRcdCAgICBjZW50ZXJQb2ludCA9IG1hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG1hcC5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvb2x0aXBQb2ludCA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChwb3MpLFxuXHRcdCAgICBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLFxuXHRcdCAgICB0b29sdGlwV2lkdGggPSBjb250YWluZXIub2Zmc2V0V2lkdGgsXG5cdFx0ICAgIHRvb2x0aXBIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcblxuXHRcdGlmIChkaXJlY3Rpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRwb3MgPSBwb3MuYWRkKHRvUG9pbnQoLXRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgLXRvb2x0aXBIZWlnaHQgKyBvZmZzZXQueSArIGFuY2hvci55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdib3R0b20nKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggLyAyIC0gb2Zmc2V0LngsIC1vZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnY2VudGVyJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55ICsgb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyB8fCBkaXJlY3Rpb24gPT09ICdhdXRvJyAmJiB0b29sdGlwUG9pbnQueCA8IGNlbnRlclBvaW50LngpIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0XHRwb3MgPSBwb3MuYWRkKHRvUG9pbnQob2Zmc2V0LnggKyBhbmNob3IueCwgYW5jaG9yLnkgLSB0b29sdGlwSGVpZ2h0IC8gMiArIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0Jztcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCArIGFuY2hvci54IC0gb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgLSBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXJpZ2h0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtbGVmdCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXRvcCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWJvdHRvbScpO1xuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLScgKyBkaXJlY3Rpb24pO1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBwb3MpO1xuXHR9LFxuXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlcik7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgdG9vbHRpcCBvbiB0aGUgc291cmNlIGxheWVyP1xuXHRcdHJldHVybiB0b1BvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IgJiYgIXRoaXMub3B0aW9ucy5zdGlja3kgPyB0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3IoKSA6IFswLCAwXSk7XG5cdH1cblxufSk7XG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuLy8gQGZhY3RvcnkgTC50b29sdGlwKG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxuLy8gSW5zdGFudGlhdGVzIGEgVG9vbHRpcCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbmV4cG9ydCB2YXIgdG9vbHRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcblx0cmV0dXJuIG5ldyBUb29sdGlwKG9wdGlvbnMsIHNvdXJjZSk7XG59O1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuTWFwLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCB0b29sdGlwLlxuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBDcmVhdGVzIGEgdG9vbHRpcCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbiBpdC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRpZiAoISh0b29sdGlwIGluc3RhbmNlb2YgVG9vbHRpcCkpIHtcblx0XHRcdHRvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zKS5zZXRDb250ZW50KHRvb2x0aXApO1xuXHRcdH1cblxuXHRcdGlmIChsYXRsbmcpIHtcblx0XHRcdHRvb2x0aXAuc2V0TGF0TG5nKGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIodG9vbHRpcCkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKHRvb2x0aXApO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKHRvb2x0aXA/OiBUb29sdGlwKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodG9vbHRpcCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgVG9vbHRpcCkge1xuXHRcdFx0VXRpbC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgb3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucygpO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQgJiYgdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKSkge1xuXHRcdFx0dGhpcy5vcGVuVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgdW5iaW5kVG9vbHRpcCgpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIHRvb2x0aXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kVG9vbHRpcGAuXG5cdHVuYmluZFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnModHJ1ZSk7XG5cdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9pbml0VG9vbHRpcEludGVyYWN0aW9uczogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdGlmICghcmVtb3ZlICYmIHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJyxcblx0XHQgICAgZXZlbnRzID0ge1xuXHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlVG9vbHRpcCxcblx0XHRcdG1vdmU6IHRoaXMuX21vdmVUb29sdGlwXG5cdFx0ICAgIH07XG5cdFx0aWYgKCF0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMubW91c2VvdmVyID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHRldmVudHMubW91c2VvdXQgPSB0aGlzLmNsb3NlVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5KSB7XG5cdFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUgPSB0aGlzLl9tb3ZlVG9vbHRpcDtcblx0XHRcdH1cblx0XHRcdGlmIChCcm93c2VyLnRvdWNoKSB7XG5cdFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0fVxuXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG5cdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWNlZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcblx0XHRcdGxheWVyID0gdGhpcztcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbGF0bG5nKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBzb3VyY2UgdG8gdGhpcyBsYXllclxuXHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgdG9vbHRpcCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL1Rvb2x0aXAuanMiLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5leHBvcnQge2ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XG5JY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcbmV4cG9ydCB7SWNvbn07XG5cbmV4cG9ydCB7RGl2SWNvbiwgZGl2SWNvbn0gZnJvbSAnLi9EaXZJY29uJztcbmV4cG9ydCB7TWFya2VyLCBtYXJrZXJ9IGZyb20gJy4vTWFya2VyJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgRGl2SWNvblxuICogQGFrYSBMLkRpdkljb25cbiAqIEBpbmhlcml0cyBJY29uXG4gKlxuICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gKlxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAqL1xuXG5leHBvcnQgdmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gcG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG5cdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9pbmRleC5qcyIsImV4cG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuZXhwb3J0IHtDYW52YXMsIGNhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtTVkcsIGNyZWF0ZSwgcG9pbnRzVG9QYXRoLCBzdmd9IGZyb20gJy4vU1ZHJztcblNWRy5jcmVhdGUgPSBjcmVhdGU7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuZXhwb3J0IHtTVkcsIHN2Z307XG5pbXBvcnQgJy4vUmVuZGVyZXIuZ2V0UmVuZGVyZXInO1x0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBuZWVkZWQgYmVjYXVzZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuZXhwb3J0IHtDaXJjbGVNYXJrZXIsIGNpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuZXhwb3J0IHtDaXJjbGUsIGNpcmNsZX0gZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0IHtQb2x5bGluZSwgcG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuZXhwb3J0IHtQb2x5Z29uLCBwb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuZXhwb3J0IHtSZWN0YW5nbGUsIHJlY3RhbmdsZX0gZnJvbSAnLi9SZWN0YW5nbGUnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvaW5kZXguanMiLCJpbXBvcnQge1BvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZXRhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxuZXhwb3J0IHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG5cdH0sXG5cblx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdGxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuXHRcdF07XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9SZWN0YW5nbGUuanMiLCJpbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuXG4vKlxuICogVGhhbmtzIHRvIERtaXRyeSBCYXJhbm92c2t5IGFuZCBoaXMgUmFwaGFlbCBsaWJyYXJ5IGZvciBpbnNwaXJhdGlvbiFcbiAqL1xuXG5cbmV4cG9ydCB2YXIgdm1sQ3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxsdm1sOicgKyBuYW1lICsgJyBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fVxufSkoKTtcblxuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0IFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW4gdGhpcyBjYXNlLlxuICpcbiAqIFZNTCB3YXMgZGVwcmVjYXRlZCBpbiAyMDEyLCB3aGljaCBtZWFucyBWTUwgZnVuY3Rpb25hbGl0eSBleGlzdHMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggb2xkIHZlcnNpb25zIG9mIEludGVybmV0IEV4cGxvcmVyLlxuICovXG5cbi8vIG1peGluIHRvIHJlZGVmaW5lIHNvbWUgU1ZHIG1ldGhvZHMgdG8gaGFuZGxlIFZNTCBzeW50YXggd2hpY2ggaXMgc2ltaWxhciBidXQgd2l0aCBzb21lIGRpZmZlcmVuY2VzXG5leHBvcnQgdmFyIHZtbE1peGluID0ge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXZtbC1jb250YWluZXInKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciA9IHZtbENyZWF0ZSgnc2hhcGUnKTtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IHZtbENyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0RG9tVXRpbC5yZW1vdmUoY29udGFpbmVyKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChjb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHN0cm9rZSA9IGxheWVyLl9zdHJva2UsXG5cdFx0ICAgIGZpbGwgPSBsYXllci5fZmlsbCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cblx0XHRjb250YWluZXIuc3Ryb2tlZCA9ICEhb3B0aW9ucy5zdHJva2U7XG5cdFx0Y29udGFpbmVyLmZpbGxlZCA9ICEhb3B0aW9ucy5maWxsO1xuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRpZiAoIXN0cm9rZSkge1xuXHRcdFx0XHRzdHJva2UgPSBsYXllci5fc3Ryb2tlID0gdm1sQ3JlYXRlKCdzdHJva2UnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xuXHRcdFx0c3Ryb2tlLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0ICsgJ3B4Jztcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRzdHJva2Uub3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSBVdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gdm1sQ3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X2JyaW5nVG9CYWNrOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvQmFjayhsYXllci5fY29udGFpbmVyKTtcblx0fVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5WTUwuanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vLi4vbWFwL01hcCc7XG5pbXBvcnQge0NhbnZhcywgY2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge1NWRywgc3ZnfSBmcm9tICcuL1NWRyc7XG5cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBtZXRob2QgZ2V0UmVuZGVyZXIobGF5ZXI6IFBhdGgpOiBSZW5kZXJlclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlblxuXHQvLyBgUGF0aGAuIEl0IHdpbGwgZW5zdXJlIHRoYXQgdGhlIGByZW5kZXJlcmAgb3B0aW9ucyBvZiB0aGUgbWFwIGFuZCBwYXRoc1xuXHQvLyBhcmUgcmVzcGVjdGVkLCBhbmQgdGhhdCB0aGUgcmVuZGVyZXJzIGRvIGV4aXN0IG9uIHRoZSBtYXAuXG5cdGdldFJlbmRlcmVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBAbmFtZXNwYWNlIFBhdGg7IEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyXG5cdFx0Ly8gVXNlIHRoaXMgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCBmb3IgdGhpcyBwYXRoLiBUYWtlc1xuXHRcdC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWFwJ3MgW2RlZmF1bHQgcmVuZGVyZXJdKCNtYXAtcmVuZGVyZXIpLlxuXHRcdHZhciByZW5kZXJlciA9IGxheWVyLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fZ2V0UGFuZVJlbmRlcmVyKGxheWVyLm9wdGlvbnMucGFuZSkgfHwgdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX3JlbmRlcmVyO1xuXG5cdFx0aWYgKCFyZW5kZXJlcikge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHRcdC8vIFdoZXRoZXIgYFBhdGhgcyBzaG91bGQgYmUgcmVuZGVyZWQgb24gYSBgQ2FudmFzYCByZW5kZXJlci5cblx0XHRcdC8vIEJ5IGRlZmF1bHQsIGFsbCBgUGF0aGBzIGFyZSByZW5kZXJlZCBpbiBhIGBTVkdgIHJlbmRlcmVyLlxuXHRcdFx0cmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciA9ICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcygpKSB8fCBzdmcoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSAoU1ZHICYmIHN2Zyh7cGFuZTogbmFtZX0pKSB8fCAoQ2FudmFzICYmIGNhbnZhcyh7cGFuZTogbmFtZX0pKTtcblx0XHRcdHRoaXMuX3BhbmVSZW5kZXJlcnNbbmFtZV0gPSByZW5kZXJlcjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmdldFJlbmRlcmVyLmpzIiwiaW1wb3J0IHsgRWxlbWVudCBhcyBQb2x5bWVyRWxlbWVudCB9IGZyb20gJy4uLy4uL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IERvbVJlcGVhdCB9IGZyb20gJy4uLy4uL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1yZXBlYXQuanMnO1xuXG5pbXBvcnQgeyB3bXMgYXMgV01TIH0gZnJvbSAnLi9sZWFmbGV0Lndtcy5qcyc7XG5cbmltcG9ydCAnLi9sZWFmbGV0LXdtcy1sYXllci5qcyc7XG5cblxuZXhwb3J0IGNsYXNzIExlYWZsZXRXTVNHcm91cCBleHRlbmRzIFBvbHltZXJFbGVtZW50IHtcbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAvLyByZXR1cm4gYFxuICAgIC8vICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwie3tzdWJMYXllcnN9fVwiPlxuICAgIC8vICAgICA8bGVhZmxldC13bXMtbGF5ZXIgd21zLXNvdXJjZT1cIltbd21zU291cmNlXV1cIiBsYXllcj1cIltbaXRlbV1dXCI+PC9sZWFmbGV0LXdtcy1sYXllcj5cbiAgICAvLyAgIDwvdGVtcGxhdGU+XG4gICAgLy8gYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFwOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfbWFwU2V0J1xuICAgICAgfSxcblxuICAgICAgc291cmNlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfc291cmNlQ2hhbmdlJyxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGF5ZXJzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICBvYnNlcnZlcjogJ19sYXllcnNDaGFuZ2UnLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG5cbiAgICAgIHRyYW5zcGFyZW50OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBmb3JtYXQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ2ltYWdlL3BuZycsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGlkZW50aWZ5OiBCb29sZWFuLFxuICAgICAgbWluWm9vbTogTnVtYmVyLFxuICAgICAgbWF4Wm9vbTogTnVtYmVyLFxuICAgICAgYXR0cmlidXRpb246IFN0cmluZyxcbiAgICAgIFxuICAgICAgd21zU291cmNlOiBPYmplY3QsXG4gICAgICBzdWJMYXllcnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgX3NvdXJjZUNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy53bXNTb3VyY2UpIHRoaXMud21zU291cmNlLnJlbW92ZUZyb20odGhpcy5tYXApO1xuXG4gICAgdGhpcy5fd21zT3B0aW9ucyA9IHtcbiAgICAgIHRyYW5zcGFyZW50OiB0aGlzLnRyYW5zcGFyZW50LFxuICAgICAgZm9ybWF0OiB0aGlzLmZvcm1hdCxcbiAgICAgIGlkZW50aWZ5OiB0aGlzLmlkZW50aWZ5LFxuICAgICAgbWluWm9vbTogdGhpcy5taW5ab29tLFxuICAgICAgbWF4Wm9vbTogdGhpcy5tYXhab29tLFxuICAgICAgYXR0cmlidXRpb246IHRoaXMuYXR0cmlidXRpb25cbiAgICB9O1xuXG4gICAgdGhpcy53bXNTb3VyY2UgPSBuZXcgV01TLlNvdXJjZSh0aGlzLnNvdXJjZSwgdGhpcy5fd21zT3B0aW9ucyk7XG4gICAgaWYgKHRoaXMubWFwKSB0aGlzLndtc1NvdXJjZS5hZGRUbyh0aGlzLm1hcCk7XG5cbiAgICB0aGlzLl9sYXllcnNDaGFuZ2UoKTtcbiAgfVxuXG4gIF9sYXllcnNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgLy8gRklYTUU6IHVzZSBwcm9taXNlIGluc3RlYWQgcGxlYXNlXG4gICAgaWYgKHRoaXMud21zU291cmNlKSB0aGlzLndtc1NvdXJjZS5yZXBsYWNlQWxsU3ViTGF5ZXJzKHRoaXMubGF5ZXJzKTtcbiAgfVxuXG4gIF9tYXBTZXQoKSB7XG4gICAgdGhpcy53bXNTb3VyY2UuYWRkVG8odGhpcy5tYXApOyAvLyBGSVhNRTogdGhlcmUgY291bGQgYmUgYSByYWNlIGNvbmRpdGlvbiBoZXJlIGZvciB0aGlzLm1hcFxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC13bXMtZ3JvdXAnLCBMZWFmbGV0V01TR3JvdXApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0LXdtcy1ncm91cC5qcyIsIi8qIVxuICogbGVhZmxldC53bXMuanNcbiAqIEEgY29sbGVjdGlvbiBvZiBMZWFmbGV0IHV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIFdlYiBNYXBwaW5nIHNlcnZpY2VzLlxuICogKGMpIDIwMTQtMjAxNiwgSG91c3RvbiBFbmdpbmVlcmluZywgSW5jLlxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCB7IEltYWdlT3ZlcmxheSB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyc7XG5pbXBvcnQgeyBUaWxlTGF5ZXJXTVMsIHRpbGVMYXllcldNUyB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyc7XG5pbXBvcnQgeyBFUFNHNDMyNiB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0c0MzI2LmpzJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvY29yZS9VdGlsLmpzJztcblxuZXhwb3J0IHZhciB3bXMgPSB7fTtcblxuLypcbiAqIHdtcy5Tb3VyY2VcbiAqIFRoZSBTb3VyY2Ugb2JqZWN0IG1hbmFnZXMgYSBzaW5nbGUgV01TIGNvbm5lY3Rpb24uICBNdWx0aXBsZSBcImxheWVyc1wiIGNhbiBiZVxuICogY3JlYXRlZCB3aXRoIHRoZSBnZXRMYXllciBmdW5jdGlvbiwgYnV0IGEgc2luZ2xlIHJlcXVlc3Qgd2lsbCBiZSBzZW50IGZvclxuICogZWFjaCBpbWFnZSB1cGRhdGUuICBDYW4gYmUgdXNlZCBpbiBub24tdGlsZWQgXCJvdmVybGF5XCIgbW9kZSAoZGVmYXVsdCksIG9yXG4gKiB0aWxlZCBtb2RlLCB2aWEgYW4gaW50ZXJuYWwgd21zLk92ZXJsYXkgb3Igd21zLlRpbGVMYXllciwgcmVzcGVjdGl2ZWx5LlxuICovXG53bXMuU291cmNlID0gTGF5ZXIuZXh0ZW5kKHtcbiAgICAnb3B0aW9ucyc6IHtcbiAgICAgICAgJ3VudGlsZWQnOiB0cnVlLFxuICAgICAgICAnaWRlbnRpZnknOiB0cnVlXG4gICAgfSxcblxuICAgICdpbml0aWFsaXplJzogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgIFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aWxlZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVudGlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuX3N1YkxheWVycyA9IHt9O1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gdGhpcy5jcmVhdGVPdmVybGF5KHRoaXMub3B0aW9ucy51bnRpbGVkKTtcbiAgICB9LFxuXG4gICAgJ2NyZWF0ZU92ZXJsYXknOiBmdW5jdGlvbih1bnRpbGVkKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvdmVybGF5IHdpdGggYWxsIG9wdGlvbnMgb3RoZXIgdGhhbiB1bnRpbGVkICYgaWRlbnRpZnlcbiAgICAgICAgdmFyIG92ZXJsYXlPcHRpb25zID0ge307XG4gICAgICAgIGZvciAodmFyIG9wdCBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHQgIT0gJ3VudGlsZWQnICYmIG9wdCAhPSAnaWRlbnRpZnknKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheU9wdGlvbnNbb3B0XSA9IHRoaXMub3B0aW9uc1tvcHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnRpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gd21zLm92ZXJsYXkodGhpcy5fdXJsLCBvdmVybGF5T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd21zLnRpbGVMYXllcih0aGlzLl91cmwsIG92ZXJsYXlPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnb25BZGQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoT3ZlcmxheSgpO1xuICAgIH0sXG5cbiAgICAnb25SZW1vdmUnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXApIHRoaXMuX292ZXJsYXkucmVtb3ZlRnJvbSh0aGlzLl9tYXApO1xuICAgIH0sXG5cbiAgICAnZ2V0RXZlbnRzJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWRlbnRpZnkpIHtcbiAgICAgICAgICAgIHJldHVybiB7J2NsaWNrJzogdGhpcy5pZGVudGlmeX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3NldE9wYWNpdHknOiBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICBpZiAodGhpcy5fb3ZlcmxheSkge1xuICAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgICdicmluZ1RvQmFjayc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgdGhpcy5vcHRpb25zLmlzQmFjayA9IHRydWU7XG4gICAgICAgICBpZiAodGhpcy5fb3ZlcmxheSkge1xuICAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuYnJpbmdUb0JhY2soKTtcbiAgICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2JyaW5nVG9Gcm9udCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgdGhpcy5vcHRpb25zLmlzQmFjayA9IGZhbHNlO1xuICAgICAgICAgaWYgKHRoaXMuX292ZXJsYXkpIHtcbiAgICAgICAgICAgICB0aGlzLl9vdmVybGF5LmJyaW5nVG9Gcm9udCgpO1xuICAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0TGF5ZXInOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB3bXMubGF5ZXIodGhpcywgbmFtZSk7XG4gICAgfSxcblxuICAgICdnZXRTdWJMYXllcnMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJMYXllcnM7XG4gICAgfSxcblxuICAgICdhZGRTdWJMYXllcic6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fc3ViTGF5ZXJzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWZyZXNoT3ZlcmxheSgpO1xuICAgIH0sXG5cbiAgICAncmVtb3ZlU3ViTGF5ZXInOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJMYXllcnNbbmFtZV07XG4gICAgICAgIHRoaXMucmVmcmVzaE92ZXJsYXkoKTtcbiAgICB9LFxuXG4gICAgLyogRWZmaWNpZW50IHdheSB0byBzd2FwIG91dCBhbGwgc3ViIGxheWVycyAqL1xuICAgICdyZXBsYWNlQWxsU3ViTGF5ZXJzJzogZnVuY3Rpb24gKG5ld1N1YkxheWVycykge1xuICAgICAgICB0aGlzLl9zdWJMYXllcnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTdWJMYXllcnMubGVuZ3RoOyBpKyspIHRoaXMuX3N1YkxheWVyc1tuZXdTdWJMYXllcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWZyZXNoT3ZlcmxheSgpO1xuICAgIH0sXG5cbiAgICAncmVmcmVzaE92ZXJsYXknOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN1YkxheWVycyA9IE9iamVjdC5rZXlzKHRoaXMuX3N1YkxheWVycykuam9pbihcIixcIik7XG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWJMYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXkucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5LnNldFBhcmFtcyh7J2xheWVycyc6IHN1YkxheWVyc30pO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5hZGRUbyh0aGlzLl9tYXApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdpZGVudGlmeSc6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAvLyBJZGVudGlmeSBtYXAgZmVhdHVyZXMgaW4gcmVzcG9uc2UgdG8gbWFwIGNsaWNrcy4gVG8gY3VzdG9taXplIHRoaXNcbiAgICAgICAgLy8gYmVoYXZpb3IsIGNyZWF0ZSBhIGNsYXNzIGV4dGVuZGluZyB3bXMuU291cmNlIGFuZCBvdmVycmlkZSBvbmUgb3JcbiAgICAgICAgLy8gbW9yZSBvZiB0aGUgZm9sbG93aW5nIGhvb2sgZnVuY3Rpb25zLlxuXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmdldElkZW50aWZ5TGF5ZXJzKCk7XG4gICAgICAgIGlmICghbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0RmVhdHVyZUluZm8oXG4gICAgICAgICAgICBldnQuY29udGFpbmVyUG9pbnQsIGV2dC5sYXRsbmcsIGxheWVycyxcbiAgICAgICAgICAgIHRoaXMuc2hvd0ZlYXR1cmVJbmZvXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgICdnZXRGZWF0dXJlSW5mbyc6IGZ1bmN0aW9uKHBvaW50LCBsYXRsbmcsIGxheWVycywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gUmVxdWVzdCBXTVMgR2V0RmVhdHVyZUluZm8gYW5kIGNhbGwgY2FsbGJhY2sgd2l0aCByZXN1bHRzXG4gICAgICAgIC8vIChzcGxpdCBmcm9tIGlkZW50aWZ5KCkgdG8gZmFjaWxpYXRlIHVzZSBvdXRzaWRlIG9mIG1hcCBldmVudHMpXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldEZlYXR1cmVJbmZvUGFyYW1zKHBvaW50LCBsYXllcnMpLFxuICAgICAgICAgICAgdXJsID0gdGhpcy5fdXJsICsgVXRpbC5nZXRQYXJhbVN0cmluZyhwYXJhbXMsIHRoaXMuX3VybCk7XG5cbiAgICAgICAgdGhpcy5zaG93V2FpdGluZygpO1xuICAgICAgICB0aGlzLmFqYXgodXJsLCBkb25lKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlV2FpdGluZygpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnBhcnNlRmVhdHVyZUluZm8ocmVzdWx0LCB1cmwpO1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBsYXRsbmcsIHRleHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdhamF4JzogZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgICAgICB3bXMuYWpheC5jYWxsKHRoaXMsIHVybCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAnZ2V0SWRlbnRpZnlMYXllcnMnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSG9vayB0byBkZXRlcm1pbmUgd2hpY2ggbGF5ZXJzIHRvIGlkZW50aWZ5XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWRlbnRpZnlMYXllcnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlkZW50aWZ5TGF5ZXJzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3ViTGF5ZXJzKTtcbiAgICAgfSxcblxuICAgICdnZXRGZWF0dXJlSW5mb1BhcmFtcyc6IGZ1bmN0aW9uKHBvaW50LCBsYXllcnMpIHtcbiAgICAgICAgLy8gSG9vayB0byBnZW5lcmF0ZSBwYXJhbWV0ZXJzIGZvciBXTVMgc2VydmljZSBHZXRGZWF0dXJlSW5mbyByZXF1ZXN0XG4gICAgICAgIHZhciB3bXNQYXJhbXMsIG92ZXJsYXk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudW50aWxlZCkge1xuICAgICAgICAgICAgLy8gVXNlIGV4aXN0aW5nIG92ZXJsYXlcbiAgICAgICAgICAgIHdtc1BhcmFtcyA9IHRoaXMuX292ZXJsYXkud21zUGFyYW1zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG92ZXJsYXkgaW5zdGFuY2UgdG8gbGV2ZXJhZ2UgdXBkYXRlV21zUGFyYW1zXG4gICAgICAgICAgICBvdmVybGF5ID0gdGhpcy5jcmVhdGVPdmVybGF5KHRydWUpO1xuICAgICAgICAgICAgb3ZlcmxheS51cGRhdGVXbXNQYXJhbXModGhpcy5fbWFwKTtcbiAgICAgICAgICAgIHdtc1BhcmFtcyA9IG92ZXJsYXkud21zUGFyYW1zO1xuICAgICAgICAgICAgd21zUGFyYW1zLmxheWVycyA9IGxheWVycy5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZm9QYXJhbXMgPSB7XG4gICAgICAgICAgICAncmVxdWVzdCc6ICdHZXRGZWF0dXJlSW5mbycsXG4gICAgICAgICAgICAncXVlcnlfbGF5ZXJzJzogbGF5ZXJzLmpvaW4oJywnKSxcbiAgICAgICAgICAgICdYJzogTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICAgICAgICAgICdZJzogTWF0aC5yb3VuZChwb2ludC55KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVXRpbC5leHRlbmQoe30sIHdtc1BhcmFtcywgaW5mb1BhcmFtcyk7XG4gICAgfSxcblxuICAgICdwYXJzZUZlYXR1cmVJbmZvJzogZnVuY3Rpb24ocmVzdWx0LCB1cmwpIHtcbiAgICAgICAgLy8gSG9vayB0byBoYW5kbGUgcGFyc2luZyBBSkFYIHJlc3BvbnNlXG4gICAgICAgIGlmIChyZXN1bHQgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAvLyBBSkFYIGZhaWxlZCwgcG9zc2libHkgZHVlIHRvIENPUlMgaXNzdWVzLlxuICAgICAgICAgICAgLy8gVHJ5IGxvYWRpbmcgY29udGVudCBpbiA8aWZyYW1lPi5cbiAgICAgICAgICAgIHJlc3VsdCA9IFwiPGlmcmFtZSBzcmM9J1wiICsgdXJsICsgXCInIHN0eWxlPSdib3JkZXI6bm9uZSc+XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgJ3Nob3dGZWF0dXJlSW5mbyc6IGZ1bmN0aW9uKGxhdGxuZywgaW5mbykge1xuICAgICAgICAvLyBIb29rIHRvIGhhbmRsZSBkaXNwbGF5aW5nIHBhcnNlZCBBSkFYIHJlc3BvbnNlIHRvIHRoZSB1c2VyXG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLm9wZW5Qb3B1cChpbmZvLCBsYXRsbmcpO1xuICAgIH0sXG5cbiAgICAnc2hvd1dhaXRpbmcnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSG9vayB0byBjdXN0b21pemUgQUpBWCB3YWl0IGFuaW1hdGlvblxuICAgICAgICBpZiAoIXRoaXMuX21hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gXCJwcm9ncmVzc1wiO1xuICAgIH0sXG5cbiAgICAnaGlkZVdhaXRpbmcnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSG9vayB0byByZW1vdmUgQUpBWCB3YWl0IGFuaW1hdGlvblxuICAgICAgICBpZiAoIXRoaXMuX21hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgfVxufSk7XG5cbndtcy5zb3VyY2UgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHdtcy5Tb3VyY2UodXJsLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gKiBMYXllclxuICogTGVhZmxldCBcImxheWVyXCIgd2l0aCBhbGwgYWN0dWFsIHJlbmRlcmluZyBoYW5kbGVkIHZpYSBhbiB1bmRlcmx5aW5nIFNvdXJjZVxuICogb2JqZWN0LiAgQ2FuIGJlIGNhbGxlZCBkaXJlY3RseSB3aXRoIGEgVVJMIHRvIGF1dG9tYXRpY2FsbHkgY3JlYXRlIG9yIHJldXNlXG4gKiBhbiBleGlzdGluZyBTb3VyY2UuICBOb3RlIHRoYXQgdGhlIGF1dG8tc291cmNlIGZlYXR1cmUgZG9lc24ndCB3b3JrIHdlbGwgaW5cbiAqIG11bHRpLW1hcCBlbnZpcm9ubWVudHM7IHNvIGZvciBiZXN0IHJlc3VsdHMsIGNyZWF0ZSBhIFNvdXJjZSBmaXJzdCBhbmQgdXNlXG4gKiBnZXRMYXllcigpIHRvIHJldHJpZXZlIHdtcy5MYXllciBpbnN0YW5jZXMuXG4gKi9cblxud21zLkxheWVyID0gTGF5ZXIuZXh0ZW5kKHtcbiAgICAnaW5pdGlhbGl6ZSc6IGZ1bmN0aW9uKHNvdXJjZSwgbGF5ZXJOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFzb3VyY2UuYWRkU3ViTGF5ZXIpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBzb3VyY2UgaXMgYSBVUkxcbiAgICAgICAgICAgIHNvdXJjZSA9IHdtcy5nZXRTb3VyY2VGb3JVcmwoc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX25hbWUgPSBsYXllck5hbWU7XG4gICAgfSxcbiAgICAnb25BZGQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2UuX21hcClcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5hZGRUbyh0aGlzLl9tYXApO1xuICAgICAgICB0aGlzLl9zb3VyY2UuYWRkU3ViTGF5ZXIodGhpcy5fbmFtZSk7XG4gICAgfSxcbiAgICAnb25SZW1vdmUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc291cmNlLnJlbW92ZVN1YkxheWVyKHRoaXMuX25hbWUpO1xuICAgIH0sXG4gICAgJ3NldE9wYWNpdHknOiBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH0sXG4gICAgJ2JyaW5nVG9CYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5icmluZ1RvQmFjaygpO1xuICAgIH0sXG4gICAgJ2JyaW5nVG9Gcm9udCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zb3VyY2UuYnJpbmdUb0Zyb250KCk7XG4gICAgfVxufSk7XG5cbndtcy5sYXllciA9IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgd21zLkxheWVyKHNvdXJjZSwgb3B0aW9ucyk7XG59O1xuXG4vLyBDYWNoZSBvZiBzb3VyY2VzIGZvciB1c2Ugd2l0aCB3bXMuTGF5ZXIgYXV0by1zb3VyY2Ugb3B0aW9uXG53bXMuc291cmNlcyA9IHt9O1xud21zLmdldFNvdXJjZUZvclVybCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgIGlmICghd21zLnNvdXJjZXNbdXJsXSkge1xuICAgICAgICB3bXMuc291cmNlc1t1cmxdID0gd21zLnNvdXJjZSh1cmwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gd21zLnNvdXJjZXNbdXJsXTtcbn07XG5cblxuLy8gQ29weSB0aWxlZCBXTVMgbGF5ZXIgZnJvbSBsZWFmbGV0IGNvcmUsIGluIGNhc2Ugd2UgbmVlZCB0byBzdWJjbGFzcyBpdCBsYXRlclxud21zLlRpbGVMYXllciA9IFRpbGVMYXllcldNUztcbndtcy50aWxlTGF5ZXIgPSB0aWxlTGF5ZXJXTVM7XG5cbi8qXG4gKiB3bXMuT3ZlcmxheTpcbiAqIFwiU2luZ2xlIFRpbGVcIiBXTVMgaW1hZ2Ugb3ZlcmxheSB0aGF0IHVwZGF0ZXMgd2l0aCBtYXAgY2hhbmdlcy5cbiAqIFBvcnRpb25zIG9mIHdtcy5PdmVybGF5IGFyZSBkaXJlY3RseSBleHRyYWN0ZWQgZnJvbSBMLlRpbGVMYXllci5XTVMuXG4gKiBTZWUgTGVhZmxldCBsaWNlbnNlLlxuICovXG53bXMuT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XG4gICAgJ2RlZmF1bHRXbXNQYXJhbXMnOiB7XG4gICAgICAgICdzZXJ2aWNlJzogJ1dNUycsXG4gICAgICAgICdyZXF1ZXN0JzogJ0dldE1hcCcsXG4gICAgICAgICd2ZXJzaW9uJzogJzEuMS4xJyxcbiAgICAgICAgJ2xheWVycyc6ICcnLFxuICAgICAgICAnc3R5bGVzJzogJycsXG4gICAgICAgICdmb3JtYXQnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICd0cmFuc3BhcmVudCc6IGZhbHNlXG4gICAgfSxcblxuICAgICdvcHRpb25zJzoge1xuICAgICAgICAnY3JzJzogbnVsbCxcbiAgICAgICAgJ3VwcGVyY2FzZSc6IGZhbHNlLFxuICAgICAgICAnYXR0cmlidXRpb24nOiAnJyxcbiAgICAgICAgJ29wYWNpdHknOiAxLFxuICAgICAgICAnaXNCYWNrJzogZmFsc2UsXG4gICAgICAgICdtaW5ab29tJzogMCxcbiAgICAgICAgJ21heFpvb20nOiAxOFxuICAgIH0sXG5cbiAgICAnaW5pdGlhbGl6ZSc6IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG5cbiAgICAgICAgLy8gTW92ZSBXTVMgcGFyYW1ldGVycyB0byBwYXJhbXMgb2JqZWN0XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fSwgb3B0cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgIGlmIChvcHQgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgIG9wdHNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICBwYXJhbXNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLndtc1BhcmFtcyA9IFV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgICdzZXRQYXJhbXMnOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgVXRpbC5leHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgICdnZXRBdHRyaWJ1dGlvbic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuICAgIH0sXG5cbiAgICAnb25BZGQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgJ29uUmVtb3ZlJzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50T3ZlcmxheSkge1xuICAgICAgICAgICAgbWFwLnJlbW92ZUxheWVyKHRoaXMuX2N1cnJlbnRPdmVybGF5KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50T3ZlcmxheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFVybCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2N1cnJlbnRVcmw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2dldEV2ZW50cyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ21vdmVlbmQnOiB0aGlzLnVwZGF0ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAndXBkYXRlJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGltYWdlIFVSTCBhbmQgd2hldGhlciBpdCBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IHVwZGF0ZVxuICAgICAgICB0aGlzLnVwZGF0ZVdtc1BhcmFtcygpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy5nZXRJbWFnZVVybCgpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFVybCA9PSB1cmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50VXJsID0gdXJsO1xuXG4gICAgICAgIC8vIEtlZXAgY3VycmVudCBpbWFnZSBvdmVybGF5IGluIHBsYWNlIHVudGlsIG5ldyBvbmUgbG9hZHNcbiAgICAgICAgLy8gKGluc3BpcmVkIGJ5IGVzcmkubGVhZmxldClcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCB7J29wYWNpdHknOiAwfSk7XG4gICAgICAgIG92ZXJsYXkuYWRkVG8odGhpcy5fbWFwKTtcbiAgICAgICAgb3ZlcmxheS5vbmNlKCdsb2FkJywgX3N3YXAsIHRoaXMpO1xuICAgICAgICBmdW5jdGlvbiBfc3dhcCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJsYXkuX3VybCAhPSB0aGlzLl9jdXJyZW50VXJsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudE92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY3VycmVudE92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICAgICAgb3ZlcmxheS5zZXRPcGFjaXR5KFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID8gdGhpcy5vcHRpb25zLm9wYWNpdHkgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0JhY2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5LmJyaW5nVG9CYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzQmFjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5LmJyaW5nVG9Gcm9udCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fbWFwLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB8fFxuICAgICAgICAgICAgKHRoaXMuX21hcC5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkpe1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKG92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdzZXRPcGFjaXR5JzogZnVuY3Rpb24ob3BhY2l0eSkge1xuICAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRPdmVybGF5KSB7XG4gICAgICAgICAgICAgdGhpcy5fY3VycmVudE92ZXJsYXkuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2JyaW5nVG9CYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pc0JhY2sgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudE92ZXJsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPdmVybGF5LmJyaW5nVG9CYWNrKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2JyaW5nVG9Gcm9udCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaXNCYWNrID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50T3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudE92ZXJsYXkuYnJpbmdUb0Zyb250KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2VlIEwuVGlsZUxheWVyLldNUzogb25BZGQoKSAmIGdldFRpbGVVcmwoKVxuICAgICd1cGRhdGVXbXNQYXJhbXMnOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIFdNUyBvcHRpb25zXG4gICAgICAgIHZhciBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHZhciBzaXplID0gbWFwLmdldFNpemUoKTtcbiAgICAgICAgdmFyIHdtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xuICAgICAgICB2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uS2V5ID0gd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xuICAgICAgICB2YXIgbncgPSBjcnMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xuICAgICAgICB2YXIgc2UgPSBjcnMucHJvamVjdChib3VuZHMuZ2V0U291dGhFYXN0KCkpO1xuXG4gICAgICAgIC8vIEFzc2VtYmxlIFdNUyBwYXJhbWV0ZXIgc3RyaW5nXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAnd2lkdGgnOiBzaXplLngsXG4gICAgICAgICAgICAnaGVpZ2h0Jzogc2l6ZS55XG4gICAgICAgIH07XG4gICAgICAgIHBhcmFtc1twcm9qZWN0aW9uS2V5XSA9IGNycy5jb2RlO1xuICAgICAgICBwYXJhbXMuYmJveCA9IChcbiAgICAgICAgICAgIHdtc1ZlcnNpb24gPj0gMS4zICYmIGNycy5jb2RlID09PSBFUFNHNDMyNi5jb2RlID9cbiAgICAgICAgICAgIFtzZS55LCBudy54LCBudy55LCBzZS54XSA6XG4gICAgICAgICAgICBbbncueCwgc2UueSwgc2UueCwgbncueV1cbiAgICAgICAgKS5qb2luKCcsJyk7XG5cbiAgICAgICAgVXRpbC5leHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgICdnZXRJbWFnZVVybCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBwZXJjYXNlID0gdGhpcy5vcHRpb25zLnVwcGVyY2FzZSB8fCBmYWxzZTtcbiAgICAgICAgdmFyIHBzdHIgPSBVdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB0aGlzLl91cmwsIHVwcGVyY2FzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmwgKyBwc3RyO1xuICAgIH1cbn0pO1xuXG53bXMub3ZlcmxheSA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgd21zLk92ZXJsYXkodXJsLCBvcHRpb25zKTtcbn07XG5cbi8vIFNpbXBsZSBBSkFYIGhlbHBlciAoc2luY2Ugd2UgY2FuJ3QgYXNzdW1lIGpRdWVyeSBldGMuIGFyZSBwcmVzZW50KVxud21zLmFqYXggPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gY2hhbmdlO1xuICAgIHJlcXVlc3Qub3BlbignR0VUJywgdXJsKTtcbiAgICByZXF1ZXN0LnNlbmQoKTtcblxuICAgIGZ1bmN0aW9uIGNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC13bXMvbGVhZmxldC53bXMuanMiLCJpbXBvcnQgeyBFbGVtZW50IGFzIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuXG5leHBvcnQgY2xhc3MgTGVhZmxldFdNU0xheWVyIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdtc1NvdXJjZTogT2JqZWN0LFxuICAgICAgbGF5ZXI6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBcbiAgICBpZiAodGhpcy53bXNTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxheWVyID09PSAnJykgcmV0dXJuO1xuICAgIHRoaXMud21zU291cmNlLmFkZFN1YkxheWVyKHRoaXMubGF5ZXIpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC13bXMtbGF5ZXInLCBMZWFmbGV0V01TTGF5ZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0LXdtcy1sYXllci5qcyIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5cbmltcG9ydCB7IFRpbGVMYXllciB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzJztcbmltcG9ydCB7IFRpbGVMYXllcldNUyB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBMZWFmbGV0VGlsZUxheWVyIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiAnX21hcFNldCdcbiAgICAgIH0sXG4gICAgICBiYXNlOiBCb29sZWFuLFxuICAgICAgdXJsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IFwiLy97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmdcIixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfdXJsQ2hhbmdlZCcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAnX2Zvcm1hdENoYW5nZWQnLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsYXllcnM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19sYXllcnNDaGFuZ2VkJ1xuICAgICAgfSxcbiAgICAgIG1pblpvb206IE51bWJlcixcbiAgICAgIG1heFpvb206IE51bWJlcixcbiAgICAgIGF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuXG4gIF91cmxDaGFuZ2VkICgpIHtcbiAgICBjb25zb2xlLmxvZygndXJsIGNoYW5nZWQnLCB0aGlzLnVybCk7XG4gICAgaWYgKHRoaXMubGVhZmxldExheWVyKSB0aGlzLmxlYWZsZXRMYXllci5zZXRVcmwodGhpcy51cmwpO1xuICB9XG5cbiAgX2xheWVyc0NoYW5nZWQgKCkge1xuICAgIGNvbnNvbGUubG9nKCdsYXllcnMgY2hhbmdlZCcsIHRoaXMubGF5ZXJzKTtcbiAgICBpZiAodGhpcy5sZWFmbGV0TGF5ZXIgJiYgdGhpcy5sZWFmbGV0TGF5ZXIgaW5zdGFuY2VvZiBUaWxlTGF5ZXJXTVMpIHRoaXMubGVhZmxldExheWVyLnNldFBhcmFtcyh7IGxheWVyczogdGhpcy5sYXllcnMgfSk7XG4gIH1cblxuICBfZm9ybWF0Q2hhbmdlZCAoKSB7XG4gICAgY29uc29sZS5sb2coJ2Zvcm1hdCBjaGFuZ2VkJywgdGhpcy5mb3JtYXQpO1xuXG4gICAgaWYgKHRoaXMubGVhZmxldExheWVyICYmIHRoaXMubWFwKSB7XG4gICAgICB0aGlzLmxlYWZsZXRMYXllci5yZW1vdmVGcm9tKHRoaXMubWFwKTtcbiAgICB9XG5cbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgIGF0dHJpYnV0aW9uOiB0aGlzLmF0dHJpYnV0aW9uXG4gICAgfTtcblxuICAgIHN3aXRjaCAodGhpcy5mb3JtYXQpIHtcbiAgICAgIGNhc2UgJ1hZWic6XG4gICAgICAgIHRoaXMubGVhZmxldExheWVyID0gbmV3IFRpbGVMYXllcih0aGlzLnVybCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnV01TJzpcbiAgICAgICAgdGhpcy5sZWFmbGV0TGF5ZXIgPSBuZXcgVGlsZUxheWVyV01TKHRoaXMudXJsLCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICBsYXllcnM6IHRoaXMubGF5ZXJzLFxuICAgICAgICAgIGZvcm1hdDogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgIGhpbnRzOiAncXVhbGl0eSdcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgbGVhZmxldC10aWxlLWxheWVyIGZvcm1hdDogJywgdGhpcy5mb3JtYXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFwKSB0aGlzLmxlYWZsZXRMYXllci5hZGRUbyh0aGlzLm1hcCk7XG4gICAgZWxzZSBjb25zb2xlLmxvZygnbWFwIG5vdCB5ZXQgc2V0Jyk7XG4gIH1cblxuICBfbWFwU2V0KCkge1xuICAgIGNvbnNvbGUubG9nKCdtYXAgc2V0Jyk7XG4gICAgaWYgKHRoaXMubGVhZmxldExheWVyICYmICF0aGlzLm1hcC5oYXNMYXllcih0aGlzLmxlYWZsZXRMYXllcikpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdubyBsYXllciB5ZXQsIGFkZGluZycpO1xuICAgICAgdGhpcy5sZWFmbGV0TGF5ZXIuYWRkVG8odGhpcy5tYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnbGF5ZXIgb2JqZWN0IG5vdCBzZXQgLyBsYXllciBleGlzdHMsIHNraXBwaW5nJyk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC10aWxlLWxheWVyJywgTGVhZmxldFRpbGVMYXllcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0BnZ2NpdHkvbGVhZmxldC10aWxlLWxheWVyL2xlYWZsZXQtdGlsZS1sYXllci5qcyIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBEb21SZXBlYXQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzJztcblxuaW1wb3J0IHsgQ2lyY2xlTWFya2VyIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyc7XG5pbXBvcnQgeyBHZW9KU09OIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvR2VvSlNPTi5qcyc7XG5pbXBvcnQgJy4uLy4uL2xlYWZsZXQvc3JjL0xlYWZsZXQuanMnO1xuaW1wb3J0IHsgTWFya2VyQ2x1c3Rlckdyb3VwIH0gZnJvbSAnLi4vLi4vbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy8nO1xuXG4vLyBEZXYgb25seVxuLy8gaW1wb3J0IHsgTGVhZmxldE1hcCB9IGZyb20gJy4uLy4uL0BnZ2NpdHkvbGVhZmxldC1tYXAvbGVhZmxldC1tYXAuanMnO1xuXG5leHBvcnQgY2xhc3MgTGVhZmxldEdlb0pTT04gZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiAnX21hcFNldCdcbiAgICAgIH0sXG5cbiAgICAgIHNvdXJjZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAnX3NvdXJjZUNoYW5nZScsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgZmlsbENvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICcjRkY4MEFCJ1xuICAgICAgfSxcblxuICAgICAgb3V0bGluZUNvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICcjRkYxNzQ0J1xuICAgICAgfSxcblxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDEwXG4gICAgICB9LFxuXG4gICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogM1xuICAgICAgfSxcblxuICAgICAgb3BhY2l0eToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAxLjBcbiAgICAgIH0sXG5cbiAgICAgIGZpbGxPcGFjaXR5OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgfSxcblxuICAgICAgY2x1c3RlcjogQm9vbGVhbixcbiAgICAgIG1heENsdXN0ZXJSYWRpdXM6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogODBcbiAgICAgIH0sXG4gICAgICBpZGVudGlmeTogQm9vbGVhbixcbiAgICAgIG1pblpvb206IE51bWJlcixcbiAgICAgIG1heFpvb206IE51bWJlcixcbiAgICAgIGF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHRoaXMuX2NsdXN0ZXJHcm91cCA9IG5ldyBNYXJrZXJDbHVzdGVyR3JvdXAoe1xuICAgICAgc2hvd0NvdmVyYWdlT25Ib3ZlcjogZmFsc2UsXG4gICAgICBtYXhDbHVzdGVyUmFkaXVzOiB0aGlzLm1heENsdXN0ZXJSYWRpdXNcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdGhpcy5tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY2x1c3Rlckdyb3VwKTtcbiAgICB0aGlzLl9jbHVzdGVyR3JvdXAuY2xlYXJMYXllcnMoKTtcbiAgfVxuXG4gIF9hZGRHZW9KU09OTGF5ZXIoZ2VvanNvbikge1xuICAgIHRoaXMuX2NsdXN0ZXJHcm91cC5jbGVhckxheWVycygpO1xuXG4gICAgdGhpcy5fZ2VvSlNPTk9wdGlvbnMgPSB7XG4gICAgICBwb2ludFRvTGF5ZXI6ICh0aGlzLmNsdXN0ZXIpID8gdGhpcy5fY2x1c3RlclBvaW50cy5iaW5kKHRoaXMpIDogdGhpcy5fc2ltcGxlUG9pbnRzLmJpbmQodGhpcyksXG4gICAgICBhdHRyaWJ1dGlvbjogdGhpcy5hdHRyaWJ1dGlvbixcbiAgICAgIG9uRWFjaEZlYXR1cmU6ICh0aGlzLmlkZW50aWZ5KSA/IHRoaXMuX29uRWFjaEZlYXR1cmUuYmluZCh0aGlzKSA6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuX2dlb0pTT05MYXllciA9IG5ldyBHZW9KU09OKGdlb2pzb24sIHRoaXMuX2dlb0pTT05PcHRpb25zKTtcblxuICAgIHRoaXMubWFwLmFkZExheWVyKHRoaXMuX2NsdXN0ZXJHcm91cCk7XG4gIH1cblxuICBfY2x1c3RlclBvaW50cyhmZWF0dXJlLCBsYXRsbmcpIHtcbiAgICB0aGlzLl9jbHVzdGVyR3JvdXAuYWRkTGF5ZXIoXG4gICAgICBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywge1xuICAgICAgICBjb2xvcjogdGhpcy5vdXRsaW5lQ29sb3IsXG4gICAgICAgIGZpbGxDb2xvcjogdGhpcy5maWxsQ29sb3IsXG4gICAgICAgIHJhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICAgIHdlaWdodDogdGhpcy53ZWlnaHQsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMuZmlsbE9wYWNpdHlcbiAgICAgIH0pLmJpbmRQb3B1cCh0aGlzLl9nZW5lcmF0ZVBvcHVwQ29udGVudChmZWF0dXJlKSlcbiAgICApO1xuICB9XG5cbiAgX3NpbXBsZVBvaW50cyhmZWF0dXJlLCBsYXRsbmcpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcpO1xuICB9XG5cbiAgX29uRWFjaEZlYXR1cmUoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICBsYXllci5iaW5kUG9wdXAodGhpcy5fZ2VuZXJhdGVQb3B1cENvbnRlbnQoZmVhdHVyZSkpO1xuICB9XG5cbiAgX2dlbmVyYXRlUG9wdXBDb250ZW50IChmZWF0dXJlKSB7XG4gICAgbGV0IHJvd3MgPSAnJztcbiAgICBmb3IgKGxldCBwIGluIGZlYXR1cmUucHJvcGVydGllcykge1xuICAgICAgbGV0IGZpZWxkTmFtZSA9IHAucmVwbGFjZSgvXFx3XFxTKi9nLCBmdW5jdGlvbih0eHQpeyByZXR1cm4gdHh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHh0LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnICcpOyB9KVxuICAgICAgcm93cyArPSBgPHRyPjx0ZD4ke2ZpZWxkTmFtZX06PC90ZD48dGQ+PHN0cm9uZz4ke2ZlYXR1cmUucHJvcGVydGllc1twXX08L3N0cm9uZz48L3RkPjwvdHI+YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYDx0YWJsZT4ke3Jvd3N9PC90YWJsZT5gO1xuICB9XG5cbiAgX3NvdXJjZUNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5tYXAgJiYgdGhpcy5fZ2VvSlNPTkxheWVyKSB0aGlzLl9nZW9KU09OTGF5ZXIucmVtb3ZlRnJvbSh0aGlzLm1hcCk7XG5cbiAgICBmZXRjaCh0aGlzLnNvdXJjZSlcbiAgICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxuICAgICAgLnRoZW4odGhpcy5fYWRkR2VvSlNPTkxheWVyLmJpbmQodGhpcykpO1xuICAgIC8vIC5jYXRjaCgoKSA9PiBhbGVydCgnVW5hYmxlIHRvIGxvYWQgbGF5ZXInKSk7XG4gIH1cblxuICBfbWFwU2V0KCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdhZGRpbmcgbGF5ZXInKTtcbiAgICAvLyB0aGlzLm1hcC5hZGRMYXllcih0aGlzLl9nZW9KU09OTGF5ZXIpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC1nZW9qc29uLXBvaW50cycsIExlYWZsZXRHZW9KU09OKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC1nZW9qc29uL2xlYWZsZXQtZ2VvanNvbi1wb2ludHMuanMiLCJcclxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xyXG5leHBvcnQge3ZlcnNpb259O1xyXG5cclxuLy8gY29udHJvbFxyXG5leHBvcnQgKiBmcm9tICcuL2NvbnRyb2wvaW5kZXgnO1xyXG5cclxuLy8gY29yZVxyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXgnO1xyXG5cclxuLy8gZG9tXHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL2luZGV4JztcclxuXHJcbi8vIGdlb21ldHJ5XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvbWV0cnkvaW5kZXgnO1xyXG5cclxuLy8gZ2VvXHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvL2luZGV4JztcclxuXHJcbi8vIGxheWVyXHJcbmV4cG9ydCAqIGZyb20gJy4vbGF5ZXIvaW5kZXgnO1xyXG5cclxuLy8gbWFwXHJcbmV4cG9ydCAqIGZyb20gJy4vbWFwL2luZGV4JztcclxuXHJcbi8vIG1pc2NcclxuXHJcbnZhciBvbGRMID0gd2luZG93Lkw7XHJcbmV4cG9ydCBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xyXG5cdHdpbmRvdy5MID0gb2xkTDtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQWx3YXlzIGV4cG9ydCB1cyB0byB3aW5kb3cgZ2xvYmFsIChzZWUgIzIzNjQpXHJcbndpbmRvdy5MID0gZXhwb3J0cztcclxuXHJcbmltcG9ydCB7ZnJlZXplfSBmcm9tICcuL2NvcmUvVXRpbCc7XHJcbk9iamVjdC5mcmVlemUgPSBmcmVlemU7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvTGVhZmxldC5qcyIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi9Ccm93c2VyJztcbmV4cG9ydCB7QnJvd3Nlcn07XG5cbmV4cG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB7RXZlbnRzfSBmcm9tICcuL0V2ZW50cyc7XG5leHBvcnQge0V2ZW50ZWR9O1xuZXhwb3J0IHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbmV4cG9ydCB7SGFuZGxlcn0gZnJvbSAnLi9IYW5kbGVyJztcblxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xuZXhwb3J0IHtVdGlsfTtcbmV4cG9ydCB7ZXh0ZW5kLCBiaW5kLCBzdGFtcCwgc2V0T3B0aW9uc30gZnJvbSAnLi9VdGlsJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9pbmRleC5qcyIsImV4cG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuL1Bvc0FuaW1hdGlvbic7XG5cbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuZXhwb3J0IHtEb21FdmVudH07XG5cbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcbmV4cG9ydCB7RG9tVXRpbH07XG5cbmV4cG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuL0RyYWdnYWJsZSc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9pbmRleC5qcyIsImV4cG9ydCB7UG9pbnQsIHRvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4vUG9pbnQnO1xuZXhwb3J0IHtCb3VuZHMsIHRvQm91bmRzIGFzIGJvdW5kc30gZnJvbSAnLi9Cb3VuZHMnO1xuZXhwb3J0IHtUcmFuc2Zvcm1hdGlvbiwgdG9UcmFuc2Zvcm1hdGlvbiBhcyB0cmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi9UcmFuc2Zvcm1hdGlvbic7XG5cbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4vTGluZVV0aWwnO1xuZXhwb3J0IHtMaW5lVXRpbH07XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuL1BvbHlVdGlsJztcbmV4cG9ydCB7UG9seVV0aWx9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9pbmRleC5qcyIsImV4cG9ydCB7TGF0TG5nLCB0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4vTGF0TG5nJztcbmV4cG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcblxuaW1wb3J0ICogYXMgUHJvamVjdGlvbiBmcm9tICcuL3Byb2plY3Rpb24vaW5kZXgnO1xuZXhwb3J0IHtQcm9qZWN0aW9ufTtcblxuZXhwb3J0ICogZnJvbSAnLi9jcnMvaW5kZXgnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vaW5kZXguanMiLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xuaW1wb3J0IHtFUFNHMzM5NX0gZnJvbSAnLi9DUlMuRVBTRzMzOTUnO1xuaW1wb3J0IHtFUFNHMzg1NywgRVBTRzkwMDkxM30gZnJvbSAnLi9DUlMuRVBTRzM4NTcnO1xuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi9DUlMuRVBTRzQzMjYnO1xuaW1wb3J0IHtTaW1wbGV9IGZyb20gJy4vQ1JTLlNpbXBsZSc7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuZXhwb3J0IHtDUlN9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL2luZGV4LmpzIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge01lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gKlxyXG4gKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHZhciBFUFNHMzM5NSA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG5cdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcyIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuU2ltcGxlLmpzIiwiLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIm5hbWVcIjpcImxlYWZsZXRcIixcInZlcnNpb25cIjpcIjEuMi4wXCIsXCJkZXNjcmlwdGlvblwiOlwiSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBtb2JpbGUtZnJpZW5kbHkgaW50ZXJhY3RpdmUgbWFwc1wiLFwiZGV2RGVwZW5kZW5jaWVzXCI6e1wiZXNsaW50XCI6XCJeMy41LjAgPDMuNi4wXCIsXCJlc2xpbnQtY29uZmlnLW1vdXJuZXJcIjpcIl4yLjAuMVwiLFwiZ2l0LXJldi1zeW5jXCI6XCJeMS44LjBcIixcImhhcHBlblwiOlwifjAuMy4xXCIsXCJqYWtlXCI6XCJ+OC4wLjEyXCIsXCJrYXJtYVwiOlwiXjEuMy4wXCIsXCJrYXJtYS1jaHJvbWUtbGF1bmNoZXJcIjpcIl4yLjAuMFwiLFwia2FybWEtY292ZXJhZ2VcIjpcIn4xLjEuMVwiLFwia2FybWEtZmlyZWZveC1sYXVuY2hlclwiOlwifjEuMC4wXCIsXCJrYXJtYS1tb2NoYVwiOlwiXjEuMi4wXCIsXCJrYXJtYS1waGFudG9tanMtbGF1bmNoZXJcIjpcIl4xLjAuMlwiLFwia2FybWEtcm9sbHVwLXByZXByb2Nlc3NvclwiOlwiXjQuMC4yXCIsXCJrYXJtYS1zYWZhcmktbGF1bmNoZXJcIjpcIn4xLjAuMFwiLFwibGVhZmRvY1wiOlwiXjEuNC4xXCIsXCJtb2NoYVwiOlwiXjMuNS4wXCIsXCJwaGFudG9tanMtcHJlYnVpbHRcIjpcIl4yLjEuMTJcIixcInByb3N0aGV0aWMtaGFuZFwiOlwiXjEuMy4xXCIsXCJyb2xsdXBcIjpcIl4wLjQ1LjJcIixcInJvbGx1cC1wbHVnaW4tZ2l0LXZlcnNpb25cIjpcIjAuMi4xXCIsXCJyb2xsdXAtcGx1Z2luLWpzb25cIjpcIl4yLjEuMFwiLFwicm9sbHVwLXdhdGNoXCI6XCJeNC4zLjFcIixcInNvdXJjZS1tYXBcIjpcIl4wLjUuNlwiLFwic3NyaVwiOlwiXjQuMS4yXCIsXCJ1Z2xpZnktanNcIjpcIn4zLjAuMjZcIn0sXCJtYWluXCI6XCJkaXN0L2xlYWZsZXQtc3JjLmpzXCIsXCJzdHlsZVwiOlwiZGlzdC9sZWFmbGV0LmNzc1wiLFwiZmlsZXNcIjpbXCJkaXN0XCIsXCJzcmNcIixcIiFkaXN0L2xlYWZsZXQuemlwXCJdLFwic2NyaXB0c1wiOntcInRlc3QtamFrZVwiOlwiamFrZSB0ZXN0XCIsXCJ0ZXN0XCI6XCJqYWtlIHRlc3RcIixcImJ1aWxkLWpha2VcIjpcImpha2UgYnVpbGRcIixcImJ1aWxkXCI6XCJucG0gcnVuIHJvbGx1cCAmJiBucG0gcnVuIHVnbGlmeVwiLFwicmVsZWFzZVwiOlwiLi9idWlsZC9wdWJsaXNoLnNoXCIsXCJsaW50XCI6XCJlc2xpbnQgc3JjOyBlc2xpbnQgc3BlYy9zdWl0ZXNcIixcImxpbnRmaXhcIjpcImVzbGludCBzcmMgLS1maXg7IGVzbGludCBzcGVjL3N1aXRlcyAtLWZpeDsgXCIsXCJyb2xsdXBcIjpcInJvbGx1cCAtYyBidWlsZC9yb2xsdXAtY29uZmlnLmpzXCIsXCJ3YXRjaFwiOlwicm9sbHVwIC13IC1jIGJ1aWxkL3JvbGx1cC13YXRjaC1jb25maWcuanNcIixcInVnbGlmeVwiOlwidWdsaWZ5anMgZGlzdC9sZWFmbGV0LXNyYy5qcyAtYyAtbSAtbyBkaXN0L2xlYWZsZXQuanMgLS1zb3VyY2UtbWFwIGZpbGVuYW1lPWRpc3QvbGVhZmxldC5qcy5tYXAgLS1pbi1zb3VyY2UtbWFwIGRpc3QvbGVhZmxldC1zcmMuanMubWFwIC0tc291cmNlLW1hcC11cmwgbGVhZmxldC5qcy5tYXAgLS1jb21tZW50c1wiLFwiaW50ZWdyaXR5XCI6XCJub2RlanMgLi9idWlsZC9pbnRlZ3JpdHkuanNcIn0sXCJlc2xpbnRDb25maWdcIjp7XCJyb290XCI6dHJ1ZSxcImdsb2JhbHNcIjp7XCJMXCI6dHJ1ZX0sXCJlbnZcIjp7XCJjb21tb25qc1wiOnRydWUsXCJhbWRcIjp0cnVlLFwibm9kZVwiOmZhbHNlfSxcImV4dGVuZHNcIjpcIm1vdXJuZXJcIixcInBhcnNlck9wdGlvbnNcIjp7XCJlY21hVmVyc2lvblwiOjYsXCJzb3VyY2VUeXBlXCI6XCJtb2R1bGVcIn0sXCJydWxlc1wiOntcImxpbmVicmVhay1zdHlsZVwiOlswLFwidW5peFwiXSxcIm5vLW1peGVkLXNwYWNlcy1hbmQtdGFic1wiOlsyLFwic21hcnQtdGFic1wiXSxcImluZGVudFwiOlsyLFwidGFiXCIse1wiVmFyaWFibGVEZWNsYXJhdG9yXCI6MH1dLFwiY3VybHlcIjoyLFwic3BhY2VkLWNvbW1lbnRcIjoyLFwic3RyaWN0XCI6MCxcIndyYXAtaWlmZVwiOjAsXCJrZXktc3BhY2luZ1wiOjAsXCJjb25zaXN0ZW50LXJldHVyblwiOjB9fSxcInJlcG9zaXRvcnlcIjp7XCJ0eXBlXCI6XCJnaXRcIixcInVybFwiOlwiZ2l0Oi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQuZ2l0XCJ9LFwia2V5d29yZHNcIjpbXCJnaXNcIixcIm1hcFwiXSxcImxpY2Vuc2VcIjpcIkJTRC0yLUNsYXVzZVwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5leHBvcnQgeyBNYXJrZXJDbHVzdGVyR3JvdXAgfSBmcm9tICcuL01hcmtlckNsdXN0ZXJHcm91cC5qcyc7XHJcbmV4cG9ydCB7IE1hcmtlckNsdXN0ZXIgfSBmcm9tICcuL01hcmtlckNsdXN0ZXIuanMnO1xyXG5pbXBvcnQge30gZnJvbSAnLi9NYXJrZXJPcGFjaXR5LmpzJztcclxuaW1wb3J0IHt9IGZyb20gJy4vRGlzdGFuY2VHcmlkLmpzJztcclxuaW1wb3J0IHt9IGZyb20gJy4vTWFya2VyQ2x1c3Rlci5RdWlja0h1bGwuanMnO1xyXG5pbXBvcnQge30gZnJvbSAnLi9NYXJrZXJDbHVzdGVyLlNwaWRlcmZpZXIuanMnO1xyXG5pbXBvcnQge30gZnJvbSAnLi9NYXJrZXJDbHVzdGVyR3JvdXAuUmVmcmVzaC5qcyc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9pbmRleC5qcyIsIi8qXHJcbiAqIEwuTWFya2VyQ2x1c3Rlckdyb3VwIGV4dGVuZHMgTC5GZWF0dXJlR3JvdXAgYnkgY2x1c3RlcmluZyB0aGUgbWFya2VycyBjb250YWluZWQgd2l0aGluXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXJrZXJDbHVzdGVyR3JvdXAgPSBMLk1hcmtlckNsdXN0ZXJHcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG1heENsdXN0ZXJSYWRpdXM6IDgwLCAvL0EgY2x1c3RlciB3aWxsIGNvdmVyIGF0IG1vc3QgdGhpcyBtYW55IHBpeGVscyBmcm9tIGl0cyBjZW50ZXJcclxuXHRcdGljb25DcmVhdGVGdW5jdGlvbjogbnVsbCxcclxuXHRcdGNsdXN0ZXJQYW5lOiBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5wYW5lLFxyXG5cclxuXHRcdHNwaWRlcmZ5T25NYXhab29tOiB0cnVlLFxyXG5cdFx0c2hvd0NvdmVyYWdlT25Ib3ZlcjogdHJ1ZSxcclxuXHRcdHpvb21Ub0JvdW5kc09uQ2xpY2s6IHRydWUsXHJcblx0XHRzaW5nbGVNYXJrZXJNb2RlOiBmYWxzZSxcclxuXHJcblx0XHRkaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbTogbnVsbCxcclxuXHJcblx0XHQvLyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcHJldmVudHMgdGhlIHJlbW92YWwgb2YgYW55IGNsdXN0ZXJzIG91dHNpZGUgb2YgdGhlIHZpZXdwb2ludCwgd2hpY2hcclxuXHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cclxuXHRcdHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzOiB0cnVlLFxyXG5cclxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGFsbCBhbmltYXRpb25zICh6b29tIGFuZCBzcGlkZXJmeSkuXHJcblx0XHQvLyBJZiBmYWxzZSwgb3B0aW9uIGFuaW1hdGVBZGRpbmdNYXJrZXJzIGJlbG93IGhhcyBubyBlZmZlY3QuXHJcblx0XHQvLyBJZiBMLkRvbVV0aWwuVFJBTlNJVElPTiBpcyBmYWxzeSwgdGhpcyBvcHRpb24gaGFzIG5vIGVmZmVjdC5cclxuXHRcdGFuaW1hdGU6IHRydWUsXHJcblxyXG5cdFx0Ly9XaGV0aGVyIHRvIGFuaW1hdGUgYWRkaW5nIG1hcmtlcnMgYWZ0ZXIgYWRkaW5nIHRoZSBNYXJrZXJDbHVzdGVyR3JvdXAgdG8gdGhlIG1hcFxyXG5cdFx0Ly8gSWYgeW91IGFyZSBhZGRpbmcgaW5kaXZpZHVhbCBtYXJrZXJzIHNldCB0byB0cnVlLCBpZiBhZGRpbmcgYnVsayBtYXJrZXJzIGxlYXZlIGZhbHNlIGZvciBtYXNzaXZlIHBlcmZvcm1hbmNlIGdhaW5zLlxyXG5cdFx0YW5pbWF0ZUFkZGluZ01hcmtlcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vSW5jcmVhc2UgdG8gaW5jcmVhc2UgdGhlIGRpc3RhbmNlIGF3YXkgdGhhdCBzcGlkZXJmaWVkIG1hcmtlcnMgYXBwZWFyIGZyb20gdGhlIGNlbnRlclxyXG5cdFx0c3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXI6IDEsXHJcblxyXG5cdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcG9seWxpbmUgb3B0aW9ucyBvbiBhIHNwaWRlciBsZWdcclxuXHRcdHNwaWRlckxlZ1BvbHlsaW5lT3B0aW9uczogeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogMC41IH0sXHJcblxyXG5cdFx0Ly8gV2hlbiBidWxrIGFkZGluZyBsYXllcnMsIGFkZHMgbWFya2VycyBpbiBjaHVua3MuIE1lYW5zIGFkZExheWVycyBtYXkgbm90IGFkZCBhbGwgdGhlIGxheWVycyBpbiB0aGUgY2FsbCwgb3RoZXJzIHdpbGwgYmUgbG9hZGVkIGR1cmluZyBzZXRUaW1lb3V0c1xyXG5cdFx0Y2h1bmtlZExvYWRpbmc6IGZhbHNlLFxyXG5cdFx0Y2h1bmtJbnRlcnZhbDogMjAwLCAvLyBwcm9jZXNzIG1hcmtlcnMgZm9yIGEgbWF4aW11bSBvZiB+IG4gbWlsbGlzZWNvbmRzICh0aGVuIHRyaWdnZXIgdGhlIGNodW5rUHJvZ3Jlc3MgY2FsbGJhY2spXHJcblx0XHRjaHVua0RlbGF5OiA1MCwgLy8gYXQgdGhlIGVuZCBvZiBlYWNoIGludGVydmFsLCBnaXZlIG4gbWlsbGlzZWNvbmRzIGJhY2sgdG8gc3lzdGVtL2Jyb3dzZXJcclxuXHRcdGNodW5rUHJvZ3Jlc3M6IG51bGwsIC8vIHByb2dyZXNzIGNhbGxiYWNrOiBmdW5jdGlvbihwcm9jZXNzZWQsIHRvdGFsLCBlbGFwc2VkKSAoZS5nLiBmb3IgYSBwcm9ncmVzcyBpbmRpY2F0b3IpXHJcblxyXG5cdFx0Ly9PcHRpb25zIHRvIHBhc3MgdG8gdGhlIEwuUG9seWdvbiBjb25zdHJ1Y3RvclxyXG5cdFx0cG9seWdvbk9wdGlvbnM6IHt9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XHJcblx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcclxuXHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTsgLy9NYXJrZXJzIHJlbW92ZWQgd2hpbGUgd2UgYXJlbid0IG9uIHRoZSBtYXAgbmVlZCB0byBiZSBrZXB0IHRyYWNrIG9mXHJcblx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuX3F1ZXVlID0gW107XHJcblxyXG5cdFx0dGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzID0ge1xyXG5cdFx0XHQnZHJhZ3N0YXJ0JzogdGhpcy5fY2hpbGRNYXJrZXJEcmFnU3RhcnQsXHJcblx0XHRcdCdtb3ZlJzogdGhpcy5fY2hpbGRNYXJrZXJNb3ZlZCxcclxuXHRcdFx0J2RyYWdlbmQnOiB0aGlzLl9jaGlsZE1hcmtlckRyYWdFbmQsXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEhvb2sgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBtZXRob2RzLlxyXG5cdFx0dmFyIGFuaW1hdGUgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0ZTtcclxuXHRcdEwuZXh0ZW5kKHRoaXMsIGFuaW1hdGUgPyB0aGlzLl93aXRoQW5pbWF0aW9uIDogdGhpcy5fbm9BbmltYXRpb24pO1xyXG5cdFx0Ly8gUmVtZW1iZXIgd2hpY2ggTWFya2VyQ2x1c3RlciBjbGFzcyB0byBpbnN0YW50aWF0ZSAoYW5pbWF0ZWQgb3Igbm90KS5cclxuXHRcdHRoaXMuX21hcmtlckNsdXN0ZXIgPSBhbmltYXRlID8gTC5NYXJrZXJDbHVzdGVyIDogTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQ7XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Eb24ndCBjbHVzdGVyIG5vbiBwb2ludCBkYXRhXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcucHVzaChsYXllcik7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvL0lmIHdlIGhhdmUgYWxyZWFkeSBjbHVzdGVyZWQgd2UnbGwgbmVlZCB0byBhZGQgdGhpcyBvbmUgdG8gYSBjbHVzdGVyXHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcclxuXHRcdHZhciB2aXNpYmxlTGF5ZXIgPSBsYXllcixcclxuXHRcdCAgICBjdXJyZW50Wm9vbSA9IHRoaXMuX3pvb207XHJcblx0XHRpZiAobGF5ZXIuX19wYXJlbnQpIHtcclxuXHRcdFx0d2hpbGUgKHZpc2libGVMYXllci5fX3BhcmVudC5fem9vbSA+PSBjdXJyZW50Wm9vbSkge1xyXG5cdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMuY29udGFpbnModmlzaWJsZUxheWVyLmdldExhdExuZygpKSkge1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmFuaW1hdGVBZGRpbmdNYXJrZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXIobGF5ZXIsIHZpc2libGVMYXllcik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgdmlzaWJsZUxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Ob24gcG9pbnQgbGF5ZXJzXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbGF5ZXIpICYmIHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdFx0dGhpcy5fbmVlZHNSZW1vdmluZy5wdXNoKHsgbGF5ZXI6IGxheWVyLCBsYXRsbmc6IGxheWVyLl9sYXRsbmcgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxheWVyLl9fcGFyZW50KSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gY2x1c3RlcnNcclxuXHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLCB0cnVlKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0bGF5ZXIub2ZmKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ZlYXR1cmVHcm91cC5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vVGFrZXMgYW4gYXJyYXkgb2YgbWFya2VycyBhbmQgYWRkcyB0aGVtIGluIGJ1bGtcclxuXHRhZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnNBcnJheSwgc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdGlmICghTC5VdGlsLmlzQXJyYXkobGF5ZXJzQXJyYXkpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyc0FycmF5KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBjaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5rZWRMb2FkaW5nLFxyXG5cdFx0ICAgIGNodW5rSW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMuY2h1bmtJbnRlcnZhbCxcclxuXHRcdCAgICBjaHVua1Byb2dyZXNzID0gdGhpcy5vcHRpb25zLmNodW5rUHJvZ3Jlc3MsXHJcblx0XHQgICAgbCA9IGxheWVyc0FycmF5Lmxlbmd0aCxcclxuXHRcdCAgICBvZmZzZXQgPSAwLFxyXG5cdFx0ICAgIG9yaWdpbmFsQXJyYXkgPSB0cnVlLFxyXG5cdFx0ICAgIG07XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgc3RhcnRlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcblx0XHRcdHZhciBwcm9jZXNzID0gTC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHRcdGZvciAoOyBvZmZzZXQgPCBsOyBvZmZzZXQrKykge1xyXG5cdFx0XHRcdFx0aWYgKGNodW5rZWQgJiYgb2Zmc2V0ICUgMjAwID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdC8vIGV2ZXJ5IGNvdXBsZSBodW5kcmVkIG1hcmtlcnMsIGluc3RydW1lbnQgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSBwcm9jZXNzaW5nIHN0YXJ0ZWQ6XHJcblx0XHRcdFx0XHRcdHZhciBlbGFwc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xyXG5cdFx0XHRcdFx0XHRpZiAoZWxhcHNlZCA+IGNodW5rSW50ZXJ2YWwpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhazsgLy8gYmVlbiB3b3JraW5nIHRvbyBoYXJkLCB0aW1lIHRvIHRha2UgYSBicmVhayA6LSlcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheVtvZmZzZXRdO1xyXG5cclxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdFx0Ly8gU2lkZSBlZmZlY3RzOlxyXG5cdFx0XHRcdFx0Ly8gLSBUb3RhbCBpbmNyZWFzZXMsIHNvIGNodW5rUHJvZ3Jlc3MgcmF0aW8ganVtcHMgYmFja3dhcmQuXHJcblx0XHRcdFx0XHQvLyAtIEdyb3VwcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAsIG9ubHkgdGhlaXIgbm9uLWdyb3VwIGNoaWxkIGxheWVycyAoaGFzTGF5ZXIpLlxyXG5cdFx0XHRcdFx0Ly8gQ2hhbmdpbmcgYXJyYXkgbGVuZ3RoIHdoaWxlIGxvb3BpbmcgZG9lcyBub3QgYWZmZWN0IHBlcmZvcm1hbmNlIGluIGN1cnJlbnQgYnJvd3NlcnM6XHJcblx0XHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mb3ItbG9vcC1jaGFuZ2luZy1sZW5ndGgvNlxyXG5cdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vTm90IHBvaW50IGRhdGEsIGNhbid0IGJlIGNsdXN0ZXJlZFxyXG5cdFx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xyXG5cdFx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5oYXNMYXllcihtKSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihtLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9JZiB3ZSBqdXN0IG1hZGUgYSBjbHVzdGVyIG9mIHNpemUgMiB0aGVuIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBvdGhlciBtYXJrZXIgZnJvbSB0aGUgbWFwIChpZiBpdCBpcykgb3Igd2UgbmV2ZXIgd2lsbFxyXG5cdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAyKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG1hcmtlcnMgPSBtLl9fcGFyZW50LmdldEFsbENoaWxkTWFya2VycygpLFxyXG5cdFx0XHRcdFx0XHRcdCAgICBvdGhlck1hcmtlciA9IG1hcmtlcnNbMF0gPT09IG0gPyBtYXJrZXJzWzFdIDogbWFya2Vyc1swXTtcclxuXHRcdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihvdGhlck1hcmtlcik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjaHVua1Byb2dyZXNzKSB7XHJcblx0XHRcdFx0XHQvLyByZXBvcnQgcHJvZ3Jlc3MgYW5kIHRpbWUgZWxhcHNlZDpcclxuXHRcdFx0XHRcdGNodW5rUHJvZ3Jlc3Mob2Zmc2V0LCBsLCAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnRlZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBDb21wbGV0ZWQgcHJvY2Vzc2luZyBhbGwgbWFya2Vycy5cclxuXHRcdFx0XHRpZiAob2Zmc2V0ID09PSBsKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHNldFRpbWVvdXQocHJvY2VzcywgdGhpcy5vcHRpb25zLmNodW5rRGVsYXkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRwcm9jZXNzKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbmVlZHNDbHVzdGVyaW5nID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xyXG5cclxuXHRcdFx0Zm9yICg7IG9mZnNldCA8IGw7IG9mZnNldCsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcclxuXHRcdFx0XHRpZiAoIW0uZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5lZWRzQ2x1c3RlcmluZy5wdXNoKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIHJlbW92ZXMgdGhlbSBpbiBidWxrXHJcblx0cmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzQXJyYXkpIHtcclxuXHRcdHZhciBpLCBtLFxyXG5cdFx0ICAgIGwgPSBsYXllcnNBcnJheS5sZW5ndGgsXHJcblx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBvcmlnaW5hbEFycmF5ID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W2ldO1xyXG5cclxuXHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBtKTtcclxuXHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcucHVzaCh7IGxheWVyOiBtLCBsYXRsbmc6IG0uX2xhdGxuZyB9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cclxuXHRcdFx0Ly8gV29yayBvbiBhIGNvcHkgb2YgdGhlIGFycmF5LCBzbyB0aGF0IG5leHQgbG9vcCBpcyBub3QgYWZmZWN0ZWQuXHJcblx0XHRcdHZhciBsYXllcnNBcnJheTIgPSBsYXllcnNBcnJheS5zbGljZSgpLFxyXG5cdFx0XHQgICAgbDIgPSBsO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDI7IGkrKykge1xyXG5cdFx0XHRcdG0gPSBsYXllcnNBcnJheTJbaV07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkyKTtcclxuXHRcdFx0XHRcdGwyID0gbGF5ZXJzQXJyYXkyLmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XHJcblxyXG5cdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghbS5fX3BhcmVudCkge1xyXG5cdFx0XHRcdG5wZy5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobSwgdHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xyXG5cclxuXHRcdFx0aWYgKGZnLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9GaXggdXAgdGhlIGNsdXN0ZXJzIGFuZCBtYXJrZXJzIG9uIHRoZSBtYXBcclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly9SZW1vdmVzIGFsbCBsYXllcnMgZnJvbSB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vTmVlZCBvdXIgb3duIHNwZWNpYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIExheWVyR3JvdXAgb25lIGRvZXNuJ3Qgd29yayBmb3IgdXNcclxuXHJcblx0XHQvL0lmIHdlIGFyZW4ndCBvbiB0aGUgbWFwICh5ZXQpLCBibG93IGF3YXkgdGhlIG1hcmtlcnMgd2Uga25vdyBvZlxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkQ2x1c3RlcnM7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSkge1xyXG5cdFx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSBhbGwgdGhlIHZpc2libGUgbGF5ZXJzXHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuY2xlYXJMYXllcnMoKTtcclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAuY2xlYXJMYXllcnMoKTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobWFya2VyKSB7XHJcblx0XHRcdG1hcmtlci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcclxuXHRcdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0Ly9SZXNldCBfdG9wQ2x1c3RlckxldmVsIGFuZCB0aGUgRGlzdGFuY2VHcmlkc1xyXG5cdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGUgRmVhdHVyZUdyb3VwLmdldEJvdW5kcyBhcyBpdCBkb2Vzbid0IHdvcmtcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fdG9wQ2x1c3RlckxldmVsKSB7XHJcblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fdG9wQ2x1c3RlckxldmVsLl9ib3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9uZWVkc0NsdXN0ZXJpbmdbaV0uZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJvdW5kcy5leHRlbmQodGhpcy5fbm9uUG9pbnRHcm91cC5nZXRCb3VuZHMoKSk7XHJcblxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmVhY2hMYXllclxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0dmFyIG1hcmtlcnMgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmcuc2xpY2UoKSxcclxuXHRcdFx0bmVlZHNSZW1vdmluZyA9IHRoaXMuX25lZWRzUmVtb3ZpbmcsXHJcblx0XHRcdHRoaXNOZWVkc1JlbW92aW5nLCBpLCBqO1xyXG5cclxuXHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycyhtYXJrZXJzKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHRoaXNOZWVkc1JlbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdGZvciAoaiA9IG5lZWRzUmVtb3ZpbmcubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0XHRpZiAobmVlZHNSZW1vdmluZ1tqXS5sYXllciA9PT0gbWFya2Vyc1tpXSkge1xyXG5cdFx0XHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXNOZWVkc1JlbW92aW5nKSB7XHJcblx0XHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgbWFya2Vyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmVhY2hMYXllcihtZXRob2QsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZ2V0TGF5ZXJzXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobCkge1xyXG5cdFx0XHRsYXllcnMucHVzaChsKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyLCBXQVJOSU5HOiBSZWFsbHkgYmFkIHBlcmZvcm1hbmNlXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IG51bGw7XHJcblxyXG5cdFx0aWQgPSBwYXJzZUludChpZCwgMTApO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsKSB7XHJcblx0XHRcdGlmIChMLnN0YW1wKGwpID09PSBpZCkge1xyXG5cdFx0XHRcdHJlc3VsdCA9IGw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGluIHRoaXMgTWFya2VyQ2x1c3Rlckdyb3VwXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGksIGFuQXJyYXkgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmc7XHJcblxyXG5cdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGFuQXJyYXkgPSB0aGlzLl9uZWVkc1JlbW92aW5nO1xyXG5cdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZiAoYW5BcnJheVtpXS5sYXllciA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gISEobGF5ZXIuX19wYXJlbnQgJiYgbGF5ZXIuX19wYXJlbnQuX2dyb3VwID09PSB0aGlzKSB8fCB0aGlzLl9ub25Qb2ludEdyb3VwLmhhc0xheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvL1pvb20gZG93biB0byBzaG93IHRoZSBnaXZlbiBsYXllciAoc3BpZGVyZnlpbmcgaWYgbmVjZXNzYXJ5KSB0aGVuIGNhbGxzIHRoZSBjYWxsYmFja1xyXG5cdHpvb21Ub1Nob3dMYXllcjogZnVuY3Rpb24gKGxheWVyLCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2hvd01hcmtlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKChsYXllci5faWNvbiB8fCBsYXllci5fX3BhcmVudC5faWNvbikgJiYgIXRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0XHR0aGlzLm9mZignYW5pbWF0aW9uZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdGlmIChsYXllci5faWNvbikge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll9pY29uKSB7XHJcblx0XHRcdFx0XHR0aGlzLm9uY2UoJ3NwaWRlcmZpZWQnLCBjYWxsYmFjaywgdGhpcyk7XHJcblx0XHRcdFx0XHRsYXllci5fX3BhcmVudC5zcGlkZXJmeSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAobGF5ZXIuX2ljb24gJiYgdGhpcy5fbWFwLmdldEJvdW5kcygpLmNvbnRhaW5zKGxheWVyLmdldExhdExuZygpKSkge1xyXG5cdFx0XHQvL0xheWVyIGlzIHZpc2libGUgb25kIG9uIHNjcmVlbiwgaW1tZWRpYXRlIHJldHVyblxyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fSBlbHNlIGlmIChsYXllci5fX3BhcmVudC5fem9vbSA8IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKSkge1xyXG5cdFx0XHQvL0xheWVyIHNob3VsZCBiZSB2aXNpYmxlIGF0IHRoaXMgem9vbSBsZXZlbC4gSXQgbXVzdCBub3QgYmUgb24gc2NyZWVuIHNvIGp1c3QgcGFuIG92ZXIgdG8gaXRcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblx0XHRcdHRoaXMuX21hcC5wYW5UbyhsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5vbignYW5pbWF0aW9uZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblx0XHRcdGxheWVyLl9fcGFyZW50Lnpvb21Ub0JvdW5kcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vbkFkZFxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHR2YXIgaSwgbCwgbGF5ZXI7XHJcblxyXG5cdFx0aWYgKCFpc0Zpbml0ZSh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSkge1xyXG5cdFx0XHR0aHJvdyBcIk1hcCBoYXMgbm8gbWF4Wm9vbSBzcGVjaWZpZWRcIjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkVG8obWFwKTtcclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAuYWRkVG8obWFwKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2dyaWRDbHVzdGVycykge1xyXG5cdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21heExhdCA9IG1hcC5vcHRpb25zLmNycy5wcm9qZWN0aW9uLk1BWF9MQVRJVFVERTtcclxuXHJcblx0XHQvL1Jlc3RvcmUgYWxsIHRoZSBwb3NpdGlvbnMgYXMgdGhleSBhcmUgaW4gdGhlIE1DRyBiZWZvcmUgcmVtb3ZpbmcgdGhlbVxyXG5cdFx0Zm9yIChpID0gMCwgbCA9IHRoaXMuX25lZWRzUmVtb3ZpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbmVlZHNSZW1vdmluZ1tpXTtcclxuXHRcdFx0bGF5ZXIubmV3bGF0bG5nID0gbGF5ZXIubGF5ZXIuX2xhdGxuZztcclxuXHRcdFx0bGF5ZXIubGF5ZXIuX2xhdGxuZyA9IGxheWVyLmxhdGxuZztcclxuXHRcdH1cclxuXHRcdC8vUmVtb3ZlIHRoZW0sIHRoZW4gcmVzdG9yZSB0aGVpciBuZXcgcG9zaXRpb25zXHJcblx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy5fbmVlZHNSZW1vdmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9uZWVkc1JlbW92aW5nW2ldO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVMYXllcihsYXllci5sYXllciwgdHJ1ZSk7XHJcblx0XHRcdGxheWVyLmxheWVyLl9sYXRsbmcgPSBsYXllci5uZXdsYXRsbmc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9uZWVkc1JlbW92aW5nID0gW107XHJcblxyXG5cdFx0Ly9SZW1lbWJlciB0aGUgY3VycmVudCB6b29tIGxldmVsIGFuZCBib3VuZHNcclxuXHRcdHRoaXMuX3pvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl96b29tRW5kLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVyT25BZGQpIHsgLy9UT0RPIEZJWE1FOiBOb3Qgc3VyZSBob3cgdG8gaGF2ZSBzcGlkZXJmaWVyIGFkZCBzb21ldGhpbmcgb24gaGVyZSBuaWNlbHlcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllck9uQWRkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmluZEV2ZW50cygpO1xyXG5cclxuXHRcdC8vQWN0dWFsbHkgYWRkIG91ciBtYXJrZXJzIHRvIHRoZSBtYXA6XHJcblx0XHRsID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xyXG5cdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XHJcblx0XHR0aGlzLmFkZExheWVycyhsLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBGZWF0dXJlR3JvdXAub25SZW1vdmVcclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCcsIHRoaXMuX3pvb21FbmQsIHRoaXMpO1xyXG5cdFx0bWFwLm9mZignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX3VuYmluZEV2ZW50cygpO1xyXG5cclxuXHRcdC8vSW4gY2FzZSB3ZSBhcmUgaW4gYSBjbHVzdGVyIGFuaW1hdGlvblxyXG5cdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSA9IHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY2x1c3Rlci1hbmltJywgJycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUpIHsgLy9UT0RPIEZJWE1FOiBOb3Qgc3VyZSBob3cgdG8gaGF2ZSBzcGlkZXJmaWVyIGFkZCBzb21ldGhpbmcgb24gaGVyZSBuaWNlbHlcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllck9uUmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX21heExhdDtcclxuXHJcblx0XHQvL0NsZWFuIHVwIGFsbCB0aGUgbGF5ZXJzIHdlIGFkZGVkIHRvIHRoZSBtYXBcclxuXHRcdHRoaXMuX2hpZGVDb3ZlcmFnZSgpO1xyXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5yZW1vdmUoKTtcclxuXHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuY2xlYXJMYXllcnMoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldFZpc2libGVQYXJlbnQ6IGZ1bmN0aW9uIChtYXJrZXIpIHtcclxuXHRcdHZhciB2TWFya2VyID0gbWFya2VyO1xyXG5cdFx0d2hpbGUgKHZNYXJrZXIgJiYgIXZNYXJrZXIuX2ljb24pIHtcclxuXHRcdFx0dk1hcmtlciA9IHZNYXJrZXIuX19wYXJlbnQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdk1hcmtlciB8fCBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8vUmVtb3ZlIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXlcclxuXHRfYXJyYXlTcGxpY2U6IGZ1bmN0aW9uIChhbkFycmF5LCBvYmopIHtcclxuXHRcdGZvciAodmFyIGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmIChhbkFycmF5W2ldID09PSBvYmopIHtcclxuXHRcdFx0XHRhbkFycmF5LnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgYSBtYXJrZXIgZnJvbSBhbGwgX2dyaWRVbmNsdXN0ZXJlZCB6b29tIGxldmVscywgc3RhcnRpbmcgYXQgdGhlIHN1cHBsaWVkIHpvb20uXHJcblx0ICogQHBhcmFtIG1hcmtlciB0byBiZSByZW1vdmVkIGZyb20gX2dyaWRVbmNsdXN0ZXJlZC5cclxuXHQgKiBAcGFyYW0geiBpbnRlZ2VyIGJvdHRvbSBzdGFydCB6b29tIGxldmVsIChpbmNsdWRlZClcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkOiBmdW5jdGlvbiAobWFya2VyLCB6KSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XHJcblxyXG5cdFx0Zm9yICg7IHogPj0gbWluWm9vbTsgei0tKSB7XHJcblx0XHRcdGlmICghZ3JpZFVuY2x1c3RlcmVkW3pdLnJlbW92ZU9iamVjdChtYXJrZXIsIG1hcC5wcm9qZWN0KG1hcmtlci5nZXRMYXRMbmcoKSwgeikpKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hpbGRNYXJrZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRhcmdldC5fX2RyYWdTdGFydCA9IGUudGFyZ2V0Ll9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0X2NoaWxkTWFya2VyTW92ZWQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2lnbm9yZU1vdmUgJiYgIWUudGFyZ2V0Ll9fZHJhZ1N0YXJ0KSB7XHJcblx0XHRcdHZhciBpc1BvcHVwT3BlbiA9IGUudGFyZ2V0Ll9wb3B1cCAmJiBlLnRhcmdldC5fcG9wdXAuaXNPcGVuKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGUub2xkTGF0TG5nLCBlLmxhdGxuZyk7XHJcblxyXG5cdFx0XHRpZiAoaXNQb3B1cE9wZW4pIHtcclxuXHRcdFx0XHRlLnRhcmdldC5vcGVuUG9wdXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChsYXllciwgZnJvbSwgdG8pIHtcclxuXHRcdGxheWVyLl9sYXRsbmcgPSBmcm9tO1xyXG5cdFx0dGhpcy5yZW1vdmVMYXllcihsYXllcik7XHJcblxyXG5cdFx0bGF5ZXIuX2xhdGxuZyA9IHRvO1xyXG5cdFx0dGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0X2NoaWxkTWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLnRhcmdldC5fX2RyYWdTdGFydCkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0LCBlLnRhcmdldC5fbGF0bG5nKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSBlLnRhcmdldC5fX2RyYWdTdGFydDtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly9JbnRlcm5hbCBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYSBtYXJrZXIgZnJvbSBldmVyeXRoaW5nLlxyXG5cdC8vZG9udFVwZGF0ZU1hcDogc2V0IHRvIHRydWUgaWYgeW91IHdpbGwgaGFuZGxlIHVwZGF0aW5nIHRoZSBtYXAgbWFudWFsbHkgKGZvciBidWxrIGZ1bmN0aW9ucylcclxuXHRfcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChtYXJrZXIsIHJlbW92ZUZyb21EaXN0YW5jZUdyaWQsIGRvbnRVcGRhdGVNYXApIHtcclxuXHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXHJcblx0XHRcdGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcclxuXHRcdFx0ZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XHJcblxyXG5cdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIGRpc3RhbmNlIGNsdXN0ZXJzIGl0IG1pZ2h0IGJlIGluXHJcblx0XHRpZiAocmVtb3ZlRnJvbURpc3RhbmNlR3JpZCkge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkKG1hcmtlciwgdGhpcy5fbWF4Wm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Xb3JrIG91ciB3YXkgdXAgdGhlIGNsdXN0ZXJzIHJlbW92aW5nIHRoZW0gYXMgd2UgZ28gaWYgcmVxdWlyZWRcclxuXHRcdHZhciBjbHVzdGVyID0gbWFya2VyLl9fcGFyZW50LFxyXG5cdFx0XHRtYXJrZXJzID0gY2x1c3Rlci5fbWFya2VycyxcclxuXHRcdFx0b3RoZXJNYXJrZXI7XHJcblxyXG5cdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBpbW1lZGlhdGUgcGFyZW50cyBtYXJrZXIgbGlzdFxyXG5cdFx0dGhpcy5fYXJyYXlTcGxpY2UobWFya2VycywgbWFya2VyKTtcclxuXHJcblx0XHR3aGlsZSAoY2x1c3Rlcikge1xyXG5cdFx0XHRjbHVzdGVyLl9jaGlsZENvdW50LS07XHJcblx0XHRcdGNsdXN0ZXIuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKGNsdXN0ZXIuX3pvb20gPCBtaW5ab29tKSB7XHJcblx0XHRcdFx0Ly9Ub3AgbGV2ZWwsIGRvIG5vdGhpbmdcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fSBlbHNlIGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkICYmIGNsdXN0ZXIuX2NoaWxkQ291bnQgPD0gMSkgeyAvL0NsdXN0ZXIgbm8gbG9uZ2VyIHJlcXVpcmVkXHJcblx0XHRcdFx0Ly9XZSBuZWVkIHRvIHB1c2ggdGhlIG90aGVyIG1hcmtlciB1cCB0byB0aGUgcGFyZW50XHJcblx0XHRcdFx0b3RoZXJNYXJrZXIgPSBjbHVzdGVyLl9tYXJrZXJzWzBdID09PSBtYXJrZXIgPyBjbHVzdGVyLl9tYXJrZXJzWzFdIDogY2x1c3Rlci5fbWFya2Vyc1swXTtcclxuXHJcblx0XHRcdFx0Ly9VcGRhdGUgZGlzdGFuY2UgZ3JpZFxyXG5cdFx0XHRcdGdyaWRDbHVzdGVyc1tjbHVzdGVyLl96b29tXS5yZW1vdmVPYmplY3QoY2x1c3RlciwgbWFwLnByb2plY3QoY2x1c3Rlci5fY0xhdExuZywgY2x1c3Rlci5fem9vbSkpO1xyXG5cdFx0XHRcdGdyaWRVbmNsdXN0ZXJlZFtjbHVzdGVyLl96b29tXS5hZGRPYmplY3Qob3RoZXJNYXJrZXIsIG1hcC5wcm9qZWN0KG90aGVyTWFya2VyLmdldExhdExuZygpLCBjbHVzdGVyLl96b29tKSk7XHJcblxyXG5cdFx0XHRcdC8vTW92ZSBvdGhlck1hcmtlciB1cCB0byBwYXJlbnRcclxuXHRcdFx0XHR0aGlzLl9hcnJheVNwbGljZShjbHVzdGVyLl9fcGFyZW50Ll9jaGlsZENsdXN0ZXJzLCBjbHVzdGVyKTtcclxuXHRcdFx0XHRjbHVzdGVyLl9fcGFyZW50Ll9tYXJrZXJzLnB1c2gob3RoZXJNYXJrZXIpO1xyXG5cdFx0XHRcdG90aGVyTWFya2VyLl9fcGFyZW50ID0gY2x1c3Rlci5fX3BhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKGNsdXN0ZXIuX2ljb24pIHtcclxuXHRcdFx0XHRcdC8vQ2x1c3RlciBpcyBjdXJyZW50bHkgb24gdGhlIG1hcCwgbmVlZCB0byBwdXQgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGluc3RlYWRcclxuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGNsdXN0ZXIpO1xyXG5cdFx0XHRcdFx0aWYgKCFkb250VXBkYXRlTWFwKSB7XHJcblx0XHRcdFx0XHRcdGZnLmFkZExheWVyKG90aGVyTWFya2VyKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2x1c3Rlci5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y2x1c3RlciA9IGNsdXN0ZXIuX19wYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcclxuXHR9LFxyXG5cclxuXHRfaXNPcklzUGFyZW50OiBmdW5jdGlvbiAoZWwsIG9lbCkge1xyXG5cdFx0d2hpbGUgKG9lbCkge1xyXG5cdFx0XHRpZiAoZWwgPT09IG9lbCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG9lbCA9IG9lbC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmZpcmVcclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoZGF0YSAmJiBkYXRhLmxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSB7XHJcblx0XHRcdC8vUHJldmVudCBtdWx0aXBsZSBjbHVzdGVybW91c2VvdmVyL29mZiBldmVudHMgaWYgdGhlIGljb24gaXMgbWFkZSB1cCBvZiBzdGFja2VkIGRpdnMgKERvZXNuJ3Qgd29yayBpbiBpZSA8PSA4LCBubyByZWxhdGVkVGFyZ2V0KVxyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50ICYmIHRoaXMuX2lzT3JJc1BhcmVudChkYXRhLmxheWVyLl9pY29uLCBkYXRhLm9yaWdpbmFsRXZlbnQucmVsYXRlZFRhcmdldCkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZSA9ICdjbHVzdGVyJyArIHR5cGU7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmZpcmUuY2FsbCh0aGlzLCB0eXBlLCBkYXRhLCBwcm9wYWdhdGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmxpc3RlbnNcclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHRyZXR1cm4gTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCB0eXBlLCBwcm9wYWdhdGUpIHx8IEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5saXN0ZW5zLmNhbGwodGhpcywgJ2NsdXN0ZXInICsgdHlwZSwgcHJvcGFnYXRlKTtcclxuXHR9LFxyXG5cclxuXHQvL0RlZmF1bHQgZnVuY3Rpb25hbGl0eVxyXG5cdF9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uOiBmdW5jdGlvbiAoY2x1c3Rlcikge1xyXG5cdFx0dmFyIGNoaWxkQ291bnQgPSBjbHVzdGVyLmdldENoaWxkQ291bnQoKTtcclxuXHJcblx0XHR2YXIgYyA9ICcgbWFya2VyLWNsdXN0ZXItJztcclxuXHRcdGlmIChjaGlsZENvdW50IDwgMTApIHtcclxuXHRcdFx0YyArPSAnc21hbGwnO1xyXG5cdFx0fSBlbHNlIGlmIChjaGlsZENvdW50IDwgMTAwKSB7XHJcblx0XHRcdGMgKz0gJ21lZGl1bSc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjICs9ICdsYXJnZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkRpdkljb24oeyBodG1sOiAnPGRpdj48c3Bhbj4nICsgY2hpbGRDb3VudCArICc8L3NwYW4+PC9kaXY+JywgY2xhc3NOYW1lOiAnbWFya2VyLWNsdXN0ZXInICsgYywgaWNvblNpemU6IG5ldyBMLlBvaW50KDQwLCA0MCkgfSk7XHJcblx0fSxcclxuXHJcblx0X2JpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgc3BpZGVyZnlPbk1heFpvb20gPSB0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20sXHJcblx0XHQgICAgc2hvd0NvdmVyYWdlT25Ib3ZlciA9IHRoaXMub3B0aW9ucy5zaG93Q292ZXJhZ2VPbkhvdmVyLFxyXG5cdFx0ICAgIHpvb21Ub0JvdW5kc09uQ2xpY2sgPSB0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljaztcclxuXHJcblx0XHQvL1pvb20gb24gY2x1c3RlciBjbGljayBvciBzcGlkZXJmeSBpZiB3ZSBhcmUgYXQgdGhlIGxvd2VzdCBsZXZlbFxyXG5cdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5vbignY2x1c3RlcmNsaWNrJywgdGhpcy5fem9vbU9yU3BpZGVyZnksIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vU2hvdyBjb252ZXggaHVsbCAoYm91bmRhcnkpIHBvbHlnb24gb24gbW91c2Ugb3ZlclxyXG5cdFx0aWYgKHNob3dDb3ZlcmFnZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PclNwaWRlcmZ5OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGNsdXN0ZXIgPSBlLmxheWVyLFxyXG5cdFx0ICAgIGJvdHRvbUNsdXN0ZXIgPSBjbHVzdGVyO1xyXG5cclxuXHRcdHdoaWxlIChib3R0b21DbHVzdGVyLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRib3R0b21DbHVzdGVyID0gYm90dG9tQ2x1c3Rlci5fY2hpbGRDbHVzdGVyc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYm90dG9tQ2x1c3Rlci5fem9vbSA9PT0gdGhpcy5fbWF4Wm9vbSAmJlxyXG5cdFx0XHRib3R0b21DbHVzdGVyLl9jaGlsZENvdW50ID09PSBjbHVzdGVyLl9jaGlsZENvdW50ICYmXHJcblx0XHRcdHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSkge1xyXG5cclxuXHRcdFx0Ly8gQWxsIGNoaWxkIG1hcmtlcnMgYXJlIGNvbnRhaW5lZCBpbiBhIHNpbmdsZSBjbHVzdGVyIGZyb20gdGhpcy5fbWF4Wm9vbSB0byB0aGlzIGNsdXN0ZXIuXHJcblx0XHRcdGNsdXN0ZXIuc3BpZGVyZnkoKTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2spIHtcclxuXHRcdFx0Y2x1c3Rlci56b29tVG9Cb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGb2N1cyB0aGUgbWFwIGFnYWluIGZvciBrZXlib2FyZCB1c2Vycy5cclxuXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3Nob3dDb3ZlcmFnZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9zaG93blBvbHlnb24pIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XHJcblx0XHR9XHJcblx0XHRpZiAoZS5sYXllci5nZXRDaGlsZENvdW50KCkgPiAyICYmIGUubGF5ZXIgIT09IHRoaXMuX3NwaWRlcmZpZWQpIHtcclxuXHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbmV3IEwuUG9seWdvbihlLmxheWVyLmdldENvbnZleEh1bGwoKSwgdGhpcy5vcHRpb25zLnBvbHlnb25PcHRpb25zKTtcclxuXHRcdFx0bWFwLmFkZExheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2hpZGVDb3ZlcmFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcclxuXHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbnVsbDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdW5iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3BpZGVyZnlPbk1heFpvb20gPSB0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20sXHJcblx0XHRcdHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3ZlcixcclxuXHRcdFx0em9vbVRvQm91bmRzT25DbGljayA9IHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrLFxyXG5cdFx0XHRtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJjbGljaycsIHRoaXMuX3pvb21PclNwaWRlcmZ5LCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdjbHVzdGVybW91c2VvdmVyJywgdGhpcy5fc2hvd0NvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyAvL01heSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYnkgYSB6b29tRW5kIGhhbmRsZXJcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fbWVyZ2VTcGxpdENsdXN0ZXJzKCk7XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcclxuXHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3Qm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XHJcblxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIG5ld0JvdW5kcyk7XHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSksIG5ld0JvdW5kcyk7XHJcblxyXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gbmV3Qm91bmRzO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH0sXHJcblxyXG5cdF9nZW5lcmF0ZUluaXRpYWxDbHVzdGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1heFpvb20gPSBNYXRoLmNlaWwodGhpcy5fbWFwLmdldE1heFpvb20oKSksXHJcblx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxyXG5cdFx0XHRyYWRpdXMgPSB0aGlzLm9wdGlvbnMubWF4Q2x1c3RlclJhZGl1cyxcclxuXHRcdFx0cmFkaXVzRm4gPSByYWRpdXM7XHJcblxyXG5cdFx0Ly9JZiB3ZSBqdXN0IHNldCBtYXhDbHVzdGVyUmFkaXVzIHRvIGEgc2luZ2xlIG51bWJlciwgd2UgbmVlZCB0byBjcmVhdGVcclxuXHRcdC8vYSBzaW1wbGUgZnVuY3Rpb24gdG8gcmV0dXJuIHRoYXQgbnVtYmVyLiBPdGhlcndpc2UsIHdlIGp1c3QgaGF2ZSB0b1xyXG5cdFx0Ly91c2UgdGhlIGZ1bmN0aW9uIHdlJ3ZlIHBhc3NlZCBpbi5cclxuXHRcdGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0cmFkaXVzRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByYWRpdXM7IH07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSAhPT0gbnVsbCkge1xyXG5cdFx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLmRpc2FibGVDbHVzdGVyaW5nQXRab29tIC0gMTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX21heFpvb20gPSBtYXhab29tO1xyXG5cdFx0dGhpcy5fZ3JpZENsdXN0ZXJzID0ge307XHJcblx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWQgPSB7fTtcclxuXHJcblx0XHQvL1NldCB1cCBEaXN0YW5jZUdyaWRzIGZvciBlYWNoIHpvb21cclxuXHRcdGZvciAodmFyIHpvb20gPSBtYXhab29tOyB6b29tID49IG1pblpvb207IHpvb20tLSkge1xyXG5cdFx0XHR0aGlzLl9ncmlkQ2x1c3RlcnNbem9vbV0gPSBuZXcgTC5EaXN0YW5jZUdyaWQocmFkaXVzRm4oem9vbSkpO1xyXG5cdFx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWRbem9vbV0gPSBuZXcgTC5EaXN0YW5jZUdyaWQocmFkaXVzRm4oem9vbSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluc3RhbnRpYXRlIHRoZSBhcHByb3ByaWF0ZSBMLk1hcmtlckNsdXN0ZXIgY2xhc3MgKGFuaW1hdGVkIG9yIG5vdCkuXHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCBtaW5ab29tIC0gMSk7XHJcblx0fSxcclxuXHJcblx0Ly9ab29tOiBab29tIHRvIHN0YXJ0IGFkZGluZyBhdCAoUGFzcyB0aGlzLl9tYXhab29tIHRvIHN0YXJ0IGF0IHRoZSBib3R0b20pXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIHpvb20pIHtcclxuXHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXHJcblx0XHQgICAgZ3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcclxuXHRcdCAgICBtYXJrZXJQb2ludCwgejtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNpbmdsZU1hcmtlck1vZGUpIHtcclxuXHRcdFx0dGhpcy5fb3ZlcnJpZGVNYXJrZXJJY29uKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5vbih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbG93ZXN0IHpvb20gbGV2ZWwgdG8gc2xvdCB0aGlzIG9uZSBpblxyXG5cdFx0Zm9yICg7IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XHJcblx0XHRcdG1hcmtlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QobGF5ZXIuZ2V0TGF0TG5nKCksIHpvb20pOyAvLyBjYWxjdWxhdGUgcGl4ZWwgcG9zaXRpb25cclxuXHJcblx0XHRcdC8vVHJ5IGZpbmQgYSBjbHVzdGVyIGNsb3NlIGJ5XHJcblx0XHRcdHZhciBjbG9zZXN0ID0gZ3JpZENsdXN0ZXJzW3pvb21dLmdldE5lYXJPYmplY3QobWFya2VyUG9pbnQpO1xyXG5cdFx0XHRpZiAoY2xvc2VzdCkge1xyXG5cdFx0XHRcdGNsb3Nlc3QuX2FkZENoaWxkKGxheWVyKTtcclxuXHRcdFx0XHRsYXllci5fX3BhcmVudCA9IGNsb3Nlc3Q7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1RyeSBmaW5kIGEgbWFya2VyIGNsb3NlIGJ5IHRvIGZvcm0gYSBuZXcgY2x1c3RlciB3aXRoXHJcblx0XHRcdGNsb3Nlc3QgPSBncmlkVW5jbHVzdGVyZWRbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XHJcblx0XHRcdGlmIChjbG9zZXN0KSB7XHJcblx0XHRcdFx0dmFyIHBhcmVudCA9IGNsb3Nlc3QuX19wYXJlbnQ7XHJcblx0XHRcdFx0aWYgKHBhcmVudCkge1xyXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIoY2xvc2VzdCwgZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9DcmVhdGUgbmV3IGNsdXN0ZXIgd2l0aCB0aGVzZSAyIGluIGl0XHJcblxyXG5cdFx0XHRcdHZhciBuZXdDbHVzdGVyID0gbmV3IHRoaXMuX21hcmtlckNsdXN0ZXIodGhpcywgem9vbSwgY2xvc2VzdCwgbGF5ZXIpO1xyXG5cdFx0XHRcdGdyaWRDbHVzdGVyc1t6b29tXS5hZGRPYmplY3QobmV3Q2x1c3RlciwgdGhpcy5fbWFwLnByb2plY3QobmV3Q2x1c3Rlci5fY0xhdExuZywgem9vbSkpO1xyXG5cdFx0XHRcdGNsb3Nlc3QuX19wYXJlbnQgPSBuZXdDbHVzdGVyO1xyXG5cdFx0XHRcdGxheWVyLl9fcGFyZW50ID0gbmV3Q2x1c3RlcjtcclxuXHJcblx0XHRcdFx0Ly9GaXJzdCBjcmVhdGUgYW55IG5ldyBpbnRlcm1lZGlhdGUgcGFyZW50IGNsdXN0ZXJzIHRoYXQgZG9uJ3QgZXhpc3RcclxuXHRcdFx0XHR2YXIgbGFzdFBhcmVudCA9IG5ld0NsdXN0ZXI7XHJcblx0XHRcdFx0Zm9yICh6ID0gem9vbSAtIDE7IHogPiBwYXJlbnQuX3pvb207IHotLSkge1xyXG5cdFx0XHRcdFx0bGFzdFBhcmVudCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIHosIGxhc3RQYXJlbnQpO1xyXG5cdFx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pdLmFkZE9iamVjdChsYXN0UGFyZW50LCB0aGlzLl9tYXAucHJvamVjdChjbG9zZXN0LmdldExhdExuZygpLCB6KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBhcmVudC5fYWRkQ2hpbGQobGFzdFBhcmVudCk7XHJcblxyXG5cdFx0XHRcdC8vUmVtb3ZlIGNsb3Nlc3QgZnJvbSB0aGlzIHpvb20gbGV2ZWwgYW5kIGFueSBhYm92ZSB0aGF0IGl0IGlzIGluLCByZXBsYWNlIHdpdGggbmV3Q2x1c3RlclxyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQoY2xvc2VzdCwgem9vbSk7XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9EaWRuJ3QgbWFuYWdlIHRvIGNsdXN0ZXIgaW4gYXQgdGhpcyB6b29tLCByZWNvcmQgdXMgYXMgYSBtYXJrZXIgaGVyZSBhbmQgY29udGludWUgdXB3YXJkc1xyXG5cdFx0XHRncmlkVW5jbHVzdGVyZWRbem9vbV0uYWRkT2JqZWN0KGxheWVyLCBtYXJrZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9EaWRuJ3QgZ2V0IGluIGFueXRoaW5nLCBhZGQgdXMgdG8gdGhlIHRvcFxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9hZGRDaGlsZChsYXllcik7XHJcblx0XHRsYXllci5fX3BhcmVudCA9IHRoaXMuX3RvcENsdXN0ZXJMZXZlbDtcclxuXHRcdHJldHVybjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWZyZXNoZXMgdGhlIGljb24gb2YgYWxsIFwiZGlydHlcIiB2aXNpYmxlIGNsdXN0ZXJzLlxyXG5cdCAqIE5vbi12aXNpYmxlIFwiZGlydHlcIiBjbHVzdGVycyB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGV5IGFyZSBhZGRlZCB0byB0aGUgbWFwLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3JlZnJlc2hDbHVzdGVyc0ljb25zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdGlmIChjIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyICYmIGMuX2ljb25OZWVkc1VwZGF0ZSkge1xyXG5cdFx0XHRcdGMuX3VwZGF0ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly9FbnF1ZXVlIGNvZGUgdG8gZmlyZSBhZnRlciB0aGUgbWFya2VyIGV4cGFuZC9jb250cmFjdCBoYXMgaGFwcGVuZWRcclxuXHRfZW5xdWV1ZTogZnVuY3Rpb24gKGZuKSB7XHJcblx0XHR0aGlzLl9xdWV1ZS5wdXNoKGZuKTtcclxuXHRcdGlmICghdGhpcy5fcXVldWVUaW1lb3V0KSB7XHJcblx0XHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3Byb2Nlc3NRdWV1ZSwgdGhpcyksIDMwMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX3F1ZXVlW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3F1ZXVlVGltZW91dCk7XHJcblx0XHR0aGlzLl9xdWV1ZVRpbWVvdXQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8vTWVyZ2UgYW5kIHNwbGl0IGFueSBleGlzdGluZyBjbHVzdGVycyB0aGF0IGFyZSB0b28gYmlnIG9yIHNtYWxsXHJcblx0X21lcmdlU3BsaXRDbHVzdGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcFpvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XHJcblxyXG5cdFx0Ly9JbiBjYXNlIHdlIGFyZSBzdGFydGluZyB0byBzcGxpdCBiZWZvcmUgdGhlIGFuaW1hdGlvbiBmaW5pc2hlZFxyXG5cdFx0dGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb20gPCBtYXBab29tICYmIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKSkgeyAvL1pvb20gaW4sIHNwbGl0XHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblx0XHRcdC8vUmVtb3ZlIGNsdXN0ZXJzIG5vdyBvZmYgc2NyZWVuXHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCB0aGlzLl96b29tLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblxyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25ab29tSW4odGhpcy5fem9vbSwgbWFwWm9vbSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0aGlzLl96b29tID4gbWFwWm9vbSkgeyAvL1pvb20gb3V0LCBtZXJnZVxyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xyXG5cclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbU91dCh0aGlzLl96b29tLCBtYXBab29tKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX21vdmVFbmQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL0dldHMgdGhlIG1hcHMgdmlzaWJsZSBib3VuZHMgZXhwYW5kZWQgaW4gZWFjaCBkaXJlY3Rpb24gYnkgdGhlIHNpemUgb2YgdGhlIHNjcmVlbiAoc28gdGhlIHVzZXIgY2Fubm90IHNlZSBhbiBhcmVhIHdlIGRvIG5vdCBjb3ZlciBpbiBvbmUgcGFuKVxyXG5cdF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9tYXBCb3VuZHNJbmZpbml0ZTtcclxuXHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLm1vYmlsZSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hlY2tCb3VuZHNNYXhMYXQodGhpcy5fbWFwLmdldEJvdW5kcygpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tCb3VuZHNNYXhMYXQodGhpcy5fbWFwLmdldEJvdW5kcygpLnBhZCgxKSk7IC8vIFBhZGRpbmcgZXhwYW5kcyB0aGUgYm91bmRzIGJ5IGl0cyBvd24gZGltZW5zaW9ucyBidXQgc2NhbGVkIHdpdGggdGhlIGdpdmVuIGZhY3Rvci5cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBFeHBhbmRzIHRoZSBsYXRpdHVkZSB0byBJbmZpbml0eSAob3IgLUluZmluaXR5KSBpZiB0aGUgaW5wdXQgYm91bmRzIHJlYWNoIHRoZSBtYXAgcHJvamVjdGlvbiBtYXhpbXVtIGRlZmluZWQgbGF0aXR1ZGVcclxuXHQgKiAoaW4gdGhlIGNhc2Ugb2YgV2ViL1NwaGVyaWNhbCBNZXJjYXRvciwgaXQgaXMgODUuMDUxMTI4Nzc5OCAvIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWVyY2F0b3IjRm9ybXVsYXMpLlxyXG5cdCAqIE90aGVyd2lzZSwgdGhlIHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzIG9wdGlvbiB3aWxsIHJlbW92ZSBtYXJrZXJzIGJleW9uZCB0aGF0IGxpbWl0LCB3aGVyZWFzIHRoZSBzYW1lIG1hcmtlcnMgd2l0aG91dFxyXG5cdCAqIHRoaXMgb3B0aW9uIChvciBvdXRzaWRlIE1DRykgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9uIGZsb29yZWQgKGNlaWxlZCkgYnkgdGhlIHByb2plY3Rpb24gYW5kIHJlbmRlcmVkIGF0IHRoYXQgbGltaXQsXHJcblx0ICogbWFraW5nIHRoZSB1c2VyIHRoaW5rIHRoYXQgTUNHIFwiZWF0c1wiIHRoZW0gYW5kIG5ldmVyIGRpc3BsYXlzIHRoZW0gYWdhaW4uXHJcblx0ICogQHBhcmFtIGJvdW5kcyBMLkxhdExuZ0JvdW5kc1xyXG5cdCAqIEByZXR1cm5zIHtMLkxhdExuZ0JvdW5kc31cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jaGVja0JvdW5kc01heExhdDogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIG1heExhdCA9IHRoaXMuX21heExhdDtcclxuXHJcblx0XHRpZiAobWF4TGF0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKGJvdW5kcy5nZXROb3J0aCgpID49IG1heExhdCkge1xyXG5cdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IEluZmluaXR5O1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChib3VuZHMuZ2V0U291dGgoKSA8PSAtbWF4TGF0KSB7XHJcblx0XHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gLUluZmluaXR5O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvL1NoYXJlZCBhbmltYXRpb24gY29kZVxyXG5cdF9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcclxuXHRcdGlmIChuZXdDbHVzdGVyID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fSBlbHNlIGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID09PSAyKSB7XHJcblx0XHRcdG5ld0NsdXN0ZXIuX2FkZFRvTWFwKCk7XHJcblxyXG5cdFx0XHR2YXIgbWFya2VycyA9IG5ld0NsdXN0ZXIuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtYXJrZXJzWzBdKTtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcnNbMV0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmV3Q2x1c3Rlci5fdXBkYXRlSWNvbigpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4dHJhY3RzIGluZGl2aWR1YWwgKGkuZS4gbm9uLWdyb3VwKSBsYXllcnMgZnJvbSBhIExheWVyIEdyb3VwLlxyXG5cdCAqIEBwYXJhbSBncm91cCB0byBleHRyYWN0IGxheWVycyBmcm9tLlxyXG5cdCAqIEBwYXJhbSBvdXRwdXQge0FycmF5fSBpbiB3aGljaCB0byBzdG9yZSB0aGUgZXh0cmFjdGVkIGxheWVycy5cclxuXHQgKiBAcmV0dXJucyB7KnxBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9leHRyYWN0Tm9uR3JvdXBMYXllcnM6IGZ1bmN0aW9uIChncm91cCwgb3V0cHV0KSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gZ3JvdXAuZ2V0TGF5ZXJzKCksXHJcblx0XHQgICAgaSA9IDAsXHJcblx0XHQgICAgbGF5ZXI7XHJcblxyXG5cdFx0b3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xyXG5cclxuXHRcdGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxheWVyID0gbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKGxheWVyLCBvdXRwdXQpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvdXRwdXQucHVzaChsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSBzaW5nbGVNYXJrZXJNb2RlIG9wdGlvbi5cclxuXHQgKiBAcGFyYW0gbGF5ZXIgTWFya2VyIHRvIHJlLXN0eWxlIHVzaW5nIHRoZSBDbHVzdGVycyBpY29uQ3JlYXRlRnVuY3Rpb24uXHJcblx0ICogQHJldHVybnMge0wuSWNvbn0gVGhlIG5ld2x5IGNyZWF0ZWQgaWNvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9vdmVycmlkZU1hcmtlckljb246IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGljb24gPSBsYXllci5vcHRpb25zLmljb24gPSB0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHtcclxuXHRcdFx0Z2V0Q2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRnZXRBbGxDaGlsZE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2xheWVyXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGljb247XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIENvbnN0YW50IGJvdW5kcyB1c2VkIGluIGNhc2Ugb3B0aW9uIFwicmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHNcIiBpcyBzZXQgdG8gZmFsc2UuXHJcbkwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xyXG5cdF9tYXBCb3VuZHNJbmZpbml0ZTogbmV3IEwuTGF0TG5nQm91bmRzKG5ldyBMLkxhdExuZygtSW5maW5pdHksIC1JbmZpbml0eSksIG5ldyBMLkxhdExuZyhJbmZpbml0eSwgSW5maW5pdHkpKVxyXG59KTtcclxuXHJcbkwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xyXG5cdF9ub0FuaW1hdGlvbjoge1xyXG5cdFx0Ly9Ob24gQW5pbWF0ZWQgdmVyc2lvbnMgb2YgZXZlcnl0aGluZ1xyXG5cdFx0X2FuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vRG8gbm90aGluZy4uLlxyXG5cdFx0fSxcclxuXHRcdF9hbmltYXRpb25ab29tSW46IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCk7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cclxuXHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXHJcblx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XHJcblx0XHR9LFxyXG5cdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCk7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cclxuXHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXHJcblx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XHJcblx0XHR9LFxyXG5cdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgbmV3Q2x1c3Rlcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3dpdGhBbmltYXRpb246IHtcclxuXHRcdC8vQW5pbWF0ZWQgdmVyc2lvbnMgaGVyZVxyXG5cdFx0X2FuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgKz0gJyBsZWFmbGV0LWNsdXN0ZXItYW5pbSc7XHJcblx0XHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbisrO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCksXHJcblx0XHRcdCAgICBmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcclxuXHRcdFx0ICAgIGk7XHJcblxyXG5cdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vQWRkIGFsbCBjaGlsZHJlbiBvZiBjdXJyZW50IGNsdXN0ZXJzIHRvIG1hcCBhbmQgcmVtb3ZlIHRob3NlIGNsdXN0ZXJzIGZyb20gbWFwXHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHkoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHR2YXIgc3RhcnRQb3MgPSBjLl9sYXRsbmcsXHJcblx0XHRcdFx0ICAgIG1hcmtlcnMgID0gYy5fbWFya2VycyxcclxuXHRcdFx0XHQgICAgbTtcclxuXHJcblx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMoc3RhcnRQb3MpKSB7XHJcblx0XHRcdFx0XHRzdGFydFBvcyA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoYy5faXNTaW5nbGVQYXJlbnQoKSAmJiBwcmV2aW91c1pvb21MZXZlbCArIDEgPT09IG5ld1pvb21MZXZlbCkgeyAvL0ltbWVkaWF0ZWx5IGFkZCB0aGUgbmV3IGNoaWxkIGFuZCByZW1vdmUgdXNcclxuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgYm91bmRzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly9GYWRlIG91dCBvbGQgY2x1c3RlclxyXG5cdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKHN0YXJ0UG9zLCBuZXdab29tTGV2ZWwsIGJvdW5kcyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL1JlbW92ZSBhbGwgbWFya2VycyB0aGF0IGFyZW4ndCB2aXNpYmxlIGFueSBtb3JlXHJcblx0XHRcdFx0Ly9UT0RPOiBEbyB3ZSBhY3R1YWxseSBuZWVkIHRvIGRvIHRoaXMgb24gdGhlIGhpZ2hlciBsZXZlbHMgdG9vP1xyXG5cdFx0XHRcdGZvciAoaSA9IG1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdG0gPSBtYXJrZXJzW2ldO1xyXG5cdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMobS5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XHJcblxyXG5cdFx0XHQvL1VwZGF0ZSBvcGFjaXRpZXNcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUJlY29tZVZpc2libGUoYm91bmRzLCBuZXdab29tTGV2ZWwpO1xyXG5cdFx0XHQvL1RPRE8gTWF5YmU/IFVwZGF0ZSBtYXJrZXJzIGluIF9yZWN1cnNpdmVseUJlY29tZVZpc2libGVcclxuXHRcdFx0ZmcuZWFjaExheWVyKGZ1bmN0aW9uIChuKSB7XHJcblx0XHRcdFx0aWYgKCEobiBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3RlcikgJiYgbi5faWNvbikge1xyXG5cdFx0XHRcdFx0bi5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwsIGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMobmV3Wm9vbUxldmVsKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvL1JlbW92ZSB0aGUgb2xkIGNsdXN0ZXJzIGFuZCBjbG9zZSB0aGUgem9vbSBhbmltYXRpb25cclxuXHRcdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0Ly91cGRhdGUgdGhlIHBvc2l0aW9ucyBvZiB0aGUganVzdCBhZGRlZCBjbHVzdGVycy9tYXJrZXJzXHJcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoYyk7XHJcblx0XHRcdFx0XHRjLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkVuZCgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUodGhpcy5fdG9wQ2x1c3RlckxldmVsLCBwcmV2aW91c1pvb21MZXZlbCAtIDEsIG5ld1pvb21MZXZlbCk7XHJcblxyXG5cdFx0XHQvL05lZWQgdG8gYWRkIG1hcmtlcnMgZm9yIHRob3NlIHRoYXQgd2VyZW4ndCBvbiB0aGUgbWFwIGJlZm9yZSBidXQgYXJlIG5vd1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHRcdFx0Ly9SZW1vdmUgbWFya2VycyB0aGF0IHdlcmUgb24gdGhlIG1hcCBiZWZvcmUgYnV0IHdvbid0IGJlIG5vd1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgcHJldmlvdXNab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcclxuXHRcdFx0dmFyIG1lID0gdGhpcyxcclxuXHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwO1xyXG5cclxuXHRcdFx0ZmcuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0XHRpZiAobmV3Q2x1c3RlciAhPT0gbGF5ZXIpIHtcclxuXHRcdFx0XHRpZiAobmV3Q2x1c3Rlci5fY2hpbGRDb3VudCA+IDIpIHsgLy9XYXMgYWxyZWFkeSBhIGNsdXN0ZXJcclxuXHJcblx0XHRcdFx0XHRuZXdDbHVzdGVyLl91cGRhdGVJY29uKCk7XHJcblx0XHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHJcblx0XHRcdFx0XHRsYXllci5fc2V0UG9zKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobmV3Q2x1c3Rlci5nZXRMYXRMbmcoKSkpO1xyXG5cdFx0XHRcdFx0bGF5ZXIuY2x1c3RlckhpZGUoKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobGF5ZXIpO1xyXG5cdFx0XHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xyXG5cclxuXHRcdFx0XHRcdFx0bWUuX2FuaW1hdGlvbkVuZCgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7IC8vSnVzdCBiZWNhbWUgYSBjbHVzdGVyXHJcblx0XHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xyXG5cclxuXHRcdFx0XHRcdG1lLl9hbmltYXRpb25TdGFydCgpO1xyXG5cdFx0XHRcdFx0bWUuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUobmV3Q2x1c3RlciwgdGhpcy5fbWFwLmdldE1heFpvb20oKSwgdGhpcy5fem9vbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gUHJpdmF0ZSBtZXRob2RzIGZvciBhbmltYXRlZCB2ZXJzaW9ucy5cclxuXHRfYW5pbWF0aW9uWm9vbU91dFNpbmdsZTogZnVuY3Rpb24gKGNsdXN0ZXIsIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XHJcblxyXG5cdFx0Ly9BbmltYXRlIGFsbCBvZiB0aGUgbWFya2VycyBpbiB0aGUgY2x1c3RlcnMgdG8gbW92ZSB0byB0aGVpciBjbHVzdGVyIGNlbnRlciBwb2ludFxyXG5cdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcChib3VuZHMsIG1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsICsgMSwgbmV3Wm9vbUxldmVsKTtcclxuXHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdC8vVXBkYXRlIHRoZSBvcGFjaXR5IChJZiB3ZSBpbW1lZGlhdGVseSBzZXQgaXQgdGhleSB3b24ndCBhbmltYXRlKVxyXG5cdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcclxuXHRcdGNsdXN0ZXIuX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZShib3VuZHMsIG5ld1pvb21MZXZlbCk7XHJcblxyXG5cdFx0Ly9UT0RPOiBNYXliZSB1c2UgdGhlIHRyYW5zaXRpb24gdGltaW5nIHN0dWZmIHRvIG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlXHJcblx0XHQvL1doZW4gdGhlIGFuaW1hdGlvbnMgYXJlIGRvbmUsIHRpZHkgdXBcclxuXHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Ly9UaGlzIGNsdXN0ZXIgc3RvcHBlZCBiZWluZyBhIGNsdXN0ZXIgYmVmb3JlIHRoZSB0aW1lb3V0IGZpcmVkXHJcblx0XHRcdGlmIChjbHVzdGVyLl9jaGlsZENvdW50ID09PSAxKSB7XHJcblx0XHRcdFx0dmFyIG0gPSBjbHVzdGVyLl9tYXJrZXJzWzBdO1xyXG5cdFx0XHRcdC8vSWYgd2Ugd2VyZSBpbiBhIGNsdXN0ZXIgYW5pbWF0aW9uIGF0IHRoZSB0aW1lIHRoZW4gdGhlIG9wYWNpdHkgYW5kIHBvc2l0aW9uIG9mIG91ciBjaGlsZCBjb3VsZCBiZSB3cm9uZyBub3csIHNvIGZpeCBpdFxyXG5cdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cdFx0XHRcdG0uc2V0TGF0TG5nKG0uZ2V0TGF0TG5nKCkpO1xyXG5cdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseShib3VuZHMsIG5ld1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgPSB0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNsdXN0ZXItYW5pbScsICcnKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbi0tO1xyXG5cdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcclxuXHR9LFxyXG5cclxuXHQvL0ZvcmNlIGEgYnJvd3NlciBsYXlvdXQgb2Ygc3R1ZmYgaW4gdGhlIG1hcFxyXG5cdC8vIFNob3VsZCBhcHBseSB0aGUgY3VycmVudCBvcGFjaXR5IGFuZCBsb2NhdGlvbiB0byBhbGwgZWxlbWVudHMgc28gd2UgY2FuIHVwZGF0ZSB0aGVtIGFnYWluIGZvciBhbiBhbmltYXRpb25cclxuXHRfZm9yY2VMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vSW4gbXkgdGVzdGluZyB0aGlzIHdvcmtzLCBpbmZhY3Qgb2Zmc2V0V2lkdGggb2YgYW55IGVsZW1lbnQgc2VlbXMgdG8gd29yay5cclxuXHRcdC8vQ291bGQgbG9vcCBhbGwgdGhpcy5fbGF5ZXJzIGFuZCBkbyB0aGlzIGZvciBlYWNoIF9pY29uIGlmIGl0IHN0b3BzIHdvcmtpbmdcclxuXHJcblx0XHRMLlV0aWwuZmFsc2VGbihkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5tYXJrZXJDbHVzdGVyR3JvdXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXJrZXJDbHVzdGVyR3JvdXAob3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyR3JvdXAuanMiLCJleHBvcnQgdmFyIE1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlci5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IEwuSWNvbi5wcm90b3R5cGUub3B0aW9ucyxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdyb3VwLCB6b29tLCBhLCBiKSB7XHJcblxyXG5cdFx0TC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhID8gKGEuX2NMYXRMbmcgfHwgYS5nZXRMYXRMbmcoKSkgOiBuZXcgTC5MYXRMbmcoMCwgMCksXHJcbiAgICAgICAgICAgIHsgaWNvbjogdGhpcywgcGFuZTogZ3JvdXAub3B0aW9ucy5jbHVzdGVyUGFuZSB9KTtcclxuXHJcblx0XHR0aGlzLl9ncm91cCA9IGdyb3VwO1xyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblxyXG5cdFx0dGhpcy5fbWFya2VycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDbHVzdGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDb3VudCA9IDA7XHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0aWYgKGEpIHtcclxuXHRcdFx0dGhpcy5fYWRkQ2hpbGQoYSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYikge1xyXG5cdFx0XHR0aGlzLl9hZGRDaGlsZChiKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL1JlY3Vyc2l2ZWx5IHJldHJpZXZlIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMgY2x1c3RlclxyXG5cdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKHN0b3JhZ2VBcnJheSkge1xyXG5cdFx0c3RvcmFnZUFycmF5ID0gc3RvcmFnZUFycmF5IHx8IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbaV0uZ2V0QWxsQ2hpbGRNYXJrZXJzKHN0b3JhZ2VBcnJheSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IHRoaXMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0c3RvcmFnZUFycmF5LnB1c2godGhpcy5fbWFya2Vyc1tqXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0b3JhZ2VBcnJheTtcclxuXHR9LFxyXG5cclxuXHQvL1JldHVybnMgdGhlIGNvdW50IG9mIGhvdyBtYW55IGNoaWxkIG1hcmtlcnMgd2UgaGF2ZVxyXG5cdGdldENoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGlsZENvdW50O1xyXG5cdH0sXHJcblxyXG5cdC8vWm9vbSB0byB0aGUgbWluaW11bSBvZiBzaG93aW5nIGFsbCBvZiB0aGUgY2hpbGQgbWFya2Vycywgb3IgdGhlIGV4dGVudHMgb2YgdGhpcyBjbHVzdGVyXHJcblx0em9vbVRvQm91bmRzOiBmdW5jdGlvbiAoZml0Qm91bmRzT3B0aW9ucykge1xyXG5cdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLnNsaWNlKCksXHJcblx0XHRcdG1hcCA9IHRoaXMuX2dyb3VwLl9tYXAsXHJcblx0XHRcdGJvdW5kc1pvb20gPSBtYXAuZ2V0Qm91bmRzWm9vbSh0aGlzLl9ib3VuZHMpLFxyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbSArIDEsXHJcblx0XHRcdG1hcFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxyXG5cdFx0XHRpO1xyXG5cclxuXHRcdC8vY2FsY3VsYXRlIGhvdyBmYXIgd2UgbmVlZCB0byB6b29tIGRvd24gdG8gc2VlIGFsbCBvZiB0aGUgbWFya2Vyc1xyXG5cdFx0d2hpbGUgKGNoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiBib3VuZHNab29tID4gem9vbSkge1xyXG5cdFx0XHR6b29tKys7XHJcblx0XHRcdHZhciBuZXdDbHVzdGVycyA9IFtdO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdG5ld0NsdXN0ZXJzID0gbmV3Q2x1c3RlcnMuY29uY2F0KGNoaWxkQ2x1c3RlcnNbaV0uX2NoaWxkQ2x1c3RlcnMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNoaWxkQ2x1c3RlcnMgPSBuZXdDbHVzdGVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYm91bmRzWm9vbSA+IHpvb20pIHtcclxuXHRcdFx0dGhpcy5fZ3JvdXAuX21hcC5zZXRWaWV3KHRoaXMuX2xhdGxuZywgem9vbSk7XHJcblx0XHR9IGVsc2UgaWYgKGJvdW5kc1pvb20gPD0gbWFwWm9vbSkgeyAvL0lmIGZpdEJvdW5kcyB3b3VsZG4ndCB6b29tIHVzIGRvd24sIHpvb20gdXMgZG93biBpbnN0ZWFkXHJcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIG1hcFpvb20gKyAxKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuZml0Qm91bmRzKHRoaXMuX2JvdW5kcywgZml0Qm91bmRzT3B0aW9ucyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX2JvdW5kcyk7XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dGhpcy5zZXRJY29uKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vQ2x1ZGdlIGZvciBJY29uLCB3ZSBwcmV0ZW5kIHRvIGJlIGFuIGljb24gZm9yIHBlcmZvcm1hbmNlXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb25OZWVkc1VwZGF0ZSkge1xyXG5cdFx0XHR0aGlzLl9pY29uT2JqID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24odGhpcyk7XHJcblx0XHRcdHRoaXMuX2ljb25OZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlSWNvbigpO1xyXG5cdH0sXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbk9iai5jcmVhdGVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHJcblx0X2FkZENoaWxkOiBmdW5jdGlvbiAobmV3MSwgaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcclxuXHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5fc2V0Q2x1c3RlckNlbnRlcihuZXcxKTtcclxuXHJcblx0XHRpZiAobmV3MSBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xyXG5cdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVycy5wdXNoKG5ldzEpO1xyXG5cdFx0XHRcdG5ldzEuX19wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2NoaWxkQ291bnQgKz0gbmV3MS5fY2hpbGRDb3VudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXJrZXJzLnB1c2gobmV3MSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fY2hpbGRDb3VudCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9fcGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX19wYXJlbnQuX2FkZENoaWxkKG5ldzEsIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1ha2VzIHN1cmUgdGhlIGNsdXN0ZXIgY2VudGVyIGlzIHNldC4gSWYgbm90LCB1c2VzIHRoZSBjaGlsZCBjZW50ZXIgaWYgaXQgaXMgYSBjbHVzdGVyLCBvciB0aGUgbWFya2VyIHBvc2l0aW9uLlxyXG5cdCAqIEBwYXJhbSBjaGlsZCBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2x1c3RlciBjZW50ZXIgaWYgbm90IGRlZmluZWQgeWV0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3NldENsdXN0ZXJDZW50ZXI6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jTGF0TG5nKSB7XHJcblx0XHRcdC8vIHdoZW4gY2x1c3RlcmluZywgdGFrZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgYXMgdGhlIGNsdXN0ZXIgY2VudGVyXHJcblx0XHRcdHRoaXMuX2NMYXRMbmcgPSBjaGlsZC5fY0xhdExuZyB8fCBjaGlsZC5fbGF0bG5nO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFzc2lnbnMgaW1wb3NzaWJsZSBib3VuZGluZyB2YWx1ZXMgc28gdGhhdCB0aGUgbmV4dCBleHRlbmQgZW50aXJlbHkgZGV0ZXJtaW5lcyB0aGUgbmV3IGJvdW5kcy5cclxuXHQgKiBUaGlzIG1ldGhvZCBhdm9pZHMgaGF2aW5nIHRvIHRyYXNoIHRoZSBwcmV2aW91cyBMLkxhdExuZ0JvdW5kcyBvYmplY3QgYW5kIHRvIGNyZWF0ZSBhIG5ldyBvbmUsIHdoaWNoIGlzIG11Y2ggc2xvd2VyIGZvciB0aGlzIGNsYXNzLlxyXG5cdCAqIEFzIGxvbmcgYXMgdGhlIGJvdW5kcyBhcmUgbm90IGV4dGVuZGVkLCBtb3N0IG90aGVyIG1ldGhvZHMgd291bGQgcHJvYmFibHkgZmFpbCwgYXMgdGhleSB3b3VsZCB3aXRoIGJvdW5kcyBpbml0aWFsaXplZCBidXQgbm90IGV4dGVuZGVkLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3Jlc2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xyXG5cclxuXHRcdGlmIChib3VuZHMuX3NvdXRoV2VzdCkge1xyXG5cdFx0XHRib3VuZHMuX3NvdXRoV2VzdC5sYXQgPSBJbmZpbml0eTtcclxuXHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubG5nID0gSW5maW5pdHk7XHJcblx0XHR9XHJcblx0XHRpZiAoYm91bmRzLl9ub3J0aEVhc3QpIHtcclxuXHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubGF0ID0gLUluZmluaXR5O1xyXG5cdFx0XHRib3VuZHMuX25vcnRoRWFzdC5sbmcgPSAtSW5maW5pdHk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlY2FsY3VsYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFya2VycyA9IHRoaXMuX21hcmtlcnMsXHJcblx0XHQgICAgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMsXHJcblx0XHQgICAgbGF0U3VtID0gMCxcclxuXHRcdCAgICBsbmdTdW0gPSAwLFxyXG5cdFx0ICAgIHRvdGFsQ291bnQgPSB0aGlzLl9jaGlsZENvdW50LFxyXG5cdFx0ICAgIGksIGNoaWxkLCBjaGlsZExhdExuZywgY2hpbGRDb3VudDtcclxuXHJcblx0XHQvLyBDYXNlIHdoZXJlIGFsbCBtYXJrZXJzIGFyZSByZW1vdmVkIGZyb20gdGhlIG1hcCBhbmQgd2UgYXJlIGxlZnQgd2l0aCBqdXN0IGFuIGVtcHR5IF90b3BDbHVzdGVyTGV2ZWwuXHJcblx0XHRpZiAodG90YWxDb3VudCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVzZXQgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgb2JqZWN0LCBmb3IgcGVyZm9ybWFuY2UuXHJcblx0XHR0aGlzLl9yZXNldEJvdW5kcygpO1xyXG5cclxuXHRcdC8vIENoaWxkIG1hcmtlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjaGlsZExhdExuZyA9IG1hcmtlcnNbaV0uX2xhdGxuZztcclxuXHJcblx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQoY2hpbGRMYXRMbmcpO1xyXG5cclxuXHRcdFx0bGF0U3VtICs9IGNoaWxkTGF0TG5nLmxhdDtcclxuXHRcdFx0bG5nU3VtICs9IGNoaWxkTGF0TG5nLmxuZztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGlsZCBjbHVzdGVycy5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZENsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNoaWxkID0gY2hpbGRDbHVzdGVyc1tpXTtcclxuXHJcblx0XHRcdC8vIFJlLWNvbXB1dGUgY2hpbGQgYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbiBmaXJzdCBpZiBuZWNlc3NhcnkuXHJcblx0XHRcdGlmIChjaGlsZC5fYm91bmRzTmVlZFVwZGF0ZSkge1xyXG5cdFx0XHRcdGNoaWxkLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGNoaWxkLl9ib3VuZHMpO1xyXG5cclxuXHRcdFx0Y2hpbGRMYXRMbmcgPSBjaGlsZC5fd0xhdExuZztcclxuXHRcdFx0Y2hpbGRDb3VudCA9IGNoaWxkLl9jaGlsZENvdW50O1xyXG5cclxuXHRcdFx0bGF0U3VtICs9IGNoaWxkTGF0TG5nLmxhdCAqIGNoaWxkQ291bnQ7XHJcblx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmcgKiBjaGlsZENvdW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRoaXMuX3dMYXRMbmcgPSBuZXcgTC5MYXRMbmcobGF0U3VtIC8gdG90YWxDb3VudCwgbG5nU3VtIC8gdG90YWxDb3VudCk7XHJcblxyXG5cdFx0Ly8gUmVzZXQgZGlydHkgZmxhZy5cclxuXHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvL1NldCBvdXIgbWFya2VycyBwb3NpdGlvbiBhcyBnaXZlbiBhbmQgYWRkIGl0IHRvIHRoZSBtYXBcclxuXHRfYWRkVG9NYXA6IGZ1bmN0aW9uIChzdGFydFBvcykge1xyXG5cdFx0aWYgKHN0YXJ0UG9zKSB7XHJcblx0XHRcdHRoaXMuX2JhY2t1cExhdGxuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdFx0dGhpcy5zZXRMYXRMbmcoc3RhcnRQb3MpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbjogZnVuY3Rpb24gKGJvdW5kcywgY2VudGVyLCBtYXhab29tKSB7XHJcblx0XHR0aGlzLl9yZWN1cnNpdmVseShib3VuZHMsIHRoaXMuX2dyb3VwLl9tYXAuZ2V0TWluWm9vbSgpLCBtYXhab29tIC0gMSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHR2YXIgbWFya2VycyA9IGMuX21hcmtlcnMsXHJcblx0XHRcdFx0XHRpLCBtO1xyXG5cdFx0XHRcdGZvciAoaSA9IG1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdG0gPSBtYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0XHRcdC8vT25seSBkbyBpdCBpZiB0aGUgaWNvbiBpcyBzdGlsbCBvbiB0aGUgbWFwXHJcblx0XHRcdFx0XHRpZiAobS5faWNvbikge1xyXG5cdFx0XHRcdFx0XHRtLl9zZXRQb3MoY2VudGVyKTtcclxuXHRcdFx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IGMuX2NoaWxkQ2x1c3RlcnMsXHJcblx0XHRcdFx0XHRqLCBjbTtcclxuXHRcdFx0XHRmb3IgKGogPSBjaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcblx0XHRcdFx0XHRjbSA9IGNoaWxkQ2x1c3RlcnNbal07XHJcblx0XHRcdFx0XHRpZiAoY20uX2ljb24pIHtcclxuXHRcdFx0XHRcdFx0Y20uX3NldFBvcyhjZW50ZXIpO1xyXG5cdFx0XHRcdFx0XHRjbS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcDogZnVuY3Rpb24gKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCBuZXdab29tTGV2ZWwsIG1hcE1pblpvb20sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5Jbihib3VuZHMsIGMuX2dyb3VwLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGMuZ2V0TGF0TG5nKCkpLnJvdW5kKCksIHByZXZpb3VzWm9vbUxldmVsKTtcclxuXHJcblx0XHRcdFx0Ly9UT0RPOiBkZXB0aFRvQW5pbWF0ZUluIGFmZmVjdHMgX2lzU2luZ2xlUGFyZW50LCBpZiB0aGVyZSBpcyBhIG11bHRpem9vbSB3ZSBtYXkvbWF5IG5vdCBiZS5cclxuXHRcdFx0XHQvL0FzIGEgaGFjayB3ZSBvbmx5IGRvIGEgYW5pbWF0aW9uIGZyZWUgem9vbSBvbiBhIHNpbmdsZSBsZXZlbCB6b29tLCBpZiBzb21lb25lIGRvZXMgbXVsdGlwbGUgbGV2ZWxzIHRoZW4gd2UgYWx3YXlzIGFuaW1hdGVcclxuXHRcdFx0XHRpZiAoYy5faXNTaW5nbGVQYXJlbnQoKSAmJiBwcmV2aW91c1pvb21MZXZlbCAtIDEgPT09IG5ld1pvb21MZXZlbCkge1xyXG5cdFx0XHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAoYm91bmRzLCBtYXBNaW5ab29tLCBwcmV2aW91c1pvb21MZXZlbCk7IC8vSW1tZWRpYXRlbHkgcmVtb3ZlIG91ciBjaGlsZHJlbiBhcyB3ZSBhcmUgcmVwbGFjaW5nIHRoZW0uIFRPRE8gcHJldmlvdXNCb3VuZHMgbm90IGJvdW5kc1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjLl9hZGRUb01hcCgpO1xyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWN1cnNpdmVseUJlY29tZVZpc2libGU6IGZ1bmN0aW9uIChib3VuZHMsIHpvb21MZXZlbCkge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgem9vbUxldmVsLCBudWxsLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRjLmNsdXN0ZXJTaG93KCk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MsIHpvb21MZXZlbCwgYm91bmRzKSB7XHJcblx0XHR0aGlzLl9yZWN1cnNpdmVseShib3VuZHMsIHRoaXMuX2dyb3VwLl9tYXAuZ2V0TWluWm9vbSgpIC0gMSwgem9vbUxldmVsLFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGlmICh6b29tTGV2ZWwgPT09IGMuX3pvb20pIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vQWRkIG91ciBjaGlsZCBtYXJrZXJzIGF0IHN0YXJ0UG9zIChzbyB0aGV5IGNhbiBiZSBhbmltYXRlZCBvdXQpXHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IGMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdHZhciBubSA9IGMuX21hcmtlcnNbaV07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMobm0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0UG9zKSB7XHJcblx0XHRcdFx0XHRcdG5tLl9iYWNrdXBMYXRsbmcgPSBubS5nZXRMYXRMbmcoKTtcclxuXHJcblx0XHRcdFx0XHRcdG5tLnNldExhdExuZyhzdGFydFBvcyk7XHJcblx0XHRcdFx0XHRcdGlmIChubS5jbHVzdGVySGlkZSkge1xyXG5cdFx0XHRcdFx0XHRcdG5tLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLmFkZExheWVyKG5tKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Yy5fYWRkVG9NYXAoc3RhcnRQb3MpO1xyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9uczogZnVuY3Rpb24gKHpvb21MZXZlbCkge1xyXG5cdFx0Ly9GaXggcG9zaXRpb25zIG9mIGNoaWxkIG1hcmtlcnNcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHZhciBubSA9IHRoaXMuX21hcmtlcnNbaV07XHJcblx0XHRcdGlmIChubS5fYmFja3VwTGF0bG5nKSB7XHJcblx0XHRcdFx0bm0uc2V0TGF0TG5nKG5tLl9iYWNrdXBMYXRsbmcpO1xyXG5cdFx0XHRcdGRlbGV0ZSBubS5fYmFja3VwTGF0bG5nO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHpvb21MZXZlbCAtIDEgPT09IHRoaXMuX3pvb20pIHtcclxuXHRcdFx0Ly9SZXBvc2l0aW9uIGNoaWxkIGNsdXN0ZXJzXHJcblx0XHRcdGZvciAodmFyIGogPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcblx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1tqXS5fcmVzdG9yZVBvc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAodmFyIGsgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XHJcblx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1trXS5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMoem9vbUxldmVsKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZXN0b3JlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9iYWNrdXBMYXRsbmcpIHtcclxuXHRcdFx0dGhpcy5zZXRMYXRMbmcodGhpcy5fYmFja3VwTGF0bG5nKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2JhY2t1cExhdGxuZztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL2V4Y2VwdEJvdW5kczogSWYgc2V0LCBkb24ndCByZW1vdmUgYW55IG1hcmtlcnMvY2x1c3RlcnMgaW4gaXRcclxuXHRfcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXA6IGZ1bmN0aW9uIChwcmV2aW91c0JvdW5kcywgbWFwTWluWm9vbSwgem9vbUxldmVsLCBleGNlcHRCb3VuZHMpIHtcclxuXHRcdHZhciBtLCBpO1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkocHJldmlvdXNCb3VuZHMsIG1hcE1pblpvb20gLSAxLCB6b29tTGV2ZWwgLSAxLFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdC8vUmVtb3ZlIG1hcmtlcnMgYXQgZXZlcnkgbGV2ZWxcclxuXHRcdFx0XHRmb3IgKGkgPSBjLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gYy5fbWFya2Vyc1tpXTtcclxuXHRcdFx0XHRcdGlmICghZXhjZXB0Qm91bmRzIHx8ICFleGNlcHRCb3VuZHMuY29udGFpbnMobS5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHQvL1JlbW92ZSBjaGlsZCBjbHVzdGVycyBhdCBqdXN0IHRoZSBib3R0b20gbGV2ZWxcclxuXHRcdFx0XHRmb3IgKGkgPSBjLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gYy5fY2hpbGRDbHVzdGVyc1tpXTtcclxuXHRcdFx0XHRcdGlmICghZXhjZXB0Qm91bmRzIHx8ICFleGNlcHRCb3VuZHMuY29udGFpbnMobS5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvL1J1biB0aGUgZ2l2ZW4gZnVuY3Rpb25zIHJlY3Vyc2l2ZWx5IHRvIHRoaXMgYW5kIGNoaWxkIGNsdXN0ZXJzXHJcblx0Ly8gYm91bmRzVG9BcHBseVRvOiBhIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudGluZyB0aGUgYm91bmRzIG9mIHdoYXQgY2x1c3RlcnMgdG8gcmVjdXJzZSBpbiB0b1xyXG5cdC8vIHpvb21MZXZlbFRvU3RhcnQ6IHpvb20gbGV2ZWwgdG8gc3RhcnQgcnVubmluZyBmdW5jdGlvbnMgKGluY2x1c2l2ZSlcclxuXHQvLyB6b29tTGV2ZWxUb1N0b3A6IHpvb20gbGV2ZWwgdG8gc3RvcCBydW5uaW5nIGZ1bmN0aW9ucyAoaW5jbHVzaXZlKVxyXG5cdC8vIHJ1bkF0RXZlcnlMZXZlbDogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBMLk1hcmtlckNsdXN0ZXIgYXMgYW4gYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBvbiBldmVyeSBsZXZlbFxyXG5cdC8vIHJ1bkF0Qm90dG9tTGV2ZWw6IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gTC5NYXJrZXJDbHVzdGVyIGFzIGFuIGFyZ3VtZW50IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgYXQgb25seSB0aGUgYm90dG9tIGxldmVsXHJcblx0X3JlY3Vyc2l2ZWx5OiBmdW5jdGlvbiAoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCkge1xyXG5cdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl96b29tLFxyXG5cdFx0ICAgIGksIGM7XHJcblxyXG5cdFx0aWYgKHpvb21MZXZlbFRvU3RhcnQgPD0gem9vbSkge1xyXG5cdFx0XHRpZiAocnVuQXRFdmVyeUxldmVsKSB7XHJcblx0XHRcdFx0cnVuQXRFdmVyeUxldmVsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChydW5BdEJvdHRvbUxldmVsICYmIHpvb20gPT09IHpvb21MZXZlbFRvU3RvcCkge1xyXG5cdFx0XHRcdHJ1bkF0Qm90dG9tTGV2ZWwodGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoem9vbSA8IHpvb21MZXZlbFRvU3RhcnQgfHwgem9vbSA8IHpvb21MZXZlbFRvU3RvcCkge1xyXG5cdFx0XHRmb3IgKGkgPSBjaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0YyA9IGNoaWxkQ2x1c3RlcnNbaV07XHJcblx0XHRcdFx0aWYgKGJvdW5kc1RvQXBwbHlUby5pbnRlcnNlY3RzKGMuX2JvdW5kcykpIHtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5KGJvdW5kc1RvQXBwbHlUbywgem9vbUxldmVsVG9TdGFydCwgem9vbUxldmVsVG9TdG9wLCBydW5BdEV2ZXJ5TGV2ZWwsIHJ1bkF0Qm90dG9tTGV2ZWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vUmV0dXJucyB0cnVlIGlmIHdlIGFyZSB0aGUgcGFyZW50IG9mIG9ubHkgb25lIGNsdXN0ZXIgYW5kIHRoYXQgY2x1c3RlciBpcyB0aGUgc2FtZSBhcyB1c1xyXG5cdF9pc1NpbmdsZVBhcmVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly9Eb24ndCBuZWVkIHRvIGNoZWNrIHRoaXMuX21hcmtlcnMgYXMgdGhlIHJlc3Qgd29uJ3Qgd29yayBpZiB0aGVyZSBhcmUgYW55XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggPiAwICYmIHRoaXMuX2NoaWxkQ2x1c3RlcnNbMF0uX2NoaWxkQ291bnQgPT09IHRoaXMuX2NoaWxkQ291bnQ7XHJcblx0fVxyXG59KTtcclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyLmpzIiwiXHJcbi8qXHJcbiogRXh0ZW5kcyBMLk1hcmtlciB0byBpbmNsdWRlIHR3byBleHRyYSBtZXRob2RzOiBjbHVzdGVySGlkZSBhbmQgY2x1c3RlclNob3cuXHJcbiogXHJcbiogVGhleSB3b3JrIGFzIHNldE9wYWNpdHkoMCkgYW5kIHNldE9wYWNpdHkoMSkgcmVzcGVjdGl2ZWx5LCBidXRcclxuKiB0aGV5IHdpbGwgcmVtZW1iZXIgdGhlIG1hcmtlcidzIG9wYWNpdHkgd2hlbiBoaWRpbmcgYW5kIHNob3dpbmcgaXQgYWdhaW4uXHJcbiogXHJcbiovXHJcblxyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0XHJcblx0Y2x1c3RlckhpZGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5V2hlblVuY2x1c3RlcmVkID0gdGhpcy5vcHRpb25zLm9wYWNpdHkgfHwgMTtcclxuXHRcdHJldHVybiB0aGlzLnNldE9wYWNpdHkoMCk7XHJcblx0fSxcclxuXHRcclxuXHRjbHVzdGVyU2hvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSB8fCB0aGlzLm9wdGlvbnMub3BhY2l0eVdoZW5VbmNsdXN0ZXJlZCk7XHJcblx0XHRkZWxldGUgdGhpcy5vcHRpb25zLm9wYWNpdHlXaGVuVW5jbHVzdGVyZWQ7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHRcclxufSk7XHJcblxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlck9wYWNpdHkuanMiLCJcclxuTC5EaXN0YW5jZUdyaWQgPSBmdW5jdGlvbiAoY2VsbFNpemUpIHtcclxuXHR0aGlzLl9jZWxsU2l6ZSA9IGNlbGxTaXplO1xyXG5cdHRoaXMuX3NxQ2VsbFNpemUgPSBjZWxsU2l6ZSAqIGNlbGxTaXplO1xyXG5cdHRoaXMuX2dyaWQgPSB7fTtcclxuXHR0aGlzLl9vYmplY3RQb2ludCA9IHsgfTtcclxufTtcclxuXHJcbkwuRGlzdGFuY2VHcmlkLnByb3RvdHlwZSA9IHtcclxuXHJcblx0YWRkT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xyXG5cdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcclxuXHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXHJcblx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXHJcblx0XHQgICAgcm93ID0gZ3JpZFt5XSA9IGdyaWRbeV0gfHwge30sXHJcblx0XHQgICAgY2VsbCA9IHJvd1t4XSA9IHJvd1t4XSB8fCBbXSxcclxuXHRcdCAgICBzdGFtcCA9IEwuVXRpbC5zdGFtcChvYmopO1xyXG5cclxuXHRcdHRoaXMuX29iamVjdFBvaW50W3N0YW1wXSA9IHBvaW50O1xyXG5cclxuXHRcdGNlbGwucHVzaChvYmopO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZU9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcclxuXHRcdHRoaXMucmVtb3ZlT2JqZWN0KG9iaik7XHJcblx0XHR0aGlzLmFkZE9iamVjdChvYmosIHBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvL1JldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IHdhcyBmb3VuZFxyXG5cdHJlbW92ZU9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcclxuXHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXHJcblx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxyXG5cdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxyXG5cdFx0ICAgIGNlbGwgPSByb3dbeF0gPSByb3dbeF0gfHwgW10sXHJcblx0XHQgICAgaSwgbGVuO1xyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9vYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV07XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAoY2VsbFtpXSA9PT0gb2JqKSB7XHJcblxyXG5cdFx0XHRcdGNlbGwuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRpZiAobGVuID09PSAxKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgcm93W3hdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ZWFjaE9iamVjdDogZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgaSwgaiwgaywgbGVuLCByb3csIGNlbGwsIHJlbW92ZWQsXHJcblx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQ7XHJcblxyXG5cdFx0Zm9yIChpIGluIGdyaWQpIHtcclxuXHRcdFx0cm93ID0gZ3JpZFtpXTtcclxuXHJcblx0XHRcdGZvciAoaiBpbiByb3cpIHtcclxuXHRcdFx0XHRjZWxsID0gcm93W2pdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGsgPSAwLCBsZW4gPSBjZWxsLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XHJcblx0XHRcdFx0XHRyZW1vdmVkID0gZm4uY2FsbChjb250ZXh0LCBjZWxsW2tdKTtcclxuXHRcdFx0XHRcdGlmIChyZW1vdmVkKSB7XHJcblx0XHRcdFx0XHRcdGstLTtcclxuXHRcdFx0XHRcdFx0bGVuLS07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0TmVhck9iamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxyXG5cdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcclxuXHRcdCAgICBpLCBqLCBrLCByb3csIGNlbGwsIGxlbiwgb2JqLCBkaXN0LFxyXG5cdFx0ICAgIG9iamVjdFBvaW50ID0gdGhpcy5fb2JqZWN0UG9pbnQsXHJcblx0XHQgICAgY2xvc2VzdERpc3RTcSA9IHRoaXMuX3NxQ2VsbFNpemUsXHJcblx0XHQgICAgY2xvc2VzdCA9IG51bGw7XHJcblxyXG5cdFx0Zm9yIChpID0geSAtIDE7IGkgPD0geSArIDE7IGkrKykge1xyXG5cdFx0XHRyb3cgPSB0aGlzLl9ncmlkW2ldO1xyXG5cdFx0XHRpZiAocm93KSB7XHJcblxyXG5cdFx0XHRcdGZvciAoaiA9IHggLSAxOyBqIDw9IHggKyAxOyBqKyspIHtcclxuXHRcdFx0XHRcdGNlbGwgPSByb3dbal07XHJcblx0XHRcdFx0XHRpZiAoY2VsbCkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGNlbGxba107XHJcblx0XHRcdFx0XHRcdFx0ZGlzdCA9IHRoaXMuX3NxRGlzdChvYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV0sIHBvaW50KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0U3EgfHxcclxuXHRcdFx0XHRcdFx0XHRcdGRpc3QgPD0gY2xvc2VzdERpc3RTcSAmJiBjbG9zZXN0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdFNxID0gZGlzdDtcclxuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3QgPSBvYmo7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2xvc2VzdDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Q29vcmQ6IGZ1bmN0aW9uICh4KSB7XHJcblx0XHR2YXIgY29vcmQgPSBNYXRoLmZsb29yKHggLyB0aGlzLl9jZWxsU2l6ZSk7XHJcblx0XHRyZXR1cm4gaXNGaW5pdGUoY29vcmQpID8gY29vcmQgOiB4O1xyXG5cdH0sXHJcblxyXG5cdF9zcURpc3Q6IGZ1bmN0aW9uIChwLCBwMikge1xyXG5cdFx0dmFyIGR4ID0gcDIueCAtIHAueCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSBwLnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvRGlzdGFuY2VHcmlkLmpzIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyIHRoZSBhdXRob3JzIGxpc3RlZCBhdCB0aGUgZm9sbG93aW5nIFVSTCwgYW5kL29yXHJcbnRoZSBhdXRob3JzIG9mIHJlZmVyZW5jZWQgYXJ0aWNsZXMgb3IgaW5jb3Jwb3JhdGVkIGV4dGVybmFsIGNvZGU6XHJcbmh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP2FjdGlvbj1oaXN0b3J5Jm9mZnNldD0yMDEyMDQxMDE3NTI1NlxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG5SZXRyaWV2ZWQgZnJvbTogaHR0cDovL2VuLmxpdGVyYXRlcHJvZ3JhbXMub3JnL1F1aWNraHVsbF8oSmF2YXNjcmlwdCk/b2xkaWQ9MTg0MzRcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0TC5RdWlja0h1bGwgPSB7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjcHQgYSBwb2ludCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBiYXNlbGluZVxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYmwgdGhlIGJhc2VsaW5lLCBhcyByZXByZXNlbnRlZCBieSBhIHR3by1lbGVtZW50XHJcblx0XHQgKiAgIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzLlxyXG5cdFx0ICogQHJldHVybnMge051bWJlcn0gYW4gYXBwcm94aW1hdGUgZGlzdGFuY2UgbWVhc3VyZVxyXG5cdFx0ICovXHJcblx0XHRnZXREaXN0YW50OiBmdW5jdGlvbiAoY3B0LCBibCkge1xyXG5cdFx0XHR2YXIgdlkgPSBibFsxXS5sYXQgLSBibFswXS5sYXQsXHJcblx0XHRcdFx0dlggPSBibFswXS5sbmcgLSBibFsxXS5sbmc7XHJcblx0XHRcdHJldHVybiAodlggKiAoY3B0LmxhdCAtIGJsWzBdLmxhdCkgKyB2WSAqIChjcHQubG5nIC0gYmxbMF0ubG5nKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlTGluZSBhIHR3by1lbGVtZW50IGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiAgIHJlcHJlc2VudGluZyB0aGUgYmFzZWxpbmUgdG8gcHJvamVjdCBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzIGFuIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgbWF4aW11bSBwb2ludCBhbmQgYWxsIG5ldyBwb2ludHMgdG8gc3RheVxyXG5cdFx0ICogICBpbiBjb25zaWRlcmF0aW9uIGZvciB0aGUgaHVsbC5cclxuXHRcdCAqL1xyXG5cdFx0ZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmU6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgbWF4RCA9IDAsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLFxyXG5cdFx0XHRcdG5ld1BvaW50cyA9IFtdLFxyXG5cdFx0XHRcdGksIHB0LCBkO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdHB0ID0gbGF0TG5nc1tpXTtcclxuXHRcdFx0XHRkID0gdGhpcy5nZXREaXN0YW50KHB0LCBiYXNlTGluZSk7XHJcblxyXG5cdFx0XHRcdGlmIChkID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocHQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChkID4gbWF4RCkge1xyXG5cdFx0XHRcdFx0bWF4RCA9IGQ7XHJcblx0XHRcdFx0XHRtYXhQdCA9IHB0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHsgbWF4UG9pbnQ6IG1heFB0LCBuZXdQb2ludHM6IG5ld1BvaW50cyB9O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEdpdmVuIGEgYmFzZWxpbmUsIGNvbXB1dGUgdGhlIGNvbnZleCBodWxsIG9mIGxhdExuZ3MgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdExuZ3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5nc1xyXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdFx0ICovXHJcblx0XHRidWlsZENvbnZleEh1bGw6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgY29udmV4SHVsbEJhc2VMaW5lcyA9IFtdLFxyXG5cdFx0XHRcdHQgPSB0aGlzLmZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lKGJhc2VMaW5lLCBsYXRMbmdzKTtcclxuXHJcblx0XHRcdGlmICh0Lm1heFBvaW50KSB7IC8vIGlmIHRoZXJlIGlzIHN0aWxsIGEgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZVxyXG5cdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxyXG5cdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXHJcblx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFtiYXNlTGluZVswXSwgdC5tYXhQb2ludF0sIHQubmV3UG9pbnRzKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzID1cclxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbdC5tYXhQb2ludCwgYmFzZUxpbmVbMV1dLCB0Lm5ld1BvaW50cylcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnZleEh1bGxCYXNlTGluZXM7XHJcblx0XHRcdH0gZWxzZSB7ICAvLyBpZiB0aGVyZSBpcyBubyBtb3JlIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmUsIHRoZSBjdXJyZW50IGJhc2UgbGluZSBpcyBwYXJ0IG9mIHRoZSBjb252ZXggaHVsbFxyXG5cdFx0XHRcdHJldHVybiBbYmFzZUxpbmVbMF1dO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBHaXZlbiBhbiBhcnJheSBvZiBsYXRsbmdzLCBjb21wdXRlIGEgY29udmV4IGh1bGwgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdGxuZ3NcclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXHJcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0XHQgKi9cclxuXHRcdGdldENvbnZleEh1bGw6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XHJcblx0XHRcdC8vIGZpbmQgZmlyc3QgYmFzZWxpbmVcclxuXHRcdFx0dmFyIG1heExhdCA9IGZhbHNlLCBtaW5MYXQgPSBmYWxzZSxcclxuXHRcdFx0XHRtYXhMbmcgPSBmYWxzZSwgbWluTG5nID0gZmFsc2UsXHJcblx0XHRcdFx0bWF4TGF0UHQgPSBudWxsLCBtaW5MYXRQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4TG5nUHQgPSBudWxsLCBtaW5MbmdQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLCBtaW5QdCA9IG51bGwsXHJcblx0XHRcdFx0aTtcclxuXHJcblx0XHRcdGZvciAoaSA9IGxhdExuZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHR2YXIgcHQgPSBsYXRMbmdzW2ldO1xyXG5cdFx0XHRcdGlmIChtYXhMYXQgPT09IGZhbHNlIHx8IHB0LmxhdCA+IG1heExhdCkge1xyXG5cdFx0XHRcdFx0bWF4TGF0UHQgPSBwdDtcclxuXHRcdFx0XHRcdG1heExhdCA9IHB0LmxhdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pbkxhdCA9PT0gZmFsc2UgfHwgcHQubGF0IDwgbWluTGF0KSB7XHJcblx0XHRcdFx0XHRtaW5MYXRQdCA9IHB0O1xyXG5cdFx0XHRcdFx0bWluTGF0ID0gcHQubGF0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobWF4TG5nID09PSBmYWxzZSB8fCBwdC5sbmcgPiBtYXhMbmcpIHtcclxuXHRcdFx0XHRcdG1heExuZ1B0ID0gcHQ7XHJcblx0XHRcdFx0XHRtYXhMbmcgPSBwdC5sbmc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtaW5MbmcgPT09IGZhbHNlIHx8IHB0LmxuZyA8IG1pbkxuZykge1xyXG5cdFx0XHRcdFx0bWluTG5nUHQgPSBwdDtcclxuXHRcdFx0XHRcdG1pbkxuZyA9IHB0LmxuZztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmIChtaW5MYXQgIT09IG1heExhdCkge1xyXG5cdFx0XHRcdG1pblB0ID0gbWluTGF0UHQ7XHJcblx0XHRcdFx0bWF4UHQgPSBtYXhMYXRQdDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtaW5QdCA9IG1pbkxuZ1B0O1xyXG5cdFx0XHRcdG1heFB0ID0gbWF4TG5nUHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBjaCA9IFtdLmNvbmNhdCh0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWluUHQsIG1heFB0XSwgbGF0TG5ncyksXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWF4UHQsIG1pblB0XSwgbGF0TG5ncykpO1xyXG5cdFx0XHRyZXR1cm4gY2g7XHJcblx0XHR9XHJcblx0fTtcclxufSgpKTtcclxuXHJcbkwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcclxuXHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0cG9pbnRzID0gW10sXHJcblx0XHRcdHAsIGk7XHJcblxyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHAgPSBjaGlsZE1hcmtlcnNbaV0uZ2V0TGF0TG5nKCk7XHJcblx0XHRcdHBvaW50cy5wdXNoKHApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLlF1aWNrSHVsbC5nZXRDb252ZXhIdWxsKHBvaW50cyk7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXIuUXVpY2tIdWxsLmpzIiwiLy9UaGlzIGNvZGUgaXMgMTAwJSBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vamF3ai9PdmVybGFwcGluZ01hcmtlclNwaWRlcmZpZXItTGVhZmxldFxyXG4vL0h1Z2UgdGhhbmtzIHRvIGphd2ogZm9yIGltcGxlbWVudGluZyBpdCBmaXJzdCB0byBtYWtlIG15IGpvYiBlYXN5IDotKVxyXG5cclxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xyXG5cclxuXHRfMlBJOiBNYXRoLlBJICogMixcclxuXHRfY2lyY2xlRm9vdFNlcGFyYXRpb246IDI1LCAvL3JlbGF0ZWQgdG8gY2lyY3VtZmVyZW5jZSBvZiBjaXJjbGVcclxuXHRfY2lyY2xlU3RhcnRBbmdsZTogMCxcclxuXHJcblx0X3NwaXJhbEZvb3RTZXBhcmF0aW9uOiAgMjgsIC8vcmVsYXRlZCB0byBzaXplIG9mIHNwaXJhbCAoZXhwZXJpbWVudCEpXHJcblx0X3NwaXJhbExlbmd0aFN0YXJ0OiAxMSxcclxuXHRfc3BpcmFsTGVuZ3RoRmFjdG9yOiA1LFxyXG5cclxuXHRfY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjogOSwgLy9zaG93IHNwaXJhbCBpbnN0ZWFkIG9mIGNpcmNsZSBmcm9tIHRoaXMgbWFya2VyIGNvdW50IHVwd2FyZHMuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAwIC0+IGFsd2F5cyBzcGlyYWw7IEluZmluaXR5IC0+IGFsd2F5cyBjaXJjbGVcclxuXHJcblx0c3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9PT0gdGhpcyB8fCB0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0Y2VudGVyID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0XHRwb3NpdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fZ3JvdXAuX3Vuc3BpZGVyZnkoKTtcclxuXHRcdHRoaXMuX2dyb3VwLl9zcGlkZXJmaWVkID0gdGhpcztcclxuXHJcblx0XHQvL1RPRE8gTWF5YmU6IGNoaWxkTWFya2VycyBvcmRlciBieSBkaXN0YW5jZSB0byBjZW50ZXJcclxuXHJcblx0XHRpZiAoY2hpbGRNYXJrZXJzLmxlbmd0aCA+PSB0aGlzLl9jaXJjbGVTcGlyYWxTd2l0Y2hvdmVyKSB7XHJcblx0XHRcdHBvc2l0aW9ucyA9IHRoaXMuX2dlbmVyYXRlUG9pbnRzU3BpcmFsKGNoaWxkTWFya2Vycy5sZW5ndGgsIGNlbnRlcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjZW50ZXIueSArPSAxMDsgLy8gT3RoZXJ3aXNlIGNpcmNsZXMgbG9vayB3cm9uZyA9PiBoYWNrIGZvciBzdGFuZGFyZCBibHVlIGljb24sIHJlbmRlcnMgZGlmZmVyZW50bHkgZm9yIG90aGVyIGljb25zLlxyXG5cdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c0NpcmNsZShjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGlvblNwaWRlcmZ5KGNoaWxkTWFya2VycywgcG9zaXRpb25zKTtcclxuXHR9LFxyXG5cclxuXHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdC8vLyA8cGFyYW0gTmFtZT1cInpvb21EZXRhaWxzXCI+QXJndW1lbnQgZnJvbSB6b29tYW5pbSBpZiBiZWluZyBjYWxsZWQgaW4gYSB6b29tIGFuaW1hdGlvbiBvciBudWxsIG90aGVyd2lzZTwvcGFyYW0+XHJcblx0XHRpZiAodGhpcy5fZ3JvdXAuX2luWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hbmltYXRpb25VbnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcclxuXHJcblx0XHR0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dlbmVyYXRlUG9pbnRzQ2lyY2xlOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XHJcblx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9jaXJjbGVGb290U2VwYXJhdGlvbiAqICgyICsgY291bnQpLFxyXG5cdFx0XHRsZWdMZW5ndGggPSBjaXJjdW1mZXJlbmNlIC8gdGhpcy5fMlBJLCAgLy9yYWRpdXMgZnJvbSBjaXJjdW1mZXJlbmNlXHJcblx0XHRcdGFuZ2xlU3RlcCA9IHRoaXMuXzJQSSAvIGNvdW50LFxyXG5cdFx0XHRyZXMgPSBbXSxcclxuXHRcdFx0aSwgYW5nbGU7XHJcblxyXG5cdFx0bGVnTGVuZ3RoID0gTWF0aC5tYXgobGVnTGVuZ3RoLCAzNSk7IC8vIE1pbmltdW0gZGlzdGFuY2UgdG8gZ2V0IG91dHNpZGUgdGhlIGNsdXN0ZXIgaWNvbi5cclxuXHJcblx0XHRyZXMubGVuZ3RoID0gY291bnQ7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHsgLy8gQ2xvY2t3aXNlLCBsaWtlIHNwaXJhbC5cclxuXHRcdFx0YW5nbGUgPSB0aGlzLl9jaXJjbGVTdGFydEFuZ2xlICsgaSAqIGFuZ2xlU3RlcDtcclxuXHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9LFxyXG5cclxuXHRfZ2VuZXJhdGVQb2ludHNTcGlyYWw6IGZ1bmN0aW9uIChjb3VudCwgY2VudGVyUHQpIHtcclxuXHRcdHZhciBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIsXHJcblx0XHRcdGxlZ0xlbmd0aCA9IHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fc3BpcmFsTGVuZ3RoU3RhcnQsXHJcblx0XHRcdHNlcGFyYXRpb24gPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbEZvb3RTZXBhcmF0aW9uLFxyXG5cdFx0XHRsZW5ndGhGYWN0b3IgPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aEZhY3RvciAqIHRoaXMuXzJQSSxcclxuXHRcdFx0YW5nbGUgPSAwLFxyXG5cdFx0XHRyZXMgPSBbXSxcclxuXHRcdFx0aTtcclxuXHJcblx0XHRyZXMubGVuZ3RoID0gY291bnQ7XHJcblxyXG5cdFx0Ly8gSGlnaGVyIGluZGV4LCBjbG9zZXIgcG9zaXRpb24gdG8gY2x1c3RlciBjZW50ZXIuXHJcblx0XHRmb3IgKGkgPSBjb3VudDsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0Ly8gU2tpcCB0aGUgZmlyc3QgcG9zaXRpb24sIHNvIHRoYXQgd2UgYXJlIGFscmVhZHkgZmFydGhlciBmcm9tIGNlbnRlciBhbmQgd2UgYXZvaWRcclxuXHRcdFx0Ly8gYmVpbmcgdW5kZXIgdGhlIGRlZmF1bHQgY2x1c3RlciBpY29uIChlc3BlY2lhbGx5IGltcG9ydGFudCBmb3IgQ2lyY2xlIE1hcmtlcnMpLlxyXG5cdFx0XHRpZiAoaSA8IGNvdW50KSB7XHJcblx0XHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YW5nbGUgKz0gc2VwYXJhdGlvbiAvIGxlZ0xlbmd0aCArIGkgKiAwLjAwMDU7XHJcblx0XHRcdGxlZ0xlbmd0aCArPSBsZW5ndGhGYWN0b3IgLyBhbmdsZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fSxcclxuXHJcblx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0Y2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0bSwgaTtcclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXRPcGFjaXR5KDEpO1xyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcclxuXHJcblx0XHRcdGlmIChtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xyXG5cdFx0XHRcdG0uc2V0TGF0TG5nKG0uX3ByZVNwaWRlcmZ5TGF0bG5nKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XHJcblx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcclxuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xyXG5cdFx0XHRjbHVzdGVyOiB0aGlzLFxyXG5cdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcclxuXHRcdH0pO1xyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHRcdGdyb3VwLl9zcGlkZXJmaWVkID0gbnVsbDtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy9Ob24gQW5pbWF0ZWQgdmVyc2lvbnMgb2YgZXZlcnl0aGluZ1xyXG5MLk1hcmtlckNsdXN0ZXJOb25BbmltYXRlZCA9IEwuTWFya2VyQ2x1c3Rlci5leHRlbmQoe1xyXG5cdF9hbmltYXRpb25TcGlkZXJmeTogZnVuY3Rpb24gKGNoaWxkTWFya2VycywgcG9zaXRpb25zKSB7XHJcblx0XHR2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHRsZWdPcHRpb25zID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMsXHJcblx0XHRcdGksIG0sIGxlZywgbmV3UG9zO1xyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBUcmF2ZXJzZSBpbiBhc2NlbmRpbmcgb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgaW5uZXIgY2lyY2xlTWFya2VycyBhcmUgb24gdG9wIG9mIGZ1cnRoZXIgbGVncy4gTm9ybWFsIG1hcmtlcnMgYXJlIHJlLW9yZGVyZWQgYnkgbmV3UG9zaXRpb24uXHJcblx0XHQvLyBUaGUgcmV2ZXJzZSBvcmRlciB0cmljayBubyBsb25nZXIgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb24gbW9kZXJuIGJyb3dzZXJzLlxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkTWFya2Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XHJcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHQvLyBBZGQgdGhlIGxlZyBiZWZvcmUgdGhlIG1hcmtlciwgc28gdGhhdCBpbiBjYXNlIHRoZSBsYXR0ZXIgaXMgYSBjaXJjbGVNYXJrZXIsIHRoZSBsZWcgaXMgYmVoaW5kIGl0LlxyXG5cdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbdGhpcy5fbGF0bG5nLCBuZXdQb3NdLCBsZWdPcHRpb25zKTtcclxuXHRcdFx0bWFwLmFkZExheWVyKGxlZyk7XHJcblx0XHRcdG0uX3NwaWRlckxlZyA9IGxlZztcclxuXHJcblx0XHRcdC8vIE5vdyBhZGQgdGhlIG1hcmtlci5cclxuXHRcdFx0bS5fcHJlU3BpZGVyZnlMYXRsbmcgPSBtLl9sYXRsbmc7XHJcblx0XHRcdG0uc2V0TGF0TG5nKG5ld1Bvcyk7XHJcblx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xyXG5cdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDEwMDAwMDApOyAvL01ha2UgdGhlc2UgYXBwZWFyIG9uIHRvcCBvZiBFVkVSWVRISU5HXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZnLmFkZExheWVyKG0pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XHJcblx0XHRcdGNsdXN0ZXI6IHRoaXMsXHJcblx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcclxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xyXG5cclxuXHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcyxcclxuXHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHR0aGlzTGF5ZXJMYXRMbmcgPSB0aGlzLl9sYXRsbmcsXHJcblx0XHRcdHRoaXNMYXllclBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpc0xheWVyTGF0TG5nKSxcclxuXHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcclxuXHRcdFx0bGVnT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyksIC8vIENvcHkgdGhlIG9wdGlvbnMgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZW0gZm9yIGFuaW1hdGlvbi5cclxuXHRcdFx0ZmluYWxMZWdPcGFjaXR5ID0gbGVnT3B0aW9ucy5vcGFjaXR5LFxyXG5cdFx0XHRpLCBtLCBsZWcsIGxlZ1BhdGgsIGxlZ0xlbmd0aCwgbmV3UG9zO1xyXG5cclxuXHRcdGlmIChmaW5hbExlZ09wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRmaW5hbExlZ09wYWNpdHkgPSBMLk1hcmtlckNsdXN0ZXJHcm91cC5wcm90b3R5cGUub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMub3BhY2l0eTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdC8vIElmIHRoZSBpbml0aWFsIG9wYWNpdHkgb2YgdGhlIHNwaWRlciBsZWcgaXMgbm90IDAgdGhlbiBpdCBhcHBlYXJzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cclxuXHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gMDtcclxuXHJcblx0XHRcdC8vIEFkZCB0aGUgY2xhc3MgZm9yIENTUyB0cmFuc2l0aW9ucy5cclxuXHRcdFx0bGVnT3B0aW9ucy5jbGFzc05hbWUgPSAobGVnT3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LWNsdXN0ZXItc3BpZGVyLWxlZyc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGRlZmluZWQgb3BhY2l0eS5cclxuXHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gZmluYWxMZWdPcGFjaXR5O1xyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBBZGQgbWFya2VycyBhbmQgc3BpZGVyIGxlZ3MgdG8gbWFwLCBoaWRkZW4gYXQgb3VyIGNlbnRlciBwb2ludC5cclxuXHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cclxuXHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XHJcblxyXG5cdFx0XHQvLyBBZGQgdGhlIGxlZyBiZWZvcmUgdGhlIG1hcmtlciwgc28gdGhhdCBpbiBjYXNlIHRoZSBsYXR0ZXIgaXMgYSBjaXJjbGVNYXJrZXIsIHRoZSBsZWcgaXMgYmVoaW5kIGl0LlxyXG5cdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbdGhpc0xheWVyTGF0TG5nLCBuZXdQb3NdLCBsZWdPcHRpb25zKTtcclxuXHRcdFx0bWFwLmFkZExheWVyKGxlZyk7XHJcblx0XHRcdG0uX3NwaWRlckxlZyA9IGxlZztcclxuXHJcblx0XHRcdC8vIEV4cGxhbmF0aW9uczogaHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8yMDEzL2FuaW1hdGVkLWxpbmUtZHJhd2luZy1zdmcvXHJcblx0XHRcdC8vIEluIG91ciBjYXNlIHRoZSB0cmFuc2l0aW9uIHByb3BlcnR5IGlzIGRlY2xhcmVkIGluIHRoZSBDU1MgZmlsZS5cclxuXHRcdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XHJcblx0XHRcdFx0bGVnTGVuZ3RoID0gbGVnUGF0aC5nZXRUb3RhbExlbmd0aCgpICsgMC4xOyAvLyBOZWVkIGEgc21hbGwgZXh0cmEgbGVuZ3RoIHRvIGF2b2lkIHJlbWFpbmluZyBkb3QgaW4gRmlyZWZveC5cclxuXHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hhcnJheSA9IGxlZ0xlbmd0aDsgLy8gSnVzdCAxIGxlbmd0aCBpcyBlbm91Z2gsIGl0IHdpbGwgYmUgZHVwbGljYXRlZC5cclxuXHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBsZWdMZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIGl0IGlzIGEgbWFya2VyLCBhZGQgaXQgbm93IGFuZCB3ZSdsbCBhbmltYXRlIGl0IG91dFxyXG5cdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy8gTWFrZSBub3JtYWwgbWFya2VycyBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobS5jbHVzdGVySGlkZSkge1xyXG5cdFx0XHRcdG0uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVmVjdG9ycyBqdXN0IGdldCBpbW1lZGlhdGVseSBhZGRlZFxyXG5cdFx0XHRmZy5hZGRMYXllcihtKTtcclxuXHJcblx0XHRcdGlmIChtLl9zZXRQb3MpIHtcclxuXHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLl9mb3JjZUxheW91dCgpO1xyXG5cdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0Ly8gUmV2ZWFsIG1hcmtlcnMgYW5kIHNwaWRlciBsZWdzLlxyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdC8vTW92ZSBtYXJrZXIgdG8gbmV3IHBvc2l0aW9uXHJcblx0XHRcdG0uX3ByZVNwaWRlcmZ5TGF0bG5nID0gbS5fbGF0bG5nO1xyXG5cdFx0XHRtLnNldExhdExuZyhuZXdQb3MpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFuaW1hdGUgbGVnIChhbmltYXRpb24gaXMgYWN0dWFsbHkgZGVsZWdhdGVkIHRvIENTUyB0cmFuc2l0aW9uKS5cclxuXHRcdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRcdGxlZyA9IG0uX3NwaWRlckxlZztcclxuXHRcdFx0XHRsZWdQYXRoID0gbGVnLl9wYXRoO1xyXG5cdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IDA7XHJcblx0XHRcdFx0Ly9sZWdQYXRoLnN0eWxlLnN0cm9rZU9wYWNpdHkgPSBmaW5hbExlZ09wYWNpdHk7XHJcblx0XHRcdFx0bGVnLnNldFN0eWxlKHtvcGFjaXR5OiBmaW5hbExlZ09wYWNpdHl9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Z3JvdXAuX2FuaW1hdGlvbkVuZCgpO1xyXG5cdFx0XHRncm91cC5maXJlKCdzcGlkZXJmaWVkJywge1xyXG5cdFx0XHRcdGNsdXN0ZXI6IG1lLFxyXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xyXG5cdFx0dmFyIG1lID0gdGhpcyxcclxuXHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHR0aGlzTGF5ZXJQb3MgPSB6b29tRGV0YWlscyA/IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgem9vbURldGFpbHMuem9vbSwgem9vbURldGFpbHMuY2VudGVyKSA6IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdFx0Y2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcclxuXHRcdFx0bSwgaSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5vbkFuaW1hdGFibGU7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0Ly9NYWtlIHVzIHZpc2libGUgYW5kIGJyaW5nIHRoZSBjaGlsZCBtYXJrZXJzIGJhY2sgaW5cclxuXHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcclxuXHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0Ly9NYXJrZXIgd2FzIGFkZGVkIHRvIHVzIGFmdGVyIHdlIHdlcmUgc3BpZGVyZmllZFxyXG5cdFx0XHRpZiAoIW0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vQ2xvc2UgYW55IHBvcHVwIG9uIHRoZSBtYXJrZXIgZmlyc3QsIG90aGVyd2lzZSBzZXR0aW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgbWFya2VyIHdpbGwgbWFrZSB0aGUgbWFwIHNjcm9sbFxyXG5cdFx0XHRtLmNsb3NlUG9wdXAoKTtcclxuXHJcblx0XHRcdC8vRml4IHVwIHRoZSBsb2NhdGlvbiB0byB0aGUgcmVhbCBvbmVcclxuXHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xyXG5cdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XHJcblxyXG5cdFx0XHQvL0hhY2sgb3ZlcnJpZGUgdGhlIGxvY2F0aW9uIHRvIGJlIG91ciBjZW50ZXJcclxuXHRcdFx0bm9uQW5pbWF0YWJsZSA9IHRydWU7XHJcblx0XHRcdGlmIChtLl9zZXRQb3MpIHtcclxuXHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcclxuXHRcdFx0XHRub25BbmltYXRhYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChub25BbmltYXRhYmxlKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFuaW1hdGUgdGhlIHNwaWRlciBsZWcgYmFjayBpbiAoYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGRlbGVnYXRlZCB0byBDU1MgdHJhbnNpdGlvbikuXHJcblx0XHRcdGlmIChzdmcpIHtcclxuXHRcdFx0XHRsZWcgPSBtLl9zcGlkZXJMZWc7XHJcblx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcclxuXHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7XHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gbGVnTGVuZ3RoO1xyXG5cdFx0XHRcdGxlZy5zZXRTdHlsZSh7b3BhY2l0eTogMH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly9JZiB3ZSBoYXZlIG9ubHkgPD0gb25lIGNoaWxkIGxlZnQgdGhlbiB0aGF0IG1hcmtlciB3aWxsIGJlIHNob3duIG9uIHRoZSBtYXAgc28gZG9uJ3QgcmVtb3ZlIGl0IVxyXG5cdFx0XHR2YXIgc3RpbGxUaGVyZUNoaWxkQ291bnQgPSAwO1xyXG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcclxuXHRcdFx0XHRcdHN0aWxsVGhlcmVDaGlsZENvdW50Kys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdFx0aWYgKCFtLl9zcGlkZXJMZWcpIHsgLy9IYXMgYWxyZWFkeSBiZWVuIHVuc3BpZGVyZmllZFxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0aWxsVGhlcmVDaGlsZENvdW50ID4gMSkge1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xyXG5cdFx0XHRcdGNsdXN0ZXI6IG1lLFxyXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcclxuXHQvL1RoZSBNYXJrZXJDbHVzdGVyIGN1cnJlbnRseSBzcGlkZXJmaWVkIChpZiBhbnkpXHJcblx0X3NwaWRlcmZpZWQ6IG51bGwsXHJcblxyXG5cdHVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR9LFxyXG5cclxuXHRfc3BpZGVyZmllck9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvL0Jyb3dzZXJzIHdpdGhvdXQgem9vbUFuaW1hdGlvbiBvciBhIGJpZyB6b29tIGRvbid0IGZpcmUgem9vbXN0YXJ0XHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRSZW5kZXJlcih0aGlzKTtcclxuXHRcdFx0Ly9OZWVkcyB0byBoYXBwZW4gaW4gdGhlIHBhZ2Vsb2FkLCBub3QgYWZ0ZXIsIG9yIGFuaW1hdGlvbnMgZG9uJ3Qgd29yayBpbiB3ZWJraXRcclxuXHRcdFx0Ly8gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1NTIwMC9zdmctYW5pbWF0ZS13aXRoLWR5bmFtaWNhbGx5LWFkZGVkLWVsZW1lbnRzXHJcblx0XHRcdC8vRGlzYWJsZSBvbiB0b3VjaCBicm93c2VycyBhcyB0aGUgYW5pbWF0aW9uIG1lc3NlcyB1cCBvbiBhIHRvdWNoIHpvb20gYW5kIGlzbid0IHZlcnkgbm90aWNhYmxlXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NwaWRlcmZpZXJPblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl91bnNwaWRlcmZ5V3JhcHBlciwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbVN0YXJ0LCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdC8vRW5zdXJlIHRoYXQgbWFya2VycyBhcmUgYmFjayB3aGVyZSB0aGV5IHNob3VsZCBiZVxyXG5cdFx0Ly8gVXNlIG5vIGFuaW1hdGlvbiB0byBhdm9pZCBhIHN0aWNreSBsZWFmbGV0LWNsdXN0ZXItYW5pbSBjbGFzcyBvbiBtYXBQYW5lXHJcblx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcclxuXHR9LFxyXG5cclxuXHQvL09uIHpvb20gc3RhcnQgd2UgYWRkIGEgem9vbWFuaW0gaGFuZGxlciBzbyB0aGF0IHdlIGFyZSBndWFyYW50ZWVkIHRvIGJlIGxhc3QgKGFmdGVyIG1hcmtlcnMgYXJlIGFuaW1hdGVkKVxyXG5cdC8vVGhpcyBtZWFucyB3ZSBjYW4gZGVmaW5lIHRoZSBhbmltYXRpb24gdGhleSBkbyByYXRoZXIgdGhhbiBNYXJrZXJzIGRvaW5nIGFuIGFuaW1hdGlvbiB0byB0aGVpciBhY3R1YWwgbG9jYXRpb25cclxuXHRfdW5zcGlkZXJmeVpvb21TdGFydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfdW5zcGlkZXJmeVpvb21BbmltOiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdC8vV2FpdCB1bnRpbCB0aGUgZmlyc3Qgem9vbWFuaW0gYWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIHRvdWNoLXpvb21pbmcgYmVmb3JlIHJ1bm5pbmcgdGhlIGFuaW1hdGlvblxyXG5cdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9tYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkoem9vbURldGFpbHMpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5V3JhcHBlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8vIDxzdW1tYXJ5Pl91bnNwaWRlcmZ5IGJ1dCBwYXNzZXMgbm8gYXJndW1lbnRzPC9zdW1tYXJ5PlxyXG5cdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XHJcblx0XHRcdHRoaXMuX3NwaWRlcmZpZWQudW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllZC5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9JZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGJlaW5nIHNwaWRlcmZpZWQgdGhlbiB3ZSB1bnNwaWRlcmZ5IGl0IHNvIGl0IGlzbid0IG9uIHRoZSBtYXAgYW55bW9yZSBldGNcclxuXHRfdW5zcGlkZXJmeUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllci5fc3BpZGVyTGVnKSB7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihsYXllcik7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIuY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFx0Ly9Qb3NpdGlvbiB3aWxsIGJlIGZpeGVkIHVwIGltbWVkaWF0ZWx5IGluIF9hbmltYXRpb25VbnNwaWRlcmZ5XHJcblx0XHRcdGlmIChsYXllci5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRsYXllci5zZXRaSW5kZXhPZmZzZXQoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihsYXllci5fc3BpZGVyTGVnKTtcclxuXHRcdFx0ZGVsZXRlIGxheWVyLl9zcGlkZXJMZWc7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXIuU3BpZGVyZmllci5qcyIsIi8qKlxyXG4gKiBBZGRzIDEgcHVibGljIG1ldGhvZCB0byBNQ0cgYW5kIDEgdG8gTC5NYXJrZXIgdG8gZmFjaWxpdGF0ZSBjaGFuZ2luZ1xyXG4gKiBtYXJrZXJzJyBpY29uIG9wdGlvbnMgYW5kIHJlZnJlc2hpbmcgdGhlaXIgaWNvbiBhbmQgdGhlaXIgcGFyZW50IGNsdXN0ZXJzXHJcbiAqIGFjY29yZGluZ2x5IChjYXNlIHdoZXJlIHRoZWlyIGljb25DcmVhdGVGdW5jdGlvbiB1c2VzIGRhdGEgb2YgY2hpbGRNYXJrZXJzXHJcbiAqIHRvIG1ha2UgdXAgdGhlIGNsdXN0ZXIgaWNvbikuXHJcbiAqL1xyXG5cclxuXHJcbkwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGljb24gb2YgYWxsIGNsdXN0ZXJzIHdoaWNoIGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBtYXJrZXIocykuXHJcblx0ICogSW4gc2luZ2xlTWFya2VyTW9kZSwgYWxzbyB1cGRhdGVzIHRoZSBnaXZlbiBtYXJrZXIocykgaWNvbi5cclxuXHQgKiBAcGFyYW0gbGF5ZXJzIEwuTWFya2VyQ2x1c3Rlckdyb3VwfEwuTGF5ZXJHcm91cHxBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKXxcclxuXHQgKiBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgKG9wdGlvbmFsKSBsaXN0IG9mIG1hcmtlcnMgKG9yIHNpbmdsZSBtYXJrZXIpIHdob3NlIHBhcmVudFxyXG5cdCAqIGNsdXN0ZXJzIG5lZWQgdG8gYmUgdXBkYXRlZC4gSWYgbm90IHByb3ZpZGVkLCByZXRyaWV2ZXMgYWxsIGNoaWxkIG1hcmtlcnMgb2YgdGhpcy5cclxuXHQgKiBAcmV0dXJucyB7TC5NYXJrZXJDbHVzdGVyR3JvdXB9XHJcblx0ICovXHJcblx0cmVmcmVzaENsdXN0ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHRpZiAoIWxheWVycykge1xyXG5cdFx0XHRsYXllcnMgPSB0aGlzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlckdyb3VwKSB7XHJcblx0XHRcdGxheWVycyA9IGxheWVycy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycygpO1xyXG5cdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0bGF5ZXJzID0gbGF5ZXJzLl9sYXllcnM7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xyXG5cdFx0XHRsYXllcnMgPSBsYXllcnMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyKSB7XHJcblx0XHRcdGxheWVycyA9IFtsYXllcnNdO1xyXG5cdFx0fSAvLyBlbHNlOiBtdXN0IGJlIGFuIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpXHJcblx0XHR0aGlzLl9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZShsYXllcnMpO1xyXG5cdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcclxuXHJcblx0XHQvLyBJbiBjYXNlIG9mIHNpbmdsZU1hcmtlck1vZGUsIGFsc28gcmUtZHJhdyB0aGUgbWFya2Vycy5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2luZ2xlTWFya2VyTW9kZSkge1xyXG5cdFx0XHR0aGlzLl9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnMobGF5ZXJzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaW1wbHkgZmxhZ3MgYWxsIHBhcmVudCBjbHVzdGVycyBvZiB0aGUgZ2l2ZW4gbWFya2VycyBhcyBoYXZpbmcgYSBcImRpcnR5XCIgaWNvbi5cclxuXHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZTogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0dmFyIGlkLCBwYXJlbnQ7XHJcblxyXG5cdFx0Ly8gQXNzdW1lcyBsYXllcnMgaXMgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IHdob3NlIHByb3RvdHlwZSBpcyBub24tZW51bWVyYWJsZS5cclxuXHRcdGZvciAoaWQgaW4gbGF5ZXJzKSB7XHJcblx0XHRcdC8vIEZsYWcgcGFyZW50IGNsdXN0ZXJzJyBpY29uIGFzIFwiZGlydHlcIiwgYWxsIHRoZSB3YXkgdXAuXHJcblx0XHRcdC8vIER1bWIgcHJvY2VzcyB0aGF0IGZsYWdzIG11bHRpcGxlIHRpbWVzIHVwcGVyIHBhcmVudHMsIGJ1dCBzdGlsbFxyXG5cdFx0XHQvLyBtdWNoIG1vcmUgZWZmaWNpZW50IHRoYW4gdHJ5aW5nIHRvIGJlIHNtYXJ0IGFuZCBtYWtlIHNob3J0IGxpc3RzLFxyXG5cdFx0XHQvLyBhdCBsZWFzdCBpbiB0aGUgY2FzZSBvZiBhIGhpZXJhcmNoeSBmb2xsb3dpbmcgYSBwb3dlciBsYXc6XHJcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL2ZsYWctbm9kZXMtaW4tcG93ZXItaGllcmFyY2h5LzJcclxuXHRcdFx0cGFyZW50ID0gbGF5ZXJzW2lkXS5fX3BhcmVudDtcclxuXHRcdFx0d2hpbGUgKHBhcmVudCkge1xyXG5cdFx0XHRcdHBhcmVudC5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX19wYXJlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZS1kcmF3cyB0aGUgaWNvbiBvZiB0aGUgc3VwcGxpZWQgbWFya2Vycy5cclxuXHQgKiBUbyBiZSB1c2VkIGluIHNpbmdsZU1hcmtlck1vZGUgb25seS5cclxuXHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdHZhciBpZCwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSBsYXllcnNbaWRdO1xyXG5cclxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRvIG5vdCBvdmVycmlkZSBtYXJrZXJzIHRoYXQgZG8gbm90IGJlbG9uZyB0byBUSElTIGdyb3VwLlxyXG5cdFx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0XHQvLyBOZWVkIHRvIHJlLWNyZWF0ZSB0aGUgaWNvbiBmaXJzdCwgdGhlbiByZS1kcmF3IHRoZSBtYXJrZXIuXHJcblx0XHRcdFx0bGF5ZXIuc2V0SWNvbih0aGlzLl9vdmVycmlkZU1hcmtlckljb24obGF5ZXIpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBnaXZlbiBvcHRpb25zIGluIHRoZSBtYXJrZXIncyBpY29uIGFuZCByZWZyZXNoZXMgdGhlIG1hcmtlci5cclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBtYXAgb2JqZWN0IG9mIGljb24gb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0gZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgYm9vbGVhbiAob3B0aW9uYWwpIHRydWUgdG8gdHJpZ2dlclxyXG5cdCAqIE1DRy5yZWZyZXNoQ2x1c3RlcnNPZigpIHJpZ2h0IGF3YXkgd2l0aCB0aGlzIHNpbmdsZSBtYXJrZXIuXHJcblx0ICogQHJldHVybnMge0wuTWFya2VyfVxyXG5cdCAqL1xyXG5cdHJlZnJlc2hJY29uT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMsIGRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzKSB7XHJcblx0XHR2YXIgaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uO1xyXG5cclxuXHRcdEwuc2V0T3B0aW9ucyhpY29uLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLnNldEljb24oaWNvbik7XHJcblxyXG5cdFx0Ly8gU2hvcnRjdXQgdG8gcmVmcmVzaCB0aGUgYXNzb2NpYXRlZCBNQ0cgY2x1c3RlcnMgcmlnaHQgYXdheS5cclxuXHRcdC8vIFRvIGJlIHVzZWQgd2hlbiByZWZyZXNoaW5nIGEgc2luZ2xlIG1hcmtlci5cclxuXHRcdC8vIE90aGVyd2lzZSwgYmV0dGVyIHVzZSBNQ0cucmVmcmVzaENsdXN0ZXJzKCkgb25jZSBhdCB0aGUgZW5kIHdpdGhcclxuXHRcdC8vIHRoZSBsaXN0IG9mIG1vZGlmaWVkIG1hcmtlcnMuXHJcblx0XHRpZiAoZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgJiYgdGhpcy5fX3BhcmVudCkge1xyXG5cdFx0XHR0aGlzLl9fcGFyZW50Ll9ncm91cC5yZWZyZXNoQ2x1c3RlcnModGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXJHcm91cC5SZWZyZXNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvNC4wLjAtYmV0YS9jc3MvYm9vdHN0cmFwLm1pbi5jc3NcXFwiIGludGVncml0eT1cXFwic2hhMzg0LS9ZNnBENkZWL1Z2MkhKbkE2dCt2c2xVNmZ3WVhqQ0Z0Y0VwSGJOSjBseUFGc1hUc2pCYmZhRGp6QUxlUXNONk1cXFwiXFxuICBjcm9zc29yaWdpbj1cXFwiYW5vbnltb3VzXFxcIj5cXG48bGluayBocmVmPVxcXCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9TGF0bzozMDAsNDAwLDQwMGksOTAwXFxcIiByZWw9XFxcInN0eWxlc2hlZXRcXFwiPlxcbjxsaW5rIGhyZWY9XFxcImh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNy4wL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzc1xcXCIgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBpbnRlZ3JpdHk9XFxcInNoYTM4NC13dmZYcHFwWlpWUUdLNlRBaDVQVmxHT2ZRTkhTb0QyeGJFK1FrUHhDQUZsTkVldm9FSDNTbDBzaWJWY09RVm5OXFxcIlxcbiAgY3Jvc3NvcmlnaW49XFxcImFub255bW91c1xcXCI+XFxuXFxuXFxuICA8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIGhyZWY9XFxcImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXQubWFya2VyY2x1c3RlckAxLjMuMC9kaXN0L01hcmtlckNsdXN0ZXIuY3NzXFxcIiBtZWRpYT1cXFwic2NyZWVuXFxcIj5cXG4gIDxsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldC5tYXJrZXJjbHVzdGVyQDEuMy4wL2Rpc3QvTWFya2VyQ2x1c3Rlci5EZWZhdWx0LmNzc1xcXCIgbWVkaWE9XFxcInNjcmVlblxcXCI+XFxuXFxuXFxuPHN0eWxlPlxcbiAgIDpob3N0IHtcXG4gICAgZm9udC1mYW1pbHk6ICdMYXRvJywgc2Fucy1zZXJpZjtcXG4gICAgLS1wcmltYXJ5LWNvbG9yOiAjMDAzZDdkO1xcbiAgICAtLXNlY29uZGFyeS1jb2xvcjogI2ZmNGI1ZjtcXG4gIH1cXG5cXG4gIG1haW4uY2FyZCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMTVweDtcXG4gICAgdG9wOiAxNXB4O1xcbiAgICBib3R0b206IDE1cHg7XFxuICAgIHdpZHRoOiAzMDBweDtcXG4gICAgei1pbmRleDogMTAwNTtcXG5cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgYm94LXNoYWRvdzogMCA4cHggMTBweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKSwgMCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xcblxcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTc1bXM7XFxuICB9XFxuXFxuICBhIHtcXG4gICAgY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IsIGluaGVyaXQpO1xcbiAgfVxcblxcbiAgLmJ0bi1wcmltYXJ5IHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IsIGluaGVyaXQpO1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IsIGluaGVyaXQpO1xcbiAgfVxcblxcbiAgaGVhZGVyI3BhZ2UtdGl0bGUge1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXG4gICAgaGVpZ2h0OiAxNTBweDtcXG4gIH1cXG5cXG4gIGhlYWRlciNwYWdlLXRpdGxlIGgxIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHBhZGRpbmctYm90dG9tOiA1cHg7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzPnVsPmxpLmxpc3QtZ3JvdXAtaXRlbSB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzIC5vdmVybGF5LWl0ZW0ge1xcbiAgICBmb250LXNpemU6IDEuMXJlbTtcXG4gICAgcGFkZGluZzogMC43NXJlbSAxLjI1cmVtO1xcbiAgICBjb2xvcjogIzQ0NDtcXG4gIH1cXG5cXG4gIHNlY3Rpb24jb3ZlcmxheXMgLm92ZXJsYXktaXRlbTpob3ZlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIH1cXG5cXG4gIHNlY3Rpb24jb3ZlcmxheXMgLm92ZXJsYXktaXRlbS5zZWxlY3RlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxuICAgIGNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXG5cXG4gICAgLyogbGVmdCBib3JkZXIgYW5kIG9mZnNldCB0ZXh0IGJhY2sgKi9cXG4gICAgYm9yZGVyLWxlZnQ6IDAuMjVyZW0gc29saWQgdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuICAgIHBhZGRpbmctbGVmdDogMXJlbTtcXG4gIH1cXG5cXG4gIHVsLm92ZXJsYXktbGF5ZXJzPmxpLmxpc3QtZ3JvdXAtaXRlbSB7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgYm9yZGVyLWxlZnQ6IDAuMjVyZW0gc29saWQgdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuICAgIHBhZGRpbmctbGVmdDogMS43NXJlbTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcblxcbiAgdWwub3ZlcmxheS1sYXllcnMgLm92ZXJsYXktbGF5ZXJzLXRvZ2dsZSB7XFxuICAgIC0tcHJpbWFyeS1jb2xvcjogdmFyKC0tc2Vjb25kYXJ5LWNvbG9yKTtcXG4gIH1cXG5cXG4gIGJ1dHRvbiNiYXNlbWFwLXN3aXRjaGVyLFxcbiAgYnV0dG9uI2xheWVycy1tZW51LXRvZ2dsZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcmlnaHQ6IDMwcHg7XFxuICAgIHdpZHRoOiAxNjBweDtcXG4gICAgaGVpZ2h0OiA5MHB4O1xcbiAgICB6LWluZGV4OiAxMDAxO1xcbiAgICBib3JkZXI6IDVweCBzb2xpZCAjZmZmZmZmO1xcbiAgICBib3gtc2hhZG93OiAwIDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDNweCAxNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMyk7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG5cXG4gIGJ1dHRvbiNiYXNlbWFwLXN3aXRjaGVyIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcuL2FlcmlhbC5wbmcnKTtcXG4gICAgYm90dG9tOiAzMHB4O1xcbiAgfVxcblxcbiAgYnV0dG9uI2xheWVycy1tZW51LXRvZ2dsZSB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGJvdHRvbTogMTMwcHg7XFxuICB9XFxuXFxuICBzZWN0aW9uI2Rvd25sb2FkLWRpc2NsYWltZXIge1xcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHRleHQtYWxpZ246IGp1c3RpZnk7XFxuICB9XFxuXFxuICAuc2hvdy1tb2JpbGUge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxuICAgIG1haW4ge1xcbiAgICAgIHJpZ2h0OiAzMHB4O1xcbiAgICAgIGxlZnQ6IDMwcHg7XFxuICAgICAgdG9wOiAzMHB4O1xcbiAgICAgIGJvdHRvbTogMzBweDtcXG4gICAgICB3aWR0aDogdW5zZXQ7XFxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgfVxcblxcbiAgICBtYWluLnNob3cge1xcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIH1cXG5cXG4gICAgLnNob3ctbW9iaWxlIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgfVxcblxcbiAgICBidXR0b24jYmFzZW1hcC1zd2l0Y2hlcixcXG4gICAgYnV0dG9uI2xheWVycy1tZW51LXRvZ2dsZSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgd2lkdGg6IDkwcHg7XFxuICAgICAgaGVpZ2h0OiA5MHB4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDkwcHg7XFxuICAgIH1cXG4gIH1cXG48L3N0eWxlPlxcblxcbjwhLS1saW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvNC4wLjAtYmV0YS9jc3MvYm9vdHN0cmFwLm1pbi5jc3NcXFwiIGludGVncml0eT1cXFwic2hhMzg0LS9ZNnBENkZWL1Z2MkhKbkE2dCt2c2xVNmZ3WVhqQ0Z0Y0VwSGJOSjBseUFGc1hUc2pCYmZhRGp6QUxlUXNONk1cXFwiIGNyb3Nzb3JpZ2luPVxcXCJhbm9ueW1vdXNcXFwiLS0+XFxuXFxuPG1haW4gaWQ9XFxcImxheWVycy1tZW51XFxcIiBjbGFzcz1cXFwiY2FyZFxcXCI+XFxuICA8aGVhZGVyIGlkPVxcXCJwYWdlLXRpdGxlXFxcIiBjbGFzcz1cXFwiY2FyZC1pbWctdG9wIGQtZmxleCBhbGlnbi1pdGVtcy1lbmRcXFwiPlxcbiAgICA8aDEgY2xhc3M9XFxcImgyXFxcIj5DaXR5IG9mIEdhcmRlbiBHcm92ZSBQdWJsaWMgTWFwczwvaDE+XFxuICA8L2hlYWRlcj5cXG5cXG4gIDwhLS0gU2VhcmNoIHNlY3Rpb24gLS0+XFxuICA8c2VjdGlvbiBpZD1cXFwic2VhcmNoLXNlY3Rpb25cXFwiIGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCI+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJzZWFyY2hcXFwiIGlkPVxcXCJzZWFyY2hcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgcm91bmRlZC0wXFxcIiBwbGFjZWhvbGRlcj1cXFwiU2VhcmNoIGFkZHJlc3NcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuIHJvdW5kZWQtMFxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1zZWNvbmRhcnkgcm91bmRlZC0wXFxcIj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1zZWFyY2hcXFwiPjwvaT5cXG4gICAgICA8L2J1dHRvbj5cXG4gICAgPC9zcGFuPlxcbiAgPC9zZWN0aW9uPlxcblxcbiAgPCEtLSBMaXN0IG9mIGF2YWlsYWJsZSBvdmVybGF5cyAtLT5cXG4gIDxzZWN0aW9uIGlkPVxcXCJvdmVybGF5c1xcXCI+XFxuICAgIDx1bCBjbGFzcz1cXFwibGlzdC1ncm91cFxcXCI+XFxuXFxuICAgICAgPHRlbXBsYXRlIGlzPVxcXCJkb20tcmVwZWF0XFxcIiBpdGVtcz1cXFwie3tvdmVybGF5TWFwc319XFxcIj5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwibGlzdC1ncm91cC1pdGVtXFxcIj5cXG5cXG4gICAgICAgICAgPCEtLSBNYWluIG92ZXJsYXkgdG9nZ2xlIC0tPlxcbiAgICAgICAgICA8ZGl2IHRpdGxlPVxcXCJbW2l0ZW0uZGVzY3JpcHRpb25dXVxcXCIgY2xhc3MkPVxcXCJbW19vdmVybGF5SXRlbUNsYXNzKHNlbGVjdGVkT3ZlcmxheSwgaXRlbSldXVxcXCIgb24tY2xpY2s9XFxcIm92ZXJsYXlTZWxlY3RcXFwiPlxcbiAgICAgICAgICAgIDxwYXBlci10b2dnbGUtYnV0dG9uIGNoZWNrZWQ9XFxcIltbX2lzQ3VycmVudE92ZXJsYXkoc2VsZWN0ZWRPdmVybGF5LCBpdGVtKV1dXFxcIj48L3BhcGVyLXRvZ2dsZS1idXR0b24+XFxuICAgICAgICAgICAgPHNwYW4+W1tpdGVtLm5hbWVdXTwvc3Bhbj5cXG4gICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgIDxkaXYgY2xhc3MkPVxcXCJbW19vdmVybGF5TGF5ZXJzU2hvdyhzZWxlY3RlZE92ZXJsYXksIGl0ZW0pXV1cXFwiPlxcbiAgICAgICAgICAgIDx1bCBjbGFzcz1cXFwib3ZlcmxheS1sYXllcnMgbGlzdC1ncm91cCBsaXN0LWdyb3VwLWZsdXNoXFxcIj5cXG5cXG4gICAgICAgICAgICAgIDwhLS0gRXhjbHVzaXZlIGxheWVycyAtLT5cXG4gICAgICAgICAgICAgIDx0ZW1wbGF0ZSBpcz1cXFwiZG9tLXJlcGVhdFxcXCIgaXRlbXM9XFxcInt7aXRlbS5sYXllcnMuZXhjbHVzaXZlc319XFxcIiBhcz1cXFwibGF5ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImxpc3QtZ3JvdXAtaXRlbSBkLWZsZXgganVzdGlmeS1jb250ZW50LXN0YXJ0XFxcIiBvbi1jbGljaz1cXFwidG9nZ2xlTGF5ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxwYXBlci10b2dnbGUtYnV0dG9uIGNsYXNzPVxcXCJvdmVybGF5LWxheWVycy10b2dnbGVcXFwiIGNoZWNrZWQ9XFxcIltbX2lzQ3VycmVudEV4Y2x1c2l2ZShsYXllciwgd21zR3JvdXBzKV1dXFxcIj48L3BhcGVyLXRvZ2dsZS1idXR0b24+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1yLWF1dG9cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgW1tsYXllci5uYW1lXV1cXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgb24tY2xpY2s9XFxcImRvd25sb2FkTGF5ZXJcXFwiIGNsYXNzPVxcXCJqdXN0aWZ5LXNlbGYtZW5kXFxcIj48aSB0aXRsZT1cXFwiRG93bmxvYWQgW1tsYXllci5uYW1lXV1cXFwiIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1kb3dubG9hZFxcXCI+PC9pPjwvYT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDwvdGVtcGxhdGU+XFxuXFxuICAgICAgICAgICAgICA8IS0tIE9wdGlvbmFsIGxheWVycyAtLT5cXG4gICAgICAgICAgICAgIDx0ZW1wbGF0ZSBpcz1cXFwiZG9tLXJlcGVhdFxcXCIgaXRlbXM9XFxcInt7aXRlbS5sYXllcnMub3B0aW9uYWxzfX1cXFwiIGFzPVxcXCJsYXllclxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwibGlzdC1ncm91cC1pdGVtIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtc3RhcnRcXFwiIG9uLWNsaWNrPVxcXCJ0b2dnbGVMYXllclxcXCI+XFxuICAgICAgICAgICAgICAgICAgPHBhcGVyLXRvZ2dsZS1idXR0b24gY2xhc3M9XFxcIm92ZXJsYXktbGF5ZXJzLXRvZ2dsZVxcXCIgY2hlY2tlZD1cXFwiW1tsYXllci52aXNpYmxlXV1cXFwiPjwvcGFwZXItdG9nZ2xlLWJ1dHRvbj5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibXItYXV0b1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICBbW2xheWVyLm5hbWVdXVxcbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBvbi1jbGljaz1cXFwiZG93bmxvYWRMYXllclxcXCIgY2xhc3M9XFxcImp1c3RpZnktc2VsZi1lbmRcXFwiPjxpIHRpdGxlPVxcXCJEb3dubG9hZCBbW2xheWVyLm5hbWVdXVxcXCIgY2xhc3M9XFxcImZhIGZhLWZ3IGZhLWRvd25sb2FkXFxcIj48L2k+PC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPC90ZW1wbGF0ZT5cXG5cXG4gICAgICAgICAgICA8L3VsPlxcbiAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDwvbGk+XFxuICAgICAgPC90ZW1wbGF0ZT5cXG5cXG4gICAgPC91bD5cXG4gIDwvc2VjdGlvbj5cXG5cXG4gIDxmb290ZXIgY2xhc3M9XFxcImNhcmQtYm9keVxcXCI+XFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPkhlbHA8L2E+XFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPlRvdXI8L2E+XFxuICAgIDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHQgc2hvdy1tb2JpbGVcXFwiPlxcbiAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIG9uLWNsaWNrPVxcXCJ0b2dnbGVMYXllcnNNZW51XFxcIj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1tYXBcXFwiPjwvaT5cXG4gICAgICAgIFZpZXcgTWFwXFxuICAgICAgPC9hPlxcbiAgICA8L2Rpdj5cXG4gIDwvZm9vdGVyPlxcbjwvbWFpbj5cXG5cXG48IS0tIEJhc2VtYXAgdG9nZ2xlIGJ1dHRvbiAtLT5cXG48YnV0dG9uIGlkPVxcXCJiYXNlbWFwLXN3aXRjaGVyXFxcIiBvbi1jbGljaz1cXFwic3dpdGNoQmFzZW1hcFxcXCI+PC9idXR0b24+XFxuXFxuPCEtLSBMYXllcnMgY29udHJvbCBtZW51IChtb2JpbGUgb25seSkgLS0+XFxuPGJ1dHRvbiBpZD1cXFwibGF5ZXJzLW1lbnUtdG9nZ2xlXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBvbi1jbGljaz1cXFwidG9nZ2xlTGF5ZXJzTWVudVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLW1hcCBmYS0zeFxcXCI+PC9pPjwvYnV0dG9uPlxcblxcbjxsZWFmbGV0LW1hcCBtYXA9XFxcInt7bWFwfX1cXFwiIGxhdGl0dWRlPVxcXCIzMy43Nzg3MjRcXFwiIGxvbmdpdHVkZT1cXFwiLTExNy45NjAwNThcXFwiIHpvb209XFxcIjEzXFxcIiBtaW4tem9vbT1cXFwiMTFcXFwiIG1heC16b29tPVxcXCIxOVxcXCIgYXR0cmlidXRpb24tcHJlZml4PVxcXCJDaXR5IG9mIEdhcmRlbiBHcm92ZVxcXCI+XFxuXFxuICA8dGVtcGxhdGUgaXM9XFxcImRvbS1pZlxcXCIgaWY9XFxcInt7YmFzZVNvdXJjZX19XFxcIiByZXN0YW1wPlxcbiAgICA8bGVhZmxldC10aWxlLWxheWVyIG1hcD1cXFwie3ttYXB9fVxcXCIgdXJsPVxcXCJbW2Jhc2VTb3VyY2VdXVxcXCIgZm9ybWF0PVxcXCJbW2Jhc2VGb3JtYXRdXVxcXCIgbGF5ZXJzPVxcXCJbW2Jhc2VMYXllcnNdXVxcXCIgYXR0cmlidXRpb249XFxcIiZjb3B5OyBPcGVuU3RyZWV0TWFwXFxcIj5cXG4gICAgPC9sZWFmbGV0LXRpbGUtbGF5ZXI+XFxuICA8L3RlbXBsYXRlPlxcblxcbiAgPHRlbXBsYXRlIGlzPVxcXCJkb20tcmVwZWF0XFxcIiBpdGVtcz1cXFwie3t3bXNHcm91cHN9fVxcXCIgYXM9XFxcImdyb3VwXFxcIj5cXG4gICAgPGxlYWZsZXQtd21zLWdyb3VwIG1hcD1cXFwie3ttYXB9fVxcXCIgc291cmNlPVxcXCJbW2dyb3VwLnNvdXJjZV1dXFxcIiBsYXllcnM9XFxcIltbZ3JvdXAubGF5ZXJzXV1cXFwiIHRyYW5zcGFyZW50IGZvcm1hdD1cXFwiaW1hZ2UvcG5nXFxcIj5cXG4gICAgPC9sZWFmbGV0LXdtcy1ncm91cD5cXG4gIDwvdGVtcGxhdGU+XFxuXFxuICA8dGVtcGxhdGUgaXM9XFxcImRvbS1yZXBlYXRcXFwiIGl0ZW1zPVxcXCJ7e2dlb2pzb25MYXllcnN9fVxcXCIgYXM9XFxcImxheWVyXFxcIj5cXG4gICAgPGxlYWZsZXQtZ2VvanNvbi1wb2ludHMgbWFwPVxcXCJ7e21hcH19XFxcIiBzb3VyY2UkPVxcXCJbW2xheWVyLnNvdXJjZV1dXFxcIiByYWRpdXMkPVxcXCJbW2xheWVyLnJhZGl1c11dXFxcIiB3ZWlnaHQkPVxcXCJbW2xheWVyLndlaWdodF1dXFxcIiBtYXgtY2x1c3Rlci1yYWRpdXMkPVxcXCJbW2xheWVyLm1heENsdXN0ZXJSYWRpdXNdXVxcXCJcXG4gICAgICBmaWxsLWNvbG9yJD1cXFwiW1tsYXllci5maWxsQ29sb3JdXVxcXCIgb3V0bGluZS1jb2xvciQ9XFxcIltbbGF5ZXIub3V0bGluZUNvbG9yXV1cXFwiIG9wYWNpdHkkPVxcXCJbW2xheWVyLm9wYWNpdHldXVxcXCIgZmlsbC1vcGFjaXR5JD1cXFwiW1tsYXllci5maWxsT3BhY2l0eV1dXFxcIiBpZGVudGlmeSQ9XFxcIltbbGF5ZXIuaWRlbnRpZnldXVxcXCJcXG4gICAgICBhdHRyaWJ1dGlvbiQ9XFxcIltbbGF5ZXIuYXR0cmlidXRpb25dXVxcXCIgY2x1c3RlciQ9XFxcIltbbGF5ZXIuY2x1c3Rlcl1dXFxcIj5cXG4gICAgPC9sZWFmbGV0LWdlb2pzb24tcG9pbnRzPlxcbiAgPC90ZW1wbGF0ZT5cXG48L2xlYWZsZXQtbWFwPlxcblxcbjwhLS0gRG93bmxvYWQgTW9kYWwgLS0+XFxuPGRpdiBjbGFzcz1cXFwibW9kYWwgZmFkZVxcXCIgaWQ9XFxcImRvd25sb2FkLW1vZGFsXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1tb2RhbC1sYWJlbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nIG1vZGFsLWxnXFxcIiByb2xlPVxcXCJkb2N1bWVudFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNvbnRlbnRcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxuICAgICAgICA8aDMgY2xhc3M9XFxcIm1vZGFsLXRpdGxlXFxcIiBpZD1cXFwiZG93bmxvYWQtbW9kYWwtbGFiZWxcXFwiPlxcbiAgICAgICAgICA8c3BhbiBpZD1cXFwibGF5ZXItbmFtZVxcXCI+PC9zcGFuPlxcbiAgICAgICAgPC9oMz5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiIGFyaWEtbGFiZWw9XFxcIkNsb3NlXFxcIj5cXG4gICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L3NwYW4+XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1ib2R5XFxcIj5cXG4gICAgICAgIDxzZWN0aW9uIHN0eWxlPVxcXCJoZWlnaHQ6IDQwMHB4OyBvdmVyZmxvdzogYXV0bzsgcGFkZGluZzogMTBweDsgYmFja2dyb3VuZC1jb2xvcjogI2VlZTsgZm9udC1zaXplOiAwLjg1cmVtO1xcXCI+XFxuICAgICAgICAgIDxoNT5Eb3dubG9hZCBEaXNjbGFpbWVyPC9oNT5cXG5cXG4gICAgICAgICAgPHA+VGhlIENpdHkgb2YgR2FyZGVuIEdyb3ZlIHByb3ZpZGVzIHRoZSBkYXRhIGFzIGEgcHVibGljIHJlc291cmNlIG9mIGdlbmVyYWwgaW5mb3JtYXRpb24gZm9yIHVzZSBcXFwiYXMgaXMuXFxcIiBUaGUgQ2l0eVxcbiAgICAgICAgICAgIG9mIEdhcmRlbiBHcm92ZSBwcm92aWRlcyB0aGlzIGluZm9ybWF0aW9uIHdpdGggdGhlIHVuZGVyc3RhbmRpbmcgdGhhdCBpdCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBhY2N1cmF0ZSwgY29ycmVjdFxcbiAgICAgICAgICAgIG9yIGNvbXBsZXRlIGFuZCBhbnkgY29uY2x1c2lvbnMgZHJhd24gZnJvbSBzdWNoIGluZm9ybWF0aW9uIGFyZSB0aGUgc29sZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdXNlci4gRnVydGhlcixcXG4gICAgICAgICAgICB0aGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgbWFrZXMgbm8gd2FycmFudHksIHJlcHJlc2VudGF0aW9uIG9yIGd1YXJhbnR5IGFzIHRvIHRoZSBjb250ZW50LCBzZXF1ZW5jZSwgYWNjdXJhY3ksXFxuICAgICAgICAgICAgdGltZWxpbmVzcyBvciBjb21wbGV0ZW5lc3Mgb2YgYW55IG9mIHRoZSBzcGF0aWFsIG9yIGRhdGFiYXNlIGluZm9ybWF0aW9uIHByb3ZpZGVkIGhlcmVpbi4gV2hpbGUgZXZlcnkgZWZmb3J0XFxuICAgICAgICAgICAgaGFzIGJlZW4gbWFkZSB0byBlbnN1cmUgdGhlIGNvbnRlbnQsIHNlcXVlbmNlLCBhY2N1cmFjeSwgdGltZWxpbmVzcyBvciBjb21wbGV0ZW5lc3Mgb2YgbWF0ZXJpYWxzIHByZXNlbnRlZCB3aXRoaW5cXG4gICAgICAgICAgICB0aGVzZSBwYWdlcywgdGhlIENpdHkgb2YgR2FyZGVuIEdyb3ZlIGFzc3VtZXMgbm8gcmVzcG9uc2liaWxpdHkgZm9yIGVycm9ycyBvciBvbWlzc2lvbnMsIGFuZCBleHBsaWNpdGx5IGRpc2NsYWltc1xcbiAgICAgICAgICAgIGFueSByZXByZXNlbnRhdGlvbnMgYW5kIHdhcnJhbnRpZXMsIGluY2x1ZGluZywgd2l0aG91dCBsaW1pdGF0aW9uLCB0aGUgaW1wbGllZCB3YXJyYW50aWVzIG9mIG1lcmNoYW50YWJpbGl0eVxcbiAgICAgICAgICAgIGFuZCBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZS4gVGhlIENpdHkgb2YgR2FyZGVuIEdyb3ZlIHNoYWxsIGFzc3VtZSBubyBsaWFiaWxpdHkgZm9yOjwvcD5cXG4gICAgICAgICAgPHA+MS5BbnkgZXJyb3JzLCBvbWlzc2lvbnMsIG9yIGluYWNjdXJhY2llcyBpbiB0aGUgaW5mb3JtYXRpb24gcHJvdmlkZWQsIHJlZ2FyZGxlc3Mgb2YgaG93IGNhdXNlZDsgb3IgMi5BbnkgZGVjaXNpb25cXG4gICAgICAgICAgICBtYWRlIG9yIGFjdGlvbiB0YWtlbiBvciBub3QgdGFrZW4gYnkgdmlld2VyIGluIHJlbGlhbmNlIHVwb24gYW55IGluZm9ybWF0aW9uIG9yIGRhdGEgZnVybmlzaGVkIGhlcmV1bmRlci48L3A+XFxuICAgICAgICAgIDxwPkF2YWlsYWJpbGl0eSBvZiB0aGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgR0lTIGlzIG5vdCBndWFyYW50ZWVkLiBBcHBsaWNhdGlvbnMsIHNlcnZlcnMsIGFuZCBuZXR3b3JrIGNvbm5lY3Rpb25zXFxuICAgICAgICAgICAgbWF5IGJlIHVuYXZhaWxhYmxlIGF0IGFueSB0aW1lIGZvciBtYWludGVuYW5jZSBvciB1bnNjaGVkdWxlZCBvdXRhZ2VzLiBPdXRhZ2VzIG1heSBiZSBvZiBsb25nIGR1cmF0aW9uLiBVc2Vyc1xcbiAgICAgICAgICAgIGFyZSBjYXV0aW9uZWQgdG8gY3JlYXRlIGRlcGVuZGVuY2llcyBvbiB0aGVzZSBzZXJ2aWNlcyBmb3IgY3JpdGljYWwgbmVlZHMuPC9wPlxcbiAgICAgICAgICA8cD5USEUgRk9SRUdPSU5HIFdBUlJBTlRZIElTIEVYQ0xVU0lWRSBBTkQgSU4gTElFVSBPRiBBTEwgT1RIRVIgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIFBBUlRJQ1VMQVJcXG4gICAgICAgICAgICBQVVJQT1NFIEFORC9PUiBBTlkgT1RIRVIgVFlQRSBXSEVUSEVSIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBJbiBubyBldmVudCBzaGFsbCBUaGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgYmVjb21lXFxuICAgICAgICAgICAgbGlhYmxlIHRvIHVzZXJzIG9mIHRoZXNlIGRhdGEsIG9yIGFueSBvdGhlciBwYXJ0eSwgZm9yIGFueSBsb3NzIG9yIGRpcmVjdCwgaW5kaXJlY3QsIHNwZWNpYWwsIGluY2lkZW50YWwgb3IgY29uc2VxdWVudGlhbFxcbiAgICAgICAgICAgIGRhbWFnZXMsIGluY2x1ZGluZywgYnV0IG5vdCBsaW1pdGVkIHRvLCB0aW1lLCBtb25leSBvciBnb29kd2lsbCwgYXJpc2luZyBmcm9tIHRoZSB1c2Ugb3IgbW9kaWZpY2F0aW9uIG9mIHRoZVxcbiAgICAgICAgICAgIGRhdGEuPC9wPlxcbiAgICAgICAgICA8cD5UbyBhc3Npc3QgVGhlIENpdHkgb2YgR2FyZGVuIEdyb3ZlIGluIHRoZSBtYWludGVuYW5jZSBhbmQvb3IgY29ycmVjdGlvbiBvZiB0aGUgZGF0YSwgdXNlcnMgc2hvdWxkIHByb3ZpZGUgdGhlIENpdHlcXG4gICAgICAgICAgICBvZiBHYXJkZW4gR3JvdmUgd2l0aCBpbmZvcm1hdGlvbiBjb25jZXJuaW5nIGVycm9ycyBvciBkaXNjcmVwYW5jaWVzIGZvdW5kIGluIHVzaW5nIHRoZSBkYXRhLiBQbGVhc2UgYWNrbm93bGVkZ2VcXG4gICAgICAgICAgICB0aGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgYXMgdGhlIHNvdXJjZSB3aGVuIGRhdGEgaXMgdXNlZCBpbiB0aGUgcHJlcGFyYXRpb24gb2YgcmVwb3J0cywgcGFwZXJzLCBwdWJsaWNhdGlvbnMsXFxuICAgICAgICAgICAgbWFwcywgb3Igb3RoZXIgcHJvZHVjdHMuPC9wPlxcbiAgICAgICAgPC9zZWN0aW9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgICAgICA8IS0tYnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc2Vjb25kYXJ5XFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj5DbG9zZTwvYnV0dG9uLS0+XFxuICAgICAgICA8c3BhbiBpZD1cXFwiZG93bmxvYWQtYnV0dG9ucy1sYWJlbFxcXCI+RG93bmxvYWQgYXM6PC9zcGFuPlxcbiAgICAgICAgPGEgaWQ9XFxcImdlb2pzb24tZG93bmxvYWRcXFwiIGhyZWY9XFxcIiNcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImRvd25sb2FkLWJ1dHRvbnMtbGFiZWxcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZG93bmxvYWRcXFwiPjwvaT5HZW9KU09OXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwiY3N2LWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+Q1NWXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwia21sLWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+S01MXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwic2hhcGVmaWxlLWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+U2hhcGVmaWxlXFxuICAgICAgICA8L2E+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hcHAudGVtcGxhdGUuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcykuanN5YW1sPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGUodCxuLGkpe2Z1bmN0aW9uIHIoYSxzKXtpZighblthXSl7aWYoIXRbYV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXMmJmMpcmV0dXJuIGMoYSwhMCk7aWYobylyZXR1cm4gbyhhLCEwKTt2YXIgdT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2ErXCInXCIpO3Rocm93IHUuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix1fXZhciBsPW5bYV09e2V4cG9ydHM6e319O3RbYV1bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFthXVsxXVtlXTtyZXR1cm4gcihufHxlKX0sbCxsLmV4cG9ydHMsZSx0LG4saSl9cmV0dXJuIG5bYV0uZXhwb3J0c31mb3IodmFyIG89XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxhPTA7YTxpLmxlbmd0aDthKyspcihpW2FdKTtyZXR1cm4gcn0oezE6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiBmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIFwiK2UrXCIgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuXCIpfX12YXIgcj1lKFwiLi9qcy15YW1sL2xvYWRlclwiKSxvPWUoXCIuL2pzLXlhbWwvZHVtcGVyXCIpO3QuZXhwb3J0cy5UeXBlPWUoXCIuL2pzLXlhbWwvdHlwZVwiKSx0LmV4cG9ydHMuU2NoZW1hPWUoXCIuL2pzLXlhbWwvc2NoZW1hXCIpLHQuZXhwb3J0cy5GQUlMU0FGRV9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIiksdC5leHBvcnRzLkpTT05fU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2pzb25cIiksdC5leHBvcnRzLkNPUkVfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2NvcmVcIiksdC5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlXCIpLHQuZXhwb3J0cy5ERUZBVUxUX0ZVTExfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSx0LmV4cG9ydHMubG9hZD1yLmxvYWQsdC5leHBvcnRzLmxvYWRBbGw9ci5sb2FkQWxsLHQuZXhwb3J0cy5zYWZlTG9hZD1yLnNhZmVMb2FkLHQuZXhwb3J0cy5zYWZlTG9hZEFsbD1yLnNhZmVMb2FkQWxsLHQuZXhwb3J0cy5kdW1wPW8uZHVtcCx0LmV4cG9ydHMuc2FmZUR1bXA9by5zYWZlRHVtcCx0LmV4cG9ydHMuWUFNTEV4Y2VwdGlvbj1lKFwiLi9qcy15YW1sL2V4Y2VwdGlvblwiKSx0LmV4cG9ydHMuTUlOSU1BTF9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIiksdC5leHBvcnRzLlNBRkVfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZVwiKSx0LmV4cG9ydHMuREVGQVVMVF9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsXCIpLHQuZXhwb3J0cy5zY2FuPWkoXCJzY2FuXCIpLHQuZXhwb3J0cy5wYXJzZT1pKFwicGFyc2VcIiksdC5leHBvcnRzLmNvbXBvc2U9aShcImNvbXBvc2VcIiksdC5leHBvcnRzLmFkZENvbnN0cnVjdG9yPWkoXCJhZGRDb25zdHJ1Y3RvclwiKX0se1wiLi9qcy15YW1sL2R1bXBlclwiOjMsXCIuL2pzLXlhbWwvZXhjZXB0aW9uXCI6NCxcIi4vanMteWFtbC9sb2FkZXJcIjo1LFwiLi9qcy15YW1sL3NjaGVtYVwiOjcsXCIuL2pzLXlhbWwvc2NoZW1hL2NvcmVcIjo4LFwiLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGxcIjo5LFwiLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmVcIjoxMCxcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIjoxMSxcIi4vanMteWFtbC9zY2hlbWEvanNvblwiOjEyLFwiLi9qcy15YW1sL3R5cGVcIjoxM31dLDI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiB2b2lkIDA9PT1lfHxudWxsPT09ZX10LmV4cG9ydHMuaXNOb3RoaW5nPWksdC5leHBvcnRzLmlzT2JqZWN0PWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZX0sdC5leHBvcnRzLnRvQXJyYXk9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTppKGUpP1tdOltlXX0sdC5leHBvcnRzLnJlcGVhdD1mdW5jdGlvbihlLHQpe3ZhciBuLGk9XCJcIjtmb3Iobj0wO248dDtuKz0xKWkrPWU7cmV0dXJuIGl9LHQuZXhwb3J0cy5pc05lZ2F0aXZlWmVybz1mdW5jdGlvbihlKXtyZXR1cm4gMD09PWUmJk51bWJlci5ORUdBVElWRV9JTkZJTklUWT09PTEvZX0sdC5leHBvcnRzLmV4dGVuZD1mdW5jdGlvbihlLHQpe3ZhciBuLGkscixvO2lmKHQpZm9yKG49MCxpPShvPU9iamVjdC5rZXlzKHQpKS5sZW5ndGg7bjxpO24rPTEpZVtyPW9bbl1dPXRbcl07cmV0dXJuIGV9fSx7fV0sMzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0KXt2YXIgbixpLHIsbyxhLHMsYztpZihudWxsPT09dClyZXR1cm57fTtmb3Iobj17fSxyPTAsbz0oaT1PYmplY3Qua2V5cyh0KSkubGVuZ3RoO3I8bztyKz0xKWE9aVtyXSxzPVN0cmluZyh0W2FdKSxcIiEhXCI9PT1hLnNsaWNlKDAsMikmJihhPVwidGFnOnlhbWwub3JnLDIwMDI6XCIrYS5zbGljZSgyKSksKGM9ZS5jb21waWxlZFR5cGVNYXAuZmFsbGJhY2tbYV0pJiZULmNhbGwoYy5zdHlsZUFsaWFzZXMscykmJihzPWMuc3R5bGVBbGlhc2VzW3NdKSxuW2FdPXM7cmV0dXJuIG59ZnVuY3Rpb24gcihlKXt2YXIgdCxuLGk7aWYodD1lLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLGU8PTI1NSluPVwieFwiLGk9MjtlbHNlIGlmKGU8PTY1NTM1KW49XCJ1XCIsaT00O2Vsc2V7aWYoIShlPD00Mjk0OTY3Mjk1KSl0aHJvdyBuZXcgRihcImNvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkZcIik7bj1cIlVcIixpPTh9cmV0dXJuXCJcXFxcXCIrbitFLnJlcGVhdChcIjBcIixpLXQubGVuZ3RoKSt0fWZ1bmN0aW9uIG8oZSl7dGhpcy5zY2hlbWE9ZS5zY2hlbWF8fF8sdGhpcy5pbmRlbnQ9TWF0aC5tYXgoMSxlLmluZGVudHx8MiksdGhpcy5za2lwSW52YWxpZD1lLnNraXBJbnZhbGlkfHwhMSx0aGlzLmZsb3dMZXZlbD1FLmlzTm90aGluZyhlLmZsb3dMZXZlbCk/LTE6ZS5mbG93TGV2ZWwsdGhpcy5zdHlsZU1hcD1pKHRoaXMuc2NoZW1hLGUuc3R5bGVzfHxudWxsKSx0aGlzLnNvcnRLZXlzPWUuc29ydEtleXN8fCExLHRoaXMubGluZVdpZHRoPWUubGluZVdpZHRofHw4MCx0aGlzLm5vUmVmcz1lLm5vUmVmc3x8ITEsdGhpcy5ub0NvbXBhdE1vZGU9ZS5ub0NvbXBhdE1vZGV8fCExLHRoaXMuY29uZGVuc2VGbG93PWUuY29uZGVuc2VGbG93fHwhMSx0aGlzLmltcGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdCx0aGlzLmV4cGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdCx0aGlzLnRhZz1udWxsLHRoaXMucmVzdWx0PVwiXCIsdGhpcy5kdXBsaWNhdGVzPVtdLHRoaXMudXNlZER1cGxpY2F0ZXM9bnVsbH1mdW5jdGlvbiBhKGUsdCl7Zm9yKHZhciBuLGk9RS5yZXBlYXQoXCIgXCIsdCkscj0wLG89LTEsYT1cIlwiLHM9ZS5sZW5ndGg7cjxzOyktMT09PShvPWUuaW5kZXhPZihcIlxcblwiLHIpKT8obj1lLnNsaWNlKHIpLHI9cyk6KG49ZS5zbGljZShyLG8rMSkscj1vKzEpLG4ubGVuZ3RoJiZcIlxcblwiIT09biYmKGErPWkpLGErPW47cmV0dXJuIGF9ZnVuY3Rpb24gcyhlLHQpe3JldHVyblwiXFxuXCIrRS5yZXBlYXQoXCIgXCIsZS5pbmRlbnQqdCl9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuLGk7Zm9yKG49MCxpPWUuaW1wbGljaXRUeXBlcy5sZW5ndGg7bjxpO24rPTEpaWYoZS5pbXBsaWNpdFR5cGVzW25dLnJlc29sdmUodCkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gdShlKXtyZXR1cm4gZT09PVV8fGU9PT1MfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIDMyPD1lJiZlPD0xMjZ8fDE2MTw9ZSYmZTw9NTUyOTUmJjgyMzIhPT1lJiY4MjMzIT09ZXx8NTczNDQ8PWUmJmU8PTY1NTMzJiY2NTI3OSE9PWV8fDY1NTM2PD1lJiZlPD0xMTE0MTExfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGwoZSkmJjY1Mjc5IT09ZSYmZSE9PSQmJmUhPT1KJiZlIT09USYmZSE9PWVlJiZlIT09bmUmJmUhPT1HJiZlIT09Un1mdW5jdGlvbiBmKGUpe3JldHVybiBsKGUpJiY2NTI3OSE9PWUmJiF1KGUpJiZlIT09SCYmZSE9PVomJmUhPT1HJiZlIT09JCYmZSE9PUomJmUhPT1RJiZlIT09ZWUmJmUhPT1uZSYmZSE9PVImJmUhPT1XJiZlIT09SyYmZSE9PXEmJmUhPT10ZSYmZSE9PVYmJmUhPT1CJiZlIT09WSYmZSE9PVAmJmUhPT16JiZlIT09WH1mdW5jdGlvbiBkKGUsdCxuLGkscil7dmFyIG8sYSxzPSExLGM9ITEsZD0tMSE9PWksaD0tMSxtPWYoZS5jaGFyQ29kZUF0KDApKSYmIXUoZS5jaGFyQ29kZUF0KGUubGVuZ3RoLTEpKTtpZih0KWZvcihvPTA7bzxlLmxlbmd0aDtvKyspe2lmKGE9ZS5jaGFyQ29kZUF0KG8pLCFsKGEpKXJldHVybiB1ZTttPW0mJnAoYSl9ZWxzZXtmb3Iobz0wO288ZS5sZW5ndGg7bysrKXtpZigoYT1lLmNoYXJDb2RlQXQobykpPT09RClzPSEwLGQmJihjPWN8fG8taC0xPmkmJlwiIFwiIT09ZVtoKzFdLGg9byk7ZWxzZSBpZighbChhKSlyZXR1cm4gdWU7bT1tJiZwKGEpfWM9Y3x8ZCYmby1oLTE+aSYmXCIgXCIhPT1lW2grMV19cmV0dXJuIHN8fGM/XCIgXCI9PT1lWzBdJiZuPjk/dWU6Yz9jZTpzZTptJiYhcihlKT9vZTphZX1mdW5jdGlvbiBoKGUsdCxuLGkpe2UuZHVtcD1mdW5jdGlvbigpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm5cIicnXCI7aWYoIWUubm9Db21wYXRNb2RlJiYtMSE9PXJlLmluZGV4T2YodCkpcmV0dXJuXCInXCIrdCtcIidcIjt2YXIgcj1lLmluZGVudCpNYXRoLm1heCgxLG4pLG89LTE9PT1lLmxpbmVXaWR0aD8tMTpNYXRoLm1heChNYXRoLm1pbihlLmxpbmVXaWR0aCw0MCksZS5saW5lV2lkdGgtcikscz1pfHxlLmZsb3dMZXZlbD4tMSYmbj49ZS5mbG93TGV2ZWw7c3dpdGNoKGQodCxzLGUuaW5kZW50LG8sZnVuY3Rpb24odCl7cmV0dXJuIGMoZSx0KX0pKXtjYXNlIG9lOnJldHVybiB0O2Nhc2UgYWU6cmV0dXJuXCInXCIrdC5yZXBsYWNlKC8nL2csXCInJ1wiKStcIidcIjtjYXNlIHNlOnJldHVyblwifFwiK20odCxlLmluZGVudCkrZyhhKHQscikpO2Nhc2UgY2U6cmV0dXJuXCI+XCIrbSh0LGUuaW5kZW50KStnKGEoeSh0LG8pLHIpKTtjYXNlIHVlOnJldHVybidcIicrdih0KSsnXCInO2RlZmF1bHQ6dGhyb3cgbmV3IEYoXCJpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZVwiKX19KCl9ZnVuY3Rpb24gbShlLHQpe3ZhciBuPVwiIFwiPT09ZVswXT9TdHJpbmcodCk6XCJcIixpPVwiXFxuXCI9PT1lW2UubGVuZ3RoLTFdO3JldHVybiBuKyhpJiYoXCJcXG5cIj09PWVbZS5sZW5ndGgtMl18fFwiXFxuXCI9PT1lKT9cIitcIjppP1wiXCI6XCItXCIpK1wiXFxuXCJ9ZnVuY3Rpb24gZyhlKXtyZXR1cm5cIlxcblwiPT09ZVtlLmxlbmd0aC0xXT9lLnNsaWNlKDAsLTEpOmV9ZnVuY3Rpb24geShlLHQpe2Zvcih2YXIgbixpLHI9LyhcXG4rKShbXlxcbl0qKS9nLG89ZnVuY3Rpb24oKXt2YXIgbj1lLmluZGV4T2YoXCJcXG5cIik7cmV0dXJuIG49LTEhPT1uP246ZS5sZW5ndGgsci5sYXN0SW5kZXg9bix4KGUuc2xpY2UoMCxuKSx0KX0oKSxhPVwiXFxuXCI9PT1lWzBdfHxcIiBcIj09PWVbMF07aT1yLmV4ZWMoZSk7KXt2YXIgcz1pWzFdLGM9aVsyXTtuPVwiIFwiPT09Y1swXSxvKz1zKyhhfHxufHxcIlwiPT09Yz9cIlwiOlwiXFxuXCIpK3goYyx0KSxhPW59cmV0dXJuIG99ZnVuY3Rpb24geChlLHQpe2lmKFwiXCI9PT1lfHxcIiBcIj09PWVbMF0pcmV0dXJuIGU7Zm9yKHZhciBuLGkscj0vIFteIF0vZyxvPTAsYT0wLHM9MCxjPVwiXCI7bj1yLmV4ZWMoZSk7KShzPW4uaW5kZXgpLW8+dCYmKGk9YT5vP2E6cyxjKz1cIlxcblwiK2Uuc2xpY2UobyxpKSxvPWkrMSksYT1zO3JldHVybiBjKz1cIlxcblwiLGUubGVuZ3RoLW8+dCYmYT5vP2MrPWUuc2xpY2UobyxhKStcIlxcblwiK2Uuc2xpY2UoYSsxKTpjKz1lLnNsaWNlKG8pLGMuc2xpY2UoMSl9ZnVuY3Rpb24gdihlKXtmb3IodmFyIHQsbixpLG89XCJcIixhPTA7YTxlLmxlbmd0aDthKyspKHQ9ZS5jaGFyQ29kZUF0KGEpKT49NTUyOTYmJnQ8PTU2MzE5JiYobj1lLmNoYXJDb2RlQXQoYSsxKSk+PTU2MzIwJiZuPD01NzM0Mz8obys9cigxMDI0Kih0LTU1Mjk2KStuLTU2MzIwKzY1NTM2KSxhKyspOm8rPSEoaT1pZVt0XSkmJmwodCk/ZVthXTppfHxyKHQpO3JldHVybiBvfWZ1bmN0aW9uIEEoZSx0LG4pe3ZhciBpLHIsbz1cIlwiLGE9ZS50YWc7Zm9yKGk9MCxyPW4ubGVuZ3RoO2k8cjtpKz0xKWooZSx0LG5baV0sITEsITEpJiYoMCE9PWkmJihvKz1cIixcIisoZS5jb25kZW5zZUZsb3c/XCJcIjpcIiBcIikpLG8rPWUuZHVtcCk7ZS50YWc9YSxlLmR1bXA9XCJbXCIrbytcIl1cIn1mdW5jdGlvbiBiKGUsdCxuLGkpe3ZhciByLG8sYT1cIlwiLGM9ZS50YWc7Zm9yKHI9MCxvPW4ubGVuZ3RoO3I8bztyKz0xKWooZSx0KzEsbltyXSwhMCwhMCkmJihpJiYwPT09cnx8KGErPXMoZSx0KSksZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/YSs9XCItXCI6YSs9XCItIFwiLGErPWUuZHVtcCk7ZS50YWc9YyxlLmR1bXA9YXx8XCJbXVwifWZ1bmN0aW9uIHcoZSx0LG4pe3ZhciBpLHIsbyxhLHMsYz1cIlwiLHU9ZS50YWcsbD1PYmplY3Qua2V5cyhuKTtmb3IoaT0wLHI9bC5sZW5ndGg7aTxyO2krPTEpcz1lLmNvbmRlbnNlRmxvdz8nXCInOlwiXCIsMCE9PWkmJihzKz1cIiwgXCIpLGE9bltvPWxbaV1dLGooZSx0LG8sITEsITEpJiYoZS5kdW1wLmxlbmd0aD4xMDI0JiYocys9XCI/IFwiKSxzKz1lLmR1bXArKGUuY29uZGVuc2VGbG93PydcIic6XCJcIikrXCI6XCIrKGUuY29uZGVuc2VGbG93P1wiXCI6XCIgXCIpLGooZSx0LGEsITEsITEpJiYoYys9cys9ZS5kdW1wKSk7ZS50YWc9dSxlLmR1bXA9XCJ7XCIrYytcIn1cIn1mdW5jdGlvbiBDKGUsdCxuLGkpe3ZhciByLG8sYSxjLHUsbCxwPVwiXCIsZj1lLnRhZyxkPU9iamVjdC5rZXlzKG4pO2lmKCEwPT09ZS5zb3J0S2V5cylkLnNvcnQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc29ydEtleXMpZC5zb3J0KGUuc29ydEtleXMpO2Vsc2UgaWYoZS5zb3J0S2V5cyl0aHJvdyBuZXcgRihcInNvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb25cIik7Zm9yKHI9MCxvPWQubGVuZ3RoO3I8bztyKz0xKWw9XCJcIixpJiYwPT09cnx8KGwrPXMoZSx0KSksYz1uW2E9ZFtyXV0saihlLHQrMSxhLCEwLCEwLCEwKSYmKCh1PW51bGwhPT1lLnRhZyYmXCI/XCIhPT1lLnRhZ3x8ZS5kdW1wJiZlLmR1bXAubGVuZ3RoPjEwMjQpJiYoZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/bCs9XCI/XCI6bCs9XCI/IFwiKSxsKz1lLmR1bXAsdSYmKGwrPXMoZSx0KSksaihlLHQrMSxjLCEwLHUpJiYoZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/bCs9XCI6XCI6bCs9XCI6IFwiLHArPWwrPWUuZHVtcCkpO2UudGFnPWYsZS5kdW1wPXB8fFwie31cIn1mdW5jdGlvbiBrKGUsdCxuKXt2YXIgaSxyLG8sYSxzLGM7Zm9yKG89MCxhPShyPW4/ZS5leHBsaWNpdFR5cGVzOmUuaW1wbGljaXRUeXBlcykubGVuZ3RoO288YTtvKz0xKWlmKCgocz1yW29dKS5pbnN0YW5jZU9mfHxzLnByZWRpY2F0ZSkmJighcy5pbnN0YW5jZU9mfHxcIm9iamVjdFwiPT10eXBlb2YgdCYmdCBpbnN0YW5jZW9mIHMuaW5zdGFuY2VPZikmJighcy5wcmVkaWNhdGV8fHMucHJlZGljYXRlKHQpKSl7aWYoZS50YWc9bj9zLnRhZzpcIj9cIixzLnJlcHJlc2VudCl7aWYoYz1lLnN0eWxlTWFwW3MudGFnXXx8cy5kZWZhdWx0U3R5bGUsXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT09TS5jYWxsKHMucmVwcmVzZW50KSlpPXMucmVwcmVzZW50KHQsYyk7ZWxzZXtpZighVC5jYWxsKHMucmVwcmVzZW50LGMpKXRocm93IG5ldyBGKFwiITxcIitzLnRhZysnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInK2MrJ1wiIHN0eWxlJyk7aT1zLnJlcHJlc2VudFtjXSh0LGMpfWUuZHVtcD1pfXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGooZSx0LG4saSxyLG8pe2UudGFnPW51bGwsZS5kdW1wPW4sayhlLG4sITEpfHxrKGUsbiwhMCk7dmFyIGE9TS5jYWxsKGUuZHVtcCk7aSYmKGk9ZS5mbG93TGV2ZWw8MHx8ZS5mbG93TGV2ZWw+dCk7dmFyIHMsYyx1PVwiW29iamVjdCBPYmplY3RdXCI9PT1hfHxcIltvYmplY3QgQXJyYXldXCI9PT1hO2lmKHUmJihjPS0xIT09KHM9ZS5kdXBsaWNhdGVzLmluZGV4T2YobikpKSwobnVsbCE9PWUudGFnJiZcIj9cIiE9PWUudGFnfHxjfHwyIT09ZS5pbmRlbnQmJnQ+MCkmJihyPSExKSxjJiZlLnVzZWREdXBsaWNhdGVzW3NdKWUuZHVtcD1cIipyZWZfXCIrcztlbHNle2lmKHUmJmMmJiFlLnVzZWREdXBsaWNhdGVzW3NdJiYoZS51c2VkRHVwbGljYXRlc1tzXT0hMCksXCJbb2JqZWN0IE9iamVjdF1cIj09PWEpaSYmMCE9PU9iamVjdC5rZXlzKGUuZHVtcCkubGVuZ3RoPyhDKGUsdCxlLmR1bXAsciksYyYmKGUuZHVtcD1cIiZyZWZfXCIrcytlLmR1bXApKToodyhlLHQsZS5kdW1wKSxjJiYoZS5kdW1wPVwiJnJlZl9cIitzK1wiIFwiK2UuZHVtcCkpO2Vsc2UgaWYoXCJbb2JqZWN0IEFycmF5XVwiPT09YSlpJiYwIT09ZS5kdW1wLmxlbmd0aD8oYihlLHQsZS5kdW1wLHIpLGMmJihlLmR1bXA9XCImcmVmX1wiK3MrZS5kdW1wKSk6KEEoZSx0LGUuZHVtcCksYyYmKGUuZHVtcD1cIiZyZWZfXCIrcytcIiBcIitlLmR1bXApKTtlbHNle2lmKFwiW29iamVjdCBTdHJpbmddXCIhPT1hKXtpZihlLnNraXBJbnZhbGlkKXJldHVybiExO3Rocm93IG5ldyBGKFwidW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgXCIrYSl9XCI/XCIhPT1lLnRhZyYmaChlLGUuZHVtcCx0LG8pfW51bGwhPT1lLnRhZyYmXCI/XCIhPT1lLnRhZyYmKGUuZHVtcD1cIiE8XCIrZS50YWcrXCI+IFwiK2UuZHVtcCl9cmV0dXJuITB9ZnVuY3Rpb24gSShlLHQpe3ZhciBuLGkscj1bXSxvPVtdO2ZvcihTKGUscixvKSxuPTAsaT1vLmxlbmd0aDtuPGk7bis9MSl0LmR1cGxpY2F0ZXMucHVzaChyW29bbl1dKTt0LnVzZWREdXBsaWNhdGVzPW5ldyBBcnJheShpKX1mdW5jdGlvbiBTKGUsdCxuKXt2YXIgaSxyLG87aWYobnVsbCE9PWUmJlwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKC0xIT09KHI9dC5pbmRleE9mKGUpKSktMT09PW4uaW5kZXhPZihyKSYmbi5wdXNoKHIpO2Vsc2UgaWYodC5wdXNoKGUpLEFycmF5LmlzQXJyYXkoZSkpZm9yKHI9MCxvPWUubGVuZ3RoO3I8bztyKz0xKVMoZVtyXSx0LG4pO2Vsc2UgZm9yKHI9MCxvPShpPU9iamVjdC5rZXlzKGUpKS5sZW5ndGg7cjxvO3IrPTEpUyhlW2lbcl1dLHQsbil9ZnVuY3Rpb24gTyhlLHQpe3ZhciBuPW5ldyBvKHQ9dHx8e30pO3JldHVybiBuLm5vUmVmc3x8SShlLG4pLGoobiwwLGUsITAsITApP24uZHVtcCtcIlxcblwiOlwiXCJ9dmFyIEU9ZShcIi4vY29tbW9uXCIpLEY9ZShcIi4vZXhjZXB0aW9uXCIpLF89ZShcIi4vc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSxOPWUoXCIuL3NjaGVtYS9kZWZhdWx0X3NhZmVcIiksTT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxMPTksRD0xMCxVPTMyLHE9MzMsWT0zNCxSPTM1LFA9MzcsVz0zOCxCPTM5LEs9NDIsJD00NCxIPTQ1LEc9NTgsVj02MixaPTYzLHo9NjQsSj05MSxRPTkzLFg9OTYsZWU9MTIzLHRlPTEyNCxuZT0xMjUsaWU9e307aWVbMF09XCJcXFxcMFwiLGllWzddPVwiXFxcXGFcIixpZVs4XT1cIlxcXFxiXCIsaWVbOV09XCJcXFxcdFwiLGllWzEwXT1cIlxcXFxuXCIsaWVbMTFdPVwiXFxcXHZcIixpZVsxMl09XCJcXFxcZlwiLGllWzEzXT1cIlxcXFxyXCIsaWVbMjddPVwiXFxcXGVcIixpZVszNF09J1xcXFxcIicsaWVbOTJdPVwiXFxcXFxcXFxcIixpZVsxMzNdPVwiXFxcXE5cIixpZVsxNjBdPVwiXFxcXF9cIixpZVs4MjMyXT1cIlxcXFxMXCIsaWVbODIzM109XCJcXFxcUFwiO3ZhciByZT1bXCJ5XCIsXCJZXCIsXCJ5ZXNcIixcIlllc1wiLFwiWUVTXCIsXCJvblwiLFwiT25cIixcIk9OXCIsXCJuXCIsXCJOXCIsXCJub1wiLFwiTm9cIixcIk5PXCIsXCJvZmZcIixcIk9mZlwiLFwiT0ZGXCJdLG9lPTEsYWU9MixzZT0zLGNlPTQsdWU9NTt0LmV4cG9ydHMuZHVtcD1PLHQuZXhwb3J0cy5zYWZlRHVtcD1mdW5jdGlvbihlLHQpe3JldHVybiBPKGUsRS5leHRlbmQoe3NjaGVtYTpOfSx0KSl9fSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL3NjaGVtYS9kZWZhdWx0X2Z1bGxcIjo5LFwiLi9zY2hlbWEvZGVmYXVsdF9zYWZlXCI6MTB9XSw0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQpe0Vycm9yLmNhbGwodGhpcyksdGhpcy5uYW1lPVwiWUFNTEV4Y2VwdGlvblwiLHRoaXMucmVhc29uPWUsdGhpcy5tYXJrPXQsdGhpcy5tZXNzYWdlPSh0aGlzLnJlYXNvbnx8XCIodW5rbm93biByZWFzb24pXCIpKyh0aGlzLm1hcms/XCIgXCIrdGhpcy5tYXJrLnRvU3RyaW5nKCk6XCJcIiksRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0aGlzLmNvbnN0cnVjdG9yKTp0aGlzLnN0YWNrPShuZXcgRXJyb3IpLnN0YWNrfHxcIlwifShpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5uYW1lK1wiOiBcIjtyZXR1cm4gdCs9dGhpcy5yZWFzb258fFwiKHVua25vd24gcmVhc29uKVwiLCFlJiZ0aGlzLm1hcmsmJih0Kz1cIiBcIit0aGlzLm1hcmsudG9TdHJpbmcoKSksdH0sdC5leHBvcnRzPWl9LHt9XSw1OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXtyZXR1cm4gMTA9PT1lfHwxMz09PWV9ZnVuY3Rpb24gcihlKXtyZXR1cm4gOT09PWV8fDMyPT09ZX1mdW5jdGlvbiBvKGUpe3JldHVybiA5PT09ZXx8MzI9PT1lfHwxMD09PWV8fDEzPT09ZX1mdW5jdGlvbiBhKGUpe3JldHVybiA0ND09PWV8fDkxPT09ZXx8OTM9PT1lfHwxMjM9PT1lfHwxMjU9PT1lfWZ1bmN0aW9uIHMoZSl7dmFyIHQ7cmV0dXJuIDQ4PD1lJiZlPD01Nz9lLTQ4Ojk3PD0odD0zMnxlKSYmdDw9MTAyP3QtOTcrMTA6LTF9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gMTIwPT09ZT8yOjExNz09PWU/NDo4NT09PWU/ODowfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIDQ4PD1lJiZlPD01Nz9lLTQ4Oi0xfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIDQ4PT09ZT9cIlxcMFwiOjk3PT09ZT9cIlx1MDAwN1wiOjk4PT09ZT9cIlxcYlwiOjExNj09PWU/XCJcXHRcIjo5PT09ZT9cIlxcdFwiOjExMD09PWU/XCJcXG5cIjoxMTg9PT1lP1wiXFx2XCI6MTAyPT09ZT9cIlxcZlwiOjExND09PWU/XCJcXHJcIjoxMDE9PT1lP1wiXHUwMDFiXCI6MzI9PT1lP1wiIFwiOjM0PT09ZT8nXCInOjQ3PT09ZT9cIi9cIjo5Mj09PWU/XCJcXFxcXCI6Nzg9PT1lP1wiwoVcIjo5NT09PWU/XCLCoFwiOjc2PT09ZT9cIlxcdTIwMjhcIjo4MD09PWU/XCJcXHUyMDI5XCI6XCJcIn1mdW5jdGlvbiBwKGUpe3JldHVybiBlPD02NTUzNT9TdHJpbmcuZnJvbUNoYXJDb2RlKGUpOlN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGUtNjU1MzY+PjEwKSw1NjMyMCsoZS02NTUzNiYxMDIzKSl9ZnVuY3Rpb24gZihlLHQpe3RoaXMuaW5wdXQ9ZSx0aGlzLmZpbGVuYW1lPXQuZmlsZW5hbWV8fG51bGwsdGhpcy5zY2hlbWE9dC5zY2hlbWF8fFcsdGhpcy5vbldhcm5pbmc9dC5vbldhcm5pbmd8fG51bGwsdGhpcy5sZWdhY3k9dC5sZWdhY3l8fCExLHRoaXMuanNvbj10Lmpzb258fCExLHRoaXMubGlzdGVuZXI9dC5saXN0ZW5lcnx8bnVsbCx0aGlzLmltcGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdCx0aGlzLnR5cGVNYXA9dGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwLHRoaXMubGVuZ3RoPWUubGVuZ3RoLHRoaXMucG9zaXRpb249MCx0aGlzLmxpbmU9MCx0aGlzLmxpbmVTdGFydD0wLHRoaXMubGluZUluZGVudD0wLHRoaXMuZG9jdW1lbnRzPVtdfWZ1bmN0aW9uIGQoZSx0KXtyZXR1cm4gbmV3IFkodCxuZXcgUihlLmZpbGVuYW1lLGUuaW5wdXQsZS5wb3NpdGlvbixlLmxpbmUsZS5wb3NpdGlvbi1lLmxpbmVTdGFydCkpfWZ1bmN0aW9uIGgoZSx0KXt0aHJvdyBkKGUsdCl9ZnVuY3Rpb24gbShlLHQpe2Uub25XYXJuaW5nJiZlLm9uV2FybmluZy5jYWxsKG51bGwsZChlLHQpKX1mdW5jdGlvbiBnKGUsdCxuLGkpe3ZhciByLG8sYSxzO2lmKHQ8bil7aWYocz1lLmlucHV0LnNsaWNlKHQsbiksaSlmb3Iocj0wLG89cy5sZW5ndGg7cjxvO3IrPTEpOT09PShhPXMuY2hhckNvZGVBdChyKSl8fDMyPD1hJiZhPD0xMTE0MTExfHxoKGUsXCJleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlclwiKTtlbHNlIEoudGVzdChzKSYmaChlLFwidGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnNcIik7ZS5yZXN1bHQrPXN9fWZ1bmN0aW9uIHkoZSx0LG4saSl7dmFyIHIsbyxhLHM7Zm9yKHEuaXNPYmplY3Qobil8fGgoZSxcImNhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlXCIpLGE9MCxzPShyPU9iamVjdC5rZXlzKG4pKS5sZW5ndGg7YTxzO2ErPTEpbz1yW2FdLEIuY2FsbCh0LG8pfHwodFtvXT1uW29dLGlbb109ITApfWZ1bmN0aW9uIHgoZSx0LG4saSxyLG8sYSxzKXt2YXIgYyx1O2lmKHI9U3RyaW5nKHIpLG51bGw9PT10JiYodD17fSksXCJ0YWc6eWFtbC5vcmcsMjAwMjptZXJnZVwiPT09aSlpZihBcnJheS5pc0FycmF5KG8pKWZvcihjPTAsdT1vLmxlbmd0aDtjPHU7Yys9MSl5KGUsdCxvW2NdLG4pO2Vsc2UgeShlLHQsbyxuKTtlbHNlIGUuanNvbnx8Qi5jYWxsKG4scil8fCFCLmNhbGwodCxyKXx8KGUubGluZT1hfHxlLmxpbmUsZS5wb3NpdGlvbj1zfHxlLnBvc2l0aW9uLGgoZSxcImR1cGxpY2F0ZWQgbWFwcGluZyBrZXlcIikpLHRbcl09byxkZWxldGUgbltyXTtyZXR1cm4gdH1mdW5jdGlvbiB2KGUpe3ZhciB0OzEwPT09KHQ9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKT9lLnBvc2l0aW9uKys6MTM9PT10PyhlLnBvc2l0aW9uKyssMTA9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJmUucG9zaXRpb24rKyk6aChlLFwiYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkXCIpLGUubGluZSs9MSxlLmxpbmVTdGFydD1lLnBvc2l0aW9ufWZ1bmN0aW9uIEEoZSx0LG4pe2Zvcih2YXIgbz0wLGE9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pOzAhPT1hOyl7Zm9yKDtyKGEpOylhPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKHQmJjM1PT09YSlkb3thPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKDEwIT09YSYmMTMhPT1hJiYwIT09YSk7aWYoIWkoYSkpYnJlYWs7Zm9yKHYoZSksYT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksbysrLGUubGluZUluZGVudD0wOzMyPT09YTspZS5saW5lSW5kZW50KyssYT1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX1yZXR1cm4tMSE9PW4mJjAhPT1vJiZlLmxpbmVJbmRlbnQ8biYmbShlLFwiZGVmaWNpZW50IGluZGVudGF0aW9uXCIpLG99ZnVuY3Rpb24gYihlKXt2YXIgdCxuPWUucG9zaXRpb247cmV0dXJuISg0NSE9PSh0PWUuaW5wdXQuY2hhckNvZGVBdChuKSkmJjQ2IT09dHx8dCE9PWUuaW5wdXQuY2hhckNvZGVBdChuKzEpfHx0IT09ZS5pbnB1dC5jaGFyQ29kZUF0KG4rMil8fChuKz0zLDAhPT0odD1lLmlucHV0LmNoYXJDb2RlQXQobikpJiYhbyh0KSkpfWZ1bmN0aW9uIHcoZSx0KXsxPT09dD9lLnJlc3VsdCs9XCIgXCI6dD4xJiYoZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsdC0xKSl9ZnVuY3Rpb24gQyhlLHQsbil7dmFyIHMsYyx1LGwscCxmLGQsaCxtLHk9ZS5raW5kLHg9ZS5yZXN1bHQ7aWYobT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksbyhtKXx8YShtKXx8MzU9PT1tfHwzOD09PW18fDQyPT09bXx8MzM9PT1tfHwxMjQ9PT1tfHw2Mj09PW18fDM5PT09bXx8MzQ9PT1tfHwzNz09PW18fDY0PT09bXx8OTY9PT1tKXJldHVybiExO2lmKCg2Mz09PW18fDQ1PT09bSkmJihjPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKzEpLG8oYyl8fG4mJmEoYykpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLHU9bD1lLnBvc2l0aW9uLHA9ITE7MCE9PW07KXtpZig1OD09PW0pe2lmKGM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSksbyhjKXx8biYmYShjKSlicmVha31lbHNlIGlmKDM1PT09bSl7aWYocz1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbi0xKSxvKHMpKWJyZWFrfWVsc2V7aWYoZS5wb3NpdGlvbj09PWUubGluZVN0YXJ0JiZiKGUpfHxuJiZhKG0pKWJyZWFrO2lmKGkobSkpe2lmKGY9ZS5saW5lLGQ9ZS5saW5lU3RhcnQsaD1lLmxpbmVJbmRlbnQsQShlLCExLC0xKSxlLmxpbmVJbmRlbnQ+PXQpe3A9ITAsbT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbik7Y29udGludWV9ZS5wb3NpdGlvbj1sLGUubGluZT1mLGUubGluZVN0YXJ0PWQsZS5saW5lSW5kZW50PWg7YnJlYWt9fXAmJihnKGUsdSxsLCExKSx3KGUsZS5saW5lLWYpLHU9bD1lLnBvc2l0aW9uLHA9ITEpLHIobSl8fChsPWUucG9zaXRpb24rMSksbT1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX1yZXR1cm4gZyhlLHUsbCwhMSksISFlLnJlc3VsdHx8KGUua2luZD15LGUucmVzdWx0PXgsITEpfWZ1bmN0aW9uIGsoZSx0KXt2YXIgbixyLG87aWYoMzkhPT0obj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLGUucG9zaXRpb24rKyxyPW89ZS5wb3NpdGlvbjswIT09KG49ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKTspaWYoMzk9PT1uKXtpZihnKGUscixlLnBvc2l0aW9uLCEwKSwzOSE9PShuPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pKSlyZXR1cm4hMDtyPWUucG9zaXRpb24sZS5wb3NpdGlvbisrLG89ZS5wb3NpdGlvbn1lbHNlIGkobik/KGcoZSxyLG8sITApLHcoZSxBKGUsITEsdCkpLHI9bz1lLnBvc2l0aW9uKTplLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyXCIpOihlLnBvc2l0aW9uKyssbz1lLnBvc2l0aW9uKTtoKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyXCIpfWZ1bmN0aW9uIGooZSx0KXt2YXIgbixyLG8sYSx1LGw7aWYoMzQhPT0obD1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLGUucG9zaXRpb24rKyxuPXI9ZS5wb3NpdGlvbjswIT09KGw9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKTspe2lmKDM0PT09bClyZXR1cm4gZyhlLG4sZS5wb3NpdGlvbiwhMCksZS5wb3NpdGlvbisrLCEwO2lmKDkyPT09bCl7aWYoZyhlLG4sZS5wb3NpdGlvbiwhMCksbD1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSxpKGwpKUEoZSwhMSx0KTtlbHNlIGlmKGw8MjU2JiZuZVtsXSllLnJlc3VsdCs9aWVbbF0sZS5wb3NpdGlvbisrO2Vsc2UgaWYoKHU9YyhsKSk+MCl7Zm9yKG89dSxhPTA7bz4wO28tLSkodT1zKGw9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpKT49MD9hPShhPDw0KSt1OmgoZSxcImV4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlclwiKTtlLnJlc3VsdCs9cChhKSxlLnBvc2l0aW9uKyt9ZWxzZSBoKGUsXCJ1bmtub3duIGVzY2FwZSBzZXF1ZW5jZVwiKTtuPXI9ZS5wb3NpdGlvbn1lbHNlIGkobCk/KGcoZSxuLHIsITApLHcoZSxBKGUsITEsdCkpLG49cj1lLnBvc2l0aW9uKTplLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyXCIpOihlLnBvc2l0aW9uKysscj1lLnBvc2l0aW9uKX1oKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyXCIpfWZ1bmN0aW9uIEkoZSx0KXt2YXIgbixpLHIsYSxzLGMsdSxsLHAsZixkPSEwLG09ZS50YWcsZz1lLmFuY2hvcix5PXt9O2lmKDkxPT09KGY9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSlyPTkzLGM9ITEsaT1bXTtlbHNle2lmKDEyMyE9PWYpcmV0dXJuITE7cj0xMjUsYz0hMCxpPXt9fWZvcihudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09aSksZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKTswIT09Zjspe2lmKEEoZSwhMCx0KSwoZj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpPT09cilyZXR1cm4gZS5wb3NpdGlvbisrLGUudGFnPW0sZS5hbmNob3I9ZyxlLmtpbmQ9Yz9cIm1hcHBpbmdcIjpcInNlcXVlbmNlXCIsZS5yZXN1bHQ9aSwhMDtkfHxoKGUsXCJtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllc1wiKSxsPXU9cD1udWxsLGE9cz0hMSw2Mz09PWYmJm8oZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkpJiYoYT1zPSEwLGUucG9zaXRpb24rKyxBKGUsITAsdCkpLG49ZS5saW5lLE0oZSx0LEssITEsITApLGw9ZS50YWcsdT1lLnJlc3VsdCxBKGUsITAsdCksZj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksIXMmJmUubGluZSE9PW58fDU4IT09Znx8KGE9ITAsZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSxBKGUsITAsdCksTShlLHQsSywhMSwhMCkscD1lLnJlc3VsdCksYz94KGUsaSx5LGwsdSxwKTphP2kucHVzaCh4KGUsbnVsbCx5LGwsdSxwKSk6aS5wdXNoKHUpLEEoZSwhMCx0KSw0ND09PShmPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKSk/KGQ9ITAsZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6ZD0hMX1oKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvblwiKX1mdW5jdGlvbiBTKGUsdCl7dmFyIG4sbyxhLHMsYz1WLGw9ITEscD0hMSxmPXQsZD0wLG09ITE7aWYoMTI0PT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSlvPSExO2Vsc2V7aWYoNjIhPT1zKXJldHVybiExO289ITB9Zm9yKGUua2luZD1cInNjYWxhclwiLGUucmVzdWx0PVwiXCI7MCE9PXM7KWlmKDQzPT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpfHw0NT09PXMpVj09PWM/Yz00Mz09PXM/ejpaOmgoZSxcInJlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllclwiKTtlbHNle2lmKCEoKGE9dShzKSk+PTApKWJyZWFrOzA9PT1hP2goZSxcImJhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmVcIik6cD9oKGUsXCJyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllclwiKTooZj10K2EtMSxwPSEwKX1pZihyKHMpKXtkb3tzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKHIocykpO2lmKDM1PT09cylkb3tzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKCFpKHMpJiYwIT09cyl9Zm9yKDswIT09czspe2Zvcih2KGUpLGUubGluZUluZGVudD0wLHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pOyghcHx8ZS5saW5lSW5kZW50PGYpJiYzMj09PXM7KWUubGluZUluZGVudCsrLHM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7aWYoIXAmJmUubGluZUluZGVudD5mJiYoZj1lLmxpbmVJbmRlbnQpLGkocykpZCsrO2Vsc2V7aWYoZS5saW5lSW5kZW50PGYpe2M9PT16P2UucmVzdWx0Kz1xLnJlcGVhdChcIlxcblwiLGw/MStkOmQpOmM9PT1WJiZsJiYoZS5yZXN1bHQrPVwiXFxuXCIpO2JyZWFrfWZvcihvP3Iocyk/KG09ITAsZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsbD8xK2Q6ZCkpOm0/KG09ITEsZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsZCsxKSk6MD09PWQ/bCYmKGUucmVzdWx0Kz1cIiBcIik6ZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsZCk6ZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsbD8xK2Q6ZCksbD0hMCxwPSEwLGQ9MCxuPWUucG9zaXRpb247IWkocykmJjAhPT1zOylzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2coZSxuLGUucG9zaXRpb24sITEpfX1yZXR1cm4hMH1mdW5jdGlvbiBPKGUsdCl7dmFyIG4saSxyLGE9ZS50YWcscz1lLmFuY2hvcixjPVtdLHU9ITE7Zm9yKG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1jKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTswIT09ciYmNDU9PT1yJiYoaT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbisxKSxvKGkpKTspaWYodT0hMCxlLnBvc2l0aW9uKyssQShlLCEwLC0xKSYmZS5saW5lSW5kZW50PD10KWMucHVzaChudWxsKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTtlbHNlIGlmKG49ZS5saW5lLE0oZSx0LEgsITEsITApLGMucHVzaChlLnJlc3VsdCksQShlLCEwLC0xKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKSwoZS5saW5lPT09bnx8ZS5saW5lSW5kZW50PnQpJiYwIT09ciloKGUsXCJiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeVwiKTtlbHNlIGlmKGUubGluZUluZGVudDx0KWJyZWFrO3JldHVybiEhdSYmKGUudGFnPWEsZS5hbmNob3I9cyxlLmtpbmQ9XCJzZXF1ZW5jZVwiLGUucmVzdWx0PWMsITApfWZ1bmN0aW9uIEUoZSx0LG4pe3ZhciBpLGEscyxjLHUsbD1lLnRhZyxwPWUuYW5jaG9yLGY9e30sZD17fSxtPW51bGwsZz1udWxsLHk9bnVsbCx2PSExLGI9ITE7Zm9yKG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1mKSx1PWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTswIT09dTspe2lmKGk9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkscz1lLmxpbmUsYz1lLnBvc2l0aW9uLDYzIT09dSYmNTghPT11fHwhbyhpKSl7aWYoIU0oZSxuLCQsITEsITApKWJyZWFrO2lmKGUubGluZT09PXMpe2Zvcih1PWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTtyKHUpOyl1PWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKDU4PT09dSlvKHU9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpfHxoKGUsXCJhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmdcIiksdiYmKHgoZSxmLGQsbSxnLG51bGwpLG09Zz15PW51bGwpLGI9ITAsdj0hMSxhPSExLG09ZS50YWcsZz1lLnJlc3VsdDtlbHNle2lmKCFiKXJldHVybiBlLnRhZz1sLGUuYW5jaG9yPXAsITA7aChlLFwiY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWRcIil9fWVsc2V7aWYoIWIpcmV0dXJuIGUudGFnPWwsZS5hbmNob3I9cCwhMDtoKGUsXCJjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXlcIil9fWVsc2UgNjM9PT11Pyh2JiYoeChlLGYsZCxtLGcsbnVsbCksbT1nPXk9bnVsbCksYj0hMCx2PSEwLGE9ITApOnY/KHY9ITEsYT0hMCk6aChlLFwiaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkOyBvciBmb2xsb3dlZCBieSBhIG5vbi10YWJ1bGF0ZWQgZW1wdHkgbGluZVwiKSxlLnBvc2l0aW9uKz0xLHU9aTtpZigoZS5saW5lPT09c3x8ZS5saW5lSW5kZW50PnQpJiYoTShlLHQsRywhMCxhKSYmKHY/Zz1lLnJlc3VsdDp5PWUucmVzdWx0KSx2fHwoeChlLGYsZCxtLGcseSxzLGMpLG09Zz15PW51bGwpLEEoZSwhMCwtMSksdT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpLGUubGluZUluZGVudD50JiYwIT09dSloKGUsXCJiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5XCIpO2Vsc2UgaWYoZS5saW5lSW5kZW50PHQpYnJlYWt9cmV0dXJuIHYmJngoZSxmLGQsbSxnLG51bGwpLGImJihlLnRhZz1sLGUuYW5jaG9yPXAsZS5raW5kPVwibWFwcGluZ1wiLGUucmVzdWx0PWYpLGJ9ZnVuY3Rpb24gRihlKXt2YXIgdCxuLGkscixhPSExLHM9ITE7aWYoMzMhPT0ocj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2lmKG51bGwhPT1lLnRhZyYmaChlLFwiZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHlcIiksNjA9PT0ocj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk/KGE9ITAscj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6MzM9PT1yPyhzPSEwLG49XCIhIVwiLHI9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpOm49XCIhXCIsdD1lLnBvc2l0aW9uLGEpe2Rve3I9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbil9d2hpbGUoMCE9PXImJjYyIT09cik7ZS5wb3NpdGlvbjxlLmxlbmd0aD8oaT1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbikscj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWdcIil9ZWxzZXtmb3IoOzAhPT1yJiYhbyhyKTspMzM9PT1yJiYocz9oKGUsXCJ0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzXCIpOihuPWUuaW5wdXQuc2xpY2UodC0xLGUucG9zaXRpb24rMSksZWUudGVzdChuKXx8aChlLFwibmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnNcIikscz0hMCx0PWUucG9zaXRpb24rMSkpLHI9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7aT1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbiksWC50ZXN0KGkpJiZoKGUsXCJ0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnNcIil9cmV0dXJuIGkmJiF0ZS50ZXN0KGkpJiZoKGUsXCJ0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6IFwiK2kpLGE/ZS50YWc9aTpCLmNhbGwoZS50YWdNYXAsbik/ZS50YWc9ZS50YWdNYXBbbl0raTpcIiFcIj09PW4/ZS50YWc9XCIhXCIraTpcIiEhXCI9PT1uP2UudGFnPVwidGFnOnlhbWwub3JnLDIwMDI6XCIraTpoKGUsJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicrbisnXCInKSwhMH1mdW5jdGlvbiBfKGUpe3ZhciB0LG47aWYoMzghPT0obj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihudWxsIT09ZS5hbmNob3ImJmgoZSxcImR1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eVwiKSxuPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09biYmIW8obikmJiFhKG4pOyluPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO3JldHVybiBlLnBvc2l0aW9uPT09dCYmaChlLFwibmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlclwiKSxlLmFuY2hvcj1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbiksITB9ZnVuY3Rpb24gTihlKXt2YXIgdCxuLGk7aWYoNDIhPT0oaT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihpPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09aSYmIW8oaSkmJiFhKGkpOylpPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO3JldHVybiBlLnBvc2l0aW9uPT09dCYmaChlLFwibmFtZSBvZiBhbiBhbGlhcyBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyXCIpLG49ZS5pbnB1dC5zbGljZSh0LGUucG9zaXRpb24pLGUuYW5jaG9yTWFwLmhhc093blByb3BlcnR5KG4pfHxoKGUsJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicrbisnXCInKSxlLnJlc3VsdD1lLmFuY2hvck1hcFtuXSxBKGUsITAsLTEpLCEwfWZ1bmN0aW9uIE0oZSx0LG4saSxyKXt2YXIgbyxhLHMsYyx1LGwscCxmLGQ9MSxtPSExLGc9ITE7aWYobnVsbCE9PWUubGlzdGVuZXImJmUubGlzdGVuZXIoXCJvcGVuXCIsZSksZS50YWc9bnVsbCxlLmFuY2hvcj1udWxsLGUua2luZD1udWxsLGUucmVzdWx0PW51bGwsbz1hPXM9Rz09PW58fEg9PT1uLGkmJkEoZSwhMCwtMSkmJihtPSEwLGUubGluZUluZGVudD50P2Q9MTplLmxpbmVJbmRlbnQ9PT10P2Q9MDplLmxpbmVJbmRlbnQ8dCYmKGQ9LTEpKSwxPT09ZClmb3IoO0YoZSl8fF8oZSk7KUEoZSwhMCwtMSk/KG09ITAscz1vLGUubGluZUluZGVudD50P2Q9MTplLmxpbmVJbmRlbnQ9PT10P2Q9MDplLmxpbmVJbmRlbnQ8dCYmKGQ9LTEpKTpzPSExO2lmKHMmJihzPW18fHIpLDEhPT1kJiZHIT09bnx8KHA9Sz09PW58fCQ9PT1uP3Q6dCsxLGY9ZS5wb3NpdGlvbi1lLmxpbmVTdGFydCwxPT09ZD9zJiYoTyhlLGYpfHxFKGUsZixwKSl8fEkoZSxwKT9nPSEwOihhJiZTKGUscCl8fGsoZSxwKXx8aihlLHApP2c9ITA6TihlKT8oZz0hMCxudWxsPT09ZS50YWcmJm51bGw9PT1lLmFuY2hvcnx8aChlLFwiYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXNcIikpOkMoZSxwLEs9PT1uKSYmKGc9ITAsbnVsbD09PWUudGFnJiYoZS50YWc9XCI/XCIpKSxudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09ZS5yZXN1bHQpKTowPT09ZCYmKGc9cyYmTyhlLGYpKSksbnVsbCE9PWUudGFnJiZcIiFcIiE9PWUudGFnKWlmKFwiP1wiPT09ZS50YWcpe2ZvcihjPTAsdT1lLmltcGxpY2l0VHlwZXMubGVuZ3RoO2M8dTtjKz0xKWlmKChsPWUuaW1wbGljaXRUeXBlc1tjXSkucmVzb2x2ZShlLnJlc3VsdCkpe2UucmVzdWx0PWwuY29uc3RydWN0KGUucmVzdWx0KSxlLnRhZz1sLnRhZyxudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09ZS5yZXN1bHQpO2JyZWFrfX1lbHNlIEIuY2FsbChlLnR5cGVNYXBbZS5raW5kfHxcImZhbGxiYWNrXCJdLGUudGFnKT8obD1lLnR5cGVNYXBbZS5raW5kfHxcImZhbGxiYWNrXCJdW2UudGFnXSxudWxsIT09ZS5yZXN1bHQmJmwua2luZCE9PWUua2luZCYmaChlLFwidW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITxcIitlLnRhZysnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicrbC5raW5kKydcIiwgbm90IFwiJytlLmtpbmQrJ1wiJyksbC5yZXNvbHZlKGUucmVzdWx0KT8oZS5yZXN1bHQ9bC5jb25zdHJ1Y3QoZS5yZXN1bHQpLG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1lLnJlc3VsdCkpOmgoZSxcImNhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8XCIrZS50YWcrXCI+IGV4cGxpY2l0IHRhZ1wiKSk6aChlLFwidW5rbm93biB0YWcgITxcIitlLnRhZytcIj5cIik7cmV0dXJuIG51bGwhPT1lLmxpc3RlbmVyJiZlLmxpc3RlbmVyKFwiY2xvc2VcIixlKSxudWxsIT09ZS50YWd8fG51bGwhPT1lLmFuY2hvcnx8Z31mdW5jdGlvbiBUKGUpe3ZhciB0LG4sYSxzLGM9ZS5wb3NpdGlvbix1PSExO2ZvcihlLnZlcnNpb249bnVsbCxlLmNoZWNrTGluZUJyZWFrcz1lLmxlZ2FjeSxlLnRhZ01hcD17fSxlLmFuY2hvck1hcD17fTswIT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSYmKEEoZSwhMCwtMSkscz1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksIShlLmxpbmVJbmRlbnQ+MHx8MzchPT1zKSk7KXtmb3IodT0hMCxzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09cyYmIW8ocyk7KXM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7Zm9yKGE9W10sKG49ZS5pbnB1dC5zbGljZSh0LGUucG9zaXRpb24pKS5sZW5ndGg8MSYmaChlLFwiZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoXCIpOzAhPT1zOyl7Zm9yKDtyKHMpOylzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKDM1PT09cyl7ZG97cz1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX13aGlsZSgwIT09cyYmIWkocykpO2JyZWFrfWlmKGkocykpYnJlYWs7Zm9yKHQ9ZS5wb3NpdGlvbjswIT09cyYmIW8ocyk7KXM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7YS5wdXNoKGUuaW5wdXQuc2xpY2UodCxlLnBvc2l0aW9uKSl9MCE9PXMmJnYoZSksQi5jYWxsKG9lLG4pP29lW25dKGUsbixhKTptKGUsJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJytuKydcIicpfUEoZSwhMCwtMSksMD09PWUubGluZUluZGVudCYmNDU9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJjQ1PT09ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkmJjQ1PT09ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMik/KGUucG9zaXRpb24rPTMsQShlLCEwLC0xKSk6dSYmaChlLFwiZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZFwiKSxNKGUsZS5saW5lSW5kZW50LTEsRywhMSwhMCksQShlLCEwLC0xKSxlLmNoZWNrTGluZUJyZWFrcyYmUS50ZXN0KGUuaW5wdXQuc2xpY2UoYyxlLnBvc2l0aW9uKSkmJm0oZSxcIm5vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudFwiKSxlLmRvY3VtZW50cy5wdXNoKGUucmVzdWx0KSxlLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/NDY9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJihlLnBvc2l0aW9uKz0zLEEoZSwhMCwtMSkpOmUucG9zaXRpb248ZS5sZW5ndGgtMSYmaChlLFwiZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWRcIil9ZnVuY3Rpb24gTChlLHQpe2U9U3RyaW5nKGUpLHQ9dHx8e30sMCE9PWUubGVuZ3RoJiYoMTAhPT1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSkmJjEzIT09ZS5jaGFyQ29kZUF0KGUubGVuZ3RoLTEpJiYoZSs9XCJcXG5cIiksNjUyNzk9PT1lLmNoYXJDb2RlQXQoMCkmJihlPWUuc2xpY2UoMSkpKTt2YXIgbj1uZXcgZihlLHQpO2ZvcihuLmlucHV0Kz1cIlxcMFwiOzMyPT09bi5pbnB1dC5jaGFyQ29kZUF0KG4ucG9zaXRpb24pOyluLmxpbmVJbmRlbnQrPTEsbi5wb3NpdGlvbis9MTtmb3IoO24ucG9zaXRpb248bi5sZW5ndGgtMTspVChuKTtyZXR1cm4gbi5kb2N1bWVudHN9ZnVuY3Rpb24gRChlLHQsbil7dmFyIGkscixvPUwoZSxuKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBvO2ZvcihpPTAscj1vLmxlbmd0aDtpPHI7aSs9MSl0KG9baV0pfWZ1bmN0aW9uIFUoZSx0KXt2YXIgbj1MKGUsdCk7aWYoMCE9PW4ubGVuZ3RoKXtpZigxPT09bi5sZW5ndGgpcmV0dXJuIG5bMF07dGhyb3cgbmV3IFkoXCJleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZVwiKX19Zm9yKHZhciBxPWUoXCIuL2NvbW1vblwiKSxZPWUoXCIuL2V4Y2VwdGlvblwiKSxSPWUoXCIuL21hcmtcIiksUD1lKFwiLi9zY2hlbWEvZGVmYXVsdF9zYWZlXCIpLFc9ZShcIi4vc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSxCPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksSz0xLCQ9MixIPTMsRz00LFY9MSxaPTIsej0zLEo9L1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vLFE9L1tcXHg4NVxcdTIwMjhcXHUyMDI5XS8sWD0vWyxcXFtcXF1cXHtcXH1dLyxlZT0vXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pLHRlPS9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2ksbmU9bmV3IEFycmF5KDI1NiksaWU9bmV3IEFycmF5KDI1NikscmU9MDtyZTwyNTY7cmUrKyluZVtyZV09bChyZSk/MTowLGllW3JlXT1sKHJlKTt2YXIgb2U9e1lBTUw6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpLHIsbztudWxsIT09ZS52ZXJzaW9uJiZoKGUsXCJkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmVcIiksMSE9PW4ubGVuZ3RoJiZoKGUsXCJZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIpLG51bGw9PT0oaT0vXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKG5bMF0pKSYmaChlLFwiaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmVcIikscj1wYXJzZUludChpWzFdLDEwKSxvPXBhcnNlSW50KGlbMl0sMTApLDEhPT1yJiZoKGUsXCJ1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudFwiKSxlLnZlcnNpb249blswXSxlLmNoZWNrTGluZUJyZWFrcz1vPDIsMSE9PW8mJjIhPT1vJiZtKGUsXCJ1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50XCIpfSxUQUc6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpLHI7MiE9PW4ubGVuZ3RoJiZoKGUsXCJUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzXCIpLGk9blswXSxyPW5bMV0sZWUudGVzdChpKXx8aChlLFwiaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmVcIiksQi5jYWxsKGUudGFnTWFwLGkpJiZoKGUsJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJytpKydcIiB0YWcgaGFuZGxlJyksdGUudGVzdChyKXx8aChlLFwiaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlXCIpLGUudGFnTWFwW2ldPXJ9fTt0LmV4cG9ydHMubG9hZEFsbD1ELHQuZXhwb3J0cy5sb2FkPVUsdC5leHBvcnRzLnNhZmVMb2FkQWxsPWZ1bmN0aW9uKGUsdCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBEKGUscS5leHRlbmQoe3NjaGVtYTpQfSxuKSk7RChlLHQscS5leHRlbmQoe3NjaGVtYTpQfSxuKSl9LHQuZXhwb3J0cy5zYWZlTG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBVKGUscS5leHRlbmQoe3NjaGVtYTpQfSx0KSl9fSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL21hcmtcIjo2LFwiLi9zY2hlbWEvZGVmYXVsdF9mdWxsXCI6OSxcIi4vc2NoZW1hL2RlZmF1bHRfc2FmZVwiOjEwfV0sNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0LG4saSxyKXt0aGlzLm5hbWU9ZSx0aGlzLmJ1ZmZlcj10LHRoaXMucG9zaXRpb249bix0aGlzLmxpbmU9aSx0aGlzLmNvbHVtbj1yfXZhciByPWUoXCIuL2NvbW1vblwiKTtpLnByb3RvdHlwZS5nZXRTbmlwcGV0PWZ1bmN0aW9uKGUsdCl7dmFyIG4saSxvLGEscztpZighdGhpcy5idWZmZXIpcmV0dXJuIG51bGw7Zm9yKGU9ZXx8NCx0PXR8fDc1LG49XCJcIixpPXRoaXMucG9zaXRpb247aT4wJiYtMT09PVwiXFwwXFxyXFxuwoVcXHUyMDI4XFx1MjAyOVwiLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGktMSkpOylpZihpLT0xLHRoaXMucG9zaXRpb24taT50LzItMSl7bj1cIiAuLi4gXCIsaSs9NTticmVha31mb3Iobz1cIlwiLGE9dGhpcy5wb3NpdGlvbjthPHRoaXMuYnVmZmVyLmxlbmd0aCYmLTE9PT1cIlxcMFxcclxcbsKFXFx1MjAyOFxcdTIwMjlcIi5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChhKSk7KWlmKChhKz0xKS10aGlzLnBvc2l0aW9uPnQvMi0xKXtvPVwiIC4uLiBcIixhLT01O2JyZWFrfXJldHVybiBzPXRoaXMuYnVmZmVyLnNsaWNlKGksYSksci5yZXBlYXQoXCIgXCIsZSkrbitzK28rXCJcXG5cIityLnJlcGVhdChcIiBcIixlK3RoaXMucG9zaXRpb24taStuLmxlbmd0aCkrXCJeXCJ9LGkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0LG49XCJcIjtyZXR1cm4gdGhpcy5uYW1lJiYobis9J2luIFwiJyt0aGlzLm5hbWUrJ1wiICcpLG4rPVwiYXQgbGluZSBcIisodGhpcy5saW5lKzEpK1wiLCBjb2x1bW4gXCIrKHRoaXMuY29sdW1uKzEpLGV8fCh0PXRoaXMuZ2V0U25pcHBldCgpKSYmKG4rPVwiOlxcblwiK3QpLG59LHQuZXhwb3J0cz1pfSx7XCIuL2NvbW1vblwiOjJ9XSw3OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQsbil7dmFyIHI9W107cmV0dXJuIGUuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe249aShlLHQsbil9KSxlW3RdLmZvckVhY2goZnVuY3Rpb24oZSl7bi5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7dC50YWc9PT1lLnRhZyYmdC5raW5kPT09ZS5raW5kJiZyLnB1c2gobil9KSxuLnB1c2goZSl9KSxuLmZpbHRlcihmdW5jdGlvbihlLHQpe3JldHVybi0xPT09ci5pbmRleE9mKHQpfSl9ZnVuY3Rpb24gcigpe3ZhciBlLHQsbj17c2NhbGFyOnt9LHNlcXVlbmNlOnt9LG1hcHBpbmc6e30sZmFsbGJhY2s6e319O2ZvcihlPTAsdD1hcmd1bWVudHMubGVuZ3RoO2U8dDtlKz0xKWFyZ3VtZW50c1tlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe25bZS5raW5kXVtlLnRhZ109bi5mYWxsYmFja1tlLnRhZ109ZX0pO3JldHVybiBufWZ1bmN0aW9uIG8oZSl7dGhpcy5pbmNsdWRlPWUuaW5jbHVkZXx8W10sdGhpcy5pbXBsaWNpdD1lLmltcGxpY2l0fHxbXSx0aGlzLmV4cGxpY2l0PWUuZXhwbGljaXR8fFtdLHRoaXMuaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbihlKXtpZihlLmxvYWRLaW5kJiZcInNjYWxhclwiIT09ZS5sb2FkS2luZCl0aHJvdyBuZXcgcyhcIlRoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKX0pLHRoaXMuY29tcGlsZWRJbXBsaWNpdD1pKHRoaXMsXCJpbXBsaWNpdFwiLFtdKSx0aGlzLmNvbXBpbGVkRXhwbGljaXQ9aSh0aGlzLFwiZXhwbGljaXRcIixbXSksdGhpcy5jb21waWxlZFR5cGVNYXA9cih0aGlzLmNvbXBpbGVkSW1wbGljaXQsdGhpcy5jb21waWxlZEV4cGxpY2l0KX12YXIgYT1lKFwiLi9jb21tb25cIikscz1lKFwiLi9leGNlcHRpb25cIiksYz1lKFwiLi90eXBlXCIpO28uREVGQVVMVD1udWxsLG8uY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGUsdDtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAxOmU9by5ERUZBVUxULHQ9YXJndW1lbnRzWzBdO2JyZWFrO2Nhc2UgMjplPWFyZ3VtZW50c1swXSx0PWFyZ3VtZW50c1sxXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvblwiKX1pZihlPWEudG9BcnJheShlKSx0PWEudG9BcnJheSh0KSwhZS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIG99KSl0aHJvdyBuZXcgcyhcIlNwZWNpZmllZCBsaXN0IG9mIHN1cGVyIHNjaGVtYXMgKG9yIGEgc2luZ2xlIFNjaGVtYSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVNjaGVtYSBvYmplY3QuXCIpO2lmKCF0LmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgY30pKXRocm93IG5ldyBzKFwiU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LlwiKTtyZXR1cm4gbmV3IG8oe2luY2x1ZGU6ZSxleHBsaWNpdDp0fSl9LHQuZXhwb3J0cz1vfSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL3R5cGVcIjoxM31dLDg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vc2NoZW1hXCIpO3QuZXhwb3J0cz1uZXcgaSh7aW5jbHVkZTpbZShcIi4vanNvblwiKV19KX0se1wiLi4vc2NoZW1hXCI6NyxcIi4vanNvblwiOjEyfV0sOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPWkuREVGQVVMVD1uZXcgaSh7aW5jbHVkZTpbZShcIi4vZGVmYXVsdF9zYWZlXCIpXSxleHBsaWNpdDpbZShcIi4uL3R5cGUvanMvdW5kZWZpbmVkXCIpLGUoXCIuLi90eXBlL2pzL3JlZ2V4cFwiKSxlKFwiLi4vdHlwZS9qcy9mdW5jdGlvblwiKV19KX0se1wiLi4vc2NoZW1hXCI6NyxcIi4uL3R5cGUvanMvZnVuY3Rpb25cIjoxOCxcIi4uL3R5cGUvanMvcmVnZXhwXCI6MTksXCIuLi90eXBlL2pzL3VuZGVmaW5lZFwiOjIwLFwiLi9kZWZhdWx0X3NhZmVcIjoxMH1dLDEwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3NjaGVtYVwiKTt0LmV4cG9ydHM9bmV3IGkoe2luY2x1ZGU6W2UoXCIuL2NvcmVcIildLGltcGxpY2l0OltlKFwiLi4vdHlwZS90aW1lc3RhbXBcIiksZShcIi4uL3R5cGUvbWVyZ2VcIildLGV4cGxpY2l0OltlKFwiLi4vdHlwZS9iaW5hcnlcIiksZShcIi4uL3R5cGUvb21hcFwiKSxlKFwiLi4vdHlwZS9wYWlyc1wiKSxlKFwiLi4vdHlwZS9zZXRcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL2JpbmFyeVwiOjE0LFwiLi4vdHlwZS9tZXJnZVwiOjIyLFwiLi4vdHlwZS9vbWFwXCI6MjQsXCIuLi90eXBlL3BhaXJzXCI6MjUsXCIuLi90eXBlL3NldFwiOjI3LFwiLi4vdHlwZS90aW1lc3RhbXBcIjoyOSxcIi4vY29yZVwiOjh9XSwxMTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPW5ldyBpKHtleHBsaWNpdDpbZShcIi4uL3R5cGUvc3RyXCIpLGUoXCIuLi90eXBlL3NlcVwiKSxlKFwiLi4vdHlwZS9tYXBcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL21hcFwiOjIxLFwiLi4vdHlwZS9zZXFcIjoyNixcIi4uL3R5cGUvc3RyXCI6Mjh9XSwxMjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPW5ldyBpKHtpbmNsdWRlOltlKFwiLi9mYWlsc2FmZVwiKV0saW1wbGljaXQ6W2UoXCIuLi90eXBlL251bGxcIiksZShcIi4uL3R5cGUvYm9vbFwiKSxlKFwiLi4vdHlwZS9pbnRcIiksZShcIi4uL3R5cGUvZmxvYXRcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL2Jvb2xcIjoxNSxcIi4uL3R5cGUvZmxvYXRcIjoxNixcIi4uL3R5cGUvaW50XCI6MTcsXCIuLi90eXBlL251bGxcIjoyMyxcIi4vZmFpbHNhZmVcIjoxMX1dLDEzOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXt2YXIgdD17fTtyZXR1cm4gbnVsbCE9PWUmJk9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24obil7ZVtuXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbU3RyaW5nKGUpXT1ufSl9KSx0fXZhciByPWUoXCIuL2V4Y2VwdGlvblwiKSxvPVtcImtpbmRcIixcInJlc29sdmVcIixcImNvbnN0cnVjdFwiLFwiaW5zdGFuY2VPZlwiLFwicHJlZGljYXRlXCIsXCJyZXByZXNlbnRcIixcImRlZmF1bHRTdHlsZVwiLFwic3R5bGVBbGlhc2VzXCJdLGE9W1wic2NhbGFyXCIsXCJzZXF1ZW5jZVwiLFwibWFwcGluZ1wiXTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZih0PXR8fHt9LE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24odCl7aWYoLTE9PT1vLmluZGV4T2YodCkpdGhyb3cgbmV3IHIoJ1Vua25vd24gb3B0aW9uIFwiJyt0KydcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicrZSsnXCIgWUFNTCB0eXBlLicpfSksdGhpcy50YWc9ZSx0aGlzLmtpbmQ9dC5raW5kfHxudWxsLHRoaXMucmVzb2x2ZT10LnJlc29sdmV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LHRoaXMuY29uc3RydWN0PXQuY29uc3RydWN0fHxmdW5jdGlvbihlKXtyZXR1cm4gZX0sdGhpcy5pbnN0YW5jZU9mPXQuaW5zdGFuY2VPZnx8bnVsbCx0aGlzLnByZWRpY2F0ZT10LnByZWRpY2F0ZXx8bnVsbCx0aGlzLnJlcHJlc2VudD10LnJlcHJlc2VudHx8bnVsbCx0aGlzLmRlZmF1bHRTdHlsZT10LmRlZmF1bHRTdHlsZXx8bnVsbCx0aGlzLnN0eWxlQWxpYXNlcz1pKHQuc3R5bGVBbGlhc2VzfHxudWxsKSwtMT09PWEuaW5kZXhPZih0aGlzLmtpbmQpKXRocm93IG5ldyByKCdVbmtub3duIGtpbmQgXCInK3RoaXMua2luZCsnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicrZSsnXCIgWUFNTCB0eXBlLicpfX0se1wiLi9leGNlcHRpb25cIjo0fV0sMTQ6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaTt0cnl7aT1lKFwiYnVmZmVyXCIpLkJ1ZmZlcn1jYXRjaChlKXt9dmFyIHI9ZShcIi4uL3R5cGVcIiksbz1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyXCI7dC5leHBvcnRzPW5ldyByKFwidGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5XCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiExO3ZhciB0LG4saT0wLHI9ZS5sZW5ndGgsYT1vO2ZvcihuPTA7bjxyO24rKylpZighKCh0PWEuaW5kZXhPZihlLmNoYXJBdChuKSkpPjY0KSl7aWYodDwwKXJldHVybiExO2krPTZ9cmV0dXJuIGklOD09MH0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lLnJlcGxhY2UoL1tcXHJcXG49XS9nLFwiXCIpLGE9ci5sZW5ndGgscz1vLGM9MCx1PVtdO2Zvcih0PTA7dDxhO3QrKyl0JTQ9PTAmJnQmJih1LnB1c2goYz4+MTYmMjU1KSx1LnB1c2goYz4+OCYyNTUpLHUucHVzaCgyNTUmYykpLGM9Yzw8NnxzLmluZGV4T2Yoci5jaGFyQXQodCkpO3JldHVybiAwPT0obj1hJTQqNik/KHUucHVzaChjPj4xNiYyNTUpLHUucHVzaChjPj44JjI1NSksdS5wdXNoKDI1NSZjKSk6MTg9PT1uPyh1LnB1c2goYz4+MTAmMjU1KSx1LnB1c2goYz4+MiYyNTUpKToxMj09PW4mJnUucHVzaChjPj40JjI1NSksaT9pLmZyb20/aS5mcm9tKHUpOm5ldyBpKHUpOnV9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm4gaSYmaS5pc0J1ZmZlcihlKX0scmVwcmVzZW50OmZ1bmN0aW9uKGUpe3ZhciB0LG4saT1cIlwiLHI9MCxhPWUubGVuZ3RoLHM9bztmb3IodD0wO3Q8YTt0KyspdCUzPT0wJiZ0JiYoaSs9c1tyPj4xOCY2M10saSs9c1tyPj4xMiY2M10saSs9c1tyPj42JjYzXSxpKz1zWzYzJnJdKSxyPShyPDw4KStlW3RdO3JldHVybiAwPT0obj1hJTMpPyhpKz1zW3I+PjE4JjYzXSxpKz1zW3I+PjEyJjYzXSxpKz1zW3I+PjYmNjNdLGkrPXNbNjMmcl0pOjI9PT1uPyhpKz1zW3I+PjEwJjYzXSxpKz1zW3I+PjQmNjNdLGkrPXNbcjw8MiY2M10saSs9c1s2NF0pOjE9PT1uJiYoaSs9c1tyPj4yJjYzXSxpKz1zW3I8PDQmNjNdLGkrPXNbNjRdLGkrPXNbNjRdKSxpfX0pfSx7XCIuLi90eXBlXCI6MTN9XSwxNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOmJvb2xcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITE7dmFyIHQ9ZS5sZW5ndGg7cmV0dXJuIDQ9PT10JiYoXCJ0cnVlXCI9PT1lfHxcIlRydWVcIj09PWV8fFwiVFJVRVwiPT09ZSl8fDU9PT10JiYoXCJmYWxzZVwiPT09ZXx8XCJGYWxzZVwiPT09ZXx8XCJGQUxTRVwiPT09ZSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm5cInRydWVcIj09PWV8fFwiVHJ1ZVwiPT09ZXx8XCJUUlVFXCI9PT1lfSxwcmVkaWNhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEJvb2xlYW5dXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDp7bG93ZXJjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1widHJ1ZVwiOlwiZmFsc2VcIn0sdXBwZXJjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1wiVFJVRVwiOlwiRkFMU0VcIn0sY2FtZWxjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1wiVHJ1ZVwiOlwiRmFsc2VcIn19LGRlZmF1bHRTdHlsZTpcImxvd2VyY2FzZVwifSl9LHtcIi4uL3R5cGVcIjoxM31dLDE2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL2NvbW1vblwiKSxyPWUoXCIuLi90eXBlXCIpLG89bmV3IFJlZ0V4cChcIl4oPzpbLStdPyg/OjB8WzEtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT98XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT98Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKnxbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpfFxcXFwuKD86bmFufE5hTnxOQU4pKSRcIiksYT0vXlstK10/WzAtOV0rZS87dC5leHBvcnRzPW5ldyByKFwidGFnOnlhbWwub3JnLDIwMDI6ZmxvYXRcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1lJiYhKCFvLnRlc3QoZSl8fFwiX1wiPT09ZVtlLmxlbmd0aC0xXSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdCxuLGkscjtyZXR1cm4gdD1lLnJlcGxhY2UoL18vZyxcIlwiKS50b0xvd2VyQ2FzZSgpLG49XCItXCI9PT10WzBdPy0xOjEscj1bXSxcIistXCIuaW5kZXhPZih0WzBdKT49MCYmKHQ9dC5zbGljZSgxKSksXCIuaW5mXCI9PT10PzE9PT1uP051bWJlci5QT1NJVElWRV9JTkZJTklUWTpOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6XCIubmFuXCI9PT10P05hTjp0LmluZGV4T2YoXCI6XCIpPj0wPyh0LnNwbGl0KFwiOlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IudW5zaGlmdChwYXJzZUZsb2F0KGUsMTApKX0pLHQ9MCxpPTEsci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QrPWUqaSxpKj02MH0pLG4qdCk6bipwYXJzZUZsb2F0KHQsMTApfSxwcmVkaWNhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IE51bWJlcl1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSYmKGUlMSE9MHx8aS5pc05lZ2F0aXZlWmVybyhlKSl9LHJlcHJlc2VudDpmdW5jdGlvbihlLHQpe3ZhciBuO2lmKGlzTmFOKGUpKXN3aXRjaCh0KXtjYXNlXCJsb3dlcmNhc2VcIjpyZXR1cm5cIi5uYW5cIjtjYXNlXCJ1cHBlcmNhc2VcIjpyZXR1cm5cIi5OQU5cIjtjYXNlXCJjYW1lbGNhc2VcIjpyZXR1cm5cIi5OYU5cIn1lbHNlIGlmKE51bWJlci5QT1NJVElWRV9JTkZJTklUWT09PWUpc3dpdGNoKHQpe2Nhc2VcImxvd2VyY2FzZVwiOnJldHVyblwiLmluZlwiO2Nhc2VcInVwcGVyY2FzZVwiOnJldHVyblwiLklORlwiO2Nhc2VcImNhbWVsY2FzZVwiOnJldHVyblwiLkluZlwifWVsc2UgaWYoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPT09ZSlzd2l0Y2godCl7Y2FzZVwibG93ZXJjYXNlXCI6cmV0dXJuXCItLmluZlwiO2Nhc2VcInVwcGVyY2FzZVwiOnJldHVyblwiLS5JTkZcIjtjYXNlXCJjYW1lbGNhc2VcIjpyZXR1cm5cIi0uSW5mXCJ9ZWxzZSBpZihpLmlzTmVnYXRpdmVaZXJvKGUpKXJldHVyblwiLTAuMFwiO3JldHVybiBuPWUudG9TdHJpbmcoMTApLGEudGVzdChuKT9uLnJlcGxhY2UoXCJlXCIsXCIuZVwiKTpufSxkZWZhdWx0U3R5bGU6XCJsb3dlcmNhc2VcIn0pfSx7XCIuLi9jb21tb25cIjoyLFwiLi4vdHlwZVwiOjEzfV0sMTc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiA0ODw9ZSYmZTw9NTd8fDY1PD1lJiZlPD03MHx8OTc8PWUmJmU8PTEwMn1mdW5jdGlvbiByKGUpe3JldHVybiA0ODw9ZSYmZTw9NTV9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gNDg8PWUmJmU8PTU3fXZhciBhPWUoXCIuLi9jb21tb25cIikscz1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IHMoXCJ0YWc6eWFtbC5vcmcsMjAwMjppbnRcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITE7dmFyIHQsbj1lLmxlbmd0aCxhPTAscz0hMTtpZighbilyZXR1cm4hMTtpZihcIi1cIiE9PSh0PWVbYV0pJiZcIitcIiE9PXR8fCh0PWVbKythXSksXCIwXCI9PT10KXtpZihhKzE9PT1uKXJldHVybiEwO2lmKFwiYlwiPT09KHQ9ZVsrK2FdKSl7Zm9yKGErKzthPG47YSsrKWlmKFwiX1wiIT09KHQ9ZVthXSkpe2lmKFwiMFwiIT09dCYmXCIxXCIhPT10KXJldHVybiExO3M9ITB9cmV0dXJuIHMmJlwiX1wiIT09dH1pZihcInhcIj09PXQpe2ZvcihhKys7YTxuO2ErKylpZihcIl9cIiE9PSh0PWVbYV0pKXtpZighaShlLmNoYXJDb2RlQXQoYSkpKXJldHVybiExO3M9ITB9cmV0dXJuIHMmJlwiX1wiIT09dH1mb3IoO2E8bjthKyspaWYoXCJfXCIhPT0odD1lW2FdKSl7aWYoIXIoZS5jaGFyQ29kZUF0KGEpKSlyZXR1cm4hMTtzPSEwfXJldHVybiBzJiZcIl9cIiE9PXR9aWYoXCJfXCI9PT10KXJldHVybiExO2Zvcig7YTxuO2ErKylpZihcIl9cIiE9PSh0PWVbYV0pKXtpZihcIjpcIj09PXQpYnJlYWs7aWYoIW8oZS5jaGFyQ29kZUF0KGEpKSlyZXR1cm4hMTtzPSEwfXJldHVybiEoIXN8fFwiX1wiPT09dCkmJihcIjpcIiE9PXR8fC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChlLnNsaWNlKGEpKSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdCxuLGk9ZSxyPTEsbz1bXTtyZXR1cm4tMSE9PWkuaW5kZXhPZihcIl9cIikmJihpPWkucmVwbGFjZSgvXy9nLFwiXCIpKSxcIi1cIiE9PSh0PWlbMF0pJiZcIitcIiE9PXR8fChcIi1cIj09PXQmJihyPS0xKSx0PShpPWkuc2xpY2UoMSkpWzBdKSxcIjBcIj09PWk/MDpcIjBcIj09PXQ/XCJiXCI9PT1pWzFdP3IqcGFyc2VJbnQoaS5zbGljZSgyKSwyKTpcInhcIj09PWlbMV0/cipwYXJzZUludChpLDE2KTpyKnBhcnNlSW50KGksOCk6LTEhPT1pLmluZGV4T2YoXCI6XCIpPyhpLnNwbGl0KFwiOlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe28udW5zaGlmdChwYXJzZUludChlLDEwKSl9KSxpPTAsbj0xLG8uZm9yRWFjaChmdW5jdGlvbihlKXtpKz1lKm4sbio9NjB9KSxyKmkpOnIqcGFyc2VJbnQoaSwxMCl9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgTnVtYmVyXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpJiZlJTE9PTAmJiFhLmlzTmVnYXRpdmVaZXJvKGUpfSxyZXByZXNlbnQ6e2JpbmFyeTpmdW5jdGlvbihlKXtyZXR1cm5cIjBiXCIrZS50b1N0cmluZygyKX0sb2N0YWw6ZnVuY3Rpb24oZSl7cmV0dXJuXCIwXCIrZS50b1N0cmluZyg4KX0sZGVjaW1hbDpmdW5jdGlvbihlKXtyZXR1cm4gZS50b1N0cmluZygxMCl9LGhleGFkZWNpbWFsOmZ1bmN0aW9uKGUpe3JldHVyblwiMHhcIitlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfX0sZGVmYXVsdFN0eWxlOlwiZGVjaW1hbFwiLHN0eWxlQWxpYXNlczp7YmluYXJ5OlsyLFwiYmluXCJdLG9jdGFsOls4LFwib2N0XCJdLGRlY2ltYWw6WzEwLFwiZGVjXCJdLGhleGFkZWNpbWFsOlsxNixcImhleFwiXX19KX0se1wiLi4vY29tbW9uXCI6MixcIi4uL3R5cGVcIjoxM31dLDE4OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk7dHJ5e2k9ZShcImVzcHJpbWFcIil9Y2F0Y2goZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKGk9d2luZG93LmVzcHJpbWEpfXZhciByPWUoXCIuLi8uLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgcihcInRhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiExO3RyeXt2YXIgdD1cIihcIitlK1wiKVwiLG49aS5wYXJzZSh0LHtyYW5nZTohMH0pO3JldHVyblwiUHJvZ3JhbVwiPT09bi50eXBlJiYxPT09bi5ib2R5Lmxlbmd0aCYmXCJFeHByZXNzaW9uU3RhdGVtZW50XCI9PT1uLmJvZHlbMF0udHlwZSYmXCJGdW5jdGlvbkV4cHJlc3Npb25cIj09PW4uYm9keVswXS5leHByZXNzaW9uLnR5cGV9Y2F0Y2goZSl7cmV0dXJuITF9fSxjb25zdHJ1Y3Q6ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIihcIitlK1wiKVwiLHI9aS5wYXJzZShuLHtyYW5nZTohMH0pLG89W107aWYoXCJQcm9ncmFtXCIhPT1yLnR5cGV8fDEhPT1yLmJvZHkubGVuZ3RofHxcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiE9PXIuYm9keVswXS50eXBlfHxcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIT09ci5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvblwiKTtyZXR1cm4gci5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24oZSl7by5wdXNoKGUubmFtZSl9KSx0PXIuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2UsbmV3IEZ1bmN0aW9uKG8sbi5zbGljZSh0WzBdKzEsdFsxXS0xKSl9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgRnVuY3Rpb25dXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDpmdW5jdGlvbihlKXtyZXR1cm4gZS50b1N0cmluZygpfX0pfSx7XCIuLi8uLi90eXBlXCI6MTN9XSwxOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi8uLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cFwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm4hMTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuITE7dmFyIHQ9ZSxuPS9cXC8oW2dpbV0qKSQvLmV4ZWMoZSksaT1cIlwiO2lmKFwiL1wiPT09dFswXSl7aWYobiYmKGk9blsxXSksaS5sZW5ndGg+MylyZXR1cm4hMTtpZihcIi9cIiE9PXRbdC5sZW5ndGgtaS5sZW5ndGgtMV0pcmV0dXJuITF9cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdD1lLG49L1xcLyhbZ2ltXSopJC8uZXhlYyhlKSxpPVwiXCI7cmV0dXJuXCIvXCI9PT10WzBdJiYobiYmKGk9blsxXSksdD10LnNsaWNlKDEsdC5sZW5ndGgtaS5sZW5ndGgtMSkpLG5ldyBSZWdFeHAodCxpKX0scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBSZWdFeHBdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDpmdW5jdGlvbihlKXt2YXIgdD1cIi9cIitlLnNvdXJjZStcIi9cIjtyZXR1cm4gZS5nbG9iYWwmJih0Kz1cImdcIiksZS5tdWx0aWxpbmUmJih0Kz1cIm1cIiksZS5pZ25vcmVDYXNlJiYodCs9XCJpXCIpLHR9fSl9LHtcIi4uLy4uL3R5cGVcIjoxM31dLDIwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uLy4uL3R5cGVcIik7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6anMvdW5kZWZpbmVkXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbigpe30scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lfSxyZXByZXNlbnQ6ZnVuY3Rpb24oKXtyZXR1cm5cIlwifX0pfSx7XCIuLi8uLi90eXBlXCI6MTN9XSwyMTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOm1hcFwiLHtraW5kOlwibWFwcGluZ1wiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTp7fX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjptZXJnZVwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtyZXR1cm5cIjw8XCI9PT1lfHxudWxsPT09ZX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpudWxsXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiEwO3ZhciB0PWUubGVuZ3RoO3JldHVybiAxPT09dCYmXCJ+XCI9PT1lfHw0PT09dCYmKFwibnVsbFwiPT09ZXx8XCJOdWxsXCI9PT1lfHxcIk5VTExcIj09PWUpfSxjb25zdHJ1Y3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT09ZX0scmVwcmVzZW50OntjYW5vbmljYWw6ZnVuY3Rpb24oKXtyZXR1cm5cIn5cIn0sbG93ZXJjYXNlOmZ1bmN0aW9uKCl7cmV0dXJuXCJudWxsXCJ9LHVwcGVyY2FzZTpmdW5jdGlvbigpe3JldHVyblwiTlVMTFwifSxjYW1lbGNhc2U6ZnVuY3Rpb24oKXtyZXR1cm5cIk51bGxcIn19LGRlZmF1bHRTdHlsZTpcImxvd2VyY2FzZVwifSl9LHtcIi4uL3R5cGVcIjoxM31dLDI0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3R5cGVcIikscj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpvbWFwXCIse2tpbmQ6XCJzZXF1ZW5jZVwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITA7dmFyIHQsbixpLGEscyxjPVtdLHU9ZTtmb3IodD0wLG49dS5sZW5ndGg7dDxuO3QrPTEpe2lmKGk9dVt0XSxzPSExLFwiW29iamVjdCBPYmplY3RdXCIhPT1vLmNhbGwoaSkpcmV0dXJuITE7Zm9yKGEgaW4gaSlpZihyLmNhbGwoaSxhKSl7aWYocylyZXR1cm4hMTtzPSEwfWlmKCFzKXJldHVybiExO2lmKC0xIT09Yy5pbmRleE9mKGEpKXJldHVybiExO2MucHVzaChhKX1yZXR1cm4hMH0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09ZT9lOltdfX0pfSx7XCIuLi90eXBlXCI6MTN9XSwyNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpLHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpwYWlyc1wiLHtraW5kOlwic2VxdWVuY2VcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiEwO3ZhciB0LG4saSxvLGEscz1lO2ZvcihhPW5ldyBBcnJheShzLmxlbmd0aCksdD0wLG49cy5sZW5ndGg7dDxuO3QrPTEpe2lmKGk9c1t0XSxcIltvYmplY3QgT2JqZWN0XVwiIT09ci5jYWxsKGkpKXJldHVybiExO2lmKDEhPT0obz1PYmplY3Qua2V5cyhpKSkubGVuZ3RoKXJldHVybiExO2FbdF09W29bMF0saVtvWzBdXV19cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm5bXTt2YXIgdCxuLGkscixvLGE9ZTtmb3Iobz1uZXcgQXJyYXkoYS5sZW5ndGgpLHQ9MCxuPWEubGVuZ3RoO3Q8bjt0Kz0xKWk9YVt0XSxyPU9iamVjdC5rZXlzKGkpLG9bdF09W3JbMF0saVtyWzBdXV07cmV0dXJuIG99fSl9LHtcIi4uL3R5cGVcIjoxM31dLDI2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3R5cGVcIik7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6c2VxXCIse2tpbmQ6XCJzZXF1ZW5jZVwiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTpbXX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKSxyPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6c2V0XCIse2tpbmQ6XCJtYXBwaW5nXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm4hMDt2YXIgdCxuPWU7Zm9yKHQgaW4gbilpZihyLmNhbGwobix0KSYmbnVsbCE9PW5bdF0pcmV0dXJuITE7cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTp7fX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpzdHJcIix7a2luZDpcInNjYWxhclwiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTpcIlwifX0pfSx7XCIuLi90eXBlXCI6MTN9XSwyOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpLHI9bmV3IFJlZ0V4cChcIl4oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldKS0oWzAtOV1bMC05XSkkXCIpLG89bmV3IFJlZ0V4cChcIl4oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldPyktKFswLTldWzAtOV0/KSg/OltUdF18WyBcXFxcdF0rKShbMC05XVswLTldPyk6KFswLTldWzAtOV0pOihbMC05XVswLTldKSg/OlxcXFwuKFswLTldKikpPyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPykoPzo6KFswLTldWzAtOV0pKT8pKT8kXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcFwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWUmJihudWxsIT09ci5leGVjKGUpfHxudWxsIT09by5leGVjKGUpKX0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3ZhciB0LG4saSxhLHMsYyx1LGwscD0wLGY9bnVsbDtpZihudWxsPT09KHQ9ci5leGVjKGUpKSYmKHQ9by5leGVjKGUpKSxudWxsPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJEYXRlIHJlc29sdmUgZXJyb3JcIik7aWYobj0rdFsxXSxpPSt0WzJdLTEsYT0rdFszXSwhdFs0XSlyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMobixpLGEpKTtpZihzPSt0WzRdLGM9K3RbNV0sdT0rdFs2XSx0WzddKXtmb3IocD10WzddLnNsaWNlKDAsMyk7cC5sZW5ndGg8MzspcCs9XCIwXCI7cD0rcH1yZXR1cm4gdFs5XSYmKGY9NmU0Kig2MCordFsxMF0rICsodFsxMV18fDApKSxcIi1cIj09PXRbOV0mJihmPS1mKSksbD1uZXcgRGF0ZShEYXRlLlVUQyhuLGksYSxzLGMsdSxwKSksZiYmbC5zZXRUaW1lKGwuZ2V0VGltZSgpLWYpLGx9LGluc3RhbmNlT2Y6RGF0ZSxyZXByZXNlbnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9JU09TdHJpbmcoKX19KX0se1wiLi4vdHlwZVwiOjEzfV0sXCIvXCI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi9saWIvanMteWFtbC5qc1wiKTt0LmV4cG9ydHM9aX0se1wiLi9saWIvanMteWFtbC5qc1wiOjF9XX0se30sW10pKFwiL1wiKX0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2Rpc3QvanMteWFtbC5taW4uanMiXSwic291cmNlUm9vdCI6IiJ9