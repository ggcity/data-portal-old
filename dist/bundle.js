/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 90);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.throttle = throttle;
exports.wrapNum = wrapNum;
exports.falseFn = falseFn;
exports.formatNum = formatNum;
exports.trim = trim;
exports.splitWords = splitWords;
exports.setOptions = setOptions;
exports.getParamString = getParamString;
exports.template = template;
exports.indexOf = indexOf;
exports.requestAnimFrame = requestAnimFrame;
exports.cancelAnimFrame = cancelAnimFrame;
/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = exports.freeze = Object.freeze;
Object.freeze = function (obj) {
	return obj;
};

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = exports.create = Object.create || function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
}();

// @function bind(fn: Function, …): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = exports.lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assiging it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || (exports.lastId = lastId += 1);
	return obj._leaflet_id;
	/*eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function later() {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function wrapperFn() {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;
		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
	    min = range[0],
	    d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() {
	return false;
}

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, digits || 5);
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_\-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values — they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);
		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = exports.isArray = Array.isArray || function (obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) {
			return i;
		}
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = exports.emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
	    timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = exports.requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = exports.cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
	window.clearTimeout(id);
};

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.enableTextSelection = exports.disableTextSelection = exports.TRANSITION_END = exports.TRANSITION = exports.TRANSFORM = undefined;
exports.get = get;
exports.getStyle = getStyle;
exports.create = create;
exports.remove = remove;
exports.empty = empty;
exports.toFront = toFront;
exports.toBack = toBack;
exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.setClass = setClass;
exports.getClass = getClass;
exports.setOpacity = setOpacity;
exports.testProp = testProp;
exports.setTransform = setTransform;
exports.setPosition = setPosition;
exports.getPosition = getPosition;
exports.disableImageDrag = disableImageDrag;
exports.enableImageDrag = enableImageDrag;
exports.preventOutline = preventOutline;
exports.restoreOutline = restoreOutline;

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Point = __webpack_require__(3);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = exports.TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = exports.TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END = exports.TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';

// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || el.currentStyle && el.currentStyle[style];

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = Util.splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, Util.trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
	    filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) {
			return;
		}
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = value !== 100;
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new _Point.Point(0, 0);

	el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/*eslint-enable */

	if (Browser.any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new _Point.Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection = exports.disableTextSelection = undefined;
var enableTextSelection = exports.enableTextSelection = undefined;
var _userSelect;
if ('onselectstart' in document) {
	exports.disableTextSelection = disableTextSelection = function disableTextSelection() {
		DomEvent.on(window, 'selectstart', DomEvent.preventDefault);
	};
	exports.enableTextSelection = enableTextSelection = function enableTextSelection() {
		DomEvent.off(window, 'selectstart', DomEvent.preventDefault);
	};
} else {
	var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	exports.disableTextSelection = disableTextSelection = function disableTextSelection() {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	exports.enableTextSelection = enableTextSelection = function enableTextSelection() {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	DomEvent.on(window, 'dragstart', DomEvent.preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	DomEvent.off(window, 'dragstart', DomEvent.preventDefault);
}

var _outlineElement, _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) {
		return;
	}
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	DomEvent.on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) {
		return;
	}
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	DomEvent.off(window, 'keydown', restoreOutline);
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.JSCompiler_renameProperty = function (prop, obj) {
  return prop;
};

/** @namespace */
var Polymer = void 0;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.Point = Point;
exports.toPoint = toPoint;

var _Util = __webpack_require__(0);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = round ? Math.round(x) : x;
	// @property y: Number; The `y` coordinate of the point
	this.y = round ? Math.round(y) : y;
}

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function clone() {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function add(point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function _add(point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function subtract(point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function _subtract(point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function divideBy(num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function _divideBy(num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function multiplyBy(num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function _multiplyBy(num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function scaleBy(point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function unscaleBy(point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function round() {
		return this.clone()._round();
	},

	_round: function _round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function floor() {
		return this.clone()._floor();
	},

	_floor: function _floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function ceil() {
		return this.clone()._ceil();
	},

	_ceil: function _ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function distanceTo(point) {
		point = toPoint(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function equals(point) {
		point = toPoint(point);

		return point.x === this.x && point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function contains(point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function toString() {
		return 'Point(' + (0, _Util.formatNum)(this.x) + ', ' + (0, _Util.formatNum)(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if ((0, _Util.isArray)(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vml = exports.svg = exports.canvas = exports.retina = exports.mobileGecko = exports.mobileOpera = exports.touch = exports.pointer = exports.msPointer = exports.mobileWebkit3d = exports.mobileWebkit = exports.mobile = exports.any3d = exports.gecko3d = exports.webkit3d = exports.ie3d = exports.win = exports.opera12 = exports.phantom = exports.safari = exports.gecko = exports.chrome = exports.opera = exports.android23 = exports.android = exports.webkit = exports.edge = exports.ielt9 = exports.ie = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _SVG = __webpack_require__(75);

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = exports.ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = exports.ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = exports.edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = exports.webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = exports.android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = exports.android23 = userAgentContains('android 2') || userAgentContains('android 3');

// @property opera: Boolean; `true` for the Opera browser
var opera = exports.opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = exports.chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = exports.gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = exports.safari = !chrome && userAgentContains('safari');

var phantom = exports.phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = exports.opera12 = 'OTransition' in style;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = exports.win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = exports.ie3d = ie && 'transition' in style;

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = exports.webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = exports.gecko3d = 'MozPerspective' in style;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = exports.any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = exports.mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = exports.mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = exports.mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = exports.msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = exports.pointer = !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = exports.touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = exports.mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = exports.mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen.
var retina = exports.retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;

// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = exports.canvas = function () {
  return !!document.createElement('canvas').getContext;
}();

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = exports.svg = !!(document.createElementNS && (0, _SVG.svgCreate)('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = exports.vml = !svg && function () {
  try {
    var div = document.createElement('div');
    div.innerHTML = '<v:shape adj="1"/>';

    var shape = div.firstChild;
    shape.style.behavior = 'url(#default#VML)';

    return shape && _typeof(shape.adj) === 'object';
  } catch (e) {
    return false;
  }
}();

function userAgentContains(str) {
  return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.removeListener = exports.addListener = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.on = on;
exports.off = off;
exports.stopPropagation = stopPropagation;
exports.disableScrollPropagation = disableScrollPropagation;
exports.disableClickPropagation = disableClickPropagation;
exports.preventDefault = preventDefault;
exports.stop = stop;
exports.getMousePosition = getMousePosition;
exports.getWheelDelta = getWheelDelta;
exports.fakeStop = fakeStop;
exports.skipped = skipped;
exports.isExternalTarget = isExternalTarget;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(76);

var _DomEvent2 = __webpack_require__(116);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = Util.splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function. If no function is specified,
// it will remove all the listeners of that particular DOM event from the element.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

// @alternative
// @function off(el: HTMLElement): this
// Removes all known event listeners
function off(obj, types, fn, context) {

	if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = Util.splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) {
		return this;
	}

	var handler = function handler(e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (Browser.pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		(0, _DomEvent.addPointerListener)(obj, type, handler, id);
	} else if (Browser.touch && type === 'dblclick' && _DomEvent2.addDoubleTapListener && !(Browser.pointer && Browser.chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		(0, _DomEvent2.addDoubleTapListener)(obj, handler, id);
	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
		} else if (type === 'mouseenter' || type === 'mouseleave') {
			handler = function handler(e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);
		} else {
			if (type === 'click' && Browser.android) {
				handler = function handler(e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}
	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : ''),
	    handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) {
		return this;
	}

	if (Browser.pointer && type.indexOf('touch') === 0) {
		(0, _DomEvent.removePointerListener)(obj, type, id);
	} else if (Browser.touch && type === 'dblclick' && _DomEvent2.removeDoubleTapListener) {
		(0, _DomEvent2.removeDoubleTapListener)(obj, id);
	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
		} else {
			obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}
	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {
		// In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new _Point.Point(e.clientX, e.clientY);
	}

	var rect = container.getBoundingClientRect();

	return new _Point.Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor = Browser.win && Browser.chrome ? 2 * window.devicePixelRatio : Browser.gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return Browser.edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
	e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
	e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
	e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
	e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
	e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
	e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
	e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
	0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) {
		return true;
	}

	try {
		while (related && related !== el) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return related !== el;
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,
	    elapsed = lastClick && timeStamp - lastClick;

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}

// @function addListener(…): this
// Alias to [`L.DomEvent.on`](#domevent-on)
exports.addListener = on;

// @function removeListener(…): this
// Alias to [`L.DomEvent.off`](#domevent-off)

exports.removeListener = off;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Base = undefined;

var _legacyElementMixin = __webpack_require__(60);

__webpack_require__(28);

__webpack_require__(100);

__webpack_require__(101);

__webpack_require__(44);

__webpack_require__(102);

__webpack_require__(103);

__webpack_require__(104);

__webpack_require__(106);

var Base = exports.Base = (0, _legacyElementMixin.LegacyElementMixin)(HTMLElement).prototype;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Map = undefined;
exports.createMap = createMap;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Events = __webpack_require__(19);

var _CRS = __webpack_require__(73);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(8);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _PosAnimation = __webpack_require__(77);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = exports.Map = _Events.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: _CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,

		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function initialize(id, options) {
		// (HTMLElement or String, Object)
		options = Util.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = Util.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView((0, _LatLng.toLatLng)(options.center), options.zoom, { reset: true });
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = DomUtil.TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			DomEvent.on(this._proxy, DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},

	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function setView(center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter((0, _LatLng.toLatLng)(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = Util.extend({ animate: options.animate }, options.zoom);
				options.pan = Util.extend({ animate: options.animate, duration: options.duration }, options.pan);
			}

			// try animating pan or zoom
			var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function setZoom(zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, { zoom: options });
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function zoomIn(delta, options) {
		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function zoomOut(delta, options) {
		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function setZoomAround(latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof _Point.Point ? latlng : this.latLngToContainerPoint(latlng),
		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, { zoom: options });
	},

	_getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : (0, _LatLngBounds.toLatLngBounds)(bounds);

		var paddingTL = (0, _Point.toPoint)(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = (0, _Point.toPoint)(options.paddingBottomRight || options.padding || [0, 0]),
		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function fitBounds(bounds, options) {

		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function fitWorld(options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function panTo(center, options) {
		// (LatLng)
		return this.setView(center, this._zoom, { pan: options });
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function panBy(offset, options) {
		offset = (0, _Point.toPoint)(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new _PosAnimation.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function flyTo(targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = (0, _LatLng.toLatLng)(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = to.distanceTo(from) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			// workaround for floating point precision bug when sq = 0, log = -Infinite,
			// thus triggering an infinite loop in flyTo
			var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) {
			return (Math.exp(n) - Math.exp(-n)) / 2;
		}
		function cosh(n) {
			return (Math.exp(n) + Math.exp(-n)) / 2;
		}
		function tanh(n) {
			return sinh(n) / cosh(n);
		}

		var r0 = r(0);

		function w(s) {
			return w0 * (cosh(r0) / cosh(r0 + rho * s));
		}
		function u(s) {
			return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
		}

		function easeOut(t) {
			return 1 - Math.pow(1 - t, 1.5);
		}

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = Util.requestAnimFrame(frame, this);

				this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), { flyTo: true });
			} else {
				this._move(targetCenter, targetZoom)._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function flyToBounds(bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function setMaxBounds(bounds) {
		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function setMinZoom(zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function setMaxZoom(zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && this.getZoom() > this.options.maxZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function panInsideBounds(bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, (0, _LatLngBounds.toLatLngBounds)(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function invalidateSize(options) {
		if (!this._loaded) {
			return this;
		}

		options = Util.extend({
			animate: false,
			pan: true
		}, options === true ? { animate: true } : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) {
			return this;
		}

		if (options.animate && options.pan) {
			this.panBy(offset);
		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(Util.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function stop() {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function locate(options) {

		options = this._locateOptions = Util.extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = Util.bind(this._handleGeolocationResponse, this),
		    onError = Util.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function stopLocate() {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function _handleGeolocationError(error) {
		var c = error.code,
		    message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function _handleGeolocationResponse(pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new _LatLng.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function addHandler(name, HandlerClass) {
		if (!HandlerClass) {
			return this;
		}

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function remove() {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/*eslint-enable */
			this._containerId = undefined;
		}

		DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			DomUtil.remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function createPane(name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function getCenter() {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function getZoom() {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function getBounds() {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new _LatLngBounds.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function getMinZoom() {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function getMaxZoom() {
		return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {
		// (LatLngBounds[, Boolean, Point]) -> Number
		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);
		padding = (0, _Point.toPoint)(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = (0, _Bounds.toBounds)(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = Browser.any3d ? this.options.zoomSnap : 1,
		    scalex = size.x / boundsSize.x,
		    scaley = size.y / boundsSize.y,
		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function getSize() {
		if (!this._size || this._sizeChanged) {
			this._size = new _Point.Point(this._container.clientWidth || 0, this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function getPixelBounds(center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new _Bounds.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function getPixelOrigin() {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function getPixelWorldBounds(zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function getPane(pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function getPanes() {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function getContainer() {
		return this._container;
	},

	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function getZoomScale(toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function getScaleZoom(scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function project(latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint((0, _LatLng.toLatLng)(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function unproject(point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng((0, _Point.toPoint)(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function layerPointToLatLng(point) {
		var projectedPoint = (0, _Point.toPoint)(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function latLngToLayerPoint(latlng) {
		var projectedPoint = this.project((0, _LatLng.toLatLng)(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function wrapLatLng(latlng) {
		return this.options.crs.wrapLatLng((0, _LatLng.toLatLng)(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function wrapLatLngBounds(latlng) {
		return this.options.crs.wrapLatLngBounds((0, _LatLngBounds.toLatLngBounds)(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function distance(latlng1, latlng2) {
		return this.options.crs.distance((0, _LatLng.toLatLng)(latlng1), (0, _LatLng.toLatLng)(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function containerPointToLayerPoint(point) {
		// (Point)
		return (0, _Point.toPoint)(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function layerPointToContainerPoint(point) {
		// (Point)
		return (0, _Point.toPoint)(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function containerPointToLatLng(point) {
		var layerPoint = this.containerPointToLayerPoint((0, _Point.toPoint)(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function latLngToContainerPoint(latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint((0, _LatLng.toLatLng)(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {
		return DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function mouseEventToLatLng(e) {
		// (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},

	// map initialization methods

	_initContainer: function _initContainer(id) {
		var container = this._container = DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		DomEvent.on(container, 'scroll', this._onScroll, this);
		this._containerId = Util.stamp(container);
	},

	_initLayout: function _initLayout() {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;

		DomUtil.addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function _initPanes() {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		DomUtil.setPosition(this._mapPane, new _Point.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},

	// private methods that modify map state

	// @section Map state change events
	_resetView: function _resetView(center, zoom) {
		DomUtil.setPosition(this._mapPane, new _Point.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this._moveStart(zoomChanged)._move(center, zoom)._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function _moveStart(zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function _move(center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || data && data.pinch) {
			// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function _moveEnd(zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function _stop() {
		Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function _rawPanBy(offset) {
		DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function _getZoomSpan() {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function _panInsideMaxBounds() {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function _checkIfLoaded() {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function _initEvents(remove) {
		this._targets = {};
		this._targets[Util.stamp(this._container)] = this;

		var onOff = remove ? DomEvent.off : DomEvent.on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (Browser.any3d && this.options.transform3DLimit) {
			(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function _onResize() {
		Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = Util.requestAnimFrame(function () {
			this.invalidateSize({ debounceMoveend: true });
		}, this);
	},

	_onScroll: function _onScroll() {
		this._container.scrollTop = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function _onMoveEnd() {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function _findEventTargets(e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[Util.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !DomEvent.isExternalTarget(src, e)) {
					break;
				}
				targets.push(target);
				if (isHover) {
					break;
				}
			}
			if (src === this._container) {
				break;
			}
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && DomEvent.isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function _handleDOMEvent(e) {
		if (!this._loaded || DomEvent.skipped(e)) {
			return;
		}

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress') {
			// prevents outline when clicking on keyboard-focusable element
			DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function _fireDOMEvent(e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) {
			return;
		}

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) {
			return;
		}

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target.options && 'icon' in target.options;
			data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && Util.indexOf(this._mouseEvents, type) !== -1) {
				return;
			}
		}
	},

	_draggableMoved: function _draggableMoved(obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
	},

	_clearHandlers: function _clearHandlers() {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function whenReady(callback, context) {
		if (this._loaded) {
			callback.call(context || this, { target: this });
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	// private methods for getting map state

	_getMapPanePos: function _getMapPanePos() {
		return DomUtil.getPosition(this._mapPane) || new _Point.Point(0, 0);
	},

	_moved: function _moved() {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function _getTopLeftPoint(center, zoom) {
		var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return (0, _Bounds.toBounds)([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function _getCenterLayerPoint() {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function _getCenterOffset(latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function _limitCenter(center, zoom, bounds) {

		if (!bounds) {
			return center;
		}

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new _Bounds.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function _limitOffset(offset, bounds) {
		if (!bounds) {
			return offset;
		}

		var viewBounds = this.getPixelBounds(),
		    newBounds = new _Bounds.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = (0, _Bounds.toBounds)(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new _Point.Point(dx, dy);
	},

	_rebound: function _rebound(left, right) {
		return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function _limitZoom(zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function _onPanTransitionStep() {
		this.fire('move');
	},

	_onPanTransitionEnd: function _onPanTransitionEnd() {
		DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function _tryAnimatedPan(center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
			return false;
		}

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function _createAnimProxy() {

		var proxy = this._proxy = DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = DomUtil.TRANSFORM,
			    transform = this._proxy.style[prop];

			DomUtil.setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			DomUtil.setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function _destroyAnimProxy() {
		DomUtil.remove(this._proxy);
		delete this._proxy;
	},

	_catchTransitionEnd: function _catchTransitionEnd(e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function _nothingToAnimate() {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {

		if (this._animatingZoom) {
			return true;
		}

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
			return false;
		}

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) {
			return false;
		}

		Util.requestAnimFrame(function () {
			this._moveStart(true)._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(Util.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function _onZoomTransitionEnd() {
		if (!this._animatingZoom) {
			return;
		}

		DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Bounds = Bounds;
exports.toBounds = toBounds;

var _Point = __webpack_require__(3);

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

function Bounds(a, b) {
	if (!a) {
		return;
	}

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function extend(point) {
		// (Point)
		point = (0, _Point.toPoint)(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function getCenter(round) {
		return new _Point.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function getBottomLeft() {
		return new _Point.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function getTopRight() {
		// -> Point
		return new _Point.Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function getTopLeft() {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function getBottomRight() {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function getSize() {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function contains(obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof _Point.Point) {
			obj = (0, _Point.toPoint)(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function intersects(bounds) {
		// (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = max2.x >= min.x && min2.x <= max.x,
		    yIntersects = max2.y >= min.y && min2.y <= max.y;

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function overlaps(bounds) {
		// (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = max2.x > min.x && min2.x < max.x,
		    yOverlaps = max2.y > min.y && min2.y < max.y;

		return xOverlaps && yOverlaps;
	},

	isValid: function isValid() {
		return !!(this.min && this.max);
	}
};

// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.LatLng = LatLng;
exports.toLatLng = toLatLng;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _CRS = __webpack_require__(16);

var _LatLngBounds = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function equals(obj, maxMargin) {
		if (!obj) {
			return false;
		}

		obj = toLatLng(obj);

		var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function toString(precision) {
		return 'LatLng(' + Util.formatNum(this.lat, precision) + ', ' + Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function distanceTo(other) {
		return _CRS.Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function wrap() {
		return _CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function toBounds(sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);

		return (0, _LatLngBounds.toLatLngBounds)([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function clone() {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};

// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (Util.isArray(a) && _typeof(a[0]) !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LatLngBounds = LatLngBounds;
exports.toLatLngBounds = toLatLngBounds;

var _LatLng = __webpack_require__(9);

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 */

function LatLngBounds(corner1, corner2) {
	// (LatLng, LatLng) or (LatLng[])
	if (!corner1) {
		return;
	}

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function extend(obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2,
		    ne2;

		if (obj instanceof _LatLng.LatLng) {
			sw2 = obj;
			ne2 = obj;
		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) {
				return this;
			}
		} else {
			return obj ? this.extend((0, _LatLng.toLatLng)(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new _LatLng.LatLng(sw2.lat, sw2.lng);
			this._northEast = new _LatLng.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function pad(bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(new _LatLng.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new _LatLng.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function getCenter() {
		return new _LatLng.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function getSouthWest() {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function getNorthEast() {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function getNorthWest() {
		return new _LatLng.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function getSouthEast() {
		return new _LatLng.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function getWest() {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function getSouth() {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function getEast() {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function getNorth() {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function contains(obj) {
		// (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof _LatLng.LatLng || 'lat' in obj) {
			obj = (0, _LatLng.toLatLng)(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2,
		    ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function intersects(bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),
		    latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
		    lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function overlaps(bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),
		    latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
		    lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function toBBoxString() {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function equals(bounds, maxMargin) {
		if (!bounds) {
			return false;
		}

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function isValid() {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Element = undefined;

var _elementMixin = __webpack_require__(33);

/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin Polymer.ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */
var Element = (0, _elementMixin.ElementMixin)(HTMLElement);
exports.Element = Element;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Layer = undefined;

var _Events = __webpack_require__(19);

var _Map = __webpack_require__(7);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */

var Layer = exports.Layer = _Events.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
  * Classes extending `L.Layer` will inherit the following methods:
  *
  * @method addTo(map: Map|LayerGroup): this
  * Adds the layer to the given map or layer group.
  */
	addTo: function addTo(map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function remove() {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function removeFrom(obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function getPane(name) {
		return this._map.getPane(name ? this.options[name] || name : this.options.pane);
	},

	addInteractiveTarget: function addInteractiveTarget(targetEl) {
		this._map._targets[Util.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function removeInteractiveTarget(targetEl) {
		delete this._map._targets[Util.stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function getAttribution() {
		return this.options.attribution;
	},

	_layerAdd: function _layerAdd(e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) {
			return;
		}

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', { layer: this });
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */

/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
_Map.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function addLayer(layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = Util.stamp(layer);
		if (this._layers[id]) {
			return this;
		}
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function removeLayer(layer) {
		var id = Util.stamp(layer);

		if (!this._layers[id]) {
			return this;
		}

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', { layer: layer });
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function hasLayer(layer) {
		return !!layer && Util.stamp(layer) in this._layers;
	},

	/* @method eachLayer(fn: Function, context?: Object): this
  * Iterates over the layers of the map, optionally specifying context of the iterator function.
  * ```
  * map.eachLayer(function(layer){
  *     layer.bindPopup('Hello');
  * });
  * ```
  */
	eachLayer: function eachLayer(method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function _addLayers(layers) {
		layers = layers ? Util.isArray(layers) ? layers : [layers] : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function _addZoomLimit(layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[Util.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function _removeZoomLimit(layer) {
		var id = Util.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function _updateZoomLevels() {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dedupingMixin = undefined;

__webpack_require__(2);

// unique global id for deduping mixins.
var dedupeId = 0;

/**
 * @constructor
 * @extends {Function}
 */
function MixinFunction() {}
/** @type {(WeakMap | undefined)} */
MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */
MixinFunction.prototype.__mixinSet;

var dedupingMixin = exports.dedupingMixin = function dedupingMixin(mixin) {
  var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
  }
  // maintain a unique id for each mixin
  var mixinDedupeId = dedupeId++;
  function dedupingMixin(base) {
    var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    var map = mixinApplications;
    var extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */mixin(base);
      map.set(base, extended);
    }
    // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.
    var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Handler = undefined;

var _Class = __webpack_require__(20);

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = exports.Handler = _Class.Class.extend({
	initialize: function initialize(map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function enable() {
		if (this._enabled) {
			return this;
		}

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function disable() {
		if (!this._enabled) {
			return this;
		}

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function enabled() {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.microTask = exports.idlePeriod = exports.animationFrame = exports.timeOut = undefined;

__webpack_require__(2);

/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

// Microtask implemented using Mutation Observer
var microtaskCurrHandle = 0;
var microtaskLastHandle = 0;
var microtaskCallbacks = [];
var microtaskNodeContent = 0;
var microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

function microtaskFlush() {
  var len = microtaskCallbacks.length;
  for (var i = 0; i < len; i++) {
    var cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

var timeOut = exports.timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} delay Time to wait before calling callbacks in ms
   * @return {AsyncInterface} An async timeout interface
   */
  after: function after(delay) {
    return {
      run: function run(fn) {
        return setTimeout(fn, delay);
      },

      cancel: window.clearTimeout.bind(window)
    };
  },

  /**
   * Enqueues a function called in the next task.
   *
   * @memberof Polymer.Async.timeOut
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.setTimeout.bind(window),
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.clearTimeout.bind(window)
};

var animationFrame = exports.animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof Polymer.Async.animationFrame
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.requestAnimationFrame.bind(window),
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.cancelAnimationFrame.bind(window)
};

var idlePeriod = exports.idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {function(IdleDeadline)} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: function run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },

  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: function cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }
};

var microTask = exports.microTask = {

  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof Polymer.Async.microTask
   * @param {Function} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run: function run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },


  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof Polymer.Async.microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: function cancel(handle) {
    var idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Earth = undefined;

var _CRS = __webpack_require__(47);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = exports.Earth = Util.extend({}, _CRS.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function distance(latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDebouncer = exports.flush = exports.matchesSelector = exports.dom = exports.DomApi = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

__webpack_require__(34);

var _flattenedNodesObserver = __webpack_require__(67);

var _flush = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var p = Element.prototype;
/**
 * @const {function(this:Element, string): boolean}
 */
var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @memberof Polymer.dom
 * @param {!Element} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
var matchesSelector = function matchesSelector(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};

/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 */

var DomApi = function () {

  /**
   * @param {Node} node Node for which to create a Polymer.dom helper object.
   */
  function DomApi(node) {
    _classCallCheck(this, DomApi);

    this.node = node;
  }

  /**
   * Returns an instance of `Polymer.FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {Function} callback Called when direct or distributed children
   *   of this element changes
   * @return {Polymer.FlattenedNodesObserver} Observer instance
   */


  _createClass(DomApi, [{
    key: 'observeNodes',
    value: function observeNodes(callback) {
      return new _flattenedNodesObserver.FlattenedNodesObserver(this.node, callback);
    }

    /**
     * Disconnects an observer previously created via `observeNodes`
     *
     * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
     *   to disconnect.
     */

  }, {
    key: 'unobserveNodes',
    value: function unobserveNodes(observerHandle) {
      observerHandle.disconnect();
    }

    /**
     * Provided as a backwards-compatible API only.  This method does nothing.
     */

  }, {
    key: 'notifyObserver',
    value: function notifyObserver() {}

    /**
     * Returns true if the provided node is contained with this element's
     * light-DOM children or shadow root, including any nested shadow roots
     * of children therein.
     *
     * @param {Node} node Node to test
     * @return {boolean} Returns true if the given `node` is contained within
     *   this element's light or shadow DOM.
     */

  }, {
    key: 'deepContains',
    value: function deepContains(node) {
      if (this.node.contains(node)) {
        return true;
      }
      var n = node;
      var doc = node.ownerDocument;
      // walk from node to `this` or `document`
      while (n && n !== doc && n !== this.node) {
        // use logical parentnode, or native ShadowRoot host
        n = n.parentNode || n.host;
      }
      return n === this.node;
    }

    /**
     * Returns the root node of this node.  Equivalent to `getRoodNode()`.
     *
     * @return {Node} Top most element in the dom tree in which the node
     * exists. If the node is connected to a document this is either a
     * shadowRoot or the document; otherwise, it may be the node
     * itself or a node or document fragment containing it.
     */

  }, {
    key: 'getOwnerRoot',
    value: function getOwnerRoot() {
      return this.node.getRootNode();
    }

    /**
     * For slot elements, returns the nodes assigned to the slot; otherwise
     * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
     *
     * @return {Array<Node>} Array of assigned nodes
     */

  }, {
    key: 'getDistributedNodes',
    value: function getDistributedNodes() {
      return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
    }

    /**
     * Returns an array of all slots this element was distributed to.
     *
     * @return {Array<HTMLSlotElement>} Description
     */

  }, {
    key: 'getDestinationInsertionPoints',
    value: function getDestinationInsertionPoints() {
      var ip$ = [];
      var n = this.node.assignedSlot;
      while (n) {
        ip$.push(n);
        n = n.assignedSlot;
      }
      return ip$;
    }

    /**
     * Calls `importNode` on the `ownerDocument` for this node.
     *
     * @param {Node} node Node to import
     * @param {boolean} deep True if the node should be cloned deeply during
     *   import
     * @return {Node} Clone of given node imported to this owner document
     */

  }, {
    key: 'importNode',
    value: function importNode(node, deep) {
      var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
      return doc.importNode(node, deep);
    }

    /**
     * @return {Array} Returns a flattened list of all child nodes and nodes assigned
     * to child slots.
     */

  }, {
    key: 'getEffectiveChildNodes',
    value: function getEffectiveChildNodes() {
      return _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(this.node);
    }

    /**
     * Returns a filtered list of flattened child elements for this element based
     * on the given selector.
     *
     * @param {string} selector Selector to filter nodes against
     * @return {Array<HTMLElement>} List of flattened child elements
     */

  }, {
    key: 'queryDistributedElements',
    value: function queryDistributedElements(selector) {
      var c$ = this.getEffectiveChildNodes();
      var list = [];
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
          list.push(c);
        }
      }
      return list;
    }

    /**
     * For shadow roots, returns the currently focused element within this
     * shadow root.
     *
     * @return {Node|undefined} Currently focused element
     */

  }, {
    key: 'activeElement',
    get: function get() {
      var node = this.node;
      return node._activeElement !== undefined ? node._activeElement : node.activeElement;
    }
  }]);

  return DomApi;
}();

function forwardMethods(proto, methods) {
  var _loop = function _loop(i) {
    var method = methods[i];
    proto[method] = /** @this {DomApi} */function () {
      return this.node[method].apply(this.node, arguments);
    };
  };

  for (var i = 0; i < methods.length; i++) {
    _loop(i);
  }
}

function forwardReadOnlyProperties(proto, properties) {
  var _loop2 = function _loop2(i) {
    var name = properties[i];
    Object.defineProperty(proto, name, {
      get: function get() {
        return (/** @type {DomApi} */this.node[name]
        );
      },
      configurable: true
    });
  };

  for (var i = 0; i < properties.length; i++) {
    _loop2(i);
  }
}

function forwardProperties(proto, properties) {
  var _loop3 = function _loop3(i) {
    var name = properties[i];
    Object.defineProperty(proto, name, {
      get: function get() {
        return (/** @type {DomApi} */this.node[name]
        );
      },
      set: function set(value) {
        /** @type {DomApi} */this.node[name] = value;
      },
      configurable: true
    });
  };

  for (var i = 0; i < properties.length; i++) {
    _loop3(i);
  }
}

forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

/**
 * Event API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is an `Event`.
 */

var EventApi = function () {
  function EventApi(event) {
    _classCallCheck(this, EventApi);

    this.event = event;
  }

  /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {Node} The node this event was dispatched to
   */


  _createClass(EventApi, [{
    key: 'rootTarget',
    get: function get() {
      return this.event.composedPath()[0];
    }

    /**
     * Returns the local (re-targeted) target for this event.
     *
     * @return {Node} The local (re-targeted) target for this event.
     */

  }, {
    key: 'localTarget',
    get: function get() {
      return this.event.target;
    }

    /**
     * Returns the `composedPath` for this event.
     */

  }, {
    key: 'path',
    get: function get() {
      return this.event.composedPath();
    }
  }]);

  return EventApi;
}();

exports.DomApi = DomApi;
var dom = exports.dom = function dom(obj) {
  obj = obj || document;
  if (!obj.__domApi) {
    var helper = void 0;
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApi(obj);
    }
    obj.__domApi = helper;
  }
  return obj.__domApi;
};

exports.matchesSelector = matchesSelector;
exports.flush = _flush.flush;
exports.addDebouncer = _flush.enqueueDebouncer;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.featureGroup = exports.FeatureGroup = undefined;

var _LayerGroup = __webpack_require__(46);

var _LatLngBounds = __webpack_require__(10);

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = exports.FeatureGroup = _LayerGroup.LayerGroup.extend({

	addLayer: function addLayer(layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		_LayerGroup.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', { layer: layer });
	},

	removeLayer: function removeLayer(layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		_LayerGroup.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', { layer: layer });
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function setStyle(style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function bringToFront() {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function bringToBack() {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function getBounds() {
		var bounds = new _LatLngBounds.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = exports.featureGroup = function featureGroup(layers) {
	return new FeatureGroup(layers);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Evented = exports.Events = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _Class = __webpack_require__(20);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = exports.Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
  * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  *
  * @alternative
  * @method on(eventMap: Object): this
  * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  */
	on: function on(types, fn, context) {

		// types can be a map of types/handlers
		if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}
		} else {
			// types can be a string of space-separated words
			types = Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
  * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  *
  * @alternative
  * @method off(eventMap: Object): this
  * Removes a set of type/listener pairs.
  *
  * @alternative
  * @method off: this
  * Removes all listeners to all events on the object.
  */
	off: function off(types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;
		} else if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}
		} else {
			types = Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function _on(type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = { fn: fn, ctx: context },
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function _off(type, fn, context) {
		var listeners, i, len;

		if (!this._events) {
			return;
		}

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) {
					continue;
				}
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function fire(type, data, propagate) {
		if (!this.listens(type, propagate)) {
			return this;
		}

		var event = Util.extend({}, data, { type: type, target: this });

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = this._firingCount + 1 || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function listens(type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) {
			return true;
		}

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) {
					return true;
				}
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function once(types, fn, context) {

		if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = Util.bind(function () {
			this.off(types, fn, context).off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this.on(types, fn, context).on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function addEventParent(obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[Util.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function removeEventParent(obj) {
		if (this._eventParents) {
			delete this._eventParents[Util.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function _propagateEvent(e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, Util.extend({ layer: e.target }, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = exports.Evented = _Class.Class.extend(Events);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Class = Class;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function NewClass() {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		Util.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = Util.extend(Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	Util.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) {
			return;
		}

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};

// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	Util.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	Util.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) {
	// (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (!L || !L.Mixin) {
		return;
	}

	includes = Util.isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Transformation = Transformation;
exports.toTransformation = toTransformation;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */

// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (Util.isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function transform(point, scale) {
		// (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function _transform(point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function untransform(point, scale) {
		scale = scale || 1;
		return new _Point.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coeficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.control = exports.Control = undefined;

var _Class = __webpack_require__(20);

var _Map = __webpack_require__(7);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = exports.Control = _Class.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
	},

	/* @section
  * Classes extending L.Control will inherit the following methods:
  *
  * @method getPosition: string
  * Returns the position of the control.
  */
	getPosition: function getPosition() {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function setPosition(position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function getContainer() {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function addTo(map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function remove() {
		if (!this._map) {
			return this;
		}

		DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function _refocusOnMap(e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = exports.control = function control(options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
_Map.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function addControl(control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function removeControl(control) {
		control.remove();
		return this;
	},

	_initControlPos: function _initControlPos() {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer = DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function _clearControlPos() {
		for (var i in this._controlCorners) {
			DomUtil.remove(this._controlCorners[i]);
		}
		DomUtil.remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Path = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = exports.Path = _Layer.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function beforeAdd(map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function onAdd() {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function onRemove() {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function redraw() {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function setStyle(style) {
		Util.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function bringToFront() {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function bringToBack() {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function getElement() {
		return this._path;
	},

	_reset: function _reset() {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function _clickTolerance() {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (_Browser.touch ? 10 : 0);
	}
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.simplify = simplify;
exports.pointToSegmentDistance = pointToSegmentDistance;
exports.closestPointOnSegment = closestPointOnSegment;
exports.clipSegment = clipSegment;
exports._getEdgeIntersection = _getEdgeIntersection;
exports._getBitCode = _getBitCode;
exports._sqClosestPointOnSegment = _sqClosestPointOnSegment;
exports.isFlat = isFlat;
exports._flat = _flat;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

	// stage 1: vertex reduction
	points = _reducePoints(points, sqTolerance);

	// stage 2: Douglas-Peucker simplification
	points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
	    ArrayConstructor = (typeof Uint8Array === 'undefined' ? 'undefined' : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,
	    markers = new ArrayConstructor(len);

	markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
	    newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	    index,
	    i,
	    sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
	    codeB = _getBitCode(b, bounds),
	    codeOut,
	    p,
	    newCode;

	// save 2nd code to avoid calculating it on the next segment
	_lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
	    dy = b.y - a.y,
	    min = bounds.min,
	    max = bounds.max,
	    x,
	    y;

	if (code & 8) {
		// top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;
	} else if (code & 4) {
		// bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;
	} else if (code & 2) {
		// right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;
	} else if (code & 1) {
		// left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new _Point.Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) {
		// left
		code |= 1;
	} else if (p.x > bounds.max.x) {
		// right
		code |= 2;
	}

	if (p.y < bounds.min.y) {
		// bottom
		code |= 4;
	} else if (p.y > bounds.max.y) {
		// top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
	    dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
	    y = p1.y,
	    dx = p2.x - x,
	    dy = p2.y - y,
	    dot = dx * dx + dy * dy,
	    t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new _Point.Point(x, y);
}

// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !Util.isArray(latlngs[0]) || _typeof(latlngs[0][0]) !== 'object' && typeof latlngs[0][0] !== 'undefined';
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathFromUrl = exports.resolveUrl = exports.resolveCss = undefined;

__webpack_require__(2);

var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var workingURL = void 0;
var resolveDoc = void 0;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  // Lazy feature detection.
  if (workingURL === undefined) {
    workingURL = false;
    try {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = u.href === 'http://a/c%20d';
    } catch (e) {
      // silently fail
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    return new URL(url, baseURI).href;
  }
  // Fallback to creating an anchor into a disconnected document.
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}

/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
    return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
  });
}

/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}

exports.resolveCss = resolveCss;
exports.resolveUrl = resolveUrl;
exports.pathFromUrl = pathFromUrl;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDeep = undefined;
exports.isPath = isPath;
exports.root = root;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
exports.translate = translate;
exports.matches = matches;
exports.normalize = normalize;
exports.split = split;
exports.get = get;
exports.set = set;

__webpack_require__(2);

function isPath(path) {
  return path.indexOf('.') >= 0;
}

function root(path) {
  var dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}

function matches(base, path) {
  return base === path || isAncestor(base, path) || isDescendant(base, path);
}

function normalize(path) {
  if (Array.isArray(path)) {
    var parts = [];
    for (var i = 0; i < path.length; i++) {
      var args = path[i].toString().split('.');
      for (var j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }
  return path.toString().split('.');
}

function get(root, path, info) {
  var prop = root;
  var parts = split(path);
  // Loop over path parts[0..n-1] and dereference
  for (var i = 0; i < parts.length; i++) {
    if (!prop) {
      return;
    }
    var part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}

function set(root, path, value) {
  var prop = root;
  var parts = split(path);
  var last = parts[parts.length - 1];
  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (var i = 0; i < parts.length - 1; i++) {
      var part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    // Set value to object at end of path
    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }
  return parts.join('.');
}

var isDeep = exports.isDeep = isPath;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Debouncer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

__webpack_require__(13);

__webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
var AsyncModule = void 0; // eslint-disable-line no-unused-vars

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 * @memberof Polymer
 */

var Debouncer = function () {
  function Debouncer() {
    _classCallCheck(this, Debouncer);

    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncModule} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   */


  _createClass(Debouncer, [{
    key: 'setConfig',
    value: function setConfig(asyncModule, callback) {
      var _this = this;

      this._asyncModule = asyncModule;
      this._callback = callback;
      this._timer = this._asyncModule.run(function () {
        _this._timer = null;
        _this._callback();
      });
    }
    /**
     * Cancels an active debouncer and returns a reference to itself.
     */

  }, {
    key: 'cancel',
    value: function cancel() {
      if (this.isActive()) {
        this._asyncModule.cancel(this._timer);
        this._timer = null;
      }
    }
    /**
     * Flushes an active debouncer and returns a reference to itself.
     */

  }, {
    key: 'flush',
    value: function flush() {
      if (this.isActive()) {
        this.cancel();
        this._callback();
      }
    }
    /**
     * Returns true if the debouncer is active.
     *
     * @return {boolean} True if active.
     */

  }, {
    key: 'isActive',
    value: function isActive() {
      return this._timer != null;
    }
    /**
     * Creates a debouncer if no debouncer is passed as a parameter
     * or it cancels an active debouncer otherwise. The following
     * example shows how a debouncer can be called multiple times within a
     * microtask and "debounced" such that the provided callback function is
     * called once. Add this method to a custom element:
     *
     * _debounceWork() {
     *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
     *       Polymer.Async.microTask, () => {
     *     this._doWork();
     *   });
     * }
     *
     * If the `_debounceWork` method is called multiple times within the same
     * microtask, the `_doWork` function will be called only once at the next
     * microtask checkpoint.
     *
     * Note: In testing it is often convenient to avoid asynchrony. To accomplish
     * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
     * `Polymer.flush`. For example, extend the above example by adding
     * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
     * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
     * the debouncer has completed.
     *
     * @param {Debouncer?} debouncer Debouncer object.
     * @param {!AsyncModule} asyncModule Object with Async interface
     * @param {function()} callback Callback to run.
     * @return {!Debouncer} Returns a debouncer object.
     */

  }], [{
    key: 'debounce',
    value: function debounce(debouncer, asyncModule, callback) {
      if (debouncer instanceof Debouncer) {
        debouncer.cancel();
      } else {
        debouncer = new Debouncer();
      }
      debouncer.setConfig(asyncModule, callback);
      return debouncer;
    }
  }]);

  return Debouncer;
}();

exports.Debouncer = Debouncer;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Polymer = undefined;

var _class = __webpack_require__(99);

var Polymer = exports.Polymer = function Polymer(info) {
  // if input is a `class` (aka a function with a prototype), use the prototype
  // remember that the `constructor` will never be called
  var klass = void 0;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = (0, _class.Class)(info);
  }
  customElements.define(klass.is, /** @type {!HTMLElement} */klass);
  return klass;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionalMutableData = exports.MutableData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _mixin = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
  var isObject = void 0;
  if (mutableData) {
    isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
    // Pull `old` for Objects from temp cache, but treat `null` as a primitive
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  // Strict equality check, but return false for NaN===NaN
  var shouldChange = old !== value && (old === old || value === value);
  // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}

var MutableData = exports.MutableData = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  var MutableData = function (_superClass) {
    _inherits(MutableData, _superClass);

    function MutableData() {
      _classCallCheck(this, MutableData);

      return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
    }

    _createClass(MutableData, [{
      key: '_shouldPropertyChange',

      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * This method pulls the value to dirty check against from the `__dataTemp`
       * cache (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      value: function _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, true);
      }
    }]);

    return MutableData;
  }(superClass);
  /** @type {boolean} */


  MutableData.prototype.mutableData = false;

  return MutableData;
});

var OptionalMutableData = exports.OptionalMutableData = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  var OptionalMutableData = function (_superClass2) {
    _inherits(OptionalMutableData, _superClass2);

    function OptionalMutableData() {
      _classCallCheck(this, OptionalMutableData);

      return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
    }

    _createClass(OptionalMutableData, [{
      key: '_shouldPropertyChange',


      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * When `this.mutableData` is true on this instance, this method
       * pulls the value to dirty check against from the `__dataTemp` cache
       * (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      value: function _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, this.mutableData);
      }
    }], [{
      key: 'properties',
      get: function get() {
        return {
          /**
           * Instance-level flag for configuring the dirty-checking strategy
           * for this element.  When true, Objects and Arrays will skip dirty
           * checking, otherwise strict equality checking will be used.
           */
          mutableData: Boolean
        };
      }
    }]);

    return OptionalMutableData;
  }(superClass);

  return OptionalMutableData;
});

// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Icon = undefined;
exports.icon = icon;

var _Class = __webpack_require__(20);

var _Util = __webpack_require__(0);

var _Point = __webpack_require__(3);

var _Browser = __webpack_require__(4);

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = exports.Icon = _Class.Class.extend({

	/* @section
  * @aka Icon options
  *
  * @option iconUrl: String = null
  * **(required)** The URL to the icon image (absolute or relative to your script path).
  *
  * @option iconRetinaUrl: String = null
  * The URL to a retina sized version of the icon image (absolute or relative to your
  * script path). Used for Retina screen devices.
  *
  * @option iconSize: Point = null
  * Size of the icon image in pixels.
  *
  * @option iconAnchor: Point = null
  * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  * will be aligned so that this point is at the marker's geographical location. Centered
  * by default if size is specified, also can be set in CSS with negative margins.
  *
  * @option popupAnchor: Point = null
  * The coordinates of the point from which popups will "open", relative to the icon anchor.
  *
  * @option shadowUrl: String = null
  * The URL to the icon shadow image. If not specified, no shadow image will be created.
  *
  * @option shadowRetinaUrl: String = null
  *
  * @option shadowSize: Point = null
  * Size of the shadow image in pixels.
  *
  * @option shadowAnchor: Point = null
  * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  * as iconAnchor if not specified).
  *
  * @option className: String = ''
  * A custom class name to assign to both icon and shadow images. Empty by default.
  */

	initialize: function initialize(options) {
		(0, _Util.setOptions)(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function createIcon(oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function createShadow(oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function _createIcon(name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function _setIconStyles(img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = (0, _Point.toPoint)(sizeOption),
		    anchor = (0, _Point.toPoint)(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = -anchor.x + 'px';
			img.style.marginTop = -anchor.y + 'px';
		}

		if (size) {
			img.style.width = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function _createImg(src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function _getIconUrl(name) {
		return _Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});

// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Renderer = undefined;

var _Layer = __webpack_require__(12);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = exports.Renderer = _Layer.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
		Util.stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function onAdd() {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function onRemove() {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function getEvents() {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function _onAnimZoom(ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function _onZoom() {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function _updateTransform(center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),
		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (Browser.any3d) {
			DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function _reset() {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function _onZoomEnd() {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function _updatePaths() {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function _update() {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new _Bounds.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CircleMarker = undefined;
exports.circleMarker = circleMarker;

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = exports.CircleMarker = _Path.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function initialize(latlng, options) {
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function setLatLng(latlng) {
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this.redraw();
		return this.fire('move', { latlng: this._latlng });
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function setRadius(radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function getRadius() {
		return this._radius;
	},

	setStyle: function setStyle(options) {
		var radius = options && options.radius || this._radius;
		_Path.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function _project() {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function _updateBounds() {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new _Bounds.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function _update() {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function _updatePath() {
		this._renderer._updateCircle(this);
	},

	_empty: function _empty() {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});

// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStyles = exports.registrations = exports.instanceCount = exports.ElementMixin = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports._regLog = _regLog;
exports.register = register;
exports.dumpRegistrations = dumpRegistrations;

__webpack_require__(2);

var _settings = __webpack_require__(34);

var _mixin = __webpack_require__(13);

var _caseMap = __webpack_require__(35);

var caseMap$0 = _interopRequireWildcard(_caseMap);

var _styleGather = __webpack_require__(58);

var _resolveUrl = __webpack_require__(25);

var _domModule = __webpack_require__(59);

var _propertyEffects = __webpack_require__(36);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ElementMixin = exports.ElementMixin = (0, _mixin.dedupingMixin)(function (base) {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_PropertyEffects}
   */
  var polymerElementBase = (0, _propertyEffects.PropertyEffects)(base);

  var caseMap = caseMap$0;

  /**
   * Returns the `properties` object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   *
   * @param {HTMLElement} klass Element class
   * @return {Object} Object containing own properties for this class
   * @private
   */
  function ownPropertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
      klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
      /** @type PolymerElementConstructor */klass.properties : {};
    }
    return klass.__ownProperties;
  }

  /**
   * Returns the `observers` array specifically on `klass`. Use for
   * setting up observers.
   *
   * @param {HTMLElement} klass Element class
   * @return {Array} Array containing own observers for this class
   * @private
   */
  function ownObserversForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
      klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
      /** @type PolymerElementConstructor */klass.observers : [];
    }
    return klass.__ownObservers;
  }

  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   *
   * @param {Object} flattenedProps Bag to collect flattened properties into
   * @param {Object} props Bag of properties to add to `flattenedProps`
   * @return {Object} The input `flattenedProps` bag
   * @private
   */
  function flattenProperties(flattenedProps, props) {
    for (var p in props) {
      var o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   * @suppress {missingProperties} class.prototype is not a property for some reason?
   * @private
   */
  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
      klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
      var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
      }
    }
    return klass.__classProperties;
  }

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */
  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
      klass.__classPropertyDefaults = null;
      var props = propertiesForClass(klass);
      for (var p in props) {
        var info = props[p];
        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }
    return klass.__classPropertyDefaults;
  }

  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {PolymerElementConstructor} klass Element class
   * @return {boolean} True if all metaprogramming for this class has been
   *   completed
   * @private
   */
  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
  }

  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClassAndSuper(klass) {
    var proto = /** @type PolymerElementConstructor */klass.prototype;
    var superCtor = Object.getPrototypeOf(proto).constructor;
    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }
    finalizeClass(klass);
  }

  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClass(klass) {
    klass.__finalized = true;
    var proto = /** @type PolymerElementConstructor */klass.prototype;
    if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
      register(proto);
    }
    var props = ownPropertiesForClass(klass);
    if (props) {
      finalizeProperties(proto, props);
    }
    var observers = ownObserversForClass(klass);
    if (observers) {
      finalizeObservers(proto, observers, props);
    }
    // note: create "working" template that is finalized at instance time
    var template = /** @type PolymerElementConstructor */klass.template;
    if (template) {
      if (typeof template === 'string') {
        var t = document.createElement('template');
        t.innerHTML = template;
        template = t;
      } else {
        template = template.cloneNode(true);
      }
      proto._template = template;
    }
  }

  /**
   * Configures a `proto` based on a `properties` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *    and effects to
   * @param {Object} properties Flattened bag of property descriptors for
   *    this class
   * @private
   */
  function finalizeProperties(proto, properties) {
    for (var p in properties) {
      createPropertyFromConfig(proto, p, properties[p], properties);
    }
  }

  /**
   * Configures a `proto` based on a `observers` array.
   * Leverages `PropertyEffects` to create observers.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {Object} observers Flattened array of observer descriptors for
   *   this class
   * @param {Object} dynamicFns Object containing keys for any properties
   *   that are functions and should trigger the effect when the function
   *   reference is changed
   * @private
   */
  function finalizeObservers(proto, observers, dynamicFns) {
    for (var i = 0; i < observers.length; i++) {
      proto._createMethodObserver(observers[i], dynamicFns);
    }
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should may contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttriute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   * Also consider adding warnings when an effect cannot be changed.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @private
   */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }

  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {!HTMLTemplateElement} template Template to process and bind
   * @param {string} baseURI URL against which to resolve urls in
   *   style element cssText
   * @param {string} is Tag name (or type extension name) for this element
   * @param {string=} ext For type extensions, the tag name that was extended
   * @private
   */
  function finalizeTemplate(proto, template, baseURI, is, ext) {
    // support `include="module-name"`
    var cssText = (0, _styleGather.cssFromModuleImports)(is) + (0, _styleGather.cssFromTemplate)(template, baseURI);
    if (cssText) {
      var style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }
    proto._bindTemplate(template);
  }

  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   */

  var PolymerElement = function (_polymerElementBase) {
    _inherits(PolymerElement, _polymerElementBase);

    _createClass(PolymerElement, null, [{
      key: 'finalize',


      /**
       * Called automatically when the first element instance is created to
       * ensure that class finalization work has been completed.
       * May be called by users to eagerly perform class finalization work
       * prior to the creation of the first element instance.
       *
       * Class finalization work generally includes meta-programming such as
       * creating property accessors and any property effect metadata needed for
       * the features used.
       *
       * @public
       */
      value: function finalize() {
        if (!hasClassFinalized(this)) {
          finalizeClassAndSuper(this);
        }
      }

      /**
       * Returns the template that will be stamped into this element's shadow root.
       *
       * If a `static get is()` getter is defined, the default implementation
       * will return the first `<template>` in a `dom-module` whose `id`
       * matches this element's `is`.
       *
       * Users may override this getter to return an arbitrary template
       * (in which case the `is` getter is unnecessary). The template returned
       * may be either an `HTMLTemplateElement` or a string that will be
       * automatically parsed into a template.
       *
       * Note that when subclassing, if the super class overrode the default
       * implementation and the subclass would like to provide an alternate
       * template via a `dom-module`, it should override this getter and
       * return `Polymer.DomModule.import(this.is, 'template')`.
       *
       * If a subclass would like to modify the super class template, it should
       * clone it rather than modify it in place.  If the getter does expensive
       * work such as cloning/modifying a template, it should memoize the
       * template for maximum performance:
       *
       *   let memoizedTemplate;
       *   class MySubClass extends MySuperClass {
       *     static get template() {
       *       if (!memoizedTemplate) {
       *         memoizedTemplate = super.template.cloneNode(true);
       *         let subContent = document.createElement('div');
       *         subContent.textContent = 'This came from MySubClass';
       *         memoizedTemplate.content.appendChild(subContent);
       *       }
       *       return memoizedTemplate;
       *     }
       *   }
       *
       * @return {HTMLTemplateElement|string} Template to be stamped
       */

    }, {
      key: 'observedAttributes',


      /**
       * Standard Custom Elements V1 API.  The default implementation returns
       * a list of dash-cased attributes based on a flattening of all properties
       * declared in `static get properties()` for this element and any
       * superclasses.
       *
       * @return {Array} Observed attribute list
       */
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
          var list = [];
          var properties = propertiesForClass(this);
          for (var prop in properties) {
            list.push((0, _caseMap.camelToDashCase)(prop));
          }
          this.__observedAttributes = list;
        }
        return this.__observedAttributes;
      }
    }, {
      key: 'template',
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
          this._template = _domModule.DomModule && _domModule.DomModule.import(
          /** @type PolymerElementConstructor*/this.is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
        }
        return this._template;
      }

      /**
       * Path matching the url from which the element was imported.
       * This path is used to resolve url's in template style cssText.
       * The `importPath` property is also set on element instances and can be
       * used to create bindings relative to the import path.
       * Defaults to the path matching the url containing a `dom-module` element
       * matching this element's static `is` property.
       * Note, this path should contain a trailing `/`.
       *
       * @return {string} The import path for this element class
       */

    }, {
      key: 'importPath',
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
          var module = _domModule.DomModule && _domModule.DomModule.import( /** @type PolymerElementConstructor */this.is);
          this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
        }
        return this._importPath;
      }
    }]);

    function PolymerElement() {
      _classCallCheck(this, PolymerElement);

      /** @type {HTMLTemplateElement} */
      var _this = _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).call(this));

      _this._template;
      /** @type {string} */
      _this._importPath;
      /** @type {string} */
      _this.rootPath;
      /** @type {string} */
      _this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
      _this.root;
      /** @type {!Object<string, !Node>} */
      _this.$;
      return _this;
    }

    /**
     * Overrides the default `Polymer.PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @override
     * @suppress {invalidCasts}
     */


    _createClass(PolymerElement, [{
      key: '_initializeProperties',
      value: function _initializeProperties() {
        exports.instanceCount = instanceCount += 1;
        this.constructor.finalize();
        var importPath = this.constructor.importPath;
        // note: finalize template when we have access to `localName` to
        // avoid dependence on `is` for polyfilling styling.
        if (this._template && !this._template.__polymerFinalized) {
          this._template.__polymerFinalized = true;
          var baseURI = importPath ? (0, _resolveUrl.resolveUrl)(importPath) : '';
          finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
          /**@type {!HTMLElement}*/this.localName);
        }
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
        // set path defaults
        this.rootPath = _settings.rootPath;
        this.importPath = importPath;
        // apply property defaults...
        var p$ = propertyDefaultsForClass(this.constructor);
        if (!p$) {
          return;
        }
        for (var p in p$) {
          var info = p$[p];
          // Don't set default value if there is already an own property, which
          // happens when a `properties` property with default but no effects had
          // a property set (e.g. bound) by its host before upgrade
          if (!this.hasOwnProperty(p)) {
            var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
            // Set via `_setProperty` if there is an accessor, to enable
            // initializing readOnly property defaults
            if (this._hasAccessor(p)) {
              this._setPendingProperty(p, value, true);
            } else {
              this[p] = value;
            }
          }
        }
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `connectedCallback`.
       *
       * The default implementation enables the property effects system and
       * flushes any pending properties, and updates shimmed CSS properties
       * when using the ShadyCSS scoping/custom properties polyfill.
       *
       * @suppress {invalidCasts}
       */

    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        if (window.ShadyCSS && this._template) {
          window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
        }
        this._enableProperties();
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `disconnectedCallback`.
       */

    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {}

      /**
       * Stamps the element template.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        if (this._template) {
          this.root = this._stampTemplate(this._template);
          this.$ = this.root.$;
        }
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
      }

      /**
       * Implements `PropertyEffects`'s `_readyClients` call. Attaches
       * element dom by calling `_attachDom` with the dom stamped from the
       * element's template via `_stampTemplate`. Note that this allows
       * client dom to be attached to the element prior to any observers
       * running.
       *
       * @override
       */

    }, {
      key: '_readyClients',
      value: function _readyClients() {
        if (this._template) {
          this.root = this._attachDom( /** @type {StampedTemplate} */this.root);
        }
        // The super._readyClients here sets the clients initialized flag.
        // We must wait to do this until after client dom is created/attached
        // so that this flag can be checked to prevent notifications fired
        // during this process from being handled before clients are ready.
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
      }

      /**
       * Attaches an element's stamped dom to itself. By default,
       * this method creates a `shadowRoot` and adds the dom to it.
       * However, this method may be overridden to allow an element
       * to put its dom in another location.
       *
       * @throws {Error}
       * @suppress {missingReturn}
       * @param {StampedTemplate} dom to attach to the element.
       * @return {ShadowRoot} node to which the dom has been attached.
       */

    }, {
      key: '_attachDom',
      value: function _attachDom(dom) {
        if (this.attachShadow) {
          if (dom) {
            if (!this.shadowRoot) {
              this.attachShadow({ mode: 'open' });
            }
            this.shadowRoot.appendChild(dom);
            return this.shadowRoot;
          }
          return null;
        } else {
          throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
          'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
        }
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `attributeChangedCallback`.
       *
       * By default, attributes declared in `properties` metadata are
       * deserialized using their `type` information to properties of the
       * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
       * properties.
       *
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @override
       */

    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          var property = caseMap.dashToCamelCase(name);
          var type = propertiesForClass(this.constructor)[property].type;
          if (!this._hasReadOnlyEffect(property)) {
            this._attributeToProperty(name, value, type);
          }
        }
      }

      /**
       * When using the ShadyCSS scoping and custom property shim, causes all
       * shimmed styles in this element (and its subtree) to be updated
       * based on current custom property values.
       *
       * The optional parameter overrides inline custom property styles with an
       * object of properties where the keys are CSS properties, and the values
       * are strings.
       *
       * Example: `this.updateStyles({'--color': 'blue'})`
       *
       * These properties are retained unless a value of `null` is set.
       *
       * @param {Object=} properties Bag of custom property key/values to
       *   apply to this element.
       * @suppress {invalidCasts}
       */

    }, {
      key: 'updateStyles',
      value: function updateStyles(properties) {
        if (window.ShadyCSS) {
          window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
        }
      }

      /**
       * Rewrites a given URL relative to a base URL. The base URL defaults to
       * the original location of the document containing the `dom-module` for
       * this element. This method will return the same URL before and after
       * bundling.
       *
       * @param {string} url URL to resolve.
       * @param {string=} base Optional base URL to resolve against, defaults
       * to the element's `importPath`
       * @return {string} Rewritten URL relative to base
       */

    }, {
      key: 'resolveUrl',
      value: function resolveUrl(url, base) {
        if (!base && this.importPath) {
          base = (0, _resolveUrl.resolveUrl)(this.importPath);
        }
        return (0, _resolveUrl.resolveUrl)(url, base);
      }

      /**
       * Overrides `PropertyAccessors` to add map of dynamic functions on
       * template info, for consumption by `PropertyEffects` template binding
       * code. This map determines which method templates should have accessors
       * created for them.
       *
       * @override
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }], [{
      key: '_parseTemplateContent',
      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
        templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
        return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
      }
    }]);

    return PolymerElement;
  }(polymerElementBase);

  return PolymerElement;
});

var instanceCount = exports.instanceCount = 0;
var registrations = exports.registrations = [];

function _regLog(prototype) {
  console.log('[' + prototype.is + ']: registered');
}

function register(prototype) {
  registrations.push(prototype);
  undefined && _regLog(prototype);
}

function dumpRegistrations() {
  registrations.forEach(_regLog);
}

var updateStyles = exports.updateStyles = function updateStyles(props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setSanitizeDOMValue = exports.sanitizeDOMValue = exports.setRootPath = exports.rootPath = exports.Settings = exports.useNativeCustomElements = exports.useNativeCSSProperties = exports.useShadow = undefined;

__webpack_require__(2);

var _resolveUrl = __webpack_require__(25);

/**
 * Legacy settings.
 * @namespace
 * @memberof Polymer
 */
var settings = undefined || {};
var useShadow = exports.useShadow = !window.ShadyDOM;
var useNativeCSSProperties = exports.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
var useNativeCustomElements = exports.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
exports.Settings = settings;

/**
 * Globally settable property that is automatically assigned to
 * `Polymer.ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `Polymer.rootPath` to provide a stable application mount path when
 * using client side routing.
 *
 * @memberof Polymer
 */

var rootPath = undefined || (0, _resolveUrl.pathFromUrl)(document.baseURI || window.location.href);

exports.rootPath = rootPath;
var setRootPath = exports.setRootPath = function setRootPath(path) {
  exports.rootPath = rootPath = path;
};

/**
 * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
 *
 *     Polymer = {
 *       sanitizeDOMValue: function(value, name, type, node) { ... }
 *     }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 * @memberof Polymer
 */
var sanitizeDOMValue = undefined;

exports.sanitizeDOMValue = sanitizeDOMValue;
var setSanitizeDOMValue = exports.setSanitizeDOMValue = function setSanitizeDOMValue(newSanitizeDOMValue) {
  exports.sanitizeDOMValue = sanitizeDOMValue = newSanitizeDOMValue;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dashToCamelCase = dashToCamelCase;
exports.camelToDashCase = camelToDashCase;

__webpack_require__(2);

var caseMap = {};
var DASH_TO_CAMEL = /-[a-z]/g;
var CAMEL_TO_DASH = /([A-Z])/g;

function dashToCamelCase(dash) {
  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
    return m[1].toUpperCase();
  }));
}

function camelToDashCase(camel) {
  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertyEffects = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _path = __webpack_require__(26);

var _caseMap = __webpack_require__(35);

var caseMap = _interopRequireWildcard(_caseMap);

var _propertyAccessors = __webpack_require__(91);

var _templateStamp = __webpack_require__(92);

var _settings = __webpack_require__(34);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @const {Object} */
var CaseMap = caseMap;

// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
var dedupeId = 0;

/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */
var TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};

/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */
var DataTrigger = void 0; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */
var DataEffect = void 0; //eslint-disable-line no-unused-vars

var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */
function ensureOwnEffectMap(model, type) {
  var effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    for (var p in effects) {
      var protoFx = effects[p];
      var instFx = effects[p] = Array(protoFx.length);
      for (var i = 0; i < protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }
  return effects;
}

// -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {Object} props Bag of current property changes
 * @param {Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    var ran = false;
    var id = dedupeId++;
    for (var prop in props) {
      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }
    return ran;
  }
  return false;
}

/**
 * Runs a list of effects for a given property.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  var ran = false;
  var rootProperty = hasPaths ? (0, _path.root)(prop) : prop;
  var fxs = effects[rootProperty];
  if (fxs) {
    for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}

/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    var triggerPath = trigger.name;
    return triggerPath == path || trigger.structured && (0, _path.isAncestor)(triggerPath, path) || trigger.wildcard && (0, _path.isDescendant)(triggerPath, path);
  } else {
    return true;
  }
}

/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runObserverEffect(inst, property, props, oldProps, info) {
  var fn = inst[info.methodName];
  var changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.methodName + '` not defined');
  }
}

/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  var fxs = inst[TYPES.NOTIFY];
  var notified = void 0;
  var id = dedupeId++;
  // Try normal notify effects; if none, fall back to try path notification
  for (var prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.
  var host = void 0;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}

/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */
function notifyPath(inst, path, props) {
  var rootProperty = (0, _path.root)(path);
  if (rootProperty !== path) {
    var eventName = (0, _caseMap.camelToDashCase)(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}

/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} eventName The name of the event to send ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property changed, the path
 *   that changed (optional).
 * @private
 * @suppress {invalidCasts}
 */
function dispatchNotifyEvent(inst, eventName, value, path) {
  var detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
}

/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  var rootProperty = hasPaths ? (0, _path.root)(property) : property;
  var path = rootProperty != property ? property : null;
  var value = path ? (0, _path.get)(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property]; // specifically for .splices
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}

/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!PropertyEffectsType} inst Host element instance handling the notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @private
 */
function handleNotification(event, inst, fromProp, toPath, negate) {
  var value = void 0;
  var detail = /** @type {Object} */event.detail;
  var fromPath = detail && detail.path;
  if (fromPath) {
    toPath = (0, _path.translate)(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.target[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}

/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runReflectEffect(inst, property, props, oldProps, info) {
  var value = inst.__data[property];
  if (_settings.sanitizeDOMValue) {
    value = (0, _settings.sanitizeDOMValue)(value, info.attrName, 'attribute', /** @type {Node} */inst);
  }
  inst._propertyToAttribute(property, info.attrName, value);
}

/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {!Object} changedProps Bag of changed properties
 * @param {!Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  var computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    var inputProps = changedProps;
    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(oldProps, inst.__dataOld);
      Object.assign(changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}

/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runComputedEffect(inst, property, props, oldProps, info) {
  var result = runMethodEffect(inst, property, props, oldProps, info);
  var computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}

/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!PropertyEffectsType} inst The instance whose props are changing
 * @param {string | !Array<(string|number)>} path Path that has changed
 * @param {*} value Value of changed path
 * @private
 */
function computeLinkedPaths(inst, path, value) {
  var links = inst.__dataLinkedPaths;
  if (links) {
    var link = void 0;
    for (var a in links) {
      var b = links[a];
      if ((0, _path.isDescendant)(a, path)) {
        link = (0, _path.translate)(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if ((0, _path.isDescendant)(b, path)) {
        link = (0, _path.translate)(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}

// -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @private
 */
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
  nodeInfo.bindings.push(binding);
  // Add listener info to binding metadata
  if (shouldAddListener(binding)) {
    var _binding$parts$ = binding.parts[0],
        event = _binding$parts$.event,
        negate = _binding$parts$.negate;

    binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
    binding.listenerNegate = negate;
  }
  // Add "propagate" property effects to templateInfo
  var index = templateInfo.nodeInfoList.length;
  for (var i = 0; i < binding.parts.length; i++) {
    var part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}

/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 */
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      var dependencies = part.dependencies;
      var info = { index: index, binding: binding, part: part, evaluator: constructor };
      for (var j = 0; j < dependencies.length; j++) {
        var trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info: info, trigger: trigger
        });
      }
    }
  }
}

/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @private
 */
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  var node = nodeList[info.index];
  var binding = info.binding;
  var part = info.part;
  // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    var value = props[path];
    path = (0, _path.translate)(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    // Propagate value to child
    applyBindingValue(inst, node, binding, part, _value);
  }
}

/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!PropertyEffectsType} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @private
 */
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (_settings.sanitizeDOMValue) {
    value = (0, _settings.sanitizeDOMValue)(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
  } else {
    // Property binding
    var prop = binding.target;
    if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}

/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    var storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}

/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */
function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
}

/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!PropertyEffectsType} inst Instance that bas been previously bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @private
 */
function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  var nodeList = templateInfo.nodeList,
      nodeInfoList = templateInfo.nodeInfoList;

  if (nodeInfoList.length) {
    for (var i = 0; i < nodeInfoList.length; i++) {
      var info = nodeInfoList[i];
      var node = nodeList[i];
      var bindings = info.bindings;
      if (bindings) {
        for (var _i = 0; _i < bindings.length; _i++) {
          var binding = bindings[_i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}

/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @private
 */
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    var parts = binding.parts;
    // Copy literals from parts into storage for this binding
    var literals = new Array(parts.length);
    for (var j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    var target = binding.target;
    storage[target] = literals;
    // Configure properties with their literal parts
    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}

/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!PropertyEffectsType} inst Host element instance to handle notification event
 * @param {Binding} binding Binding metadata
 * @private
 */
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    var part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function (e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}

// -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @private
 */
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
  var info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo: methodInfo,
    dynamicFn: dynamicFn
  };
  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
}

/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */
function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  var context = inst._methodHost || inst;
  var fn = context[info.methodName];
  if (fn) {
    var args = marshalArgs(inst.__data, info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

var emptyArray = [];

// Regular expressions used for binding
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?'; // Group 2
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
var bindingRegex = new RegExp(EXPRESSION, "g");

/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */
function literalFromParts(parts) {
  var s = '';
  for (var i = 0; i < parts.length; i++) {
    var literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}

/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */
function parseMethod(expression) {
  // tries to match valid javascript property names
  var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    var methodName = m[1];
    var sig = { methodName: methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      var args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}

/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */
function parseArgs(argList, sig) {
  sig.args = argList.map(function (rawArg) {
    var arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}

/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */
function parseArg(rawArg) {
  // clean up whitespace
  var arg = rawArg.trim()
  // replace comma entity with comma
  .replace(/&comma;/g, ',')
  // repair extra escape sequences; note only commas strictly need
  // escaping, but we allow any other char to be escaped since its
  // likely users will do this
  .replace(/\\(.)/g, '\$1');
  // basic argument descriptor
  var a = {
    name: arg,
    value: '',
    literal: false
  };
  // detect literal value (must be String or Number)
  var fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch (fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  // if not literal, look for structured path
  if (!a.literal) {
    a.rootProperty = (0, _path.root)(arg);
    // detect structured path (has dots)
    a.structured = (0, _path.isPath)(arg);
    if (a.structured) {
      a.wildcard = arg.slice(-2) == '.*';
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}

/**
 * Gather the argument values for a method specified in the provided array
 * of argument metadata.
 *
 * The `path` and `value` arguments are used to fill in wildcard descriptor
 * when the method is being called as a result of a path notification.
 *
 * @param {Object} data Instance data storage object to read properties from
 * @param {!Array<!MethodArg>} args Array of argument metadata
 * @param {string} path Property/path name that triggered the method effect
 * @param {Object} props Bag of current property changes
 * @return {Array<*>} Array of argument values
 * @private
 */
function marshalArgs(data, args, path, props) {
  var values = [];
  for (var i = 0, l = args.length; i < l; i++) {
    var arg = args[i];
    var name = arg.name;
    var v = void 0;
    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = (0, _path.get)(data, name);
        // when data is not stored e.g. `splices`
        if (v === undefined) {
          v = props[name];
        }
      } else {
        v = data[name];
      }
    }
    if (arg.wildcard) {
      // Only send the actual path changed info if the change that
      // caused the observer to run matched the wildcard
      var baseChanged = name.indexOf(path + '.') === 0;
      var matches = path.indexOf(name) === 0 && !baseChanged;
      values[i] = {
        path: matches ? path : name,
        value: matches ? props[path] : v,
        base: v
      };
    } else {
      values[i] = v;
    }
  }
  return values;
}

// data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @private
 */
function _notifySplices(inst, array, path, splices) {
  var splicesPath = path + '.splices';
  inst.notifyPath(splicesPath, { indexSplices: splices });
  inst.notifyPath(path + '.length', array.length);
  // Null here to allow potentially large splice records to be GC'ed.
  inst.__data[splicesPath] = { indexSplices: null };
}

/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @private
 */
function notifySplice(inst, array, path, index, addedCount, removed) {
  _notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}

/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

var PropertyEffects = exports.PropertyEffects = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   */
  var propertyEffectsBase = (0, _templateStamp.TemplateStamp)((0, _propertyAccessors.PropertyAccessors)(superClass));

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */

  var PropertyEffects = function (_propertyEffectsBase) {
    _inherits(PropertyEffects, _propertyEffectsBase);

    function PropertyEffects() {
      _classCallCheck(this, PropertyEffects);

      /** @type {boolean} */
      var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

      _this.__dataClientsReady;
      /** @type {Array} */
      _this.__dataPendingClients;
      /** @type {Object} */
      _this.__dataToNotify;
      /** @type {Object} */
      _this.__dataLinkedPaths;
      /** @type {boolean} */
      _this.__dataHasPaths;
      /** @type {Object} */
      _this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */
      _this.__dataHost;
      /** @type {!Object} */
      _this.__dataTemp;
      /** @type {boolean} */
      _this.__dataClientsInitialized;
      /** @type {!Object} */
      _this.__data;
      /** @type {!Object} */
      _this.__dataPending;
      /** @type {!Object} */
      _this.__dataOld;
      /** @type {Object} */
      _this.__computeEffects;
      /** @type {Object} */
      _this.__reflectEffects;
      /** @type {Object} */
      _this.__notifyEffects;
      /** @type {Object} */
      _this.__propagateEffects;
      /** @type {Object} */
      _this.__observeEffects;
      /** @type {Object} */
      _this.__readOnly;
      /** @type {number} */
      _this.__dataCounter;
      /** @type {!TemplateInfo} */
      _this.__templateInfo;
      return _this;
    }

    _createClass(PropertyEffects, [{
      key: '_initializeProperties',
      value: function _initializeProperties() {
        _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
        hostStack.registerHost(this);
        this.__dataClientsReady = false;
        this.__dataPendingClients = null;
        this.__dataToNotify = null;
        this.__dataLinkedPaths = null;
        this.__dataHasPaths = false;
        // May be set on instance prior to upgrade
        this.__dataCompoundStorage = this.__dataCompoundStorage || null;
        this.__dataHost = this.__dataHost || null;
        this.__dataTemp = {};
        this.__dataClientsInitialized = false;
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to provide a
       * more efficient implementation of initializing properties from
       * the prototype on the instance.
       *
       * @override
       * @param {Object} props Properties to initialize on the prototype
       */

    }, {
      key: '_initializeProtoProperties',
      value: function _initializeProtoProperties(props) {
        this.__data = Object.create(props);
        this.__dataPending = Object.create(props);
        this.__dataOld = {};
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
       * `_setProperty`'s `shouldNotify: true`.
       *
       * @override
       * @param {Object} props Properties to initialize on the instance
       */

    }, {
      key: '_initializeInstanceProperties',
      value: function _initializeInstanceProperties(props) {
        var readOnly = this[TYPES.READ_ONLY];
        for (var prop in props) {
          if (!readOnly || !readOnly[prop]) {
            this.__dataPending = this.__dataPending || {};
            this.__dataOld = this.__dataOld || {};
            this.__data[prop] = this.__dataPending[prop] = props[prop];
          }
        }
      }

      // Prototype setup ----------------------------------------

      /**
       * Equivalent to static `addPropertyEffect` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_addPropertyEffect',
      value: function _addPropertyEffect(property, type, effect) {
        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
        // effects are accumulated into arrays per property based on type
        var effects = ensureOwnEffectMap(this, type)[property];
        if (!effects) {
          effects = this[type][property] = [];
        }
        effects.push(effect);
      }

      /**
       * Removes the given property effect.
       *
       * @param {string} property Property the effect was associated with
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object to remove
       */

    }, {
      key: '_removePropertyEffect',
      value: function _removePropertyEffect(property, type, effect) {
        var effects = ensureOwnEffectMap(this, type)[property];
        var idx = effects.indexOf(effect);
        if (idx >= 0) {
          effects.splice(idx, 1);
        }
      }

      /**
       * Returns whether the current prototype/instance has a property effect
       * of a certain type.
       *
       * @param {string} property Property name
       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasPropertyEffect',
      value: function _hasPropertyEffect(property, type) {
        var effects = this[type];
        return Boolean(effects && effects[property]);
      }

      /**
       * Returns whether the current prototype/instance has a "read only"
       * accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasReadOnlyEffect',
      value: function _hasReadOnlyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.READ_ONLY);
      }

      /**
       * Returns whether the current prototype/instance has a "notify"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasNotifyEffect',
      value: function _hasNotifyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.NOTIFY);
      }

      /**
       * Returns whether the current prototype/instance has a "reflect to attribute"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasReflectEffect',
      value: function _hasReflectEffect(property) {
        return this._hasPropertyEffect(property, TYPES.REFLECT);
      }

      /**
       * Returns whether the current prototype/instance has a "computed"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasComputedEffect',
      value: function _hasComputedEffect(property) {
        return this._hasPropertyEffect(property, TYPES.COMPUTE);
      }

      // Runtime ----------------------------------------

      /**
       * Sets a pending property or path.  If the root property of the path in
       * question had no accessor, the path is set, otherwise it is enqueued
       * via `_setPendingProperty`.
       *
       * This function isolates relatively expensive functionality necessary
       * for the public API (`set`, `setProperties`, `notifyPath`, and property
       * change listeners via {{...}} bindings), such that it is only done
       * when paths enter the system, and not at every propagation step.  It
       * also sets a `__dataHasPaths` flag on the instance which is used to
       * fast-path slower path-matching code in the property effects host paths.
       *
       * `path` can be a path string or array of path parts as accepted by the
       * public API.
       *
       * @param {string | !Array<number|string>} path Path to set
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify Set to true if this change should
       *  cause a property notification event dispatch
       * @param {boolean=} isPathNotification If the path being set is a path
       *   notification of an already changed value, as opposed to a request
       *   to set and notify the change.  In the latter `false` case, a dirty
       *   check is performed and then the value is set to the path before
       *   enqueuing the pending property change.
       * @return {boolean} Returns true if the property/path was enqueued in
       *   the pending changes bag.
       * @protected
       */

    }, {
      key: '_setPendingPropertyOrPath',
      value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
        if (isPathNotification || (0, _path.root)(Array.isArray(path) ? path[0] : path) !== path) {
          // Dirty check changes being set to a path against the actual object,
          // since this is the entry point for paths into the system; from here
          // the only dirty checks are against the `__dataTemp` cache to prevent
          // duplicate work in the same turn only. Note, if this was a notification
          // of a change already set to a path (isPathNotification: true),
          // we always let the change through and skip the `set` since it was
          // already dirty checked at the point of entry and the underlying
          // object has already been updated
          if (!isPathNotification) {
            var old = (0, _path.get)(this, path);
            path = /** @type {string} */(0, _path.set)(this, path, value);
            // Use property-accessor's simpler dirty check
            if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
              return false;
            }
          }
          this.__dataHasPaths = true;
          if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
            computeLinkedPaths(this, path, value);
            return true;
          }
        } else {
          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
            return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
          } else {
            this[path] = value;
          }
        }
        return false;
      }

      /**
       * Applies a value to a non-Polymer element/node's property.
       *
       * The implementation makes a best-effort at binding interop:
       * Some native element properties have side-effects when
       * re-setting the same value (e.g. setting `<input>.value` resets the
       * cursor position), so we do a dirty-check before setting the value.
       * However, for better interop with non-Polymer custom elements that
       * accept objects, we explicitly re-set object changes coming from the
       * Polymer world (which may include deep object changes without the
       * top reference changing), erring on the side of providing more
       * information.
       *
       * Users may override this method to provide alternate approaches.
       *
       * @param {Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       * @protected
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        // It is a judgment call that resetting primitives is
        // "bad" and resettings objects is also "good"; alternatively we could
        // implement a whitelist of tag & property values that should never
        // be reset (e.g. <input>.value && <select>.value)
        if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
          node[prop] = value;
        }
      }

      /**
       * Overrides the `PropertyAccessors` implementation to introduce special
       * dirty check logic depending on the property & value being set:
       *
       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
       * 2. Object set to simple property (e.g. 'prop': {...})
       *    Stored in `__dataTemp` and `__data`, dirty checked against
       *    `__dataTemp` by default implementation of `_shouldPropertyChange`
       * 3. Primitive value set to simple property (e.g. 'prop': 42)
       *    Stored in `__data`, dirty checked against `__data`
       *
       * The dirty-check is important to prevent cycles due to two-way
       * notification, but paths and objects are only dirty checked against any
       * previous value set during this turn via a "temporary cache" that is
       * cleared when the last `_propertiesChaged` exits. This is so:
       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
       *    due to array mutations like shift/unshift/splice; this is fine
       *    since path changes are dirty-checked at user entry points like `set`
       * b. dirty-checking for objects only lasts one turn to allow the user
       *    to mutate the object in-place and re-set it with the same identity
       *    and have all sub-properties re-propagated in a subsequent turn.
       *
       * The temp cache is not necessarily sufficient to prevent invalid array
       * paths, since a splice can happen during the same turn (with pathological
       * user code); we could introduce a "fixup" for temporarily cached array
       * paths if needed: https://github.com/Polymer/polymer/issues/4227
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify True if property should fire notification
       *   event (applies only for `notify: true` properties)
       * @return {boolean} Returns true if the property changed
       * @override
       */

    }, {
      key: '_setPendingProperty',
      value: function _setPendingProperty(property, value, shouldNotify) {
        var isPath = this.__dataHasPaths && (0, _path.isPath)(property);
        var prevProps = isPath ? this.__dataTemp : this.__data;
        if (this._shouldPropertyChange(property, value, prevProps[property])) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = this.__data[property];
          }
          // Paths are stored in temporary cache (cleared at end of turn),
          // which is used for dirty-checking, all others stored in __data
          if (isPath) {
            this.__dataTemp[property] = value;
          } else {
            this.__data[property] = value;
          }
          // All changes go into pending property bag, passed to _propertiesChanged
          this.__dataPending[property] = value;
          // Track properties that should notify separately
          if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
            this.__dataToNotify = this.__dataToNotify || {};
            this.__dataToNotify[property] = shouldNotify;
          }
          return true;
        }
        return false;
      }

      /**
       * Overrides base implementation to ensure all accessors set `shouldNotify`
       * to true, for per-property notification tracking.
       *
       * @override
       */

    }, {
      key: '_setProperty',
      value: function _setProperty(property, value) {
        if (this._setPendingProperty(property, value, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Overrides `PropertyAccessor`'s default async queuing of
       * `_propertiesChanged`: if `__dataReady` is false (has not yet been
       * manually flushed), the function no-ops; otherwise flushes
       * `_propertiesChanged` synchronously.
       *
       * @override
       */

    }, {
      key: '_invalidateProperties',
      value: function _invalidateProperties() {
        if (this.__dataReady) {
          this._flushProperties();
        }
      }

      /**
       * Enqueues the given client on a list of pending clients, whose
       * pending property changes can later be flushed via a call to
       * `_flushClients`.
       *
       * @param {Object} client PropertyEffects client to enqueue
       * @protected
       */

    }, {
      key: '_enqueueClient',
      value: function _enqueueClient(client) {
        this.__dataPendingClients = this.__dataPendingClients || [];
        if (client !== this) {
          this.__dataPendingClients.push(client);
        }
      }

      /**
       * Flushes any clients previously enqueued via `_enqueueClient`, causing
       * their `_flushProperties` method to run.
       *
       * @protected
       */

    }, {
      key: '_flushClients',
      value: function _flushClients() {
        if (!this.__dataClientsReady) {
          this.__dataClientsReady = true;
          this._readyClients();
          // Override point where accessors are turned on; importantly,
          // this is after clients have fully readied, providing a guarantee
          // that any property effects occur only after all clients are ready.
          this.__dataReady = true;
        } else {
          this.__enableOrFlushClients();
        }
      }

      // NOTE: We ensure clients either enable or flush as appropriate. This
      // handles two corner cases:
      // (1) clients flush properly when connected/enabled before the host
      // enables; e.g.
      //   (a) Templatize stamps with no properties and does not flush and
      //   (b) the instance is inserted into dom and
      //   (c) then the instance flushes.
      // (2) clients enable properly when not connected/enabled when the host
      // flushes; e.g.
      //   (a) a template is runtime stamped and not yet connected/enabled
      //   (b) a host sets a property, causing stamped dom to flush
      //   (c) the stamped dom enables.

    }, {
      key: '__enableOrFlushClients',
      value: function __enableOrFlushClients() {
        var clients = this.__dataPendingClients;
        if (clients) {
          this.__dataPendingClients = null;
          for (var i = 0; i < clients.length; i++) {
            var client = clients[i];
            if (!client.__dataEnabled) {
              client._enableProperties();
            } else if (client.__dataPending) {
              client._flushProperties();
            }
          }
        }
      }

      /**
       * Perform any initial setup on client dom. Called before the first
       * `_flushProperties` call on client dom and before any element
       * observers are called.
       *
       * @protected
       */

    }, {
      key: '_readyClients',
      value: function _readyClients() {
        this.__enableOrFlushClients();
      }

      /**
       * Sets a bag of property changes to this instance, and
       * synchronously processes all effects of the properties as a batch.
       *
       * Property names must be simple properties, not paths.  Batched
       * path propagation is not supported.
       *
       * @param {Object} props Bag of one or more key-value pairs whose key is
       *   a property and value is the new value to set for that property.
       * @param {boolean=} setReadOnly When true, any private values set in
       *   `props` will be set. By default, `setProperties` will not set
       *   `readOnly: true` root properties.
       * @public
       */

    }, {
      key: 'setProperties',
      value: function setProperties(props, setReadOnly) {
        for (var path in props) {
          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
            //TODO(kschaaf): explicitly disallow paths in setProperty?
            // wildcard observers currently only pass the first changed path
            // in the `info` object, and you could do some odd things batching
            // paths, e.g. {'foo.bar': {...}, 'foo': null}
            this._setPendingPropertyOrPath(path, props[path], true);
          }
        }
        this._invalidateProperties();
      }

      /**
       * Overrides `PropertyAccessors` so that property accessor
       * side effects are not enabled until after client dom is fully ready.
       * Also calls `_flushClients` callback to ensure client dom is enabled
       * that was not enabled as a result of flushing properties.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        // It is important that `super.ready()` is not called here as it
        // immediately turns on accessors. Instead, we wait until `readyClients`
        // to enable accessors to provide a guarantee that clients are ready
        // before processing any accessors side effects.
        this._flushProperties();
        // If no data was pending, `_flushProperties` will not `flushClients`
        // so ensure this is done.
        if (!this.__dataClientsReady) {
          this._flushClients();
        }
        // Before ready, client notifications do not trigger _flushProperties.
        // Therefore a flush is necessary here if data has been set.
        if (this.__dataPending) {
          this._flushProperties();
        }
      }

      /**
       * Implements `PropertyAccessors`'s properties changed callback.
       *
       * Runs each class of effects for the batch of changed properties in
       * a specific order (compute, propagate, reflect, observe, notify).
       *
       * @override
       */

    }, {
      key: '_propertiesChanged',
      value: function _propertiesChanged(currentProps, changedProps, oldProps) {
        // ----------------------------
        // let c = Object.getOwnPropertyNames(changedProps || {});
        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
        // if (window.debug) { debugger; }
        // ----------------------------
        var hasPaths = this.__dataHasPaths;
        this.__dataHasPaths = false;
        // Compute properties
        runComputedEffects(this, changedProps, oldProps, hasPaths);
        // Clear notify properties prior to possible reentry (propagate, observe),
        // but after computing effects have a chance to add to them
        var notifyProps = this.__dataToNotify;
        this.__dataToNotify = null;
        // Propagate properties to clients
        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
        // Flush clients
        this._flushClients();
        // Reflect properties
        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
        // Observe properties
        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
        // Notify properties to host
        if (notifyProps) {
          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
        }
        // Clear temporary cache at end of turn
        if (this.__dataCounter == 1) {
          this.__dataTemp = {};
        }
        // ----------------------------
        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
        // ----------------------------
      }

      /**
       * Called to propagate any property changes to stamped template nodes
       * managed by this element.
       *
       * @param {Object} changedProps Bag of changed properties
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @protected
       */

    }, {
      key: '_propagatePropertyChanges',
      value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
        if (this[TYPES.PROPAGATE]) {
          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
        }
        var templateInfo = this.__templateInfo;
        while (templateInfo) {
          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
          templateInfo = templateInfo.nextTemplateInfo;
        }
      }

      /**
       * Aliases one data path as another, such that path notifications from one
       * are routed to the other.
       *
       * @param {string | !Array<string|number>} to Target path to link.
       * @param {string | !Array<string|number>} from Source path to link.
       * @public
       */

    }, {
      key: 'linkPaths',
      value: function linkPaths(to, from) {
        to = (0, _path.normalize)(to);
        from = (0, _path.normalize)(from);
        this.__dataLinkedPaths = this.__dataLinkedPaths || {};
        this.__dataLinkedPaths[to] = from;
      }

      /**
       * Removes a data path alias previously established with `_linkPaths`.
       *
       * Note, the path to unlink should be the target (`to`) used when
       * linking the paths.
       *
       * @param {string | !Array<string|number>} path Target path to unlink.
       * @public
       */

    }, {
      key: 'unlinkPaths',
      value: function unlinkPaths(path) {
        path = (0, _path.normalize)(path);
        if (this.__dataLinkedPaths) {
          delete this.__dataLinkedPaths[path];
        }
      }

      /**
       * Notify that an array has changed.
       *
       * Example:
       *
       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
       *     ...
       *     this.items.splice(1, 1, {name: 'Sam'});
       *     this.items.push({name: 'Bob'});
       *     this.notifySplices('items', [
       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
       *     ]);
       *
       * @param {string} path Path that should be notified.
       * @param {Array} splices Array of splice records indicating ordered
       *   changes that occurred to the array. Each record should have the
       *   following fields:
       *    * index: index at which the change occurred
       *    * removed: array of items that were removed from this index
       *    * addedCount: number of new items added at this index
       *    * object: a reference to the array in question
       *    * type: the string literal 'splice'
       *
       *   Note that splice records _must_ be normalized such that they are
       *   reported in index order (raw results from `Object.observe` are not
       *   ordered and must be normalized/merged before notifying).
       * @public
      */

    }, {
      key: 'notifySplices',
      value: function notifySplices(path, splices) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        _notifySplices(this, array, info.path, splices);
      }

      /**
       * Convenience method for reading a value from a path.
       *
       * Note, if any part in the path is undefined, this method returns
       * `undefined` (this method does not throw when dereferencing undefined
       * paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `users.12.name` or `['users', 12, 'name']`).
       * @param {Object=} root Root object from which the path is evaluated.
       * @return {*} Value at the path, or `undefined` if any part of the path
       *   is undefined.
       * @public
       */

    }, {
      key: 'get',
      value: function get(path, root) {
        return (0, _path.get)(root || this, path);
      }

      /**
       * Convenience method for setting a value to a path and notifying any
       * elements bound to the same path.
       *
       * Note, if any part in the path except for the last is undefined,
       * this method does nothing (this method does not throw when
       * dereferencing undefined paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
       * @param {*} value Value to set at the specified path.
       * @param {Object=} root Root object from which the path is evaluated.
       *   When specified, no notification will occur.
       * @public
      */

    }, {
      key: 'set',
      value: function set(path, value, root) {
        if (root) {
          (0, _path.set)(root, path, value);
        } else {
          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
            if (this._setPendingPropertyOrPath(path, value, true)) {
              this._invalidateProperties();
            }
          }
        }
      }

      /**
       * Adds items onto the end of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to push onto array
       * @return {number} New length of the array.
       * @public
       */

    }, {
      key: 'push',
      value: function push(path) {
        var info = { path: '' };
        var array = /** @type {Array}*/(0, _path.get)(this, path, info);
        var len = array.length;

        for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          items[_key - 1] = arguments[_key];
        }

        var ret = array.push.apply(array, items);
        if (items.length) {
          notifySplice(this, array, info.path, len, items.length, []);
        }
        return ret;
      }

      /**
       * Removes an item from the end of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */

    }, {
      key: 'pop',
      value: function pop(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        var hadLength = Boolean(array.length);
        var ret = array.pop();
        if (hadLength) {
          notifySplice(this, array, info.path, array.length, 0, [ret]);
        }
        return ret;
      }

      /**
       * Starting from the start index specified, removes 0 or more items
       * from the array and inserts 0 or more new items in their place.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.splice`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {number} start Index from which to start removing/inserting.
       * @param {number} deleteCount Number of items to remove.
       * @param {...*} items Items to insert into array.
       * @return {Array} Array of removed items.
       * @public
       */

    }, {
      key: 'splice',
      value: function splice(path, start, deleteCount) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        // Normalize fancy native splice handling of crazy start values
        if (start < 0) {
          start = array.length - Math.floor(-start);
        } else {
          start = Math.floor(start);
        }
        if (!start) {
          start = 0;
        }

        for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          items[_key2 - 3] = arguments[_key2];
        }

        var ret = array.splice.apply(array, [start, deleteCount].concat(items));
        if (items.length || ret.length) {
          notifySplice(this, array, info.path, start, items.length, ret);
        }
        return ret;
      }

      /**
       * Removes an item from the beginning of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */

    }, {
      key: 'shift',
      value: function shift(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        var hadLength = Boolean(array.length);
        var ret = array.shift();
        if (hadLength) {
          notifySplice(this, array, info.path, 0, 0, [ret]);
        }
        return ret;
      }

      /**
       * Adds items onto the beginning of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to insert info array
       * @return {number} New length of the array.
       * @public
       */

    }, {
      key: 'unshift',
      value: function unshift(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);

        for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          items[_key3 - 1] = arguments[_key3];
        }

        var ret = array.unshift.apply(array, items);
        if (items.length) {
          notifySplice(this, array, info.path, 0, items.length, []);
        }
        return ret;
      }

      /**
       * Notify that a path has changed.
       *
       * Example:
       *
       *     this.item.user.name = 'Bob';
       *     this.notifyPath('item.user.name');
       *
       * @param {string} path Path that should be notified.
       * @param {*=} value Value at the path (optional).
       * @public
      */

    }, {
      key: 'notifyPath',
      value: function notifyPath(path, value) {
        /** @type {string} */
        var propPath = void 0;
        if (arguments.length == 1) {
          // Get value if not supplied
          var info = { path: '' };
          value = (0, _path.get)(this, path, info);
          propPath = info.path;
        } else if (Array.isArray(path)) {
          // Normalize path if needed
          propPath = (0, _path.normalize)(path);
        } else {
          propPath = /** @type{string} */path;
        }
        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Equivalent to static `createReadOnlyProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */

    }, {
      key: '_createReadOnlyProperty',
      value: function _createReadOnlyProperty(property, protectedSetter) {
        this._addPropertyEffect(property, TYPES.READ_ONLY);
        if (protectedSetter) {
          this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
            this._setProperty(property, value);
          };
        }
      }

      /**
       * Equivalent to static `createPropertyObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createPropertyObserver',
      value: function _createPropertyObserver(property, methodName, dynamicFn) {
        var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
        this._addPropertyEffect(property, TYPES.OBSERVE, {
          fn: runObserverEffect, info: info, trigger: { name: property }
        });
        if (dynamicFn) {
          this._addPropertyEffect(methodName, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: methodName }
          });
        }
      }

      /**
       * Equivalent to static `createMethodObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createMethodObserver',
      value: function _createMethodObserver(expression, dynamicFn) {
        var sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed observer expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
      }

      /**
       * Equivalent to static `createNotifyingProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: '_createNotifyingProperty',
      value: function _createNotifyingProperty(property) {
        this._addPropertyEffect(property, TYPES.NOTIFY, {
          fn: runNotifyEffect,
          info: {
            eventName: CaseMap.camelToDashCase(property) + '-changed',
            property: property
          }
        });
      }

      /**
       * Equivalent to static `createReflectedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: '_createReflectedProperty',
      value: function _createReflectedProperty(property) {
        var attr = CaseMap.camelToDashCase(property);
        if (attr[0] === '-') {
          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
        } else {
          this._addPropertyEffect(property, TYPES.REFLECT, {
            fn: runReflectEffect,
            info: {
              attrName: attr
            }
          });
        }
      }

      /**
       * Equivalent to static `createComputedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createComputedProperty',
      value: function _createComputedProperty(property, expression, dynamicFn) {
        var sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed computed expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
      }

      // -- static class methods ------------

      /**
       * Ensures an accessor exists for the specified property, and adds
       * to a list of "property effects" that will run when the accessor for
       * the specified property is set.  Effects are grouped by "type", which
       * roughly corresponds to a phase in effect processing.  The effect
       * metadata should be in the following form:
       *
       *     {
       *       fn: effectFunction, // Reference to function to call to perform effect
       *       info: { ... }       // Effect metadata passed to function
       *       trigger: {          // Optional triggering metadata; if not provided
       *         name: string      // the property is treated as a wildcard
       *         structured: boolean
       *         wildcard: boolean
       *       }
       *     }
       *
       * Effects are called from `_propertiesChanged` in the following order by
       * type:
       *
       * 1. COMPUTE
       * 2. PROPAGATE
       * 3. REFLECT
       * 4. OBSERVE
       * 5. NOTIFY
       *
       * Effect functions are called with the following signature:
       *
       *     effectFunction(inst, path, props, oldProps, info, hasPaths)
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_bindTemplate',


      // -- binding ----------------------------------------------

      /**
       * Equivalent to static `bindTemplate` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * This method may be called on the prototype (for prototypical template
       * binding, to avoid creating accessors every instance) once per prototype,
       * and will be called with `runtimeBinding: true` by `_stampTemplate` to
       * create and link an instance of the template metadata associated with a
       * particular stamping.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @param {boolean=} instanceBinding When false (default), performs
       *   "prototypical" binding of the template and overwrites any previously
       *   bound template for the class. When true (as passed from
       *   `_stampTemplate`), the template info is instanced and linked into
       *   the list of bound templates.
       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
       *   this is an instance of the prototypical template info
       * @protected
       */
      value: function _bindTemplate(template, instanceBinding) {
        var templateInfo = this.constructor._parseTemplate(template);
        var wasPreBound = this.__templateInfo == templateInfo;
        // Optimization: since this is called twice for proto-bound templates,
        // don't attempt to recreate accessors if this template was pre-bound
        if (!wasPreBound) {
          for (var prop in templateInfo.propertyEffects) {
            this._createPropertyAccessor(prop);
          }
        }
        if (instanceBinding) {
          // For instance-time binding, create instance of template metadata
          // and link into list of templates if necessary
          templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
          templateInfo.wasPreBound = wasPreBound;
          if (!wasPreBound && this.__templateInfo) {
            var last = this.__templateInfoLast || this.__templateInfo;
            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
            templateInfo.previousTemplateInfo = last;
            return templateInfo;
          }
        }
        return this.__templateInfo = templateInfo;
      }

      /**
       * Adds a property effect to the given template metadata, which is run
       * at the "propagate" stage of `_propertiesChanged` when the template
       * has been bound to the element via `_bindTemplate`.
       *
       * The `effect` object should match the format in `_addPropertyEffect`.
       *
       * @param {Object} templateInfo Template metadata to add effect to
       * @param {string} prop Property that should trigger the effect
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_stampTemplate',


      /**
       * Stamps the provided template and performs instance-time setup for
       * Polymer template features, including data bindings, declarative event
       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
       * is returned containing the stamped DOM, ready for insertion into the
       * DOM.
       *
       * This method may be called more than once; however note that due to
       * `shadycss` polyfill limitations, only styles from templates prepared
       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
       * to the shadow root and support CSS custom properties), and note that
       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
       * any styles required by in runtime-stamped templates must be included
       * in the main element template.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       * @override
       * @protected
       */
      value: function _stampTemplate(template) {
        // Ensures that created dom is `_enqueueClient`'d to this element so
        // that it can be flushed on next call to `_flushProperties`
        hostStack.beginHosting(this);
        var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
        hostStack.endHosting(this);
        var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
        // Add template-instance-specific data to instanced templateInfo
        templateInfo.nodeList = dom.nodeList;
        // Capture child nodes to allow unstamping of non-prototypical templates
        if (!templateInfo.wasPreBound) {
          var nodes = templateInfo.childNodes = [];
          for (var n = dom.firstChild; n; n = n.nextSibling) {
            nodes.push(n);
          }
        }
        dom.templateInfo = templateInfo;
        // Setup compound storage, 2-way listeners, and dataHost for bindings
        setupBindings(this, templateInfo);
        // Flush properties into template nodes if already booted
        if (this.__dataReady) {
          runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
        }
        return dom;
      }

      /**
       * Removes and unbinds the nodes previously contained in the provided
       * DocumentFragment returned from `_stampTemplate`.
       *
       * @param {!StampedTemplate} dom DocumentFragment previously returned
       *   from `_stampTemplate` associated with the nodes to be removed
       * @protected
       */

    }, {
      key: '_removeBoundDom',
      value: function _removeBoundDom(dom) {
        // Unlink template info
        var templateInfo = dom.templateInfo;
        if (templateInfo.previousTemplateInfo) {
          templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
        }
        if (templateInfo.nextTemplateInfo) {
          templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
        }
        if (this.__templateInfoLast == templateInfo) {
          this.__templateInfoLast = templateInfo.previousTemplateInfo;
        }
        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
        // Remove stamped nodes
        var nodes = templateInfo.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          node.parentNode.removeChild(node);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: 'PROPERTY_EFFECT_TYPES',
      get: function get() {
        return TYPES;
      }
    }], [{
      key: 'addPropertyEffect',
      value: function addPropertyEffect(property, type, effect) {
        this.prototype._addPropertyEffect(property, type, effect);
      }

      /**
       * Creates a single-property observer for the given property.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createPropertyObserver',
      value: function createPropertyObserver(property, methodName, dynamicFn) {
        this.prototype._createPropertyObserver(property, methodName, dynamicFn);
      }

      /**
       * Creates a multi-property "method observer" based on the provided
       * expression, which should be a string in the form of a normal Javascript
       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
       * should correspond to a property or path in the context of this
       * prototype (or instance), or may be a literal string or number.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createMethodObserver',
      value: function createMethodObserver(expression, dynamicFn) {
        this.prototype._createMethodObserver(expression, dynamicFn);
      }

      /**
       * Causes the setter for the given property to dispatch `<property>-changed`
       * events to notify of changes to the property.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: 'createNotifyingProperty',
      value: function createNotifyingProperty(property) {
        this.prototype._createNotifyingProperty(property);
      }

      /**
       * Creates a read-only accessor for the given property.
       *
       * To set the property, use the protected `_setProperty` API.
       * To create a custom protected setter (e.g. `_setMyProp()` for
       * property `myProp`), pass `true` for `protectedSetter`.
       *
       * Note, if the property will have other property effects, this method
       * should be called first, before adding other effects.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */

    }, {
      key: 'createReadOnlyProperty',
      value: function createReadOnlyProperty(property, protectedSetter) {
        this.prototype._createReadOnlyProperty(property, protectedSetter);
      }

      /**
       * Causes the setter for the given property to reflect the property value
       * to a (dash-cased) attribute of the same name.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: 'createReflectedProperty',
      value: function createReflectedProperty(property) {
        this.prototype._createReflectedProperty(property);
      }

      /**
       * Creates a computed property whose value is set to the result of the
       * method described by the given `expression` each time one or more
       * arguments to the method changes.  The expression should be a string
       * in the form of a normal Javascript function signature:
       * `'methodName(arg1, [..., argn])'`
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
       *   method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createComputedProperty',
      value: function createComputedProperty(property, expression, dynamicFn) {
        this.prototype._createComputedProperty(property, expression, dynamicFn);
      }

      /**
       * Parses the provided template to ensure binding effects are created
       * for them, and then ensures property accessors are created for any
       * dependent properties in the template.  Binding effects for bound
       * templates are stored in a linked list on the instance so that
       * templates can be efficiently stamped and unstamped.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @return {Object} Template metadata object
       * @protected
       */

    }, {
      key: 'bindTemplate',
      value: function bindTemplate(template) {
        return this.prototype._bindTemplate(template);
      }
    }, {
      key: '_addTemplatePropertyEffect',
      value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
        var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
        hostProps[prop] = true;
        var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
        var propEffects = effects[prop] = effects[prop] || [];
        propEffects.push(effect);
      }
    }, {
      key: '_parseTemplateNode',
      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
        if (node.nodeType === Node.TEXT_NODE) {
          var parts = this._parseBindings(node.textContent, templateInfo);
          if (parts) {
            // Initialize the textContent with any literal parts
            // NOTE: default to a space here so the textNode remains; some browsers
            // (IE) evacipate an empty textNode following cloneNode/importNode.
            node.textContent = literalFromParts(parts) || ' ';
            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
            noted = true;
          }
        }
        return noted;
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from attributes.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: '_parseTemplateNodeAttribute',
      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        var parts = this._parseBindings(value, templateInfo);
        if (parts) {
          // Attribute or property
          var origName = name;
          var kind = 'property';
          if (name[name.length - 1] == '$') {
            name = name.slice(0, -1);
            kind = 'attribute';
          }
          // Initialize attribute bindings with any literal parts
          var literal = literalFromParts(parts);
          if (literal && kind == 'attribute') {
            node.setAttribute(name, literal);
          }
          // Clear attribute before removing, since IE won't allow removing
          // `value` attribute if it previously had a value (can't
          // unconditionally set '' before removing since attributes with `$`
          // can't be set using setAttribute)
          if (node.localName === 'input' && origName === 'value') {
            node.setAttribute(origName, '');
          }
          // Remove annotation
          node.removeAttribute(origName);
          // Case hackery: attributes are lower-case, but bind targets
          // (properties) are case sensitive. Gambit is to map dash-case to
          // camel-case: `foo-bar` becomes `fooBar`.
          // Attribute bindings are excepted.
          if (kind === 'property') {
            name = (0, _caseMap.dashToCamelCase)(name);
          }
          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
          return true;
        } else {
          return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * binding the properties that a nested template depends on to the template
       * as `_host_<property>`.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: '_parseTemplateNestedTemplate',
      value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
        // Merge host props into outer template and add bindings
        var hostProps = nodeInfo.templateInfo.hostProps;
        var mode = '{';
        for (var source in hostProps) {
          var parts = [{ mode: mode, source: source, dependencies: [source] }];
          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
        }
        return noted;
      }

      /**
       * Called to parse text in a template (either attribute values or
       * textContent) into binding metadata.
       *
       * Any overrides of this method should return an array of binding part
       * metadata  representing one or more bindings found in the provided text
       * and any "literal" text in between.  Any non-literal parts will be passed
       * to `_evaluateBinding` when any dependencies change.  The only required
       * fields of each "part" in the returned array are as follows:
       *
       * - `dependencies` - Array containing trigger metadata for each property
       *   that should trigger the binding to update
       * - `literal` - String containing text if the part represents a literal;
       *   in this case no `dependencies` are needed
       *
       * Additional metadata for use by `_evaluateBinding` may be provided in
       * each part object as needed.
       *
       * The default implementation handles the following types of bindings
       * (one or more may be intermixed with literal strings):
       * - Property binding: `[[prop]]`
       * - Path binding: `[[object.prop]]`
       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
       * - Two-way property or path bindings (supports negation):
       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
       * - Inline computed method (supports negation):
       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
       *
       * @param {string} text Text to parse from attribute or textContent
       * @param {Object} templateInfo Current template metadata
       * @return {Array<!BindingPart>} Array of binding part metadata
       * @protected
       */

    }, {
      key: '_parseBindings',
      value: function _parseBindings(text, templateInfo) {
        var parts = [];
        var lastIndex = 0;
        var m = void 0;
        // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
        // Regex matches:
        //        Iteration 1:  Iteration 2:
        // m[1]: '{{'          '[['
        // m[2]: ''            '!'
        // m[3]: 'prop'        'compute(foo,bar)'
        while ((m = bindingRegex.exec(text)) !== null) {
          // Add literal part
          if (m.index > lastIndex) {
            parts.push({ literal: text.slice(lastIndex, m.index) });
          }
          // Add binding part
          var mode = m[1][0];
          var negate = Boolean(m[2]);
          var source = m[3].trim();
          var customEvent = false,
              notifyEvent = '',
              colon = -1;
          if (mode == '{' && (colon = source.indexOf('::')) > 0) {
            notifyEvent = source.substring(colon + 2);
            source = source.substring(0, colon);
            customEvent = true;
          }
          var signature = parseMethod(source);
          var dependencies = [];
          if (signature) {
            // Inline computed function
            var args = signature.args,
                methodName = signature.methodName;

            for (var i = 0; i < args.length; i++) {
              var arg = args[i];
              if (!arg.literal) {
                dependencies.push(arg);
              }
            }
            var dynamicFns = templateInfo.dynamicFns;
            if (dynamicFns && dynamicFns[methodName] || signature.static) {
              dependencies.push(methodName);
              signature.dynamicFn = true;
            }
          } else {
            // Property or path
            dependencies.push(source);
          }
          parts.push({
            source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
            event: notifyEvent
          });
          lastIndex = bindingRegex.lastIndex;
        }
        // Add a final literal part
        if (lastIndex && lastIndex < text.length) {
          var literal = text.substring(lastIndex);
          if (literal) {
            parts.push({
              literal: literal
            });
          }
        }
        if (parts.length) {
          return parts;
        } else {
          return null;
        }
      }

      /**
       * Called to evaluate a previously parsed binding part based on a set of
       * one or more changed dependencies.
       *
       * @param {this} inst Element that should be used as scope for
       *   binding dependencies
       * @param {BindingPart} part Binding part metadata
       * @param {string} path Property/path that triggered this effect
       * @param {Object} props Bag of current property changes
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @return {*} Value the binding part evaluated to
       * @protected
       */

    }, {
      key: '_evaluateBinding',
      value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
        var value = void 0;
        if (part.signature) {
          value = runMethodEffect(inst, path, props, oldProps, part.signature);
        } else if (path != part.source) {
          value = (0, _path.get)(inst, part.source);
        } else {
          if (hasPaths && (0, _path.isPath)(path)) {
            value = (0, _path.get)(inst, path);
          } else {
            value = inst.__data[path];
          }
        }
        if (part.negate) {
          value = !value;
        }
        return value;
      }
    }]);

    return PropertyEffects;
  }(propertyEffectsBase);

  // make a typing for closure :P


  PropertyEffectsType = PropertyEffects;

  return PropertyEffects;
});

/**
 * Helper api for enqueing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */
var hostStack = {

  stack: [],

  /**
   * @param {*} inst Instance to add to hostStack
   * @this {hostStack}
   */
  registerHost: function registerHost(inst) {
    if (this.stack.length) {
      var host = this.stack[this.stack.length - 1];
      host._enqueueClient(inst);
    }
  },


  /**
   * @param {*} inst Instance to begin hosting
   * @this {hostStack}
   */
  beginHosting: function beginHosting(inst) {
    this.stack.push(inst);
  },


  /**
   * @param {*} inst Instance to end hosting
   * @this {hostStack}
   */
  endHosting: function endHosting(inst) {
    var stackLen = this.stack.length;
    if (stackLen && this.stack[stackLen - 1] == inst) {
      this.stack.pop();
    }
  }
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
var nativeShadow = exports.nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
var nativeCssVariables = exports.nativeCssVariables = void 0;

/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */
function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    exports.nativeCssVariables = nativeCssVariables = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    exports.nativeCssVariables = nativeCssVariables = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  exports.nativeCssVariables = nativeCssVariables = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  // reset window variable to let ShadyCSS API take its place
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/



/** @unrestricted */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.stringify = stringify;
exports.removeCustomPropAssignment = removeCustomPropAssignment;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleNode = function StyleNode() {
  _classCallCheck(this, StyleNode);

  /** @type {number} */
  this['start'] = 0;
  /** @type {number} */
  this['end'] = 0;
  /** @type {StyleNode} */
  this['previous'] = null;
  /** @type {StyleNode} */
  this['parent'] = null;
  /** @type {Array<StyleNode>} */
  this['rules'] = null;
  /** @type {string} */
  this['parsedCssText'] = '';
  /** @type {string} */
  this['cssText'] = '';
  /** @type {boolean} */
  this['atRule'] = false;
  /** @type {number} */
  this['type'] = 0;
  /** @type {string} */
  this['keyframesName'] = '';
  /** @type {string} */
  this['selector'] = '';
  /** @type {string} */
  this['parsedSelector'] = '';
};

exports.StyleNode = StyleNode;

// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */

function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}

// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}

// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function lex(text) {
  var root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length;
  var n = root;
  for (var i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      var p = n;
      var previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}

// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */
function parseCss(node, text) {
  var t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    var ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax
    t = t.substring(t.lastIndexOf(';') + 1);
    var s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = s.indexOf(AT_START) === 0;
    // note, support a subset of rule types...
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  var r$ = node['rules'];
  if (r$) {
    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}

/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
    var code = arguments[1],
        repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}

/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */
function stringify(node, preserveProperties) {
  var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  // calc rule cssText
  var cssText = '';
  if (node['cssText'] || node['rules']) {
    var r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  // emit rule if there is cssText
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}

/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */
function _hasMixinRules(rules) {
  var r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
}

/** @enum {number} */
var types = exports.types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
};

var OPEN_BRACE = '{';
var CLOSE_BRACE = '}';

// helper regexp's
var RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};

var VAR_START = '--';
var MEDIA_START = '@media';
var AT_START = '@';

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

var VAR_ASSIGN = exports.VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
var MIXIN_MATCH = exports.MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
var VAR_CONSUMED = exports.VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
var ANIMATION_MATCH = exports.ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
var MEDIA_MATCH = exports.MEDIA_MATCH = /@media\s(.*)/;
var IS_VAR = exports.IS_VAR = /^--/;
var BRACKETED = exports.BRACKETED = /\{[^}]*\}/g;
var HOST_PREFIX = exports.HOST_PREFIX = '(?:^|[^.#[:])';
var HOST_SUFFIX = exports.HOST_SUFFIX = '($|[.:[\\s>+~])';

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateNativeProperties = updateNativeProperties;
exports.getComputedStyleValue = getComputedStyleValue;
exports.detectMixin = detectMixin;

var _commonRegex = __webpack_require__(39);

/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (var p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  var value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}

/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */
function detectMixin(cssText) {
  var has = _commonRegex.MIXIN_MATCH.test(cssText) || _commonRegex.VAR_ASSIGN.test(cssText);
  // reset state of the regexes
  _commonRegex.MIXIN_MATCH.lastIndex = 0;
  _commonRegex.VAR_ASSIGN.lastIndex = 0;
  return has;
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = exports.add = exports.findOriginalTarget = exports.prevent = exports._fire = exports.recognizers = exports.gestures = undefined;
exports.deepTargetFind = deepTargetFind;
exports._findOriginalTarget = _findOriginalTarget;
exports._handleNative = _handleNative;
exports._handleTouchAction = _handleTouchAction;
exports.addListener = addListener;
exports.removeListener = removeListener;
exports._add = _add;
exports._remove = _remove;
exports.register = register;
exports._findRecognizerByEvent = _findRecognizerByEvent;
exports.setTouchAction = setTouchAction;
exports.resetMouseCanceller = resetMouseCanceller;

__webpack_require__(2);

var _async = __webpack_require__(15);

var _debounce = __webpack_require__(27);

// detect native touch action support
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
// number of last N track positions to keep
var TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
var MOUSE_HAS_BUTTONS = function () {
  try {
    return new MouseEvent('test', { buttons: 1 }).buttons === 1;
  } catch (e) {
    return false;
  }
}();

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
var SUPPORTS_PASSIVE = false;
(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', { get: function get() {
        SUPPORTS_PASSIVE = true;
      } });
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch (e) {}
})();

// Check for touch-only devices
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
GestureRecognizer.prototype.reset = function () {};
/** @type {function(MouseEvent) | undefined} */
GestureRecognizer.prototype.mousedown;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mousemove;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mouseup;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchstart;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchmove;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchend;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.click;

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
var mouseCanceller = function mouseCanceller(mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  var sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  // skip synthetic mouse events
  mouseEvent[HANDLED_OBJ] = { skip: true };
  // disable "ghost clicks"
  if (mouseEvent.type === 'click') {
    var path = mouseEvent.composedPath && mouseEvent.composedPath();
    if (path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};

/**
 * @param {boolean=} setup True to add, false to remove.
 */
function setupTeardownMouseCanceller(setup) {
  var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (var i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  var unset = function unset() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = e.composedPath()[0];
  POINTERSTATE.mouse.mouseIgnoreJob = _debounce.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, _async.timeOut.after(MOUSE_TIMEOUT), unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
  var type = ev.type;
  // exit early if the event is not a mouse event
  if (MOUSE_EVENTS.indexOf(type) === -1) {
    return false;
  }
  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
  if (type === 'mousemove') {
    // allow undefined for testing events
    var buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    // buttons is a bitmask, check that the left button bit is set (1)
    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    var button = ev.button === undefined ? 0 : ev.button;
    // ev.button is 0 in mousedown/mouseup/click for left button activation
    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    }
    // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(
    var t = _findOriginalTarget(ev);
    // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click
    if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    var bcr = /** @type {Element} */t.getBoundingClientRect();
    // use page x/y to account for scrolling
    var x = ev.pageX,
        y = ev.pageY;
    // ev is a synthetic click if the position is outside the bounding box of the target
    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
  }
  return false;
}

var POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  var ta = 'auto';
  var path = ev.composedPath && ev.composedPath();
  if (path) {
    for (var i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
  }
  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

// use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

var gestures = exports.gestures = {};
var recognizers = exports.recognizers = [];

function deepTargetFind(x, y) {
  var node = document.elementFromPoint(x, y);
  var next = node;
  // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop
  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    var oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    // on Safari, elementFromPoint may return the shadowRoot host
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}

function _findOriginalTarget(ev) {
  // shadowdom
  if (ev.composedPath) {
    return (/** @type {EventTarget} */ev.composedPath()[0]
    );
  }
  // shadydom
  return ev.target;
}

function _handleNative(ev) {
  var handled = void 0;
  var type = ev.type;
  var node = ev.currentTarget;
  var gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  var gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
      var t = ev.changedTouches[0];
      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  // used to ignore synthetic mouse events
  if (handled.skip) {
    return;
  }
  // reset recognizer state
  for (var i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  // enforce gesture recognizer order
  for (var _i = 0, _r; _i < recognizers.length; _i++) {
    _r = recognizers[_i];
    if (gs[_r.name] && !handled[_r.name]) {
      handled[_r.name] = true;
      _r[type](ev);
    }
  }
}

function _handleTouchAction(ev) {
  var t = ev.changedTouches[0];
  var type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    var ta = firstTouchAction(ev);
    var _prevent = false;
    var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) {
      // scrolling is happening
    } else if (ta === 'none') {
      _prevent = true;
    } else if (ta === 'pan-x') {
      _prevent = dy > dx;
    } else if (ta === 'pan-y') {
      _prevent = dx > dy;
    }
    if (_prevent) {
      ev.preventDefault();
    } else {
      _prevent('track');
    }
  }
}

function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}

function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}

function _add(node, evType, handler) {
  var recognizer = gestures[evType];
  var deps = recognizer.deps;
  var name = recognizer.name;
  var gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (var i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    // don't add mouse handlers on iOS because they cause gray selection overlays
    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = { _count: 0 };
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative);
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}

function _remove(node, evType, handler) {
  var recognizer = gestures[evType];
  var deps = recognizer.deps;
  var name = recognizer.name;
  var gobj = node[GESTURE_KEY];
  if (gobj) {
    for (var i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative);
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}

function register(recog) {
  recognizers.push(recog);
  for (var i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}

function _findRecognizerByEvent(evName) {
  for (var i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (var j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}

function setTouchAction(node, value) {
  if (HAS_NATIVE_TA) {
    node.style.touchAction = value;
  }
  node[TOUCH_ACTION] = value;
}

function _fire2(target, type, detail) {
  var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  target.dispatchEvent(ev);
  // forward `preventDefault` in a clean way
  if (ev.defaultPrevented) {
    var preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}

exports._fire = _fire2;
function _prevent2(evName) {
  var recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}

exports.prevent = _prevent2;
function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}

/* eslint-disable valid-jsdoc */

register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],

  info: {
    movefn: null,
    upfn: null
  },

  /** @this {GestureRecognizer} */
  reset: function reset() {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = _findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        self._fire('up', t, e);
        untrackDocument(self.info);
      }
    };
    var upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        self._fire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this._fire('down', t, e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @param {string} type
   * @param {EventTarget} target
   * @param {Event} event
   * @param {Function} preventer
   */
  _fire: function _fire(type, target, event, preventer) {
    _fire2(target, type, {
      x: event.clientX,
      y: event.clientY,
      sourceEvent: event,
      preventer: preventer,
      prevent: function prevent(e) {
        return _prevent2(e);
      }
    });
  }
});

register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],

  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    /** @this {GestureRecognizer} */
    addMove: function addMove(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /** @this {GestureRecognizer} */
  reset: function reset() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  hasMovedEnough: function hasMovedEnough(x, y) {
    if (this.info.prevent) {
      return false;
    }
    if (this.info.started) {
      return true;
    }
    var dx = Math.abs(this.info.x - x);
    var dy = Math.abs(this.info.y - y);
    return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = _findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      var x = e.clientX,
          y = e.clientY;
      if (self.hasMovedEnough(x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          _prevent2('tap');
        }
        self.info.addMove({ x: x, y: y });
        if (!hasLeftMouseButton(e)) {
          // always _fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        self._fire(t, e);
        self.info.started = true;
      }
    };
    var upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }

      // remove the temporary listeners
      untrackDocument(self.info);
    };
    // add temporary document listeners as mouse retargets
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    var ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchmove: function touchmove(e) {
    var t = _findOriginalTarget(e);
    var ct = e.changedTouches[0];
    var x = ct.clientX,
        y = ct.clientY;
    if (this.hasMovedEnough(x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        _prevent2('tap');
      }
      this.info.addMove({ x: x, y: y });
      this._fire(t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    var t = _findOriginalTarget(e);
    var ct = e.changedTouches[0];
    // only trackend if track was started and not aborted
    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({ x: ct.clientX, y: ct.clientY });
      this._fire(t, ct, e);
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {EventTarget} target
   * @param {Touch} touch
   */
  _fire: function _fire(target, touch) {
    var secondlast = this.info.moves[this.info.moves.length - 2];
    var lastmove = this.info.moves[this.info.moves.length - 1];
    var dx = lastmove.x - this.info.x;
    var dy = lastmove.y - this.info.y;
    var ddx = void 0,
        ddy = 0;
    if (secondlast) {
      ddx = lastmove.x - secondlast.x;
      ddy = lastmove.y - secondlast.y;
    }
    _fire2(target, 'track', {
      state: this.info.state,
      x: touch.clientX,
      y: touch.clientY,
      dx: dx,
      dy: dy,
      ddx: ddx,
      ddy: ddy,
      sourceEvent: touch,
      hover: function hover() {
        return deepTargetFind(touch.clientX, touch.clientY);
      }
    });
  }

});

register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /** @this {GestureRecognizer} */
  reset: function reset() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /** @this {GestureRecognizer} */
  save: function save(e) {
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (hasLeftMouseButton(e)) {
      this.save(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  click: function click(e) {
    if (hasLeftMouseButton(e)) {
      this.forward(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    this.save(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    this.forward(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {Event | Touch} e
   * @param {Event=} preventer
   */
  forward: function forward(e, preventer) {
    var dx = Math.abs(e.clientX - this.info.x);
    var dy = Math.abs(e.clientY - this.info.y);
    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
    var t = _findOriginalTarget(preventer || e);
    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
    if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
      // prevent taps from being generated if an event has canceled them
      if (!this.info.prevent) {
        _fire2(t, 'tap', {
          x: e.clientX,
          y: e.clientY,
          sourceEvent: e,
          preventer: preventer
        });
      }
    }
  }
});

var findOriginalTarget = exports.findOriginalTarget = _findOriginalTarget;
var add = exports.add = addListener;
var remove = exports.remove = removeListener;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flush = exports.enqueueDebouncer = undefined;

__webpack_require__(2);

var debouncerQueue = [];

var enqueueDebouncer = exports.enqueueDebouncer = function enqueueDebouncer(debouncer) {
  debouncerQueue.push(debouncer);
};

function flushDebouncers() {
  var didFlush = Boolean(debouncerQueue.length);
  while (debouncerQueue.length) {
    try {
      debouncerQueue.shift().flush();
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }
  return didFlush;
}

var flush = exports.flush = function flush() {
  var shadyDOM = void 0,
      debouncers = void 0;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplateInstanceBase = exports.Templatize = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(2);

var _propertyEffects = __webpack_require__(36);

var _mutableData = __webpack_require__(29);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
var newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 */
function HTMLTemplateElementExtension() {
  return newInstance;
}
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 */
var DataTemplate = (0, _propertyEffects.PropertyEffects)(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 */
var MutableDataTemplate = (0, _mutableData.MutableData)(DataTemplate);

// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}

// Base class for TemplateInstance's
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 */
var base = (0, _propertyEffects.PropertyEffects)(function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  return _class;
}());

/**
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @unrestricted
 */

var TemplateInstanceBase = function (_base) {
  _inherits(TemplateInstanceBase, _base);

  function TemplateInstanceBase(props) {
    _classCallCheck(this, TemplateInstanceBase);

    var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

    _this._configureProperties(props);
    _this.root = _this._stampTemplate(_this.__dataHost);
    // Save list of stamped children
    var children = _this.children = [];
    for (var n = _this.root.firstChild; n; n = n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = _this;
    }
    if (_this.__templatizeOwner.__hideTemplateChildren__) {
      _this._showHideChildren(true);
    }
    // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.
    var options = _this.__templatizeOptions;
    if (props && options.instanceProps || !options.instanceProps) {
      _this._enableProperties();
    }
    return _this;
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   */


  _createClass(TemplateInstanceBase, [{
    key: '_configureProperties',
    value: function _configureProperties(props) {
      var options = this.__templatizeOptions;
      if (props) {
        for (var iprop in options.instanceProps) {
          if (iprop in props) {
            this._setPendingProperty(iprop, props[iprop]);
          }
        }
      }
      for (var hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
      }
    }
    /**
     * Forwards a host property to this instance.  This method should be
     * called on instances from the `options.forwardHostProp` callback
     * to propagate changes of host properties to each instance.
     *
     * Note this method enqueues the change, which are flushed as a batch.
     *
     * @param {string} prop Property or path name
     * @param {*} value Value of the property to forward
     */

  }, {
    key: 'forwardHostProp',
    value: function forwardHostProp(prop, value) {
      if (this._setPendingPropertyOrPath(prop, value, false, true)) {
        this.__dataHost._enqueueClient(this);
      }
    }
    /**
     * @override
     */

  }, {
    key: '_addEventListenerToNode',
    value: function _addEventListenerToNode(node, eventName, handler) {
      var _this2 = this;

      if (this._methodHost && this.__templatizeOptions.parentModel) {
        // If this instance should be considered a parent model, decorate
        // events this template instance as `model`
        this._methodHost._addEventListenerToNode(node, eventName, function (e) {
          e.model = _this2;
          handler(e);
        });
      } else {
        // Otherwise delegate to the template's host (which could be)
        // another template instance
        var templateHost = this.__dataHost.__dataHost;
        if (templateHost) {
          templateHost._addEventListenerToNode(node, eventName, handler);
        }
      }
    }
    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @param {boolean} hide Set to true to hide the children;
     * set to false to show them.
     * @protected
     */

  }, {
    key: '_showHideChildren',
    value: function _showHideChildren(hide) {
      var c = this.children;
      for (var i = 0; i < c.length; i++) {
        var n = c[i];
        // Ignore non-changes
        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
          if (n.nodeType === Node.TEXT_NODE) {
            if (hide) {
              n.__polymerTextContent__ = n.textContent;
              n.textContent = '';
            } else {
              n.textContent = n.__polymerTextContent__;
            }
          } else if (n.style) {
            if (hide) {
              n.__polymerDisplay__ = n.style.display;
              n.style.display = 'none';
            } else {
              n.style.display = n.__polymerDisplay__;
            }
          }
        }
        n.__hideTemplateChildren__ = hide;
        if (n._showHideChildren) {
          n._showHideChildren(hide);
        }
      }
    }
    /**
     * Overrides default property-effects implementation to intercept
     * textContent bindings while children are "hidden" and cache in
     * private storage for later retrieval.
     *
     * @override
     */

  }, {
    key: '_setUnmanagedPropertyToNode',
    value: function _setUnmanagedPropertyToNode(node, prop, value) {
      if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
        node.__polymerTextContent__ = value;
      } else {
        _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
      }
    }
    /**
     * Find the parent model of this template instance.  The parent model
     * is either another templatize instance that had option `parentModel: true`,
     * or else the host element.
     *
     * @return {Polymer_PropertyEffects} The parent model of this instance
     */

  }, {
    key: 'parentModel',
    get: function get() {
      var model = this.__parentModel;
      if (!model) {
        var options = void 0;
        model = this;
        do {
          // A template instance's `__dataHost` is a <template>
          // `model.__dataHost.__dataHost` is the template's host
          model = model.__dataHost.__dataHost;
        } while ((options = model.__templatizeOptions) && !options.parentModel);
        this.__parentModel = model;
      }
      return model;
    }
  }]);

  return TemplateInstanceBase;
}(base);

/** @type {!DataTemplate} */


TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */
TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */
TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */
TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */
TemplateInstanceBase.prototype.__hostProps;

/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 */
var MutableTemplateInstanceBase = (0, _mutableData.MutableData)(TemplateInstanceBase);

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  var templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}

/* eslint-disable valid-jsdoc */
/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function createTemplatizerClass(template, templateInfo, options) {
  // Anonymous class created by the templatize
  var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
  /**
   * @constructor
   * @extends {base}
   */
  var klass = function (_base2) {
    _inherits(klass, _base2);

    function klass() {
      _classCallCheck(this, klass);

      return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
    }

    return klass;
  }(base);
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}

/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function addPropagateEffects(template, templateInfo, options) {
  var userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp) {
    // Provide data API and property effects on memoized template class
    var klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
      klass = templateInfo.templatizeTemplateClass = function (_base4) {
        _inherits(TemplatizedTemplate, _base4);

        function TemplatizedTemplate() {
          _classCallCheck(this, TemplatizedTemplate);

          return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
        }

        return TemplatizedTemplate;
      }(_base3);
      // Add template - >instances effects
      // and host <- template effects
      var hostProps = templateInfo.hostProps;
      for (var prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
    }
    upgradeTemplate(template, klass);
    // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time
    if (template.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(template.__data, template.__dataProto);
    }
    // Clear any pending data for performance
    template.__dataTemp = {};
    template.__dataPending = null;
    template.__dataOld = null;
    template._enableProperties();
  }
}
/* eslint-enable valid-jsdoc */

function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  var hostProps = templateInfo.hostProps || {};
  for (var iprop in options.instanceProps) {
    delete hostProps[iprop];
    var userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (var hprop in hostProps) {
      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}

/**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Polymer.Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customze property forwarding and event model decoration
 *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
 *       parentModel: true,
 *       instanceProps: {...},
 *       forwardHostProp(property, value) {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 *
 * @namespace
 * @memberof Polymer
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */

var Templatize = {

  /**
   * Returns an anonymous `Polymer.PropertyEffects` class bound to the
   * `<template>` provided.  Instancing the class will result in the
   * template being stamped into document fragment stored as the instance's
   * `root` property, after which it can be appended to the DOM.
   *
   * Templates may utilize all Polymer data-binding features as well as
   * declarative event listeners.  Event listeners and inline computing
   * functions in the template will be called on the host of the template.
   *
   * The constructor returned takes a single argument dictionary of initial
   * property values to propagate into template bindings.  Additionally
   * host properties can be forwarded in, and instance properties can be
   * notified out by providing optional callbacks in the `options` dictionary.
   *
   * Valid configuration in `options` are as follows:
   *
   * - `forwardHostProp(property, value)`: Called when a property referenced
   *   in the template changed on the template's host. As this library does
   *   not retain references to templates instanced by the user, it is the
   *   templatize owner's responsibility to forward host property changes into
   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
   *    method on the generated class should be called to forward host
   *   properties into the template to prevent unnecessary property-changed
   *   notifications. Any properties referenced in the template that are not
   *   defined in `instanceProps` will be notified up to the template's host
   *   automatically.
   * - `instanceProps`: Dictionary of property names that will be added
   *   to the instance by the templatize owner.  These properties shadow any
   *   host properties, and changes within the template to these properties
   *   will result in `notifyInstanceProp` being called.
   * - `mutableData`: When `true`, the generated class will skip strict
   *   dirty-checking for objects and arrays (always consider them to be
   *   "dirty").
   * - `notifyInstanceProp(instance, property, value)`: Called when
   *   an instance property changes.  Users may choose to call `notifyPath`
   *   on e.g. the owner to notify the change.
   * - `parentModel`: When `true`, events handled by declarative event listeners
   *   (`on-event="handler"`) will be decorated with a `model` property pointing
   *   to the template instance that stamped it.  It will also be returned
   *   from `instance.parentModel` in cases where template instance nesting
   *   causes an inner model to shadow an outer model.
   *
   * Note that the class returned from `templatize` is generated only once
   * for a given `<template>` using `options` from the first call for that
   * template, and the cached class is returned for all subsequent calls to
   * `templatize` for that template.  As such, `options` callbacks should not
   * close over owner-specific properties since only the first `options` is
   * used; rather, callbacks are called bound to the `owner`, and so context
   * needed from the callbacks (such as references to `instances` stamped)
   * should be stored on the `owner` such that they can be retrieved via `this`.
   *
   * @memberof Polymer.Templatize
   * @param {!HTMLTemplateElement} template Template to templatize
   * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
   *   any optional callbacks will be bound to this owner.
   * @param {Object=} options Options dictionary (see summary for details)
   * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
   *   provided
   * @suppress {invalidCasts}
   */
  templatize: function templatize(template, owner, options) {
    options = /** @type {!TemplatizeOptions} */options || {};
    if (template.__templatizeOwner) {
      throw new Error('A <template> can only be templatized once');
    }
    template.__templatizeOwner = owner;
    var templateInfo = owner.constructor._parseTemplate(template);
    // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding
    var baseClass = templateInfo.templatizeInstanceClass;
    if (!baseClass) {
      baseClass = createTemplatizerClass(template, templateInfo, options);
      templateInfo.templatizeInstanceClass = baseClass;
    }
    // Host property forwarding must be installed onto template instance
    addPropagateEffects(template, templateInfo, options);
    // Subclass base class and add reference for this specific template
    var klass = function (_baseClass) {
      _inherits(TemplateInstance, _baseClass);

      function TemplateInstance() {
        _classCallCheck(this, TemplateInstance);

        return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
      }

      return TemplateInstance;
    }(baseClass);
    klass.prototype._methodHost = findMethodHost(template);
    klass.prototype.__dataHost = template;
    klass.prototype.__templatizeOwner = owner;
    klass.prototype.__hostProps = templateInfo.hostProps;
    return (/** @type {function(new:TemplateInstanceBase)} */klass
    );
  },


  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of
   * `TemplateInstanceBase`, and should be used to manipulate data
   * associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @memberof Polymer.Templatize
   * @param {HTMLTemplateElement} template The model will be returned for
   *   elements stamped from this template
   * @param {Node} node Node for which to return a template model.
   * @return {TemplateInstanceBase} Template instance representing the
   *   binding scope for the element
   */
  modelForElement: function modelForElement(template, node) {
    var model = void 0;
    while (node) {
      // An element with a __templatizeInstance marks the top boundary
      // of a scope; walk up until we find one, and then ensure that
      // its __dataHost matches `this`, meaning this dom-repeat stamped it
      if (model = node.__templatizeInstance) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) {
          node = model.__dataHost;
        } else {
          return model;
        }
      } else {
        // Still in a template scope, keep going up until
        // a __templatizeInstance is found
        node = node.parentNode;
      }
    }
    return null;
  }
};

exports.Templatize = Templatize;
exports.TemplateInstanceBase = TemplateInstanceBase;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomRepeat = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _templatize = __webpack_require__(43);

var _debounce = __webpack_require__(27);

var _flush = __webpack_require__(42);

var _mutableData = __webpack_require__(29);

var _path = __webpack_require__(26);

var _async = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TemplateInstanceBase = _templatize.TemplateInstanceBase; // eslint-disable-line

/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {Polymer.Element}
 */
var domRepeatBase = (0, _mutableData.OptionalMutableData)(_polymerElement.Element);

/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 *   <script>
 *     Polymer({
 *       is: 'employee-list',
 *       ready: function() {
 *         this.employees = [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *         ];
 *       }
 *     });
 *   < /script>
 *
 * </dom-module>
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
 * `unshift`), and template instances will be kept in sync with the data in the
 * array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model is an instance of Polymer.Base, and should
 * be used to manipulate data on the instance, for example
 * `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer: function(item) {
 *     return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <template is="dom-repeat" items="{{employees}}"
 *           filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @extends {domRepeatBase}
 * @appliesMixin Polymer.OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */

var DomRepeat = function (_domRepeatBase) {
  _inherits(DomRepeat, _domRepeatBase);

  _createClass(DomRepeat, null, [{
    key: 'is',


    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'dom-repeat';
    }
  }, {
    key: 'template',
    get: function get() {
      return null;
    }
  }, {
    key: 'properties',
    get: function get() {

      /**
       * Fired whenever DOM is added or removed by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */
      return {

        /**
         * An array containing items determining how many instances of the template
         * to stamp and that that each template instance should bind to.
         */
        items: {
          type: Array
        },

        /**
         * The name of the variable to add to the binding scope for the array
         * element associated with a given template instance.
         */
        as: {
          type: String,
          value: 'item'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the sorted and filtered list of rendered items.
         * Note, for the index in the `this.items` array, use the value of the
         * `itemsIndexAs` property.
         */
        indexAs: {
          type: String,
          value: 'index'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the `this.items` array. Note, for the index of
         * this instance in the sorted and filtered list of rendered items,
         * use the value of the `indexAs` property.
         */
        itemsIndexAs: {
          type: String,
          value: 'itemsIndex'
        },

        /**
         * A function that should determine the sort order of the items.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.sort`.
         * Using a sort function has no effect on the underlying `items` array.
         */
        sort: {
          type: Function,
          observer: '__sortChanged'
        },

        /**
         * A function that can be used to filter items out of the view.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.filter`.
         * Using a filter function has no effect on the underlying `items` array.
         */
        filter: {
          type: Function,
          observer: '__filterChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `observe` property
         * should be set to a space-separated list of the names of item
         * sub-fields that should trigger a re-sort or re-filter when changed.
         * These should generally be fields of `item` that the sort or filter
         * function depends on.
         */
        observe: {
          type: String,
          observer: '__observeChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `delay` property
         * determines a debounce time after a change to observed item
         * properties that must pass before the filter or sort is re-run.
         * This is useful in rate-limiting shuffing of the view when
         * item changes may be frequent.
         */
        delay: Number,

        /**
         * Count of currently rendered items after `filter` (if any) has been applied.
         * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
         * set of template instances is rendered.
         *
         */
        renderedItemCount: {
          type: Number,
          notify: true,
          readOnly: true
        },

        /**
         * Defines an initial count of template instances to render after setting
         * the `items` array, before the next paint, and puts the `dom-repeat`
         * into "chunking mode".  The remaining items will be created and rendered
         * incrementally at each animation frame therof until all instances have
         * been rendered.
         */
        initialCount: {
          type: Number,
          observer: '__initializeChunking'
        },

        /**
         * When `initialCount` is used, this property defines a frame rate to
         * target by throttling the number of instances rendered each frame to
         * not exceed the budget for the target frame rate.  Setting this to a
         * higher number will allow lower latency and higher throughput for
         * things like event handlers, but will result in a longer time for the
         * remaining items to complete rendering.
         */
        targetFramerate: {
          type: Number,
          value: 20
        },

        _targetFrameTime: {
          type: Number,
          computed: '__computeFrameTime(targetFramerate)'
        }

      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['__itemsChanged(items.*)'];
    }
  }]);

  function DomRepeat() {
    _classCallCheck(this, DomRepeat);

    var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

    _this.__instances = [];
    _this.__limit = Infinity;
    _this.__pool = [];
    _this.__renderDebouncer = null;
    _this.__itemsIdxToInstIdx = {};
    _this.__chunkCount = null;
    _this.__lastChunkTime = null;
    _this.__sortFn = null;
    _this.__filterFn = null;
    _this.__observePaths = null;
    _this.__ctor = null;
    _this.__isDetached = true;
    _this.template = null;
    return _this;
  }

  _createClass(DomRepeat, [{
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
      this.__isDetached = true;
      for (var i = 0; i < this.__instances.length; i++) {
        this.__detachInstance(i);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
      // only perform attachment if the element was previously detached.
      if (this.__isDetached) {
        this.__isDetached = false;
        var parent = this.parentNode;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__attachInstance(i, parent);
        }
      }
    }
  }, {
    key: '__ensureTemplatized',
    value: function __ensureTemplatized() {
      var _this2 = this;

      // Templatizing (generating the instance constructor) needs to wait
      // until ready, since won't have its template content handed back to
      // it until then
      if (!this.__ctor) {
        var template = this.template = this.querySelector('template');
        if (!template) {
          // // Wait until childList changes and template should be there by then
          var observer = new MutationObserver(function () {
            if (_this2.querySelector('template')) {
              observer.disconnect();
              _this2.__render();
            } else {
              throw new Error('dom-repeat requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return false;
        }
        // Template instance props that should be excluded from forwarding
        var instanceProps = {};
        instanceProps[this.as] = true;
        instanceProps[this.indexAs] = true;
        instanceProps[this.itemsIndexAs] = true;
        this.__ctor = _templatize.Templatize.templatize(template, this, {
          mutableData: this.mutableData,
          parentModel: true,
          instanceProps: instanceProps,
          /**
           * @this {this}
           * @param {string} prop Property to set
           * @param {*} value Value to set property to
           */
          forwardHostProp: function forwardHostProp(prop, value) {
            var i$ = this.__instances;
            for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
              inst.forwardHostProp(prop, value);
            }
          },
          /**
           * @this {this}
           * @param {Object} inst Instance to notify
           * @param {string} prop Property to notify
           * @param {*} value Value to notify
           */
          notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
            if ((0, _path.matches)(this.as, prop)) {
              var idx = inst[this.itemsIndexAs];
              if (prop == this.as) {
                this.items[idx] = value;
              }
              var path = (0, _path.translate)(this.as, 'items.' + idx, prop);
              this.notifyPath(path, value);
            }
          }
        });
      }
      return true;
    }
  }, {
    key: '__getMethodHost',
    value: function __getMethodHost() {
      // Technically this should be the owner of the outermost template.
      // In shadow dom, this is always getRootNode().host, but we can
      // approximate this via cooperation with our dataHost always setting
      // `_methodHost` as long as there were bindings (or id's) on this
      // instance causing it to get a dataHost.
      return this.__dataHost._methodHost || this.__dataHost;
    }
  }, {
    key: '__sortChanged',
    value: function __sortChanged(sort) {
      var methodHost = this.__getMethodHost();
      this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
        return methodHost[sort].apply(methodHost, arguments);
      });
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__filterChanged',
    value: function __filterChanged(filter) {
      var methodHost = this.__getMethodHost();
      this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
        return methodHost[filter].apply(methodHost, arguments);
      });
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__computeFrameTime',
    value: function __computeFrameTime(rate) {
      return Math.ceil(1000 / rate);
    }
  }, {
    key: '__initializeChunking',
    value: function __initializeChunking() {
      if (this.initialCount) {
        this.__limit = this.initialCount;
        this.__chunkCount = this.initialCount;
        this.__lastChunkTime = performance.now();
      }
    }
  }, {
    key: '__tryRenderChunk',
    value: function __tryRenderChunk() {
      // Debounced so that multiple calls through `_render` between animation
      // frames only queue one new rAF (e.g. array mutation & chunked render)
      if (this.items && this.__limit < this.items.length) {
        this.__debounceRender(this.__requestRenderChunk);
      }
    }
  }, {
    key: '__requestRenderChunk',
    value: function __requestRenderChunk() {
      var _this3 = this;

      requestAnimationFrame(function () {
        return _this3.__renderChunk();
      });
    }
  }, {
    key: '__renderChunk',
    value: function __renderChunk() {
      // Simple auto chunkSize throttling algorithm based on feedback loop:
      // measure actual time between frames and scale chunk count by ratio
      // of target/actual frame time
      var currChunkTime = performance.now();
      var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
      this.__limit += this.__chunkCount;
      this.__lastChunkTime = currChunkTime;
      this.__debounceRender(this.__render);
    }
  }, {
    key: '__observeChanged',
    value: function __observeChanged() {
      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
    }
  }, {
    key: '__itemsChanged',
    value: function __itemsChanged(change) {
      if (this.items && !Array.isArray(this.items)) {
        console.warn('dom-repeat expected array for `items`, found', this.items);
      }
      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
      // path to that instance synchronously (retuns false for non-item paths)
      if (!this.__handleItemPath(change.path, change.value)) {
        // Otherwise, the array was reset ('items') or spliced ('items.splices'),
        // so queue a full refresh
        this.__initializeChunking();
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__handleObservedPaths',
    value: function __handleObservedPaths(path) {
      if (this.__observePaths) {
        path = path.substring(path.indexOf('.') + 1);
        var paths = this.__observePaths;
        for (var i = 0; i < paths.length; i++) {
          if (path.indexOf(paths[i]) === 0) {
            this.__debounceRender(this.__render, this.delay);
            return true;
          }
        }
      }
    }

    /**
     * @param {function(this:DomRepeat)} fn Function to debounce.
     * @param {number=} delay Delay in ms to debounce by.
     */

  }, {
    key: '__debounceRender',
    value: function __debounceRender(fn) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? _async.timeOut.after(delay) : _async.microTask, fn.bind(this));
      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */

  }, {
    key: 'render',
    value: function render() {
      // Queue this repeater, then flush all in order
      this.__debounceRender(this.__render);
      (0, _flush.flush)();
    }
  }, {
    key: '__render',
    value: function __render() {
      if (!this.__ensureTemplatized()) {
        // No template found yet
        return;
      }
      this.__applyFullRefresh();
      // Reset the pool
      // TODO(kschaaf): Reuse pool across turns and nested templates
      // Now that objects/arrays are re-evaluated when set, we can safely
      // reuse pooled instances across turns, however we still need to decide
      // semantics regarding how long to hold, how many to hold, etc.
      this.__pool.length = 0;
      // Set rendered item count
      this._setRenderedItemCount(this.__instances.length);
      // Notify users
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      // Check to see if we need to render more items
      this.__tryRenderChunk();
    }
  }, {
    key: '__applyFullRefresh',
    value: function __applyFullRefresh() {
      var _this4 = this;

      var items = this.items || [];
      var isntIdxToItemsIdx = new Array(items.length);
      for (var i = 0; i < items.length; i++) {
        isntIdxToItemsIdx[i] = i;
      }
      // Apply user filter
      if (this.__filterFn) {
        isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
          return _this4.__filterFn(items[i], idx, array);
        });
      }
      // Apply user sort
      if (this.__sortFn) {
        isntIdxToItemsIdx.sort(function (a, b) {
          return _this4.__sortFn(items[a], items[b]);
        });
      }
      // items->inst map kept for item path forwarding
      var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
      var instIdx = 0;
      // Generate instances and assign items
      var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
      for (; instIdx < limit; instIdx++) {
        var inst = this.__instances[instIdx];
        var itemIdx = isntIdxToItemsIdx[instIdx];
        var item = items[itemIdx];
        itemsIdxToInstIdx[itemIdx] = instIdx;
        if (inst && instIdx < this.__limit) {
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          this.__insertInstance(item, instIdx, itemIdx);
        }
      }
      // Remove any extra instances from previous state
      for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
        this.__detachAndRemoveInstance(_i);
      }
    }
  }, {
    key: '__detachInstance',
    value: function __detachInstance(idx) {
      var inst = this.__instances[idx];
      for (var i = 0; i < inst.children.length; i++) {
        var el = inst.children[i];
        inst.root.appendChild(el);
      }
      return inst;
    }
  }, {
    key: '__attachInstance',
    value: function __attachInstance(idx, parent) {
      var inst = this.__instances[idx];
      parent.insertBefore(inst.root, this);
    }
  }, {
    key: '__detachAndRemoveInstance',
    value: function __detachAndRemoveInstance(idx) {
      var inst = this.__detachInstance(idx);
      if (inst) {
        this.__pool.push(inst);
      }
      this.__instances.splice(idx, 1);
    }
  }, {
    key: '__stampInstance',
    value: function __stampInstance(item, instIdx, itemIdx) {
      var model = {};
      model[this.as] = item;
      model[this.indexAs] = instIdx;
      model[this.itemsIndexAs] = itemIdx;
      return new this.__ctor(model);
    }
  }, {
    key: '__insertInstance',
    value: function __insertInstance(item, instIdx, itemIdx) {
      var inst = this.__pool.pop();
      if (inst) {
        // TODO(kschaaf): If the pool is shared across turns, hostProps
        // need to be re-set to reused instances in addition to item
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        inst = this.__stampInstance(item, instIdx, itemIdx);
      }
      var beforeRow = this.__instances[instIdx + 1];
      var beforeNode = beforeRow ? beforeRow.children[0] : this;
      this.parentNode.insertBefore(inst.root, beforeNode);
      this.__instances[instIdx] = inst;
      return inst;
    }

    // Implements extension point from Templatize mixin

  }, {
    key: '_showHideChildren',
    value: function _showHideChildren(hidden) {
      for (var i = 0; i < this.__instances.length; i++) {
        this.__instances[i]._showHideChildren(hidden);
      }
    }

    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to inst for key

  }, {
    key: '__handleItemPath',
    value: function __handleItemPath(path, value) {
      var itemsPath = path.slice(6); // 'items.'.length == 6
      var dot = itemsPath.indexOf('.');
      var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
      // If path was index into array...
      if (itemsIdx == parseInt(itemsIdx, 10)) {
        var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
        // If the path is observed, it will trigger a full refresh
        this.__handleObservedPaths(itemSubPath);
        // Note, even if a rull refresh is triggered, always do the path
        // notification because unless mutableData is used for dom-repeat
        // and all elements in the instance subtree, a full refresh may
        // not trigger the proper update.
        var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
        var inst = this.__instances[instIdx];
        if (inst) {
          var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
          // This is effectively `notifyPath`, but avoids some of the overhead
          // of the public API
          inst._setPendingPropertyOrPath(itemPath, value, false, true);
          inst._flushProperties();
        }
        return true;
      }
    }

    /**
     * Returns the item associated with a given element stamped by
     * this `dom-repeat`.
     *
     * Note, to modify sub-properties of the item,
     * `modelForElement(el).set('item.<sub-prop>', value)`
     * should be used.
     *
     * @param {HTMLElement} el Element for which to return the item.
     * @return {*} Item associated with the element.
     */

  }, {
    key: 'itemForElement',
    value: function itemForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.as];
    }

    /**
     * Returns the inst index for a given element stamped by this `dom-repeat`.
     * If `sort` is provided, the index will reflect the sorted order (rather
     * than the original array order).
     *
     * @param {HTMLElement} el Element for which to return the index.
     * @return {*} Row index associated with the element (note this may
     *   not correspond to the array index if a user `sort` is applied).
     */

  }, {
    key: 'indexForElement',
    value: function indexForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.indexAs];
    }

    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of `Polymer.Base`, and
     * should be used to manipulate data associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     */

  }, {
    key: 'modelForElement',
    value: function modelForElement(el) {
      return _templatize.Templatize.modelForElement(this.template, el);
    }
  }]);

  return DomRepeat;
}(domRepeatBase);

customElements.define(DomRepeat.is, DomRepeat);

exports.DomRepeat = DomRepeat;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperRippleBehavior = undefined;

__webpack_require__(6);

__webpack_require__(115);

var _ironButtonState = __webpack_require__(70);

var _polymerDom = __webpack_require__(17);

var PaperRippleBehavior = exports.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    _ironButtonState.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        (0, _polymerDom.dom)(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = (0, _polymerDom.dom)(this._rippleContainer || this);
        var target = (0, _polymerDom.dom)(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.layerGroup = exports.LayerGroup = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = exports.LayerGroup = _Layer.Layer.extend({

	initialize: function initialize(layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function addLayer(layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function removeLayer(layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function hasLayer(layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function clearLayers() {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function invoke(methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i,
		    layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function onAdd(map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function onRemove(map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function eachLayer(method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function getLayer(id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function getLayers() {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function setZIndex(zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function getLayerId(layer) {
		return Util.stamp(layer);
	}
});

// @factory L.layerGroup(layers?: Layer[])
// Create a layer group, optionally given an initial set of layers.
var layerGroup = exports.layerGroup = function layerGroup(layers) {
	return new LayerGroup(layers);
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CRS = undefined;

var _Bounds = __webpack_require__(8);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

var CRS = exports.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function latLngToPoint(latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function pointToLatLng(point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function project(latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function unproject(point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function scale(zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function zoom(scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function getProjectedBounds(zoom) {
		if (this.infinite) {
			return null;
		}

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return new _Bounds.Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function wrapLatLng(latlng) {
		var lng = this.wrapLng ? Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return new _LatLng.LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function wrapLatLngBounds(bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = new _LatLng.LatLng(sw.lat - latShift, sw.lng - lngShift),
		    newNe = new _LatLng.LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new _LatLngBounds.LatLngBounds(newSw, newNe);
	}
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Marker = undefined;
exports.marker = marker;

var _Layer = __webpack_require__(12);

var _Icon = __webpack_require__(78);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Marker = __webpack_require__(117);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = exports.Marker = _Layer.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new _Icon.IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false
	},

	/* @section
  *
  * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  */

	initialize: function initialize(latlng, options) {
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);
	},

	onAdd: function onAdd(map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function onRemove(map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function getEvents() {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function setLatLng(latlng) {
		var oldLatLng = this._latlng;
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', { oldLatLng: oldLatLng, latlng: this._latlng });
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function setZIndexOffset(offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function setIcon(icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function getElement() {
		return this._icon;
	},

	update: function update() {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function _initIcon() {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			DomUtil.addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;

		if (options.opacity < 1) {
			this._updateOpacity();
		}

		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function _removeIcon() {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function _removeShadow() {
		if (this._shadow) {
			DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function _setPos(pos) {
		DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function _updateZIndex(offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function _animateZoom(opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function _initInteraction() {

		if (!this.options.interactive) {
			return;
		}

		DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (_Marker.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new _Marker.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function _updateOpacity() {
		var opacity = this.options.opacity;

		DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function _bringToFront() {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function _resetZIndex() {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function _getPopupAnchor() {
		return this.options.icon.options.popupAnchor || [0, 0];
	},

	_getTooltipAnchor: function _getTooltipAnchor() {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});

// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Draggable = undefined;

var _Events = __webpack_require__(19);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Point = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};

var Draggable = exports.Draggable = _Events.Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function initialize(element, dragStartTarget, preventOutline, options) {
		Util.setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function enable() {
		if (this._enabled) {
			return;
		}

		DomEvent.on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function disable() {
		if (!this._enabled) {
			return;
		}

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		DomEvent.off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function _onDown(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}

		this._moved = false;

		if (DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) {
			return;
		}

		if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
			return;
		}
		Draggable._dragging = this; // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			DomUtil.preventOutline(this._element);
		}

		DomUtil.disableImageDrag();
		DomUtil.disableTextSelection();

		if (this._moving) {
			return;
		}

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new _Point.Point(first.clientX, first.clientY);

		DomEvent.on(document, MOVE[e.type], this._onMove, this);
		DomEvent.on(document, END[e.type], this._onUp, this);
	},

	_onMove: function _onMove(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
		    newPoint = new _Point.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) {
			return;
		}
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
			return;
		}

		DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = DomUtil.getPosition(this._element).subtract(offset);

			DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function _updatePosition() {
		var e = { originalEvent: this._lastEvent };

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function _onUp(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}
		this.finishDrag();
	},

	finishDrag: function finishDrag() {
		DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			DomEvent.off(document, MOVE[i], this._onMove, this);
			DomEvent.off(document, END[i], this._onUp, this);
		}

		DomUtil.enableImageDrag();
		DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.imageOverlay = exports.ImageOverlay = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = exports.ImageOverlay = _Layer.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the tile layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: ''
	},

	initialize: function initialize(url, bounds, options) {
		// (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		Util.setOptions(this, options);
	},

	onAdd: function onAdd() {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function onRemove() {
		DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function setStyle(styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function setUrl(url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function setBounds(bounds) {
		this._bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function getEvents() {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method: setZIndex(value: Number) : this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function setZIndex(value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function getBounds() {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function getElement() {
		return this._image;
	},

	_initImage: function _initImage() {
		var img = this._image = DomUtil.create('img', 'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : '') + (this.options.className || ''));

		img.onselectstart = Util.falseFn;
		img.onmousemove = Util.falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = Util.bind(this.fire, this, 'load');
		img.onerror = Util.bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function _animateZoom(e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function _reset() {
		var image = this._image,
		    bounds = new _Bounds.Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		DomUtil.setPosition(image, bounds.min);

		image.style.width = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function _updateOpacity() {
		DomUtil.setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function _updateZIndex() {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function _overlayOnError() {
		// @event error: Event
		// Fired when the ImageOverlay layer has loaded its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = exports.imageOverlay = function imageOverlay(url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DivOverlay = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _Point = __webpack_require__(3);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = exports.DivOverlay = _Layer.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function initialize(options, source) {
		Util.setOptions(this, options);

		this._source = source;
	},

	onAdd: function onAdd(map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function onRemove(map) {
		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(Util.bind(DomUtil.remove, undefined, this._container), 200);
		} else {
			DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function setLatLng(latlng) {
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function getContent() {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function setContent(content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function getElement() {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function update() {
		if (!this._map) {
			return;
		}

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function getEvents() {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function isOpen() {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function _updateContent() {
		if (!this._content) {
			return;
		}

		var node = this._contentNode;
		var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function _updatePosition() {
		if (!this._map) {
			return;
		}

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = (0, _Point.toPoint)(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function _getAnchor() {
		return [0, 0];
	}

});

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TileLayer = undefined;
exports.tileLayer = tileLayer;

var _GridLayer = __webpack_require__(83);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */

var TileLayer = exports.TileLayer = _GridLayer.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function initialize(url, options) {

		this._url = url;

		options = Util.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function setUrl(url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function createTile(coords, done) {
		var tile = document.createElement('img');

		DomEvent.on(tile, 'load', Util.bind(this._tileOnLoad, this, done, tile));
		DomEvent.on(tile, 'error', Util.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
   Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
   http://www.w3.org/TR/WCAG20-TECHS/H67
  */
		tile.alt = '';

		/*
   Set role="presentation" to force screen readers to ignore this
   https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
  */
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function getTileUrl(coords) {
		var data = {
			r: Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return Util.template(this._url, Util.extend(data, this.options));
	},

	_tileOnLoad: function _tileOnLoad(done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (Browser.ielt9) {
			setTimeout(Util.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function _tileOnError(done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.src !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function _onTileRemove(e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function _getZoomForUrl() {
		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom,
		    zoomReverse = this.options.zoomReverse,
		    zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function _getSubdomain(tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function _abortLoading() {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = Util.falseFn;
				tile.onerror = Util.falseFn;

				if (!tile.complete) {
					tile.src = Util.emptyImageUrl;
					DomUtil.remove(tile);
				}
			}
		}
	}
});

// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});
exports.TileLayerWMS = undefined;
exports.tileLayerWMS = tileLayerWMS;

var _TileLayer = __webpack_require__(52);

var _Util = __webpack_require__(0);

var _Browser = __webpack_require__(4);

var _CRS = __webpack_require__(54);

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = exports.TileLayerWMS = _TileLayer.TileLayer.extend({

		// @section
		// @aka TileLayer.WMS options
		// If any custom options not documented here are used, they will be sent to the
		// WMS server as extra parameters in each request URL. This can be useful for
		// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
		defaultWmsParams: {
				service: 'WMS',
				request: 'GetMap',

				// @option layers: String = ''
				// **(required)** Comma-separated list of WMS layers to show.
				layers: '',

				// @option styles: String = ''
				// Comma-separated list of WMS styles.
				styles: '',

				// @option format: String = 'image/jpeg'
				// WMS image format (use `'image/png'` for layers with transparency).
				format: 'image/jpeg',

				// @option transparent: Boolean = false
				// If `true`, the WMS service will return images with transparency.
				transparent: false,

				// @option version: String = '1.1.1'
				// Version of the WMS service to use
				version: '1.1.1'
		},

		options: {
				// @option crs: CRS = null
				// Coordinate Reference System to use for the WMS requests, defaults to
				// map CRS. Don't change this if you're not sure what it means.
				crs: null,

				// @option uppercase: Boolean = false
				// If `true`, WMS request parameter keys will be uppercase.
				uppercase: false
		},

		initialize: function initialize(url, options) {

				this._url = url;

				var wmsParams = (0, _Util.extend)({}, this.defaultWmsParams);

				// all keys that are not TileLayer options go to WMS params
				for (var i in options) {
						if (!(i in this.options)) {
								wmsParams[i] = options[i];
						}
				}

				options = (0, _Util.setOptions)(this, options);

				wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && _Browser.retina ? 2 : 1);

				this.wmsParams = wmsParams;
		},

		onAdd: function onAdd(map) {

				this._crs = this.options.crs || map.options.crs;
				this._wmsVersion = parseFloat(this.wmsParams.version);

				var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
				this.wmsParams[projectionKey] = this._crs.code;

				_TileLayer.TileLayer.prototype.onAdd.call(this, map);
		},

		getTileUrl: function getTileUrl(coords) {

				var tileBounds = this._tileCoordsToBounds(coords),
				    nw = this._crs.project(tileBounds.getNorthWest()),
				    se = this._crs.project(tileBounds.getSouthEast()),
				    bbox = (this._wmsVersion >= 1.3 && this._crs === _CRS.EPSG4326 ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(','),
				    url = _TileLayer.TileLayer.prototype.getTileUrl.call(this, coords);

				return url + (0, _Util.getParamString)(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
		},

		// @method setParams(params: Object, noRedraw?: Boolean): this
		// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
		setParams: function setParams(params, noRedraw) {

				(0, _Util.extend)(this.wmsParams, params);

				if (!noRedraw) {
						this.redraw();
				}

				return this;
		}
});

// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
		return new TileLayerWMS(url, options);
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EPSG4326 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(55);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = exports.EPSG4326 = Util.extend({}, _CRS.Earth, {
  code: 'EPSG:4326',
  projection: _Projection.LonLat,
  transformation: (0, _Transformation.toTransformation)(1 / 180, 1, -1 / 180, 0.5)
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LonLat = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = exports.LonLat = {
  project: function project(latlng) {
    return new _Point.Point(latlng.lng, latlng.lat);
  },

  unproject: function unproject(point) {
    return new _LatLng.LatLng(point.y, point.x);
  },

  bounds: new _Bounds.Bounds([-180, -90], [180, 90])
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Polyline = undefined;
exports.polyline = polyline;

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */

var Polyline = exports.Polyline = _Path.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function initialize(latlngs, options) {
		Util.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function getLatLngs() {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function setLatLngs(latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function isEmpty() {
		return !this._latlngs.length;
	},

	closestLayerPoint: function closestLayerPoint(p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = LineUtil._sqClosestPointOnSegment,
		    p1,
		    p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function getCenter() {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i,
		    halfDist,
		    segDist,
		    dist,
		    p1,
		    p2,
		    ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) {
			return null;
		}

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function getBounds() {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function addLatLng(latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = (0, _LatLng.toLatLng)(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function _setLatLngs(latlngs) {
		this._bounds = new _LatLngBounds.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function _defaultShape() {
		return LineUtil.isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function _convertLatLngs(latlngs) {
		var result = [],
		    flat = LineUtil.isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = (0, _LatLng.toLatLng)(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function _project() {
		var pxBounds = new _Bounds.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new _Point.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof _LatLng.LatLng,
		    len = latlngs.length,
		    i,
		    ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function _clipPoints() {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i,
		    j,
		    k,
		    len,
		    len2,
		    segment,
		    points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) {
					continue;
				}

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if (segment[1] !== points[j + 1] || j === len2 - 2) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function _simplifyPoints() {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function _update() {
		if (!this._map) {
			return;
		}

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function _updatePath() {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p, closed) {
		var i,
		    j,
		    k,
		    len,
		    len2,
		    part,
		    w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) {
			return false;
		}

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && j === 0) {
					continue;
				}

				if (LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = LineUtil._flat;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Polygon = undefined;
exports.polygon = polygon;

var _Polyline = __webpack_require__(56);

var _LatLng = __webpack_require__(9);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(8);

var _PolyUtil = __webpack_require__(86);

var PolyUtil = _interopRequireWildcard(_PolyUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = exports.Polygon = _Polyline.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function isEmpty() {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function getCenter() {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i,
		    j,
		    p1,
		    p2,
		    f,
		    area,
		    x,
		    y,
		    center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) {
			return null;
		}

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function _convertLatLngs(latlngs) {
		var result = _Polyline.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof _LatLng.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function _setLatLngs(latlngs) {
		_Polyline.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (LineUtil.isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function _defaultShape() {
		return LineUtil.isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function _clipPoints() {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new _Point.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new _Bounds.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function _updatePath() {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p) {
		var inside = false,
		    part,
		    p1,
		    p2,
		    i,
		    j,
		    k,
		    len,
		    len2;

		if (!this._pxBounds.contains(p)) {
			return false;
		}

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || _Polyline.Polyline.prototype._containsPoint.call(this, p, true);
	}

});

// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssFromModules = cssFromModules;
exports.cssFromModule = cssFromModule;
exports.cssFromTemplate = cssFromTemplate;
exports.cssFromModuleImports = cssFromModuleImports;
exports._cssFromModuleImports = _cssFromModuleImports;

var _resolveUrl = __webpack_require__(25);

var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
var INCLUDE_ATTR = 'include';

function importModule(moduleId) {
  var /** Polymer.DomModule */PolymerDomModule = customElements.get('dom-module');
  if (!PolymerDomModule) {
    return null;
  }
  return PolymerDomModule.import(moduleId);
}

/** @typedef {{assetpath: string}} */
var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

function cssFromModules(moduleIds) {
  var modules = moduleIds.trim().split(/\s+/);
  var cssText = '';
  for (var i = 0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }
  return cssText;
}

function cssFromModule(moduleId) {
  var m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    var cssText = _cssFromModuleImports(m);
    // include css from the first template in the module
    var t = m.querySelector('template');
    if (t) {
      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */m.assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}

function cssFromTemplate(template, baseURI) {
  var cssText = '';
  // if element is a template, get content from its .content
  var e$ = template.content.querySelectorAll('style');
  for (var i = 0; i < e$.length; i++) {
    var e = e$[i];
    // support style sharing by allowing styles to "include"
    // other dom-modules that contain styling
    var include = e.getAttribute(INCLUDE_ATTR);
    if (include) {
      cssText += cssFromModules(include);
    }
    e.parentNode.removeChild(e);
    cssText += baseURI ? (0, _resolveUrl.resolveCss)(e.textContent, baseURI) : e.textContent;
  }
  return cssText;
}

function cssFromModuleImports(moduleId) {
  var m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}

function _cssFromModuleImports(module) {
  var cssText = '';
  var p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (var i = 0; i < p$.length; i++) {
    var p = p$[i];
    if (p.import) {
      var importDoc = p.import;
      // NOTE: polyfill affordance.
      // under the HTMLImports polyfill, there will be no 'body',
      // but the import pseudo-doc can be used directly.
      var container = importDoc.body ? importDoc.body : importDoc;
      cssText += (0, _resolveUrl.resolveCss)(container.textContent, importDoc.baseURI);
    }
  }
  return cssText;
}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomModule = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _resolveUrl = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var modules = {};
var lcModules = {};
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}

/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */

var DomModule = function (_HTMLElement) {
  _inherits(DomModule, _HTMLElement);

  function DomModule() {
    _classCallCheck(this, DomModule);

    return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
  }

  _createClass(DomModule, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this.register();
      }
    }

    /**
     * The absolute URL of the original location of this `dom-module`.
     *
     * This value will differ from this element's `ownerDocument` in the
     * following ways:
     * - Takes into account any `assetpath` attribute added during bundling
     *   to indicate the original location relative to the bundled location
     * - Uses the HTMLImports polyfill's `importForElement` API to ensure
     *   the path is relative to the import document's location since
     *   `ownerDocument` is not currently polyfilled
     */

  }, {
    key: 'register',


    /**
     * Registers the dom-module at a given id. This method should only be called
     * when a dom-module is imperatively created. For
     * example, `document.createElement('dom-module').register('foo')`.
     * @param {string=} id The id at which to register the dom-module.
     */
    value: function register(id) {
      id = id || this.id;
      if (id) {
        this.id = id;
        // store id separate from lowercased id so that
        // in all cases mixedCase id will stored distinctly
        // and lowercase version is a fallback
        modules[id] = this;
        lcModules[id.toLowerCase()] = this;
        styleOutsideTemplateCheck(this);
      }
    }
  }, {
    key: 'assetpath',
    get: function get() {
      // Don't override existing assetpath.
      if (!this.__assetpath) {
        // note: assetpath set via an attribute must be relative to this
        // element's location; accomodate polyfilled HTMLImports
        var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
        var url = (0, _resolveUrl.resolveUrl)(this.getAttribute('assetpath') || '', owner.baseURI);
        this.__assetpath = (0, _resolveUrl.pathFromUrl)(url);
      }
      return this.__assetpath;
    }
  }], [{
    key: 'import',


    /**
     * Retrieves the element specified by the css `selector` in the module
     * registered by `id`. For example, this.import('foo', 'img');
     * @param {string} id The id of the dom-module in which to search.
     * @param {string=} selector The css selector by which to find the element.
     * @return {Element} Returns the element which matches `selector` in the
     * module registered at the specified `id`.
     */
    value: function _import(id, selector) {
      if (id) {
        var m = findModule(id);
        if (m && selector) {
          return m.querySelector(selector);
        }
        return m;
      }
      return null;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['id'];
    }
  }]);

  return DomModule;
}(HTMLElement);

DomModule.prototype['modules'] = modules;

customElements.define('dom-module', DomModule);

exports.DomModule = DomModule;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LegacyElementMixin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(94);

var _elementMixin = __webpack_require__(33);

var _gestureEventListeners = __webpack_require__(65);

var _mixin = __webpack_require__(13);

var _importHref = __webpack_require__(97);

__webpack_require__(66);

__webpack_require__(98);

var _polymerDom = __webpack_require__(17);

var _gestures = __webpack_require__(41);

var _debounce = __webpack_require__(27);

var _async = __webpack_require__(15);

var _path = __webpack_require__(26);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var styleInterface = window.ShadyCSS;

var LegacyElementMixin = exports.LegacyElementMixin = (0, _mixin.dedupingMixin)(function (base) {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   */
  var legacyElementBase = (0, _gestureEventListeners.GestureEventListeners)((0, _elementMixin.ElementMixin)(base));

  /**
   * Map of simple names to touch action names
   * @dict
   */
  var DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };

  /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */

  var LegacyElement = function (_legacyElementBase) {
    _inherits(LegacyElement, _legacyElementBase);

    function LegacyElement() {
      _classCallCheck(this, LegacyElement);

      var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

      _this.root = _this;
      /** @type {boolean} */
      _this.isAttached;
      /** @type {WeakMap<!Element, !Object<string, !Function>>} */
      _this.__boundListeners;
      /** @type {Object<string, Function>} */
      _this._debouncers;
      _this.created();
      return _this;
    }

    /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     */


    _createClass(LegacyElement, [{
      key: 'created',
      value: function created() {}

      /**
       * Provides an implementation of `connectedCallback`
       * which adds Polymer legacy API's `attached` method.
       * @override
       */

    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
        this.isAttached = true;
        this.attached();
      }

      /**
       * Legacy callback called during `connectedCallback`, for overriding
       * by the user.
       */

    }, {
      key: 'attached',
      value: function attached() {}

      /**
       * Provides an implementation of `disconnectedCallback`
       * which adds Polymer legacy API's `detached` method.
       * @override
       */

    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
        this.isAttached = false;
        this.detached();
      }

      /**
       * Legacy callback called during `disconnectedCallback`, for overriding
       * by the user.
       */

    }, {
      key: 'detached',
      value: function detached() {}

      /**
       * Provides an override implementation of `attributeChangedCallback`
       * which adds the Polymer legacy API's `attributeChanged` method.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @override
       */

    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
          this.attributeChanged(name, old, value);
        }
      }

      /**
       * Legacy callback called during `attributeChangedChallback`, for overriding
       * by the user.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       */

    }, {
      key: 'attributeChanged',
      value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for class initialization via the `_registered` callback.
       * This is called only when the first instance of the element is created.
       *
       * @override
       */

    }, {
      key: '_initializeProperties',
      value: function _initializeProperties() {
        var proto = Object.getPrototypeOf(this);
        if (!proto.hasOwnProperty('__hasRegisterFinished')) {
          proto.__hasRegisterFinished = true;
          this._registered();
        }
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
      }

      /**
       * Called automatically when an element is initializing.
       * Users may override this method to perform class registration time
       * work. The implementation should ensure the work is performed
       * only once for the class.
       * @protected
       */

    }, {
      key: '_registered',
      value: function _registered() {}

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for installing `hostAttributes` and `listeners`.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        this._ensureAttributes();
        this._applyListeners();
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
      }

      /**
       * Ensures an element has required attributes. Called when the element
       * is being readied via `ready`. Users should override to set the
       * element's required attributes. The implementation should be sure
       * to check and not override existing attributes added by
       * the user of the element. Typically, setting attributes should be left
       * to the element user and not done here; reasonable exceptions include
       * setting aria roles and focusability.
       * @protected
       */

    }, {
      key: '_ensureAttributes',
      value: function _ensureAttributes() {}

      /**
       * Adds element event listeners. Called when the element
       * is being readied via `ready`. Users should override to
       * add any required element event listeners.
       * In performance critical elements, the work done here should be kept
       * to a minimum since it is done before the element is rendered. In
       * these elements, consider adding listeners asychronously so as not to
       * block render.
       * @protected
       */

    }, {
      key: '_applyListeners',
      value: function _applyListeners() {}

      /**
       * Converts a typed JavaScript value to a string.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features. To customize
       * how properties are serialized to attributes for attribute bindings and
       * `reflectToAttribute: true` properties as well as this method, override
       * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
       *
       * @param {*} value Value to deserialize
       * @return {string | undefined} Serialized value
       */

    }, {
      key: 'serialize',
      value: function serialize(value) {
        return this._serializeValue(value);
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.  To customize
       * how attributes are deserialized to properties for in
       * `attributeChangedCallback`, override `_deserializeValue` method
       * provided by `Polymer.PropertyAccessors`.
       *
       * @param {string} value String to deserialize
       * @param {*} type Type to deserialize the string to
       * @return {*} Returns the deserialized value in the `type` given.
       */

    }, {
      key: 'deserialize',
      value: function deserialize(value, type) {
        return this._deserializeValue(value, type);
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */

    }, {
      key: 'reflectPropertyToAttribute',
      value: function reflectPropertyToAttribute(property, attribute, value) {
        this._propertyToAttribute(property, attribute, value);
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @param {Element} node Element to set attribute to.
       */

    }, {
      key: 'serializeValueToAttribute',
      value: function serializeValueToAttribute(value, attribute, node) {
        this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
      }

      /**
       * Copies own properties (including accessor descriptors) from a source
       * object to a target object.
       *
       * @param {Object} prototype Target object to copy properties to.
       * @param {Object} api Source object to copy properties from.
       * @return {Object} prototype object that was passed as first argument.
       */

    }, {
      key: 'extend',
      value: function extend(prototype, api) {
        if (!(prototype && api)) {
          return prototype || api;
        }
        var n$ = Object.getOwnPropertyNames(api);
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
          var pd = Object.getOwnPropertyDescriptor(api, n);
          if (pd) {
            Object.defineProperty(prototype, n, pd);
          }
        }
        return prototype;
      }

      /**
       * Copies props from a source object to a target object.
       *
       * Note, this method uses a simple `for...in` strategy for enumerating
       * properties.  To ensure only `ownProperties` are copied from source
       * to target and that accessor implementations are copied, use `extend`.
       *
       * @param {Object} target Target object to copy properties to.
       * @param {Object} source Source object to copy properties from.
       * @return {Object} Target object that was passed as first argument.
       */

    }, {
      key: 'mixin',
      value: function mixin(target, source) {
        for (var i in source) {
          target[i] = source[i];
        }
        return target;
      }

      /**
       * Sets the prototype of an object.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       * @param {Object} object The object on which to set the prototype.
       * @param {Object} prototype The prototype that will be set on the given
       * `object`.
       * @return {Object} Returns the given `object` with its prototype set
       * to the given `prototype` object.
       */

    }, {
      key: 'chainObject',
      value: function chainObject(object, prototype) {
        if (object && prototype && object !== prototype) {
          object.__proto__ = prototype;
        }
        return object;
      }

      /* **** Begin Template **** */

      /**
       * Calls `importNode` on the `content` of the `template` specified and
       * returns a document fragment containing the imported content.
       *
       * @param {HTMLTemplateElement} template HTML template element to instance.
       * @return {DocumentFragment} Document fragment containing the imported
       *   template content.
      */

    }, {
      key: 'instanceTemplate',
      value: function instanceTemplate(template) {
        var content = this.constructor._contentForTemplate(template);
        var dom = /** @type {DocumentFragment} */
        document.importNode(content, true);
        return dom;
      }

      /* **** Begin Events **** */

      /**
       * Dispatches a custom event with an optional detail value.
       *
       * @param {string} type Name of event type.
       * @param {*=} detail Detail value containing event-specific
       *   payload.
       * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
       *  options Object specifying options.  These may include:
       *  `bubbles` (boolean, defaults to `true`),
       *  `cancelable` (boolean, defaults to false), and
       *  `node` on which to fire the event (HTMLElement, defaults to `this`).
       * @return {Event} The new event that was fired.
       */

    }, {
      key: 'fire',
      value: function fire(type, detail, options) {
        options = options || {};
        detail = detail === null || detail === undefined ? {} : detail;
        var event = new Event(type, {
          bubbles: options.bubbles === undefined ? true : options.bubbles,
          cancelable: Boolean(options.cancelable),
          composed: options.composed === undefined ? true : options.composed
        });
        event.detail = detail;
        var node = options.node || this;
        node.dispatchEvent(event);
        return event;
      }

      /**
       * Convenience method to add an event listener on a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to add event listener to.
       * @param {string} eventName Name of event to listen for.
       * @param {string} methodName Name of handler method on `this` to call.
       */

    }, {
      key: 'listen',
      value: function listen(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
        var bl = hbl.get(node);
        if (!bl) {
          bl = {};
          hbl.set(node, bl);
        }
        var key = eventName + methodName;
        if (!bl[key]) {
          bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
        }
      }

      /**
       * Convenience method to remove an event listener from a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to remove event listener from.
       * @param {string} eventName Name of event to stop listening to.
       * @param {string} methodName Name of handler method on `this` to not call
       anymore.
       */

    }, {
      key: 'unlisten',
      value: function unlisten(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        var bl = this.__boundListeners && this.__boundListeners.get(node);
        var key = eventName + methodName;
        var handler = bl && bl[key];
        if (handler) {
          this._removeEventListenerFromNode(node, eventName, handler);
          bl[key] = null;
        }
      }

      /**
       * Override scrolling behavior to all direction, one direction, or none.
       *
       * Valid scroll directions:
       *   - 'all': scroll in any direction
       *   - 'x': scroll only in the 'x' direction
       *   - 'y': scroll only in the 'y' direction
       *   - 'none': disable scrolling for this node
       *
       * @param {string=} direction Direction to allow scrolling
       * Defaults to `all`.
       * @param {Element=} node Element to apply scroll direction setting.
       * Defaults to `this`.
       */

    }, {
      key: 'setScrollDirection',
      value: function setScrollDirection(direction, node) {
        (0, _gestures.setTouchAction)(node || this, DIRECTION_MAP[direction] || 'auto');
      }
      /* **** End Events **** */

      /**
       * Convenience method to run `querySelector` on this local DOM scope.
       *
       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
       *
       * @param {string} slctr Selector to run on this local DOM scope
       * @return {Element} Element found by the selector, or null if not found.
       */

    }, {
      key: '$$',
      value: function $$(slctr) {
        return this.root.querySelector(slctr);
      }

      /**
       * Return the element whose local dom within which this element
       * is contained. This is a shorthand for
       * `this.getRootNode().host`.
       * @this {Element}
       */

    }, {
      key: 'distributeContent',


      /**
       * Force this element to distribute its children to its local dom.
       * This should not be necessary as of Polymer 2.0.2 and is provided only
       * for backwards compatibility.
       */
      value: function distributeContent() {
        if (window.ShadyDOM && this.shadowRoot) {
          ShadyDOM.flush();
        }
      }

      /**
       * Returns a list of nodes that are the effective childNodes. The effective
       * childNodes list is the same as the element's childNodes except that
       * any `<content>` elements are replaced with the list of nodes distributed
       * to the `<content>`, the result of its `getDistributedNodes` method.
       * @this {Element}
       * @return {Array<Node>} List of effctive child nodes.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return (
          /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(this).getEffectiveChildNodes()
        );
      }

      /**
       * Returns a list of nodes distributed within this element that match
       * `selector`. These can be dom children or elements distributed to
       * children that are insertion points.
       * @param {string} selector Selector to run.
       * @this {Element}
       * @return {Array<Node>} List of distributed elements that match selector.
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        return (
          /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(this).queryDistributedElements(selector)
        );
      }

      /**
       * Returns a list of elements that are the effective children. The effective
       * children list is the same as the element's children except that
       * any `<content>` elements are replaced with the list of elements
       * distributed to the `<content>`.
       *
       * @return {Array<Node>} List of effctive children.
       */

    }, {
      key: 'getEffectiveChildren',
      value: function getEffectiveChildren() {
        var list = this.getEffectiveChildNodes();
        return list.filter(function ( /** @type {Node} */n) {
          return n.nodeType === Node.ELEMENT_NODE;
        });
      }

      /**
       * Returns a string of text content that is the concatenation of the
       * text content's of the element's effective childNodes (the elements
       * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
       *
       * @return {string} List of effctive children.
       */

    }, {
      key: 'getEffectiveTextContent',
      value: function getEffectiveTextContent() {
        var cn = this.getEffectiveChildNodes();
        var tc = [];
        for (var i = 0, c; c = cn[i]; i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      }

      /**
       * Returns the first effective childNode within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {Object<Node>} First effective child node that matches selector.
       */

    }, {
      key: 'queryEffectiveChildren',
      value: function queryEffectiveChildren(selector) {
        var e$ = this.queryDistributedElements(selector);
        return e$ && e$[0];
      }

      /**
       * Returns a list of effective childNodes within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {Array<Node>} List of effective child nodes that match selector.
       */

    }, {
      key: 'queryAllEffectiveChildren',
      value: function queryAllEffectiveChildren(selector) {
        return this.queryDistributedElements(selector);
      }

      /**
       * Returns a list of nodes distributed to this element's `<slot>`.
       *
       * If this element contains more than one `<slot>` in its local DOM,
       * an optional selector may be passed to choose the desired content.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<slot>`.  Defaults to `content`.
       * @return {Array<Node>} List of distributed nodes for the `<slot>`.
       */

    }, {
      key: 'getContentChildNodes',
      value: function getContentChildNodes(slctr) {
        var content = this.root.querySelector(slctr || 'slot');
        return content ? /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(content).getDistributedNodes() : [];
      }

      /**
       * Returns a list of element children distributed to this element's
       * `<slot>`.
       *
       * If this element contains more than one `<slot>` in its
       * local DOM, an optional selector may be passed to choose the desired
       * content.  This method differs from `getContentChildNodes` in that only
       * elements are returned.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<HTMLElement>} List of distributed nodes for the
       *   `<slot>`.
       * @suppress {invalidCasts}
       */

    }, {
      key: 'getContentChildren',
      value: function getContentChildren(slctr) {
        return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
            return n.nodeType === Node.ELEMENT_NODE;
          })
        );
      }

      /**
       * Checks whether an element is in this element's light DOM tree.
       *
       * @param {?Node} node The element to be checked.
       * @this {Element}
       * @return {boolean} true if node is in this element's light DOM tree.
       */

    }, {
      key: 'isLightDescendant',
      value: function isLightDescendant(node) {
        return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
      }

      /**
       * Checks whether an element is in this element's local DOM tree.
       *
       * @param {Element=} node The element to be checked.
       * @return {boolean} true if node is in this element's local DOM tree.
       */

    }, {
      key: 'isLocalDescendant',
      value: function isLocalDescendant(node) {
        return this.root === node.getRootNode();
      }

      // NOTE: should now be handled by ShadyCss library.

    }, {
      key: 'scopeSubtree',
      value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


      /**
       * Returns the computed style value for the given property.
       * @param {string} property The css property name.
       * @return {string} Returns the computed css property value for the given
       * `property`.
       */

    }, {
      key: 'getComputedStyleValue',
      value: function getComputedStyleValue(property) {
        return styleInterface.getComputedStyleValue(this, property);
      }

      // debounce

      /**
       * Call `debounce` to collapse multiple requests for a named task into
       * one invocation which is made after the wait time has elapsed with
       * no new request.  If no wait time is given, the callback will be called
       * at microtask timing (guaranteed before paint).
       *
       *     debouncedClickAction(e) {
       *       // will not call `processClick` more than once per 100ms
       *       this.debounce('click', function() {
       *        this.processClick();
       *       } 100);
       *     }
       *
       * @param {string} jobName String to indentify the debounce job.
       * @param {function()} callback Function that is called (with `this`
       *   context) when the wait time elapses.
       * @param {number} wait Optional wait time in milliseconds (ms) after the
       *   last signal that must elapse before invoking `callback`
       * @return {Object} Returns a debouncer object on which exists the
       * following methods: `isActive()` returns true if the debouncer is
       * active; `cancel()` cancels the debouncer if it is active;
       * `flush()` immediately invokes the debounced callback if the debouncer
       * is active.
       */

    }, {
      key: 'debounce',
      value: function debounce(jobName, callback, wait) {
        this._debouncers = this._debouncers || {};
        return this._debouncers[jobName] = _debounce.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? _async.timeOut.after(wait) : _async.microTask, callback.bind(this));
      }

      /**
       * Returns whether a named debouncer is active.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       * @return {boolean} Whether the debouncer is active (has not yet fired).
       */

    }, {
      key: 'isDebouncerActive',
      value: function isDebouncerActive(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.isActive());
      }

      /**
       * Immediately calls the debouncer `callback` and inactivates it.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       */

    }, {
      key: 'flushDebouncer',
      value: function flushDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.flush();
        }
      }

      /**
       * Cancels an active debouncer.  The `callback` will not be called.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       */

    }, {
      key: 'cancelDebouncer',
      value: function cancelDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.cancel();
        }
      }

      /**
       * Runs a callback function asyncronously.
       *
       * By default (if no waitTime is specified), async callbacks are run at
       * microtask timing, which will occur before paint.
       *
       * @param {Function} callback The callback function to run, bound to `this`.
       * @param {number=} waitTime Time to wait before calling the
       *   `callback`.  If unspecified or 0, the callback will be run at microtask
       *   timing (before paint).
       * @return {number} Handle that may be used to cancel the async job.
       */

    }, {
      key: 'async',
      value: function async(callback, waitTime) {
        return waitTime > 0 ? _async.timeOut.run(callback.bind(this), waitTime) : ~_async.microTask.run(callback.bind(this));
      }

      /**
       * Cancels an async operation started with `async`.
       *
       * @param {number} handle Handle returned from original `async` call to
       *   cancel.
       */

    }, {
      key: 'cancelAsync',
      value: function cancelAsync(handle) {
        handle < 0 ? _async.microTask.cancel(~handle) : _async.timeOut.cancel(handle);
      }

      // other

      /**
       * Convenience method for creating an element and configuring it.
       *
       * @param {string} tag HTML element tag to create.
       * @param {Object} props Object of properties to configure on the
       *    instance.
       * @return {Element} Newly created and configured element.
       */

    }, {
      key: 'create',
      value: function create(tag, props) {
        var elt = document.createElement(tag);
        if (props) {
          if (elt.setProperties) {
            elt.setProperties(props);
          } else {
            for (var n in props) {
              elt[n] = props[n];
            }
          }
        }
        return elt;
      }

      /**
       * Convenience method for importing an HTML document imperatively.
       *
       * This method creates a new `<link rel="import">` element with
       * the provided URL and appends it to the document to start loading.
       * In the `onload` callback, the `import` property of the `link`
       * element will contain the imported document contents.
       *
       * @param {string} href URL to document to load.
       * @param {Function} onload Callback to notify when an import successfully
       *   loaded.
       * @param {Function} onerror Callback to notify when an import
       *   unsuccessfully loaded.
       * @param {boolean} optAsync True if the import should be loaded `async`.
       *   Defaults to `false`.
       * @return {HTMLLinkElement} The link element for the URL to be loaded.
       */

    }, {
      key: 'importHref',
      value: function importHref(href, onload, onerror, optAsync) {
        // eslint-disable-line no-unused-vars
        var loadFn = onload ? onload.bind(this) : null;
        var errorFn = onerror ? onerror.bind(this) : null;
        return (0, _importHref.importHref)(href, loadFn, errorFn, optAsync);
      }

      /**
       * Polyfill for Element.prototype.matches, which is sometimes still
       * prefixed.
       *
       * @param {string} selector Selector to test.
       * @param {Element=} node Element to test the selector against.
       * @return {boolean} Whether the element matches the selector.
       */

    }, {
      key: 'elementMatches',
      value: function elementMatches(selector, node) {
        return (0, _polymerDom.matchesSelector)(node || this, selector);
      }

      /**
       * Toggles an HTML attribute on or off.
       *
       * @param {string} name HTML attribute name
       * @param {boolean=} bool Boolean to force the attribute on or off.
       *    When unspecified, the state of the attribute will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       */

    }, {
      key: 'toggleAttribute',
      value: function toggleAttribute(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.hasAttribute(name);
        }
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      }

      /**
       * Toggles a CSS class on or off.
       *
       * @param {string} name CSS class name
       * @param {boolean=} bool Boolean to force the class on or off.
       *    When unspecified, the state of the class will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       */

    }, {
      key: 'toggleClass',
      value: function toggleClass(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.classList.contains(name);
        }
        if (bool) {
          node.classList.add(name);
        } else {
          node.classList.remove(name);
        }
      }

      /**
       * Cross-platform helper for setting an element's CSS `transform` property.
       *
       * @param {string} transformText Transform setting.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`
       */

    }, {
      key: 'transform',
      value: function transform(transformText, node) {
        node = /** @type {Element} */node || this;
        node.style.webkitTransform = transformText;
        node.style.transform = transformText;
      }

      /**
       * Cross-platform helper for setting an element's CSS `translate3d`
       * property.
       *
       * @param {number} x X offset.
       * @param {number} y Y offset.
       * @param {number} z Z offset.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`.
       */

    }, {
      key: 'translate3d',
      value: function translate3d(x, y, z, node) {
        node = /** @type {Element} */node || this;
        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
      }

      /**
       * Removes an item from an array, if it exists.
       *
       * If the array is specified by path, a change notification is
       * generated, so that observers, data bindings and computed
       * properties watching that path can update.
       *
       * If the array is passed directly, **no change
       * notification is generated**.
       *
       * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
       *   (or the array itself).
       * @param {*} item Item to remove.
       * @return {Array} Array containing item removed.
       */

    }, {
      key: 'arrayDelete',
      value: function arrayDelete(arrayOrPath, item) {
        var index = void 0;
        if (Array.isArray(arrayOrPath)) {
          index = arrayOrPath.indexOf(item);
          if (index >= 0) {
            return arrayOrPath.splice(index, 1);
          }
        } else {
          var arr = (0, _path.get)(this, arrayOrPath);
          index = arr.indexOf(item);
          if (index >= 0) {
            return this.splice(arrayOrPath, index, 1);
          }
        }
        return null;
      }

      // logging

      /**
       * Facades `console.log`/`warn`/`error` as override point.
       *
       * @param {string} level One of 'log', 'warn', 'error'
       * @param {Array} args Array of strings or objects to log
       */

    }, {
      key: '_logger',
      value: function _logger(level, args) {
        var _console;

        // accept ['foo', 'bar'] and [['foo', 'bar']]
        if (Array.isArray(args) && args.length === 1) {
          args = args[0];
        }
        switch (level) {
          case 'log':
          case 'warn':
          case 'error':
            (_console = console)[level].apply(_console, _toConsumableArray(args));
        }
      }

      /**
       * Facades `console.log` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_log',
      value: function _log() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        this._logger('log', args);
      }

      /**
       * Facades `console.warn` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_warn',
      value: function _warn() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        this._logger('warn', args);
      }

      /**
       * Facades `console.error` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_error',
      value: function _error() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        this._logger('error', args);
      }

      /**
       * Formats a message using the element type an a method name.
       *
       * @param {string} methodName Method name to associate with message
       * @param {...*} args Array of strings or objects to log
       * @return {Array} Array with formatting information for `console`
       *   logging.
       */

    }, {
      key: '_logf',
      value: function _logf(methodName) {
        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        return ['[%s::%s]', this.is, methodName].concat(args);
      }
    }, {
      key: 'domHost',
      get: function get() {
        var root = this.getRootNode();
        return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
      }
    }]);

    return LegacyElement;
  }(legacyElementBase);

  LegacyElement.prototype.is = '';

  return LegacyElement;
});

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toCssText = toCssText;
exports.rulesForStyle = rulesForStyle;
exports.isKeyframesSelector = isKeyframesSelector;
exports.forEachRule = forEachRule;
exports.applyCss = applyCss;
exports.createScopeStyle = createScopeStyle;
exports.applyStylePlaceHolder = applyStylePlaceHolder;
exports.applyStyle = applyStyle;
exports.isTargetedBuild = isTargetedBuild;
exports.getCssBuildType = getCssBuildType;
exports.processVariableAndFallback = processVariableAndFallback;
exports.setElementClassRaw = setElementClassRaw;
exports.getIsExtends = getIsExtends;

var _styleSettings = __webpack_require__(37);

var _cssParse = __webpack_require__(38);

var _commonRegex = __webpack_require__(39);

/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */
function toCssText(rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = (0, _cssParse.parse)(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return (0, _cssParse.stringify)(rules, _styleSettings.nativeCssVariables);
}

/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */
// eslint-disable-line no-unused-vars
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = (0, _cssParse.parse)(style.textContent);
  }
  return style['__cssRules'] || null;
}

// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */
function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) && rule['parent']['type'] === _cssParse.types.KEYFRAMES_RULE;
}

/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  var skipRules = false;
  var type = node['type'];
  if (onlyActiveRules) {
    if (type === _cssParse.types.MEDIA_RULE) {
      var matchMedia = node['selector'].match(_commonRegex.MEDIA_MATCH);
      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === _cssParse.types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === _cssParse.types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === _cssParse.types.MIXIN_RULE) {
    skipRules = true;
  }
  var r$ = node['rules'];
  if (r$ && !skipRules) {
    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}

// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */
function applyCss(cssText, moniker, target, contextNode) {
  var style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}

/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */
function createScopeStyle(cssText, moniker) {
  var style = /** @type {HTMLStyleElement} */document.createElement('style');
  if (moniker) {
    style.setAttribute('scope', moniker);
  }
  style.textContent = cssText;
  return style;
}

/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */
var lastHeadApplyNode = null;

// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {!Comment}
 */
function applyStylePlaceHolder(moniker) {
  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
  var after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;
  var scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}

/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */
function applyStyle(style, target, contextNode) {
  target = target || document.head;
  var after = contextNode && contextNode.nextSibling || target.firstChild;
  target.insertBefore(style, after);
  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    var position = style.compareDocumentPosition(lastHeadApplyNode);
    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}

/**
 * @param {string} buildType
 * @return {boolean}
 */
function isTargetedBuild(buildType) {
  return _styleSettings.nativeShadow ? buildType === 'shadow' : buildType === 'shady';
}

/**
 * @param {Element} element
 * @return {?string}
 */
function getCssBuildType(element) {
  return element.getAttribute('css-build');
}

/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */
function findMatchingParen(text, start) {
  var level = 0;
  for (var i = start, l = text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */
function processVariableAndFallback(str, callback) {
  // find 'var('
  var start = str.indexOf('var(');
  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  }
  //${prefix}var(${inner})${suffix}
  var end = findMatchingParen(str, start + 3);
  var inner = str.substring(start + 4, end);
  var prefix = str.substring(0, start);
  // suffix may have other variables
  var suffix = processVariableAndFallback(str.substring(end + 1), callback);
  var comma = inner.indexOf(',');
  // value and fallback args should be trimmed to match in property lookup
  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  }
  // var(${value},${fallback})
  var value = inner.substring(0, comma).trim();
  var fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}

/**
 * @param {Element} element
 * @param {string} value
 */
function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (_styleSettings.nativeShadow) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}

/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */
function getIsExtends(element) {
  var localName = element['localName'];
  var is = '',
      typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = element.getAttribute && element.getAttribute('is') || '';
    }
  } else {
    is = /** @type {?} */element.is;
    typeExtension = /** @type {?} */element.extends;
  }
  return { is: is, typeExtension: typeExtension };
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var templateMap = {};
exports.default = templateMap;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {Promise<void>} */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = documentWait;
var readyPromise = null;

/** @type {?function(?function())} */
var whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
var resolveFn = void 0;

/**
 * @param {?function()} callback
 */
function documentWait(callback) {
  requestAnimationFrame(function () {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise(function (resolve) {
          resolveFn = resolve;
        });
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', function () {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function () {
        callback && callback();
      });
    }
  });
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStyleInterfaceInterface = exports.CustomStyleProvider = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _documentWait = __webpack_require__(63);

var _documentWait2 = _interopRequireDefault(_documentWait);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
 */
var CustomStyleProvider = exports.CustomStyleProvider = void 0;

var SEEN_MARKER = '__seenByShadyCSS';
var CACHED_STYLE = '__shadyCSSCachedStyle';

/** @type {?function(!HTMLStyleElement)} */
var transformFn = null;

/** @type {?function()} */
var validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/

var CustomStyleInterface = function () {
  function CustomStyleInterface() {
    _classCallCheck(this, CustomStyleInterface);

    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */


  _createClass(CustomStyleInterface, [{
    key: 'enqueueDocumentValidation',
    value: function enqueueDocumentValidation() {
      if (this['enqueued'] || !validateFn) {
        return;
      }
      this['enqueued'] = true;
      (0, _documentWait2.default)(validateFn);
    }
    /**
     * @param {!HTMLStyleElement} style
     */

  }, {
    key: 'addCustomStyle',
    value: function addCustomStyle(style) {
      if (!style[SEEN_MARKER]) {
        style[SEEN_MARKER] = true;
        this['customStyles'].push(style);
        this.enqueueDocumentValidation();
      }
    }
    /**
     * @param {!CustomStyleProvider} customStyle
     * @return {HTMLStyleElement}
     */

  }, {
    key: 'getStyleForCustomStyle',
    value: function getStyleForCustomStyle(customStyle) {
      if (customStyle[CACHED_STYLE]) {
        return customStyle[CACHED_STYLE];
      }
      var style = void 0;
      if (customStyle['getStyle']) {
        style = customStyle['getStyle']();
      } else {
        style = customStyle;
      }
      return style;
    }
    /**
     * @return {!Array<!CustomStyleProvider>}
     */

  }, {
    key: 'processStyles',
    value: function processStyles() {
      var cs = this['customStyles'];
      for (var i = 0; i < cs.length; i++) {
        var customStyle = cs[i];
        if (customStyle[CACHED_STYLE]) {
          continue;
        }
        var style = this.getStyleForCustomStyle(customStyle);
        if (style) {
          // HTMLImports polyfill may have cloned the style into the main document,
          // which is referenced with __appliedElement.
          var styleToTransform = /** @type {!HTMLStyleElement} */style['__appliedElement'] || style;
          if (transformFn) {
            transformFn(styleToTransform);
          }
          customStyle[CACHED_STYLE] = styleToTransform;
        }
      }
      return cs;
    }
  }]);

  return CustomStyleInterface;
}();

exports.default = CustomStyleInterface;


CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get: function get() {
      return transformFn;
    },

    /** @param {?function(!HTMLStyleElement)} fn */
    set: function set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get: function get() {
      return validateFn;
    },

    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set: function set(fn) {
      var needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    }
  }
});

/** @typedef {{
 * customStyles: !Array<!CustomStyleProvider>,
 * addCustomStyle: function(!CustomStyleProvider),
 * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
 * findStyles: function(),
 * transformCallback: ?function(!HTMLStyleElement),
 * validateCallback: ?function()
 * }}
 */
var CustomStyleInterfaceInterface = exports.CustomStyleInterfaceInterface = void 0;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GestureEventListeners = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _gestures = __webpack_require__(41);

var gestures$0 = _interopRequireWildcard(_gestures);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @const {Polymer.Gestures}
 */
var gestures = gestures$0;

var GestureEventListeners = exports.GestureEventListeners = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  var GestureEventListeners = function (_superClass) {
    _inherits(GestureEventListeners, _superClass);

    function GestureEventListeners() {
      _classCallCheck(this, GestureEventListeners);

      return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
    }

    _createClass(GestureEventListeners, [{
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        if (!gestures.addListener(node, eventName, handler)) {
          _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
        }
      }
    }, {
      key: '_removeEventListenerFromNode',
      value: function _removeEventListenerFromNode(node, eventName, handler) {
        if (!gestures.removeListener(node, eventName, handler)) {
          _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
        }
      }
    }]);

    return GestureEventListeners;
  }(superClass);

  return GestureEventListeners;
});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flush = undefined;
exports.beforeNextRender = beforeNextRender;
exports.afterNextRender = afterNextRender;

__webpack_require__(2);

var scheduled = false;
var beforeRenderQueue = [];
var afterRenderQueue = [];

function schedule() {
  scheduled = true;
  // before next render
  requestAnimationFrame(function () {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    // after the render
    setTimeout(function () {
      runQueue(afterRenderQueue);
    });
  });
}

function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}

function runQueue(queue) {
  for (var i = 0, l = queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}

function callMethod(info) {
  var context = info[0];
  var callback = info[1];
  var args = info[2];
  try {
    callback.apply(context, args);
  } catch (e) {
    setTimeout(function () {
      throw e;
    });
  }
}

function flush() {
  while (beforeRenderQueue.length || afterRenderQueue.length) {
    flushQueue(beforeRenderQueue);
    flushQueue(afterRenderQueue);
  }
  scheduled = false;
}

function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}

function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}

exports.flush = flush;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlattenedNodesObserver = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _arraySplice = __webpack_require__(68);

var _async = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Returns true if `node` is a slot element
 * @param {HTMLElement} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */
function isSlot(node) {
  return node.localName === 'slot';
}

/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * @memberof Polymer
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 */

var FlattenedNodesObserver = function () {
  _createClass(FlattenedNodesObserver, null, [{
    key: 'getFlattenedNodes',


    /**
     * Returns the list of flattened nodes for the given `node`.
     * This list consists of a node's children and, for any children
     * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
     * For example, if the observed node has children `<a></a><slot></slot><b></b>`
     * and the `<slot>` has one `<div>` assigned to it, then the flattened
     * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
     * `<slot>` elements assigned to it, these are flattened as well.
     *
     * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
     * @return {Array} The list of flattened nodes for the given `node`.
    */
    value: function getFlattenedNodes(node) {
      if (isSlot(node)) {
        return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
        );
      } else {
        return Array.from(node.childNodes).map(function (node) {
          if (isSlot(node)) {
            return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
            );
          } else {
            return [node];
          }
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
      }
    }

    /**
     * @param {Node} target Node on which to listen for changes.
     * @param {Function} callback Function called when there are additions
     * or removals from the target's list of flattened nodes.
    */

  }]);

  function FlattenedNodesObserver(target, callback) {
    var _this = this;

    _classCallCheck(this, FlattenedNodesObserver);

    /** @type {MutationObserver} */
    this._shadyChildrenObserver = null;
    /** @type {MutationObserver} */
    this._nativeChildrenObserver = null;
    this._connected = false;
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /** @type {function()} */
    this._boundSchedule = function () {
      _this._schedule();
    };
    this.connect();
    this._schedule();
  }

  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   */


  _createClass(FlattenedNodesObserver, [{
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (isSlot(this._target)) {
        this._listenSlots([this._target]);
      } else {
        this._listenSlots(this._target.children);
        if (window.ShadyDOM) {
          this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
            _this2._processMutations(mutations);
          });
        } else {
          this._nativeChildrenObserver = new MutationObserver(function (mutations) {
            _this2._processMutations(mutations);
          });
          this._nativeChildrenObserver.observe(this._target, { childList: true });
        }
      }
      this._connected = true;
    }

    /**
     * Deactivates the flattened nodes observer. After calling this method
     * the observer callback will not be called when changes to flattened nodes
     * occur. The `connect` method may be subsequently called to reactivate
     * the observer.
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (isSlot(this._target)) {
        this._unlistenSlots([this._target]);
      } else {
        this._unlistenSlots(this._target.children);
        if (window.ShadyDOM && this._shadyChildrenObserver) {
          ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
          this._shadyChildrenObserver = null;
        } else if (this._nativeChildrenObserver) {
          this._nativeChildrenObserver.disconnect();
          this._nativeChildrenObserver = null;
        }
      }
      this._connected = false;
    }
  }, {
    key: '_schedule',
    value: function _schedule() {
      var _this3 = this;

      if (!this._scheduled) {
        this._scheduled = true;
        _async.microTask.run(function () {
          return _this3.flush();
        });
      }
    }
  }, {
    key: '_processMutations',
    value: function _processMutations(mutations) {
      this._processSlotMutations(mutations);
      this.flush();
    }
  }, {
    key: '_processSlotMutations',
    value: function _processSlotMutations(mutations) {
      if (mutations) {
        for (var i = 0; i < mutations.length; i++) {
          var mutation = mutations[i];
          if (mutation.addedNodes) {
            this._listenSlots(mutation.addedNodes);
          }
          if (mutation.removedNodes) {
            this._unlistenSlots(mutation.removedNodes);
          }
        }
      }
    }

    /**
     * Flushes the observer causing any pending changes to be immediately
     * delivered the observer callback. By default these changes are delivered
     * asynchronously at the next microtask checkpoint.
     *
     * @return {boolean} Returns true if any pending changes caused the observer
     * callback to run.
     */

  }, {
    key: 'flush',
    value: function flush() {
      if (!this._connected) {
        return false;
      }
      if (window.ShadyDOM) {
        ShadyDOM.flush();
      }
      if (this._nativeChildrenObserver) {
        this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
      } else if (this._shadyChildrenObserver) {
        this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
      }
      this._scheduled = false;
      var info = {
        target: this._target,
        addedNodes: [],
        removedNodes: []
      };
      var newNodes = this.constructor.getFlattenedNodes(this._target);
      var splices = (0, _arraySplice.calculateSplices)(newNodes, this._effectiveNodes);
      // process removals
      for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
          info.removedNodes.push(n);
        }
      }
      // process adds
      for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
        for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
          info.addedNodes.push(newNodes[_j]);
        }
      }
      // update cache
      this._effectiveNodes = newNodes;
      var didFlush = false;
      if (info.addedNodes.length || info.removedNodes.length) {
        didFlush = true;
        this.callback.call(this._target, info);
      }
      return didFlush;
    }
  }, {
    key: '_listenSlots',
    value: function _listenSlots(nodeList) {
      for (var i = 0; i < nodeList.length; i++) {
        var n = nodeList[i];
        if (isSlot(n)) {
          n.addEventListener('slotchange', this._boundSchedule);
        }
      }
    }
  }, {
    key: '_unlistenSlots',
    value: function _unlistenSlots(nodeList) {
      for (var i = 0; i < nodeList.length; i++) {
        var n = nodeList[i];
        if (isSlot(n)) {
          n.removeEventListener('slotchange', this._boundSchedule);
        }
      }
    }
  }]);

  return FlattenedNodesObserver;
}();

exports.FlattenedNodesObserver = FlattenedNodesObserver;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSplices = undefined;

__webpack_require__(2);

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;

// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  // "Deletion" columns
  var rowCount = oldEnd - oldStart + 1;
  var columnCount = currentEnd - currentStart + 1;
  var distances = new Array(rowCount);

  // "Addition" rows. Initialize null column.
  for (var i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }

  // Initialize null row
  for (var j = 0; j < columnCount; j++) {
    distances[0][j] = j;
  }for (var _i = 1; _i < rowCount; _i++) {
    for (var _j = 1; _j < columnCount; _j++) {
      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
        var north = distances[_i - 1][_j] + 1;
        var west = distances[_i][_j - 1] + 1;
        distances[_i][_j] = north < west ? north : west;
      }
    }
  }

  return distances;
}

// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
  var i = distances.length - 1;
  var j = distances[0].length - 1;
  var current = distances[i][j];
  var edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    var northWest = distances[i - 1][j - 1];
    var west = distances[i - 1][j];
    var north = distances[i][j - 1];

    var min = void 0;
    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}

/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  var prefixCount = 0;
  var suffixCount = 0;
  var splice = void 0;

  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;

  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd) {
      splice.removed.push(old[oldStart++]);
    }return [splice];
  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

  splice = undefined;
  var splices = [];
  var index = currentStart;
  var oldIndex = oldStart;
  for (var i = 0; i < ops.length; i++) {
    switch (ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice) splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice) splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice) splice = newSplice(index, [], 0);

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }
  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (var i = 0; i < searchLength; i++) {
    if (!equals(current[i], old[i])) return i;
  }return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  var index1 = current.length;
  var index2 = old.length;
  var count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2])) {
    count++;
  }return count;
}

function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0, previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}

exports.calculateSplices = calculateSplices;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n\n      /* Material Design color palette for Google products */\n\n      --google-red-100: #f4c7c3;\n      --google-red-300: #e67c73;\n      --google-red-500: #db4437;\n      --google-red-700: #c53929;\n\n      --google-blue-100: #c6dafc;\n      --google-blue-300: #7baaf7;\n      --google-blue-500: #4285f4;\n      --google-blue-700: #3367d6;\n\n      --google-green-100: #b7e1cd;\n      --google-green-300: #57bb8a;\n      --google-green-500: #0f9d58;\n      --google-green-700: #0b8043;\n\n      --google-yellow-100: #fce8b2;\n      --google-yellow-300: #f7cb4d;\n      --google-yellow-500: #f4b400;\n      --google-yellow-700: #f09300;\n\n      --google-grey-100: #f5f5f5;\n      --google-grey-300: #e0e0e0;\n      --google-grey-500: #9e9e9e;\n      --google-grey-700: #616161;\n\n      /* Material Design color palette from online spec document */\n\n      --paper-red-50: #ffebee;\n      --paper-red-100: #ffcdd2;\n      --paper-red-200: #ef9a9a;\n      --paper-red-300: #e57373;\n      --paper-red-400: #ef5350;\n      --paper-red-500: #f44336;\n      --paper-red-600: #e53935;\n      --paper-red-700: #d32f2f;\n      --paper-red-800: #c62828;\n      --paper-red-900: #b71c1c;\n      --paper-red-a100: #ff8a80;\n      --paper-red-a200: #ff5252;\n      --paper-red-a400: #ff1744;\n      --paper-red-a700: #d50000;\n\n      --paper-pink-50: #fce4ec;\n      --paper-pink-100: #f8bbd0;\n      --paper-pink-200: #f48fb1;\n      --paper-pink-300: #f06292;\n      --paper-pink-400: #ec407a;\n      --paper-pink-500: #e91e63;\n      --paper-pink-600: #d81b60;\n      --paper-pink-700: #c2185b;\n      --paper-pink-800: #ad1457;\n      --paper-pink-900: #880e4f;\n      --paper-pink-a100: #ff80ab;\n      --paper-pink-a200: #ff4081;\n      --paper-pink-a400: #f50057;\n      --paper-pink-a700: #c51162;\n\n      --paper-purple-50: #f3e5f5;\n      --paper-purple-100: #e1bee7;\n      --paper-purple-200: #ce93d8;\n      --paper-purple-300: #ba68c8;\n      --paper-purple-400: #ab47bc;\n      --paper-purple-500: #9c27b0;\n      --paper-purple-600: #8e24aa;\n      --paper-purple-700: #7b1fa2;\n      --paper-purple-800: #6a1b9a;\n      --paper-purple-900: #4a148c;\n      --paper-purple-a100: #ea80fc;\n      --paper-purple-a200: #e040fb;\n      --paper-purple-a400: #d500f9;\n      --paper-purple-a700: #aa00ff;\n\n      --paper-deep-purple-50: #ede7f6;\n      --paper-deep-purple-100: #d1c4e9;\n      --paper-deep-purple-200: #b39ddb;\n      --paper-deep-purple-300: #9575cd;\n      --paper-deep-purple-400: #7e57c2;\n      --paper-deep-purple-500: #673ab7;\n      --paper-deep-purple-600: #5e35b1;\n      --paper-deep-purple-700: #512da8;\n      --paper-deep-purple-800: #4527a0;\n      --paper-deep-purple-900: #311b92;\n      --paper-deep-purple-a100: #b388ff;\n      --paper-deep-purple-a200: #7c4dff;\n      --paper-deep-purple-a400: #651fff;\n      --paper-deep-purple-a700: #6200ea;\n\n      --paper-indigo-50: #e8eaf6;\n      --paper-indigo-100: #c5cae9;\n      --paper-indigo-200: #9fa8da;\n      --paper-indigo-300: #7986cb;\n      --paper-indigo-400: #5c6bc0;\n      --paper-indigo-500: #3f51b5;\n      --paper-indigo-600: #3949ab;\n      --paper-indigo-700: #303f9f;\n      --paper-indigo-800: #283593;\n      --paper-indigo-900: #1a237e;\n      --paper-indigo-a100: #8c9eff;\n      --paper-indigo-a200: #536dfe;\n      --paper-indigo-a400: #3d5afe;\n      --paper-indigo-a700: #304ffe;\n\n      --paper-blue-50: #e3f2fd;\n      --paper-blue-100: #bbdefb;\n      --paper-blue-200: #90caf9;\n      --paper-blue-300: #64b5f6;\n      --paper-blue-400: #42a5f5;\n      --paper-blue-500: #2196f3;\n      --paper-blue-600: #1e88e5;\n      --paper-blue-700: #1976d2;\n      --paper-blue-800: #1565c0;\n      --paper-blue-900: #0d47a1;\n      --paper-blue-a100: #82b1ff;\n      --paper-blue-a200: #448aff;\n      --paper-blue-a400: #2979ff;\n      --paper-blue-a700: #2962ff;\n\n      --paper-light-blue-50: #e1f5fe;\n      --paper-light-blue-100: #b3e5fc;\n      --paper-light-blue-200: #81d4fa;\n      --paper-light-blue-300: #4fc3f7;\n      --paper-light-blue-400: #29b6f6;\n      --paper-light-blue-500: #03a9f4;\n      --paper-light-blue-600: #039be5;\n      --paper-light-blue-700: #0288d1;\n      --paper-light-blue-800: #0277bd;\n      --paper-light-blue-900: #01579b;\n      --paper-light-blue-a100: #80d8ff;\n      --paper-light-blue-a200: #40c4ff;\n      --paper-light-blue-a400: #00b0ff;\n      --paper-light-blue-a700: #0091ea;\n\n      --paper-cyan-50: #e0f7fa;\n      --paper-cyan-100: #b2ebf2;\n      --paper-cyan-200: #80deea;\n      --paper-cyan-300: #4dd0e1;\n      --paper-cyan-400: #26c6da;\n      --paper-cyan-500: #00bcd4;\n      --paper-cyan-600: #00acc1;\n      --paper-cyan-700: #0097a7;\n      --paper-cyan-800: #00838f;\n      --paper-cyan-900: #006064;\n      --paper-cyan-a100: #84ffff;\n      --paper-cyan-a200: #18ffff;\n      --paper-cyan-a400: #00e5ff;\n      --paper-cyan-a700: #00b8d4;\n\n      --paper-teal-50: #e0f2f1;\n      --paper-teal-100: #b2dfdb;\n      --paper-teal-200: #80cbc4;\n      --paper-teal-300: #4db6ac;\n      --paper-teal-400: #26a69a;\n      --paper-teal-500: #009688;\n      --paper-teal-600: #00897b;\n      --paper-teal-700: #00796b;\n      --paper-teal-800: #00695c;\n      --paper-teal-900: #004d40;\n      --paper-teal-a100: #a7ffeb;\n      --paper-teal-a200: #64ffda;\n      --paper-teal-a400: #1de9b6;\n      --paper-teal-a700: #00bfa5;\n\n      --paper-green-50: #e8f5e9;\n      --paper-green-100: #c8e6c9;\n      --paper-green-200: #a5d6a7;\n      --paper-green-300: #81c784;\n      --paper-green-400: #66bb6a;\n      --paper-green-500: #4caf50;\n      --paper-green-600: #43a047;\n      --paper-green-700: #388e3c;\n      --paper-green-800: #2e7d32;\n      --paper-green-900: #1b5e20;\n      --paper-green-a100: #b9f6ca;\n      --paper-green-a200: #69f0ae;\n      --paper-green-a400: #00e676;\n      --paper-green-a700: #00c853;\n\n      --paper-light-green-50: #f1f8e9;\n      --paper-light-green-100: #dcedc8;\n      --paper-light-green-200: #c5e1a5;\n      --paper-light-green-300: #aed581;\n      --paper-light-green-400: #9ccc65;\n      --paper-light-green-500: #8bc34a;\n      --paper-light-green-600: #7cb342;\n      --paper-light-green-700: #689f38;\n      --paper-light-green-800: #558b2f;\n      --paper-light-green-900: #33691e;\n      --paper-light-green-a100: #ccff90;\n      --paper-light-green-a200: #b2ff59;\n      --paper-light-green-a400: #76ff03;\n      --paper-light-green-a700: #64dd17;\n\n      --paper-lime-50: #f9fbe7;\n      --paper-lime-100: #f0f4c3;\n      --paper-lime-200: #e6ee9c;\n      --paper-lime-300: #dce775;\n      --paper-lime-400: #d4e157;\n      --paper-lime-500: #cddc39;\n      --paper-lime-600: #c0ca33;\n      --paper-lime-700: #afb42b;\n      --paper-lime-800: #9e9d24;\n      --paper-lime-900: #827717;\n      --paper-lime-a100: #f4ff81;\n      --paper-lime-a200: #eeff41;\n      --paper-lime-a400: #c6ff00;\n      --paper-lime-a700: #aeea00;\n\n      --paper-yellow-50: #fffde7;\n      --paper-yellow-100: #fff9c4;\n      --paper-yellow-200: #fff59d;\n      --paper-yellow-300: #fff176;\n      --paper-yellow-400: #ffee58;\n      --paper-yellow-500: #ffeb3b;\n      --paper-yellow-600: #fdd835;\n      --paper-yellow-700: #fbc02d;\n      --paper-yellow-800: #f9a825;\n      --paper-yellow-900: #f57f17;\n      --paper-yellow-a100: #ffff8d;\n      --paper-yellow-a200: #ffff00;\n      --paper-yellow-a400: #ffea00;\n      --paper-yellow-a700: #ffd600;\n\n      --paper-amber-50: #fff8e1;\n      --paper-amber-100: #ffecb3;\n      --paper-amber-200: #ffe082;\n      --paper-amber-300: #ffd54f;\n      --paper-amber-400: #ffca28;\n      --paper-amber-500: #ffc107;\n      --paper-amber-600: #ffb300;\n      --paper-amber-700: #ffa000;\n      --paper-amber-800: #ff8f00;\n      --paper-amber-900: #ff6f00;\n      --paper-amber-a100: #ffe57f;\n      --paper-amber-a200: #ffd740;\n      --paper-amber-a400: #ffc400;\n      --paper-amber-a700: #ffab00;\n\n      --paper-orange-50: #fff3e0;\n      --paper-orange-100: #ffe0b2;\n      --paper-orange-200: #ffcc80;\n      --paper-orange-300: #ffb74d;\n      --paper-orange-400: #ffa726;\n      --paper-orange-500: #ff9800;\n      --paper-orange-600: #fb8c00;\n      --paper-orange-700: #f57c00;\n      --paper-orange-800: #ef6c00;\n      --paper-orange-900: #e65100;\n      --paper-orange-a100: #ffd180;\n      --paper-orange-a200: #ffab40;\n      --paper-orange-a400: #ff9100;\n      --paper-orange-a700: #ff6500;\n\n      --paper-deep-orange-50: #fbe9e7;\n      --paper-deep-orange-100: #ffccbc;\n      --paper-deep-orange-200: #ffab91;\n      --paper-deep-orange-300: #ff8a65;\n      --paper-deep-orange-400: #ff7043;\n      --paper-deep-orange-500: #ff5722;\n      --paper-deep-orange-600: #f4511e;\n      --paper-deep-orange-700: #e64a19;\n      --paper-deep-orange-800: #d84315;\n      --paper-deep-orange-900: #bf360c;\n      --paper-deep-orange-a100: #ff9e80;\n      --paper-deep-orange-a200: #ff6e40;\n      --paper-deep-orange-a400: #ff3d00;\n      --paper-deep-orange-a700: #dd2c00;\n\n      --paper-brown-50: #efebe9;\n      --paper-brown-100: #d7ccc8;\n      --paper-brown-200: #bcaaa4;\n      --paper-brown-300: #a1887f;\n      --paper-brown-400: #8d6e63;\n      --paper-brown-500: #795548;\n      --paper-brown-600: #6d4c41;\n      --paper-brown-700: #5d4037;\n      --paper-brown-800: #4e342e;\n      --paper-brown-900: #3e2723;\n\n      --paper-grey-50: #fafafa;\n      --paper-grey-100: #f5f5f5;\n      --paper-grey-200: #eeeeee;\n      --paper-grey-300: #e0e0e0;\n      --paper-grey-400: #bdbdbd;\n      --paper-grey-500: #9e9e9e;\n      --paper-grey-600: #757575;\n      --paper-grey-700: #616161;\n      --paper-grey-800: #424242;\n      --paper-grey-900: #212121;\n\n      --paper-blue-grey-50: #eceff1;\n      --paper-blue-grey-100: #cfd8dc;\n      --paper-blue-grey-200: #b0bec5;\n      --paper-blue-grey-300: #90a4ae;\n      --paper-blue-grey-400: #78909c;\n      --paper-blue-grey-500: #607d8b;\n      --paper-blue-grey-600: #546e7a;\n      --paper-blue-grey-700: #455a64;\n      --paper-blue-grey-800: #37474f;\n      --paper-blue-grey-900: #263238;\n\n      /* opacity for dark text on a light background */\n      --dark-divider-opacity: 0.12;\n      --dark-disabled-opacity: 0.38; /* or hint text or icon */\n      --dark-secondary-opacity: 0.54;\n      --dark-primary-opacity: 0.87;\n\n      /* opacity for light text on a dark background */\n      --light-divider-opacity: 0.12;\n      --light-disabled-opacity: 0.3; /* or hint text or icon */\n      --light-secondary-opacity: 0.7;\n      --light-primary-opacity: 1.0;\n\n    }\n\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronButtonState = exports.IronButtonStateImpl = undefined;

__webpack_require__(6);

var _ironA11yKeysBehavior = __webpack_require__(71);

__webpack_require__(72);

var _polymerDom = __webpack_require__(17);

var IronButtonStateImpl = exports.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = (0, _polymerDom.dom)(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = (0, _polymerDom.dom)(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

var IronButtonState = exports.IronButtonState = [_ironA11yKeysBehavior.IronA11yKeysBehavior, IronButtonStateImpl];

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronA11yKeysBehavior = undefined;

__webpack_require__(6);

/**
 * Chrome uses an older version of DOM Level 3 Keyboard Events
 *
 * Most keys are labeled as text, but some are Unicode codepoints.
 * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
 */
var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};

/**
 * Special table for KeyboardEvent.keyCode.
 * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
 * than that.
 *
 * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
 */
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};

/**
 * MODIFIER_KEYS maps the short name for modifier keys used in a key
 * combo string to the property name that references those same keys
 * in a KeyboardEvent instance.
 */
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};

/**
 * KeyboardEvent.key is mostly represented by printable character made by
 * the keyboard, with unprintable keys labeled nicely.
 *
 * However, on OS X, Alt+char can make a Unicode character that follows an
 * Apple-specific mapping. In this case, we fall back to .keyCode.
 */
var KEY_CHAR = /[a-z0-9*]/;

/**
 * Matches a keyIdentifier string.
 */
var IDENT_CHAR = /U\+/;

/**
 * Matches arrow keys in Gecko 27.0+
 */
var ARROW_KEY = /^arrow/;

/**
 * Matches space keys everywhere (notably including IE10's exceptional name
 * `spacebar`).
 */
var SPACE_KEY = /^space(bar)?/;

/**
 * Matches ESC key.
 *
 * Value from: http://w3c.github.io/uievents-key/#key-Escape
 */
var ESC_KEY = /^escape$/;

/**
 * Transforms the key.
 * @param {string} key The KeyBoardEvent.key
 * @param {Boolean} [noSpecialChars] Limits the transformation to
 * alpha-numeric characters.
 */
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      // numpad '*' can map to Multiply on IE/Windows
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}

function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}

function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      // ascii a-z
      // lowercase is 32 offset from uppercase
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      // function keys f1-f12
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      // top 0-9 keys
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      // num pad 0-9
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}

/**
  * Calculates the normalized key for a KeyboardEvent.
  * @param {KeyboardEvent} keyEvent
  * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
  * transformation to alpha-numeric chars. This is useful with key
  * combinations like shift + 2, which on FF for MacOS produces
  * keyEvent.key = @
  * To get 2 returned, set noSpecialChars = true
  * To get @ returned, set noSpecialChars = false
 */
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  // Fall back from .key, to .detail.key for artifical keyboard events,
  // and then to deprecated .keyIdentifier and .keyCode.
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
}

function keyComboMatchesEvent(keyCombo, event) {
  // For combos with modifiers we support only alpha-numeric keys
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
}

function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {
      combo: keyComboString,
      key: keyComboString,
      event: 'keydown'
    };
  }
  return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
    var eventParts = keyComboPart.split(':');
    var keyName = eventParts[0];
    var event = eventParts[1];

    if (keyName in MODIFIER_KEYS) {
      parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
      parsedKeyCombo.hasModifiers = true;
    } else {
      parsedKeyCombo.key = keyName;
      parsedKeyCombo.event = event || 'keydown';
    }

    return parsedKeyCombo;
  }, {
    combo: keyComboString.split(':').shift()
  });
}

function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function (keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}

var IronA11yKeysBehavior = exports.IronA11yKeysBehavior = {
  properties: {
    /**
     * The EventTarget that will be firing relevant KeyboardEvents. Set it to
     * `null` to disable the listeners.
     * @type {?EventTarget}
     */
    keyEventTarget: {
      type: Object,
      value: function value() {
        return this;
      }
    },

    /**
     * If true, this property will cause the implementing element to
     * automatically stop propagation on any handled KeyboardEvents.
     */
    stopKeyboardEventPropagation: {
      type: Boolean,
      value: false
    },

    _boundKeyHandlers: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    // We use this due to a limitation in IE10 where instances will have
    // own properties of everything on the "prototype".
    _imperativeKeyBindings: {
      type: Object,
      value: function value() {
        return {};
      }
    }
  },

  observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

  /**
   * To be used to express what combination of keys  will trigger the relative
   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
   * @type {!Object}
   */
  keyBindings: {},

  registered: function registered() {
    this._prepKeyBindings();
  },

  attached: function attached() {
    this._listenKeyEventListeners();
  },

  detached: function detached() {
    this._unlistenKeyEventListeners();
  },

  /**
   * Can be used to imperatively add a key binding to the implementing
   * element. This is the imperative equivalent of declaring a keybinding
   * in the `keyBindings` prototype property.
   *
   * @param {string} eventString
   * @param {string} handlerName
   */
  addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * When called, will remove all imperatively-added key bindings.
   */
  removeOwnKeyBindings: function removeOwnKeyBindings() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * Returns true if a keyboard event matches `eventString`.
   *
   * @param {KeyboardEvent} event
   * @param {string} eventString
   * @return {boolean}
   */
  keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },

  _collectKeyBindings: function _collectKeyBindings() {
    var keyBindings = this.behaviors.map(function (behavior) {
      return behavior.keyBindings;
    });

    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }

    return keyBindings;
  },

  _prepKeyBindings: function _prepKeyBindings() {
    this._keyBindings = {};

    this._collectKeyBindings().forEach(function (keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);

    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
    }

    // Give precedence to combos with modifiers to be checked first.
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function (kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return b1 === b2 ? 0 : b1 ? -1 : 1;
      });
    }
  },

  _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
    parseEventString(eventString).forEach(function (keyCombo) {
      this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
    }, this);
  },

  _resetKeyEventListeners: function _resetKeyEventListeners() {
    this._unlistenKeyEventListeners();

    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },

  _listenKeyEventListeners: function _listenKeyEventListeners() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function (eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },

  _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;

    while (this._boundKeyHandlers.length) {
      // My kingdom for block-scope binding and destructuring assignment..
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];

      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },

  _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }

    // if event has been already prevented, don't do anything
    if (event.defaultPrevented) {
      return;
    }

    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        // exit the loop if eventDefault was prevented
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },

  _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event = new CustomEvent(keyCombo.event, {
      detail: detail,
      cancelable: true
    });
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronControlState = undefined;

__webpack_require__(6);

var _polymerElement = __webpack_require__(11);

var _polymerDom = __webpack_require__(17);

var IronControlState = exports.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !_polymerElement.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (_polymerElement.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */(0, _polymerDom.dom)(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EPSG900913 = exports.EPSG3857 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(74);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = exports.EPSG3857 = Util.extend({}, _CRS.Earth, {
  code: 'EPSG:3857',
  projection: _Projection.SphericalMercator,

  transformation: function () {
    var scale = 0.5 / (Math.PI * _Projection.SphericalMercator.R);
    return (0, _Transformation.toTransformation)(scale, 0.5, -scale, 0.5);
  }()
});

var EPSG900913 = exports.EPSG900913 = Util.extend({}, EPSG3857, {
  code: 'EPSG:900913'
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SphericalMercator = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var SphericalMercator = exports.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function project(latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new _Point.Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function unproject(point) {
		var d = 180 / Math.PI;

		return new _LatLng.LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
	},

	bounds: function () {
		var d = 6378137 * Math.PI;
		return new _Bounds.Bounds([-d, -d], [d, d]);
	}()
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.svgCreate = svgCreate;
exports.pointsToPath = pointsToPath;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	    i,
	    j,
	    len,
	    len2,
	    points,
	    p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? Browser.svg ? 'z' : 'x' : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports._pointersCount = undefined;
exports.addPointerListener = addPointerListener;
exports.removePointerListener = removePointerListener;

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
    POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove',
    POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup',
    POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
    TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'],
    _pointers = {},
    _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = exports._pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);
	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);
	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);
	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);
	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = Util.bind(function (e) {
		if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				DomEvent.preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	exports._pointersCount = _pointersCount += 1;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	exports._pointersCount = _pointersCount -= 1;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function onMove(e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
			return;
		}

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function onUp(e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.PosAnimation = undefined;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Events = __webpack_require__(19);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = exports.PosAnimation = _Events.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function run(el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function stop() {
		if (!this._inProgress) {
			return;
		}

		this._step(true);
		this._complete();
	},

	_animate: function _animate() {
		// animation loop
		this._animId = Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function _step(round) {
		var elapsed = +new Date() - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function _runFrame(progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function _complete() {
		Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function _easeOut(t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.IconDefault = undefined;

var _Icon = __webpack_require__(30);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = exports.IconDefault = _Icon.Icon.extend({

	options: {
		iconUrl: 'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl: 'marker-shadow.png',
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize: [41, 41]
	},

	_getIconUrl: function _getIconUrl(name) {
		if (!IconDefault.imagePath) {
			// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the absolute location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right absolute path.
		return (this.options.imagePath || IconDefault.imagePath) + _Icon.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function _detectIconPath() {
		var el = DomUtil.create('div', 'leaflet-default-icon-path', document.body);
		var path = DomUtil.getStyle(el, 'background-image') || DomUtil.getStyle(el, 'backgroundImage'); // IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '');
		}

		return path;
	}
});

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = exports.Map = undefined;

var _Map = __webpack_require__(7);

Object.defineProperty(exports, 'Map', {
  enumerable: true,
  get: function get() {
    return _Map.Map;
  }
});
Object.defineProperty(exports, 'map', {
  enumerable: true,
  get: function get() {
    return _Map.createMap;
  }
});

var _Map2 = __webpack_require__(121);

var _Map3 = __webpack_require__(122);

var _Map4 = __webpack_require__(123);

var _Map5 = __webpack_require__(124);

var _Map6 = __webpack_require__(125);

var _Map7 = __webpack_require__(126);

var _Map8 = __webpack_require__(127);

_Map.Map.BoxZoom = _Map2.BoxZoom;

_Map.Map.DoubleClickZoom = _Map3.DoubleClickZoom;

_Map.Map.Drag = _Map4.Drag;

_Map.Map.Keyboard = _Map5.Keyboard;

_Map.Map.ScrollWheelZoom = _Map6.ScrollWheelZoom;

_Map.Map.Tap = _Map7.Tap;

_Map.Map.TouchZoom = _Map8.TouchZoom;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.attribution = exports.Attribution = undefined;

var _Control = __webpack_require__(22);

var _Map = __webpack_require__(7);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = exports.Attribution = _Control.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function onAdd(map) {
		map.attributionControl = this;
		this._container = DomUtil.create('div', 'leaflet-control-attribution');
		DomEvent.disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function setPrefix(prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function addAttribution(text) {
		if (!text) {
			return this;
		}

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function removeAttribution(text) {
		if (!text) {
			return this;
		}

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function _update() {
		if (!this._map) {
			return;
		}

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
_Map.Map.mergeOptions({
	attributionControl: true
});

_Map.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = exports.attribution = function attribution(options) {
	return new Attribution(options);
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.control = exports.Control = undefined;

var _Control = __webpack_require__(22);

var _Control2 = __webpack_require__(128);

var _Control3 = __webpack_require__(129);

var _Control4 = __webpack_require__(130);

var _Control5 = __webpack_require__(80);

_Control.Control.Layers = _Control2.Layers;
_Control.Control.Zoom = _Control3.Zoom;
_Control.Control.Scale = _Control4.Scale;
_Control.Control.Attribution = _Control5.Attribution;

_Control.control.layers = _Control2.layers;
_Control.control.zoom = _Control3.zoom;
_Control.control.scale = _Control4.scale;
_Control.control.attribution = _Control5.attribution;

exports.Control = _Control.Control;
exports.control = _Control.control;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tooltip = exports.Tooltip = exports.popup = exports.Popup = exports.DivOverlay = exports.videoOverlay = exports.VideoOverlay = exports.imageOverlay = exports.ImageOverlay = exports.geoJson = exports.geoJSON = exports.GeoJSON = exports.featureGroup = exports.FeatureGroup = exports.layerGroup = exports.LayerGroup = exports.Layer = undefined;

var _Layer = __webpack_require__(12);

Object.defineProperty(exports, 'Layer', {
  enumerable: true,
  get: function get() {
    return _Layer.Layer;
  }
});

var _LayerGroup = __webpack_require__(46);

Object.defineProperty(exports, 'LayerGroup', {
  enumerable: true,
  get: function get() {
    return _LayerGroup.LayerGroup;
  }
});
Object.defineProperty(exports, 'layerGroup', {
  enumerable: true,
  get: function get() {
    return _LayerGroup.layerGroup;
  }
});

var _FeatureGroup = __webpack_require__(18);

Object.defineProperty(exports, 'FeatureGroup', {
  enumerable: true,
  get: function get() {
    return _FeatureGroup.FeatureGroup;
  }
});
Object.defineProperty(exports, 'featureGroup', {
  enumerable: true,
  get: function get() {
    return _FeatureGroup.featureGroup;
  }
});

var _ImageOverlay = __webpack_require__(50);

Object.defineProperty(exports, 'ImageOverlay', {
  enumerable: true,
  get: function get() {
    return _ImageOverlay.ImageOverlay;
  }
});
Object.defineProperty(exports, 'imageOverlay', {
  enumerable: true,
  get: function get() {
    return _ImageOverlay.imageOverlay;
  }
});

var _VideoOverlay = __webpack_require__(131);

Object.defineProperty(exports, 'VideoOverlay', {
  enumerable: true,
  get: function get() {
    return _VideoOverlay.VideoOverlay;
  }
});
Object.defineProperty(exports, 'videoOverlay', {
  enumerable: true,
  get: function get() {
    return _VideoOverlay.videoOverlay;
  }
});

var _DivOverlay = __webpack_require__(51);

Object.defineProperty(exports, 'DivOverlay', {
  enumerable: true,
  get: function get() {
    return _DivOverlay.DivOverlay;
  }
});

var _Popup = __webpack_require__(132);

Object.defineProperty(exports, 'Popup', {
  enumerable: true,
  get: function get() {
    return _Popup.Popup;
  }
});
Object.defineProperty(exports, 'popup', {
  enumerable: true,
  get: function get() {
    return _Popup.popup;
  }
});

var _Tooltip = __webpack_require__(133);

Object.defineProperty(exports, 'Tooltip', {
  enumerable: true,
  get: function get() {
    return _Tooltip.Tooltip;
  }
});
Object.defineProperty(exports, 'tooltip', {
  enumerable: true,
  get: function get() {
    return _Tooltip.tooltip;
  }
});

var _index = __webpack_require__(134);

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

var _index2 = __webpack_require__(136);

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index2[key];
    }
  });
});

var _index3 = __webpack_require__(137);

Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index3[key];
    }
  });
});

var _GeoJSON = __webpack_require__(88);

_GeoJSON.GeoJSON.geometryToLayer = _GeoJSON.geometryToLayer;
_GeoJSON.GeoJSON.coordsToLatLng = _GeoJSON.coordsToLatLng;
_GeoJSON.GeoJSON.coordsToLatLngs = _GeoJSON.coordsToLatLngs;
_GeoJSON.GeoJSON.latLngToCoords = _GeoJSON.latLngToCoords;
_GeoJSON.GeoJSON.latLngsToCoords = _GeoJSON.latLngsToCoords;
_GeoJSON.GeoJSON.getFeature = _GeoJSON.getFeature;
_GeoJSON.GeoJSON.asFeature = _GeoJSON.asFeature;
exports.GeoJSON = _GeoJSON.GeoJSON;
exports.geoJSON = _GeoJSON.geoJSON;
exports.geoJson = _GeoJSON.geoJson;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.GridLayer = undefined;
exports.gridLayer = gridLayer;

var _Layer = __webpack_require__(12);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(8);

var _LatLngBounds = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */

var GridLayer = exports.GridLayer = _Layer.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
	},

	onAdd: function onAdd() {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function beforeAdd(map) {
		map._addZoomLimit(this);
	},

	onRemove: function onRemove(map) {
		this._removeAllTiles();
		DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function getContainer() {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function setZIndex(zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function isLoading() {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function redraw() {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function getEvents() {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function createTile() {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function getTileSize() {
		var s = this.options.tileSize;
		return s instanceof _Point.Point ? s : new _Point.Point(s, s);
	},

	_updateZIndex: function _updateZIndex() {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function _setAutoZIndex(compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function _updateOpacity() {
		if (!this._map) {
			return;
		}

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (Browser.ielt9) {
			return;
		}

		DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) {
				continue;
			}

			var fade = Math.min(1, (now - tile.loaded) / 200);

			DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) {
			this._pruneTiles();
		}

		if (nextFrame) {
			Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: Util.falseFn,

	_initContainer: function _initContainer() {
		if (this._container) {
			return;
		}

		this._container = DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function _updateLevels() {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) {
			return undefined;
		}

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			Util.falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: Util.falseFn,

	_onRemoveLevel: Util.falseFn,

	_onCreateLevel: Util.falseFn,

	_pruneTiles: function _pruneTiles() {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function _removeTilesAtZoom(zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function _removeAllTiles() {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function _invalidateAll() {
		for (var z in this._levels) {
			DomUtil.remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function _retainParent(x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new _Point.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;
		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function _retainChildren(x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new _Point.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;
				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function _resetView(e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function _animateZoom(e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function _clampZoom(zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function _setView(center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function _setZoomTransforms(center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function _setZoomTransform(level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (Browser.any3d) {
			DomUtil.setTransform(level.el, translate, scale);
		} else {
			DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function _resetGrid() {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
	},

	_onMoveEnd: function _onMoveEnd() {
		if (!this._map || this._map._animatingZoom) {
			return;
		}

		this._update();
	},

	_getTiledPixelBounds: function _getTiledPixelBounds(center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new _Bounds.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function _update(center) {
		var map = this._map;
		if (!map) {
			return;
		}
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) {
			center = map.getCenter();
		}
		if (this._tileZoom === undefined) {
			return;
		} // if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new _Bounds.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
			throw new Error('Attempted to load an infinite number of tiles');
		}

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new _Point.Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) {
			this._setView(center, zoom);return;
		}

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new _Point.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) {
					continue;
				}

				if (!this._tiles[this._tileCoordsToKey(coords)]) {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function _isValidTile(coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
				return false;
			}
		}

		if (!this.options.bounds) {
			return true;
		}

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return (0, _LatLngBounds.toLatLngBounds)(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function _keyToBounds(key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function _tileCoordsToBounds(coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),
		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),
		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z),
		    bounds = new _LatLngBounds.LatLngBounds(nw, se);

		if (!this.options.noWrap) {
			map.wrapLatLngBounds(bounds);
		}

		return bounds;
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function _tileCoordsToKey(coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function _keyToTileCoords(key) {
		var k = key.split(':'),
		    coords = new _Point.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function _removeTile(key) {
		var tile = this._tiles[key];
		if (!tile) {
			return;
		}

		DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function _initTile(tile) {
		DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = Util.falseFn;
		tile.onmousemove = Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (Browser.ielt9 && this.options.opacity < 1) {
			DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (Browser.android && !Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function _addTile(coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), Util.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			Util.requestAnimFrame(Util.bind(this._tileReady, this, coords, null, tile));
		}

		DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function _tileReady(coords, err, tile) {
		if (!this._map) {
			return;
		}

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) {
			return;
		}

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			DomUtil.setOpacity(tile.el, 0);
			Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (Browser.ielt9 || !this._map._fadeAnimated) {
				Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(Util.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function _getTilePos(coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function _wrapCoords(coords) {
		var newCoords = new _Point.Point(this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {
		var tileSize = this.getTileSize();
		return new _Bounds.Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function _noTilesToLoad() {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) {
				return false;
			}
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Canvas = undefined;
exports.canvas = canvas;

var _Renderer = __webpack_require__(31);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = exports.Canvas = _Renderer.Renderer.extend({
	getEvents: function getEvents() {
		var events = _Renderer.Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function _onViewPreReset() {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function onAdd() {
		_Renderer.Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function _initContainer() {
		var container = this._container = document.createElement('canvas');

		DomEvent.on(container, 'mousemove', Util.throttle(this._onMouseMove, 32, this), this);
		DomEvent.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		DomEvent.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function _destroyContainer() {
		delete this._ctx;
		DomUtil.remove(this._container);
		DomEvent.off(this._container);
		delete this._container;
	},

	_updatePaths: function _updatePaths() {
		if (this._postponeUpdatePaths) {
			return;
		}

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function _update() {
		if (this._map._animatingZoom && this._bounds) {
			return;
		}

		this._drawnLayers = {};

		_Renderer.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = Browser.retina ? 2 : 1;

		DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function _reset() {
		_Renderer.Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function _initPath(layer) {
		this._updateDashArray(layer);
		this._layers[Util.stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) {
			this._drawLast.next = order;
		}
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function _addPath(layer) {
		this._requestRedraw(layer);
	},

	_removePath: function _removePath(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[L.stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function _updatePath(layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function _updateStyle(layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function _updateDashArray(layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function _requestRedraw(layer) {
		if (!this._map) {
			return;
		}

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || Util.requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function _extendRedrawBounds(layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new _Bounds.Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function _redraw() {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function _clear() {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function _draw() {
		var layer,
		    bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore(); // Restore state before clipping.
	},

	_updatePoly: function _updatePoly(layer, closed) {
		if (!this._drawing) {
			return;
		}

		var i,
		    j,
		    len2,
		    p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) {
			return;
		}

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function _updateCircle(layer) {

		if (!this._drawing || layer._empty()) {
			return;
		}

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function _fillStroke(ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function _onClick(e) {
		var point = this._map.mouseEventToLayerPoint(e),
		    layer,
		    clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer) {
			DomEvent.fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function _onMouseMove(e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
			return;
		}

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},

	_handleMouseOut: function _handleMouseOut(e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function _handleMouseHover(e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function _fireEvent(layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function _bringToFront(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// signle entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function _bringToBack(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// signle entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas(options) {
	return Browser.canvas ? new Canvas(options) : null;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Circle = undefined;
exports.circle = circle;

var _CircleMarker = __webpack_require__(32);

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _CRS = __webpack_require__(16);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = exports.Circle = _CircleMarker.CircleMarker.extend({

	initialize: function initialize(latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = Util.extend({}, legacyOptions, { radius: options });
		}
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);

		if (isNaN(this.options.radius)) {
			throw new Error('Circle radius cannot be NaN');
		}

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function setRadius(radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function getRadius() {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function getBounds() {
		var half = [this._radius, this._radiusY || this._radius];

		return new _LatLngBounds.LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: _Path.Path.prototype.setStyle,

	_project: function _project() {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === _CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = this._mRadius / _CRS.Earth.R / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);
		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.clipPolygon = clipPolygon;

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i,
	    j,
	    k,
	    a,
	    b,
	    len,
	    edge,
	    p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = LineUtil._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = LineUtil._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = LineUtil._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

				// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = LineUtil._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = LineUtil._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SVG = exports.create = exports.pointsToPath = undefined;
exports.svg = svg;

var _Renderer = __webpack_require__(31);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var _SVG = __webpack_require__(75);

var _SVG2 = __webpack_require__(139);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.pointsToPath = _SVG.pointsToPath;
var create = exports.create = Browser.vml ? _SVG2.vmlCreate : _SVG.svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = exports.SVG = _Renderer.Renderer.extend({

	getEvents: function getEvents() {
		var events = _Renderer.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function _initContainer() {
		this._container = create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function _destroyContainer() {
		DomUtil.remove(this._container);
		DomEvent.off(this._container);
		delete this._container;
		delete this._rootGroup;
	},

	_onZoomStart: function _onZoomStart() {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function _update() {
		if (this._map._animatingZoom && this._bounds) {
			return;
		}

		_Renderer.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function _initPath(layer) {
		var path = layer._path = create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[(0, _Util.stamp)(layer)] = layer;
	},

	_addPath: function _addPath(layer) {
		if (!this._rootGroup) {
			this._initContainer();
		}
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function _removePath(layer) {
		DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[(0, _Util.stamp)(layer)];
	},

	_updatePath: function _updatePath(layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function _updateStyle(layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) {
			return;
		}

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function _updatePoly(layer, closed) {
		this._setPath(layer, (0, _SVG.pointsToPath)(layer._parts, closed));
	},

	_updateCircle: function _updateCircle(layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function _setPath(layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function _bringToFront(layer) {
		DomUtil.toFront(layer._path);
	},

	_bringToBack: function _bringToBack(layer) {
		DomUtil.toBack(layer._path);
	}
});

if (Browser.vml) {
	SVG.include(_SVG2.vmlMixin);
}

// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg(options) {
	return Browser.svg || Browser.vml ? new SVG(options) : null;
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.geoJson = exports.GeoJSON = undefined;
exports.geometryToLayer = geometryToLayer;
exports.coordsToLatLng = coordsToLatLng;
exports.coordsToLatLngs = coordsToLatLngs;
exports.latLngToCoords = latLngToCoords;
exports.latLngsToCoords = latLngsToCoords;
exports.getFeature = getFeature;
exports.asFeature = asFeature;
exports.geoJSON = geoJSON;

var _LayerGroup = __webpack_require__(46);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Marker = __webpack_require__(48);

var _Circle = __webpack_require__(85);

var _CircleMarker = __webpack_require__(32);

var _Polyline = __webpack_require__(56);

var _Polygon = __webpack_require__(57);

var _LatLng = __webpack_require__(9);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = exports.GeoJSON = _FeatureGroup.FeatureGroup.extend({

	/* @section
  * @aka GeoJSON options
  *
  * @option pointToLayer: Function = *
  * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  * The default is to spawn a default `Marker`:
  * ```js
  * function(geoJsonPoint, latlng) {
  * 	return L.marker(latlng);
  * }
  * ```
  *
  * @option style: Function = *
  * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  * called internally when data is added.
  * The default value is to not override any defaults:
  * ```js
  * function (geoJsonFeature) {
  * 	return {}
  * }
  * ```
  *
  * @option onEachFeature: Function = *
  * A `Function` that will be called once for each created `Feature`, after it has
  * been created and styled. Useful for attaching events and popups to features.
  * The default is to do nothing with the newly created layers:
  * ```js
  * function (feature, layer) {}
  * ```
  *
  * @option filter: Function = *
  * A `Function` that will be used to decide whether to include a feature or not.
  * The default is to include all features:
  * ```js
  * function (geoJsonFeature) {
  * 	return true;
  * }
  * ```
  * Note: dynamically changing the `filter` option will have effect only on newly
  * added data. It will _not_ re-evaluate already included features.
  *
  * @option coordsToLatLng: Function = *
  * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  * The default is the `coordsToLatLng` static method.
  */

	initialize: function initialize(geojson, options) {
		Util.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function addData(geojson) {
		var features = Util.isArray(geojson) ? geojson : geojson.features,
		    i,
		    len,
		    feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) {
			return this;
		}

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function resetStyle(layer) {
		// reset any custom styles
		layer.options = Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function setStyle(style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function _setLayerStyle(layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
	    coords = geometry ? geometry.coordinates : null,
	    layers = [],
	    pointToLayer = options && options.pointToLayer,
	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
	    latlng,
	    latlngs,
	    i,
	    len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
		case 'Point':
			latlng = _coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new _Marker.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = _coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new _Marker.Marker(latlng));
			}
			return new _FeatureGroup.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
			return new _Polyline.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
			return new _Polygon.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new _FeatureGroup.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
	}
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new _LatLng.LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ? [Util.formatNum(latlng.lng, precision), Util.formatNum(latlng.lat, precision), Util.formatNum(latlng.alt, precision)] : [Util.formatNum(latlng.lng, precision), Util.formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ? Util.extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function toGeoJSON(precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
_Marker.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
_Circle.Circle.include(PointToGeoJSON);
_CircleMarker.CircleMarker.include(PointToGeoJSON);

// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
_Polyline.Polyline.include({
	toGeoJSON: function toGeoJSON(precision) {
		var multi = !LineUtil.isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
_Polygon.Polygon.include({
	toGeoJSON: function toGeoJSON(precision) {
		var holes = !LineUtil.isFlat(this._latlngs),
		    multi = holes && !LineUtil.isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});

// @namespace LayerGroup
_LayerGroup.LayerGroup.include({
	toMultiPoint: function toMultiPoint(precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function toGeoJSON(precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = exports.geoJson = geoJSON;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Mercator = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(8);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

var Mercator = exports.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new _Bounds.Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function project(latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new _Point.Point(latlng.lng * d * r, y);
	},

	unproject: function unproject(point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new _LatLng.LatLng(phi * d, point.x * d / r);
	}
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GGMapViewer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

__webpack_require__(93);

var _FeatureGroup = __webpack_require__(18);

var _Marker = __webpack_require__(48);

var _Icon = __webpack_require__(30);

var _markerIcon = __webpack_require__(118);

var _markerIcon2 = _interopRequireDefault(_markerIcon);

var _markerShadow = __webpack_require__(119);

var _markerShadow2 = _interopRequireDefault(_markerShadow);

var _leafletMap = __webpack_require__(120);

var _leafletWmsGroup = __webpack_require__(141);

var _leafletTileLayer = __webpack_require__(144);

var _leafletGeojsonPoints = __webpack_require__(145);

var _appTemplate = __webpack_require__(164);

var _appTemplate2 = _interopRequireDefault(_appTemplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var yaml = __webpack_require__(165);

var GGMapViewer = exports.GGMapViewer = function (_PolymerElement) {
  _inherits(GGMapViewer, _PolymerElement);

  _createClass(GGMapViewer, null, [{
    key: 'template',
    get: function get() {
      return _appTemplate2.default;
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        config: {
          type: String
        },
        mapTitle: {
          type: String,
          value: 'City of Garden Grove Public Maps'
        },
        flat: {
          type: Boolean,
          value: false
        },
        map: {
          type: Object
        },
        baseSource: {
          type: String
        },
        baseFormat: {
          type: String
        },
        selectedOverlay: {
          type: Object,
          observer: '_overlayChanged'
        },
        wmsGroups: {
          type: Array,
          value: []
        },
        geojsonLayers: {
          type: Array,
          value: []
        },
        baseMaps: {
          type: Array
        },
        overlayMaps: {
          type: Array
        },
        searchMarkers: {
          type: Array,
          value: [],
          observer: '_markMap'
        }
      };
    }
  }]);

  function GGMapViewer() {
    _classCallCheck(this, GGMapViewer);

    var _this = _possibleConstructorReturn(this, (GGMapViewer.__proto__ || Object.getPrototypeOf(GGMapViewer)).call(this));

    _this._markersGroup = new _FeatureGroup.FeatureGroup([]);
    return _this;
  }

  _createClass(GGMapViewer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(GGMapViewer.prototype.__proto__ || Object.getPrototypeOf(GGMapViewer.prototype), 'connectedCallback', this).call(this);

      fetch(this.config).then(function (r) {
        return r.text();
      }).then(this.initializeMap.bind(this));

      this.initializeSearch();
    }
  }, {
    key: 'initializeMap',
    value: function initializeMap(response) {
      var rjson = yaml.safeLoad(response);

      this.baseMaps = rjson.baseMaps;
      this.overlayMaps = rjson.overlayMaps;

      if (this.flat && this.overlayMaps.length > 1) {
        console.error('You cannot enable flat mode with multiple overlays at this time.');
      }

      if (this.overlayMaps.length === 1) {
        this.flat = true;
      }

      if (rjson.mapTitle) {
        this.mapTitle = rjson.mapTitle;
      }

      // iterate through groups of layers
      for (var i = 0; i < this.overlayMaps.length; i++) {
        var l = this.overlayMaps[i].layers;
        this.overlayMaps[i].flattenedLayers = [];

        // iterate through layer interaction types (optionals, exclusives, always on.. in this order)
        var _arr = ['optionals', 'exclusives', 'alwaysOn'];
        for (var _i = 0; _i < _arr.length; _i++) {
          var t = _arr[_i];
          this.overlayMaps[i].flattenedLayers = this.overlayMaps[i].flattenedLayers.concat(l[t]);

          // iterate through all layers
          for (var j = 0; j < l[t].length; j++) {
            l[t][j].interaction = t;

            // always on layers should always be visible
            if (t === 'alwaysOn') {
              l[t][j].visible = true;
            } else {
              if (location.hash !== '') {
                if (l[t][j].machineName === location.hash.substring(1)) {
                  l[t][j].visible = true;
                } else {
                  l[t][j].visible = false;
                }
              }
            }

            // For convenience, allow source to be globally defined, but propagate it here.
            if ((l[t][j].type === 'wms' || l[t][j].type === undefined) && l[t][j].source === undefined) {
              l[t][j].type = 'wms';
              l[t][j].source = rjson.wmsDefaultSource;
            }
          }
        }
      }

      // FIXME: hacky hardcoded initial view
      this._selectedBasemap = 0;
      this.baseSource = this.baseMaps[0].source;
      this.baseFormat = this.baseMaps[0].format;
      this.baseLayers = this.baseMaps[0].layers;

      this.overlaySelect();
    }
  }, {
    key: 'initializeSearch',
    value: function initializeSearch() {
      var _this2 = this;

      this._markersGroup.addTo(this.map);

      jQuery('#search', this.shadowRoot).autocomplete({
        preventBadQueries: false,
        deferRequestBy: 200,
        minChars: 3,
        serviceUrl: '//www.ci.garden-grove.ca.us/maps/api/addresses/search',
        paramName: 'q',
        // params: { limit: 10 },
        transformResult: function transformResult(response) {
          var addresses = JSON.parse(response).addresses;
          return {
            suggestions: addresses.map(function (d) {
              return { value: d.address, data: d };
            })
          };
        },
        onSearchStart: function onSearchStart() {
          return _this2.set('searchMakers', []);
        },
        onSearchComplete: function onSearchComplete(q, s) {
          return _this2.set('searchMarkers', s.map(function (obj) {
            return { coords: [obj.data.latitude, obj.data.longitude], address: obj.data.address };
          }));
        },
        onSelect: function onSelect(obj) {
          return _this2.set('searchMarkers', [{ coords: [obj.data.latitude, obj.data.longitude], address: obj.data.address }]);
        }
      });
    }
  }, {
    key: 'toggleLayer',
    value: function toggleLayer(event) {
      // First save the current state
      var currVisible = event.model.layer.visible;

      if (event.model.layer.interaction === 'exclusives') {
        // Turn all exclusive layers off
        for (var i = 0; i < this.selectedOverlay.layers.exclusives.length; i++) {
          this.set('selectedOverlay.layers.exclusives.' + i + '.visible', false);
        }
      }

      // Compute toggle on original state
      event.model.set('layer.visible', !currVisible);

      this._parseLayers(this.selectedOverlay);
    }
  }, {
    key: 'overlaySelect',
    value: function overlaySelect(event) {
      this.selectedOverlay = event ? event.model.item : this.overlayMaps[0];

      if (this.selectedOverlay.resetViewOnSelect) {
        this.map.flyTo(this.selectedOverlay.initialCenter, this.selectedOverlay.initialZoom);
      }
    }

    // FIXE: Achtung! Uber hacky!!!

  }, {
    key: 'switchBasemap',
    value: function switchBasemap(event) {
      var idx = ++this._selectedBasemap % 2;
      this.baseSource = this.baseMaps[idx].source;
      this.baseFormat = this.baseMaps[idx].format;
      this.baseLayers = this.baseMaps[idx].layers;

      if (idx === 1) {
        event.target.style.backgroundImage = "url(./vector.png)";
      } else {
        event.target.style.backgroundImage = "url(./aerial.png)";
      }
    }
  }, {
    key: 'toggleLayersMenu',
    value: function toggleLayersMenu() {
      var layersMenu = this.shadowRoot.querySelector('main#layers-menu');
      layersMenu.classList.toggle('show');
    }
  }, {
    key: '_parseLayers',
    value: function _parseLayers(overlay) {
      var _this3 = this;

      var layers = overlay.flattenedLayers;
      var wmsLayers = {};

      // reset
      this.set('wmsGroups', []);
      this.set('geojsonLayers', []);

      layers.filter(function (l) {
        return l.visible;
      }).forEach(function (l) {
        if (l.type === 'wms') {
          // group the sources
          wmsLayers[l.source] = wmsLayers[l.source] || { layers: [], identify: false, infoFormat: null };
          wmsLayers[l.source].layers.push(l.machineName);
          wmsLayers[l.source].identify = wmsLayers[l.source].identify || l.identify;
          wmsLayers[l.source].infoFormat = wmsLayers[l.source].infoFormat || l.infoFormat;
        } else if (l.type === 'geojson') {
          _this3.push('geojsonLayers', l);
        }
      });

      // flattened the grouped WMS sources
      for (var s in wmsLayers) {
        this.push('wmsGroups', { source: s, layers: wmsLayers[s].layers, identify: wmsLayers[s].identify });
      }
    }
  }, {
    key: '_markMap',
    value: function _markMap(markersData) {
      var _this4 = this;

      this._markersGroup.clearLayers();
      if (markersData.length === 0) return;

      markersData.forEach(function (m) {
        _this4._markersGroup.addLayer(new _Marker.Marker(m.coords, {
          icon: new _Icon.Icon({
            iconUrl: _markerIcon2.default,
            shadowUrl: _markerShadow2.default,
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          })
        }).bindPopup(m.address));
      });

      if (markersData.length === 1) this.map.flyTo(markersData[0].coords);else this.map.fitBounds(this._markersGroup.getBounds());
    }
  }, {
    key: '_isCurrentExclusive',
    value: function _isCurrentExclusive(layer) {
      return layer.visible;
    }
  }, {
    key: '_isCurrentOverlay',
    value: function _isCurrentOverlay(selected, item) {
      return selected === item;
    }
  }, {
    key: '_overlayChanged',
    value: function _overlayChanged(newOverlay) {
      this._parseLayers(newOverlay);
    }
  }, {
    key: '_overlayLayersShow',
    value: function _overlayLayersShow(selected, item) {
      if (selected === item || this.flat) return "collapse show";
      return "collapse";
    }
  }, {
    key: '_overlayItemClass',
    value: function _overlayItemClass(selected, item) {
      var defaultClass = "overlay-item d-flex justify-content-start";
      if (selected === item) return defaultClass + ' selected';
      return defaultClass;
    }

    // FIXME: make this less hardcodey

  }, {
    key: 'downloadLayer',
    value: function downloadLayer(event) {
      event.stopPropagation();
      event.preventDefault();

      // if modal is not already found in light DOM, pull from shadow DOM
      var dom = document.querySelector('#download-modal') ? document : this.shadowRoot;

      var layer = event.model.layer;
      // FIXME: hardcoded url
      var downloadURL = 'https://www.ci.garden-grove.ca.us/geoserver/gis/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=' + layer.machineName;

      jQuery('#layer-name', dom).html(layer.name);
      jQuery('#geojson-download', dom).attr('href', downloadURL + '&outputFormat=application/json');
      jQuery('#csv-download', dom).attr('href', downloadURL + '&outputFormat=csv');
      jQuery('#kml-download', dom).attr('href', downloadURL + '&outputFormat=application/vnd.google-earth.kml+xml');
      jQuery('#shapefile-download', dom).attr('href', downloadURL + '&outputFormat=SHAPE-ZIP');
      jQuery('#download-modal', dom).modal();
    }
  }]);

  return GGMapViewer;
}(_polymerElement.Element);

customElements.define('gg-map-viewer', GGMapViewer);

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertyAccessors = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _caseMap = __webpack_require__(35);

var caseMap$0 = _interopRequireWildcard(_caseMap);

var _async = __webpack_require__(15);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var caseMap = caseMap$0;

var microtask = _async.microTask;

// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
var nativeProperties = {};
var proto = HTMLElement.prototype;
while (proto) {
  var props = Object.getOwnPropertyNames(proto);
  for (var i = 0; i < props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}

/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @private
 */
function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    var value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}

var PropertyAccessors = exports.PropertyAccessors = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends HTMLElement
   * @unrestricted
   */
  var PropertyAccessors = function (_superClass) {
    _inherits(PropertyAccessors, _superClass);

    _createClass(PropertyAccessors, null, [{
      key: 'createPropertiesForAttributes',


      /**
       * Generates property accessors for all attributes in the standard
       * static `observedAttributes` array.
       *
       * Attribute names are mapped to property names using the `dash-case` to
       * `camelCase` convention
       *
       */
      value: function createPropertiesForAttributes() {
        var a$ = this.observedAttributes;
        for (var _i = 0; _i < a$.length; _i++) {
          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
        }
      }
    }]);

    function PropertyAccessors() {
      _classCallCheck(this, PropertyAccessors);

      /** @type {boolean} */
      var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

      _this.__serializing;
      /** @type {number} */
      _this.__dataCounter;
      /** @type {boolean} */
      _this.__dataEnabled;
      /** @type {boolean} */
      _this.__dataReady;
      /** @type {boolean} */
      _this.__dataInvalid;
      /** @type {!Object} */
      _this.__data;
      /** @type {Object} */
      _this.__dataPending;
      /** @type {Object} */
      _this.__dataOld;
      /** @type {Object} */
      _this.__dataProto;
      /** @type {Object} */
      _this.__dataHasAccessor;
      /** @type {Object} */
      _this.__dataInstanceProps;
      _this._initializeProperties();
      return _this;
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     */


    _createClass(PropertyAccessors, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this._attributeToProperty(name, value);
        }
      }

      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @protected
       */

    }, {
      key: '_initializeProperties',
      value: function _initializeProperties() {
        this.__serializing = false;
        this.__dataCounter = 0;
        this.__dataEnabled = false;
        this.__dataReady = false;
        this.__dataInvalid = false;
        this.__data = {};
        this.__dataPending = null;
        this.__dataOld = null;
        if (this.__dataProto) {
          this._initializeProtoProperties(this.__dataProto);
          this.__dataProto = null;
        }
        // Capture instance properties; these will be set into accessors
        // during first flush. Don't set them here, since we want
        // these to overwrite defaults/constructor assignments
        for (var p in this.__dataHasAccessor) {
          if (this.hasOwnProperty(p)) {
            this.__dataInstanceProps = this.__dataInstanceProps || {};
            this.__dataInstanceProps[p] = this[p];
            delete this[p];
          }
        }
      }

      /**
       * Called at instance time with bag of properties that were overwritten
       * by accessors on the prototype when accessors were created.
       *
       * The default implementation sets these properties back into the
       * setter at instance time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @protected
       */

    }, {
      key: '_initializeProtoProperties',
      value: function _initializeProtoProperties(props) {
        for (var p in props) {
          this._setProperty(p, props[p]);
        }
      }

      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @protected
       */

    }, {
      key: '_initializeInstanceProperties',
      value: function _initializeInstanceProperties(props) {
        Object.assign(this, props);
      }

      /**
       * Ensures the element has the given attribute. If it does not,
       * assigns the given value to the attribute.
       *
       *
       * @param {string} attribute Name of attribute to ensure is set.
       * @param {string} value of the attribute.
       */

    }, {
      key: '_ensureAttribute',
      value: function _ensureAttribute(attribute, value) {
        if (!this.hasAttribute(attribute)) {
          this._valueToNodeAttribute(this, value, attribute);
        }
      }

      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to.
       */

    }, {
      key: '_attributeToProperty',
      value: function _attributeToProperty(attribute, value, type) {
        // Don't deserialize back to property if currently reflecting
        if (!this.__serializing) {
          var property = caseMap.dashToCamelCase(attribute);
          this[property] = this._deserializeValue(value, type);
        }
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */

    }, {
      key: '_propertyToAttribute',
      value: function _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = arguments.length < 3 ? this[property] : value;
        this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
        this.__serializing = false;
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       */

    }, {
      key: '_valueToNodeAttribute',
      value: function _valueToNodeAttribute(node, value, attribute) {
        var str = this._serializeValue(value);
        if (str === undefined) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(attribute, str);
        }
      }

      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called by Polymer when setting JS property values to
       * HTML attributes.  Users may override this method on Polymer element
       * prototypes to provide serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided property value.
       */

    }, {
      key: '_serializeValue',
      value: function _serializeValue(value) {
        /* eslint-disable no-fallthrough */
        switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
          case 'boolean':
            return value ? '' : undefined;

          case 'object':
            if (value instanceof Date) {
              return value.toString();
            } else if (value) {
              try {
                return JSON.stringify(value);
              } catch (x) {
                return '';
              }
            }

          default:
            return value != null ? value.toString() : undefined;
        }
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called by Polymer when reading HTML attribute values to
       * JS properties.  Users may override this method on Polymer element
       * prototypes to provide deserialization for custom `type`s.  Note,
       * the `type` argument is the value of the `type` field provided in the
       * `properties` configuration object for a given property, and is
       * by convention the constructor for the type to deserialize.
       *
       * Note: The return value of `undefined` is used as a sentinel value to
       * indicate the attribute should be removed.
       *
       * @param {?string} value Attribute value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       */

    }, {
      key: '_deserializeValue',
      value: function _deserializeValue(value, type) {
        /**
         * @type {*}
         */
        var outValue = void 0;
        switch (type) {
          case Number:
            outValue = Number(value);
            break;

          case Boolean:
            outValue = value !== null;
            break;

          case Object:
            try {
              outValue = JSON.parse( /** @type string */value);
            } catch (x) {
              // allow non-JSON literals like Strings and Numbers
            }
            break;

          case Array:
            try {
              outValue = JSON.parse( /** @type string */value);
            } catch (x) {
              outValue = null;
              console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
            }
            break;

          case Date:
            outValue = new Date(value);
            break;

          case String:
          default:
            outValue = value;
            break;
        }

        return outValue;
      }
      /* eslint-enable no-fallthrough */

      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.  When calling on
       * a prototype, any overwritten values are saved in `__dataProto`,
       * and it is up to the subclasser to decide how/when to set those
       * properties back into the accessor.  When calling on an instance,
       * the overwritten value is set via `_setPendingProperty`, and the
       * user should call `_invalidateProperties` or `_flushProperties`
       * for the values to take effect.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @protected
       */

    }, {
      key: '_createPropertyAccessor',
      value: function _createPropertyAccessor(property, readOnly) {
        if (!this.hasOwnProperty('__dataHasAccessor')) {
          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
        }
        if (!this.__dataHasAccessor[property]) {
          this.__dataHasAccessor[property] = true;
          saveAccessorValue(this, property);
          Object.defineProperty(this, property, {
            /* eslint-disable valid-jsdoc */
            /** @this {PropertyAccessors} */
            get: function get() {
              return this.__data[property];
            },
            /** @this {PropertyAccessors} */
            set: readOnly ? function () {} : function (value) {
              this._setProperty(property, value);
            }
            /* eslint-enable */
          });
        }
      }

      /**
       * Returns true if this library created an accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if an accessor was created
       */

    }, {
      key: '_hasAccessor',
      value: function _hasAccessor(property) {
        return this.__dataHasAccessor && this.__dataHasAccessor[property];
      }

      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @protected
       */

    }, {
      key: '_setProperty',
      value: function _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }

      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {boolean} Returns true if the property changed
       * @protected
       */

    }, {
      key: '_setPendingProperty',
      value: function _setPendingProperty(property, value) {
        var old = this.__data[property];
        var changed = this._shouldPropertyChange(property, value, old);
        if (changed) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (this.__dataOld && !(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
        }
        return changed;
      }

      /**
       * Returns true if the specified property has a pending change.
       *
       * @param {string} prop Property name
       * @return {boolean} True if property has a pending change
       * @protected
       */

    }, {
      key: '_isPropertyPending',
      value: function _isPropertyPending(prop) {
        return Boolean(this.__dataPending && prop in this.__dataPending);
      }

      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @protected
       */

    }, {
      key: '_invalidateProperties',
      value: function _invalidateProperties() {
        var _this2 = this;

        if (!this.__dataInvalid && this.__dataReady) {
          this.__dataInvalid = true;
          microtask.run(function () {
            if (_this2.__dataInvalid) {
              _this2.__dataInvalid = false;
              _this2._flushProperties();
            }
          });
        }
      }

      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       */

    }, {
      key: '_enableProperties',
      value: function _enableProperties() {
        if (!this.__dataEnabled) {
          this.__dataEnabled = true;
          if (this.__dataInstanceProps) {
            this._initializeInstanceProperties(this.__dataInstanceProps);
            this.__dataInstanceProps = null;
          }
          this.ready();
        }
      }

      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       *
       * @protected
       */

    }, {
      key: '_flushProperties',
      value: function _flushProperties() {
        if (this.__dataPending && this.__dataOld) {
          var changedProps = this.__dataPending;
          this.__dataPending = null;
          this.__dataCounter++;
          this._propertiesChanged(this.__data, changedProps, this.__dataOld);
          this.__dataCounter--;
        }
      }

      /**
       * Lifecycle callback called the first time properties are being flushed.
       * Prior to `ready`, all property sets through accessors are queued and
       * their effects are flushed after this method returns.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its properties initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @public
       */

    }, {
      key: 'ready',
      value: function ready() {
        this.__dataReady = true;
        // Run normal flush
        this._flushProperties();
      }

      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {!Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {!Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @protected
       */

    }, {
      key: '_propertiesChanged',
      value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` for primitive types if a
       * strict equality check fails, and returns `true` for all Object/Arrays.
       * The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       */

    }, {
      key: '_shouldPropertyChange',
      value: function _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check
          old !== value && (
          // This ensures (old==NaN, value==NaN) always returns false
          old === old || value === value)
        );
      }
    }]);

    return PropertyAccessors;
  }(superClass);

  return PropertyAccessors;
});

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplateStamp = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _mixin = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
var templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
function wrapTemplateExtension(node) {
  var is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    var t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while (t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }
  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  // unwind the stack, returning the indexed node at each level
  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}

// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}

// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}

// push configuration references at configure time
function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;
  var handler = function handler(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}

var TemplateStamp = exports.TemplateStamp = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  var TemplateStamp = function (_superClass) {
    _inherits(TemplateStamp, _superClass);

    function TemplateStamp() {
      _classCallCheck(this, TemplateStamp);

      return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
    }

    _createClass(TemplateStamp, [{
      key: '_stampTemplate',


      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       */
      value: function _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        var templateInfo = this.constructor._parseTemplate(template);
        var nodeInfo = templateInfo.nodeInfoList;
        var content = templateInfo.content || template.content;
        var dom = /** @type DocumentFragment */document.importNode(content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
        var nodes = dom.nodeList = new Array(nodeInfo.length);
        dom.$ = {};
        for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
          var node = nodes[i] = findTemplateNode(dom, info);
          applyIdToMap(this, dom.$, node, info);
          applyTemplateContent(this, node, info);
          applyEventListener(this, node, info);
        }
        return (/** @type {!StampedTemplate} */dom
        );
      }

      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {Node} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       */

    }, {
      key: '_addMethodEventListenerToNode',
      value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        var handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {Node} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {Function} handler Listener function to add
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {Node} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {Function} handler Listener function to remove
       */

    }, {
      key: '_removeEventListenerFromNode',
      value: function _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }
    }], [{
      key: '_parseTemplate',


      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       */
      value: function _parseTemplate(template, outerTemplateInfo) {
        // since a template may be re-used, memo-ize metadata
        if (!template._templateInfo) {
          var templateInfo = template._templateInfo = {};
          templateInfo.nodeInfoList = [];
          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
          this._parseTemplateContent(template, templateInfo, { parent: null });
        }
        return template._templateInfo;
      }
    }, {
      key: '_parseTemplateContent',
      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
      }

      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNode',
      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
        var noted = void 0;
        var element = /** @type Element */node;
        if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
        } else if (element.localName === 'slot') {
          // For ShadyDom optimization, indicating there is an insertion point
          templateInfo.hasInsertionPoint = true;
        }
        if (element.firstChild) {
          noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
        }
        if (element.hasAttributes && element.hasAttributes()) {
          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
        }
        return noted;
      }

      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       */

    }, {
      key: '_parseTemplateChildNodes',
      value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
        for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
          // Wrap templates
          if (node.localName == 'template') {
            node = wrapTemplateExtension(node);
          }
          // collapse adjacent textNodes: fixes an IE issue that can cause
          // text nodes to be inexplicably split =(
          // note that root.normalize() should work but does not so we do this
          // manually.
          next = node.nextSibling;
          if (node.nodeType === Node.TEXT_NODE) {
            var /** Node */n = next;
            while (n && n.nodeType === Node.TEXT_NODE) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root.removeChild(n);
              n = next;
            }
            // optionally strip whitespace
            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
              root.removeChild(node);
              continue;
            }
          }
          var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
          if (this._parseTemplateNode(node, templateInfo, childInfo)) {
            childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
          }
          // Increment if not removed
          if (node.parentNode) {
            parentIndex++;
          }
        }
      }

      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNestedTemplate',
      value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
        var templateInfo = this._parseTemplate(node, outerTemplateInfo);
        var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
        content.appendChild(node.content);
        nodeInfo.templateInfo = templateInfo;
        return true;
      }

      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNodeAttributes',
      value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
        // Make copy of original attribute list, since the order may change
        // as attributes are added and removed
        var noted = false;
        var attrs = Array.from(node.attributes);
        for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
        }
        return noted;
      }

      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNodeAttribute',
      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        // events (on-*)
        if (name.slice(0, 3) === 'on-') {
          node.removeAttribute(name);
          nodeInfo.events = nodeInfo.events || [];
          nodeInfo.events.push({
            name: name.slice(3),
            value: value
          });
          return true;
        }
        // static id
        else if (name === 'id') {
            nodeInfo.id = value;
            return true;
          }
        return false;
      }

      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       */

    }, {
      key: '_contentForTemplate',
      value: function _contentForTemplate(template) {
        var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
        return templateInfo && templateInfo.content || template.content;
      }
    }]);

    return TemplateStamp;
  }(superClass);

  return TemplateStamp;
});

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

__webpack_require__(107);

__webpack_require__(69);

__webpack_require__(108);

var _paperCheckedElementBehavior = __webpack_require__(109);

var _polymerFn = __webpack_require__(28);

var _renderStatus = __webpack_require__(66);

var _gestures = __webpack_require__(41);

var _paperRippleBehavior = __webpack_require__(45);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<dom-module id="paper-toggle-button">\n  <template strip-whitespace="">\n\n    <style>\n      :host {\n        display: inline-block;\n        @apply --layout-horizontal;\n        @apply --layout-center;\n        @apply --paper-font-common-base;\n      }\n\n      :host([disabled]) {\n        pointer-events: none;\n      }\n\n      :host(:focus) {\n        outline:none;\n      }\n\n      .toggle-bar {\n        position: absolute;\n        height: 100%;\n        width: 100%;\n        border-radius: 8px;\n        pointer-events: none;\n        opacity: 0.4;\n        transition: background-color linear .08s;\n        background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);\n\n        @apply --paper-toggle-button-unchecked-bar;\n      }\n\n      .toggle-button {\n        position: absolute;\n        top: -3px;\n        left: 0;\n        height: 20px;\n        width: 20px;\n        border-radius: 50%;\n        box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);\n        transition: -webkit-transform linear .08s, background-color linear .08s;\n        transition: transform linear .08s, background-color linear .08s;\n        will-change: transform;\n        background-color: var(--paper-toggle-button-unchecked-button-color, var(--paper-grey-50));\n\n        @apply --paper-toggle-button-unchecked-button;\n      }\n\n      .toggle-button.dragging {\n        -webkit-transition: none;\n        transition: none;\n      }\n\n      :host([checked]:not([disabled])) .toggle-bar {\n        opacity: 0.5;\n        background-color: var(--paper-toggle-button-checked-bar-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-bar;\n      }\n\n      :host([disabled]) .toggle-bar {\n        background-color: #000;\n        opacity: 0.12;\n      }\n\n      :host([checked]) .toggle-button {\n        -webkit-transform: translate(16px, 0);\n        transform: translate(16px, 0);\n      }\n\n      :host([checked]:not([disabled])) .toggle-button {\n        background-color: var(--paper-toggle-button-checked-button-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-button;\n      }\n\n      :host([disabled]) .toggle-button {\n        background-color: #bdbdbd;\n        opacity: 1;\n      }\n\n      .toggle-ink {\n        position: absolute;\n        top: -14px;\n        left: -14px;\n        right: auto;\n        bottom: auto;\n        width: 48px;\n        height: 48px;\n        opacity: 0.5;\n        pointer-events: none;\n        color: var(--paper-toggle-button-unchecked-ink-color, var(--primary-text-color));\n\n        @apply --paper-toggle-button-unchecked-ink;\n      }\n\n      :host([checked]) .toggle-ink {\n        color: var(--paper-toggle-button-checked-ink-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-ink;\n      }\n\n      .toggle-container {\n        display: inline-block;\n        position: relative;\n        width: 36px;\n        height: 14px;\n        /* The toggle button has an absolute position of -3px; The extra 1px\n        /* accounts for the toggle button shadow box. */\n        margin: 4px 1px;\n      }\n\n      .toggle-label {\n        position: relative;\n        display: inline-block;\n        vertical-align: middle;\n        padding-left: var(--paper-toggle-button-label-spacing, 8px);\n        pointer-events: none;\n        color: var(--paper-toggle-button-label-color, var(--primary-text-color));\n      }\n\n      /* invalid state */\n      :host([invalid]) .toggle-bar {\n        background-color: var(--paper-toggle-button-invalid-bar-color, var(--error-color));\n      }\n\n      :host([invalid]) .toggle-button {\n        background-color: var(--paper-toggle-button-invalid-button-color, var(--error-color));\n      }\n\n      :host([invalid]) .toggle-ink {\n        color: var(--paper-toggle-button-invalid-ink-color, var(--error-color));\n      }\n    </style>\n\n    <div class="toggle-container">\n      <div id="toggleBar" class="toggle-bar"></div>\n      <div id="toggleButton" class="toggle-button"></div>\n    </div>\n\n    <div class="toggle-label"><slot></slot></div>\n\n  </template>\n\n  \n</dom-module>';

document.head.appendChild($_documentContainer);
(0, _polymerFn.Polymer)({
  is: 'paper-toggle-button',

  behaviors: [_paperCheckedElementBehavior.PaperCheckedElementBehavior],

  hostAttributes: {
    role: 'button',
    'aria-pressed': 'false',
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
  },

  listeners: {
    track: '_ontrack'
  },

  attached: function attached() {
    (0, _renderStatus.afterNextRender)(this, function () {
      (0, _gestures.setTouchAction)(this, 'pan-y');
    });
  },

  _ontrack: function _ontrack(event) {
    var track = event.detail;
    if (track.state === 'start') {
      this._trackStart(track);
    } else if (track.state === 'track') {
      this._trackMove(track);
    } else if (track.state === 'end') {
      this._trackEnd(track);
    }
  },

  _trackStart: function _trackStart(track) {
    this._width = this.$.toggleBar.offsetWidth / 2;
    /*
     * keep an track-only check state to keep the dragging behavior smooth
     * while toggling activations
     */
    this._trackChecked = this.checked;
    this.$.toggleButton.classList.add('dragging');
  },

  _trackMove: function _trackMove(track) {
    var dx = track.dx;
    this._x = Math.min(this._width, Math.max(0, this._trackChecked ? this._width + dx : dx));
    this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
    this._userActivate(this._x > this._width / 2);
  },

  _trackEnd: function _trackEnd(track) {
    this.$.toggleButton.classList.remove('dragging');
    this.transform('', this.$.toggleButton);
  },

  // customize the element's ripple
  _createRipple: function _createRipple() {
    this._rippleContainer = this.$.toggleButton;
    var ripple = _paperRippleBehavior.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('recenters', '');
    ripple.classList.add('circle', 'toggle-ink');
    return ripple;
  }

});

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


var _applyShim = __webpack_require__(95);

var _applyShim2 = _interopRequireDefault(_applyShim);

var _templateMap = __webpack_require__(62);

var _templateMap2 = _interopRequireDefault(_templateMap);

var _styleUtil = __webpack_require__(61);

var _applyShimUtils = __webpack_require__(96);

var ApplyShimUtils = _interopRequireWildcard(_applyShimUtils);

var _documentWait = __webpack_require__(63);

var _documentWait2 = _interopRequireDefault(_documentWait);

var _commonUtils = __webpack_require__(40);

var _customStyleInterface = __webpack_require__(64);

var _styleSettings = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @const {ApplyShim} */
var applyShim = new _applyShim2.default();

var ApplyShimInterface = function () {
  function ApplyShimInterface() {
    var _this = this;

    _classCallCheck(this, ApplyShimInterface);

    /** @type {?CustomStyleInterfaceInterface} */
    this.customStyleInterface = null;
    (0, _documentWait2.default)(function () {
      _this.ensure();
    });
    applyShim['invalidCallback'] = ApplyShimUtils.invalidate;
  }

  _createClass(ApplyShimInterface, [{
    key: 'ensure',
    value: function ensure() {
      var _this2 = this;

      if (this.customStyleInterface) {
        return;
      }
      this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
      if (this.customStyleInterface) {
        this.customStyleInterface['transformCallback'] = function (style) {
          applyShim.transformCustomStyle(style);
        };
        this.customStyleInterface['validateCallback'] = function () {
          requestAnimationFrame(function () {
            if (_this2.customStyleInterface['enqueued']) {
              _this2.flushCustomStyles();
            }
          });
        };
      }
    }
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     */

  }, {
    key: 'prepareTemplate',
    value: function prepareTemplate(template, elementName) {
      this.ensure();
      _templateMap2.default[elementName] = template;
      var ast = applyShim.transformTemplate(template, elementName);
      // save original style ast to use for revalidating instances
      template['_styleAst'] = ast;
    }
  }, {
    key: 'flushCustomStyles',
    value: function flushCustomStyles() {
      this.ensure();
      if (!this.customStyleInterface) {
        return;
      }
      var styles = this.customStyleInterface['processStyles']();
      if (!this.customStyleInterface['enqueued']) {
        return;
      }
      for (var i = 0; i < styles.length; i++) {
        var cs = styles[i];
        var style = this.customStyleInterface['getStyleForCustomStyle'](cs);
        if (style) {
          applyShim.transformCustomStyle(style);
        }
      }
      this.customStyleInterface['enqueued'] = false;
    }
    /**
     * @param {HTMLElement} element
     * @param {Object=} properties
     */

  }, {
    key: 'styleSubtree',
    value: function styleSubtree(element, properties) {
      this.ensure();
      if (properties) {
        (0, _commonUtils.updateNativeProperties)(element, properties);
      }
      if (element.shadowRoot) {
        this.styleElement(element);
        var shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
        for (var i = 0; i < shadowChildren.length; i++) {
          this.styleSubtree( /** @type {HTMLElement} */shadowChildren[i]);
        }
      } else {
        var children = element.children || element.childNodes;
        for (var _i = 0; _i < children.length; _i++) {
          this.styleSubtree( /** @type {HTMLElement} */children[_i]);
        }
      }
    }
    /**
     * @param {HTMLElement} element
     */

  }, {
    key: 'styleElement',
    value: function styleElement(element) {
      this.ensure();

      var _getIsExtends = (0, _styleUtil.getIsExtends)(element),
          is = _getIsExtends.is;

      var template = _templateMap2.default[is];
      if (template && !ApplyShimUtils.templateIsValid(template)) {
        // only revalidate template once
        if (!ApplyShimUtils.templateIsValidating(template)) {
          this.prepareTemplate(template, is);
          ApplyShimUtils.startValidatingTemplate(template);
        }
        // update this element instance
        var root = element.shadowRoot;
        if (root) {
          var style = /** @type {HTMLStyleElement} */root.querySelector('style');
          if (style) {
            // reuse the template's style ast, it has all the original css text
            style['__cssRules'] = template['_styleAst'];
            style.textContent = (0, _styleUtil.toCssText)(template['_styleAst']);
          }
        }
      }
    }
    /**
     * @param {Object=} properties
     */

  }, {
    key: 'styleDocument',
    value: function styleDocument(properties) {
      this.ensure();
      this.styleSubtree(document.body, properties);
    }
  }]);

  return ApplyShimInterface;
}();

if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  var applyShimInterface = new ApplyShimInterface();
  var CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;

  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate: function prepareTemplate(template, elementName, elementExtends) {
      // eslint-disable-line no-unused-vars
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName);
    },


    /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */
    styleSubtree: function styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },


    /**
     * @param {!HTMLElement} element
     */
    styleElement: function styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },


    /**
     * @param {Object=} properties
     */
    styleDocument: function styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },


    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue: function getComputedStyleValue(element, property) {
      return (0, _commonUtils.getComputedStyleValue)(element, property);
    },

    nativeCss: _styleSettings.nativeCssVariables,
    nativeShadow: _styleSettings.nativeShadow
  };

  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}

window.ShadyCSS.ApplyShim = applyShim;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/*
 * The apply shim simulates the behavior of `@apply` proposed at
 * https://tabatkins.github.io/specs/css-apply-rule/.
 * The approach is to convert a property like this:
 *
 *    --foo: {color: red; background: blue;}
 *
 * to this:
 *
 *    --foo_-_color: red;
 *    --foo_-_background: blue;
 *
 * Then where `@apply --foo` is used, that is converted to:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background);
 *
 * This approach generally works but there are some issues and limitations.
 * Consider, for example, that somewhere *between* where `--foo` is set and used,
 * another element sets it to:
 *
 *    --foo: { border: 2px solid red; }
 *
 * We must now ensure that the color and background from the previous setting
 * do not apply. This is accomplished by changing the property set to this:
 *
 *    --foo_-_border: 2px solid red;
 *    --foo_-_color: initial;
 *    --foo_-_background: initial;
 *
 * This works but introduces one new issue.
 * Consider this setup at the point where the `@apply` is used:
 *
 *    background: orange;
 *    `@apply` --foo;
 *
 * In this case the background will be unset (initial) rather than the desired
 * `orange`. We address this by altering the property set to use a fallback
 * value like this:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background, orange);
 *    border: var(--foo_-_border);
 *
 * Note that the default is retained in the property set and the `background` is
 * the desired `orange`. This leads us to a limitation.
 *
 * Limitation 1:

 * Only properties in the rule where the `@apply`
 * is used are considered as default values.
 * If another rule matches the element and sets `background` with
 * less specificity than the rule in which `@apply` appears,
 * the `background` will not be set.
 *
 * Limitation 2:
 *
 * When using Polymer's `updateStyles` api, new properties may not be set for
 * `@apply` properties.

*/



Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _styleUtil = __webpack_require__(61);

var _commonRegex = __webpack_require__(39);

var _commonUtils = __webpack_require__(40);

var _cssParse = __webpack_require__(38);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// eslint-disable-line no-unused-vars

var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;

// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
var MIXIN_VAR_SEP = '_-_';

/**
 * @typedef {!Object<string, string>}
 */
var PropertyEntry = void 0; // eslint-disable-line no-unused-vars

/**
 * @typedef {!Object<string, boolean>}
 */
var DependantsEntry = void 0; // eslint-disable-line no-unused-vars

/** @typedef {{
 *    properties: PropertyEntry,
 *    dependants: DependantsEntry
 * }}
 */
var MixinMapEntry = void 0; // eslint-disable-line no-unused-vars

// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}

var MixinMap = function () {
  function MixinMap() {
    _classCallCheck(this, MixinMap);

    /** @type {!Object<string, !MixinMapEntry>} */
    this._map = {};
  }
  /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */


  _createClass(MixinMap, [{
    key: 'set',
    value: function set(name, props) {
      name = name.trim();
      this._map[name] = {
        properties: props,
        dependants: {}
      };
    }
    /**
     * @param {string} name
     * @return {MixinMapEntry}
     */

  }, {
    key: 'get',
    value: function get(name) {
      name = name.trim();
      return this._map[name] || null;
    }
  }]);

  return MixinMap;
}();

/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */


var invalidCallback = null;

/** @unrestricted */

var ApplyShim = function () {
  function ApplyShim() {
    _classCallCheck(this, ApplyShim);

    /** @type {?string} */
    this._currentElement = null;
    /** @type {HTMLMetaElement} */
    this._measureElement = null;
    this._map = new MixinMap();
  }
  /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */


  _createClass(ApplyShim, [{
    key: 'detectMixin',
    value: function detectMixin(cssText) {
      return (0, _commonUtils.detectMixin)(cssText);
    }
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @return {StyleNode}
     */

  }, {
    key: 'transformTemplate',
    value: function transformTemplate(template, elementName) {
      var style = /** @type {HTMLStyleElement} */template.content.querySelector('style');
      /** @type {StyleNode} */
      var ast = null;
      if (style) {
        ast = this.transformStyle(style, elementName);
      }
      return ast;
    }
    /**
     * @param {!HTMLStyleElement} style
     * @param {string} elementName
     * @return {StyleNode}
     */

  }, {
    key: 'transformStyle',
    value: function transformStyle(style) {
      var elementName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var ast = (0, _styleUtil.rulesForStyle)(style);
      this.transformRules(ast, elementName);
      style.textContent = (0, _styleUtil.toCssText)(ast);
      return ast;
    }
    /**
     * @param {!HTMLStyleElement} style
     * @return {StyleNode}
     */

  }, {
    key: 'transformCustomStyle',
    value: function transformCustomStyle(style) {
      var _this = this;

      var ast = (0, _styleUtil.rulesForStyle)(style);
      (0, _styleUtil.forEachRule)(ast, function (rule) {
        if (rule['selector'] === ':root') {
          rule['selector'] = 'html';
        }
        _this.transformRule(rule);
      });
      style.textContent = (0, _styleUtil.toCssText)(ast);
      return ast;
    }
    /**
     * @param {StyleNode} rules
     * @param {string} elementName
     */

  }, {
    key: 'transformRules',
    value: function transformRules(rules, elementName) {
      var _this2 = this;

      this._currentElement = elementName;
      (0, _styleUtil.forEachRule)(rules, function (r) {
        _this2.transformRule(r);
      });
      this._currentElement = null;
    }
    /**
     * @param {!StyleNode} rule
     */

  }, {
    key: 'transformRule',
    value: function transformRule(rule) {
      rule['cssText'] = this.transformCssText(rule['parsedCssText']);
      // :root was only used for variable assignment in property shim,
      // but generates invalid selectors with real properties.
      // replace with `:host > *`, which serves the same effect
      if (rule['selector'] === ':root') {
        rule['selector'] = ':host > *';
      }
    }
    /**
     * @param {string} cssText
     * @return {string}
     */

  }, {
    key: 'transformCssText',
    value: function transformCssText(cssText) {
      var _this3 = this;

      // produce variables
      cssText = cssText.replace(_commonRegex.VAR_ASSIGN, function (matchText, propertyName, valueProperty, valueMixin) {
        return _this3._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);
      });
      // consume mixins
      return this._consumeCssProperties(cssText);
    }
    /**
     * @param {string} property
     * @return {string}
     */

  }, {
    key: '_getInitialValueForProperty',
    value: function _getInitialValueForProperty(property) {
      if (!this._measureElement) {
        this._measureElement = /** @type {HTMLMetaElement} */document.createElement('meta');
        this._measureElement.setAttribute('apply-shim-measure', '');
        this._measureElement.style.all = 'initial';
        document.head.appendChild(this._measureElement);
      }
      return window.getComputedStyle(this._measureElement).getPropertyValue(property);
    }
    /**
     * replace mixin consumption with variable consumption
     * @param {string} text
     * @return {string}
     */

  }, {
    key: '_consumeCssProperties',
    value: function _consumeCssProperties(text) {
      /** @type {Array} */
      var m = null;
      // loop over text until all mixins with defintions have been applied
      while (m = _commonRegex.MIXIN_MATCH.exec(text)) {
        var matchText = m[0];
        var mixinName = m[1];
        var idx = m.index;
        // collect properties before apply to be "defaults" if mixin might override them
        // match includes a "prefix", so find the start and end positions of @apply
        var applyPos = idx + matchText.indexOf('@apply');
        var afterApplyPos = idx + matchText.length;
        // find props defined before this @apply
        var textBeforeApply = text.slice(0, applyPos);
        var textAfterApply = text.slice(afterApplyPos);
        var defaults = this._cssTextToMap(textBeforeApply);
        var replacement = this._atApplyToCssProperties(mixinName, defaults);
        // use regex match position to replace mixin, keep linear processing time
        text = '' + textBeforeApply + replacement + textAfterApply;
        // move regex search to _after_ replacement
        _commonRegex.MIXIN_MATCH.lastIndex = idx + replacement.length;
      }
      return text;
    }
    /**
     * produce variable consumption at the site of mixin consumption
     * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
     * Example:
     *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
     *
     * @param {string} mixinName
     * @param {Object} fallbacks
     * @return {string}
     */

  }, {
    key: '_atApplyToCssProperties',
    value: function _atApplyToCssProperties(mixinName, fallbacks) {
      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
      var vars = [];
      var mixinEntry = this._map.get(mixinName);
      // if we depend on a mixin before it is created
      // make a sentinel entry in the map to add this element as a dependency for when it is defined.
      if (!mixinEntry) {
        this._map.set(mixinName, {});
        mixinEntry = this._map.get(mixinName);
      }
      if (mixinEntry) {
        if (this._currentElement) {
          mixinEntry.dependants[this._currentElement] = true;
        }
        var p = void 0,
            parts = void 0,
            f = void 0;
        for (p in mixinEntry.properties) {
          f = fallbacks && fallbacks[p];
          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
          if (f) {
            parts.push(',', f);
          }
          parts.push(')');
          vars.push(parts.join(''));
        }
      }
      return vars.join('; ');
    }

    /**
     * @param {string} property
     * @param {string} value
     * @return {string}
     */

  }, {
    key: '_replaceInitialOrInherit',
    value: function _replaceInitialOrInherit(property, value) {
      var match = INITIAL_INHERIT.exec(value);
      if (match) {
        if (match[1]) {
          // initial
          // replace `initial` with the concrete initial value for this property
          value = this._getInitialValueForProperty(property);
        } else {
          // inherit
          // with this purposfully illegal value, the variable will be invalid at
          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
          // and for inheriting values, will behave similarly
          // we cannot support the same behavior for non inheriting values like 'border'
          value = 'apply-shim-inherit';
        }
      }
      return value;
    }

    /**
     * "parse" a mixin definition into a map of properties and values
     * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
     * @param {string} text
     * @return {!Object<string, string>}
     */

  }, {
    key: '_cssTextToMap',
    value: function _cssTextToMap(text) {
      var props = text.split(';');
      var property = void 0,
          value = void 0;
      var out = {};
      for (var i = 0, p, sp; i < props.length; i++) {
        p = props[i];
        if (p) {
          sp = p.split(':');
          // ignore lines that aren't definitions like @media
          if (sp.length > 1) {
            property = sp[0].trim();
            // some properties may have ':' in the value, like data urls
            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
            out[property] = value;
          }
        }
      }
      return out;
    }

    /**
     * @param {MixinMapEntry} mixinEntry
     */

  }, {
    key: '_invalidateMixinEntry',
    value: function _invalidateMixinEntry(mixinEntry) {
      if (!invalidCallback) {
        return;
      }
      for (var elementName in mixinEntry.dependants) {
        if (elementName !== this._currentElement) {
          invalidCallback(elementName);
        }
      }
    }

    /**
     * @param {string} matchText
     * @param {string} propertyName
     * @param {?string} valueProperty
     * @param {?string} valueMixin
     * @return {string}
     */

  }, {
    key: '_produceCssProperties',
    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
      var _this4 = this;

      // handle case where property value is a mixin
      if (valueProperty) {
        // form: --mixin2: var(--mixin1), where --mixin1 is in the map
        (0, _styleUtil.processVariableAndFallback)(valueProperty, function (prefix, value) {
          if (value && _this4._map.get(value)) {
            valueMixin = '@apply ' + value + ';';
          }
        });
      }
      if (!valueMixin) {
        return matchText;
      }
      var mixinAsProperties = this._consumeCssProperties(valueMixin);
      var prefix = matchText.slice(0, matchText.indexOf('--'));
      var mixinValues = this._cssTextToMap(mixinAsProperties);
      var combinedProps = mixinValues;
      var mixinEntry = this._map.get(propertyName);
      var oldProps = mixinEntry && mixinEntry.properties;
      if (oldProps) {
        // NOTE: since we use mixin, the map of properties is updated here
        // and this is what we want.
        combinedProps = Object.assign(Object.create(oldProps), mixinValues);
      } else {
        this._map.set(propertyName, combinedProps);
      }
      var out = [];
      var p = void 0,
          v = void 0;
      // set variables defined by current mixin
      var needToInvalidate = false;
      for (p in combinedProps) {
        v = mixinValues[p];
        // if property not defined by current mixin, set initial
        if (v === undefined) {
          v = 'initial';
        }
        if (oldProps && !(p in oldProps)) {
          needToInvalidate = true;
        }
        out.push('' + propertyName + MIXIN_VAR_SEP + p + ': ' + v);
      }
      if (needToInvalidate) {
        this._invalidateMixinEntry(mixinEntry);
      }
      if (mixinEntry) {
        mixinEntry.properties = combinedProps;
      }
      // because the mixinMap is global, the mixin might conflict with
      // a different scope's simple variable definition:
      // Example:
      // some style somewhere:
      // --mixin1:{ ... }
      // --mixin2: var(--mixin1);
      // some other element:
      // --mixin1: 10px solid red;
      // --foo: var(--mixin1);
      // In this case, we leave the original variable definition in place.
      if (valueProperty) {
        prefix = matchText + ';' + prefix;
      }
      return '' + prefix + out.join('; ') + ';';
    }
  }]);

  return ApplyShim;
}();

/* exports */


ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  /** @return {?function(string)} */
  get: function get() {
    return invalidCallback;
  },

  /** @param {?function(string)} cb */
  set: function set(cb) {
    invalidCallback = cb;
  }
});

exports.default = ApplyShim;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invalidate = invalidate;
exports.invalidateTemplate = invalidateTemplate;
exports.isValid = isValid;
exports.templateIsValid = templateIsValid;
exports.isValidating = isValidating;
exports.templateIsValidating = templateIsValidating;
exports.startValidating = startValidating;
exports.startValidatingTemplate = startValidatingTemplate;
exports.elementsAreInvalid = elementsAreInvalid;

var _templateMap = __webpack_require__(62);

var _templateMap2 = _interopRequireDefault(_templateMap);

var _cssParse = __webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line no-unused-vars

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */
var CURRENT_VERSION = '_applyShimCurrentVersion';

/** @const {string} */
var NEXT_VERSION = '_applyShimNextVersion';

/** @const {string} */
var VALIDATING_VERSION = '_applyShimValidatingVersion';

/**
 * @const {Promise<void>}
 */
var promise = Promise.resolve();

/**
 * @param {string} elementName
 */
function invalidate(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */
function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  // ensure the "validating for" flag exists
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  // increment the next version
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValid(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    return templateIsValid(template);
  }
  return true;
}

/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValidating(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    return templateIsValidating(template);
  }
  return false;
}

/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}

/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
*/
function startValidating(elementName) {
  var template = _templateMap2.default[elementName];
  startValidatingTemplate(template);
}

/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */
function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  // however, there only needs to be one async task to clear the counters
  if (!template._validating) {
    template._validating = true;
    promise.then(function () {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
 * @return {boolean}
 */
function elementsAreInvalid() {
  for (var elementName in _templateMap2.default) {
    var template = _templateMap2.default[elementName];
    if (!templateIsValid(template)) {
      return true;
    }
  }
  return false;
}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.importHref = undefined;

__webpack_require__(2);

// run a callback when HTMLImports are ready or immediately if
// this api is not available.
function whenImportsReady(cb) {
  if (window.HTMLImports) {
    HTMLImports.whenReady(cb);
  } else {
    cb();
  }
}

var importHref = exports.importHref = function importHref(href, onload, onerror, optAsync) {
  var link = /** @type {HTMLLinkElement} */
  document.head.querySelector('link[href="' + href + '"][import-href]');
  if (!link) {
    link = /** @type {HTMLLinkElement} */document.createElement('link');
    link.rel = 'import';
    link.href = href;
    link.setAttribute('import-href', '');
  }
  // always ensure link has `async` attribute if user specified one,
  // even if it was previously not async. This is considered less confusing.
  if (optAsync) {
    link.setAttribute('async', '');
  }
  // NOTE: the link may now be in 3 states: (1) pending insertion,
  // (2) inflight, (3) already laoded. In each case, we need to add
  // event listeners to process callbacks.
  var cleanup = function cleanup() {
    link.removeEventListener('load', loadListener);
    link.removeEventListener('error', errorListener);
  };
  var loadListener = function loadListener(event) {
    cleanup();
    // In case of a successful load, cache the load event on the link so
    // that it can be used to short-circuit this method in the future when
    // it is called with the same href param.
    link.__dynamicImportLoaded = true;
    if (onload) {
      whenImportsReady(function () {
        onload(event);
      });
    }
  };
  var errorListener = function errorListener(event) {
    cleanup();
    // In case of an error, remove the link from the document so that it
    // will be automatically created again the next time `importHref` is
    // called.
    if (link.parentNode) {
      link.parentNode.removeChild(link);
    }
    if (onerror) {
      whenImportsReady(function () {
        onerror(event);
      });
    }
  };
  link.addEventListener('load', loadListener);
  link.addEventListener('error', errorListener);
  if (link.parentNode == null) {
    document.head.appendChild(link);
    // if the link already loaded, dispatch a fake load event
    // so that listeners are called and get a proper event argument.
  } else if (link.__dynamicImportLoaded) {
    link.dispatchEvent(new Event('load'));
  }
  return link;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function resolve() {
  document.body.removeAttribute('unresolved');
}

if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mixinBehaviors = exports.Class = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _legacyElementMixin = __webpack_require__(60);

var _domModule = __webpack_require__(59);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var metaProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  // meta objects
  behaviors: true
};

/**
 * Applies a "legacy" behavior or array of behaviors to the provided class.
 *
 * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
 * to ensure that any legacy behaviors can rely on legacy Polymer API on
 * the underlying element.
 *
 * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
 * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
 * @return {function(new:HTMLElement)} Returns a new Element class extended by the
 * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
 * @memberof Polymer
 * @suppress {invalidCasts, checkTypes}
 */
function mixinBehaviors(behaviors, klass) {
  if (!behaviors) {
    return (/** @type {HTMLElement} */klass
    );
  }
  // NOTE: ensure the bahevior is extending a class with
  // legacy element api. This is necessary since behaviors expect to be able
  // to access 1.x legacy api.
  klass = (0, _legacyElementMixin.LegacyElementMixin)(klass);
  if (!Array.isArray(behaviors)) {
    behaviors = [behaviors];
  }
  var superBehaviors = klass.prototype.behaviors;
  // get flattened, deduped list of behaviors *not* already on super class
  behaviors = flattenBehaviors(behaviors, null, superBehaviors);
  // mixin new behaviors
  klass = _mixinBehaviors(behaviors, klass);
  if (superBehaviors) {
    behaviors = superBehaviors.concat(behaviors);
  }
  // Set behaviors on prototype for BC...
  klass.prototype.behaviors = behaviors;
  return klass;
}

// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function _mixinBehaviors(behaviors, klass) {
  for (var i = 0; i < behaviors.length; i++) {
    var b = behaviors[i];
    if (b) {
      klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
    }
  }
  return klass;
}

/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (var i = behaviors.length - 1; i >= 0; i--) {
    var b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        // dedup
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}

/**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */
function GenerateClassFromInfo(info, Base) {
  var PolymerGenerated = function (_Base) {
    _inherits(PolymerGenerated, _Base);

    function PolymerGenerated() {
      _classCallCheck(this, PolymerGenerated);

      return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
    }

    _createClass(PolymerGenerated, [{
      key: 'created',
      value: function created() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
        if (info.created) {
          info.created.call(this);
        }
      }
    }, {
      key: '_registered',
      value: function _registered() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
        /* NOTE: `beforeRegister` is called here for bc, but the behavior
         is different than in 1.x. In 1.0, the method was called *after*
         mixing prototypes together but *before* processing of meta-objects.
         However, dynamic effects can still be set here and can be done either
         in `beforeRegister` or `registered`. It is no longer possible to set
         `is` in `beforeRegister` as you could in 1.x.
        */
        if (info.beforeRegister) {
          info.beforeRegister.call(Object.getPrototypeOf(this));
        }
        if (info.registered) {
          info.registered.call(Object.getPrototypeOf(this));
        }
      }
    }, {
      key: '_applyListeners',
      value: function _applyListeners() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
        if (info.listeners) {
          for (var l in info.listeners) {
            this._addMethodEventListenerToNode(this, l, info.listeners[l]);
          }
        }
      }

      // note: exception to "super then me" rule;
      // do work before calling super so that super attributes
      // only apply if not already set.

    }, {
      key: '_ensureAttributes',
      value: function _ensureAttributes() {
        if (info.hostAttributes) {
          for (var a in info.hostAttributes) {
            this._ensureAttribute(a, info.hostAttributes[a]);
          }
        }
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
      }
    }, {
      key: 'ready',
      value: function ready() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
        if (info.ready) {
          info.ready.call(this);
        }
      }
    }, {
      key: 'attached',
      value: function attached() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
        if (info.attached) {
          info.attached.call(this);
        }
      }
    }, {
      key: 'detached',
      value: function detached() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
        if (info.detached) {
          info.detached.call(this);
        }
      }
    }, {
      key: 'attributeChanged',
      value: function attributeChanged(name, old, value) {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
        if (info.attributeChanged) {
          info.attributeChanged.call(this, name, old, value);
        }
      }
    }], [{
      key: 'properties',
      get: function get() {
        return info.properties;
      }
    }, {
      key: 'observers',
      get: function get() {
        return info.observers;
      }

      /**
       * @return {HTMLTemplateElement} template for this class
       */

    }, {
      key: 'template',
      get: function get() {
        // get template first from any imperative set in `info._template`
        return info._template ||
        // next look in dom-module associated with this element's is.
        _domModule.DomModule && _domModule.DomModule.import(this.is, 'template') ||
        // next look for superclass template (note: use superclass symbol
        // to ensure correct `this.is`)
        Base.template ||
        // finally fall back to `_template` in element's protoype.
        this.prototype._template || null;
      }
    }]);

    return PolymerGenerated;
  }(Base);

  PolymerGenerated.generatedFrom = info;

  for (var p in info) {
    // NOTE: cannot copy `metaProps` methods onto prototype at least because
    // `super.ready` must be called and is not included in the user fn.
    if (!(p in metaProps)) {
      var pd = Object.getOwnPropertyDescriptor(info, p);
      if (pd) {
        Object.defineProperty(PolymerGenerated.prototype, p, pd);
      }
    }
  }

  return PolymerGenerated;
}

var Class = exports.Class = function Class(info) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  var klass = GenerateClassFromInfo(info, info.behaviors ?
  // note: mixinBehaviors ensures `LegacyElementMixin`.
  mixinBehaviors(info.behaviors, HTMLElement) : (0, _legacyElementMixin.LegacyElementMixin)(HTMLElement));
  // decorate klass with registration info
  klass.is = info.is;
  return klass;
};

exports.mixinBehaviors = mixinBehaviors;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Templatizer = undefined;

var _templatize = __webpack_require__(43);

var TemplateInstanceBase = _templatize.TemplateInstanceBase; // eslint-disable-line

/**
 * @typedef {{
 *   _templatizerTemplate: HTMLTemplateElement,
 *   _parentModel: boolean,
 *   _instanceProps: Object,
 *   _forwardHostPropV2: Function,
 *   _notifyInstancePropV2: Function,
 *   ctor: TemplateInstanceBase
 * }}
 */
var TemplatizerUser = void 0; // eslint-disable-line

/**
 * The `Polymer.Templatizer` behavior adds methods to generate instances of
 * templates that are each managed by an anonymous `Polymer.PropertyEffects`
 * instance where data-bindings in the stamped template content are bound to
 * accessors on itself.
 *
 * This behavior is provided in Polymer 2.x as a hybrid-element convenience
 * only.  For non-hybrid usage, the `Polymer.Templatize` library
 * should be used instead.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     this.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = this.stamp({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. light DOM
 *     Polymer.dom(this).appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * Users of `Templatizer` may need to implement the following abstract
 * API's to determine how properties and paths from the host should be
 * forwarded into to instances:
 *
 *     _forwardHostPropV2: function(prop, value)
 *
 * Likewise, users may implement these additional abstract API's to determine
 * how instance-specific properties that change on the instance should be
 * forwarded out to the host, if necessary.
 *
 *     _notifyInstancePropV2: function(inst, prop, value)
 *
 * In order to determine which properties are instance-specific and require
 * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
 * object containing keys for each instance prop, for example:
 *
 *     _instanceProps: {
 *       item: true,
 *       index: true
 *     }
 *
 * Any properties used in the template that are not defined in _instanceProp
 * will be forwarded out to the Templatize `owner` automatically.
 *
 * Users may also implement the following abstract function to show or
 * hide any DOM generated using `stamp`:
 *
 *     _showHideChildren: function(shouldHide)
 *
 * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
 * as the implementations will need to differ from the callbacks required
 * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
 * between versions 1.x and 2.x.
 *
 * @polymerBehavior
 * @memberof Polymer
 */
var Templatizer = {

  /**
   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
   * for the provided template.  This method should be called once per
   * template to prepare an element for stamping the template, followed
   * by `stamp` to create new instances of the template.
   *
   * @param {HTMLTemplateElement} template Template to prepare
   * @param {boolean=} mutableData When `true`, the generated class will skip
   *   strict dirty-checking for objects and arrays (always consider them to
   *   be "dirty"). Defaults to false.
   * @this {TemplatizerUser}
   */
  templatize: function templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = _templatize.Templatize.templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },


  /**
   * Creates an instance of the template prepared by `templatize`.  The object
   * returned is an instance of the anonymous class generated by `templatize`
   * whose `root` property is a document fragment containing newly cloned
   * template content, and which has property accessors corresponding to
   * properties referenced in template bindings.
   *
   * @param {Object=} model Object containing initial property values to
   *   populate into the template bindings.
   * @return {TemplateInstanceBase} Returns the created instance of
   * the template prepared by `templatize`.
   * @this {TemplatizerUser}
   */
  stamp: function stamp(model) {
    return new this.ctor(model);
  },


  /**
   * Returns the template "model" (`TemplateInstance`) associated with
   * a given element, which serves as the binding scope for the template
   * instance the element is contained in.  A template model should be used
   * to manipulate data associated with this template instance.
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   * @this {TemplatizerUser}
   */
  modelForElement: function modelForElement(el) {
    return _templatize.Templatize.modelForElement(this._templatizerTemplate, el);
  }
};

exports.Templatizer = Templatizer;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomBind = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _propertyEffects = __webpack_require__(36);

var _mutableData = __webpack_require__(29);

var _gestureEventListeners = __webpack_require__(65);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 */
var domBindBase = (0, _gestureEventListeners.GestureEventListeners)((0, _mutableData.OptionalMutableData)((0, _propertyEffects.PropertyEffects)(HTMLElement)));

/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @appliesMixin Polymer.OptionalMutableData
 * @appliesMixin Polymer.GestureEventListeners
 * @extends {domBindBase}
 * @memberof Polymer
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */

var DomBind = function (_domBindBase) {
  _inherits(DomBind, _domBindBase);

  _createClass(DomBind, null, [{
    key: 'observedAttributes',
    get: function get() {
      return ['mutable-data'];
    }
  }]);

  function DomBind() {
    _classCallCheck(this, DomBind);

    var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

    _this.root = null;
    _this.$ = null;
    _this.__children = null;
    return _this;
  }

  // assumes only one observed attribute


  _createClass(DomBind, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback() {
      this.mutableData = true;
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.render();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.__removeChildren();
    }
  }, {
    key: '__insertChildren',
    value: function __insertChildren() {
      this.parentNode.insertBefore(this.root, this);
    }
  }, {
    key: '__removeChildren',
    value: function __removeChildren() {
      if (this.__children) {
        for (var i = 0; i < this.__children.length; i++) {
          this.root.appendChild(this.__children[i]);
        }
      }
    }

    /**
     * Forces the element to render its content. This is typically only
     * necessary to call if HTMLImports with the async attribute are used.
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var template = void 0;
      if (!this.__children) {
        template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
        if (!template) {
          // Wait until childList changes and template should be there by then
          var observer = new MutationObserver(function () {
            template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
            if (template) {
              observer.disconnect();
              _this2.render();
            } else {
              throw new Error('dom-bind requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return;
        }
        this.root = this._stampTemplate(template);
        this.$ = this.root.$;
        this.__children = [];
        for (var n = this.root.firstChild; n; n = n.nextSibling) {
          this.__children[this.__children.length] = n;
        }
        this._enableProperties();
      }
      this.__insertChildren();
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
    }
  }]);

  return DomBind;
}(domBindBase);

customElements.define('dom-bind', DomBind);

exports.DomBind = DomBind;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomIf = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _templatize = __webpack_require__(43);

var _debounce = __webpack_require__(27);

var _flush = __webpack_require__(42);

var _async = __webpack_require__(15);

var _path = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsey, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends Polymer.Element
 * @memberof Polymer
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */
var DomIf = function (_Element) {
  _inherits(DomIf, _Element);

  _createClass(DomIf, null, [{
    key: 'is',


    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'dom-if';
    }
  }, {
    key: 'template',
    get: function get() {
      return null;
    }
  }, {
    key: 'properties',
    get: function get() {

      return {

        /**
         * Fired whenever DOM is added or removed/hidden by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */

        /**
         * A boolean indicating whether this template should stamp.
         */
        if: {
          type: Boolean,
          observer: '__debounceRender'
        },

        /**
         * When true, elements will be removed from DOM and discarded when `if`
         * becomes false and re-created and added back to the DOM when `if`
         * becomes true.  By default, stamped elements will be hidden but left
         * in the DOM when `if` becomes false, which is generally results
         * in better performance.
         */
        restamp: {
          type: Boolean,
          observer: '__debounceRender'
        }

      };
    }
  }]);

  function DomIf() {
    _classCallCheck(this, DomIf);

    var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

    _this.__renderDebouncer = null;
    _this.__invalidProps = null;
    _this.__instance = null;
    _this._lastIf = false;
    _this.__ctor = null;
    return _this;
  }

  _createClass(DomIf, [{
    key: '__debounceRender',
    value: function __debounceRender() {
      var _this2 = this;

      // Render is async for 2 reasons:
      // 1. To eliminate dom creation trashing if user code thrashes `if` in the
      //    same turn. This was more common in 1.x where a compound computed
      //    property could result in the result changing multiple times, but is
      //    mitigated to a large extent by batched property processing in 2.x.
      // 2. To avoid double object propagation when a bag including values bound
      //    to the `if` property as well as one or more hostProps could enqueue
      //    the <dom-if> to flush before the <template>'s host property
      //    forwarding. In that scenario creating an instance would result in
      //    the host props being set once, and then the enqueued changes on the
      //    template would set properties a second time, potentially causing an
      //    object to be set to an instance more than once.  Creating the
      //    instance async from flushing data ensures this doesn't happen. If
      //    we wanted a sync option in the future, simply having <dom-if> flush
      //    (or clear) its template's pending host properties before creating
      //    the instance would also avoid the problem.
      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, _async.microTask, function () {
        return _this2.__render();
      });
      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
      if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
        this.__teardownInstance();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
      if (this.if) {
        this.__debounceRender();
      }
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */

  }, {
    key: 'render',
    value: function render() {
      (0, _flush.flush)();
    }
  }, {
    key: '__render',
    value: function __render() {
      if (this.if) {
        if (!this.__ensureInstance()) {
          // No template found yet
          return;
        }
        this._showHideChildren();
      } else if (this.restamp) {
        this.__teardownInstance();
      }
      if (!this.restamp && this.__instance) {
        this._showHideChildren();
      }
      if (this.if != this._lastIf) {
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        this._lastIf = this.if;
      }
    }
  }, {
    key: '__ensureInstance',
    value: function __ensureInstance() {
      var _this3 = this;

      var parentNode = this.parentNode;
      // Guard against element being detached while render was queued
      if (parentNode) {
        if (!this.__ctor) {
          var template = this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this3.querySelector('template')) {
                observer.disconnect();
                _this3.__render();
              } else {
                throw new Error('dom-if requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          this.__ctor = _templatize.Templatize.templatize(template, this, {
            // dom-if templatizer instances require `mutable: true`, as
            // `__syncHostProperties` relies on that behavior to sync objects
            mutableData: true,
            /**
             * @param {string} prop Property to forward
             * @param {*} value Value of property
             * @this {this}
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              if (this.__instance) {
                if (this.if) {
                  this.__instance.forwardHostProp(prop, value);
                } else {
                  // If we have an instance but are squelching host property
                  // forwarding due to if being false, note the invalidated
                  // properties so `__syncHostProperties` can sync them the next
                  // time `if` becomes true
                  this.__invalidProps = this.__invalidProps || Object.create(null);
                  this.__invalidProps[(0, _path.root)(prop)] = true;
                }
              }
            }
          });
        }
        if (!this.__instance) {
          this.__instance = new this.__ctor();
          parentNode.insertBefore(this.__instance.root, this);
        } else {
          this.__syncHostProperties();
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // Detect case where dom-if was re-attached in new position
            var lastChild = this.previousSibling;
            if (lastChild !== c$[c$.length - 1]) {
              for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                parentNode.insertBefore(n, this);
              }
            }
          }
        }
      }
      return true;
    }
  }, {
    key: '__syncHostProperties',
    value: function __syncHostProperties() {
      var props = this.__invalidProps;
      if (props) {
        for (var prop in props) {
          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
        }
        this.__invalidProps = null;
        this.__instance._flushProperties();
      }
    }
  }, {
    key: '__teardownInstance',
    value: function __teardownInstance() {
      if (this.__instance) {
        var c$ = this.__instance.children;
        if (c$ && c$.length) {
          // use first child parent, for case when dom-if may have been detached
          var parent = c$[0].parentNode;
          for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
            parent.removeChild(n);
          }
        }
        this.__instance = null;
        this.__invalidProps = null;
      }
    }
  }, {
    key: '_showHideChildren',
    value: function _showHideChildren() {
      var hidden = this.__hideTemplateChildren__ || !this.if;
      if (this.__instance) {
        this.__instance._showHideChildren(hidden);
      }
    }
  }]);

  return DomIf;
}(_polymerElement.Element);

customElements.define(DomIf.is, DomIf);

exports.DomIf = DomIf;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArraySelector = exports.ArraySelectorMixin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _mixin = __webpack_require__(13);

var _arraySplice = __webpack_require__(68);

var _elementMixin = __webpack_require__(33);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin Polymer.ElementMixin
 * @memberof Polymer
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */
var ArraySelectorMixin = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_ElementMixin}
   */
  var elementBase = (0, _elementMixin.ElementMixin)(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */

  var ArraySelectorMixin = function (_elementBase) {
    _inherits(ArraySelectorMixin, _elementBase);

    _createClass(ArraySelectorMixin, null, [{
      key: 'properties',
      get: function get() {

        return {

          /**
           * An array containing items from which selection will be made.
           */
          items: {
            type: Array
          },

          /**
           * When `true`, multiple items may be selected at once (in this case,
           * `selected` is an array of currently selected items).  When `false`,
           * only one item may be selected at a time.
           */
          multi: {
            type: Boolean,
            value: false
          },

          /**
           * When `multi` is true, this is an array that contains any selected.
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?(Object|Array<!Object>)}
           */
          selected: {
            type: Object,
            notify: true
          },

          /**
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?Object}
           */
          selectedItem: {
            type: Object,
            notify: true
          },

          /**
           * When `true`, calling `select` on an item that is already selected
           * will deselect the item.
           */
          toggle: {
            type: Boolean,
            value: false
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__updateSelection(multi, items.*)'];
      }
    }]);

    function ArraySelectorMixin() {
      _classCallCheck(this, ArraySelectorMixin);

      var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

      _this.__lastItems = null;
      _this.__lastMulti = null;
      _this.__selectedMap = null;
      return _this;
    }

    _createClass(ArraySelectorMixin, [{
      key: '__updateSelection',
      value: function __updateSelection(multi, itemsInfo) {
        var path = itemsInfo.path;
        if (path == 'items') {
          // Case 1 - items array changed, so diff against previous array and
          // deselect any removed items and adjust selected indices
          var newItems = itemsInfo.base || [];
          var lastItems = this.__lastItems;
          var lastMulti = this.__lastMulti;
          if (multi !== lastMulti) {
            this.clearSelection();
          }
          if (lastItems) {
            var splices = (0, _arraySplice.calculateSplices)(newItems, lastItems);
            this.__applySplices(splices);
          }
          this.__lastItems = newItems;
          this.__lastMulti = multi;
        } else if (itemsInfo.path == 'items.splices') {
          // Case 2 - got specific splice information describing the array mutation:
          // deselect any removed items and adjust selected indices
          this.__applySplices(itemsInfo.value.indexSplices);
        } else {
          // Case 3 - an array element was changed, so deselect the previous
          // item for that index if it was previously selected
          var part = path.slice('items.'.length);
          var idx = parseInt(part, 10);
          if (part.indexOf('.') < 0 && part == idx) {
            this.__deselectChangedIdx(idx);
          }
        }
      }
    }, {
      key: '__applySplices',
      value: function __applySplices(splices) {
        var _this2 = this;

        var selected = this.__selectedMap;
        // Adjust selected indices and mark removals

        var _loop = function _loop(i) {
          var s = splices[i];
          selected.forEach(function (idx, item) {
            if (idx < s.index) {
              // no change
            } else if (idx >= s.index + s.removed.length) {
              // adjust index
              selected.set(item, idx + s.addedCount - s.removed.length);
            } else {
              // remove index
              selected.set(item, -1);
            }
          });
          for (var j = 0; j < s.addedCount; j++) {
            var idx = s.index + j;
            if (selected.has(_this2.items[idx])) {
              selected.set(_this2.items[idx], idx);
            }
          }
        };

        for (var i = 0; i < splices.length; i++) {
          _loop(i);
        }
        // Update linked paths
        this.__updateLinks();
        // Remove selected items that were removed from the items array
        var sidx = 0;
        selected.forEach(function (idx, item) {
          if (idx < 0) {
            if (_this2.multi) {
              _this2.splice('selected', sidx, 1);
            } else {
              _this2.selected = _this2.selectedItem = null;
            }
            selected.delete(item);
          } else {
            sidx++;
          }
        });
      }
    }, {
      key: '__updateLinks',
      value: function __updateLinks() {
        var _this3 = this;

        this.__dataLinkedPaths = {};
        if (this.multi) {
          var sidx = 0;
          this.__selectedMap.forEach(function (idx) {
            if (idx >= 0) {
              _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
            }
          });
        } else {
          this.__selectedMap.forEach(function (idx) {
            _this3.linkPaths('selected', 'items.' + idx);
            _this3.linkPaths('selectedItem', 'items.' + idx);
          });
        }
      }

      /**
       * Clears the selection state.
       *
       */

    }, {
      key: 'clearSelection',
      value: function clearSelection() {
        // Unbind previous selection
        this.__dataLinkedPaths = {};
        // The selected map stores 3 pieces of information:
        // key: items array object
        // value: items array index
        // order: selected array index
        this.__selectedMap = new Map();
        // Initialize selection
        this.selected = this.multi ? [] : null;
        this.selectedItem = null;
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {*} item Item from `items` array to test
       * @return {boolean} Whether the item is selected
       */

    }, {
      key: 'isSelected',
      value: function isSelected(item) {
        return this.__selectedMap.has(item);
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {number} idx Index from `items` array to test
       * @return {boolean} Whether the item is selected
       */

    }, {
      key: 'isIndexSelected',
      value: function isIndexSelected(idx) {
        return this.isSelected(this.items[idx]);
      }
    }, {
      key: '__deselectChangedIdx',
      value: function __deselectChangedIdx(idx) {
        var _this4 = this;

        var sidx = this.__selectedIndexForItemIndex(idx);
        if (sidx >= 0) {
          var i = 0;
          this.__selectedMap.forEach(function (idx, item) {
            if (sidx == i++) {
              _this4.deselect(item);
            }
          });
        }
      }
    }, {
      key: '__selectedIndexForItemIndex',
      value: function __selectedIndexForItemIndex(idx) {
        var selected = this.__dataLinkedPaths['items.' + idx];
        if (selected) {
          return parseInt(selected.slice('selected.'.length), 10);
        }
      }

      /**
       * Deselects the given item if it is already selected.
       *
       * @param {*} item Item from `items` array to deselect
       */

    }, {
      key: 'deselect',
      value: function deselect(item) {
        var idx = this.__selectedMap.get(item);
        if (idx >= 0) {
          this.__selectedMap.delete(item);
          var sidx = void 0;
          if (this.multi) {
            sidx = this.__selectedIndexForItemIndex(idx);
          }
          this.__updateLinks();
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
        }
      }

      /**
       * Deselects the given index if it is already selected.
       *
       * @param {number} idx Index from `items` array to deselect
       */

    }, {
      key: 'deselectIndex',
      value: function deselectIndex(idx) {
        this.deselect(this.items[idx]);
      }

      /**
       * Selects the given item.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {*} item Item from `items` array to select
       */

    }, {
      key: 'select',
      value: function select(item) {
        this.selectIndex(this.items.indexOf(item));
      }

      /**
       * Selects the given index.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {number} idx Index from `items` array to select
       */

    }, {
      key: 'selectIndex',
      value: function selectIndex(idx) {
        var item = this.items[idx];
        if (!this.isSelected(item)) {
          if (!this.multi) {
            this.__selectedMap.clear();
          }
          this.__selectedMap.set(item, idx);
          this.__updateLinks();
          if (this.multi) {
            this.push('selected', item);
          } else {
            this.selected = this.selectedItem = item;
          }
        } else if (this.toggle) {
          this.deselectIndex(idx);
        }
      }
    }]);

    return ArraySelectorMixin;
  }(elementBase);

  return ArraySelectorMixin;
});

exports.ArraySelectorMixin = ArraySelectorMixin;

/**
 * @constructor
 * @extends {Polymer.Element}
 * @implements {Polymer_ArraySelectorMixin}
 */

var baseArraySelector = ArraySelectorMixin(_polymerElement.Element);

/**
 * Element implementing the `Polymer.ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *         <button on-click="toggleSelection">Select</button>
 *     </template>
 *
 *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
 *
 *     <div> Selected employees: </div>
 *     <template is="dom-repeat" items="{{selected}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * ```js
 * Polymer({
 *   is: 'employee-list',
 *   ready() {
 *     this.employees = [
 *         {first: 'Bob', last: 'Smith'},
 *         {first: 'Sally', last: 'Johnson'},
 *         ...
 *     ];
 *   },
 *   toggleSelection(e) {
 *     let item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * });
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin Polymer.ArraySelectorMixin
 * @memberof Polymer
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */

var ArraySelector = function (_baseArraySelector) {
  _inherits(ArraySelector, _baseArraySelector);

  function ArraySelector() {
    _classCallCheck(this, ArraySelector);

    return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
  }

  _createClass(ArraySelector, null, [{
    key: 'is',

    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'array-selector';
    }
  }]);

  return ArraySelector;
}(baseArraySelector);

customElements.define(ArraySelector.is, ArraySelector);
exports.ArraySelector = ArraySelector;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(105);

var _styleGather = __webpack_require__(58);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var attr = 'include';

var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 * ...
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */

var CustomStyle = function (_HTMLElement) {
  _inherits(CustomStyle, _HTMLElement);

  function CustomStyle() {
    _classCallCheck(this, CustomStyle);

    var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

    _this._style = null;
    CustomStyleInterface.addCustomStyle(_this);
    return _this;
  }
  /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */


  _createClass(CustomStyle, [{
    key: 'getStyle',
    value: function getStyle() {
      if (this._style) {
        return this._style;
      }
      var style = /** @type {HTMLStyleElement} */this.querySelector('style');
      if (!style) {
        return null;
      }
      this._style = style;
      var include = style.getAttribute(attr);
      if (include) {
        style.removeAttribute(attr);
        style.textContent = (0, _styleGather.cssFromModules)(include) + style.textContent;
      }
      return this._style;
    }
  }]);

  return CustomStyle;
}(HTMLElement);

window.customElements.define('custom-style', CustomStyle);
exports.CustomStyle = CustomStyle;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



var _customStyleInterface = __webpack_require__(64);

var _customStyleInterface2 = _interopRequireDefault(_customStyleInterface);

var _commonUtils = __webpack_require__(40);

var _styleSettings = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var customStyleInterface = new _customStyleInterface2.default();

if (!window.ShadyCSS) {
  window.ShadyCSS = {
    /**
     * @param {HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate: function prepareTemplate(template, elementName, elementExtends) {},
    // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    styleSubtree: function styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      (0, _commonUtils.updateNativeProperties)(element, properties);
    },


    /**
     * @param {Element} element
     */
    styleElement: function styleElement(element) {
      // eslint-disable-line no-unused-vars
      customStyleInterface.processStyles();
    },


    /**
     * @param {Object=} properties
     */
    styleDocument: function styleDocument(properties) {
      customStyleInterface.processStyles();
      (0, _commonUtils.updateNativeProperties)(document.body, properties);
    },


    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue: function getComputedStyleValue(element, property) {
      return (0, _commonUtils.getComputedStyleValue)(element, property);
    },

    nativeCss: _styleSettings.nativeCssVariables,
    nativeShadow: _styleSettings.nativeShadow
  };
}

window.ShadyCSS.CustomStyleInterface = customStyleInterface;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionalMutableDataBehavior = exports.MutableDataBehavior = undefined;

var _mutableData = __webpack_require__(29);

var mutablePropertyChange = void 0;
(
/** @suppress {missingProperties} */
function () {
  mutablePropertyChange = _mutableData.MutableData._mutablePropertyChange;
})();

var MutableDataBehavior = exports.MutableDataBehavior = {

  /**
   * Overrides `Polymer.PropertyEffects` to provide option for skipping
   * strict equality checking for Objects and Arrays.
   *
   * This method pulls the value to dirty check against from the `__dataTemp`
   * cache (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   */
  _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, true);
  }
};

var OptionalMutableDataBehavior = exports.OptionalMutableDataBehavior = {

  properties: {
    /**
     * Instance-level flag for configuring the dirty-checking strategy
     * for this element.  When true, Objects and Arrays will skip dirty
     * checking, otherwise strict equality checking will be used.
     */
    mutableData: Boolean
  },

  /**
   * Overrides `Polymer.PropertyEffects` to skip strict equality checking
   * for Objects and Arrays.
   *
   * Pulls the value to dirty check against from the `__dataTemp` cache
   * (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @this {this}
   * @protected
   */
  _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n\n      --layout: {\n        display: -ms-flexbox;\n        display: -webkit-flex;\n        display: flex;\n      };\n\n      --layout-inline: {\n        display: -ms-inline-flexbox;\n        display: -webkit-inline-flex;\n        display: inline-flex;\n      };\n\n      --layout-horizontal: {\n        @apply --layout;\n\n        -ms-flex-direction: row;\n        -webkit-flex-direction: row;\n        flex-direction: row;\n      };\n\n      --layout-horizontal-reverse: {\n        @apply --layout;\n\n        -ms-flex-direction: row-reverse;\n        -webkit-flex-direction: row-reverse;\n        flex-direction: row-reverse;\n      };\n\n      --layout-vertical: {\n        @apply --layout;\n\n        -ms-flex-direction: column;\n        -webkit-flex-direction: column;\n        flex-direction: column;\n      };\n\n      --layout-vertical-reverse: {\n        @apply --layout;\n\n        -ms-flex-direction: column-reverse;\n        -webkit-flex-direction: column-reverse;\n        flex-direction: column-reverse;\n      };\n\n      --layout-wrap: {\n        -ms-flex-wrap: wrap;\n        -webkit-flex-wrap: wrap;\n        flex-wrap: wrap;\n      };\n\n      --layout-wrap-reverse: {\n        -ms-flex-wrap: wrap-reverse;\n        -webkit-flex-wrap: wrap-reverse;\n        flex-wrap: wrap-reverse;\n      };\n\n      --layout-flex-auto: {\n        -ms-flex: 1 1 auto;\n        -webkit-flex: 1 1 auto;\n        flex: 1 1 auto;\n      };\n\n      --layout-flex-none: {\n        -ms-flex: none;\n        -webkit-flex: none;\n        flex: none;\n      };\n\n      --layout-flex: {\n        -ms-flex: 1 1 0.000000001px;\n        -webkit-flex: 1;\n        flex: 1;\n        -webkit-flex-basis: 0.000000001px;\n        flex-basis: 0.000000001px;\n      };\n\n      --layout-flex-2: {\n        -ms-flex: 2;\n        -webkit-flex: 2;\n        flex: 2;\n      };\n\n      --layout-flex-3: {\n        -ms-flex: 3;\n        -webkit-flex: 3;\n        flex: 3;\n      };\n\n      --layout-flex-4: {\n        -ms-flex: 4;\n        -webkit-flex: 4;\n        flex: 4;\n      };\n\n      --layout-flex-5: {\n        -ms-flex: 5;\n        -webkit-flex: 5;\n        flex: 5;\n      };\n\n      --layout-flex-6: {\n        -ms-flex: 6;\n        -webkit-flex: 6;\n        flex: 6;\n      };\n\n      --layout-flex-7: {\n        -ms-flex: 7;\n        -webkit-flex: 7;\n        flex: 7;\n      };\n\n      --layout-flex-8: {\n        -ms-flex: 8;\n        -webkit-flex: 8;\n        flex: 8;\n      };\n\n      --layout-flex-9: {\n        -ms-flex: 9;\n        -webkit-flex: 9;\n        flex: 9;\n      };\n\n      --layout-flex-10: {\n        -ms-flex: 10;\n        -webkit-flex: 10;\n        flex: 10;\n      };\n\n      --layout-flex-11: {\n        -ms-flex: 11;\n        -webkit-flex: 11;\n        flex: 11;\n      };\n\n      --layout-flex-12: {\n        -ms-flex: 12;\n        -webkit-flex: 12;\n        flex: 12;\n      };\n\n      /* alignment in cross axis */\n\n      --layout-start: {\n        -ms-flex-align: start;\n        -webkit-align-items: flex-start;\n        align-items: flex-start;\n      };\n\n      --layout-center: {\n        -ms-flex-align: center;\n        -webkit-align-items: center;\n        align-items: center;\n      };\n\n      --layout-end: {\n        -ms-flex-align: end;\n        -webkit-align-items: flex-end;\n        align-items: flex-end;\n      };\n\n      --layout-baseline: {\n        -ms-flex-align: baseline;\n        -webkit-align-items: baseline;\n        align-items: baseline;\n      };\n\n      /* alignment in main axis */\n\n      --layout-start-justified: {\n        -ms-flex-pack: start;\n        -webkit-justify-content: flex-start;\n        justify-content: flex-start;\n      };\n\n      --layout-center-justified: {\n        -ms-flex-pack: center;\n        -webkit-justify-content: center;\n        justify-content: center;\n      };\n\n      --layout-end-justified: {\n        -ms-flex-pack: end;\n        -webkit-justify-content: flex-end;\n        justify-content: flex-end;\n      };\n\n      --layout-around-justified: {\n        -ms-flex-pack: distribute;\n        -webkit-justify-content: space-around;\n        justify-content: space-around;\n      };\n\n      --layout-justified: {\n        -ms-flex-pack: justify;\n        -webkit-justify-content: space-between;\n        justify-content: space-between;\n      };\n\n      --layout-center-center: {\n        @apply --layout-center;\n        @apply --layout-center-justified;\n      };\n\n      /* self alignment */\n\n      --layout-self-start: {\n        -ms-align-self: flex-start;\n        -webkit-align-self: flex-start;\n        align-self: flex-start;\n      };\n\n      --layout-self-center: {\n        -ms-align-self: center;\n        -webkit-align-self: center;\n        align-self: center;\n      };\n\n      --layout-self-end: {\n        -ms-align-self: flex-end;\n        -webkit-align-self: flex-end;\n        align-self: flex-end;\n      };\n\n      --layout-self-stretch: {\n        -ms-align-self: stretch;\n        -webkit-align-self: stretch;\n        align-self: stretch;\n      };\n\n      --layout-self-baseline: {\n        -ms-align-self: baseline;\n        -webkit-align-self: baseline;\n        align-self: baseline;\n      };\n\n      /* multi-line alignment in main axis */\n\n      --layout-start-aligned: {\n        -ms-flex-line-pack: start;  /* IE10 */\n        -ms-align-content: flex-start;\n        -webkit-align-content: flex-start;\n        align-content: flex-start;\n      };\n\n      --layout-end-aligned: {\n        -ms-flex-line-pack: end;  /* IE10 */\n        -ms-align-content: flex-end;\n        -webkit-align-content: flex-end;\n        align-content: flex-end;\n      };\n\n      --layout-center-aligned: {\n        -ms-flex-line-pack: center;  /* IE10 */\n        -ms-align-content: center;\n        -webkit-align-content: center;\n        align-content: center;\n      };\n\n      --layout-between-aligned: {\n        -ms-flex-line-pack: justify;  /* IE10 */\n        -ms-align-content: space-between;\n        -webkit-align-content: space-between;\n        align-content: space-between;\n      };\n\n      --layout-around-aligned: {\n        -ms-flex-line-pack: distribute;  /* IE10 */\n        -ms-align-content: space-around;\n        -webkit-align-content: space-around;\n        align-content: space-around;\n      };\n\n      /*******************************\n                Other Layout\n      *******************************/\n\n      --layout-block: {\n        display: block;\n      };\n\n      --layout-invisible: {\n        visibility: hidden !important;\n      };\n\n      --layout-relative: {\n        position: relative;\n      };\n\n      --layout-fit: {\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n      --layout-scroll: {\n        -webkit-overflow-scrolling: touch;\n        overflow: auto;\n      };\n\n      --layout-fullbleed: {\n        margin: 0;\n        height: 100vh;\n      };\n\n      /* fixed position */\n\n      --layout-fixed-top: {\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n      };\n\n      --layout-fixed-right: {\n        position: fixed;\n        top: 0;\n        right: 0;\n        bottom: 0;\n      };\n\n      --layout-fixed-bottom: {\n        position: fixed;\n        right: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n      --layout-fixed-left: {\n        position: fixed;\n        top: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n    }\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

__webpack_require__(69);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n      /*\n       * You can use these generic variables in your elements for easy theming.\n       * For example, if all your elements use `--primary-text-color` as its main\n       * color, then switching from a light to a dark theme is just a matter of\n       * changing the value of `--primary-text-color` in your application.\n       */\n      --primary-text-color: var(--light-theme-text-color);\n      --primary-background-color: var(--light-theme-background-color);\n      --secondary-text-color: var(--light-theme-secondary-color);\n      --disabled-text-color: var(--light-theme-disabled-color);\n      --divider-color: var(--light-theme-divider-color);\n      --error-color: var(--paper-deep-orange-a700);\n\n      /*\n       * Primary and accent colors. Also see color.html for more colors.\n       */\n      --primary-color: var(--paper-indigo-500);\n      --light-primary-color: var(--paper-indigo-100);\n      --dark-primary-color: var(--paper-indigo-700);\n\n      --accent-color: var(--paper-pink-a200);\n      --light-accent-color: var(--paper-pink-a100);\n      --dark-accent-color: var(--paper-pink-a400);\n\n\n      /*\n       * Material Design Light background theme\n       */\n      --light-theme-background-color: #ffffff;\n      --light-theme-base-color: #000000;\n      --light-theme-text-color: var(--paper-grey-900);\n      --light-theme-secondary-color: #737373;  /* for secondary text and icons */\n      --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */\n      --light-theme-divider-color: #dbdbdb;\n\n      /*\n       * Material Design Dark background theme\n       */\n      --dark-theme-background-color: var(--paper-grey-900);\n      --dark-theme-base-color: #ffffff;\n      --dark-theme-text-color: #ffffff;\n      --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */\n      --dark-theme-disabled-color: #646464;  /* disabled/hint text */\n      --dark-theme-divider-color: #3c3c3c;\n\n      /*\n       * Deprecated values because of their confusing names.\n       */\n      --text-primary-color: var(--dark-theme-text-color);\n      --default-primary-color: var(--primary-color);\n    }\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperCheckedElementBehavior = exports.PaperCheckedElementBehaviorImpl = undefined;

__webpack_require__(6);

var _ironCheckedElementBehavior = __webpack_require__(110);

var _paperInkyFocusBehavior = __webpack_require__(114);

var _paperRippleBehavior = __webpack_require__(45);

var PaperCheckedElementBehaviorImpl = exports.PaperCheckedElementBehaviorImpl = {
  /**
   * Synchronizes the element's checked state with its ripple effect.
   */
  _checkedChanged: function _checkedChanged() {
    _ironCheckedElementBehavior.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
    if (this.hasRipple()) {
      if (this.checked) {
        this._ripple.setAttribute('checked', '');
      } else {
        this._ripple.removeAttribute('checked');
      }
    }
  },

  /**
   * Synchronizes the element's `active` and `checked` state.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    _paperRippleBehavior.PaperRippleBehavior._buttonStateChanged.call(this);
    if (this.disabled) {
      return;
    }
    if (this.isAttached) {
      this.checked = this.active;
    }
  }
};

var PaperCheckedElementBehavior = exports.PaperCheckedElementBehavior = [_paperInkyFocusBehavior.PaperInkyFocusBehavior, _ironCheckedElementBehavior.IronCheckedElementBehavior, PaperCheckedElementBehaviorImpl];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronCheckedElementBehavior = exports.IronCheckedElementBehaviorImpl = undefined;

__webpack_require__(6);

var _ironValidatableBehavior = __webpack_require__(111);

var _ironFormElementBehavior = __webpack_require__(113);

var IronCheckedElementBehaviorImpl = exports.IronCheckedElementBehaviorImpl = {

  properties: {
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */

    /**
     * Gets or sets the state, `true` is checked and `false` is unchecked.
     */
    checked: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      notify: true,
      observer: '_checkedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: true,
      reflectToAttribute: true
    },

    /* Overriden from Polymer.IronFormElementBehavior */
    value: {
      type: String,
      value: 'on',
      observer: '_valueChanged'
    }
  },

  observers: ['_requiredChanged(required)'],

  created: function created() {
    // Used by `iron-form` to handle the case that an element with this behavior
    // doesn't have a role of 'checkbox' or 'radio', but should still only be
    // included when the form is serialized if `this.checked === true`.
    this._hasIronCheckedElementBehavior = true;
  },

  /**
   * Returns false if the element is required and not checked, and true otherwise.
   * @param {*=} _value Ignored.
   * @return {boolean} true if `required` is false or if `checked` is true.
   */
  _getValidity: function _getValidity(_value) {
    return this.disabled || !this.required || this.checked;
  },

  /**
   * Update the aria-required label when `required` is changed.
   */
  _requiredChanged: function _requiredChanged() {
    if (this.required) {
      this.setAttribute('aria-required', 'true');
    } else {
      this.removeAttribute('aria-required');
    }
  },

  /**
   * Fire `iron-changed` when the checked state changes.
   */
  _checkedChanged: function _checkedChanged() {
    this.active = this.checked;
    this.fire('iron-change');
  },

  /**
   * Reset value to 'on' if it is set to `undefined`.
   */
  _valueChanged: function _valueChanged() {
    if (this.value === undefined || this.value === null) {
      this.value = 'on';
    }
  }
};

var IronCheckedElementBehavior = exports.IronCheckedElementBehavior = [_ironFormElementBehavior.IronFormElementBehavior, _ironValidatableBehavior.IronValidatableBehavior, IronCheckedElementBehaviorImpl];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronValidatableBehavior = exports.IronValidatableBehaviorMeta = undefined;

__webpack_require__(6);

var _ironMeta = __webpack_require__(112);

var IronValidatableBehaviorMeta = exports.IronValidatableBehaviorMeta = null;

var IronValidatableBehavior = exports.IronValidatableBehavior = {

  properties: {
    /**
     * Name of the validator to use.
     */
    validator: {
      type: String
    },

    /**
     * True if the last call to `validate` is invalid.
     */
    invalid: {
      notify: true,
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_invalidChanged'
    }
  },

  registered: function registered() {
    exports.IronValidatableBehaviorMeta = IronValidatableBehaviorMeta = new _ironMeta.IronMeta({ type: 'validator' });
  },

  _invalidChanged: function _invalidChanged() {
    if (this.invalid) {
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('aria-invalid');
    }
  },

  /* Recompute this every time it's needed, because we don't know if the
   * underlying IronValidatableBehaviorMeta has changed. */
  get _validator() {
    return IronValidatableBehaviorMeta && IronValidatableBehaviorMeta.byKey(this.validator);
  },

  /**
   * @return {boolean} True if the validator `validator` exists.
   */
  hasValidator: function hasValidator() {
    return this._validator != null;
  },

  /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.
    * @param {Object} value Deprecated: The value to be validated. By default,
   * it is passed to the validator's `validate()` function, if a validator is set.
   * If this argument is not specified, then the element's `value` property
   * is used, if it exists.
   * @return {boolean} True if `value` is valid.
   */
  validate: function validate(value) {
    // If this is an element that also has a value property, and there was
    // no explicit value argument passed, use the element's property instead.
    if (value === undefined && this.value !== undefined) this.invalid = !this._getValidity(this.value);else this.invalid = !this._getValidity(value);
    return !this.invalid;
  },

  /**
   * Returns true if `value` is valid.  By default, it is passed
   * to the validator's `validate()` function, if a validator is set. You
   * should override this method if you want to implement custom validity
   * logic for your element.
   *
   * @param {Object} value The value to be validated.
   * @return {boolean} True if `value` is valid.
   */

  _getValidity: function _getValidity(value) {
    if (this.hasValidator()) {
      return this._validator.validate(value);
    }
    return true;
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronMeta = undefined;

__webpack_require__(6);

var _polymerFn = __webpack_require__(28);

/**
 * @constructor
 * @param {{type: (string|null), key: (string|null), value: *}} options
 */
function IronMeta(options) {
  this.type = options && options.type || 'default';
  this.key = options && options.key;
  if ('value' in options) {
    this.value = options.value;
  }
}

IronMeta.types = {};

IronMeta.prototype = {
  get value() {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      return IronMeta.types[type] && IronMeta.types[type][key];
    }
  },

  set value(value) {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      type = IronMeta.types[type] = IronMeta.types[type] || {};
      if (value == null) {
        delete type[key];
      } else {
        type[key] = value;
      }
    }
  },

  get list() {
    var type = this.type;

    if (type) {
      return Object.keys(IronMeta.types[this.type]).map(function (key) {
        return metaDatas[this.type][key];
      }, this);
    }
  },

  byKey: function byKey(key) {
    this.key = key;
    return this.value;
  }
};

exports.IronMeta = IronMeta;


var metaDatas = IronMeta.types;

(0, _polymerFn.Polymer)({

  is: 'iron-meta',

  properties: {

    /**
     * The type of meta-data.  All meta-data of the same type is stored
     * together.
     * @type {string}
     */
    type: {
      type: String,
      value: 'default'
    },

    /**
     * The key used to store `value` under the `type` namespace.
     * @type {?string}
     */
    key: {
      type: String
    },

    /**
     * The meta-data to store or retrieve.
     * @type {*}
     */
    value: {
      type: String,
      notify: true
    },

    /**
     * If true, `value` is set to the iron-meta instance itself.
     */
    self: {
      type: Boolean,
      observer: '_selfChanged'
    },

    __meta: {
      type: Boolean,
      computed: '__computeMeta(type, key, value)'
    }
  },

  hostAttributes: {
    hidden: true
  },

  __computeMeta: function __computeMeta(type, key, value) {
    var meta = new IronMeta({
      type: type,
      key: key
    });

    if (value !== undefined && value !== meta.value) {
      meta.value = value;
    } else if (this.value !== meta.value) {
      this.value = meta.value;
    }

    return meta;
  },

  get list() {
    return this.__meta && this.__meta.list;
  },

  _selfChanged: function _selfChanged(self) {
    if (self) {
      this.value = this;
    }
  },

  /**
   * Retrieves meta data value by key.
   *
   * @method byKey
   * @param {string} key The key of the meta-data to be returned.
   * @return {*}
   */
  byKey: function byKey(key) {
    return new IronMeta({
      type: this.type,
      key: key
    }).value;
  }
});

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronFormElementBehavior = undefined;

__webpack_require__(6);

var _polymerElement = __webpack_require__(11);

var IronFormElementBehavior = exports.IronFormElementBehavior = {

  properties: {
    /**
     * Fired when the element is added to an `iron-form`.
     *
     * @event iron-form-element-register
     */

    /**
     * Fired when the element is removed from an `iron-form`.
     *
     * @event iron-form-element-unregister
     */

    /**
     * The name of this element.
     */
    name: {
      type: String
    },

    /**
     * The value for this element.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to mark the input as required. If used in a form, a
     * custom element that uses this behavior should also use
     * Polymer.IronValidatableBehavior and define a custom validation method.
     * Otherwise, a `required` element will always be considered valid.
     * It's also strongly recommended to provide a visual style for the element
     * when its value is invalid.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The form that the element is registered to.
     */
    _parentForm: {
      type: Object
    }
  },

  attached: _polymerElement.Element ? null : function () {
    // Note: the iron-form that this element belongs to will set this
    // element's _parentForm property when handling this event.
    this.fire('iron-form-element-register');
  },

  detached: _polymerElement.Element ? null : function () {
    if (this._parentForm) {
      this._parentForm.fire('iron-form-element-unregister', { target: this });
    }
  }

};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperInkyFocusBehavior = exports.PaperInkyFocusBehaviorImpl = undefined;

__webpack_require__(6);

var _ironButtonState = __webpack_require__(70);

var _paperRippleBehavior = __webpack_require__(45);

var _ironControlState = __webpack_require__(72);

var PaperInkyFocusBehaviorImpl = exports.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = _paperRippleBehavior.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

var PaperInkyFocusBehavior = exports.PaperInkyFocusBehavior = [_ironButtonState.IronButtonState, _ironControlState.IronControlState, _paperRippleBehavior.PaperRippleBehavior, PaperInkyFocusBehaviorImpl];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(6);

var _ironA11yKeysBehavior = __webpack_require__(71);

var _polymerDom = __webpack_require__(17);

var _polymerFn = __webpack_require__(28);

var Utility = {
  distance: function distance(x1, y1, x2, y2) {
    var xDelta = x1 - x2;
    var yDelta = y1 - y2;

    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },

  now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;

  this.size = Math.max(this.width, this.height);
}

ElementMetrics.prototype = {
  get boundingRect() {
    return this.element.getBoundingClientRect();
  },

  furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);

    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;

  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  (0, _polymerDom.dom)(this.waveContainer).appendChild(this.wave);

  this.resetInteractionState();
}

Ripple.MAX_RADIUS = 300;

Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },

  get center() {
    return this.element.center;
  },

  get mouseDownElapsed() {
    var elapsed;

    if (!this.mouseDownStart) {
      return 0;
    }

    elapsed = Utility.now() - this.mouseDownStart;

    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }

    return elapsed;
  },

  get mouseUpElapsed() {
    return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
  },

  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },

  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },

  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },

  get initialOpacity() {
    return this.element.initialOpacity;
  },

  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },

  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));

    return Math.abs(size);
  },

  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }

    return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
  },

  get outerOpacity() {
    // Linear increase in background opacity, capped at the opacity
    // of the wavefront (waveOpacity).
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;

    return Math.max(0, Math.min(outerOpacity, waveOpacity));
  },

  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isAnimationComplete() {
    return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
  },

  get translationFraction() {
    return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
  },

  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }

    return this.xStart;
  },

  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }

    return this.yStart;
  },

  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },

  resetInteractionState: function resetInteractionState() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;

    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;

    this.containerMetrics = new ElementMetrics(this.element);
  },

  draw: function draw() {
    var scale;
    var translateString;
    var dx;
    var dy;

    this.wave.style.opacity = this.opacity;

    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - this.containerMetrics.width / 2;
    dy = this.yNow - this.containerMetrics.height / 2;

    // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
    // https://bugs.webkit.org/show_bug.cgi?id=98538
    this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },

  /** @param {Event=} event */
  downAction: function downAction(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;

    this.resetInteractionState();
    this.mouseDownStart = Utility.now();

    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    } else {
      this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
      this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
    }

    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    }

    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

    this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },

  /** @param {Event=} event */
  upAction: function upAction(event) {
    if (!this.isMouseDown) {
      return;
    }

    this.mouseUpStart = Utility.now();
  },

  remove: function remove() {
    (0, _polymerDom.dom)(this.waveContainer.parentNode).removeChild(this.waveContainer);
  }
};

(0, _polymerFn.Polymer)({
  _template: '\n    <style>\n      :host {\n        display: block;\n        position: absolute;\n        border-radius: inherit;\n        overflow: hidden;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n\n        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,\n         * creating a node (with a position:absolute) in the middle of an event\n         * handler "interrupts" that event handler (which happens when the\n         * ripple is created on demand) */\n        pointer-events: none;\n      }\n\n      :host([animating]) {\n        /* This resolves a rendering issue in Chrome (as of 40) where the\n           ripple is not properly clipped by its parent (which may have\n           rounded corners). See: http://jsbin.com/temexa/4\n\n           Note: We only apply this style conditionally. Otherwise, the browser\n           will create a new compositing layer for every ripple element on the\n           page, and that would be bad. */\n        -webkit-transform: translate(0, 0);\n        transform: translate3d(0, 0, 0);\n      }\n\n      #background,\n      #waves,\n      .wave-container,\n      .wave {\n        pointer-events: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      #background,\n      .wave {\n        opacity: 0;\n      }\n\n      #waves,\n      .wave {\n        overflow: hidden;\n      }\n\n      .wave-container,\n      .wave {\n        border-radius: 50%;\n      }\n\n      :host(.circle) #background,\n      :host(.circle) #waves {\n        border-radius: 50%;\n      }\n\n      :host(.circle) .wave-container {\n        overflow: hidden;\n      }\n    </style>\n\n    <div id="background"></div>\n    <div id="waves"></div>\n',

  is: 'paper-ripple',

  behaviors: [_ironA11yKeysBehavior.IronA11yKeysBehavior],

  properties: {
    /**
     * The initial opacity set on the wave.
     *
     * @attribute initialOpacity
     * @type number
     * @default 0.25
     */
    initialOpacity: {
      type: Number,
      value: 0.25
    },

    /**
     * How fast (opacity per second) the wave fades out.
     *
     * @attribute opacityDecayVelocity
     * @type number
     * @default 0.8
     */
    opacityDecayVelocity: {
      type: Number,
      value: 0.8
    },

    /**
     * If true, ripples will exhibit a gravitational pull towards
     * the center of their container as they fade away.
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    recenters: {
      type: Boolean,
      value: false
    },

    /**
     * If true, ripples will center inside its container
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    center: {
      type: Boolean,
      value: false
    },

    /**
     * A list of the visual ripples.
     *
     * @attribute ripples
     * @type Array
     * @default []
     */
    ripples: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    /**
     * True when there are visible ripples animating within the
     * element.
     */
    animating: {
      type: Boolean,
      readOnly: true,
      reflectToAttribute: true,
      value: false
    },

    /**
     * If true, the ripple will remain in the "down" state until `holdDown`
     * is set to false again.
     */
    holdDown: {
      type: Boolean,
      value: false,
      observer: '_holdDownChanged'
    },

    /**
     * If true, the ripple will not generate a ripple effect
     * via pointer interaction.
     * Calling ripple's imperative api like `simulatedRipple` will
     * still generate the ripple effect.
     */
    noink: {
      type: Boolean,
      value: false
    },

    _animating: {
      type: Boolean
    },

    _boundAnimate: {
      type: Function,
      value: function value() {
        return this.animate.bind(this);
      }
    }
  },

  get target() {
    return this.keyEventTarget;
  },

  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },

  attached: function attached() {
    // Set up a11yKeysBehavior to listen to key events on the target,
    // so that space and enter activate the ripple even if the target doesn't
    // handle key events. The key handlers deal with `noink` themselves.
    if (this.parentNode.nodeType == 11) {
      // DOCUMENT_FRAGMENT_NODE
      this.keyEventTarget = (0, _polymerDom.dom)(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = this.parentNode;
    }
    var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },

  detached: function detached() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },

  get shouldKeepAnimating() {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }

    return false;
  },

  simulatedRipple: function simulatedRipple() {
    this.downAction(null);

    // Please see polymer/polymer#1305
    this.async(function () {
      this.upAction();
    }, 1);
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiDownAction: function uiDownAction(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  downAction: function downAction(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }

    var ripple = this.addRipple();

    ripple.downAction(event);

    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiUpAction: function uiUpAction(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  upAction: function upAction(event) {
    if (this.holdDown) {
      return;
    }

    this.ripples.forEach(function (ripple) {
      ripple.upAction(event);
    });

    this._animating = true;
    this.animate();
  },

  onAnimationComplete: function onAnimationComplete() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire('transitionend');
  },

  addRipple: function addRipple() {
    var ripple = new Ripple(this);

    (0, _polymerDom.dom)(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);

    this._setAnimating(true);

    return ripple;
  },

  removeRipple: function removeRipple(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);

    if (rippleIndex < 0) {
      return;
    }

    this.ripples.splice(rippleIndex, 1);

    ripple.remove();

    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },

  /**
   * This conflicts with Element#antimate().
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
   * @suppress {checkTypes}
   */
  animate: function animate() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;

    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];

      ripple.draw();

      this.$.background.style.opacity = ripple.outerOpacity;

      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }

    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },

  _onEnterKeydown: function _onEnterKeydown() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },

  _onSpaceKeydown: function _onSpaceKeydown() {
    this.uiDownAction();
  },

  _onSpaceKeyup: function _onSpaceKeyup() {
    this.uiUpAction();
  },

  // note: holdDown does not respect noink since it can be a focus based
  // effect.
  _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.
   @event transitionend
  @param {{node: Object}} detail Contains the animated node.
  */
});

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.addDoubleTapListener = addDoubleTapListener;
exports.removeDoubleTapListener = removeDoubleTapListener;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(76);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = Browser.msPointer ? 'MSPointerDown' : Browser.pointer ? 'pointerdown' : 'touchstart',
    _touchend = Browser.msPointer ? 'MSPointerUp' : Browser.pointer ? 'pointerup' : 'touchend',
    _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last,
	    touch,
	    doubleTap = false,
	    delay = 250;

	function onTouchStart(e) {
		var count;

		if (Browser.pointer) {
			if (!Browser.edge || e.pointerType === 'mouse') {
				return;
			}
			count = _DomEvent._pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) {
			return;
		}

		var now = Date.now(),
		    delta = now - (last || now);

		touch = e.touches ? e.touches[0] : e;
		doubleTap = delta > 0 && delta <= delay;
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch.cancelBubble) {
			if (Browser.pointer) {
				if (!Browser.edge || e.pointerType === 'mouse') {
					return;
				}
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
				    prop,
				    i;

				for (i in touch) {
					prop = touch[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
				}
				touch = newTouch;
			}
			touch.type = 'dblclick';
			handler(touch);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, false);
	obj.addEventListener(_touchend, onTouchEnd, false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
	    touchend = obj[_pre + _touchend + id],
	    dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, false);
	obj.removeEventListener(_touchend, touchend, false);
	if (!Browser.edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.MarkerDrag = undefined;

var _Handler = __webpack_require__(14);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Draggable = __webpack_require__(49);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = exports.MarkerDrag = _Handler.Handler.extend({
	initialize: function initialize(marker) {
		this._marker = marker;
	},

	addHooks: function addHooks() {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new _Draggable.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function removeHooks() {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function moved() {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function _onDragStart() {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker.closePopup().fire('movestart').fire('dragstart');
	},

	_onDrag: function _onDrag(e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker.fire('move', e).fire('drag', e);
	},

	_onDragEnd: function _onDragEnd(e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker.fire('moveend').fire('dragend', e);
	}
});

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "2273e3d8ad9264b7daa5bdbf8e6b47f8.png";

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "44a526eed258222515aa21eaffd14a96.png";

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletMap = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _flattenedNodesObserver = __webpack_require__(67);

var _map = __webpack_require__(79);

var _ControlAttribution = __webpack_require__(80);

__webpack_require__(81);

__webpack_require__(82);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Need these side effects


var LeafletMap = exports.LeafletMap = function (_PolymerElement) {
  _inherits(LeafletMap, _PolymerElement);

  _createClass(LeafletMap, null, [{
    key: 'template',
    get: function get() {
      return '\n      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />\n\n      <!-- FIXME: Figure out Shadow DOM so this doesn\'t have to be included here -->\n      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css" media="screen">\n      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css" media="screen">\n\n      <style>\n        #map {\n          width: 100%;\n          height: 100%;\n          @apply (--leaflet-map-component)\n        }\n      </style>\n\n      <div id="map">\n        <slot></slot>\n      </div>\n    ';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          notify: true
        },
        latitude: {
          type: Number
        },
        longitude: {
          type: Number
        },
        zoom: {
          type: Number
        },
        minZoom: {
          type: Number
        },
        maxZoom: {
          type: Number
        },
        zoomControl: {
          type: Boolean,
          value: false
        },
        attributionPrefix: {
          type: String
        },
        _childrenObserver: Object
      };
    }
  }]);

  function LeafletMap() {
    _classCallCheck(this, LeafletMap);

    return _possibleConstructorReturn(this, (LeafletMap.__proto__ || Object.getPrototypeOf(LeafletMap)).call(this));
  }

  _createClass(LeafletMap, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletMap.prototype.__proto__ || Object.getPrototypeOf(LeafletMap.prototype), 'connectedCallback', this).call(this);

      this.map = new _map.Map(this.$.map, {
        center: [this.latitude, this.longitude],
        zoom: this.zoom,
        zoomControl: this.zoomControl,
        inertiaDeceleration: 3000,
        inertiaMaxSpeed: 3000,
        attributionControl: false,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        tapTolerance: 40
      });

      if (this.attributionPrefix) {
        var attrControl = new _ControlAttribution.Attribution({ prefix: this.attributionPrefix });
        this.map.addControl(attrControl);
      }

      // L.marker([this.latitude, this.longitude]).addTo(this.map);

      var slot = this.shadowRoot.querySelector('slot');
      this._childrenObserver = new _flattenedNodesObserver.FlattenedNodesObserver(slot, this._bindDependencies.bind(this));
    }

    /* Shitty way of passing value to children */

  }, {
    key: '_bindDependencies',
    value: function _bindDependencies(_ref) {
      var _this2 = this;

      var addedNodes = _ref.addedNodes;

      addedNodes.forEach(function (n) {
        n.map = _this2.map;
      });
    }
  }]);

  return LeafletMap;
}(_polymerElement.Element);

customElements.define('leaflet-map', LeafletMap);

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.BoxZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = exports.BoxZoom = _Handler.Handler.extend({
	initialize: function initialize(map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function addHooks() {
		DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function moved() {
		return this._moved;
	},

	_destroy: function _destroy() {
		DomUtil.remove(this._pane);
		delete this._pane;
	},

	_resetState: function _resetState() {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function _clearDeferredResetState() {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function _onMouseDown(e) {
		if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
			return false;
		}

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		DomUtil.disableTextSelection();
		DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		DomEvent.on(document, {
			contextmenu: DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function _onMouseMove(e) {
		if (!this._moved) {
			this._moved = true;

			this._box = DomUtil.create('div', 'leaflet-zoom-box', this._container);
			DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new _Bounds.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function _finish() {
		if (this._moved) {
			DomUtil.remove(this._box);
			DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		DomUtil.enableTextSelection();
		DomUtil.enableImageDrag();

		DomEvent.off(document, {
			contextmenu: DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function _onMouseUp(e) {
		if (e.which !== 1 && e.button !== 1) {
			return;
		}

		this._finish();

		if (!this._moved) {
			return;
		}
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(Util.bind(this._resetState, this), 0);

		var bounds = new _LatLngBounds.LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

		this._map.fitBounds(bounds).fire('boxzoomend', { boxZoomBounds: bounds });
	},

	_onKeyDown: function _onKeyDown(e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
_Map.Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DoubleClickZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

_Map.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = exports.DoubleClickZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function removeHooks() {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function _onDoubleClick(e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
_Map.Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Drag = undefined;

var _Map = __webpack_require__(7);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Handler = __webpack_require__(14);

var _Draggable = __webpack_require__(49);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = exports.Drag = _Handler.Handler.extend({
	addHooks: function addHooks() {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new _Draggable.Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function removeHooks() {
		DomUtil.removeClass(this._map._container, 'leaflet-grab');
		DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function moved() {
		return this._draggable && this._draggable._moved;
	},

	moving: function moving() {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function _onDragStart() {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = (0, _LatLngBounds.toLatLngBounds)(this._map.options.maxBounds);

			this._offsetLimit = (0, _Bounds.toBounds)(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map.fire('movestart').fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function _onDrag(e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map.fire('move', e).fire('drag', e);
	},

	_onZoomEnd: function _onZoomEnd() {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function _viscousLimit(value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function _onPreDragLimit() {
		if (!this._viscosity || !this._offsetLimit) {
			return;
		}

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) {
			offset.x = this._viscousLimit(offset.x, limit.min.x);
		}
		if (offset.y < limit.min.y) {
			offset.y = this._viscousLimit(offset.y, limit.min.y);
		}
		if (offset.x > limit.max.x) {
			offset.x = this._viscousLimit(offset.x, limit.max.x);
		}
		if (offset.y > limit.max.y) {
			offset.y = this._viscousLimit(offset.y, limit.max.y);
		}

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function _onPreDragWrap() {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function _onDragEnd(e) {
		var map = this._map,
		    options = map.options,
		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');
		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,
			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),
			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');
			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
_Map.Map.addInitHook('addHandler', 'dragging', Drag);

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Keyboard = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var _Point = __webpack_require__(3);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
_Map.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = exports.Keyboard = _Handler.Handler.extend({

	keyCodes: {
		left: [37],
		right: [39],
		down: [40],
		up: [38],
		zoomIn: [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function initialize(map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function addHooks() {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		(0, _DomEvent.on)(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function removeHooks() {
		this._removeHooks();

		(0, _DomEvent.off)(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function _onMouseDown() {
		if (this._focused) {
			return;
		}

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function _onFocus() {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function _onBlur() {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function _setPanDelta(panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i,
		    len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function _setZoomDelta(zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i,
		    len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function _addHooks() {
		(0, _DomEvent.on)(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function _removeHooks() {
		(0, _DomEvent.off)(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function _onKeyDown(e) {
		if (e.altKey || e.ctrlKey || e.metaKey) {
			return;
		}

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) {
				return;
			}

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = (0, _Point.toPoint)(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
		} else if (key === 27 && map._popup) {
			map.closePopup();
		} else {
			return;
		}

		(0, _DomEvent.stop)(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
_Map.Map.addInitHook('addHandler', 'keyboard', Keyboard);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ScrollWheelZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = exports.ScrollWheelZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function _onWheelScroll(e) {
		var delta = DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(Util.bind(this._performZoom, this), left);

		DomEvent.stop(e);
	},

	_performZoom: function _performZoom() {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) {
			return;
		}

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
_Map.Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Tap = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = exports.Tap = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function _onDown(e) {
		if (!e.touches) {
			return;
		}

		DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new _Point.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(Util.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function _onUp(e) {
		clearTimeout(this._holdTimeout);

		DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function _isTapValid() {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function _onMove(e) {
		var first = e.touches[0];
		this._newPos = new _Point.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function _simulateEvent(type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (Browser.touch && !Browser.pointer) {
	_Map.Map.addInitHook('addHandler', 'tap', Tap);
}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TouchZoom = undefined;

var _Map = __webpack_require__(7);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: Browser.touch && !Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = exports.TouchZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function removeHooks() {
		DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function _onTouchStart(e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
			return;
		}

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		DomEvent.on(document, 'touchmove', this._onTouchMove, this);
		DomEvent.on(document, 'touchend', this._onTouchEnd, this);

		DomEvent.preventDefault(e);
	},

	_onTouchMove: function _onTouchMove(e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) {
			return;
		}

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) {
				return;
			}
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) {
				return;
			}
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		Util.cancelAnimFrame(this._animRequest);

		var moveFn = Util.bind(map._move, map, this._center, this._zoom, { pinch: true, round: false });
		this._animRequest = Util.requestAnimFrame(moveFn, this, true);

		DomEvent.preventDefault(e);
	},

	_onTouchEnd: function _onTouchEnd() {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		Util.cancelAnimFrame(this._animRequest);

		DomEvent.off(document, 'touchmove', this._onTouchMove);
		DomEvent.off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
_Map.Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.layers = exports.Layers = undefined;

var _Control = __webpack_require__(22);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = exports.Layers = _Control.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function sortFunction(layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
		}
	},

	initialize: function initialize(baseLayers, overlays, options) {
		Util.setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function onAdd(map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function addTo(map) {
		_Control.Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function onRemove() {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function addBaseLayer(layer, name) {
		this._addLayer(layer, name);
		return this._map ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function addOverlay(layer, name) {
		this._addLayer(layer, name, true);
		return this._map ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function removeLayer(layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(Util.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return this._map ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function expand() {
		DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function collapse() {
		DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function _initLayout() {
		var className = 'leaflet-control-layers',
		    container = this._container = DomUtil.create('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		DomEvent.disableClickPropagation(container);
		DomEvent.disableScrollPropagation(container);

		var form = this._form = DomUtil.create('form', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!Browser.android) {
				DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = DomUtil.create('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (Browser.touch) {
			DomEvent.on(link, 'click', DomEvent.stop);
			DomEvent.on(link, 'click', this.expand, this);
		} else {
			DomEvent.on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = DomUtil.create('div', className + '-base', form);
		this._separator = DomUtil.create('div', className + '-separator', form);
		this._overlaysList = DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function _getLayer(id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && Util.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function _addLayer(layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(Util.bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function _update() {
		if (!this._container) {
			return this;
		}

		DomUtil.empty(this._baseLayersList);
		DomUtil.empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent,
		    overlaysPresent,
		    i,
		    obj,
		    baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function _onLayerChange(e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(Util.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function _createRadioElement(name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function _addItem(obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = Util.stamp(obj.layer);

		DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function _onInputClick() {
		var inputs = this._layerControlInputs,
		    input,
		    layer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function _checkDisabledLayers() {
		var inputs = this._layerControlInputs,
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
		}
	},

	_expandIfNotCollapsed: function _expandIfNotCollapsed() {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function _expand() {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function _collapse() {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});

// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = exports.layers = function layers(baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.zoom = exports.Zoom = undefined;

var _Control = __webpack_require__(22);

var _Map = __webpack_require__(7);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = exports.Zoom = _Control.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function onAdd(map) {
		var zoomName = 'leaflet-control-zoom',
		    container = DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function onRemove(map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function disable() {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function enable() {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function _zoomIn(e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function _zoomOut(e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function _createButton(html, title, className, container, fn) {
		var link = DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
   * Will force screen readers like VoiceOver to read this as "Zoom in - button"
   */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		DomEvent.disableClickPropagation(link);
		DomEvent.on(link, 'click', DomEvent.stop);
		DomEvent.on(link, 'click', fn, this);
		DomEvent.on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function _updateDisabled() {
		var map = this._map,
		    className = 'leaflet-disabled';

		DomUtil.removeClass(this._zoomInButton, className);
		DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
_Map.Map.mergeOptions({
	zoomControl: true
});

_Map.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = exports.zoom = function zoom(options) {
	return new Zoom(options);
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.scale = exports.Scale = undefined;

var _Control = __webpack_require__(22);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = exports.Scale = _Control.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function onAdd(map) {
		var className = 'leaflet-control-scale',
		    container = DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function onRemove(map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function _addScales(options, className, container) {
		if (options.metric) {
			this._mScale = DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = DomUtil.create('div', className, container);
		}
	},

	_update: function _update() {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function _updateScales(maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function _updateMetric(maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function _updateImperial(maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles,
		    miles,
		    feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function _updateScale(scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function _getRoundNum(num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = exports.scale = function scale(options) {
	return new Scale(options);
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.VideoOverlay = undefined;
exports.videoOverlay = videoOverlay;

var _ImageOverlay = __webpack_require__(50);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.VideoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = exports.VideoOverlay = _ImageOverlay.ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true
	},

	_initImage: function _initImage() {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : DomUtil.create('video');

		vid.class = vid.class || '';
		vid.class += 'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : '');

		vid.onselectstart = Util.falseFn;
		vid.onmousemove = Util.falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = Util.bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			return;
		}

		if (!Util.isArray(this._url)) {
			this._url = [this._url];
		}

		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = DomUtil.create('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});

// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.popup = exports.Popup = undefined;

var _DivOverlay = __webpack_require__(51);

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Point = __webpack_require__(3);

var _Map = __webpack_require__(7);

var _Layer = __webpack_require__(12);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Path = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */

// @namespace Popup
var Popup = exports.Popup = _DivOverlay.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function openOn(map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function onAdd(map) {
		_DivOverlay.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', { popup: this });

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', { popup: this }, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof _Path.Path)) {
				this._source.on('preclick', DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function onRemove(map) {
		_DivOverlay.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', { popup: this });

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', { popup: this }, true);
			if (!(this._source instanceof _Path.Path)) {
				this._source.off('preclick', DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function getEvents() {
		var events = _DivOverlay.DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function _close() {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function _initLayout() {
		var prefix = 'leaflet-popup',
		    container = this._container = DomUtil.create('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');

		var wrapper = this._wrapper = DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = DomUtil.create('div', prefix + '-content', wrapper);

		DomEvent.disableClickPropagation(wrapper);
		DomEvent.disableScrollPropagation(this._contentNode);
		DomEvent.on(wrapper, 'contextmenu', DomEvent.stopPropagation);

		this._tipContainer = DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = DomUtil.create('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function _updateLayout() {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = width + 1 + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			DomUtil.addClass(container, scrolledClass);
		} else {
			DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function _animateZoom(e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function _adjustPan() {
		if (!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress) {
			return;
		}

		var map = this._map,
		    marginBottom = parseInt(DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new _Point.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = (0, _Point.toPoint)(this.options.autoPanPadding),
		    paddingTL = (0, _Point.toPoint)(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = (0, _Point.toPoint)(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) {
			// right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) {
			// left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) {
			// bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) {
			// top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map.fire('autopanstart').panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function _onCloseButtonClick(e) {
		this._close();
		DomEvent.stop(e);
	},

	_getAnchor: function _getAnchor() {
		// Where should we anchor the popup on the source layer?
		return (0, _Point.toPoint)(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = exports.popup = function popup(options, source) {
	return new Popup(options, source);
};

/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
_Map.Map.mergeOptions({
	closePopupOnClick: true
});

// @namespace Map
// @section Methods for Layers and Controls
_Map.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function openPopup(popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function closePopup(popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
_Layer.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function bindPopup(content, options) {

		if (content instanceof Popup) {
			Util.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function unbindPopup() {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function openPopup(layer, latlng) {
		if (!(layer instanceof _Layer.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof _FeatureGroup.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function closePopup() {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function togglePopup(target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function isPopupOpen() {
		return this._popup ? this._popup.isOpen() : false;
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function setPopupContent(content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function getPopup() {
		return this._popup;
	},

	_openPopup: function _openPopup(e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof _Path.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function _movePopup(e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function _onKeyPress(e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.tooltip = exports.Tooltip = undefined;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DivOverlay = __webpack_require__(51);

var _Point = __webpack_require__(3);

var _Map = __webpack_require__(7);

var _Layer = __webpack_require__(12);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */

// @namespace Tooltip
var Tooltip = exports.Tooltip = _DivOverlay.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function onAdd(map) {
		_DivOverlay.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', { tooltip: this });

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', { tooltip: this }, true);
		}
	},

	onRemove: function onRemove(map) {
		_DivOverlay.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', { tooltip: this });

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', { tooltip: this }, true);
		}
	},

	getEvents: function getEvents() {
		var events = _DivOverlay.DivOverlay.prototype.getEvents.call(this);

		if (Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function _close() {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function _initLayout() {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = DomUtil.create('div', className);
	},

	_updateLayout: function _updateLayout() {},

	_adjustPan: function _adjustPan() {},

	_setPosition: function _setPosition(pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = (0, _Point.toPoint)(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add((0, _Point.toPoint)(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add((0, _Point.toPoint)(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		DomUtil.removeClass(container, 'leaflet-tooltip-right');
		DomUtil.removeClass(container, 'leaflet-tooltip-left');
		DomUtil.removeClass(container, 'leaflet-tooltip-top');
		DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		DomUtil.setPosition(container, pos);
	},

	_updatePosition: function _updatePosition() {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function _animateZoom(e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function _getAnchor() {
		// Where should we anchor the tooltip on the source layer?
		return (0, _Point.toPoint)(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = exports.tooltip = function tooltip(options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
_Map.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function openTooltip(tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function closeTooltip(tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
_Layer.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function bindTooltip(content, options) {

		if (content instanceof Tooltip) {
			Util.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);
		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function unbindTooltip() {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function _initTooltipInteractions(remove) {
		if (!remove && this._tooltipHandlersAdded) {
			return;
		}
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		};
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function openTooltip(layer, latlng) {
		if (!(layer instanceof _Layer.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof _FeatureGroup.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function closeTooltip() {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function toggleTooltip(target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function isTooltipOpen() {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function setTooltipContent(content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function getTooltip() {
		return this._tooltip;
	},

	_openTooltip: function _openTooltip(e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function _moveTooltip(e) {
		var latlng = e.latlng,
		    containerPoint,
		    layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.marker = exports.Marker = exports.divIcon = exports.DivIcon = exports.Icon = exports.icon = undefined;

var _Icon = __webpack_require__(30);

Object.defineProperty(exports, 'icon', {
  enumerable: true,
  get: function get() {
    return _Icon.icon;
  }
});

var _DivIcon = __webpack_require__(135);

Object.defineProperty(exports, 'DivIcon', {
  enumerable: true,
  get: function get() {
    return _DivIcon.DivIcon;
  }
});
Object.defineProperty(exports, 'divIcon', {
  enumerable: true,
  get: function get() {
    return _DivIcon.divIcon;
  }
});

var _Marker = __webpack_require__(48);

Object.defineProperty(exports, 'Marker', {
  enumerable: true,
  get: function get() {
    return _Marker.Marker;
  }
});
Object.defineProperty(exports, 'marker', {
  enumerable: true,
  get: function get() {
    return _Marker.marker;
  }
});

var _Icon2 = __webpack_require__(78);

_Icon.Icon.Default = _Icon2.IconDefault;
exports.Icon = _Icon.Icon;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DivIcon = undefined;
exports.divIcon = divIcon;

var _Icon = __webpack_require__(30);

var _Point = __webpack_require__(3);

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = exports.DivIcon = _Icon.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function createIcon(oldIcon) {
		var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = (0, _Point.toPoint)(options.bgPos);
			div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function createShadow() {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tileLayer = exports.TileLayer = exports.gridLayer = exports.GridLayer = undefined;

var _GridLayer = __webpack_require__(83);

Object.defineProperty(exports, 'GridLayer', {
  enumerable: true,
  get: function get() {
    return _GridLayer.GridLayer;
  }
});
Object.defineProperty(exports, 'gridLayer', {
  enumerable: true,
  get: function get() {
    return _GridLayer.gridLayer;
  }
});

var _TileLayer = __webpack_require__(52);

var _TileLayer2 = __webpack_require__(53);

_TileLayer.TileLayer.WMS = _TileLayer2.TileLayerWMS;
_TileLayer.tileLayer.wms = _TileLayer2.tileLayerWMS;
exports.TileLayer = _TileLayer.TileLayer;
exports.tileLayer = _TileLayer.tileLayer;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectangle = exports.Rectangle = exports.polygon = exports.Polygon = exports.polyline = exports.Polyline = exports.circle = exports.Circle = exports.circleMarker = exports.CircleMarker = exports.Path = exports.svg = exports.SVG = exports.canvas = exports.Canvas = exports.Renderer = undefined;

var _Renderer = __webpack_require__(31);

Object.defineProperty(exports, 'Renderer', {
  enumerable: true,
  get: function get() {
    return _Renderer.Renderer;
  }
});

var _Canvas = __webpack_require__(84);

Object.defineProperty(exports, 'Canvas', {
  enumerable: true,
  get: function get() {
    return _Canvas.Canvas;
  }
});
Object.defineProperty(exports, 'canvas', {
  enumerable: true,
  get: function get() {
    return _Canvas.canvas;
  }
});

var _Path = __webpack_require__(23);

Object.defineProperty(exports, 'Path', {
  enumerable: true,
  get: function get() {
    return _Path.Path;
  }
});

var _CircleMarker = __webpack_require__(32);

Object.defineProperty(exports, 'CircleMarker', {
  enumerable: true,
  get: function get() {
    return _CircleMarker.CircleMarker;
  }
});
Object.defineProperty(exports, 'circleMarker', {
  enumerable: true,
  get: function get() {
    return _CircleMarker.circleMarker;
  }
});

var _Circle = __webpack_require__(85);

Object.defineProperty(exports, 'Circle', {
  enumerable: true,
  get: function get() {
    return _Circle.Circle;
  }
});
Object.defineProperty(exports, 'circle', {
  enumerable: true,
  get: function get() {
    return _Circle.circle;
  }
});

var _Polyline = __webpack_require__(56);

Object.defineProperty(exports, 'Polyline', {
  enumerable: true,
  get: function get() {
    return _Polyline.Polyline;
  }
});
Object.defineProperty(exports, 'polyline', {
  enumerable: true,
  get: function get() {
    return _Polyline.polyline;
  }
});

var _Polygon = __webpack_require__(57);

Object.defineProperty(exports, 'Polygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.Polygon;
  }
});
Object.defineProperty(exports, 'polygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.polygon;
  }
});

var _Rectangle = __webpack_require__(138);

Object.defineProperty(exports, 'Rectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.Rectangle;
  }
});
Object.defineProperty(exports, 'rectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.rectangle;
  }
});

var _SVG = __webpack_require__(87);

__webpack_require__(140);

_SVG.SVG.create = _SVG.create;
_SVG.SVG.pointsToPath = _SVG.pointsToPath;
exports.SVG = _SVG.SVG;
exports.svg = _SVG.svg;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rectangle = undefined;
exports.rectangle = rectangle;

var _Polygon = __webpack_require__(57);

var _LatLngBounds = __webpack_require__(10);

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */

var Rectangle = exports.Rectangle = _Polygon.Polygon.extend({
  initialize: function initialize(latLngBounds, options) {
    _Polygon.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  },

  // @method setBounds(latLngBounds: LatLngBounds): this
  // Redraws the rectangle with the passed bounds.
  setBounds: function setBounds(latLngBounds) {
    return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  },

  _boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {
    latLngBounds = (0, _LatLngBounds.toLatLngBounds)(latLngBounds);
    return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
  }
});

// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
  return new Rectangle(latLngBounds, options);
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.vmlMixin = exports.vmlCreate = undefined;

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Renderer = __webpack_require__(31);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

var vmlCreate = exports.vmlCreate = function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
}();

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = exports.vmlMixin = {

	_initContainer: function _initContainer() {
		this._container = DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function _update() {
		if (this._map._animatingZoom) {
			return;
		}
		_Renderer.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function _initPath(layer) {
		var container = layer._container = vmlCreate('shape');

		DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[Util.stamp(layer)] = layer;
	},

	_addPath: function _addPath(layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function _removePath(layer) {
		var container = layer._container;
		DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[Util.stamp(layer)];
	},

	_updateStyle: function _updateStyle(layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = Util.isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;
		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;
		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function _updateCircle(layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
	},

	_setPath: function _setPath(layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function _bringToFront(layer) {
		DomUtil.toFront(layer._container);
	},

	_bringToBack: function _bringToBack(layer) {
		DomUtil.toBack(layer._container);
	}
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Map = __webpack_require__(7);

var _Canvas = __webpack_require__(84);

var _SVG = __webpack_require__(87);

_Map.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function getRenderer(layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = this.options.preferCanvas && (0, _Canvas.canvas)() || (0, _SVG.svg)();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function _getPaneRenderer(name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = _SVG.SVG && (0, _SVG.svg)({ pane: name }) || _Canvas.Canvas && (0, _Canvas.canvas)({ pane: name });
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletWMSGroup = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _domRepeat = __webpack_require__(44);

var _leafletWms = __webpack_require__(142);

__webpack_require__(143);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletWMSGroup = exports.LeafletWMSGroup = function (_PolymerElement) {
  _inherits(LeafletWMSGroup, _PolymerElement);

  _createClass(LeafletWMSGroup, null, [{
    key: 'template',
    get: function get() {
      // return `
      //   <template is="dom-repeat" items="{{subLayers}}">
      //     <leaflet-wms-layer wms-source="[[wmsSource]]" layer="[[item]]"></leaflet-wms-layer>
      //   </template>
      // `;
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },

        source: {
          type: String,
          observer: '_sourceChange',
          reflectToAttribute: true
        },
        layers: {
          type: Array,
          observer: '_layersChange',
          reflectToAttribute: true
        },

        transparent: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        },
        format: {
          type: String,
          value: 'image/png',
          reflectToAttribute: true
        },
        identify: Boolean,
        infoFormat: {
          type: String,
          value: 'text/html'
        },
        minZoom: Number,
        maxZoom: Number,
        attribution: String,

        wmsSource: Object,
        subLayers: {
          type: Array,
          value: []
        }
      };
    }
  }]);

  function LeafletWMSGroup() {
    _classCallCheck(this, LeafletWMSGroup);

    return _possibleConstructorReturn(this, (LeafletWMSGroup.__proto__ || Object.getPrototypeOf(LeafletWMSGroup)).call(this));
  }

  _createClass(LeafletWMSGroup, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletWMSGroup.prototype.__proto__ || Object.getPrototypeOf(LeafletWMSGroup.prototype), 'connectedCallback', this).call(this);

      this._wmsOptions = {
        transparent: this.transparent,
        format: this.format,
        identify: this.identify,
        info_format: this.infoFormat,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        attribution: this.attribution
      };
    }
  }, {
    key: '_sourceChange',
    value: function _sourceChange() {
      if (this.wmsSource) this.wmsSource.removeFrom(this.map);

      this.wmsSource = new _leafletWms.wms.Source(this.source, this._wmsOptions);
      if (this.map) this.wmsSource.addTo(this.map);
    }
  }, {
    key: '_layersChange',
    value: function _layersChange(newValue, oldValue) {
      this.wmsSource.replaceAllSubLayers(this.layers);
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      this.wmsSource.addTo(this.map); // FIXME: there could be a race condition here for this.map
    }
  }]);

  return LeafletWMSGroup;
}(_polymerElement.Element);

customElements.define('leaflet-wms-group', LeafletWMSGroup);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wms = undefined;

var _Layer = __webpack_require__(12);

var _ImageOverlay = __webpack_require__(50);

var _TileLayerWMS = __webpack_require__(53);

var _CRSEPSG = __webpack_require__(54);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var wms = exports.wms = {};

/*
 * wms.Source
 * The Source object manages a single WMS connection.  Multiple "layers" can be
 * created with the getLayer function, but a single request will be sent for
 * each image update.  Can be used in non-tiled "overlay" mode (default), or
 * tiled mode, via an internal wms.Overlay or wms.TileLayer, respectively.
 */
/*!
 * leaflet.wms.js
 * A collection of Leaflet utilities for working with Web Mapping services.
 * (c) 2014-2016, Houston Engineering, Inc.
 * MIT License
 */

wms.Source = _Layer.Layer.extend({
    'options': {
        'untiled': true,
        'identify': true
    },

    'initialize': function initialize(url, options) {
        Util.setOptions(this, options);
        if (this.options.tiled) {
            this.options.untiled = false;
        }
        this._url = url;
        this._subLayers = {};
        this._overlay = this.createOverlay(this.options.untiled);
    },

    'createOverlay': function createOverlay(untiled) {
        // Create overlay with all options other than untiled & identify
        var overlayOptions = {};
        for (var opt in this.options) {
            if (opt != 'untiled' && opt != 'identify') {
                overlayOptions[opt] = this.options[opt];
            }
        }
        if (untiled) {
            return wms.overlay(this._url, overlayOptions);
        } else {
            return wms.tileLayer(this._url, overlayOptions);
        }
    },

    'onAdd': function onAdd() {
        this.refreshOverlay();
    },

    'onRemove': function onRemove() {
        if (this._map) this._overlay.removeFrom(this._map);
    },

    'getEvents': function getEvents() {
        if (this.options.identify) {
            return { 'click': this.identify };
        } else {
            return {};
        }
    },

    'setOpacity': function setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._overlay) {
            this._overlay.setOpacity(opacity);
        }
    },

    'bringToBack': function bringToBack() {
        this.options.isBack = true;
        if (this._overlay) {
            this._overlay.bringToBack();
        }
    },

    'bringToFront': function bringToFront() {
        this.options.isBack = false;
        if (this._overlay) {
            this._overlay.bringToFront();
        }
    },

    'getLayer': function getLayer(name) {
        return wms.layer(this, name);
    },

    'getSubLayers': function getSubLayers() {
        return this._subLayers;
    },

    'addSubLayer': function addSubLayer(name) {
        this._subLayers[name] = true;
        this.refreshOverlay();
    },

    'removeSubLayer': function removeSubLayer(name) {
        delete this._subLayers[name];
        this.refreshOverlay();
    },

    /* Efficient way to swap out all sub layers */
    'replaceAllSubLayers': function replaceAllSubLayers(newSubLayers) {
        this._subLayers = {};
        for (var i = 0; i < newSubLayers.length; i++) {
            this._subLayers[newSubLayers[i]] = true;
        }this.refreshOverlay();
    },

    'refreshOverlay': function refreshOverlay() {
        var subLayers = Object.keys(this._subLayers).join(",");
        if (!this._map) {
            return;
        }
        if (!subLayers) {
            this._overlay.remove();
        } else {
            this._overlay.setParams({ 'layers': subLayers });
            this._overlay.addTo(this._map);
        }
    },

    'identify': function identify(evt) {
        // Identify map features in response to map clicks. To customize this
        // behavior, create a class extending wms.Source and override one or
        // more of the following hook functions.

        var layers = this.getIdentifyLayers();
        if (!layers.length) {
            return;
        }
        this.getFeatureInfo(evt.containerPoint, evt.latlng, layers, this.showFeatureInfo);
    },

    'getFeatureInfo': function getFeatureInfo(point, latlng, layers, callback) {
        // Request WMS GetFeatureInfo and call callback with results
        // (split from identify() to faciliate use outside of map events)
        var params = this.getFeatureInfoParams(point, layers),
            url = this._url + Util.getParamString(params, this._url);

        this.showWaiting();
        this.ajax(url, done);

        function done(result) {
            this.hideWaiting();
            var text = this.parseFeatureInfo(result, url);
            callback.call(this, latlng, text);
        }
    },

    'ajax': function ajax(url, callback) {
        wms.ajax.call(this, url, callback);
    },

    'getIdentifyLayers': function getIdentifyLayers() {
        // Hook to determine which layers to identify
        if (this.options.identifyLayers) return this.options.identifyLayers;
        return Object.keys(this._subLayers);
    },

    'getFeatureInfoParams': function getFeatureInfoParams(point, layers) {
        // Hook to generate parameters for WMS service GetFeatureInfo request
        var wmsParams, overlay;
        if (this.options.untiled) {
            // Use existing overlay
            wmsParams = this._overlay.wmsParams;
        } else {
            // Create overlay instance to leverage updateWmsParams
            overlay = this.createOverlay(true);
            overlay.updateWmsParams(this._map);
            wmsParams = overlay.wmsParams;
            wmsParams.layers = layers.join(',');
        }
        var infoParams = {
            'request': 'GetFeatureInfo',
            'query_layers': layers.join(','),
            'X': Math.round(point.x),
            'Y': Math.round(point.y)
        };
        return Util.extend({}, wmsParams, infoParams);
    },

    'parseFeatureInfo': function parseFeatureInfo(result, url) {
        // Hook to handle parsing AJAX response
        if (result == "error") {
            // AJAX failed, possibly due to CORS issues.
            // Try loading content in <iframe>.
            result = "<iframe src='" + url + "' style='border:none'>";
        }
        return result;
    },

    'showFeatureInfo': function showFeatureInfo(latlng, info) {
        // Hook to handle displaying parsed AJAX response to the user
        if (!this._map) {
            return;
        }
        this._map.openPopup(info, latlng);
    },

    'showWaiting': function showWaiting() {
        // Hook to customize AJAX wait animation
        if (!this._map) return;
        this._map._container.style.cursor = "progress";
    },

    'hideWaiting': function hideWaiting() {
        // Hook to remove AJAX wait animation
        if (!this._map) return;
        this._map._container.style.cursor = "default";
    }
});

wms.source = function (url, options) {
    return new wms.Source(url, options);
};

/*
 * Layer
 * Leaflet "layer" with all actual rendering handled via an underlying Source
 * object.  Can be called directly with a URL to automatically create or reuse
 * an existing Source.  Note that the auto-source feature doesn't work well in
 * multi-map environments; so for best results, create a Source first and use
 * getLayer() to retrieve wms.Layer instances.
 */

wms.Layer = _Layer.Layer.extend({
    'initialize': function initialize(source, layerName, options) {
        Util.setOptions(this, options);
        if (!source.addSubLayer) {
            // Assume source is a URL
            source = wms.getSourceForUrl(source, options);
        }
        this._source = source;
        this._name = layerName;
    },
    'onAdd': function onAdd() {
        if (!this._source._map) this._source.addTo(this._map);
        this._source.addSubLayer(this._name);
    },
    'onRemove': function onRemove() {
        this._source.removeSubLayer(this._name);
    },
    'setOpacity': function setOpacity(opacity) {
        this._source.setOpacity(opacity);
    },
    'bringToBack': function bringToBack() {
        this._source.bringToBack();
    },
    'bringToFront': function bringToFront() {
        this._source.bringToFront();
    }
});

wms.layer = function (source, options) {
    return new wms.Layer(source, options);
};

// Cache of sources for use with wms.Layer auto-source option
wms.sources = {};
wms.getSourceForUrl = function (url, options) {
    if (!wms.sources[url]) {
        wms.sources[url] = wms.source(url, options);
    }
    return wms.sources[url];
};

// Copy tiled WMS layer from leaflet core, in case we need to subclass it later
wms.TileLayer = _TileLayerWMS.TileLayerWMS;
wms.tileLayer = _TileLayerWMS.tileLayerWMS;

/*
 * wms.Overlay:
 * "Single Tile" WMS image overlay that updates with map changes.
 * Portions of wms.Overlay are directly extracted from L.TileLayer.WMS.
 * See Leaflet license.
 */
wms.Overlay = _Layer.Layer.extend({
    'defaultWmsParams': {
        'service': 'WMS',
        'request': 'GetMap',
        'version': '1.1.1',
        'layers': '',
        'styles': '',
        'format': 'image/jpeg',
        'transparent': false
    },

    'options': {
        'crs': null,
        'uppercase': false,
        'attribution': '',
        'opacity': 1,
        'isBack': false,
        'minZoom': 0,
        'maxZoom': 18
    },

    'initialize': function initialize(url, options) {
        this._url = url;

        // Move WMS parameters to params object
        var params = {},
            opts = {};
        for (var opt in options) {
            if (opt in this.options) {
                opts[opt] = options[opt];
            } else {
                params[opt] = options[opt];
            }
        }
        Util.setOptions(this, opts);
        this.wmsParams = Util.extend({}, this.defaultWmsParams, params);
    },

    'setParams': function setParams(params) {
        Util.extend(this.wmsParams, params);
        this.update();
    },

    'getAttribution': function getAttribution() {
        return this.options.attribution;
    },

    'onAdd': function onAdd() {
        this.update();
    },

    'onRemove': function onRemove(map) {
        if (this._currentOverlay) {
            map.removeLayer(this._currentOverlay);
            delete this._currentOverlay;
        }
        if (this._currentUrl) {
            delete this._currentUrl;
        }
    },

    'getEvents': function getEvents() {
        return {
            'moveend': this.update
        };
    },

    'update': function update() {
        if (!this._map) {
            return;
        }
        // Determine image URL and whether it has changed since last update
        this.updateWmsParams();
        var url = this.getImageUrl();
        if (this._currentUrl == url) {
            return;
        }
        this._currentUrl = url;

        // Keep current image overlay in place until new one loads
        // (inspired by esri.leaflet)
        var bounds = this._map.getBounds();
        var overlay = new _ImageOverlay.ImageOverlay(url, bounds, { 'opacity': 0 });
        overlay.addTo(this._map);
        overlay.once('load', _swap, this);
        function _swap() {
            if (!this._map) {
                return;
            }
            if (overlay._url != this._currentUrl) {
                this._map.removeLayer(overlay);
                return;
            } else if (this._currentOverlay) {
                this._map.removeLayer(this._currentOverlay);
            }
            this._currentOverlay = overlay;
            overlay.setOpacity(this.options.opacity ? this.options.opacity : 1);
            if (this.options.isBack === true) {
                overlay.bringToBack();
            }
            if (this.options.isBack === false) {
                overlay.bringToFront();
            }
        }
        if (this._map.getZoom() < this.options.minZoom || this._map.getZoom() > this.options.maxZoom) {
            this._map.removeLayer(overlay);
        }
    },

    'setOpacity': function setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._currentOverlay) {
            this._currentOverlay.setOpacity(opacity);
        }
    },

    'bringToBack': function bringToBack() {
        this.options.isBack = true;
        if (this._currentOverlay) {
            this._currentOverlay.bringToBack();
        }
    },

    'bringToFront': function bringToFront() {
        this.options.isBack = false;
        if (this._currentOverlay) {
            this._currentOverlay.bringToFront();
        }
    },

    // See L.TileLayer.WMS: onAdd() & getTileUrl()
    'updateWmsParams': function updateWmsParams(map) {
        if (!map) {
            map = this._map;
        }
        // Compute WMS options
        var bounds = map.getBounds();
        var size = map.getSize();
        var wmsVersion = parseFloat(this.wmsParams.version);
        var crs = this.options.crs || map.options.crs;
        var projectionKey = wmsVersion >= 1.3 ? 'crs' : 'srs';
        var nw = crs.project(bounds.getNorthWest());
        var se = crs.project(bounds.getSouthEast());

        // Assemble WMS parameter string
        var params = {
            'width': size.x,
            'height': size.y
        };
        params[projectionKey] = crs.code;
        params.bbox = (wmsVersion >= 1.3 && crs.code === _CRSEPSG.EPSG4326.code ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(',');

        Util.extend(this.wmsParams, params);
    },

    'getImageUrl': function getImageUrl() {
        var uppercase = this.options.uppercase || false;
        var pstr = Util.getParamString(this.wmsParams, this._url, uppercase);
        return this._url + pstr;
    }
});

wms.overlay = function (url, options) {
    return new wms.Overlay(url, options);
};

// Simple AJAX helper (since we can't assume jQuery etc. are present)
wms.ajax = function (url, callback) {
    var context = this,
        request = new XMLHttpRequest();
    request.onreadystatechange = change;
    request.open('GET', url);
    request.send();

    function change() {
        if (request.readyState === 4) {
            if (request.status === 200) {
                callback.call(context, request.responseText);
            } else {
                callback.call(context, "error");
            }
        }
    }
};

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletWMSLayer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletWMSLayer = exports.LeafletWMSLayer = function (_PolymerElement) {
  _inherits(LeafletWMSLayer, _PolymerElement);

  _createClass(LeafletWMSLayer, null, [{
    key: 'properties',
    get: function get() {
      return {
        wmsSource: Object,
        layer: {
          type: String,
          reflectToAttribute: true
        }
      };
    }
  }]);

  function LeafletWMSLayer() {
    _classCallCheck(this, LeafletWMSLayer);

    return _possibleConstructorReturn(this, (LeafletWMSLayer.__proto__ || Object.getPrototypeOf(LeafletWMSLayer)).call(this));
  }

  _createClass(LeafletWMSLayer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletWMSLayer.prototype.__proto__ || Object.getPrototypeOf(LeafletWMSLayer.prototype), 'connectedCallback', this).call(this);

      if (this.wmsSource === undefined || this.layer === '') return;
      this.wmsSource.addSubLayer(this.layer);
    }
  }]);

  return LeafletWMSLayer;
}(_polymerElement.Element);

customElements.define('leaflet-wms-layer', LeafletWMSLayer);

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletTileLayer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _TileLayer = __webpack_require__(52);

var _TileLayerWMS = __webpack_require__(53);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletTileLayer = exports.LeafletTileLayer = function (_PolymerElement) {
  _inherits(LeafletTileLayer, _PolymerElement);

  _createClass(LeafletTileLayer, null, [{
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },
        base: Boolean,
        url: {
          type: String,
          value: "//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          observer: '_urlChanged',
          reflectToAttribute: true
        },
        format: {
          type: String,
          observer: '_formatChanged',
          reflectToAttribute: true
        },
        layers: {
          type: String,
          observer: '_layersChanged'
        },
        minZoom: Number,
        maxZoom: Number,
        attribution: String
      };
    }
  }]);

  function LeafletTileLayer() {
    _classCallCheck(this, LeafletTileLayer);

    return _possibleConstructorReturn(this, (LeafletTileLayer.__proto__ || Object.getPrototypeOf(LeafletTileLayer)).call(this));
  }

  _createClass(LeafletTileLayer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletTileLayer.prototype.__proto__ || Object.getPrototypeOf(LeafletTileLayer.prototype), 'connectedCallback', this).call(this);
    }
  }, {
    key: '_urlChanged',
    value: function _urlChanged() {
      console.log('url changed', this.url);
      if (this.leafletLayer) this.leafletLayer.setUrl(this.url);
    }
  }, {
    key: '_layersChanged',
    value: function _layersChanged() {
      console.log('layers changed', this.layers);
      if (this.leafletLayer && this.leafletLayer instanceof _TileLayerWMS.TileLayerWMS) this.leafletLayer.setParams({ layers: this.layers });
    }
  }, {
    key: '_formatChanged',
    value: function _formatChanged() {
      console.log('format changed', this.format);

      if (this.leafletLayer && this.map) {
        this.leafletLayer.removeFrom(this.map);
      }

      var options = {
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        attribution: this.attribution
      };

      switch (this.format) {
        case 'XYZ':
          this.leafletLayer = new _TileLayer.TileLayer(this.url, options);
          break;
        case 'WMS':
          this.leafletLayer = new _TileLayerWMS.TileLayerWMS(this.url, Object.assign(options, {
            layers: this.layers,
            format: 'image/png',
            transparent: false,
            hints: 'quality'
          }));
          break;
        default:
          console.error('Invalid leaflet-tile-layer format: ', this.format);
          return;
      }

      if (this.map) this.leafletLayer.addTo(this.map);else console.log('map not yet set');
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      console.log('map set');
      if (this.leafletLayer && !this.map.hasLayer(this.leafletLayer)) {
        console.log('no layer yet, adding');
        this.leafletLayer.addTo(this.map);
      } else {
        console.log('layer object not set / layer exists, skipping');
      }
    }
  }]);

  return LeafletTileLayer;
}(_polymerElement.Element);

customElements.define('leaflet-tile-layer', LeafletTileLayer);

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletGeoJSON = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _domRepeat = __webpack_require__(44);

var _CircleMarker = __webpack_require__(32);

var _GeoJSON = __webpack_require__(88);

__webpack_require__(146);

var _src = __webpack_require__(156);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Dev only
// import { LeafletMap } from '../../@ggcity/leaflet-map/leaflet-map.js';

var LeafletGeoJSON = exports.LeafletGeoJSON = function (_PolymerElement) {
  _inherits(LeafletGeoJSON, _PolymerElement);

  _createClass(LeafletGeoJSON, null, [{
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },

        source: {
          type: String,
          observer: '_sourceChange',
          reflectToAttribute: true
        },

        fillColor: {
          type: String,
          value: '#FF80AB'
        },

        outlineColor: {
          type: String,
          value: '#FF1744'
        },

        radius: {
          type: Number,
          value: 10
        },

        weight: {
          type: Number,
          value: 3
        },

        opacity: {
          type: Number,
          value: 1.0
        },

        fillOpacity: {
          type: Number,
          value: 1.0
        },

        cluster: Boolean,
        maxClusterRadius: {
          type: Number,
          value: 80
        },
        identify: Boolean,
        minZoom: Number,
        maxZoom: Number,
        attribution: String
      };
    }
  }]);

  function LeafletGeoJSON() {
    _classCallCheck(this, LeafletGeoJSON);

    return _possibleConstructorReturn(this, (LeafletGeoJSON.__proto__ || Object.getPrototypeOf(LeafletGeoJSON)).call(this));
  }

  _createClass(LeafletGeoJSON, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletGeoJSON.prototype.__proto__ || Object.getPrototypeOf(LeafletGeoJSON.prototype), 'connectedCallback', this).call(this);

      this._clusterGroup = new _src.MarkerClusterGroup({
        showCoverageOnHover: false,
        maxClusterRadius: this.maxClusterRadius
      });

      this._circleMakerOptions = {
        color: this.outlineColor,
        fillColor: this.fillColor,
        radius: this.radius,
        weight: this.weight,
        opacity: this.opacity,
        fillOpacity: this.fillOpacity
      };
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(LeafletGeoJSON.prototype.__proto__ || Object.getPrototypeOf(LeafletGeoJSON.prototype), 'disconnectedCallback', this).call(this);
      this.map.removeLayer(this._clusterGroup);
      this._clusterGroup.clearLayers();
    }
  }, {
    key: '_addGeoJSONLayer',
    value: function _addGeoJSONLayer(geojson) {
      this._clusterGroup.clearLayers();

      this._geoJSONOptions = {
        pointToLayer: this.cluster ? this._clusterPoints.bind(this) : this._simplePoints.bind(this),
        attribution: this.attribution
      };
      this._geoJSONLayer = new _GeoJSON.GeoJSON(geojson, this._geoJSONOptions);

      if (this.cluster) {
        this.map.addLayer(this._clusterGroup);
      } else {
        this.map.addLayer(this._geoJSONLayer);
      }
    }
  }, {
    key: '_clusterPoints',
    value: function _clusterPoints(feature, latlng) {
      var marker = new _CircleMarker.CircleMarker(latlng, this._circleMakerOptions);
      if (this.identify) marker.bindPopup(this._generatePopupContent(feature));

      this._clusterGroup.addLayer(marker);
    }
  }, {
    key: '_simplePoints',
    value: function _simplePoints(feature, latlng) {
      var marker = new _CircleMarker.CircleMarker(latlng, this._circleMakerOptions);
      if (this.identify) marker.bindPopup(this._generatePopupContent(feature));

      return marker;
    }
  }, {
    key: '_onEachFeature',
    value: function _onEachFeature(feature, layer) {
      console.log('binding');
      if (this.identify) {
        layer.bindPopup(this._generatePopupContent(feature));
      }
    }
  }, {
    key: '_generatePopupContent',
    value: function _generatePopupContent(feature) {
      var rows = '';
      for (var p in feature.properties) {
        var fieldName = p.replace(/\w\S*/g, function (txt) {
          return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase().replace('_', ' ');
        });
        rows += '<tr><td>' + fieldName + ':</td><td><strong>' + feature.properties[p] + '</strong></td></tr>';
      }

      return '<table>' + rows + '</table>';
    }
  }, {
    key: '_sourceChange',
    value: function _sourceChange() {
      if (this.map && this._geoJSONLayer) this._geoJSONLayer.removeFrom(this.map);

      fetch(this.source).then(function (res) {
        return res.json();
      }).then(this._addGeoJSONLayer.bind(this));
      // .catch(() => alert('Unable to load layer'));
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      // console.log('adding layer');
      // this.map.addLayer(this._geoJSONLayer);
    }
  }]);

  return LeafletGeoJSON;
}(_polymerElement.Element);

customElements.define('leaflet-geojson-points', LeafletGeoJSON);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.version = undefined;

var _index = __webpack_require__(81);

Object.keys(_index).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index[key];
		}
	});
});

var _index2 = __webpack_require__(147);

Object.keys(_index2).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index2[key];
		}
	});
});

var _index3 = __webpack_require__(148);

Object.keys(_index3).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index3[key];
		}
	});
});

var _index4 = __webpack_require__(149);

Object.keys(_index4).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index4[key];
		}
	});
});

var _index5 = __webpack_require__(150);

Object.keys(_index5).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index5[key];
		}
	});
});

var _index6 = __webpack_require__(82);

Object.keys(_index6).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index6[key];
		}
	});
});

var _index7 = __webpack_require__(79);

Object.keys(_index7).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index7[key];
		}
	});
});
exports.noConflict = noConflict;

var _package = __webpack_require__(155);

var _Util = __webpack_require__(0);

exports.version = _package.version;

// control


// core


// dom


// geometry


// geo


// layer


// map

// misc

var oldL = window.L;
function noConflict() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

Object.freeze = _Util.freeze;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setOptions = exports.stamp = exports.bind = exports.extend = exports.Util = exports.Handler = exports.Mixin = exports.Evented = exports.Class = exports.Browser = undefined;

var _Class = __webpack_require__(20);

Object.defineProperty(exports, 'Class', {
  enumerable: true,
  get: function get() {
    return _Class.Class;
  }
});

var _Handler = __webpack_require__(14);

Object.defineProperty(exports, 'Handler', {
  enumerable: true,
  get: function get() {
    return _Handler.Handler;
  }
});

var _Util = __webpack_require__(0);

Object.defineProperty(exports, 'extend', {
  enumerable: true,
  get: function get() {
    return _Util.extend;
  }
});
Object.defineProperty(exports, 'bind', {
  enumerable: true,
  get: function get() {
    return _Util.bind;
  }
});
Object.defineProperty(exports, 'stamp', {
  enumerable: true,
  get: function get() {
    return _Util.stamp;
  }
});
Object.defineProperty(exports, 'setOptions', {
  enumerable: true,
  get: function get() {
    return _Util.setOptions;
  }
});

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Events = __webpack_require__(19);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Browser = Browser;
exports.Evented = _Events.Evented;
var Mixin = exports.Mixin = { Events: _Events.Events };

exports.Util = Util;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Draggable = exports.DomUtil = exports.DomEvent = exports.PosAnimation = undefined;

var _PosAnimation = __webpack_require__(77);

Object.defineProperty(exports, 'PosAnimation', {
  enumerable: true,
  get: function get() {
    return _PosAnimation.PosAnimation;
  }
});

var _Draggable = __webpack_require__(49);

Object.defineProperty(exports, 'Draggable', {
  enumerable: true,
  get: function get() {
    return _Draggable.Draggable;
  }
});

var _DomEvent = __webpack_require__(5);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolyUtil = exports.LineUtil = exports.transformation = exports.Transformation = exports.bounds = exports.Bounds = exports.point = exports.Point = undefined;

var _Point = __webpack_require__(3);

Object.defineProperty(exports, 'Point', {
  enumerable: true,
  get: function get() {
    return _Point.Point;
  }
});
Object.defineProperty(exports, 'point', {
  enumerable: true,
  get: function get() {
    return _Point.toPoint;
  }
});

var _Bounds = __webpack_require__(8);

Object.defineProperty(exports, 'Bounds', {
  enumerable: true,
  get: function get() {
    return _Bounds.Bounds;
  }
});
Object.defineProperty(exports, 'bounds', {
  enumerable: true,
  get: function get() {
    return _Bounds.toBounds;
  }
});

var _Transformation = __webpack_require__(21);

Object.defineProperty(exports, 'Transformation', {
  enumerable: true,
  get: function get() {
    return _Transformation.Transformation;
  }
});
Object.defineProperty(exports, 'transformation', {
  enumerable: true,
  get: function get() {
    return _Transformation.toTransformation;
  }
});

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _PolyUtil = __webpack_require__(86);

var PolyUtil = _interopRequireWildcard(_PolyUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Projection = exports.latLngBounds = exports.LatLngBounds = exports.latLng = exports.LatLng = undefined;

var _LatLng = __webpack_require__(9);

Object.defineProperty(exports, 'LatLng', {
  enumerable: true,
  get: function get() {
    return _LatLng.LatLng;
  }
});
Object.defineProperty(exports, 'latLng', {
  enumerable: true,
  get: function get() {
    return _LatLng.toLatLng;
  }
});

var _LatLngBounds = __webpack_require__(10);

Object.defineProperty(exports, 'LatLngBounds', {
  enumerable: true,
  get: function get() {
    return _LatLngBounds.LatLngBounds;
  }
});
Object.defineProperty(exports, 'latLngBounds', {
  enumerable: true,
  get: function get() {
    return _LatLngBounds.toLatLngBounds;
  }
});

var _index = __webpack_require__(151);

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

var _index2 = __webpack_require__(154);

var Projection = _interopRequireWildcard(_index2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Projection = Projection;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CRS = undefined;

var _CRS = __webpack_require__(47);

var _CRS2 = __webpack_require__(16);

var _CRS3 = __webpack_require__(152);

var _CRS4 = __webpack_require__(73);

var _CRS5 = __webpack_require__(54);

var _CRS6 = __webpack_require__(153);

_CRS.CRS.Earth = _CRS2.Earth;
_CRS.CRS.EPSG3395 = _CRS3.EPSG3395;
_CRS.CRS.EPSG3857 = _CRS4.EPSG3857;
_CRS.CRS.EPSG900913 = _CRS4.EPSG900913;
_CRS.CRS.EPSG4326 = _CRS5.EPSG4326;
_CRS.CRS.Simple = _CRS6.Simple;

exports.CRS = _CRS.CRS;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.EPSG3395 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(89);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = exports.EPSG3395 = Util.extend({}, _CRS.Earth, {
	code: 'EPSG:3395',
	projection: _Projection.Mercator,

	transformation: function () {
		var scale = 0.5 / (Math.PI * _Projection.Mercator.R);
		return (0, _Transformation.toTransformation)(scale, 0.5, -scale, 0.5);
	}()
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Simple = undefined;

var _CRS = __webpack_require__(47);

var _Projection = __webpack_require__(55);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = exports.Simple = Util.extend({}, _CRS.CRS, {
	projection: _Projection.LonLat,
	transformation: (0, _Transformation.toTransformation)(1, 0, -1, 0),

	scale: function scale(zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function zoom(scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function distance(latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Projection = __webpack_require__(55);

Object.defineProperty(exports, 'LonLat', {
  enumerable: true,
  get: function get() {
    return _Projection.LonLat;
  }
});

var _Projection2 = __webpack_require__(89);

Object.defineProperty(exports, 'Mercator', {
  enumerable: true,
  get: function get() {
    return _Projection2.Mercator;
  }
});

var _Projection3 = __webpack_require__(74);

Object.defineProperty(exports, 'SphericalMercator', {
  enumerable: true,
  get: function get() {
    return _Projection3.SphericalMercator;
  }
});

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = {"name":"leaflet","version":"1.2.0","description":"JavaScript library for mobile-friendly interactive maps","devDependencies":{"eslint":"^3.5.0 <3.6.0","eslint-config-mourner":"^2.0.1","git-rev-sync":"^1.8.0","happen":"~0.3.1","jake":"~8.0.12","karma":"^1.3.0","karma-chrome-launcher":"^2.0.0","karma-coverage":"~1.1.1","karma-firefox-launcher":"~1.0.0","karma-mocha":"^1.2.0","karma-phantomjs-launcher":"^1.0.2","karma-rollup-preprocessor":"^4.0.2","karma-safari-launcher":"~1.0.0","leafdoc":"^1.4.1","mocha":"^3.5.0","phantomjs-prebuilt":"^2.1.12","prosthetic-hand":"^1.3.1","rollup":"^0.45.2","rollup-plugin-git-version":"0.2.1","rollup-plugin-json":"^2.1.0","rollup-watch":"^4.3.1","source-map":"^0.5.6","ssri":"^4.1.2","uglify-js":"~3.0.26"},"main":"dist/leaflet-src.js","style":"dist/leaflet.css","files":["dist","src","!dist/leaflet.zip"],"scripts":{"test-jake":"jake test","test":"jake test","build-jake":"jake build","build":"npm run rollup && npm run uglify","release":"./build/publish.sh","lint":"eslint src; eslint spec/suites","lintfix":"eslint src --fix; eslint spec/suites --fix; ","rollup":"rollup -c build/rollup-config.js","watch":"rollup -w -c build/rollup-watch-config.js","uglify":"uglifyjs dist/leaflet-src.js -c -m -o dist/leaflet.js --source-map filename=dist/leaflet.js.map --in-source-map dist/leaflet-src.js.map --source-map-url leaflet.js.map --comments","integrity":"nodejs ./build/integrity.js"},"eslintConfig":{"root":true,"globals":{"L":true},"env":{"commonjs":true,"amd":true,"node":false},"extends":"mourner","parserOptions":{"ecmaVersion":6,"sourceType":"module"},"rules":{"linebreak-style":[0,"unix"],"no-mixed-spaces-and-tabs":[2,"smart-tabs"],"indent":[2,"tab",{"VariableDeclarator":0}],"curly":2,"spaced-comment":2,"strict":0,"wrap-iife":0,"key-spacing":0,"consistent-return":0}},"repository":{"type":"git","url":"git://github.com/Leaflet/Leaflet.git"},"keywords":["gis","map"],"license":"BSD-2-Clause"}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerCluster = exports.MarkerClusterGroup = undefined;

var _MarkerClusterGroup = __webpack_require__(157);

Object.defineProperty(exports, 'MarkerClusterGroup', {
  enumerable: true,
  get: function get() {
    return _MarkerClusterGroup.MarkerClusterGroup;
  }
});

var _MarkerCluster = __webpack_require__(158);

Object.defineProperty(exports, 'MarkerCluster', {
  enumerable: true,
  get: function get() {
    return _MarkerCluster.MarkerCluster;
  }
});

__webpack_require__(159);

__webpack_require__(160);

__webpack_require__(161);

__webpack_require__(162);

__webpack_require__(163);

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

var MarkerClusterGroup = exports.MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({

	options: {
		maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
		iconCreateFunction: null,
		clusterPane: L.Marker.prototype.options.pane,

		spiderfyOnMaxZoom: true,
		showCoverageOnHover: true,
		zoomToBoundsOnClick: true,
		singleMarkerMode: false,

		disableClusteringAtZoom: null,

		// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
		// is the default behaviour for performance reasons.
		removeOutsideVisibleBounds: true,

		// Set to false to disable all animations (zoom and spiderfy).
		// If false, option animateAddingMarkers below has no effect.
		// If L.DomUtil.TRANSITION is falsy, this option has no effect.
		animate: true,

		//Whether to animate adding markers after adding the MarkerClusterGroup to the map
		// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
		animateAddingMarkers: false,

		//Increase to increase the distance away that spiderfied markers appear from the center
		spiderfyDistanceMultiplier: 1,

		// Make it possible to specify a polyline options on a spider leg
		spiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },

		// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
		chunkedLoading: false,
		chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
		chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
		chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

		//Options to pass to the L.Polygon constructor
		polygonOptions: {}
	},

	initialize: function initialize(options) {
		L.Util.setOptions(this, options);
		if (!this.options.iconCreateFunction) {
			this.options.iconCreateFunction = this._defaultIconCreateFunction;
		}

		this._featureGroup = L.featureGroup();
		this._featureGroup.addEventParent(this);

		this._nonPointGroup = L.featureGroup();
		this._nonPointGroup.addEventParent(this);

		this._inZoomAnimation = 0;
		this._needsClustering = [];
		this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
		//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
		this._currentShownBounds = null;

		this._queue = [];

		this._childMarkerEventHandlers = {
			'dragstart': this._childMarkerDragStart,
			'move': this._childMarkerMoved,
			'dragend': this._childMarkerDragEnd
		};

		// Hook the appropriate animation methods.
		var animate = L.DomUtil.TRANSITION && this.options.animate;
		L.extend(this, animate ? this._withAnimation : this._noAnimation);
		// Remember which MarkerCluster class to instantiate (animated or not).
		this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
	},

	addLayer: function addLayer(layer) {

		if (layer instanceof L.LayerGroup) {
			return this.addLayers([layer]);
		}

		//Don't cluster non point data
		if (!layer.getLatLng) {
			this._nonPointGroup.addLayer(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (!this._map) {
			this._needsClustering.push(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (this.hasLayer(layer)) {
			return this;
		}

		//If we have already clustered we'll need to add this one to a cluster

		if (this._unspiderfy) {
			this._unspiderfy();
		}

		this._addLayer(layer, this._maxZoom);
		this.fire('layeradd', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Work out what is visible
		var visibleLayer = layer,
		    currentZoom = this._zoom;
		if (layer.__parent) {
			while (visibleLayer.__parent._zoom >= currentZoom) {
				visibleLayer = visibleLayer.__parent;
			}
		}

		if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
			if (this.options.animateAddingMarkers) {
				this._animationAddLayer(layer, visibleLayer);
			} else {
				this._animationAddLayerNonAnimated(layer, visibleLayer);
			}
		}
		return this;
	},

	removeLayer: function removeLayer(layer) {

		if (layer instanceof L.LayerGroup) {
			return this.removeLayers([layer]);
		}

		//Non point layers
		if (!layer.getLatLng) {
			this._nonPointGroup.removeLayer(layer);
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!this._map) {
			if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
				this._needsRemoving.push({ layer: layer, latlng: layer._latlng });
			}
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!layer.__parent) {
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			this._unspiderfyLayer(layer);
		}

		//Remove the marker from clusters
		this._removeLayer(layer, true);
		this.fire('layerremove', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		layer.off(this._childMarkerEventHandlers, this);

		if (this._featureGroup.hasLayer(layer)) {
			this._featureGroup.removeLayer(layer);
			if (layer.clusterShow) {
				layer.clusterShow();
			}
		}

		return this;
	},

	//Takes an array of markers and adds them in bulk
	addLayers: function addLayers(layersArray, skipLayerAddEvent) {
		if (!L.Util.isArray(layersArray)) {
			return this.addLayer(layersArray);
		}

		var fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    chunked = this.options.chunkedLoading,
		    chunkInterval = this.options.chunkInterval,
		    chunkProgress = this.options.chunkProgress,
		    l = layersArray.length,
		    offset = 0,
		    originalArray = true,
		    m;

		if (this._map) {
			var started = new Date().getTime();
			var process = L.bind(function () {
				var start = new Date().getTime();
				for (; offset < l; offset++) {
					if (chunked && offset % 200 === 0) {
						// every couple hundred markers, instrument the time elapsed since processing started:
						var elapsed = new Date().getTime() - start;
						if (elapsed > chunkInterval) {
							break; // been working too hard, time to take a break :-)
						}
					}

					m = layersArray[offset];

					// Group of layers, append children to layersArray and skip.
					// Side effects:
					// - Total increases, so chunkProgress ratio jumps backward.
					// - Groups are not included in this group, only their non-group child layers (hasLayer).
					// Changing array length while looping does not affect performance in current browsers:
					// http://jsperf.com/for-loop-changing-length/6
					if (m instanceof L.LayerGroup) {
						if (originalArray) {
							layersArray = layersArray.slice();
							originalArray = false;
						}
						this._extractNonGroupLayers(m, layersArray);
						l = layersArray.length;
						continue;
					}

					//Not point data, can't be clustered
					if (!m.getLatLng) {
						npg.addLayer(m);
						if (!skipLayerAddEvent) {
							this.fire('layeradd', { layer: m });
						}
						continue;
					}

					if (this.hasLayer(m)) {
						continue;
					}

					this._addLayer(m, this._maxZoom);
					if (!skipLayerAddEvent) {
						this.fire('layeradd', { layer: m });
					}

					//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
					if (m.__parent) {
						if (m.__parent.getChildCount() === 2) {
							var markers = m.__parent.getAllChildMarkers(),
							    otherMarker = markers[0] === m ? markers[1] : markers[0];
							fg.removeLayer(otherMarker);
						}
					}
				}

				if (chunkProgress) {
					// report progress and time elapsed:
					chunkProgress(offset, l, new Date().getTime() - started);
				}

				// Completed processing all markers.
				if (offset === l) {

					// Refresh bounds and weighted positions.
					this._topClusterLevel._recalculateBounds();

					this._refreshClustersIcons();

					this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
				} else {
					setTimeout(process, this.options.chunkDelay);
				}
			}, this);

			process();
		} else {
			var needsClustering = this._needsClustering;

			for (; offset < l; offset++) {
				m = layersArray[offset];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				//Not point data, can't be clustered
				if (!m.getLatLng) {
					npg.addLayer(m);
					continue;
				}

				if (this.hasLayer(m)) {
					continue;
				}

				needsClustering.push(m);
			}
		}
		return this;
	},

	//Takes an array of markers and removes them in bulk
	removeLayers: function removeLayers(layersArray) {
		var i,
		    m,
		    l = layersArray.length,
		    fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    originalArray = true;

		if (!this._map) {
			for (i = 0; i < l; i++) {
				m = layersArray[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				this._arraySplice(this._needsClustering, m);
				npg.removeLayer(m);
				if (this.hasLayer(m)) {
					this._needsRemoving.push({ layer: m, latlng: m._latlng });
				}
				this.fire('layerremove', { layer: m });
			}
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();

			// Work on a copy of the array, so that next loop is not affected.
			var layersArray2 = layersArray.slice(),
			    l2 = l;
			for (i = 0; i < l2; i++) {
				m = layersArray2[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					this._extractNonGroupLayers(m, layersArray2);
					l2 = layersArray2.length;
					continue;
				}

				this._unspiderfyLayer(m);
			}
		}

		for (i = 0; i < l; i++) {
			m = layersArray[i];

			// Group of layers, append children to layersArray and skip.
			if (m instanceof L.LayerGroup) {
				if (originalArray) {
					layersArray = layersArray.slice();
					originalArray = false;
				}
				this._extractNonGroupLayers(m, layersArray);
				l = layersArray.length;
				continue;
			}

			if (!m.__parent) {
				npg.removeLayer(m);
				this.fire('layerremove', { layer: m });
				continue;
			}

			this._removeLayer(m, true, true);
			this.fire('layerremove', { layer: m });

			if (fg.hasLayer(m)) {
				fg.removeLayer(m);
				if (m.clusterShow) {
					m.clusterShow();
				}
			}
		}

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Fix up the clusters and markers on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

		return this;
	},

	//Removes all layers from the MarkerClusterGroup
	clearLayers: function clearLayers() {
		//Need our own special implementation as the LayerGroup one doesn't work for us

		//If we aren't on the map (yet), blow away the markers we know of
		if (!this._map) {
			this._needsClustering = [];
			delete this._gridClusters;
			delete this._gridUnclustered;
		}

		if (this._noanimationUnspiderfy) {
			this._noanimationUnspiderfy();
		}

		//Remove all the visible layers
		this._featureGroup.clearLayers();
		this._nonPointGroup.clearLayers();

		this.eachLayer(function (marker) {
			marker.off(this._childMarkerEventHandlers, this);
			delete marker.__parent;
		}, this);

		if (this._map) {
			//Reset _topClusterLevel and the DistanceGrids
			this._generateInitialClusters();
		}

		return this;
	},

	//Override FeatureGroup.getBounds as it doesn't work
	getBounds: function getBounds() {
		var bounds = new L.LatLngBounds();

		if (this._topClusterLevel) {
			bounds.extend(this._topClusterLevel._bounds);
		}

		for (var i = this._needsClustering.length - 1; i >= 0; i--) {
			bounds.extend(this._needsClustering[i].getLatLng());
		}

		bounds.extend(this._nonPointGroup.getBounds());

		return bounds;
	},

	//Overrides LayerGroup.eachLayer
	eachLayer: function eachLayer(method, context) {
		var markers = this._needsClustering.slice(),
		    needsRemoving = this._needsRemoving,
		    thisNeedsRemoving,
		    i,
		    j;

		if (this._topClusterLevel) {
			this._topClusterLevel.getAllChildMarkers(markers);
		}

		for (i = markers.length - 1; i >= 0; i--) {
			thisNeedsRemoving = true;

			for (j = needsRemoving.length - 1; j >= 0; j--) {
				if (needsRemoving[j].layer === markers[i]) {
					thisNeedsRemoving = false;
					break;
				}
			}

			if (thisNeedsRemoving) {
				method.call(context, markers[i]);
			}
		}

		this._nonPointGroup.eachLayer(method, context);
	},

	//Overrides LayerGroup.getLayers
	getLayers: function getLayers() {
		var layers = [];
		this.eachLayer(function (l) {
			layers.push(l);
		});
		return layers;
	},

	//Overrides LayerGroup.getLayer, WARNING: Really bad performance
	getLayer: function getLayer(id) {
		var result = null;

		id = parseInt(id, 10);

		this.eachLayer(function (l) {
			if (L.stamp(l) === id) {
				result = l;
			}
		});

		return result;
	},

	//Returns true if the given layer is in this MarkerClusterGroup
	hasLayer: function hasLayer(layer) {
		if (!layer) {
			return false;
		}

		var i,
		    anArray = this._needsClustering;

		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return true;
			}
		}

		anArray = this._needsRemoving;
		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i].layer === layer) {
				return false;
			}
		}

		return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
	},

	//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
	zoomToShowLayer: function zoomToShowLayer(layer, callback) {

		if (typeof callback !== 'function') {
			callback = function callback() {};
		}

		var showMarker = function showMarker() {
			if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
				this._map.off('moveend', showMarker, this);
				this.off('animationend', showMarker, this);

				if (layer._icon) {
					callback();
				} else if (layer.__parent._icon) {
					this.once('spiderfied', callback, this);
					layer.__parent.spiderfy();
				}
			}
		};

		if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
			//Layer is visible ond on screen, immediate return
			callback();
		} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {
			//Layer should be visible at this zoom level. It must not be on screen so just pan over to it
			this._map.on('moveend', showMarker, this);
			this._map.panTo(layer.getLatLng());
		} else {
			this._map.on('moveend', showMarker, this);
			this.on('animationend', showMarker, this);
			layer.__parent.zoomToBounds();
		}
	},

	//Overrides FeatureGroup.onAdd
	onAdd: function onAdd(map) {
		this._map = map;
		var i, l, layer;

		if (!isFinite(this._map.getMaxZoom())) {
			throw "Map has no maxZoom specified";
		}

		this._featureGroup.addTo(map);
		this._nonPointGroup.addTo(map);

		if (!this._gridClusters) {
			this._generateInitialClusters();
		}

		this._maxLat = map.options.crs.projection.MAX_LATITUDE;

		//Restore all the positions as they are in the MCG before removing them
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			layer.newlatlng = layer.layer._latlng;
			layer.layer._latlng = layer.latlng;
		}
		//Remove them, then restore their new positions
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			this._removeLayer(layer.layer, true);
			layer.layer._latlng = layer.newlatlng;
		}
		this._needsRemoving = [];

		//Remember the current zoom level and bounds
		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();

		this._map.on('zoomend', this._zoomEnd, this);
		this._map.on('moveend', this._moveEnd, this);

		if (this._spiderfierOnAdd) {
			//TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnAdd();
		}

		this._bindEvents();

		//Actually add our markers to the map:
		l = this._needsClustering;
		this._needsClustering = [];
		this.addLayers(l, true);
	},

	//Overrides FeatureGroup.onRemove
	onRemove: function onRemove(map) {
		map.off('zoomend', this._zoomEnd, this);
		map.off('moveend', this._moveEnd, this);

		this._unbindEvents();

		//In case we are in a cluster animation
		this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

		if (this._spiderfierOnRemove) {
			//TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnRemove();
		}

		delete this._maxLat;

		//Clean up all the layers we added to the map
		this._hideCoverage();
		this._featureGroup.remove();
		this._nonPointGroup.remove();

		this._featureGroup.clearLayers();

		this._map = null;
	},

	getVisibleParent: function getVisibleParent(marker) {
		var vMarker = marker;
		while (vMarker && !vMarker._icon) {
			vMarker = vMarker.__parent;
		}
		return vMarker || null;
	},

	//Remove the given object from the given array
	_arraySplice: function _arraySplice(anArray, obj) {
		for (var i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === obj) {
				anArray.splice(i, 1);
				return true;
			}
		}
	},

	/**
  * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
  * @param marker to be removed from _gridUnclustered.
  * @param z integer bottom start zoom level (included)
  * @private
  */
	_removeFromGridUnclustered: function _removeFromGridUnclustered(marker, z) {
		var map = this._map,
		    gridUnclustered = this._gridUnclustered,
		    minZoom = Math.floor(this._map.getMinZoom());

		for (; z >= minZoom; z--) {
			if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
				break;
			}
		}
	},

	_childMarkerDragStart: function _childMarkerDragStart(e) {
		e.target.__dragStart = e.target._latlng;
	},

	_childMarkerMoved: function _childMarkerMoved(e) {
		if (!this._ignoreMove && !e.target.__dragStart) {
			var isPopupOpen = e.target._popup && e.target._popup.isOpen();

			this._moveChild(e.target, e.oldLatLng, e.latlng);

			if (isPopupOpen) {
				e.target.openPopup();
			}
		}
	},

	_moveChild: function _moveChild(layer, from, to) {
		layer._latlng = from;
		this.removeLayer(layer);

		layer._latlng = to;
		this.addLayer(layer);
	},

	_childMarkerDragEnd: function _childMarkerDragEnd(e) {
		if (e.target.__dragStart) {
			this._moveChild(e.target, e.target.__dragStart, e.target._latlng);
		}
		delete e.target.__dragStart;
	},

	//Internal function for removing a marker from everything.
	//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
	_removeLayer: function _removeLayer(marker, removeFromDistanceGrid, dontUpdateMap) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    fg = this._featureGroup,
		    map = this._map,
		    minZoom = Math.floor(this._map.getMinZoom());

		//Remove the marker from distance clusters it might be in
		if (removeFromDistanceGrid) {
			this._removeFromGridUnclustered(marker, this._maxZoom);
		}

		//Work our way up the clusters removing them as we go if required
		var cluster = marker.__parent,
		    markers = cluster._markers,
		    otherMarker;

		//Remove the marker from the immediate parents marker list
		this._arraySplice(markers, marker);

		while (cluster) {
			cluster._childCount--;
			cluster._boundsNeedUpdate = true;

			if (cluster._zoom < minZoom) {
				//Top level, do nothing
				break;
			} else if (removeFromDistanceGrid && cluster._childCount <= 1) {
				//Cluster no longer required
				//We need to push the other marker up to the parent
				otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

				//Update distance grid
				gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
				gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

				//Move otherMarker up to parent
				this._arraySplice(cluster.__parent._childClusters, cluster);
				cluster.__parent._markers.push(otherMarker);
				otherMarker.__parent = cluster.__parent;

				if (cluster._icon) {
					//Cluster is currently on the map, need to put the marker on the map instead
					fg.removeLayer(cluster);
					if (!dontUpdateMap) {
						fg.addLayer(otherMarker);
					}
				}
			} else {
				cluster._iconNeedsUpdate = true;
			}

			cluster = cluster.__parent;
		}

		delete marker.__parent;
	},

	_isOrIsParent: function _isOrIsParent(el, oel) {
		while (oel) {
			if (el === oel) {
				return true;
			}
			oel = oel.parentNode;
		}
		return false;
	},

	//Override L.Evented.fire
	fire: function fire(type, data, propagate) {
		if (data && data.layer instanceof L.MarkerCluster) {
			//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
			if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {
				return;
			}
			type = 'cluster' + type;
		}

		L.FeatureGroup.prototype.fire.call(this, type, data, propagate);
	},

	//Override L.Evented.listens
	listens: function listens(type, propagate) {
		return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);
	},

	//Default functionality
	_defaultIconCreateFunction: function _defaultIconCreateFunction(cluster) {
		var childCount = cluster.getChildCount();

		var c = ' marker-cluster-';
		if (childCount < 10) {
			c += 'small';
		} else if (childCount < 100) {
			c += 'medium';
		} else {
			c += 'large';
		}

		return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
	},

	_bindEvents: function _bindEvents() {
		var map = this._map,
		    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

		//Zoom on cluster click or spiderfy if we are at the lowest level
		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.on('clusterclick', this._zoomOrSpiderfy, this);
		}

		//Show convex hull (boundary) polygon on mouse over
		if (showCoverageOnHover) {
			this.on('clustermouseover', this._showCoverage, this);
			this.on('clustermouseout', this._hideCoverage, this);
			map.on('zoomend', this._hideCoverage, this);
		}
	},

	_zoomOrSpiderfy: function _zoomOrSpiderfy(e) {
		var cluster = e.layer,
		    bottomCluster = cluster;

		while (bottomCluster._childClusters.length === 1) {
			bottomCluster = bottomCluster._childClusters[0];
		}

		if (bottomCluster._zoom === this._maxZoom && bottomCluster._childCount === cluster._childCount && this.options.spiderfyOnMaxZoom) {

			// All child markers are contained in a single cluster from this._maxZoom to this cluster.
			cluster.spiderfy();
		} else if (this.options.zoomToBoundsOnClick) {
			cluster.zoomToBounds();
		}

		// Focus the map again for keyboard users.
		if (e.originalEvent && e.originalEvent.keyCode === 13) {
			this._map._container.focus();
		}
	},

	_showCoverage: function _showCoverage(e) {
		var map = this._map;
		if (this._inZoomAnimation) {
			return;
		}
		if (this._shownPolygon) {
			map.removeLayer(this._shownPolygon);
		}
		if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
			this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
			map.addLayer(this._shownPolygon);
		}
	},

	_hideCoverage: function _hideCoverage() {
		if (this._shownPolygon) {
			this._map.removeLayer(this._shownPolygon);
			this._shownPolygon = null;
		}
	},

	_unbindEvents: function _unbindEvents() {
		var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
		    map = this._map;

		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.off('clusterclick', this._zoomOrSpiderfy, this);
		}
		if (showCoverageOnHover) {
			this.off('clustermouseover', this._showCoverage, this);
			this.off('clustermouseout', this._hideCoverage, this);
			map.off('zoomend', this._hideCoverage, this);
		}
	},

	_zoomEnd: function _zoomEnd() {
		if (!this._map) {
			//May have been removed from the map by a zoomEnd handler
			return;
		}
		this._mergeSplitClusters();

		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();
	},

	_moveEnd: function _moveEnd() {
		if (this._inZoomAnimation) {
			return;
		}

		var newBounds = this._getExpandedVisibleBounds();

		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);

		this._currentShownBounds = newBounds;
		return;
	},

	_generateInitialClusters: function _generateInitialClusters() {
		var maxZoom = Math.ceil(this._map.getMaxZoom()),
		    minZoom = Math.floor(this._map.getMinZoom()),
		    radius = this.options.maxClusterRadius,
		    radiusFn = radius;

		//If we just set maxClusterRadius to a single number, we need to create
		//a simple function to return that number. Otherwise, we just have to
		//use the function we've passed in.
		if (typeof radius !== "function") {
			radiusFn = function radiusFn() {
				return radius;
			};
		}

		if (this.options.disableClusteringAtZoom !== null) {
			maxZoom = this.options.disableClusteringAtZoom - 1;
		}
		this._maxZoom = maxZoom;
		this._gridClusters = {};
		this._gridUnclustered = {};

		//Set up DistanceGrids for each zoom
		for (var zoom = maxZoom; zoom >= minZoom; zoom--) {
			this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
			this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
		}

		// Instantiate the appropriate L.MarkerCluster class (animated or not).
		this._topClusterLevel = new this._markerCluster(this, minZoom - 1);
	},

	//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
	_addLayer: function _addLayer(layer, zoom) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    minZoom = Math.floor(this._map.getMinZoom()),
		    markerPoint,
		    z;

		if (this.options.singleMarkerMode) {
			this._overrideMarkerIcon(layer);
		}

		layer.on(this._childMarkerEventHandlers, this);

		//Find the lowest zoom level to slot this one in
		for (; zoom >= minZoom; zoom--) {
			markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

			//Try find a cluster close by
			var closest = gridClusters[zoom].getNearObject(markerPoint);
			if (closest) {
				closest._addChild(layer);
				layer.__parent = closest;
				return;
			}

			//Try find a marker close by to form a new cluster with
			closest = gridUnclustered[zoom].getNearObject(markerPoint);
			if (closest) {
				var parent = closest.__parent;
				if (parent) {
					this._removeLayer(closest, false);
				}

				//Create new cluster with these 2 in it

				var newCluster = new this._markerCluster(this, zoom, closest, layer);
				gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
				closest.__parent = newCluster;
				layer.__parent = newCluster;

				//First create any new intermediate parent clusters that don't exist
				var lastParent = newCluster;
				for (z = zoom - 1; z > parent._zoom; z--) {
					lastParent = new this._markerCluster(this, z, lastParent);
					gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
				}
				parent._addChild(lastParent);

				//Remove closest from this zoom level and any above that it is in, replace with newCluster
				this._removeFromGridUnclustered(closest, zoom);

				return;
			}

			//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
			gridUnclustered[zoom].addObject(layer, markerPoint);
		}

		//Didn't get in anything, add us to the top
		this._topClusterLevel._addChild(layer);
		layer.__parent = this._topClusterLevel;
		return;
	},

	/**
  * Refreshes the icon of all "dirty" visible clusters.
  * Non-visible "dirty" clusters will be updated when they are added to the map.
  * @private
  */
	_refreshClustersIcons: function _refreshClustersIcons() {
		this._featureGroup.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
				c._updateIcon();
			}
		});
	},

	//Enqueue code to fire after the marker expand/contract has happened
	_enqueue: function _enqueue(fn) {
		this._queue.push(fn);
		if (!this._queueTimeout) {
			this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
		}
	},
	_processQueue: function _processQueue() {
		for (var i = 0; i < this._queue.length; i++) {
			this._queue[i].call(this);
		}
		this._queue.length = 0;
		clearTimeout(this._queueTimeout);
		this._queueTimeout = null;
	},

	//Merge and split any existing clusters that are too big or small
	_mergeSplitClusters: function _mergeSplitClusters() {
		var mapZoom = Math.round(this._map._zoom);

		//In case we are starting to split before the animation finished
		this._processQueue();

		if (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) {
			//Zoom in, split
			this._animationStart();
			//Remove clusters now off screen
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());

			this._animationZoomIn(this._zoom, mapZoom);
		} else if (this._zoom > mapZoom) {
			//Zoom out, merge
			this._animationStart();

			this._animationZoomOut(this._zoom, mapZoom);
		} else {
			this._moveEnd();
		}
	},

	//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
	_getExpandedVisibleBounds: function _getExpandedVisibleBounds() {
		if (!this.options.removeOutsideVisibleBounds) {
			return this._mapBoundsInfinite;
		} else if (L.Browser.mobile) {
			return this._checkBoundsMaxLat(this._map.getBounds());
		}

		return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.
	},

	/**
  * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
  * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
  * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
  * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
  * making the user think that MCG "eats" them and never displays them again.
  * @param bounds L.LatLngBounds
  * @returns {L.LatLngBounds}
  * @private
  */
	_checkBoundsMaxLat: function _checkBoundsMaxLat(bounds) {
		var maxLat = this._maxLat;

		if (maxLat !== undefined) {
			if (bounds.getNorth() >= maxLat) {
				bounds._northEast.lat = Infinity;
			}
			if (bounds.getSouth() <= -maxLat) {
				bounds._southWest.lat = -Infinity;
			}
		}

		return bounds;
	},

	//Shared animation code
	_animationAddLayerNonAnimated: function _animationAddLayerNonAnimated(layer, newCluster) {
		if (newCluster === layer) {
			this._featureGroup.addLayer(layer);
		} else if (newCluster._childCount === 2) {
			newCluster._addToMap();

			var markers = newCluster.getAllChildMarkers();
			this._featureGroup.removeLayer(markers[0]);
			this._featureGroup.removeLayer(markers[1]);
		} else {
			newCluster._updateIcon();
		}
	},

	/**
  * Extracts individual (i.e. non-group) layers from a Layer Group.
  * @param group to extract layers from.
  * @param output {Array} in which to store the extracted layers.
  * @returns {*|Array}
  * @private
  */
	_extractNonGroupLayers: function _extractNonGroupLayers(group, output) {
		var layers = group.getLayers(),
		    i = 0,
		    layer;

		output = output || [];

		for (; i < layers.length; i++) {
			layer = layers[i];

			if (layer instanceof L.LayerGroup) {
				this._extractNonGroupLayers(layer, output);
				continue;
			}

			output.push(layer);
		}

		return output;
	},

	/**
  * Implements the singleMarkerMode option.
  * @param layer Marker to re-style using the Clusters iconCreateFunction.
  * @returns {L.Icon} The newly created icon.
  * @private
  */
	_overrideMarkerIcon: function _overrideMarkerIcon(layer) {
		var icon = layer.options.icon = this.options.iconCreateFunction({
			getChildCount: function getChildCount() {
				return 1;
			},
			getAllChildMarkers: function getAllChildMarkers() {
				return [layer];
			}
		});

		return icon;
	}
});

// Constant bounds used in case option "removeOutsideVisibleBounds" is set to false.
L.MarkerClusterGroup.include({
	_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))
});

L.MarkerClusterGroup.include({
	_noAnimation: {
		//Non Animated versions of everything
		_animationStart: function _animationStart() {
			//Do nothing...
		},
		_animationZoomIn: function _animationZoomIn(previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationZoomOut: function _animationZoomOut(previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationAddLayer: function _animationAddLayer(layer, newCluster) {
			this._animationAddLayerNonAnimated(layer, newCluster);
		}
	},

	_withAnimation: {
		//Animated versions here
		_animationStart: function _animationStart() {
			this._map._mapPane.className += ' leaflet-cluster-anim';
			this._inZoomAnimation++;
		},

		_animationZoomIn: function _animationZoomIn(previousZoomLevel, newZoomLevel) {
			var bounds = this._getExpandedVisibleBounds(),
			    fg = this._featureGroup,
			    minZoom = Math.floor(this._map.getMinZoom()),
			    i;

			this._ignoreMove = true;

			//Add all children of current clusters to map and remove those clusters from map
			this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
				var startPos = c._latlng,
				    markers = c._markers,
				    m;

				if (!bounds.contains(startPos)) {
					startPos = null;
				}

				if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) {
					//Immediately add the new child and remove us
					fg.removeLayer(c);
					c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
				} else {
					//Fade out old cluster
					c.clusterHide();
					c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
				}

				//Remove all markers that aren't visible any more
				//TODO: Do we actually need to do this on the higher levels too?
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];
					if (!bounds.contains(m._latlng)) {
						fg.removeLayer(m);
					}
				}
			});

			this._forceLayout();

			//Update opacities
			this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
			//TODO Maybe? Update markers in _recursivelyBecomeVisible
			fg.eachLayer(function (n) {
				if (!(n instanceof L.MarkerCluster) && n._icon) {
					n.clusterShow();
				}
			});

			//update the positions of the just added clusters/markers
			this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
				c._recursivelyRestoreChildPositions(newZoomLevel);
			});

			this._ignoreMove = false;

			//Remove the old clusters and close the zoom animation
			this._enqueue(function () {
				//update the positions of the just added clusters/markers
				this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
					fg.removeLayer(c);
					c.clusterShow();
				});

				this._animationEnd();
			});
		},

		_animationZoomOut: function _animationZoomOut(previousZoomLevel, newZoomLevel) {
			this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

			//Need to add markers for those that weren't on the map before but are now
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
			//Remove markers that were on the map before but won't be now
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());
		},

		_animationAddLayer: function _animationAddLayer(layer, newCluster) {
			var me = this,
			    fg = this._featureGroup;

			fg.addLayer(layer);
			if (newCluster !== layer) {
				if (newCluster._childCount > 2) {
					//Was already a cluster

					newCluster._updateIcon();
					this._forceLayout();
					this._animationStart();

					layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
					layer.clusterHide();

					this._enqueue(function () {
						fg.removeLayer(layer);
						layer.clusterShow();

						me._animationEnd();
					});
				} else {
					//Just became a cluster
					this._forceLayout();

					me._animationStart();
					me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);
				}
			}
		}
	},

	// Private methods for animated versions.
	_animationZoomOutSingle: function _animationZoomOutSingle(cluster, previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds(),
		    minZoom = Math.floor(this._map.getMinZoom());

		//Animate all of the markers in the clusters to move to their cluster center point
		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);

		var me = this;

		//Update the opacity (If we immediately set it they won't animate)
		this._forceLayout();
		cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

		//TODO: Maybe use the transition timing stuff to make this more reliable
		//When the animations are done, tidy up
		this._enqueue(function () {

			//This cluster stopped being a cluster before the timeout fired
			if (cluster._childCount === 1) {
				var m = cluster._markers[0];
				//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
				this._ignoreMove = true;
				m.setLatLng(m.getLatLng());
				this._ignoreMove = false;
				if (m.clusterShow) {
					m.clusterShow();
				}
			} else {
				cluster._recursively(bounds, newZoomLevel, minZoom, function (c) {
					c._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);
				});
			}
			me._animationEnd();
		});
	},

	_animationEnd: function _animationEnd() {
		if (this._map) {
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
		}
		this._inZoomAnimation--;
		this.fire('animationend');
	},

	//Force a browser layout of stuff in the map
	// Should apply the current opacity and location to all elements so we can update them again for an animation
	_forceLayout: function _forceLayout() {
		//In my testing this works, infact offsetWidth of any element seems to work.
		//Could loop all this._layers and do this for each _icon if it stops working

		L.Util.falseFn(document.body.offsetWidth);
	}
});

L.markerClusterGroup = function (options) {
	return new L.MarkerClusterGroup(options);
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var MarkerCluster = exports.MarkerCluster = L.MarkerCluster = L.Marker.extend({
	options: L.Icon.prototype.options,

	initialize: function initialize(group, zoom, a, b) {

		L.Marker.prototype.initialize.call(this, a ? a._cLatLng || a.getLatLng() : new L.LatLng(0, 0), { icon: this, pane: group.options.clusterPane });

		this._group = group;
		this._zoom = zoom;

		this._markers = [];
		this._childClusters = [];
		this._childCount = 0;
		this._iconNeedsUpdate = true;
		this._boundsNeedUpdate = true;

		this._bounds = new L.LatLngBounds();

		if (a) {
			this._addChild(a);
		}
		if (b) {
			this._addChild(b);
		}
	},

	//Recursively retrieve all child markers of this cluster
	getAllChildMarkers: function getAllChildMarkers(storageArray) {
		storageArray = storageArray || [];

		for (var i = this._childClusters.length - 1; i >= 0; i--) {
			this._childClusters[i].getAllChildMarkers(storageArray);
		}

		for (var j = this._markers.length - 1; j >= 0; j--) {
			storageArray.push(this._markers[j]);
		}

		return storageArray;
	},

	//Returns the count of how many child markers we have
	getChildCount: function getChildCount() {
		return this._childCount;
	},

	//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
	zoomToBounds: function zoomToBounds(fitBoundsOptions) {
		var childClusters = this._childClusters.slice(),
		    map = this._group._map,
		    boundsZoom = map.getBoundsZoom(this._bounds),
		    zoom = this._zoom + 1,
		    mapZoom = map.getZoom(),
		    i;

		//calculate how far we need to zoom down to see all of the markers
		while (childClusters.length > 0 && boundsZoom > zoom) {
			zoom++;
			var newClusters = [];
			for (i = 0; i < childClusters.length; i++) {
				newClusters = newClusters.concat(childClusters[i]._childClusters);
			}
			childClusters = newClusters;
		}

		if (boundsZoom > zoom) {
			this._group._map.setView(this._latlng, zoom);
		} else if (boundsZoom <= mapZoom) {
			//If fitBounds wouldn't zoom us down, zoom us down instead
			this._group._map.setView(this._latlng, mapZoom + 1);
		} else {
			this._group._map.fitBounds(this._bounds, fitBoundsOptions);
		}
	},

	getBounds: function getBounds() {
		var bounds = new L.LatLngBounds();
		bounds.extend(this._bounds);
		return bounds;
	},

	_updateIcon: function _updateIcon() {
		this._iconNeedsUpdate = true;
		if (this._icon) {
			this.setIcon(this);
		}
	},

	//Cludge for Icon, we pretend to be an icon for performance
	createIcon: function createIcon() {
		if (this._iconNeedsUpdate) {
			this._iconObj = this._group.options.iconCreateFunction(this);
			this._iconNeedsUpdate = false;
		}
		return this._iconObj.createIcon();
	},
	createShadow: function createShadow() {
		return this._iconObj.createShadow();
	},

	_addChild: function _addChild(new1, isNotificationFromChild) {

		this._iconNeedsUpdate = true;

		this._boundsNeedUpdate = true;
		this._setClusterCenter(new1);

		if (new1 instanceof L.MarkerCluster) {
			if (!isNotificationFromChild) {
				this._childClusters.push(new1);
				new1.__parent = this;
			}
			this._childCount += new1._childCount;
		} else {
			if (!isNotificationFromChild) {
				this._markers.push(new1);
			}
			this._childCount++;
		}

		if (this.__parent) {
			this.__parent._addChild(new1, true);
		}
	},

	/**
  * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
  * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
  * @private
  */
	_setClusterCenter: function _setClusterCenter(child) {
		if (!this._cLatLng) {
			// when clustering, take position of the first point as the cluster center
			this._cLatLng = child._cLatLng || child._latlng;
		}
	},

	/**
  * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
  * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
  * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
  * @private
  */
	_resetBounds: function _resetBounds() {
		var bounds = this._bounds;

		if (bounds._southWest) {
			bounds._southWest.lat = Infinity;
			bounds._southWest.lng = Infinity;
		}
		if (bounds._northEast) {
			bounds._northEast.lat = -Infinity;
			bounds._northEast.lng = -Infinity;
		}
	},

	_recalculateBounds: function _recalculateBounds() {
		var markers = this._markers,
		    childClusters = this._childClusters,
		    latSum = 0,
		    lngSum = 0,
		    totalCount = this._childCount,
		    i,
		    child,
		    childLatLng,
		    childCount;

		// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.
		if (totalCount === 0) {
			return;
		}

		// Reset rather than creating a new object, for performance.
		this._resetBounds();

		// Child markers.
		for (i = 0; i < markers.length; i++) {
			childLatLng = markers[i]._latlng;

			this._bounds.extend(childLatLng);

			latSum += childLatLng.lat;
			lngSum += childLatLng.lng;
		}

		// Child clusters.
		for (i = 0; i < childClusters.length; i++) {
			child = childClusters[i];

			// Re-compute child bounds and weighted position first if necessary.
			if (child._boundsNeedUpdate) {
				child._recalculateBounds();
			}

			this._bounds.extend(child._bounds);

			childLatLng = child._wLatLng;
			childCount = child._childCount;

			latSum += childLatLng.lat * childCount;
			lngSum += childLatLng.lng * childCount;
		}

		this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);

		// Reset dirty flag.
		this._boundsNeedUpdate = false;
	},

	//Set our markers position as given and add it to the map
	_addToMap: function _addToMap(startPos) {
		if (startPos) {
			this._backupLatlng = this._latlng;
			this.setLatLng(startPos);
		}
		this._group._featureGroup.addLayer(this);
	},

	_recursivelyAnimateChildrenIn: function _recursivelyAnimateChildrenIn(bounds, center, maxZoom) {
		this._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1, function (c) {
			var markers = c._markers,
			    i,
			    m;
			for (i = markers.length - 1; i >= 0; i--) {
				m = markers[i];

				//Only do it if the icon is still on the map
				if (m._icon) {
					m._setPos(center);
					m.clusterHide();
				}
			}
		}, function (c) {
			var childClusters = c._childClusters,
			    j,
			    cm;
			for (j = childClusters.length - 1; j >= 0; j--) {
				cm = childClusters[j];
				if (cm._icon) {
					cm._setPos(center);
					cm.clusterHide();
				}
			}
		});
	},

	_recursivelyAnimateChildrenInAndAddSelfToMap: function _recursivelyAnimateChildrenInAndAddSelfToMap(bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {
		this._recursively(bounds, newZoomLevel, mapMinZoom, function (c) {
			c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

			//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
			//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
			if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
				c.clusterShow();
				c._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
			} else {
				c.clusterHide();
			}

			c._addToMap();
		});
	},

	_recursivelyBecomeVisible: function _recursivelyBecomeVisible(bounds, zoomLevel) {
		this._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {
			c.clusterShow();
		});
	},

	_recursivelyAddChildrenToMap: function _recursivelyAddChildrenToMap(startPos, zoomLevel, bounds) {
		this._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel, function (c) {
			if (zoomLevel === c._zoom) {
				return;
			}

			//Add our child markers at startPos (so they can be animated out)
			for (var i = c._markers.length - 1; i >= 0; i--) {
				var nm = c._markers[i];

				if (!bounds.contains(nm._latlng)) {
					continue;
				}

				if (startPos) {
					nm._backupLatlng = nm.getLatLng();

					nm.setLatLng(startPos);
					if (nm.clusterHide) {
						nm.clusterHide();
					}
				}

				c._group._featureGroup.addLayer(nm);
			}
		}, function (c) {
			c._addToMap(startPos);
		});
	},

	_recursivelyRestoreChildPositions: function _recursivelyRestoreChildPositions(zoomLevel) {
		//Fix positions of child markers
		for (var i = this._markers.length - 1; i >= 0; i--) {
			var nm = this._markers[i];
			if (nm._backupLatlng) {
				nm.setLatLng(nm._backupLatlng);
				delete nm._backupLatlng;
			}
		}

		if (zoomLevel - 1 === this._zoom) {
			//Reposition child clusters
			for (var j = this._childClusters.length - 1; j >= 0; j--) {
				this._childClusters[j]._restorePosition();
			}
		} else {
			for (var k = this._childClusters.length - 1; k >= 0; k--) {
				this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
			}
		}
	},

	_restorePosition: function _restorePosition() {
		if (this._backupLatlng) {
			this.setLatLng(this._backupLatlng);
			delete this._backupLatlng;
		}
	},

	//exceptBounds: If set, don't remove any markers/clusters in it
	_recursivelyRemoveChildrenFromMap: function _recursivelyRemoveChildrenFromMap(previousBounds, mapMinZoom, zoomLevel, exceptBounds) {
		var m, i;
		this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1, function (c) {
			//Remove markers at every level
			for (i = c._markers.length - 1; i >= 0; i--) {
				m = c._markers[i];
				if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
					c._group._featureGroup.removeLayer(m);
					if (m.clusterShow) {
						m.clusterShow();
					}
				}
			}
		}, function (c) {
			//Remove child clusters at just the bottom level
			for (i = c._childClusters.length - 1; i >= 0; i--) {
				m = c._childClusters[i];
				if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
					c._group._featureGroup.removeLayer(m);
					if (m.clusterShow) {
						m.clusterShow();
					}
				}
			}
		});
	},

	//Run the given functions recursively to this and child clusters
	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
	// zoomLevelToStart: zoom level to start running functions (inclusive)
	// zoomLevelToStop: zoom level to stop running functions (inclusive)
	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
	_recursively: function _recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
		var childClusters = this._childClusters,
		    zoom = this._zoom,
		    i,
		    c;

		if (zoomLevelToStart <= zoom) {
			if (runAtEveryLevel) {
				runAtEveryLevel(this);
			}
			if (runAtBottomLevel && zoom === zoomLevelToStop) {
				runAtBottomLevel(this);
			}
		}

		if (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {
			for (i = childClusters.length - 1; i >= 0; i--) {
				c = childClusters[i];
				if (boundsToApplyTo.intersects(c._bounds)) {
					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
				}
			}
		}
	},

	//Returns true if we are the parent of only one cluster and that cluster is the same as us
	_isSingleParent: function _isSingleParent() {
		//Don't need to check this._markers as the rest won't work if there are any
		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
	}
});

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
* Extends L.Marker to include two extra methods: clusterHide and clusterShow.
* 
* They work as setOpacity(0) and setOpacity(1) respectively, but
* they will remember the marker's opacity when hiding and showing it again.
* 
*/

L.Marker.include({

	clusterHide: function clusterHide() {
		this.options.opacityWhenUnclustered = this.options.opacity || 1;
		return this.setOpacity(0);
	},

	clusterShow: function clusterShow() {
		var ret = this.setOpacity(this.options.opacity || this.options.opacityWhenUnclustered);
		delete this.options.opacityWhenUnclustered;
		return ret;
	}

});

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


L.DistanceGrid = function (cellSize) {
	this._cellSize = cellSize;
	this._sqCellSize = cellSize * cellSize;
	this._grid = {};
	this._objectPoint = {};
};

L.DistanceGrid.prototype = {

	addObject: function addObject(obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    stamp = L.Util.stamp(obj);

		this._objectPoint[stamp] = point;

		cell.push(obj);
	},

	updateObject: function updateObject(obj, point) {
		this.removeObject(obj);
		this.addObject(obj, point);
	},

	//Returns true if the object was found
	removeObject: function removeObject(obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    i,
		    len;

		delete this._objectPoint[L.Util.stamp(obj)];

		for (i = 0, len = cell.length; i < len; i++) {
			if (cell[i] === obj) {

				cell.splice(i, 1);

				if (len === 1) {
					delete row[x];
				}

				return true;
			}
		}
	},

	eachObject: function eachObject(fn, context) {
		var i,
		    j,
		    k,
		    len,
		    row,
		    cell,
		    removed,
		    grid = this._grid;

		for (i in grid) {
			row = grid[i];

			for (j in row) {
				cell = row[j];

				for (k = 0, len = cell.length; k < len; k++) {
					removed = fn.call(context, cell[k]);
					if (removed) {
						k--;
						len--;
					}
				}
			}
		}
	},

	getNearObject: function getNearObject(point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    i,
		    j,
		    k,
		    row,
		    cell,
		    len,
		    obj,
		    dist,
		    objectPoint = this._objectPoint,
		    closestDistSq = this._sqCellSize,
		    closest = null;

		for (i = y - 1; i <= y + 1; i++) {
			row = this._grid[i];
			if (row) {

				for (j = x - 1; j <= x + 1; j++) {
					cell = row[j];
					if (cell) {

						for (k = 0, len = cell.length; k < len; k++) {
							obj = cell[k];
							dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
							if (dist < closestDistSq || dist <= closestDistSq && closest === null) {
								closestDistSq = dist;
								closest = obj;
							}
						}
					}
				}
			}
		}
		return closest;
	},

	_getCoord: function _getCoord(x) {
		var coord = Math.floor(x / this._cellSize);
		return isFinite(coord) ? coord : x;
	},

	_sqDist: function _sqDist(p, p2) {
		var dx = p2.x - p.x,
		    dy = p2.y - p.y;
		return dx * dx + dy * dy;
	}
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* Copyright (c) 2012 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
*/

(function () {
	L.QuickHull = {

		/*
   * @param {Object} cpt a point to be measured from the baseline
   * @param {Array} bl the baseline, as represented by a two-element
   *   array of latlng objects.
   * @returns {Number} an approximate distance measure
   */
		getDistant: function getDistant(cpt, bl) {
			var vY = bl[1].lat - bl[0].lat,
			    vX = bl[0].lng - bl[1].lng;
			return vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng);
		},

		/*
   * @param {Array} baseLine a two-element array of latlng objects
   *   representing the baseline to project from
   * @param {Array} latLngs an array of latlng objects
   * @returns {Object} the maximum point and all new points to stay
   *   in consideration for the hull.
   */
		findMostDistantPointFromBaseLine: function findMostDistantPointFromBaseLine(baseLine, latLngs) {
			var maxD = 0,
			    maxPt = null,
			    newPoints = [],
			    i,
			    pt,
			    d;

			for (i = latLngs.length - 1; i >= 0; i--) {
				pt = latLngs[i];
				d = this.getDistant(pt, baseLine);

				if (d > 0) {
					newPoints.push(pt);
				} else {
					continue;
				}

				if (d > maxD) {
					maxD = d;
					maxPt = pt;
				}
			}

			return { maxPoint: maxPt, newPoints: newPoints };
		},

		/*
   * Given a baseline, compute the convex hull of latLngs as an array
   * of latLngs.
   *
   * @param {Array} latLngs
   * @returns {Array}
   */
		buildConvexHull: function buildConvexHull(baseLine, latLngs) {
			var convexHullBaseLines = [],
			    t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

			if (t.maxPoint) {
				// if there is still a point "outside" the base line
				convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints));
				convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints));
				return convexHullBaseLines;
			} else {
				// if there is no more point "outside" the base line, the current base line is part of the convex hull
				return [baseLine[0]];
			}
		},

		/*
   * Given an array of latlngs, compute a convex hull as an array
   * of latlngs
   *
   * @param {Array} latLngs
   * @returns {Array}
   */
		getConvexHull: function getConvexHull(latLngs) {
			// find first baseline
			var maxLat = false,
			    minLat = false,
			    maxLng = false,
			    minLng = false,
			    maxLatPt = null,
			    minLatPt = null,
			    maxLngPt = null,
			    minLngPt = null,
			    maxPt = null,
			    minPt = null,
			    i;

			for (i = latLngs.length - 1; i >= 0; i--) {
				var pt = latLngs[i];
				if (maxLat === false || pt.lat > maxLat) {
					maxLatPt = pt;
					maxLat = pt.lat;
				}
				if (minLat === false || pt.lat < minLat) {
					minLatPt = pt;
					minLat = pt.lat;
				}
				if (maxLng === false || pt.lng > maxLng) {
					maxLngPt = pt;
					maxLng = pt.lng;
				}
				if (minLng === false || pt.lng < minLng) {
					minLngPt = pt;
					minLng = pt.lng;
				}
			}

			if (minLat !== maxLat) {
				minPt = minLatPt;
				maxPt = maxLatPt;
			} else {
				minPt = minLngPt;
				maxPt = maxLngPt;
			}

			var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs), this.buildConvexHull([maxPt, minPt], latLngs));
			return ch;
		}
	};
})();

L.MarkerCluster.include({
	getConvexHull: function getConvexHull() {
		var childMarkers = this.getAllChildMarkers(),
		    points = [],
		    p,
		    i;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			p = childMarkers[i].getLatLng();
			points.push(p);
		}

		return L.QuickHull.getConvexHull(points);
	}
});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

L.MarkerCluster.include({

	_2PI: Math.PI * 2,
	_circleFootSeparation: 25, //related to circumference of circle
	_circleStartAngle: 0,

	_spiralFootSeparation: 28, //related to size of spiral (experiment!)
	_spiralLengthStart: 11,
	_spiralLengthFactor: 5,

	_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
	// 0 -> always spiral; Infinity -> always circle

	spiderfy: function spiderfy() {
		if (this._group._spiderfied === this || this._group._inZoomAnimation) {
			return;
		}

		var childMarkers = this.getAllChildMarkers(),
		    group = this._group,
		    map = group._map,
		    center = map.latLngToLayerPoint(this._latlng),
		    positions;

		this._group._unspiderfy();
		this._group._spiderfied = this;

		//TODO Maybe: childMarkers order by distance to center

		if (childMarkers.length >= this._circleSpiralSwitchover) {
			positions = this._generatePointsSpiral(childMarkers.length, center);
		} else {
			center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.
			positions = this._generatePointsCircle(childMarkers.length, center);
		}

		this._animationSpiderfy(childMarkers, positions);
	},

	unspiderfy: function unspiderfy(zoomDetails) {
		/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
		if (this._group._inZoomAnimation) {
			return;
		}
		this._animationUnspiderfy(zoomDetails);

		this._group._spiderfied = null;
	},

	_generatePointsCircle: function _generatePointsCircle(count, centerPt) {
		var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
		    legLength = circumference / this._2PI,
		    //radius from circumference
		angleStep = this._2PI / count,
		    res = [],
		    i,
		    angle;

		legLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.

		res.length = count;

		for (i = 0; i < count; i++) {
			// Clockwise, like spiral.
			angle = this._circleStartAngle + i * angleStep;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
		}

		return res;
	},

	_generatePointsSpiral: function _generatePointsSpiral(count, centerPt) {
		var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,
		    legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,
		    separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,
		    lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,
		    angle = 0,
		    res = [],
		    i;

		res.length = count;

		// Higher index, closer position to cluster center.
		for (i = count; i >= 0; i--) {
			// Skip the first position, so that we are already farther from center and we avoid
			// being under the default cluster icon (especially important for Circle Markers).
			if (i < count) {
				res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			}
			angle += separation / legLength + i * 0.0005;
			legLength += lengthFactor / angle;
		}
		return res;
	},

	_noanimationUnspiderfy: function _noanimationUnspiderfy() {
		var group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    childMarkers = this.getAllChildMarkers(),
		    m,
		    i;

		group._ignoreMove = true;

		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			fg.removeLayer(m);

			if (m._preSpiderfyLatlng) {
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;
			}
			if (m.setZIndexOffset) {
				m.setZIndexOffset(0);
			}

			if (m._spiderLeg) {
				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
		}

		group.fire('unspiderfied', {
			cluster: this,
			markers: childMarkers
		});
		group._ignoreMove = false;
		group._spiderfied = null;
	}
});

//Non Animated versions of everything
L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
	_animationSpiderfy: function _animationSpiderfy(childMarkers, positions) {
		var group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    legOptions = this._group.options.spiderLegPolylineOptions,
		    i,
		    m,
		    leg,
		    newPos;

		group._ignoreMove = true;

		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([this._latlng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Now add the marker.
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
			}

			fg.addLayer(m);
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;
		group.fire('spiderfied', {
			cluster: this,
			markers: childMarkers
		});
	},

	_animationUnspiderfy: function _animationUnspiderfy() {
		this._noanimationUnspiderfy();
	}
});

//Animated versions here
L.MarkerCluster.include({

	_animationSpiderfy: function _animationSpiderfy(childMarkers, positions) {
		var me = this,
		    group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    thisLayerLatLng = this._latlng,
		    thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),
		    svg = L.Path.SVG,
		    legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions),
		    // Copy the options so that we can modify them for animation.
		finalLegOpacity = legOptions.opacity,
		    i,
		    m,
		    leg,
		    legPath,
		    legLength,
		    newPos;

		if (finalLegOpacity === undefined) {
			finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;
		}

		if (svg) {
			// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.
			legOptions.opacity = 0;

			// Add the class for CSS transitions.
			legOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';
		} else {
			// Make sure we have a defined opacity.
			legOptions.opacity = finalLegOpacity;
		}

		group._ignoreMove = true;

		// Add markers and spider legs to map, hidden at our center point.
		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			m = childMarkers[i];

			newPos = map.layerPointToLatLng(positions[i]);

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([thisLayerLatLng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/
			// In our case the transition property is declared in the CSS file.
			if (svg) {
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.
				legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.
				legPath.style.strokeDashoffset = legLength;
			}

			// If it is a marker, add it now and we'll animate it out
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING
			}
			if (m.clusterHide) {
				m.clusterHide();
			}

			// Vectors just get immediately added
			fg.addLayer(m);

			if (m._setPos) {
				m._setPos(thisLayerPos);
			}
		}

		group._forceLayout();
		group._animationStart();

		// Reveal markers and spider legs.
		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			//Move marker to new position
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);

			if (m.clusterShow) {
				m.clusterShow();
			}

			// Animate leg (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legPath.style.strokeDashoffset = 0;
				//legPath.style.strokeOpacity = finalLegOpacity;
				leg.setStyle({ opacity: finalLegOpacity });
			}
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;

		setTimeout(function () {
			group._animationEnd();
			group.fire('spiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	},

	_animationUnspiderfy: function _animationUnspiderfy(zoomDetails) {
		var me = this,
		    group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
		    childMarkers = this.getAllChildMarkers(),
		    svg = L.Path.SVG,
		    m,
		    i,
		    leg,
		    legPath,
		    legLength,
		    nonAnimatable;

		group._ignoreMove = true;
		group._animationStart();

		//Make us visible and bring the child markers back in
		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//Marker was added to us after we were spiderfied
			if (!m._preSpiderfyLatlng) {
				continue;
			}

			//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll
			m.closePopup();

			//Fix up the location to the real one
			m.setLatLng(m._preSpiderfyLatlng);
			delete m._preSpiderfyLatlng;

			//Hack override the location to be our center
			nonAnimatable = true;
			if (m._setPos) {
				m._setPos(thisLayerPos);
				nonAnimatable = false;
			}
			if (m.clusterHide) {
				m.clusterHide();
				nonAnimatable = false;
			}
			if (nonAnimatable) {
				fg.removeLayer(m);
			}

			// Animate the spider leg back in (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1;
				legPath.style.strokeDashoffset = legLength;
				leg.setStyle({ opacity: 0 });
			}
		}

		group._ignoreMove = false;

		setTimeout(function () {
			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
			var stillThereChildCount = 0;
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];
				if (m._spiderLeg) {
					stillThereChildCount++;
				}
			}

			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				if (!m._spiderLeg) {
					//Has already been unspiderfied
					continue;
				}

				if (m.clusterShow) {
					m.clusterShow();
				}
				if (m.setZIndexOffset) {
					m.setZIndexOffset(0);
				}

				if (stillThereChildCount > 1) {
					fg.removeLayer(m);
				}

				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
			group._animationEnd();
			group.fire('unspiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	}
});

L.MarkerClusterGroup.include({
	//The MarkerCluster currently spiderfied (if any)
	_spiderfied: null,

	unspiderfy: function unspiderfy() {
		this._unspiderfy.apply(this, arguments);
	},

	_spiderfierOnAdd: function _spiderfierOnAdd() {
		this._map.on('click', this._unspiderfyWrapper, this);

		if (this._map.options.zoomAnimation) {
			this._map.on('zoomstart', this._unspiderfyZoomStart, this);
		}
		//Browsers without zoomAnimation or a big zoom don't fire zoomstart
		this._map.on('zoomend', this._noanimationUnspiderfy, this);

		if (!L.Browser.touch) {
			this._map.getRenderer(this);
			//Needs to happen in the pageload, not after, or animations don't work in webkit
			//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
			//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
		}
	},

	_spiderfierOnRemove: function _spiderfierOnRemove() {
		this._map.off('click', this._unspiderfyWrapper, this);
		this._map.off('zoomstart', this._unspiderfyZoomStart, this);
		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._map.off('zoomend', this._noanimationUnspiderfy, this);

		//Ensure that markers are back where they should be
		// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane
		this._noanimationUnspiderfy();
	},

	//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
	//This means we can define the animation they do rather than Markers doing an animation to their actual location
	_unspiderfyZoomStart: function _unspiderfyZoomStart() {
		if (!this._map) {
			//May have been removed from the map by a zoomEnd handler
			return;
		}

		this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
	},

	_unspiderfyZoomAnim: function _unspiderfyZoomAnim(zoomDetails) {
		//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
		if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
			return;
		}

		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._unspiderfy(zoomDetails);
	},

	_unspiderfyWrapper: function _unspiderfyWrapper() {
		/// <summary>_unspiderfy but passes no arguments</summary>
		this._unspiderfy();
	},

	_unspiderfy: function _unspiderfy(zoomDetails) {
		if (this._spiderfied) {
			this._spiderfied.unspiderfy(zoomDetails);
		}
	},

	_noanimationUnspiderfy: function _noanimationUnspiderfy() {
		if (this._spiderfied) {
			this._spiderfied._noanimationUnspiderfy();
		}
	},

	//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
	_unspiderfyLayer: function _unspiderfyLayer(layer) {
		if (layer._spiderLeg) {
			this._featureGroup.removeLayer(layer);

			if (layer.clusterShow) {
				layer.clusterShow();
			}
			//Position will be fixed up immediately in _animationUnspiderfy
			if (layer.setZIndexOffset) {
				layer.setZIndexOffset(0);
			}

			this._map.removeLayer(layer._spiderLeg);
			delete layer._spiderLeg;
		}
	}
});

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
 * markers' icon options and refreshing their icon and their parent clusters
 * accordingly (case where their iconCreateFunction uses data of childMarkers
 * to make up the cluster icon).
 */

L.MarkerClusterGroup.include({
	/**
  * Updates the icon of all clusters which are parents of the given marker(s).
  * In singleMarkerMode, also updates the given marker(s) icon.
  * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
  * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
  * clusters need to be updated. If not provided, retrieves all child markers of this.
  * @returns {L.MarkerClusterGroup}
  */
	refreshClusters: function refreshClusters(layers) {
		if (!layers) {
			layers = this._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.MarkerClusterGroup) {
			layers = layers._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.LayerGroup) {
			layers = layers._layers;
		} else if (layers instanceof L.MarkerCluster) {
			layers = layers.getAllChildMarkers();
		} else if (layers instanceof L.Marker) {
			layers = [layers];
		} // else: must be an Array(L.Marker)|Map(L.Marker)
		this._flagParentsIconsNeedUpdate(layers);
		this._refreshClustersIcons();

		// In case of singleMarkerMode, also re-draw the markers.
		if (this.options.singleMarkerMode) {
			this._refreshSingleMarkerModeMarkers(layers);
		}

		return this;
	},

	/**
  * Simply flags all parent clusters of the given markers as having a "dirty" icon.
  * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
  * @private
  */
	_flagParentsIconsNeedUpdate: function _flagParentsIconsNeedUpdate(layers) {
		var id, parent;

		// Assumes layers is an Array or an Object whose prototype is non-enumerable.
		for (id in layers) {
			// Flag parent clusters' icon as "dirty", all the way up.
			// Dumb process that flags multiple times upper parents, but still
			// much more efficient than trying to be smart and make short lists,
			// at least in the case of a hierarchy following a power law:
			// http://jsperf.com/flag-nodes-in-power-hierarchy/2
			parent = layers[id].__parent;
			while (parent) {
				parent._iconNeedsUpdate = true;
				parent = parent.__parent;
			}
		}
	},

	/**
  * Re-draws the icon of the supplied markers.
  * To be used in singleMarkerMode only.
  * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
  * @private
  */
	_refreshSingleMarkerModeMarkers: function _refreshSingleMarkerModeMarkers(layers) {
		var id, layer;

		for (id in layers) {
			layer = layers[id];

			// Make sure we do not override markers that do not belong to THIS group.
			if (this.hasLayer(layer)) {
				// Need to re-create the icon first, then re-draw the marker.
				layer.setIcon(this._overrideMarkerIcon(layer));
			}
		}
	}
});

L.Marker.include({
	/**
  * Updates the given options in the marker's icon and refreshes the marker.
  * @param options map object of icon options.
  * @param directlyRefreshClusters boolean (optional) true to trigger
  * MCG.refreshClustersOf() right away with this single marker.
  * @returns {L.Marker}
  */
	refreshIconOptions: function refreshIconOptions(options, directlyRefreshClusters) {
		var icon = this.options.icon;

		L.setOptions(icon, options);

		this.setIcon(icon);

		// Shortcut to refresh the associated MCG clusters right away.
		// To be used when refreshing a single marker.
		// Otherwise, better use MCG.refreshClusters() once at the end with
		// the list of modified markers.
		if (directlyRefreshClusters && this.__parent) {
			this.__parent._group.refreshClusters(this);
		}

		return this;
	}
});

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "<link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\" integrity=\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\"\n  crossorigin=\"anonymous\">\n<link href=\"https://fonts.googleapis.com/css?family=Lato:300,400,400i,900\" rel=\"stylesheet\">\n<link href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\" rel=\"stylesheet\" integrity=\"sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN\"\n  crossorigin=\"anonymous\">\n\n\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css\" media=\"screen\">\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css\" media=\"screen\">\n\n\n<style>\n   :host {\n    font-family: 'Lato', sans-serif;\n    --primary-color: #003d7d;\n    --secondary-color: #ff4b5f;\n  }\n\n  main.card {\n    position: absolute;\n    left: 15px;\n    top: 15px;\n    bottom: 15px;\n    width: 300px;\n    z-index: 1005;\n\n    background-color: #fff;\n    box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.3);\n\n    transition: transform 175ms;\n  }\n\n  a {\n    color: var(--primary-color, inherit);\n  }\n\n  .btn-primary {\n    color: #fff;\n    background-color: var(--primary-color, inherit);\n    border-color: var(--primary-color, inherit);\n  }\n\n  header#page-title {\n    padding: 10px;\n    background-color: var(--primary-color);\n    height: 150px;\n  }\n\n  header#page-title h1 {\n    color: #fff;\n    font-weight: 900;\n  }\n\n  section#overlays {\n    overflow: auto;\n    padding-bottom: 5px;\n  }\n\n  section#overlays>ul>li.list-group-item {\n    padding: 0;\n  }\n\n  section#overlays .overlay-item {\n    font-size: 1.1rem;\n    padding: 0.75rem 1.25rem;\n    color: #444;\n  }\n\n  section#overlays .overlay-item:hover {\n    cursor: pointer;\n    background-color: #eee;\n  }\n\n  section#overlays .overlay-item.selected {\n    background-color: #ddd;\n    color: var(--primary-color);\n\n    /* left border and offset text back */\n    border-left: 0.25rem solid var(--primary-color);\n    padding-left: 1rem;\n  }\n\n  ul.overlay-layers>li.list-group-item {\n    border: 0;\n    border-left: 0.25rem solid var(--primary-color);\n    padding-left: 1.75rem;\n    background-color: #eee;\n    cursor: pointer;\n  }\n\n  ul.overlay-layers .overlay-layers-toggle {\n    --primary-color: var(--secondary-color);\n  }\n\n  button#basemap-switcher,\n  button#layers-menu-toggle {\n    position: absolute;\n    right: 30px;\n    width: 160px;\n    height: 90px;\n    z-index: 1001;\n    border: 5px solid #ffffff;\n    box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.3);\n    cursor: pointer;\n  }\n\n  button#basemap-switcher {\n    background-image: url('./aerial.png');\n    bottom: 30px;\n  }\n\n  button#layers-menu-toggle {\n    display: none;\n    bottom: 130px;\n  }\n\n  section#download-disclaimer {\n    max-height: 400px;\n    overflow: auto;\n    text-align: justify;\n  }\n\n  .show-mobile {\n    display: none;\n  }\n\n  @media (max-width: 600px) {\n    main.card {\n      right: 30px;\n      left: 30px;\n      top: 30px;\n      bottom: 30px;\n      width: unset;\n      transform: scale(0);\n    }\n\n    main.show {\n      transform: scale(1);\n    }\n\n    .show-mobile {\n      display: block;\n    }\n\n    button#basemap-switcher,\n    button#layers-menu-toggle {\n      display: block;\n      width: 90px;\n      height: 90px;\n      border-radius: 90px;\n    }\n  }\n</style>\n\n<!--link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\" integrity=\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\" crossorigin=\"anonymous\"-->\n\n<main id=\"layers-menu\" class=\"card\">\n  <header id=\"page-title\" class=\"card-img-top d-flex align-items-end\">\n    <h1 class=\"h2\">[[mapTitle]]</h1>\n  </header>\n\n  <!-- Search section -->\n  <section id=\"search-section\" class=\"input-group\">\n    <input type=\"text\" name=\"search\" id=\"search\" class=\"form-control rounded-0\" placeholder=\"Search address\">\n    <span class=\"input-group-btn rounded-0\">\n      <button class=\"btn btn-secondary rounded-0\">\n        <i class=\"fa fa-fw fa-search\"></i>\n      </button>\n    </span>\n  </section>\n\n  <!-- List of available overlays -->\n  <section id=\"overlays\">\n    <ul class=\"list-group\">\n\n      <template is=\"dom-repeat\" items=\"{{overlayMaps}}\">\n        <li class=\"list-group-item\">\n\n          <!-- Main overlay toggle -->\n          <template is=\"dom-if\" if=\"{{!flat}}\">\n            <div title=\"[[item.description]]\" class$=\"[[_overlayItemClass(selectedOverlay, item)]]\" on-click=\"overlaySelect\">\n              <paper-toggle-button checked=\"[[_isCurrentOverlay(selectedOverlay, item)]]\"></paper-toggle-button>\n              <span>[[item.name]]</span>\n            </div>\n          </template>\n\n          <div class$=\"[[_overlayLayersShow(selectedOverlay, item)]]\">\n            <ul class=\"overlay-layers list-group list-group-flush\">\n\n              <!-- Exclusive layers -->\n              <template is=\"dom-repeat\" items=\"{{item.layers.exclusives}}\" as=\"layer\">\n                <li class=\"list-group-item d-flex justify-content-start\" on-click=\"toggleLayer\">\n                  <paper-toggle-button class=\"overlay-layers-toggle\" checked=\"[[_isCurrentExclusive(layer, wmsGroups)]]\"></paper-toggle-button>\n                  <span class=\"mr-auto\">\n                    [[layer.name]]\n                  </span>\n                  <a href=\"#\" on-click=\"downloadLayer\" class=\"justify-self-end\"><i title=\"Download [[layer.name]]\" class=\"fa fa-fw fa-download\"></i></a>\n                </li>\n              </template>\n\n              <!-- Optional layers -->\n              <template is=\"dom-repeat\" items=\"{{item.layers.optionals}}\" as=\"layer\">\n                <li class=\"list-group-item d-flex justify-content-start\" on-click=\"toggleLayer\">\n                  <paper-toggle-button class=\"overlay-layers-toggle\" checked=\"[[layer.visible]]\"></paper-toggle-button>\n                  <span class=\"mr-auto\">\n                    [[layer.name]]\n                  </span>\n                  <a href=\"#\" on-click=\"downloadLayer\" class=\"justify-self-end\"><i title=\"Download [[layer.name]]\" class=\"fa fa-fw fa-download\"></i></a>\n                </li>\n              </template>\n\n            </ul>\n          </div>\n\n        </li>\n      </template>\n\n    </ul>\n  </section>\n\n  <footer class=\"card-body\">\n    <!-- <a href=\"#\" class=\"btn btn-link\">Help</a>\n    <a href=\"#\" class=\"btn btn-link\">Tour</a> -->\n    <div class=\"pull-right show-mobile\">\n      <a href=\"#\" class=\"btn btn-primary\" on-click=\"toggleLayersMenu\">\n        <i class=\"fa fa-map\"></i>\n        View Map\n      </a>\n    </div>\n  </footer>\n</main>\n\n<!-- Basemap toggle button -->\n<button id=\"basemap-switcher\" on-click=\"switchBasemap\"></button>\n\n<!-- Layers control menu (mobile only) -->\n<button id=\"layers-menu-toggle\" class=\"btn btn-primary\" on-click=\"toggleLayersMenu\"><i class=\"fa fa-bars fa-3x\"></i></button>\n\n<leaflet-map map=\"{{map}}\" latitude=\"33.778724\" longitude=\"-117.960058\" zoom=\"13\" min-zoom=\"11\" max-zoom=\"19\" attribution-prefix=\"City of Garden Grove\">\n\n  <template is=\"dom-if\" if=\"{{baseSource}}\" restamp>\n    <leaflet-tile-layer map=\"{{map}}\" url=\"[[baseSource]]\" format=\"[[baseFormat]]\" layers=\"[[baseLayers]]\" attribution=\"&copy; OpenStreetMap\">\n    </leaflet-tile-layer>\n  </template>\n\n  <template is=\"dom-repeat\" items=\"{{wmsGroups}}\" as=\"group\">\n    <leaflet-wms-group map=\"{{map}}\" source=\"[[group.source]]\" layers=\"[[group.layers]]\" transparent format=\"image/png\" identify=\"[[group.identify]]\" info-format=\"[[group.infoFormat]]\">\n    </leaflet-wms-group>\n  </template>\n\n  <template is=\"dom-repeat\" items=\"{{geojsonLayers}}\" as=\"layer\">\n    <leaflet-geojson-points map=\"{{map}}\" source$=\"[[layer.source]]\" radius$=\"[[layer.radius]]\" weight$=\"[[layer.weight]]\" max-cluster-radius$=\"[[layer.maxClusterRadius]]\"\n      fill-color$=\"[[layer.fillColor]]\" outline-color$=\"[[layer.outlineColor]]\" opacity$=\"[[layer.opacity]]\" fill-opacity$=\"[[layer.fillOpacity]]\" identify$=\"[[layer.identify]]\"\n      attribution$=\"[[layer.attribution]]\" cluster$=\"[[layer.cluster]]\">\n    </leaflet-geojson-points>\n  </template>\n</leaflet-map>\n\n<!-- Download Modal -->\n<div class=\"modal fade\" id=\"download-modal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"download-modal-label\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h3 class=\"modal-title\" id=\"download-modal-label\">\n          <span id=\"layer-name\"></span>\n        </h3>\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n          <span aria-hidden=\"true\">&times;</span>\n        </button>\n      </div>\n      <div class=\"modal-body\">\n        <section style=\"height: 400px; overflow: auto; padding: 10px; background-color: #eee; font-size: 0.85rem;\">\n          <h5>Download Disclaimer</h5>\n\n          <p>The City of Garden Grove provides the data as a public resource of general information for use \"as is.\" The City\n            of Garden Grove provides this information with the understanding that it is not guaranteed to be accurate, correct\n            or complete and any conclusions drawn from such information are the sole responsibility of the user. Further,\n            the City of Garden Grove makes no warranty, representation or guaranty as to the content, sequence, accuracy,\n            timeliness or completeness of any of the spatial or database information provided herein. While every effort\n            has been made to ensure the content, sequence, accuracy, timeliness or completeness of materials presented within\n            these pages, the City of Garden Grove assumes no responsibility for errors or omissions, and explicitly disclaims\n            any representations and warranties, including, without limitation, the implied warranties of merchantability\n            and fitness for a particular purpose. The City of Garden Grove shall assume no liability for:</p>\n          <p>1.Any errors, omissions, or inaccuracies in the information provided, regardless of how caused; or 2.Any decision\n            made or action taken or not taken by viewer in reliance upon any information or data furnished hereunder.</p>\n          <p>Availability of the City of Garden Grove GIS is not guaranteed. Applications, servers, and network connections\n            may be unavailable at any time for maintenance or unscheduled outages. Outages may be of long duration. Users\n            are cautioned to create dependencies on these services for critical needs.</p>\n          <p>THE FOREGOING WARRANTY IS EXCLUSIVE AND IN LIEU OF ALL OTHER WARRANTIES OF MERCHANTABILITY, FITNESS FOR PARTICULAR\n            PURPOSE AND/OR ANY OTHER TYPE WHETHER EXPRESSED OR IMPLIED. In no event shall The City of Garden Grove become\n            liable to users of these data, or any other party, for any loss or direct, indirect, special, incidental or consequential\n            damages, including, but not limited to, time, money or goodwill, arising from the use or modification of the\n            data.\n          </p>\n          <p>To assist The City of Garden Grove in the maintenance and/or correction of the data, users should provide the City\n            of Garden Grove with information concerning errors or discrepancies found in using the data. Please acknowledge\n            the City of Garden Grove as the source when data is used in the preparation of reports, papers, publications,\n            maps, or other products.</p>\n        </section>\n      </div>\n      <div class=\"modal-footer\">\n        <!--button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\">Close</button-->\n        <span id=\"download-buttons-label\">Download as:</span>\n        <a id=\"geojson-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>GeoJSON\n        </a>\n        <a id=\"csv-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>CSV\n        </a>\n        <a id=\"kml-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>KML\n        </a>\n        <a id=\"shapefile-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>Shapefile\n        </a>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e) {
  if ("object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
    ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).jsyaml = e();
  }
}(function () {
  return function e(t, n, i) {
    function r(a, s) {
      if (!n[a]) {
        if (!t[a]) {
          var c = "function" == typeof require && require;if (!s && c) return require(a, !0);if (o) return o(a, !0);var u = new Error("Cannot find module '" + a + "'");throw u.code = "MODULE_NOT_FOUND", u;
        }var l = n[a] = { exports: {} };t[a][0].call(l.exports, function (e) {
          var n = t[a][1][e];return r(n || e);
        }, l, l.exports, e, t, n, i);
      }return n[a].exports;
    }for (var o = "function" == typeof require && require, a = 0; a < i.length; a++) {
      r(i[a]);
    }return r;
  }({ 1: [function (e, t, n) {
      "use strict";
      function i(e) {
        return function () {
          throw new Error("Function " + e + " is deprecated and cannot be used.");
        };
      }var r = e("./js-yaml/loader"),
          o = e("./js-yaml/dumper");t.exports.Type = e("./js-yaml/type"), t.exports.Schema = e("./js-yaml/schema"), t.exports.FAILSAFE_SCHEMA = e("./js-yaml/schema/failsafe"), t.exports.JSON_SCHEMA = e("./js-yaml/schema/json"), t.exports.CORE_SCHEMA = e("./js-yaml/schema/core"), t.exports.DEFAULT_SAFE_SCHEMA = e("./js-yaml/schema/default_safe"), t.exports.DEFAULT_FULL_SCHEMA = e("./js-yaml/schema/default_full"), t.exports.load = r.load, t.exports.loadAll = r.loadAll, t.exports.safeLoad = r.safeLoad, t.exports.safeLoadAll = r.safeLoadAll, t.exports.dump = o.dump, t.exports.safeDump = o.safeDump, t.exports.YAMLException = e("./js-yaml/exception"), t.exports.MINIMAL_SCHEMA = e("./js-yaml/schema/failsafe"), t.exports.SAFE_SCHEMA = e("./js-yaml/schema/default_safe"), t.exports.DEFAULT_SCHEMA = e("./js-yaml/schema/default_full"), t.exports.scan = i("scan"), t.exports.parse = i("parse"), t.exports.compose = i("compose"), t.exports.addConstructor = i("addConstructor");
    }, { "./js-yaml/dumper": 3, "./js-yaml/exception": 4, "./js-yaml/loader": 5, "./js-yaml/schema": 7, "./js-yaml/schema/core": 8, "./js-yaml/schema/default_full": 9, "./js-yaml/schema/default_safe": 10, "./js-yaml/schema/failsafe": 11, "./js-yaml/schema/json": 12, "./js-yaml/type": 13 }], 2: [function (e, t, n) {
      "use strict";
      function i(e) {
        return void 0 === e || null === e;
      }t.exports.isNothing = i, t.exports.isObject = function (e) {
        return "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e;
      }, t.exports.toArray = function (e) {
        return Array.isArray(e) ? e : i(e) ? [] : [e];
      }, t.exports.repeat = function (e, t) {
        var n,
            i = "";for (n = 0; n < t; n += 1) {
          i += e;
        }return i;
      }, t.exports.isNegativeZero = function (e) {
        return 0 === e && Number.NEGATIVE_INFINITY === 1 / e;
      }, t.exports.extend = function (e, t) {
        var n, i, r, o;if (t) for (n = 0, i = (o = Object.keys(t)).length; n < i; n += 1) {
          e[r = o[n]] = t[r];
        }return e;
      };
    }, {}], 3: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        var n, i, r, o, a, s, c;if (null === t) return {};for (n = {}, r = 0, o = (i = Object.keys(t)).length; r < o; r += 1) {
          a = i[r], s = String(t[a]), "!!" === a.slice(0, 2) && (a = "tag:yaml.org,2002:" + a.slice(2)), (c = e.compiledTypeMap.fallback[a]) && T.call(c.styleAliases, s) && (s = c.styleAliases[s]), n[a] = s;
        }return n;
      }function r(e) {
        var t, n, i;if (t = e.toString(16).toUpperCase(), e <= 255) n = "x", i = 2;else if (e <= 65535) n = "u", i = 4;else {
          if (!(e <= 4294967295)) throw new F("code point within a string may not be greater than 0xFFFFFFFF");n = "U", i = 8;
        }return "\\" + n + E.repeat("0", i - t.length) + t;
      }function o(e) {
        this.schema = e.schema || _, this.indent = Math.max(1, e.indent || 2), this.skipInvalid = e.skipInvalid || !1, this.flowLevel = E.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = i(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
      }function a(e, t) {
        for (var n, i = E.repeat(" ", t), r = 0, o = -1, a = "", s = e.length; r < s;) {
          -1 === (o = e.indexOf("\n", r)) ? (n = e.slice(r), r = s) : (n = e.slice(r, o + 1), r = o + 1), n.length && "\n" !== n && (a += i), a += n;
        }return a;
      }function s(e, t) {
        return "\n" + E.repeat(" ", e.indent * t);
      }function c(e, t) {
        var n, i;for (n = 0, i = e.implicitTypes.length; n < i; n += 1) {
          if (e.implicitTypes[n].resolve(t)) return !0;
        }return !1;
      }function u(e) {
        return e === U || e === L;
      }function l(e) {
        return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && 8232 !== e && 8233 !== e || 57344 <= e && e <= 65533 && 65279 !== e || 65536 <= e && e <= 1114111;
      }function p(e) {
        return l(e) && 65279 !== e && e !== $ && e !== J && e !== Q && e !== ee && e !== ne && e !== G && e !== R;
      }function f(e) {
        return l(e) && 65279 !== e && !u(e) && e !== H && e !== Z && e !== G && e !== $ && e !== J && e !== Q && e !== ee && e !== ne && e !== R && e !== W && e !== K && e !== q && e !== te && e !== V && e !== B && e !== Y && e !== P && e !== z && e !== X;
      }function d(e, t, n, i, r) {
        var o,
            a,
            s = !1,
            c = !1,
            d = -1 !== i,
            h = -1,
            m = f(e.charCodeAt(0)) && !u(e.charCodeAt(e.length - 1));if (t) for (o = 0; o < e.length; o++) {
          if (a = e.charCodeAt(o), !l(a)) return ue;m = m && p(a);
        } else {
          for (o = 0; o < e.length; o++) {
            if ((a = e.charCodeAt(o)) === D) s = !0, d && (c = c || o - h - 1 > i && " " !== e[h + 1], h = o);else if (!l(a)) return ue;m = m && p(a);
          }c = c || d && o - h - 1 > i && " " !== e[h + 1];
        }return s || c ? " " === e[0] && n > 9 ? ue : c ? ce : se : m && !r(e) ? oe : ae;
      }function h(e, t, n, i) {
        e.dump = function () {
          if (0 === t.length) return "''";if (!e.noCompatMode && -1 !== re.indexOf(t)) return "'" + t + "'";var r = e.indent * Math.max(1, n),
              o = -1 === e.lineWidth ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - r),
              s = i || e.flowLevel > -1 && n >= e.flowLevel;switch (d(t, s, e.indent, o, function (t) {
            return c(e, t);
          })) {case oe:
              return t;case ae:
              return "'" + t.replace(/'/g, "''") + "'";case se:
              return "|" + m(t, e.indent) + g(a(t, r));case ce:
              return ">" + m(t, e.indent) + g(a(y(t, o), r));case ue:
              return '"' + v(t) + '"';default:
              throw new F("impossible error: invalid scalar style");}
        }();
      }function m(e, t) {
        var n = " " === e[0] ? String(t) : "",
            i = "\n" === e[e.length - 1];return n + (i && ("\n" === e[e.length - 2] || "\n" === e) ? "+" : i ? "" : "-") + "\n";
      }function g(e) {
        return "\n" === e[e.length - 1] ? e.slice(0, -1) : e;
      }function y(e, t) {
        for (var n, i, r = /(\n+)([^\n]*)/g, o = function () {
          var n = e.indexOf("\n");return n = -1 !== n ? n : e.length, r.lastIndex = n, x(e.slice(0, n), t);
        }(), a = "\n" === e[0] || " " === e[0]; i = r.exec(e);) {
          var s = i[1],
              c = i[2];n = " " === c[0], o += s + (a || n || "" === c ? "" : "\n") + x(c, t), a = n;
        }return o;
      }function x(e, t) {
        if ("" === e || " " === e[0]) return e;for (var n, i, r = / [^ ]/g, o = 0, a = 0, s = 0, c = ""; n = r.exec(e);) {
          (s = n.index) - o > t && (i = a > o ? a : s, c += "\n" + e.slice(o, i), o = i + 1), a = s;
        }return c += "\n", e.length - o > t && a > o ? c += e.slice(o, a) + "\n" + e.slice(a + 1) : c += e.slice(o), c.slice(1);
      }function v(e) {
        for (var t, n, i, o = "", a = 0; a < e.length; a++) {
          (t = e.charCodeAt(a)) >= 55296 && t <= 56319 && (n = e.charCodeAt(a + 1)) >= 56320 && n <= 57343 ? (o += r(1024 * (t - 55296) + n - 56320 + 65536), a++) : o += !(i = ie[t]) && l(t) ? e[a] : i || r(t);
        }return o;
      }function A(e, t, n) {
        var i,
            r,
            o = "",
            a = e.tag;for (i = 0, r = n.length; i < r; i += 1) {
          j(e, t, n[i], !1, !1) && (0 !== i && (o += "," + (e.condenseFlow ? "" : " ")), o += e.dump);
        }e.tag = a, e.dump = "[" + o + "]";
      }function b(e, t, n, i) {
        var r,
            o,
            a = "",
            c = e.tag;for (r = 0, o = n.length; r < o; r += 1) {
          j(e, t + 1, n[r], !0, !0) && (i && 0 === r || (a += s(e, t)), e.dump && D === e.dump.charCodeAt(0) ? a += "-" : a += "- ", a += e.dump);
        }e.tag = c, e.dump = a || "[]";
      }function w(e, t, n) {
        var i,
            r,
            o,
            a,
            s,
            c = "",
            u = e.tag,
            l = Object.keys(n);for (i = 0, r = l.length; i < r; i += 1) {
          s = e.condenseFlow ? '"' : "", 0 !== i && (s += ", "), a = n[o = l[i]], j(e, t, o, !1, !1) && (e.dump.length > 1024 && (s += "? "), s += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), j(e, t, a, !1, !1) && (c += s += e.dump));
        }e.tag = u, e.dump = "{" + c + "}";
      }function C(e, t, n, i) {
        var r,
            o,
            a,
            c,
            u,
            l,
            p = "",
            f = e.tag,
            d = Object.keys(n);if (!0 === e.sortKeys) d.sort();else if ("function" == typeof e.sortKeys) d.sort(e.sortKeys);else if (e.sortKeys) throw new F("sortKeys must be a boolean or a function");for (r = 0, o = d.length; r < o; r += 1) {
          l = "", i && 0 === r || (l += s(e, t)), c = n[a = d[r]], j(e, t + 1, a, !0, !0, !0) && ((u = null !== e.tag && "?" !== e.tag || e.dump && e.dump.length > 1024) && (e.dump && D === e.dump.charCodeAt(0) ? l += "?" : l += "? "), l += e.dump, u && (l += s(e, t)), j(e, t + 1, c, !0, u) && (e.dump && D === e.dump.charCodeAt(0) ? l += ":" : l += ": ", p += l += e.dump));
        }e.tag = f, e.dump = p || "{}";
      }function k(e, t, n) {
        var i, r, o, a, s, c;for (o = 0, a = (r = n ? e.explicitTypes : e.implicitTypes).length; o < a; o += 1) {
          if (((s = r[o]).instanceOf || s.predicate) && (!s.instanceOf || "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t instanceof s.instanceOf) && (!s.predicate || s.predicate(t))) {
            if (e.tag = n ? s.tag : "?", s.represent) {
              if (c = e.styleMap[s.tag] || s.defaultStyle, "[object Function]" === M.call(s.represent)) i = s.represent(t, c);else {
                if (!T.call(s.represent, c)) throw new F("!<" + s.tag + '> tag resolver accepts not "' + c + '" style');i = s.represent[c](t, c);
              }e.dump = i;
            }return !0;
          }
        }return !1;
      }function j(e, t, n, i, r, o) {
        e.tag = null, e.dump = n, k(e, n, !1) || k(e, n, !0);var a = M.call(e.dump);i && (i = e.flowLevel < 0 || e.flowLevel > t);var s,
            c,
            u = "[object Object]" === a || "[object Array]" === a;if (u && (c = -1 !== (s = e.duplicates.indexOf(n))), (null !== e.tag && "?" !== e.tag || c || 2 !== e.indent && t > 0) && (r = !1), c && e.usedDuplicates[s]) e.dump = "*ref_" + s;else {
          if (u && c && !e.usedDuplicates[s] && (e.usedDuplicates[s] = !0), "[object Object]" === a) i && 0 !== Object.keys(e.dump).length ? (C(e, t, e.dump, r), c && (e.dump = "&ref_" + s + e.dump)) : (w(e, t, e.dump), c && (e.dump = "&ref_" + s + " " + e.dump));else if ("[object Array]" === a) i && 0 !== e.dump.length ? (b(e, t, e.dump, r), c && (e.dump = "&ref_" + s + e.dump)) : (A(e, t, e.dump), c && (e.dump = "&ref_" + s + " " + e.dump));else {
            if ("[object String]" !== a) {
              if (e.skipInvalid) return !1;throw new F("unacceptable kind of an object to dump " + a);
            }"?" !== e.tag && h(e, e.dump, t, o);
          }null !== e.tag && "?" !== e.tag && (e.dump = "!<" + e.tag + "> " + e.dump);
        }return !0;
      }function I(e, t) {
        var n,
            i,
            r = [],
            o = [];for (S(e, r, o), n = 0, i = o.length; n < i; n += 1) {
          t.duplicates.push(r[o[n]]);
        }t.usedDuplicates = new Array(i);
      }function S(e, t, n) {
        var i, r, o;if (null !== e && "object" == (typeof e === "undefined" ? "undefined" : _typeof(e))) if (-1 !== (r = t.indexOf(e))) -1 === n.indexOf(r) && n.push(r);else if (t.push(e), Array.isArray(e)) for (r = 0, o = e.length; r < o; r += 1) {
          S(e[r], t, n);
        } else for (r = 0, o = (i = Object.keys(e)).length; r < o; r += 1) {
          S(e[i[r]], t, n);
        }
      }function O(e, t) {
        var n = new o(t = t || {});return n.noRefs || I(e, n), j(n, 0, e, !0, !0) ? n.dump + "\n" : "";
      }var E = e("./common"),
          F = e("./exception"),
          _ = e("./schema/default_full"),
          N = e("./schema/default_safe"),
          M = Object.prototype.toString,
          T = Object.prototype.hasOwnProperty,
          L = 9,
          D = 10,
          U = 32,
          q = 33,
          Y = 34,
          R = 35,
          P = 37,
          W = 38,
          B = 39,
          K = 42,
          $ = 44,
          H = 45,
          G = 58,
          V = 62,
          Z = 63,
          z = 64,
          J = 91,
          Q = 93,
          X = 96,
          ee = 123,
          te = 124,
          ne = 125,
          ie = {};ie[0] = "\\0", ie[7] = "\\a", ie[8] = "\\b", ie[9] = "\\t", ie[10] = "\\n", ie[11] = "\\v", ie[12] = "\\f", ie[13] = "\\r", ie[27] = "\\e", ie[34] = '\\"', ie[92] = "\\\\", ie[133] = "\\N", ie[160] = "\\_", ie[8232] = "\\L", ie[8233] = "\\P";var re = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
          oe = 1,
          ae = 2,
          se = 3,
          ce = 4,
          ue = 5;t.exports.dump = O, t.exports.safeDump = function (e, t) {
        return O(e, E.extend({ schema: N }, t));
      };
    }, { "./common": 2, "./exception": 4, "./schema/default_full": 9, "./schema/default_safe": 10 }], 4: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
      }(i.prototype = Object.create(Error.prototype)).constructor = i, i.prototype.toString = function (e) {
        var t = this.name + ": ";return t += this.reason || "(unknown reason)", !e && this.mark && (t += " " + this.mark.toString()), t;
      }, t.exports = i;
    }, {}], 5: [function (e, t, n) {
      "use strict";
      function i(e) {
        return 10 === e || 13 === e;
      }function r(e) {
        return 9 === e || 32 === e;
      }function o(e) {
        return 9 === e || 32 === e || 10 === e || 13 === e;
      }function a(e) {
        return 44 === e || 91 === e || 93 === e || 123 === e || 125 === e;
      }function s(e) {
        var t;return 48 <= e && e <= 57 ? e - 48 : 97 <= (t = 32 | e) && t <= 102 ? t - 97 + 10 : -1;
      }function c(e) {
        return 120 === e ? 2 : 117 === e ? 4 : 85 === e ? 8 : 0;
      }function u(e) {
        return 48 <= e && e <= 57 ? e - 48 : -1;
      }function l(e) {
        return 48 === e ? "\0" : 97 === e ? "" : 98 === e ? "\b" : 116 === e ? "\t" : 9 === e ? "\t" : 110 === e ? "\n" : 118 === e ? "\v" : 102 === e ? "\f" : 114 === e ? "\r" : 101 === e ? "" : 32 === e ? " " : 34 === e ? '"' : 47 === e ? "/" : 92 === e ? "\\" : 78 === e ? "" : 95 === e ? " " : 76 === e ? "\u2028" : 80 === e ? "\u2029" : "";
      }function p(e) {
        return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(55296 + (e - 65536 >> 10), 56320 + (e - 65536 & 1023));
      }function f(e, t) {
        this.input = e, this.filename = t.filename || null, this.schema = t.schema || W, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
      }function d(e, t) {
        return new Y(t, new R(e.filename, e.input, e.position, e.line, e.position - e.lineStart));
      }function h(e, t) {
        throw d(e, t);
      }function m(e, t) {
        e.onWarning && e.onWarning.call(null, d(e, t));
      }function g(e, t, n, i) {
        var r, o, a, s;if (t < n) {
          if (s = e.input.slice(t, n), i) for (r = 0, o = s.length; r < o; r += 1) {
            9 === (a = s.charCodeAt(r)) || 32 <= a && a <= 1114111 || h(e, "expected valid JSON character");
          } else J.test(s) && h(e, "the stream contains non-printable characters");e.result += s;
        }
      }function y(e, t, n, i) {
        var r, o, a, s;for (q.isObject(n) || h(e, "cannot merge mappings; the provided source object is unacceptable"), a = 0, s = (r = Object.keys(n)).length; a < s; a += 1) {
          o = r[a], B.call(t, o) || (t[o] = n[o], i[o] = !0);
        }
      }function x(e, t, n, i, r, o, a, s) {
        var c, u;if (r = String(r), null === t && (t = {}), "tag:yaml.org,2002:merge" === i) {
          if (Array.isArray(o)) for (c = 0, u = o.length; c < u; c += 1) {
            y(e, t, o[c], n);
          } else y(e, t, o, n);
        } else e.json || B.call(n, r) || !B.call(t, r) || (e.line = a || e.line, e.position = s || e.position, h(e, "duplicated mapping key")), t[r] = o, delete n[r];return t;
      }function v(e) {
        var t;10 === (t = e.input.charCodeAt(e.position)) ? e.position++ : 13 === t ? (e.position++, 10 === e.input.charCodeAt(e.position) && e.position++) : h(e, "a line break is expected"), e.line += 1, e.lineStart = e.position;
      }function A(e, t, n) {
        for (var o = 0, a = e.input.charCodeAt(e.position); 0 !== a;) {
          for (; r(a);) {
            a = e.input.charCodeAt(++e.position);
          }if (t && 35 === a) do {
            a = e.input.charCodeAt(++e.position);
          } while (10 !== a && 13 !== a && 0 !== a);if (!i(a)) break;for (v(e), a = e.input.charCodeAt(e.position), o++, e.lineIndent = 0; 32 === a;) {
            e.lineIndent++, a = e.input.charCodeAt(++e.position);
          }
        }return -1 !== n && 0 !== o && e.lineIndent < n && m(e, "deficient indentation"), o;
      }function b(e) {
        var t,
            n = e.position;return !(45 !== (t = e.input.charCodeAt(n)) && 46 !== t || t !== e.input.charCodeAt(n + 1) || t !== e.input.charCodeAt(n + 2) || (n += 3, 0 !== (t = e.input.charCodeAt(n)) && !o(t)));
      }function w(e, t) {
        1 === t ? e.result += " " : t > 1 && (e.result += q.repeat("\n", t - 1));
      }function C(e, t, n) {
        var s,
            c,
            u,
            l,
            p,
            f,
            d,
            h,
            m,
            y = e.kind,
            x = e.result;if (m = e.input.charCodeAt(e.position), o(m) || a(m) || 35 === m || 38 === m || 42 === m || 33 === m || 124 === m || 62 === m || 39 === m || 34 === m || 37 === m || 64 === m || 96 === m) return !1;if ((63 === m || 45 === m) && (c = e.input.charCodeAt(e.position + 1), o(c) || n && a(c))) return !1;for (e.kind = "scalar", e.result = "", u = l = e.position, p = !1; 0 !== m;) {
          if (58 === m) {
            if (c = e.input.charCodeAt(e.position + 1), o(c) || n && a(c)) break;
          } else if (35 === m) {
            if (s = e.input.charCodeAt(e.position - 1), o(s)) break;
          } else {
            if (e.position === e.lineStart && b(e) || n && a(m)) break;if (i(m)) {
              if (f = e.line, d = e.lineStart, h = e.lineIndent, A(e, !1, -1), e.lineIndent >= t) {
                p = !0, m = e.input.charCodeAt(e.position);continue;
              }e.position = l, e.line = f, e.lineStart = d, e.lineIndent = h;break;
            }
          }p && (g(e, u, l, !1), w(e, e.line - f), u = l = e.position, p = !1), r(m) || (l = e.position + 1), m = e.input.charCodeAt(++e.position);
        }return g(e, u, l, !1), !!e.result || (e.kind = y, e.result = x, !1);
      }function k(e, t) {
        var n, r, o;if (39 !== (n = e.input.charCodeAt(e.position))) return !1;for (e.kind = "scalar", e.result = "", e.position++, r = o = e.position; 0 !== (n = e.input.charCodeAt(e.position));) {
          if (39 === n) {
            if (g(e, r, e.position, !0), 39 !== (n = e.input.charCodeAt(++e.position))) return !0;r = e.position, e.position++, o = e.position;
          } else i(n) ? (g(e, r, o, !0), w(e, A(e, !1, t)), r = o = e.position) : e.position === e.lineStart && b(e) ? h(e, "unexpected end of the document within a single quoted scalar") : (e.position++, o = e.position);
        }h(e, "unexpected end of the stream within a single quoted scalar");
      }function j(e, t) {
        var n, r, o, a, u, l;if (34 !== (l = e.input.charCodeAt(e.position))) return !1;for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; 0 !== (l = e.input.charCodeAt(e.position));) {
          if (34 === l) return g(e, n, e.position, !0), e.position++, !0;if (92 === l) {
            if (g(e, n, e.position, !0), l = e.input.charCodeAt(++e.position), i(l)) A(e, !1, t);else if (l < 256 && ne[l]) e.result += ie[l], e.position++;else if ((u = c(l)) > 0) {
              for (o = u, a = 0; o > 0; o--) {
                (u = s(l = e.input.charCodeAt(++e.position))) >= 0 ? a = (a << 4) + u : h(e, "expected hexadecimal character");
              }e.result += p(a), e.position++;
            } else h(e, "unknown escape sequence");n = r = e.position;
          } else i(l) ? (g(e, n, r, !0), w(e, A(e, !1, t)), n = r = e.position) : e.position === e.lineStart && b(e) ? h(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
        }h(e, "unexpected end of the stream within a double quoted scalar");
      }function I(e, t) {
        var n,
            i,
            r,
            a,
            s,
            c,
            u,
            l,
            p,
            f,
            d = !0,
            m = e.tag,
            g = e.anchor,
            y = {};if (91 === (f = e.input.charCodeAt(e.position))) r = 93, c = !1, i = [];else {
          if (123 !== f) return !1;r = 125, c = !0, i = {};
        }for (null !== e.anchor && (e.anchorMap[e.anchor] = i), f = e.input.charCodeAt(++e.position); 0 !== f;) {
          if (A(e, !0, t), (f = e.input.charCodeAt(e.position)) === r) return e.position++, e.tag = m, e.anchor = g, e.kind = c ? "mapping" : "sequence", e.result = i, !0;d || h(e, "missed comma between flow collection entries"), l = u = p = null, a = s = !1, 63 === f && o(e.input.charCodeAt(e.position + 1)) && (a = s = !0, e.position++, A(e, !0, t)), n = e.line, M(e, t, K, !1, !0), l = e.tag, u = e.result, A(e, !0, t), f = e.input.charCodeAt(e.position), !s && e.line !== n || 58 !== f || (a = !0, f = e.input.charCodeAt(++e.position), A(e, !0, t), M(e, t, K, !1, !0), p = e.result), c ? x(e, i, y, l, u, p) : a ? i.push(x(e, null, y, l, u, p)) : i.push(u), A(e, !0, t), 44 === (f = e.input.charCodeAt(e.position)) ? (d = !0, f = e.input.charCodeAt(++e.position)) : d = !1;
        }h(e, "unexpected end of the stream within a flow collection");
      }function S(e, t) {
        var n,
            o,
            a,
            s,
            c = V,
            l = !1,
            p = !1,
            f = t,
            d = 0,
            m = !1;if (124 === (s = e.input.charCodeAt(e.position))) o = !1;else {
          if (62 !== s) return !1;o = !0;
        }for (e.kind = "scalar", e.result = ""; 0 !== s;) {
          if (43 === (s = e.input.charCodeAt(++e.position)) || 45 === s) V === c ? c = 43 === s ? z : Z : h(e, "repeat of a chomping mode identifier");else {
            if (!((a = u(s)) >= 0)) break;0 === a ? h(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : p ? h(e, "repeat of an indentation width identifier") : (f = t + a - 1, p = !0);
          }
        }if (r(s)) {
          do {
            s = e.input.charCodeAt(++e.position);
          } while (r(s));if (35 === s) do {
            s = e.input.charCodeAt(++e.position);
          } while (!i(s) && 0 !== s);
        }for (; 0 !== s;) {
          for (v(e), e.lineIndent = 0, s = e.input.charCodeAt(e.position); (!p || e.lineIndent < f) && 32 === s;) {
            e.lineIndent++, s = e.input.charCodeAt(++e.position);
          }if (!p && e.lineIndent > f && (f = e.lineIndent), i(s)) d++;else {
            if (e.lineIndent < f) {
              c === z ? e.result += q.repeat("\n", l ? 1 + d : d) : c === V && l && (e.result += "\n");break;
            }for (o ? r(s) ? (m = !0, e.result += q.repeat("\n", l ? 1 + d : d)) : m ? (m = !1, e.result += q.repeat("\n", d + 1)) : 0 === d ? l && (e.result += " ") : e.result += q.repeat("\n", d) : e.result += q.repeat("\n", l ? 1 + d : d), l = !0, p = !0, d = 0, n = e.position; !i(s) && 0 !== s;) {
              s = e.input.charCodeAt(++e.position);
            }g(e, n, e.position, !1);
          }
        }return !0;
      }function O(e, t) {
        var n,
            i,
            r,
            a = e.tag,
            s = e.anchor,
            c = [],
            u = !1;for (null !== e.anchor && (e.anchorMap[e.anchor] = c), r = e.input.charCodeAt(e.position); 0 !== r && 45 === r && (i = e.input.charCodeAt(e.position + 1), o(i));) {
          if (u = !0, e.position++, A(e, !0, -1) && e.lineIndent <= t) c.push(null), r = e.input.charCodeAt(e.position);else if (n = e.line, M(e, t, H, !1, !0), c.push(e.result), A(e, !0, -1), r = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && 0 !== r) h(e, "bad indentation of a sequence entry");else if (e.lineIndent < t) break;
        }return !!u && (e.tag = a, e.anchor = s, e.kind = "sequence", e.result = c, !0);
      }function E(e, t, n) {
        var i,
            a,
            s,
            c,
            u,
            l = e.tag,
            p = e.anchor,
            f = {},
            d = {},
            m = null,
            g = null,
            y = null,
            v = !1,
            b = !1;for (null !== e.anchor && (e.anchorMap[e.anchor] = f), u = e.input.charCodeAt(e.position); 0 !== u;) {
          if (i = e.input.charCodeAt(e.position + 1), s = e.line, c = e.position, 63 !== u && 58 !== u || !o(i)) {
            if (!M(e, n, $, !1, !0)) break;if (e.line === s) {
              for (u = e.input.charCodeAt(e.position); r(u);) {
                u = e.input.charCodeAt(++e.position);
              }if (58 === u) o(u = e.input.charCodeAt(++e.position)) || h(e, "a whitespace character is expected after the key-value separator within a block mapping"), v && (x(e, f, d, m, g, null), m = g = y = null), b = !0, v = !1, a = !1, m = e.tag, g = e.result;else {
                if (!b) return e.tag = l, e.anchor = p, !0;h(e, "can not read an implicit mapping pair; a colon is missed");
              }
            } else {
              if (!b) return e.tag = l, e.anchor = p, !0;h(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
            }
          } else 63 === u ? (v && (x(e, f, d, m, g, null), m = g = y = null), b = !0, v = !0, a = !0) : v ? (v = !1, a = !0) : h(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, u = i;if ((e.line === s || e.lineIndent > t) && (M(e, t, G, !0, a) && (v ? g = e.result : y = e.result), v || (x(e, f, d, m, g, y, s, c), m = g = y = null), A(e, !0, -1), u = e.input.charCodeAt(e.position)), e.lineIndent > t && 0 !== u) h(e, "bad indentation of a mapping entry");else if (e.lineIndent < t) break;
        }return v && x(e, f, d, m, g, null), b && (e.tag = l, e.anchor = p, e.kind = "mapping", e.result = f), b;
      }function F(e) {
        var t,
            n,
            i,
            r,
            a = !1,
            s = !1;if (33 !== (r = e.input.charCodeAt(e.position))) return !1;if (null !== e.tag && h(e, "duplication of a tag property"), 60 === (r = e.input.charCodeAt(++e.position)) ? (a = !0, r = e.input.charCodeAt(++e.position)) : 33 === r ? (s = !0, n = "!!", r = e.input.charCodeAt(++e.position)) : n = "!", t = e.position, a) {
          do {
            r = e.input.charCodeAt(++e.position);
          } while (0 !== r && 62 !== r);e.position < e.length ? (i = e.input.slice(t, e.position), r = e.input.charCodeAt(++e.position)) : h(e, "unexpected end of the stream within a verbatim tag");
        } else {
          for (; 0 !== r && !o(r);) {
            33 === r && (s ? h(e, "tag suffix cannot contain exclamation marks") : (n = e.input.slice(t - 1, e.position + 1), ee.test(n) || h(e, "named tag handle cannot contain such characters"), s = !0, t = e.position + 1)), r = e.input.charCodeAt(++e.position);
          }i = e.input.slice(t, e.position), X.test(i) && h(e, "tag suffix cannot contain flow indicator characters");
        }return i && !te.test(i) && h(e, "tag name cannot contain such characters: " + i), a ? e.tag = i : B.call(e.tagMap, n) ? e.tag = e.tagMap[n] + i : "!" === n ? e.tag = "!" + i : "!!" === n ? e.tag = "tag:yaml.org,2002:" + i : h(e, 'undeclared tag handle "' + n + '"'), !0;
      }function _(e) {
        var t, n;if (38 !== (n = e.input.charCodeAt(e.position))) return !1;for (null !== e.anchor && h(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; 0 !== n && !o(n) && !a(n);) {
          n = e.input.charCodeAt(++e.position);
        }return e.position === t && h(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
      }function N(e) {
        var t, n, i;if (42 !== (i = e.input.charCodeAt(e.position))) return !1;for (i = e.input.charCodeAt(++e.position), t = e.position; 0 !== i && !o(i) && !a(i);) {
          i = e.input.charCodeAt(++e.position);
        }return e.position === t && h(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), e.anchorMap.hasOwnProperty(n) || h(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], A(e, !0, -1), !0;
      }function M(e, t, n, i, r) {
        var o,
            a,
            s,
            c,
            u,
            l,
            p,
            f,
            d = 1,
            m = !1,
            g = !1;if (null !== e.listener && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, o = a = s = G === n || H === n, i && A(e, !0, -1) && (m = !0, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)), 1 === d) for (; F(e) || _(e);) {
          A(e, !0, -1) ? (m = !0, s = o, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)) : s = !1;
        }if (s && (s = m || r), 1 !== d && G !== n || (p = K === n || $ === n ? t : t + 1, f = e.position - e.lineStart, 1 === d ? s && (O(e, f) || E(e, f, p)) || I(e, p) ? g = !0 : (a && S(e, p) || k(e, p) || j(e, p) ? g = !0 : N(e) ? (g = !0, null === e.tag && null === e.anchor || h(e, "alias node should not have any properties")) : C(e, p, K === n) && (g = !0, null === e.tag && (e.tag = "?")), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : 0 === d && (g = s && O(e, f))), null !== e.tag && "!" !== e.tag) if ("?" === e.tag) {
          for (c = 0, u = e.implicitTypes.length; c < u; c += 1) {
            if ((l = e.implicitTypes[c]).resolve(e.result)) {
              e.result = l.construct(e.result), e.tag = l.tag, null !== e.anchor && (e.anchorMap[e.anchor] = e.result);break;
            }
          }
        } else B.call(e.typeMap[e.kind || "fallback"], e.tag) ? (l = e.typeMap[e.kind || "fallback"][e.tag], null !== e.result && l.kind !== e.kind && h(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + l.kind + '", not "' + e.kind + '"'), l.resolve(e.result) ? (e.result = l.construct(e.result), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : h(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")) : h(e, "unknown tag !<" + e.tag + ">");return null !== e.listener && e.listener("close", e), null !== e.tag || null !== e.anchor || g;
      }function T(e) {
        var t,
            n,
            a,
            s,
            c = e.position,
            u = !1;for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = {}, e.anchorMap = {}; 0 !== (s = e.input.charCodeAt(e.position)) && (A(e, !0, -1), s = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || 37 !== s));) {
          for (u = !0, s = e.input.charCodeAt(++e.position), t = e.position; 0 !== s && !o(s);) {
            s = e.input.charCodeAt(++e.position);
          }for (a = [], (n = e.input.slice(t, e.position)).length < 1 && h(e, "directive name must not be less than one character in length"); 0 !== s;) {
            for (; r(s);) {
              s = e.input.charCodeAt(++e.position);
            }if (35 === s) {
              do {
                s = e.input.charCodeAt(++e.position);
              } while (0 !== s && !i(s));break;
            }if (i(s)) break;for (t = e.position; 0 !== s && !o(s);) {
              s = e.input.charCodeAt(++e.position);
            }a.push(e.input.slice(t, e.position));
          }0 !== s && v(e), B.call(oe, n) ? oe[n](e, n, a) : m(e, 'unknown document directive "' + n + '"');
        }A(e, !0, -1), 0 === e.lineIndent && 45 === e.input.charCodeAt(e.position) && 45 === e.input.charCodeAt(e.position + 1) && 45 === e.input.charCodeAt(e.position + 2) ? (e.position += 3, A(e, !0, -1)) : u && h(e, "directives end mark is expected"), M(e, e.lineIndent - 1, G, !1, !0), A(e, !0, -1), e.checkLineBreaks && Q.test(e.input.slice(c, e.position)) && m(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && b(e) ? 46 === e.input.charCodeAt(e.position) && (e.position += 3, A(e, !0, -1)) : e.position < e.length - 1 && h(e, "end of the stream or a document separator is expected");
      }function L(e, t) {
        e = String(e), t = t || {}, 0 !== e.length && (10 !== e.charCodeAt(e.length - 1) && 13 !== e.charCodeAt(e.length - 1) && (e += "\n"), 65279 === e.charCodeAt(0) && (e = e.slice(1)));var n = new f(e, t);for (n.input += "\0"; 32 === n.input.charCodeAt(n.position);) {
          n.lineIndent += 1, n.position += 1;
        }for (; n.position < n.length - 1;) {
          T(n);
        }return n.documents;
      }function D(e, t, n) {
        var i,
            r,
            o = L(e, n);if ("function" != typeof t) return o;for (i = 0, r = o.length; i < r; i += 1) {
          t(o[i]);
        }
      }function U(e, t) {
        var n = L(e, t);if (0 !== n.length) {
          if (1 === n.length) return n[0];throw new Y("expected a single document in the stream, but found more");
        }
      }for (var q = e("./common"), Y = e("./exception"), R = e("./mark"), P = e("./schema/default_safe"), W = e("./schema/default_full"), B = Object.prototype.hasOwnProperty, K = 1, $ = 2, H = 3, G = 4, V = 1, Z = 2, z = 3, J = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Q = /[\x85\u2028\u2029]/, X = /[,\[\]\{\}]/, ee = /^(?:!|!!|![a-z\-]+!)$/i, te = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i, ne = new Array(256), ie = new Array(256), re = 0; re < 256; re++) {
        ne[re] = l(re) ? 1 : 0, ie[re] = l(re);
      }var oe = { YAML: function YAML(e, t, n) {
          var i, r, o;null !== e.version && h(e, "duplication of %YAML directive"), 1 !== n.length && h(e, "YAML directive accepts exactly one argument"), null === (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])) && h(e, "ill-formed argument of the YAML directive"), r = parseInt(i[1], 10), o = parseInt(i[2], 10), 1 !== r && h(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = o < 2, 1 !== o && 2 !== o && m(e, "unsupported YAML version of the document");
        }, TAG: function TAG(e, t, n) {
          var i, r;2 !== n.length && h(e, "TAG directive accepts exactly two arguments"), i = n[0], r = n[1], ee.test(i) || h(e, "ill-formed tag handle (first argument) of the TAG directive"), B.call(e.tagMap, i) && h(e, 'there is a previously declared suffix for "' + i + '" tag handle'), te.test(r) || h(e, "ill-formed tag prefix (second argument) of the TAG directive"), e.tagMap[i] = r;
        } };t.exports.loadAll = D, t.exports.load = U, t.exports.safeLoadAll = function (e, t, n) {
        if ("function" != typeof t) return D(e, q.extend({ schema: P }, n));D(e, t, q.extend({ schema: P }, n));
      }, t.exports.safeLoad = function (e, t) {
        return U(e, q.extend({ schema: P }, t));
      };
    }, { "./common": 2, "./exception": 4, "./mark": 6, "./schema/default_full": 9, "./schema/default_safe": 10 }], 6: [function (e, t, n) {
      "use strict";
      function i(e, t, n, i, r) {
        this.name = e, this.buffer = t, this.position = n, this.line = i, this.column = r;
      }var r = e("./common");i.prototype.getSnippet = function (e, t) {
        var n, i, o, a, s;if (!this.buffer) return null;for (e = e || 4, t = t || 75, n = "", i = this.position; i > 0 && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(i - 1));) {
          if (i -= 1, this.position - i > t / 2 - 1) {
            n = " ... ", i += 5;break;
          }
        }for (o = "", a = this.position; a < this.buffer.length && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(a));) {
          if ((a += 1) - this.position > t / 2 - 1) {
            o = " ... ", a -= 5;break;
          }
        }return s = this.buffer.slice(i, a), r.repeat(" ", e) + n + s + o + "\n" + r.repeat(" ", e + this.position - i + n.length) + "^";
      }, i.prototype.toString = function (e) {
        var t,
            n = "";return this.name && (n += 'in "' + this.name + '" '), n += "at line " + (this.line + 1) + ", column " + (this.column + 1), e || (t = this.getSnippet()) && (n += ":\n" + t), n;
      }, t.exports = i;
    }, { "./common": 2 }], 7: [function (e, t, n) {
      "use strict";
      function i(e, t, n) {
        var r = [];return e.include.forEach(function (e) {
          n = i(e, t, n);
        }), e[t].forEach(function (e) {
          n.forEach(function (t, n) {
            t.tag === e.tag && t.kind === e.kind && r.push(n);
          }), n.push(e);
        }), n.filter(function (e, t) {
          return -1 === r.indexOf(t);
        });
      }function r() {
        var e,
            t,
            n = { scalar: {}, sequence: {}, mapping: {}, fallback: {} };for (e = 0, t = arguments.length; e < t; e += 1) {
          arguments[e].forEach(function (e) {
            n[e.kind][e.tag] = n.fallback[e.tag] = e;
          });
        }return n;
      }function o(e) {
        this.include = e.include || [], this.implicit = e.implicit || [], this.explicit = e.explicit || [], this.implicit.forEach(function (e) {
          if (e.loadKind && "scalar" !== e.loadKind) throw new s("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }), this.compiledImplicit = i(this, "implicit", []), this.compiledExplicit = i(this, "explicit", []), this.compiledTypeMap = r(this.compiledImplicit, this.compiledExplicit);
      }var a = e("./common"),
          s = e("./exception"),
          c = e("./type");o.DEFAULT = null, o.create = function () {
        var e, t;switch (arguments.length) {case 1:
            e = o.DEFAULT, t = arguments[0];break;case 2:
            e = arguments[0], t = arguments[1];break;default:
            throw new s("Wrong number of arguments for Schema.create function");}if (e = a.toArray(e), t = a.toArray(t), !e.every(function (e) {
          return e instanceof o;
        })) throw new s("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");if (!t.every(function (e) {
          return e instanceof c;
        })) throw new s("Specified list of YAML types (or a single Type object) contains a non-Type object.");return new o({ include: e, explicit: t });
      }, t.exports = o;
    }, { "./common": 2, "./exception": 4, "./type": 13 }], 8: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./json")] });
    }, { "../schema": 7, "./json": 12 }], 9: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = i.DEFAULT = new i({ include: [e("./default_safe")], explicit: [e("../type/js/undefined"), e("../type/js/regexp"), e("../type/js/function")] });
    }, { "../schema": 7, "../type/js/function": 18, "../type/js/regexp": 19, "../type/js/undefined": 20, "./default_safe": 10 }], 10: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./core")], implicit: [e("../type/timestamp"), e("../type/merge")], explicit: [e("../type/binary"), e("../type/omap"), e("../type/pairs"), e("../type/set")] });
    }, { "../schema": 7, "../type/binary": 14, "../type/merge": 22, "../type/omap": 24, "../type/pairs": 25, "../type/set": 27, "../type/timestamp": 29, "./core": 8 }], 11: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ explicit: [e("../type/str"), e("../type/seq"), e("../type/map")] });
    }, { "../schema": 7, "../type/map": 21, "../type/seq": 26, "../type/str": 28 }], 12: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./failsafe")], implicit: [e("../type/null"), e("../type/bool"), e("../type/int"), e("../type/float")] });
    }, { "../schema": 7, "../type/bool": 15, "../type/float": 16, "../type/int": 17, "../type/null": 23, "./failsafe": 11 }], 13: [function (e, t, n) {
      "use strict";
      function i(e) {
        var t = {};return null !== e && Object.keys(e).forEach(function (n) {
          e[n].forEach(function (e) {
            t[String(e)] = n;
          });
        }), t;
      }var r = e("./exception"),
          o = ["kind", "resolve", "construct", "instanceOf", "predicate", "represent", "defaultStyle", "styleAliases"],
          a = ["scalar", "sequence", "mapping"];t.exports = function (e, t) {
        if (t = t || {}, Object.keys(t).forEach(function (t) {
          if (-1 === o.indexOf(t)) throw new r('Unknown option "' + t + '" is met in definition of "' + e + '" YAML type.');
        }), this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function () {
          return !0;
        }, this.construct = t.construct || function (e) {
          return e;
        }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.defaultStyle = t.defaultStyle || null, this.styleAliases = i(t.styleAliases || null), -1 === a.indexOf(this.kind)) throw new r('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
      };
    }, { "./exception": 4 }], 14: [function (e, t, n) {
      "use strict";
      var i;try {
        i = e("buffer").Buffer;
      } catch (e) {}var r = e("../type"),
          o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";t.exports = new r("tag:yaml.org,2002:binary", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t,
              n,
              i = 0,
              r = e.length,
              a = o;for (n = 0; n < r; n++) {
            if (!((t = a.indexOf(e.charAt(n))) > 64)) {
              if (t < 0) return !1;i += 6;
            }
          }return i % 8 == 0;
        }, construct: function construct(e) {
          var t,
              n,
              r = e.replace(/[\r\n=]/g, ""),
              a = r.length,
              s = o,
              c = 0,
              u = [];for (t = 0; t < a; t++) {
            t % 4 == 0 && t && (u.push(c >> 16 & 255), u.push(c >> 8 & 255), u.push(255 & c)), c = c << 6 | s.indexOf(r.charAt(t));
          }return 0 == (n = a % 4 * 6) ? (u.push(c >> 16 & 255), u.push(c >> 8 & 255), u.push(255 & c)) : 18 === n ? (u.push(c >> 10 & 255), u.push(c >> 2 & 255)) : 12 === n && u.push(c >> 4 & 255), i ? i.from ? i.from(u) : new i(u) : u;
        }, predicate: function predicate(e) {
          return i && i.isBuffer(e);
        }, represent: function represent(e) {
          var t,
              n,
              i = "",
              r = 0,
              a = e.length,
              s = o;for (t = 0; t < a; t++) {
            t % 3 == 0 && t && (i += s[r >> 18 & 63], i += s[r >> 12 & 63], i += s[r >> 6 & 63], i += s[63 & r]), r = (r << 8) + e[t];
          }return 0 == (n = a % 3) ? (i += s[r >> 18 & 63], i += s[r >> 12 & 63], i += s[r >> 6 & 63], i += s[63 & r]) : 2 === n ? (i += s[r >> 10 & 63], i += s[r >> 4 & 63], i += s[r << 2 & 63], i += s[64]) : 1 === n && (i += s[r >> 2 & 63], i += s[r << 4 & 63], i += s[64], i += s[64]), i;
        } });
    }, { "../type": 13 }], 15: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:bool", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t = e.length;return 4 === t && ("true" === e || "True" === e || "TRUE" === e) || 5 === t && ("false" === e || "False" === e || "FALSE" === e);
        }, construct: function construct(e) {
          return "true" === e || "True" === e || "TRUE" === e;
        }, predicate: function predicate(e) {
          return "[object Boolean]" === Object.prototype.toString.call(e);
        }, represent: { lowercase: function lowercase(e) {
            return e ? "true" : "false";
          }, uppercase: function uppercase(e) {
            return e ? "TRUE" : "FALSE";
          }, camelcase: function camelcase(e) {
            return e ? "True" : "False";
          } }, defaultStyle: "lowercase" });
    }, { "../type": 13 }], 16: [function (e, t, n) {
      "use strict";
      var i = e("../common"),
          r = e("../type"),
          o = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"),
          a = /^[-+]?[0-9]+e/;t.exports = new r("tag:yaml.org,2002:float", { kind: "scalar", resolve: function resolve(e) {
          return null !== e && !(!o.test(e) || "_" === e[e.length - 1]);
        }, construct: function construct(e) {
          var t, n, i, r;return t = e.replace(/_/g, "").toLowerCase(), n = "-" === t[0] ? -1 : 1, r = [], "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), ".inf" === t ? 1 === n ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : ".nan" === t ? NaN : t.indexOf(":") >= 0 ? (t.split(":").forEach(function (e) {
            r.unshift(parseFloat(e, 10));
          }), t = 0, i = 1, r.forEach(function (e) {
            t += e * i, i *= 60;
          }), n * t) : n * parseFloat(t, 10);
        }, predicate: function predicate(e) {
          return "[object Number]" === Object.prototype.toString.call(e) && (e % 1 != 0 || i.isNegativeZero(e));
        }, represent: function represent(e, t) {
          var n;if (isNaN(e)) switch (t) {case "lowercase":
              return ".nan";case "uppercase":
              return ".NAN";case "camelcase":
              return ".NaN";} else if (Number.POSITIVE_INFINITY === e) switch (t) {case "lowercase":
              return ".inf";case "uppercase":
              return ".INF";case "camelcase":
              return ".Inf";} else if (Number.NEGATIVE_INFINITY === e) switch (t) {case "lowercase":
              return "-.inf";case "uppercase":
              return "-.INF";case "camelcase":
              return "-.Inf";} else if (i.isNegativeZero(e)) return "-0.0";return n = e.toString(10), a.test(n) ? n.replace("e", ".e") : n;
        }, defaultStyle: "lowercase" });
    }, { "../common": 2, "../type": 13 }], 17: [function (e, t, n) {
      "use strict";
      function i(e) {
        return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
      }function r(e) {
        return 48 <= e && e <= 55;
      }function o(e) {
        return 48 <= e && e <= 57;
      }var a = e("../common"),
          s = e("../type");t.exports = new s("tag:yaml.org,2002:int", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t,
              n = e.length,
              a = 0,
              s = !1;if (!n) return !1;if ("-" !== (t = e[a]) && "+" !== t || (t = e[++a]), "0" === t) {
            if (a + 1 === n) return !0;if ("b" === (t = e[++a])) {
              for (a++; a < n; a++) {
                if ("_" !== (t = e[a])) {
                  if ("0" !== t && "1" !== t) return !1;s = !0;
                }
              }return s && "_" !== t;
            }if ("x" === t) {
              for (a++; a < n; a++) {
                if ("_" !== (t = e[a])) {
                  if (!i(e.charCodeAt(a))) return !1;s = !0;
                }
              }return s && "_" !== t;
            }for (; a < n; a++) {
              if ("_" !== (t = e[a])) {
                if (!r(e.charCodeAt(a))) return !1;s = !0;
              }
            }return s && "_" !== t;
          }if ("_" === t) return !1;for (; a < n; a++) {
            if ("_" !== (t = e[a])) {
              if (":" === t) break;if (!o(e.charCodeAt(a))) return !1;s = !0;
            }
          }return !(!s || "_" === t) && (":" !== t || /^(:[0-5]?[0-9])+$/.test(e.slice(a)));
        }, construct: function construct(e) {
          var t,
              n,
              i = e,
              r = 1,
              o = [];return -1 !== i.indexOf("_") && (i = i.replace(/_/g, "")), "-" !== (t = i[0]) && "+" !== t || ("-" === t && (r = -1), t = (i = i.slice(1))[0]), "0" === i ? 0 : "0" === t ? "b" === i[1] ? r * parseInt(i.slice(2), 2) : "x" === i[1] ? r * parseInt(i, 16) : r * parseInt(i, 8) : -1 !== i.indexOf(":") ? (i.split(":").forEach(function (e) {
            o.unshift(parseInt(e, 10));
          }), i = 0, n = 1, o.forEach(function (e) {
            i += e * n, n *= 60;
          }), r * i) : r * parseInt(i, 10);
        }, predicate: function predicate(e) {
          return "[object Number]" === Object.prototype.toString.call(e) && e % 1 == 0 && !a.isNegativeZero(e);
        }, represent: { binary: function binary(e) {
            return "0b" + e.toString(2);
          }, octal: function octal(e) {
            return "0" + e.toString(8);
          }, decimal: function decimal(e) {
            return e.toString(10);
          }, hexadecimal: function hexadecimal(e) {
            return "0x" + e.toString(16).toUpperCase();
          } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } });
    }, { "../common": 2, "../type": 13 }], 18: [function (e, t, n) {
      "use strict";
      var i;try {
        i = e("esprima");
      } catch (e) {
        "undefined" != typeof window && (i = window.esprima);
      }var r = e("../../type");t.exports = new r("tag:yaml.org,2002:js/function", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;try {
            var t = "(" + e + ")",
                n = i.parse(t, { range: !0 });return "Program" === n.type && 1 === n.body.length && "ExpressionStatement" === n.body[0].type && "FunctionExpression" === n.body[0].expression.type;
          } catch (e) {
            return !1;
          }
        }, construct: function construct(e) {
          var t,
              n = "(" + e + ")",
              r = i.parse(n, { range: !0 }),
              o = [];if ("Program" !== r.type || 1 !== r.body.length || "ExpressionStatement" !== r.body[0].type || "FunctionExpression" !== r.body[0].expression.type) throw new Error("Failed to resolve function");return r.body[0].expression.params.forEach(function (e) {
            o.push(e.name);
          }), t = r.body[0].expression.body.range, new Function(o, n.slice(t[0] + 1, t[1] - 1));
        }, predicate: function predicate(e) {
          return "[object Function]" === Object.prototype.toString.call(e);
        }, represent: function represent(e) {
          return e.toString();
        } });
    }, { "../../type": 13 }], 19: [function (e, t, n) {
      "use strict";
      var i = e("../../type");t.exports = new i("tag:yaml.org,2002:js/regexp", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;if (0 === e.length) return !1;var t = e,
              n = /\/([gim]*)$/.exec(e),
              i = "";if ("/" === t[0]) {
            if (n && (i = n[1]), i.length > 3) return !1;if ("/" !== t[t.length - i.length - 1]) return !1;
          }return !0;
        }, construct: function construct(e) {
          var t = e,
              n = /\/([gim]*)$/.exec(e),
              i = "";return "/" === t[0] && (n && (i = n[1]), t = t.slice(1, t.length - i.length - 1)), new RegExp(t, i);
        }, predicate: function predicate(e) {
          return "[object RegExp]" === Object.prototype.toString.call(e);
        }, represent: function represent(e) {
          var t = "/" + e.source + "/";return e.global && (t += "g"), e.multiline && (t += "m"), e.ignoreCase && (t += "i"), t;
        } });
    }, { "../../type": 13 }], 20: [function (e, t, n) {
      "use strict";
      var i = e("../../type");t.exports = new i("tag:yaml.org,2002:js/undefined", { kind: "scalar", resolve: function resolve() {
          return !0;
        }, construct: function construct() {}, predicate: function predicate(e) {
          return void 0 === e;
        }, represent: function represent() {
          return "";
        } });
    }, { "../../type": 13 }], 21: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:map", { kind: "mapping", construct: function construct(e) {
          return null !== e ? e : {};
        } });
    }, { "../type": 13 }], 22: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:merge", { kind: "scalar", resolve: function resolve(e) {
          return "<<" === e || null === e;
        } });
    }, { "../type": 13 }], 23: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:null", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !0;var t = e.length;return 1 === t && "~" === e || 4 === t && ("null" === e || "Null" === e || "NULL" === e);
        }, construct: function construct() {
          return null;
        }, predicate: function predicate(e) {
          return null === e;
        }, represent: { canonical: function canonical() {
            return "~";
          }, lowercase: function lowercase() {
            return "null";
          }, uppercase: function uppercase() {
            return "NULL";
          }, camelcase: function camelcase() {
            return "Null";
          } }, defaultStyle: "lowercase" });
    }, { "../type": 13 }], 24: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.hasOwnProperty,
          o = Object.prototype.toString;t.exports = new i("tag:yaml.org,2002:omap", { kind: "sequence", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n,
              i,
              a,
              s,
              c = [],
              u = e;for (t = 0, n = u.length; t < n; t += 1) {
            if (i = u[t], s = !1, "[object Object]" !== o.call(i)) return !1;for (a in i) {
              if (r.call(i, a)) {
                if (s) return !1;s = !0;
              }
            }if (!s) return !1;if (-1 !== c.indexOf(a)) return !1;c.push(a);
          }return !0;
        }, construct: function construct(e) {
          return null !== e ? e : [];
        } });
    }, { "../type": 13 }], 25: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.toString;t.exports = new i("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n,
              i,
              o,
              a,
              s = e;for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1) {
            if (i = s[t], "[object Object]" !== r.call(i)) return !1;if (1 !== (o = Object.keys(i)).length) return !1;a[t] = [o[0], i[o[0]]];
          }return !0;
        }, construct: function construct(e) {
          if (null === e) return [];var t,
              n,
              i,
              r,
              o,
              a = e;for (o = new Array(a.length), t = 0, n = a.length; t < n; t += 1) {
            i = a[t], r = Object.keys(i), o[t] = [r[0], i[r[0]]];
          }return o;
        } });
    }, { "../type": 13 }], 26: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:seq", { kind: "sequence", construct: function construct(e) {
          return null !== e ? e : [];
        } });
    }, { "../type": 13 }], 27: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.hasOwnProperty;t.exports = new i("tag:yaml.org,2002:set", { kind: "mapping", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n = e;for (t in n) {
            if (r.call(n, t) && null !== n[t]) return !1;
          }return !0;
        }, construct: function construct(e) {
          return null !== e ? e : {};
        } });
    }, { "../type": 13 }], 28: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:str", { kind: "scalar", construct: function construct(e) {
          return null !== e ? e : "";
        } });
    }, { "../type": 13 }], 29: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
          o = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");t.exports = new i("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: function resolve(e) {
          return null !== e && (null !== r.exec(e) || null !== o.exec(e));
        }, construct: function construct(e) {
          var t,
              n,
              i,
              a,
              s,
              c,
              u,
              l,
              p = 0,
              f = null;if (null === (t = r.exec(e)) && (t = o.exec(e)), null === t) throw new Error("Date resolve error");if (n = +t[1], i = +t[2] - 1, a = +t[3], !t[4]) return new Date(Date.UTC(n, i, a));if (s = +t[4], c = +t[5], u = +t[6], t[7]) {
            for (p = t[7].slice(0, 3); p.length < 3;) {
              p += "0";
            }p = +p;
          }return t[9] && (f = 6e4 * (60 * +t[10] + +(t[11] || 0)), "-" === t[9] && (f = -f)), l = new Date(Date.UTC(n, i, a, s, c, u, p)), f && l.setTime(l.getTime() - f), l;
        }, instanceOf: Date, represent: function represent(e) {
          return e.toISOString();
        } });
    }, { "../type": 13 }], "/": [function (e, t, n) {
      "use strict";
      var i = e("./lib/js-yaml.js");t.exports = i;
    }, { "./lib/js-yaml.js": 1 }] }, {}, [])("/");
});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWQzYmVjNDEyZmVlYzVlODcxMjciLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL1V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Cb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vTGF0TG5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL0xhdExuZ0JvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9GZWF0dXJlR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9QYXRoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL211dGFibGUtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXNldHRpbmdzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2Nzcy1wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3RlbXBsYXRpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvRGl2T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS11dGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3RlbXBsYXRlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9kb2N1bWVudC13YWl0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2NvbG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZG9tL1Bvc0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuQXR0cmlidXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL0dyaWRMYXllci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvUG9seVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvR2VvSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dnLW1hcC12aWV3ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvYXBwbHktc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9pbXBvcnQtaHJlZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvY2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1pZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tbWV0YS9pcm9uLW1ldGEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvTWFya2VyLkRyYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmciLCJ3ZWJwYWNrOi8vLy92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LW1hcC9sZWFmbGV0LW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5ab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLlNjYWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvUG9wdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9Ub29sdGlwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuVk1MLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmdldFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8vdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC13bXMvbGVhZmxldC13bXMtZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0Lndtcy5qcyIsIndlYnBhY2s6Ly8vL3Zhci93d3cvbG9jYWxob3N0L2h0ZG9jcy9AZ2djaXR5L2xlYWZsZXQtd21zL2xlYWZsZXQtd21zLWxheWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGdnY2l0eS9sZWFmbGV0LXRpbGUtbGF5ZXIvbGVhZmxldC10aWxlLWxheWVyLmpzIiwid2VicGFjazovLy8vdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC1nZW9qc29uL2xlYWZsZXQtZ2VvanNvbi1wb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9MZWFmbGV0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czMzk1LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuU2ltcGxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3BhY2thZ2UuanNvbiIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXJHcm91cC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyT3BhY2l0eS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvRGlzdGFuY2VHcmlkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyLlF1aWNrSHVsbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlci5TcGlkZXJmaWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyR3JvdXAuUmVmcmVzaC5qcyIsIndlYnBhY2s6Ly8vLi4vYXBwLnRlbXBsYXRlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2Rpc3QvanMteWFtbC5taW4uanMiXSwibmFtZXMiOlsiZXh0ZW5kIiwiYmluZCIsInN0YW1wIiwidGhyb3R0bGUiLCJ3cmFwTnVtIiwiZmFsc2VGbiIsImZvcm1hdE51bSIsInRyaW0iLCJzcGxpdFdvcmRzIiwic2V0T3B0aW9ucyIsImdldFBhcmFtU3RyaW5nIiwidGVtcGxhdGUiLCJpbmRleE9mIiwicmVxdWVzdEFuaW1GcmFtZSIsImNhbmNlbEFuaW1GcmFtZSIsImZyZWV6ZSIsIk9iamVjdCIsIm9iaiIsImRlc3QiLCJpIiwiaiIsImxlbiIsInNyYyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNyZWF0ZSIsIkYiLCJwcm90byIsInByb3RvdHlwZSIsImZuIiwic2xpY2UiLCJBcnJheSIsImFwcGx5IiwiY2FsbCIsImFyZ3MiLCJjb25jYXQiLCJsYXN0SWQiLCJfbGVhZmxldF9pZCIsInRpbWUiLCJjb250ZXh0IiwibG9jayIsIndyYXBwZXJGbiIsImxhdGVyIiwic2V0VGltZW91dCIsIngiLCJyYW5nZSIsImluY2x1ZGVNYXgiLCJtYXgiLCJtaW4iLCJkIiwibnVtIiwiZGlnaXRzIiwicG93IiwiTWF0aCIsInJvdW5kIiwic3RyIiwicmVwbGFjZSIsInNwbGl0Iiwib3B0aW9ucyIsImhhc093blByb3BlcnR5IiwiZXhpc3RpbmdVcmwiLCJ1cHBlcmNhc2UiLCJwYXJhbXMiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9VcHBlckNhc2UiLCJqb2luIiwidGVtcGxhdGVSZSIsImRhdGEiLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIkVycm9yIiwiaXNBcnJheSIsInRvU3RyaW5nIiwiYXJyYXkiLCJlbCIsImVtcHR5SW1hZ2VVcmwiLCJnZXRQcmVmaXhlZCIsIm5hbWUiLCJ3aW5kb3ciLCJsYXN0VGltZSIsInRpbWVvdXREZWZlciIsIkRhdGUiLCJ0aW1lVG9DYWxsIiwicmVxdWVzdEZuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsRm4iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkIiwiY2xlYXJUaW1lb3V0IiwiaW1tZWRpYXRlIiwiZ2V0IiwiZ2V0U3R5bGUiLCJyZW1vdmUiLCJlbXB0eSIsInRvRnJvbnQiLCJ0b0JhY2siLCJoYXNDbGFzcyIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJzZXRDbGFzcyIsImdldENsYXNzIiwic2V0T3BhY2l0eSIsInRlc3RQcm9wIiwic2V0VHJhbnNmb3JtIiwic2V0UG9zaXRpb24iLCJnZXRQb3NpdGlvbiIsImRpc2FibGVJbWFnZURyYWciLCJlbmFibGVJbWFnZURyYWciLCJwcmV2ZW50T3V0bGluZSIsInJlc3RvcmVPdXRsaW5lIiwiRG9tRXZlbnQiLCJVdGlsIiwiQnJvd3NlciIsIlRSQU5TRk9STSIsIlRSQU5TSVRJT04iLCJUUkFOU0lUSU9OX0VORCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzdHlsZSIsImN1cnJlbnRTdHlsZSIsImRlZmF1bHRWaWV3IiwiY3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRhZ05hbWUiLCJjbGFzc05hbWUiLCJjb250YWluZXIiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJSZWdFeHAiLCJ0ZXN0IiwiY2xhc3NlcyIsImFkZCIsImJhc2VWYWwiLCJvcGFjaXR5IiwiX3NldE9wYWNpdHlJRSIsImZpbHRlciIsImZpbHRlck5hbWUiLCJmaWx0ZXJzIiwiaXRlbSIsImUiLCJFbmFibGVkIiwiT3BhY2l0eSIsInByb3BzIiwiZG9jdW1lbnRFbGVtZW50Iiwib2Zmc2V0Iiwic2NhbGUiLCJwb3MiLCJpZTNkIiwieSIsInBvaW50IiwiX2xlYWZsZXRfcG9zIiwiYW55M2QiLCJsZWZ0IiwidG9wIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiX3VzZXJTZWxlY3QiLCJvbiIsInByZXZlbnREZWZhdWx0Iiwib2ZmIiwidXNlclNlbGVjdFByb3BlcnR5IiwiX291dGxpbmVFbGVtZW50IiwiX291dGxpbmVTdHlsZSIsImVsZW1lbnQiLCJ0YWJJbmRleCIsIm91dGxpbmUiLCJKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5IiwicHJvcCIsIlBvbHltZXIiLCJQb2ludCIsInRvUG9pbnQiLCJjbG9uZSIsIl9hZGQiLCJzdWJ0cmFjdCIsIl9zdWJ0cmFjdCIsImRpdmlkZUJ5IiwiX2RpdmlkZUJ5IiwibXVsdGlwbHlCeSIsIl9tdWx0aXBseUJ5Iiwic2NhbGVCeSIsInVuc2NhbGVCeSIsIl9yb3VuZCIsImZsb29yIiwiX2Zsb29yIiwiY2VpbCIsIl9jZWlsIiwiZGlzdGFuY2VUbyIsInNxcnQiLCJlcXVhbHMiLCJhYnMiLCJpZSIsImllbHQ5IiwiYWRkRXZlbnRMaXN0ZW5lciIsImVkZ2UiLCJuYXZpZ2F0b3IiLCJ3ZWJraXQiLCJ1c2VyQWdlbnRDb250YWlucyIsImFuZHJvaWQiLCJhbmRyb2lkMjMiLCJvcGVyYSIsImNocm9tZSIsImdlY2tvIiwic2FmYXJpIiwicGhhbnRvbSIsIm9wZXJhMTIiLCJ3aW4iLCJwbGF0Zm9ybSIsIndlYmtpdDNkIiwiV2ViS2l0Q1NTTWF0cml4IiwiZ2Vja28zZCIsIkxfRElTQUJMRV8zRCIsIm1vYmlsZSIsIm9yaWVudGF0aW9uIiwibW9iaWxlV2Via2l0IiwibW9iaWxlV2Via2l0M2QiLCJtc1BvaW50ZXIiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsInBvaW50ZXIiLCJ0b3VjaCIsIkxfTk9fVE9VQ0giLCJEb2N1bWVudFRvdWNoIiwibW9iaWxlT3BlcmEiLCJtb2JpbGVHZWNrbyIsInJldGluYSIsImRldmljZVBpeGVsUmF0aW8iLCJzY3JlZW4iLCJkZXZpY2VYRFBJIiwibG9naWNhbFhEUEkiLCJjYW52YXMiLCJnZXRDb250ZXh0Iiwic3ZnIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlU1ZHUmVjdCIsInZtbCIsImRpdiIsImlubmVySFRNTCIsInNoYXBlIiwiYmVoYXZpb3IiLCJhZGoiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsInN0b3BQcm9wYWdhdGlvbiIsImRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsImRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwic3RvcCIsImdldE1vdXNlUG9zaXRpb24iLCJnZXRXaGVlbERlbHRhIiwiZmFrZVN0b3AiLCJza2lwcGVkIiwiaXNFeHRlcm5hbFRhcmdldCIsInR5cGVzIiwidHlwZSIsImFkZE9uZSIsImV2ZW50c0tleSIsInJlbW92ZU9uZSIsImhhbmRsZXIiLCJldmVudCIsIm9yaWdpbmFsSGFuZGxlciIsImZpbHRlckNsaWNrIiwiYXR0YWNoRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJvcmlnaW5hbEV2ZW50IiwiX3N0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJyZXR1cm5WYWx1ZSIsImNsaWVudFgiLCJjbGllbnRZIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJ3aGVlbFB4RmFjdG9yIiwid2hlZWxEZWx0YVkiLCJkZWx0YVkiLCJkZWx0YU1vZGUiLCJkZWx0YVgiLCJkZWx0YVoiLCJ3aGVlbERlbHRhIiwiZGV0YWlsIiwic2tpcEV2ZW50cyIsImV2ZW50cyIsInJlbGF0ZWQiLCJyZWxhdGVkVGFyZ2V0IiwiZXJyIiwibGFzdENsaWNrIiwidGltZVN0YW1wIiwiZWxhcHNlZCIsInRhcmdldCIsIl9zaW11bGF0ZWRDbGljayIsIl9zaW11bGF0ZWQiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiQmFzZSIsIkhUTUxFbGVtZW50IiwiY3JlYXRlTWFwIiwiRG9tVXRpbCIsIk1hcCIsImNycyIsImNlbnRlciIsInpvb20iLCJtaW5ab29tIiwibWF4Wm9vbSIsImxheWVycyIsIm1heEJvdW5kcyIsInJlbmRlcmVyIiwiem9vbUFuaW1hdGlvbiIsInpvb21BbmltYXRpb25UaHJlc2hvbGQiLCJmYWRlQW5pbWF0aW9uIiwibWFya2VyWm9vbUFuaW1hdGlvbiIsInRyYW5zZm9ybTNETGltaXQiLCJ6b29tU25hcCIsInpvb21EZWx0YSIsInRyYWNrUmVzaXplIiwiaW5pdGlhbGl6ZSIsIl9pbml0Q29udGFpbmVyIiwiX2luaXRMYXlvdXQiLCJfb25SZXNpemUiLCJfaW5pdEV2ZW50cyIsInNldE1heEJvdW5kcyIsIl96b29tIiwiX2xpbWl0Wm9vbSIsInNldFZpZXciLCJyZXNldCIsIl9oYW5kbGVycyIsIl9sYXllcnMiLCJfem9vbUJvdW5kTGF5ZXJzIiwiX3NpemVDaGFuZ2VkIiwiY2FsbEluaXRIb29rcyIsIl96b29tQW5pbWF0ZWQiLCJfY3JlYXRlQW5pbVByb3h5IiwiX3Byb3h5IiwiX2NhdGNoVHJhbnNpdGlvbkVuZCIsIl9hZGRMYXllcnMiLCJfbGltaXRDZW50ZXIiLCJfc3RvcCIsIl9sb2FkZWQiLCJhbmltYXRlIiwicGFuIiwiZHVyYXRpb24iLCJtb3ZlZCIsIl90cnlBbmltYXRlZFpvb20iLCJfdHJ5QW5pbWF0ZWRQYW4iLCJfc2l6ZVRpbWVyIiwiX3Jlc2V0VmlldyIsInNldFpvb20iLCJnZXRDZW50ZXIiLCJ6b29tSW4iLCJkZWx0YSIsInpvb21PdXQiLCJzZXRab29tQXJvdW5kIiwibGF0bG5nIiwiZ2V0Wm9vbVNjYWxlIiwidmlld0hhbGYiLCJnZXRTaXplIiwiY29udGFpbmVyUG9pbnQiLCJsYXRMbmdUb0NvbnRhaW5lclBvaW50IiwiY2VudGVyT2Zmc2V0IiwibmV3Q2VudGVyIiwiY29udGFpbmVyUG9pbnRUb0xhdExuZyIsIl9nZXRCb3VuZHNDZW50ZXJab29tIiwiYm91bmRzIiwiZ2V0Qm91bmRzIiwicGFkZGluZ1RMIiwicGFkZGluZ1RvcExlZnQiLCJwYWRkaW5nIiwicGFkZGluZ0JSIiwicGFkZGluZ0JvdHRvbVJpZ2h0IiwiZ2V0Qm91bmRzWm9vbSIsIkluZmluaXR5IiwicGFkZGluZ09mZnNldCIsInN3UG9pbnQiLCJwcm9qZWN0IiwiZ2V0U291dGhXZXN0IiwibmVQb2ludCIsImdldE5vcnRoRWFzdCIsInVucHJvamVjdCIsImZpdEJvdW5kcyIsImlzVmFsaWQiLCJmaXRXb3JsZCIsInBhblRvIiwicGFuQnkiLCJmaXJlIiwiZ2V0Wm9vbSIsIl9wYW5BbmltIiwiX29uUGFuVHJhbnNpdGlvblN0ZXAiLCJfb25QYW5UcmFuc2l0aW9uRW5kIiwibm9Nb3ZlU3RhcnQiLCJfbWFwUGFuZSIsIm5ld1BvcyIsIl9nZXRNYXBQYW5lUG9zIiwicnVuIiwiZWFzZUxpbmVhcml0eSIsIl9yYXdQYW5CeSIsImZseVRvIiwidGFyZ2V0Q2VudGVyIiwidGFyZ2V0Wm9vbSIsImZyb20iLCJ0byIsInNpemUiLCJzdGFydFpvb20iLCJ3MCIsIncxIiwidTEiLCJyaG8iLCJyaG8yIiwiciIsInMxIiwiczIiLCJ0MSIsImIxIiwiYiIsInNxIiwibG9nIiwic2luaCIsIm4iLCJleHAiLCJjb3NoIiwidGFuaCIsInIwIiwidyIsInMiLCJ1IiwiZWFzZU91dCIsInQiLCJzdGFydCIsIm5vdyIsIlMiLCJmcmFtZSIsIl9mbHlUb0ZyYW1lIiwiX21vdmUiLCJnZXRTY2FsZVpvb20iLCJfbW92ZUVuZCIsIl9tb3ZlU3RhcnQiLCJmbHlUb0JvdW5kcyIsIl9wYW5JbnNpZGVNYXhCb3VuZHMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInBhbkluc2lkZUJvdW5kcyIsIl9lbmZvcmNpbmdCb3VuZHMiLCJpbnZhbGlkYXRlU2l6ZSIsIm9sZFNpemUiLCJfbGFzdENlbnRlciIsIm5ld1NpemUiLCJvbGRDZW50ZXIiLCJkZWJvdW5jZU1vdmVlbmQiLCJsb2NhdGUiLCJfbG9jYXRlT3B0aW9ucyIsInRpbWVvdXQiLCJ3YXRjaCIsIl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJvblJlc3BvbnNlIiwiX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UiLCJvbkVycm9yIiwiX2xvY2F0aW9uV2F0Y2hJZCIsImdlb2xvY2F0aW9uIiwid2F0Y2hQb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsInN0b3BMb2NhdGUiLCJjbGVhcldhdGNoIiwiZXJyb3IiLCJjIiwibGF0IiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsbmciLCJsb25naXR1ZGUiLCJ0b0JvdW5kcyIsImFjY3VyYWN5IiwidGltZXN0YW1wIiwiYWRkSGFuZGxlciIsIkhhbmRsZXJDbGFzcyIsImVuYWJsZSIsIl9jb250YWluZXJJZCIsIl9jb250YWluZXIiLCJfY2xlYXJDb250cm9sUG9zIiwiX2NsZWFySGFuZGxlcnMiLCJfcGFuZXMiLCJfcmVuZGVyZXIiLCJjcmVhdGVQYW5lIiwicGFuZSIsIl9jaGVja0lmTG9hZGVkIiwiX21vdmVkIiwibGF5ZXJQb2ludFRvTGF0TG5nIiwiX2dldENlbnRlckxheWVyUG9pbnQiLCJnZXRQaXhlbEJvdW5kcyIsInN3IiwiZ2V0Qm90dG9tTGVmdCIsIm5lIiwiZ2V0VG9wUmlnaHQiLCJnZXRNaW5ab29tIiwiX2xheWVyc01pblpvb20iLCJnZXRNYXhab29tIiwiX2xheWVyc01heFpvb20iLCJpbnNpZGUiLCJudyIsImdldE5vcnRoV2VzdCIsInNlIiwiZ2V0U291dGhFYXN0IiwiYm91bmRzU2l6ZSIsInNuYXAiLCJzY2FsZXgiLCJzY2FsZXkiLCJfc2l6ZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidG9wTGVmdFBvaW50IiwiX2dldFRvcExlZnRQb2ludCIsImdldFBpeGVsT3JpZ2luIiwiX3BpeGVsT3JpZ2luIiwiZ2V0UGl4ZWxXb3JsZEJvdW5kcyIsImdldFByb2plY3RlZEJvdW5kcyIsImdldFBhbmUiLCJnZXRQYW5lcyIsImdldENvbnRhaW5lciIsInRvWm9vbSIsImZyb21ab29tIiwiaXNOYU4iLCJsYXRMbmdUb1BvaW50IiwicG9pbnRUb0xhdExuZyIsInByb2plY3RlZFBvaW50IiwibGF0TG5nVG9MYXllclBvaW50Iiwid3JhcExhdExuZyIsIndyYXBMYXRMbmdCb3VuZHMiLCJkaXN0YW5jZSIsImxhdGxuZzEiLCJsYXRsbmcyIiwiY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQiLCJsYXllclBvaW50VG9Db250YWluZXJQb2ludCIsImxheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCIsIm1vdXNlRXZlbnRUb0xheWVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXRMbmciLCJfb25TY3JvbGwiLCJfZmFkZUFuaW1hdGVkIiwicG9zaXRpb24iLCJfaW5pdFBhbmVzIiwiX2luaXRDb250cm9sUG9zIiwicGFuZXMiLCJfcGFuZVJlbmRlcmVycyIsIm1hcmtlclBhbmUiLCJzaGFkb3dQYW5lIiwibG9hZGluZyIsInpvb21DaGFuZ2VkIiwiX2dldE5ld1BpeGVsT3JpZ2luIiwicGluY2giLCJfZ2V0Wm9vbVNwYW4iLCJfdGFyZ2V0cyIsIm9uT2ZmIiwiX2hhbmRsZURPTUV2ZW50IiwiX29uTW92ZUVuZCIsIl9yZXNpemVSZXF1ZXN0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIl9maW5kRXZlbnRUYXJnZXRzIiwidGFyZ2V0cyIsImlzSG92ZXIiLCJzcmNFbGVtZW50IiwiZHJhZ2dpbmciLCJfZHJhZ2dhYmxlTW92ZWQiLCJsaXN0ZW5zIiwiX2ZpcmVET01FdmVudCIsIl9tb3VzZUV2ZW50cyIsInN5bnRoIiwiaXNNYXJrZXIiLCJnZXRMYXRMbmciLCJidWJibGluZ01vdXNlRXZlbnRzIiwiZW5hYmxlZCIsImJveFpvb20iLCJkaXNhYmxlIiwid2hlblJlYWR5IiwiY2FsbGJhY2siLCJwaXhlbE9yaWdpbiIsIl9sYXRMbmdUb05ld0xheWVyUG9pbnQiLCJ0b3BMZWZ0IiwiX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJfZ2V0Q2VudGVyT2Zmc2V0IiwiY2VudGVyUG9pbnQiLCJ2aWV3Qm91bmRzIiwiX2dldEJvdW5kc09mZnNldCIsIl9saW1pdE9mZnNldCIsIm5ld0JvdW5kcyIsInB4Qm91bmRzIiwicHJvamVjdGVkTWF4Qm91bmRzIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiZHgiLCJfcmVib3VuZCIsImR5IiwicmlnaHQiLCJwcm94eSIsIm1hcFBhbmUiLCJ0cmFuc2Zvcm0iLCJfYW5pbWF0aW5nWm9vbSIsIl9vblpvb21UcmFuc2l0aW9uRW5kIiwieiIsIl9vbiIsIl9kZXN0cm95QW5pbVByb3h5IiwicHJvcGVydHlOYW1lIiwiX25vdGhpbmdUb0FuaW1hdGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiX2FuaW1hdGVab29tIiwic3RhcnRBbmltIiwibm9VcGRhdGUiLCJfYW5pbWF0ZVRvQ2VudGVyIiwiX2FuaW1hdGVUb1pvb20iLCJCb3VuZHMiLCJhIiwicG9pbnRzIiwiZ2V0VG9wTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiaW50ZXJzZWN0cyIsIm1pbjIiLCJtYXgyIiwieEludGVyc2VjdHMiLCJ5SW50ZXJzZWN0cyIsIm92ZXJsYXBzIiwieE92ZXJsYXBzIiwieU92ZXJsYXBzIiwiTGF0TG5nIiwidG9MYXRMbmciLCJhbHQiLCJtYXhNYXJnaW4iLCJtYXJnaW4iLCJwcmVjaXNpb24iLCJvdGhlciIsIndyYXAiLCJzaXplSW5NZXRlcnMiLCJsYXRBY2N1cmFjeSIsImxuZ0FjY3VyYWN5IiwiY29zIiwiUEkiLCJsb24iLCJMYXRMbmdCb3VuZHMiLCJ0b0xhdExuZ0JvdW5kcyIsImNvcm5lcjEiLCJjb3JuZXIyIiwibGF0bG5ncyIsIl9zb3V0aFdlc3QiLCJfbm9ydGhFYXN0Iiwic3cyIiwibmUyIiwicGFkIiwiYnVmZmVyUmF0aW8iLCJoZWlnaHRCdWZmZXIiLCJ3aWR0aEJ1ZmZlciIsImdldE5vcnRoIiwiZ2V0V2VzdCIsImdldFNvdXRoIiwiZ2V0RWFzdCIsImxhdEludGVyc2VjdHMiLCJsbmdJbnRlcnNlY3RzIiwibGF0T3ZlcmxhcHMiLCJsbmdPdmVybGFwcyIsInRvQkJveFN0cmluZyIsIkVsZW1lbnQiLCJMYXllciIsImF0dHJpYnV0aW9uIiwiYWRkVG8iLCJtYXAiLCJhZGRMYXllciIsInJlbW92ZUZyb20iLCJfbWFwIiwiX21hcFRvQWRkIiwicmVtb3ZlTGF5ZXIiLCJhZGRJbnRlcmFjdGl2ZVRhcmdldCIsInRhcmdldEVsIiwicmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQiLCJnZXRBdHRyaWJ1dGlvbiIsIl9sYXllckFkZCIsImhhc0xheWVyIiwiZ2V0RXZlbnRzIiwib25jZSIsIm9uQWRkIiwiYXR0cmlidXRpb25Db250cm9sIiwiYWRkQXR0cmlidXRpb24iLCJsYXllciIsImluY2x1ZGUiLCJiZWZvcmVBZGQiLCJvblJlbW92ZSIsInJlbW92ZUF0dHJpYnV0aW9uIiwiZWFjaExheWVyIiwibWV0aG9kIiwiX2FkZFpvb21MaW1pdCIsIl91cGRhdGVab29tTGV2ZWxzIiwiX3JlbW92ZVpvb21MaW1pdCIsIm9sZFpvb21TcGFuIiwiZGVkdXBlSWQiLCJNaXhpbkZ1bmN0aW9uIiwiX19taXhpbkFwcGxpY2F0aW9ucyIsIl9fbWl4aW5TZXQiLCJkZWR1cGluZ01peGluIiwibWl4aW4iLCJtaXhpbkFwcGxpY2F0aW9ucyIsIldlYWtNYXAiLCJtaXhpbkRlZHVwZUlkIiwiYmFzZSIsImJhc2VTZXQiLCJleHRlbmRlZCIsInNldCIsIm1peGluU2V0IiwiSGFuZGxlciIsIl9lbmFibGVkIiwiYWRkSG9va3MiLCJyZW1vdmVIb29rcyIsIkFzeW5jSW50ZXJmYWNlIiwibWljcm90YXNrQ3VyckhhbmRsZSIsIm1pY3JvdGFza0xhc3RIYW5kbGUiLCJtaWNyb3Rhc2tDYWxsYmFja3MiLCJtaWNyb3Rhc2tOb2RlQ29udGVudCIsIm1pY3JvdGFza05vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJtaWNyb3Rhc2tGbHVzaCIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwiY2IiLCJzcGxpY2UiLCJ0aW1lT3V0IiwiYWZ0ZXIiLCJkZWxheSIsImNhbmNlbCIsImFuaW1hdGlvbkZyYW1lIiwiaWRsZVBlcmlvZCIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYW5kbGUiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJtaWNyb1Rhc2siLCJ0ZXh0Q29udGVudCIsImlkeCIsIkVhcnRoIiwid3JhcExuZyIsIlIiLCJyYWQiLCJsYXQxIiwibGF0MiIsInNpbiIsImFjb3MiLCJwIiwibm9ybWFsaXplZE1hdGNoZXNTZWxlY3RvciIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJub2RlIiwic2VsZWN0b3IiLCJEb21BcGkiLCJvYnNlcnZlckhhbmRsZSIsImRpc2Nvbm5lY3QiLCJkb2MiLCJvd25lckRvY3VtZW50IiwiaG9zdCIsImdldFJvb3ROb2RlIiwibG9jYWxOYW1lIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCJpcCQiLCJhc3NpZ25lZFNsb3QiLCJkZWVwIiwiRG9jdW1lbnQiLCJpbXBvcnROb2RlIiwiZ2V0RmxhdHRlbmVkTm9kZXMiLCJjJCIsImdldEVmZmVjdGl2ZUNoaWxkTm9kZXMiLCJsaXN0IiwibCIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsIl9hY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsImZvcndhcmRNZXRob2RzIiwibWV0aG9kcyIsImZvcndhcmRSZWFkT25seVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJmb3J3YXJkUHJvcGVydGllcyIsIkV2ZW50QXBpIiwiY29tcG9zZWRQYXRoIiwiZG9tIiwiX19kb21BcGkiLCJoZWxwZXIiLCJFdmVudCIsImZsdXNoIiwiYWRkRGVib3VuY2VyIiwiRmVhdHVyZUdyb3VwIiwiYWRkRXZlbnRQYXJlbnQiLCJyZW1vdmVFdmVudFBhcmVudCIsInNldFN0eWxlIiwiaW52b2tlIiwiYnJpbmdUb0Zyb250IiwiYnJpbmdUb0JhY2siLCJmZWF0dXJlR3JvdXAiLCJFdmVudHMiLCJfZXZlbnRzIiwiX29mZiIsInR5cGVMaXN0ZW5lcnMiLCJuZXdMaXN0ZW5lciIsImN0eCIsImxpc3RlbmVycyIsIl9maXJpbmdDb3VudCIsInByb3BhZ2F0ZSIsIl9wcm9wYWdhdGVFdmVudCIsIl9ldmVudFBhcmVudHMiLCJjbGVhckFsbEV2ZW50TGlzdGVuZXJzIiwiYWRkT25lVGltZUV2ZW50TGlzdGVuZXIiLCJmaXJlRXZlbnQiLCJoYXNFdmVudExpc3RlbmVycyIsIkV2ZW50ZWQiLCJDbGFzcyIsIk5ld0NsYXNzIiwicGFyZW50UHJvdG8iLCJfX3N1cGVyX18iLCJjb25zdHJ1Y3RvciIsInN0YXRpY3MiLCJpbmNsdWRlcyIsImNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzIiwiX2luaXRIb29rcyIsIl9pbml0SG9va3NDYWxsZWQiLCJtZXJnZU9wdGlvbnMiLCJhZGRJbml0SG9vayIsImluaXQiLCJMIiwiTWl4aW4iLCJjb25zb2xlIiwid2FybiIsInN0YWNrIiwiVHJhbnNmb3JtYXRpb24iLCJ0b1RyYW5zZm9ybWF0aW9uIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfdHJhbnNmb3JtIiwidW50cmFuc2Zvcm0iLCJDb250cm9sIiwicmVtb3ZlQ29udHJvbCIsImFkZENvbnRyb2wiLCJjb3JuZXIiLCJfY29udHJvbENvcm5lcnMiLCJfcmVmb2N1c09uTWFwIiwic2NyZWVuWCIsInNjcmVlblkiLCJmb2N1cyIsImNvbnRyb2wiLCJjb3JuZXJzIiwiX2NvbnRyb2xDb250YWluZXIiLCJjcmVhdGVDb3JuZXIiLCJ2U2lkZSIsImhTaWRlIiwiUGF0aCIsInN0cm9rZSIsImNvbG9yIiwid2VpZ2h0IiwibGluZUNhcCIsImxpbmVKb2luIiwiZGFzaEFycmF5IiwiZGFzaE9mZnNldCIsImZpbGwiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImZpbGxSdWxlIiwiaW50ZXJhY3RpdmUiLCJnZXRSZW5kZXJlciIsIl9pbml0UGF0aCIsIl9yZXNldCIsIl9hZGRQYXRoIiwiX3JlbW92ZVBhdGgiLCJyZWRyYXciLCJfdXBkYXRlUGF0aCIsIl91cGRhdGVTdHlsZSIsIl9icmluZ1RvRnJvbnQiLCJfYnJpbmdUb0JhY2siLCJnZXRFbGVtZW50IiwiX3BhdGgiLCJfcHJvamVjdCIsIl91cGRhdGUiLCJfY2xpY2tUb2xlcmFuY2UiLCJzaW1wbGlmeSIsInBvaW50VG9TZWdtZW50RGlzdGFuY2UiLCJjbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJjbGlwU2VnbWVudCIsIl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwiX2dldEJpdENvZGUiLCJfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJpc0ZsYXQiLCJfZmxhdCIsInRvbGVyYW5jZSIsInNxVG9sZXJhbmNlIiwiX3JlZHVjZVBvaW50cyIsIl9zaW1wbGlmeURQIiwicDEiLCJwMiIsIkFycmF5Q29uc3RydWN0b3IiLCJVaW50OEFycmF5IiwibWFya2VycyIsIl9zaW1wbGlmeURQU3RlcCIsIm5ld1BvaW50cyIsImZpcnN0IiwibGFzdCIsIm1heFNxRGlzdCIsImluZGV4Iiwic3FEaXN0IiwicmVkdWNlZFBvaW50cyIsInByZXYiLCJfc3FEaXN0IiwiX2xhc3RDb2RlIiwidXNlTGFzdENvZGUiLCJjb2RlQSIsImNvZGVCIiwiY29kZU91dCIsIm5ld0NvZGUiLCJkb3QiLCJDU1NfVVJMX1JYIiwiQUJTX1VSTCIsIndvcmtpbmdVUkwiLCJyZXNvbHZlRG9jIiwicmVzb2x2ZVVybCIsInVybCIsImJhc2VVUkkiLCJVUkwiLCJwYXRobmFtZSIsImhyZWYiLCJsb2NhdGlvbiIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiaGVhZCIsImFuY2hvciIsImJvZHkiLCJyZXNvbHZlQ3NzIiwiY3NzVGV4dCIsIm0iLCJwcmUiLCJwb3N0IiwicGF0aEZyb21VcmwiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImlzUGF0aCIsInJvb3QiLCJpc0FuY2VzdG9yIiwiaXNEZXNjZW5kYW50IiwidHJhbnNsYXRlIiwibm9ybWFsaXplIiwicGF0aCIsImRvdEluZGV4IiwibmV3QmFzZSIsInBhcnRzIiwiaW5mbyIsInBhcnQiLCJpc0RlZXAiLCJBc3luY01vZHVsZSIsIkRlYm91bmNlciIsIl9hc3luY01vZHVsZSIsIl9jYWxsYmFjayIsIl90aW1lciIsImFzeW5jTW9kdWxlIiwiaXNBY3RpdmUiLCJkZWJvdW5jZXIiLCJzZXRDb25maWciLCJrbGFzcyIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIiwiaXMiLCJtdXRhYmxlUHJvcGVydHlDaGFuZ2UiLCJpbnN0IiwicHJvcGVydHkiLCJvbGQiLCJtdXRhYmxlRGF0YSIsImlzT2JqZWN0IiwiX19kYXRhVGVtcCIsInNob3VsZENoYW5nZSIsIk11dGFibGVEYXRhIiwic3VwZXJDbGFzcyIsIk9wdGlvbmFsTXV0YWJsZURhdGEiLCJCb29sZWFuIiwiX211dGFibGVQcm9wZXJ0eUNoYW5nZSIsImljb24iLCJJY29uIiwiY3JlYXRlSWNvbiIsIm9sZEljb24iLCJfY3JlYXRlSWNvbiIsImNyZWF0ZVNoYWRvdyIsIl9nZXRJY29uVXJsIiwiaW1nIiwiX2NyZWF0ZUltZyIsIl9zZXRJY29uU3R5bGVzIiwic2l6ZU9wdGlvbiIsInNoYWRvd0FuY2hvciIsImljb25BbmNob3IiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwid2lkdGgiLCJoZWlnaHQiLCJSZW5kZXJlciIsIl91cGRhdGVQYXRocyIsIl9kZXN0cm95Q29udGFpbmVyIiwidmlld3Jlc2V0IiwiX29uWm9vbSIsIm1vdmVlbmQiLCJ6b29tZW5kIiwiX29uWm9vbUVuZCIsInpvb21hbmltIiwiX29uQW5pbVpvb20iLCJldiIsIl91cGRhdGVUcmFuc2Zvcm0iLCJjdXJyZW50Q2VudGVyUG9pbnQiLCJfY2VudGVyIiwiZGVzdENlbnRlclBvaW50IiwidG9wTGVmdE9mZnNldCIsIl9ib3VuZHMiLCJjaXJjbGVNYXJrZXIiLCJDaXJjbGVNYXJrZXIiLCJyYWRpdXMiLCJfbGF0bG5nIiwiX3JhZGl1cyIsInNldExhdExuZyIsInNldFJhZGl1cyIsImdldFJhZGl1cyIsIl9wb2ludCIsIl91cGRhdGVCb3VuZHMiLCJyMiIsIl9yYWRpdXNZIiwiX3B4Qm91bmRzIiwiX3VwZGF0ZUNpcmNsZSIsIl9lbXB0eSIsIl9jb250YWluc1BvaW50IiwiX3JlZ0xvZyIsInJlZ2lzdGVyIiwiZHVtcFJlZ2lzdHJhdGlvbnMiLCJjYXNlTWFwJDAiLCJFbGVtZW50TWl4aW4iLCJwb2x5bWVyRWxlbWVudEJhc2UiLCJjYXNlTWFwIiwib3duUHJvcGVydGllc0ZvckNsYXNzIiwiX19vd25Qcm9wZXJ0aWVzIiwib3duT2JzZXJ2ZXJzRm9yQ2xhc3MiLCJfX293bk9ic2VydmVycyIsIm9ic2VydmVycyIsImZsYXR0ZW5Qcm9wZXJ0aWVzIiwiZmxhdHRlbmVkUHJvcHMiLCJvIiwicHJvcGVydGllc0ZvckNsYXNzIiwiX19jbGFzc1Byb3BlcnRpZXMiLCJzdXBlckN0b3IiLCJnZXRQcm90b3R5cGVPZiIsIlBvbHltZXJFbGVtZW50IiwiYXNzaWduIiwicHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzIiwiX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMiLCJoYXNDbGFzc0ZpbmFsaXplZCIsImZpbmFsaXplQ2xhc3NBbmRTdXBlciIsImZpbmFsaXplIiwiZmluYWxpemVDbGFzcyIsIl9fZmluYWxpemVkIiwiZmluYWxpemVQcm9wZXJ0aWVzIiwiZmluYWxpemVPYnNlcnZlcnMiLCJjbG9uZU5vZGUiLCJfdGVtcGxhdGUiLCJjcmVhdGVQcm9wZXJ0eUZyb21Db25maWciLCJkeW5hbWljRm5zIiwiX2NyZWF0ZU1ldGhvZE9ic2VydmVyIiwiYWxsUHJvcHMiLCJjb21wdXRlZCIsInJlYWRPbmx5IiwiX2hhc1JlYWRPbmx5RWZmZWN0IiwiX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkiLCJfY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eSIsInJlZmxlY3RUb0F0dHJpYnV0ZSIsIl9oYXNSZWZsZWN0RWZmZWN0IiwiX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5Iiwibm90aWZ5IiwiX2hhc05vdGlmeUVmZmVjdCIsIl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eSIsIm9ic2VydmVyIiwiX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIiLCJmaW5hbGl6ZVRlbXBsYXRlIiwiZXh0IiwiY29udGVudCIsIlNoYWR5Q1NTIiwicHJlcGFyZVRlbXBsYXRlIiwiX2JpbmRUZW1wbGF0ZSIsIl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiaW1wb3J0IiwibW9kdWxlIiwiX2ltcG9ydFBhdGgiLCJhc3NldHBhdGgiLCJpbXBvcnRQYXRoIiwicm9vdFBhdGgiLCIkIiwiaW5zdGFuY2VDb3VudCIsIl9fcG9seW1lckZpbmFsaXplZCIsIl9fcHJvdG9fXyIsInAkIiwiX2hhc0FjY2Vzc29yIiwiX3NldFBlbmRpbmdQcm9wZXJ0eSIsInN0eWxlRWxlbWVudCIsIl9lbmFibGVQcm9wZXJ0aWVzIiwiX3N0YW1wVGVtcGxhdGUiLCJfYXR0YWNoRG9tIiwiYXR0YWNoU2hhZG93Iiwic2hhZG93Um9vdCIsIm1vZGUiLCJkYXNoVG9DYW1lbENhc2UiLCJfYXR0cmlidXRlVG9Qcm9wZXJ0eSIsInN0eWxlU3VidHJlZSIsInRlbXBsYXRlSW5mbyIsIm5vZGVJbmZvIiwicmVnaXN0cmF0aW9ucyIsImZvckVhY2giLCJ1cGRhdGVTdHlsZXMiLCJzdHlsZURvY3VtZW50Iiwic2V0dGluZ3MiLCJ1c2VTaGFkb3ciLCJTaGFkeURPTSIsInVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMiLCJuYXRpdmVDc3MiLCJ1c2VOYXRpdmVDdXN0b21FbGVtZW50cyIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJTZXR0aW5ncyIsInNldFJvb3RQYXRoIiwic2FuaXRpemVET01WYWx1ZSIsInNldFNhbml0aXplRE9NVmFsdWUiLCJuZXdTYW5pdGl6ZURPTVZhbHVlIiwiY2FtZWxUb0Rhc2hDYXNlIiwiREFTSF9UT19DQU1FTCIsIkNBTUVMX1RPX0RBU0giLCJkYXNoIiwiY2FtZWwiLCJDYXNlTWFwIiwiVFlQRVMiLCJDT01QVVRFIiwiUkVGTEVDVCIsIk5PVElGWSIsIlBST1BBR0FURSIsIk9CU0VSVkUiLCJSRUFEX09OTFkiLCJEYXRhVHJpZ2dlciIsIkRhdGFFZmZlY3QiLCJQcm9wZXJ0eUVmZmVjdHNUeXBlIiwiZW5zdXJlT3duRWZmZWN0TWFwIiwibW9kZWwiLCJlZmZlY3RzIiwicHJvdG9GeCIsImluc3RGeCIsInJ1bkVmZmVjdHMiLCJvbGRQcm9wcyIsImhhc1BhdGhzIiwiZXh0cmFBcmdzIiwicmFuIiwicnVuRWZmZWN0c0ZvclByb3BlcnR5Iiwicm9vdFByb3BlcnR5IiwiZnhzIiwiZngiLCJsYXN0UnVuIiwicGF0aE1hdGNoZXNUcmlnZ2VyIiwidHJpZ2dlciIsInRyaWdnZXJQYXRoIiwic3RydWN0dXJlZCIsIndpbGRjYXJkIiwicnVuT2JzZXJ2ZXJFZmZlY3QiLCJtZXRob2ROYW1lIiwiY2hhbmdlZFByb3AiLCJfX2RhdGEiLCJkeW5hbWljRm4iLCJydW5Ob3RpZnlFZmZlY3RzIiwibm90aWZ5UHJvcHMiLCJub3RpZmllZCIsIm5vdGlmeVBhdGgiLCJfX2RhdGFIb3N0IiwiX2ludmFsaWRhdGVQcm9wZXJ0aWVzIiwiZXZlbnROYW1lIiwiZGlzcGF0Y2hOb3RpZnlFdmVudCIsInF1ZXVlUHJvcGVydHkiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJydW5Ob3RpZnlFZmZlY3QiLCJoYW5kbGVOb3RpZmljYXRpb24iLCJmcm9tUHJvcCIsInRvUGF0aCIsIm5lZ2F0ZSIsImZyb21QYXRoIiwiX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCIsInJ1blJlZmxlY3RFZmZlY3QiLCJhdHRyTmFtZSIsIl9wcm9wZXJ0eVRvQXR0cmlidXRlIiwicnVuQ29tcHV0ZWRFZmZlY3RzIiwiY2hhbmdlZFByb3BzIiwiY29tcHV0ZUVmZmVjdHMiLCJpbnB1dFByb3BzIiwiX19kYXRhT2xkIiwiX19kYXRhUGVuZGluZyIsInJ1bkNvbXB1dGVkRWZmZWN0IiwicmVzdWx0IiwicnVuTWV0aG9kRWZmZWN0IiwiY29tcHV0ZWRQcm9wIiwibWV0aG9kSW5mbyIsIl9fZGF0YUhhc0FjY2Vzc29yIiwiY29tcHV0ZUxpbmtlZFBhdGhzIiwibGlua3MiLCJfX2RhdGFMaW5rZWRQYXRocyIsImxpbmsiLCJhZGRCaW5kaW5nIiwia2luZCIsImxpdGVyYWwiLCJiaW5kaW5ncyIsImJpbmRpbmciLCJpc0NvbXBvdW5kIiwic2hvdWxkQWRkTGlzdGVuZXIiLCJsaXN0ZW5lckV2ZW50IiwibGlzdGVuZXJOZWdhdGUiLCJub2RlSW5mb0xpc3QiLCJjb21wb3VuZEluZGV4IiwiYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQiLCJkZXBlbmRlbmNpZXMiLCJldmFsdWF0b3IiLCJwYXJzZUFyZyIsIl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0IiwicnVuQmluZGluZ0VmZmVjdCIsIm5vZGVMaXN0Iiwic291cmNlIiwiX2VucXVldWVDbGllbnQiLCJfZXZhbHVhdGVCaW5kaW5nIiwiYXBwbHlCaW5kaW5nVmFsdWUiLCJjb21wdXRlQmluZGluZ1ZhbHVlIiwiX3ZhbHVlVG9Ob2RlQXR0cmlidXRlIiwiX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlIiwic3RvcmFnZSIsIl9fZGF0YUNvbXBvdW5kU3RvcmFnZSIsInNldHVwQmluZGluZ3MiLCJzZXR1cENvbXBvdW5kU3RvcmFnZSIsImFkZE5vdGlmeUxpc3RlbmVyIiwibGl0ZXJhbHMiLCJjcmVhdGVNZXRob2RFZmZlY3QiLCJzaWciLCJlZmZlY3RGbiIsInN0YXRpYyIsImFyZyIsIl9hZGRQcm9wZXJ0eUVmZmVjdCIsIl9tZXRob2RIb3N0IiwibWFyc2hhbEFyZ3MiLCJlbXB0eUFycmF5IiwiSURFTlQiLCJOVU1CRVIiLCJTUVVPVEVfU1RSSU5HIiwiRFFVT1RFX1NUUklORyIsIlNUUklORyIsIkFSR1VNRU5UIiwiQVJHVU1FTlRTIiwiQVJHVU1FTlRfTElTVCIsIkJJTkRJTkciLCJPUEVOX0JSQUNLRVQiLCJDTE9TRV9CUkFDS0VUIiwiTkVHQVRFIiwiRVhQUkVTU0lPTiIsImJpbmRpbmdSZWdleCIsImxpdGVyYWxGcm9tUGFydHMiLCJwYXJzZU1ldGhvZCIsImV4cHJlc3Npb24iLCJtYXRjaCIsInBhcnNlQXJncyIsImFyZ0xpc3QiLCJyYXdBcmciLCJmYyIsIk51bWJlciIsInZhbHVlcyIsInYiLCJiYXNlQ2hhbmdlZCIsIm5vdGlmeVNwbGljZXMiLCJzcGxpY2VzIiwic3BsaWNlc1BhdGgiLCJpbmRleFNwbGljZXMiLCJub3RpZnlTcGxpY2UiLCJhZGRlZENvdW50IiwicmVtb3ZlZCIsIm9iamVjdCIsInVwcGVyIiwiUHJvcGVydHlFZmZlY3RzIiwicHJvcGVydHlFZmZlY3RzQmFzZSIsIl9fZGF0YUNsaWVudHNSZWFkeSIsIl9fZGF0YVBlbmRpbmdDbGllbnRzIiwiX19kYXRhVG9Ob3RpZnkiLCJfX2RhdGFIYXNQYXRocyIsIl9fZGF0YUNsaWVudHNJbml0aWFsaXplZCIsIl9fY29tcHV0ZUVmZmVjdHMiLCJfX3JlZmxlY3RFZmZlY3RzIiwiX19ub3RpZnlFZmZlY3RzIiwiX19wcm9wYWdhdGVFZmZlY3RzIiwiX19vYnNlcnZlRWZmZWN0cyIsIl9fcmVhZE9ubHkiLCJfX2RhdGFDb3VudGVyIiwiX190ZW1wbGF0ZUluZm8iLCJob3N0U3RhY2siLCJyZWdpc3Rlckhvc3QiLCJlZmZlY3QiLCJfY3JlYXRlUHJvcGVydHlBY2Nlc3NvciIsIl9oYXNQcm9wZXJ0eUVmZmVjdCIsInNob3VsZE5vdGlmeSIsImlzUGF0aE5vdGlmaWNhdGlvbiIsInByZXZQcm9wcyIsIl9zaG91bGRQcm9wZXJ0eUNoYW5nZSIsIl9fZGF0YVJlYWR5IiwiX2ZsdXNoUHJvcGVydGllcyIsImNsaWVudCIsIl9yZWFkeUNsaWVudHMiLCJfX2VuYWJsZU9yRmx1c2hDbGllbnRzIiwiY2xpZW50cyIsIl9fZGF0YUVuYWJsZWQiLCJzZXRSZWFkT25seSIsIl9mbHVzaENsaWVudHMiLCJjdXJyZW50UHJvcHMiLCJfcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzIiwicHJvcGVydHlFZmZlY3RzIiwibmV4dFRlbXBsYXRlSW5mbyIsIml0ZW1zIiwicmV0IiwiaGFkTGVuZ3RoIiwicG9wIiwiZGVsZXRlQ291bnQiLCJzaGlmdCIsInVuc2hpZnQiLCJwcm9wUGF0aCIsInByb3RlY3RlZFNldHRlciIsIl9zZXRQcm9wZXJ0eSIsImF0dHIiLCJpbnN0YW5jZUJpbmRpbmciLCJfcGFyc2VUZW1wbGF0ZSIsIndhc1ByZUJvdW5kIiwiX190ZW1wbGF0ZUluZm9MYXN0IiwicHJldmlvdXNUZW1wbGF0ZUluZm8iLCJiZWdpbkhvc3RpbmciLCJlbmRIb3N0aW5nIiwibm9kZXMiLCJjaGlsZE5vZGVzIiwibmV4dFNpYmxpbmciLCJob3N0UHJvcHMiLCJwcm9wRWZmZWN0cyIsIm5vdGVkIiwiVEVYVF9OT0RFIiwiX3BhcnNlQmluZGluZ3MiLCJvcmlnTmFtZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInRleHQiLCJsYXN0SW5kZXgiLCJleGVjIiwiY3VzdG9tRXZlbnQiLCJub3RpZnlFdmVudCIsImNvbG9uIiwic2lnbmF0dXJlIiwic3RhY2tMZW4iLCJuYXRpdmVTaGFkb3ciLCJuYXRpdmVDc3NWYXJpYWJsZXMiLCJjYWxjQ3NzVmFyaWFibGVzIiwiQ1NTIiwic3VwcG9ydHMiLCJwYXJzZSIsInN0cmluZ2lmeSIsInJlbW92ZUN1c3RvbVByb3BBc3NpZ25tZW50IiwiU3R5bGVOb2RlIiwiY2xlYW4iLCJwYXJzZUNzcyIsImxleCIsIlJYIiwiY29tbWVudHMiLCJwb3J0IiwiT1BFTl9CUkFDRSIsInByZXZpb3VzIiwiQ0xPU0VfQlJBQ0UiLCJzcyIsIl9leHBhbmRVbmljb2RlRXNjYXBlcyIsIm11bHRpcGxlU3BhY2VzIiwiQVRfU1RBUlQiLCJNRURJQV9TVEFSVCIsIk1FRElBX1JVTEUiLCJrZXlmcmFtZXNSdWxlIiwiS0VZRlJBTUVTX1JVTEUiLCJWQVJfU1RBUlQiLCJNSVhJTl9SVUxFIiwiU1RZTEVfUlVMRSIsInIkIiwicmVwZWF0IiwicHJlc2VydmVQcm9wZXJ0aWVzIiwiX2hhc01peGluUnVsZXMiLCJyZW1vdmVDdXN0b21Qcm9wcyIsInJ1bGVzIiwicmVtb3ZlQ3VzdG9tUHJvcEFwcGx5IiwiY3VzdG9tUHJvcCIsIm1peGluUHJvcCIsIm1peGluQXBwbHkiLCJ2YXJBcHBseSIsIlZBUl9BU1NJR04iLCJNSVhJTl9NQVRDSCIsIlZBUl9DT05TVU1FRCIsIkFOSU1BVElPTl9NQVRDSCIsIk1FRElBX01BVENIIiwiSVNfVkFSIiwiQlJBQ0tFVEVEIiwiSE9TVF9QUkVGSVgiLCJIT1NUX1NVRkZJWCIsInVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJkZXRlY3RNaXhpbiIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaGFzIiwiZGVlcFRhcmdldEZpbmQiLCJfZmluZE9yaWdpbmFsVGFyZ2V0IiwiX2hhbmRsZU5hdGl2ZSIsIl9oYW5kbGVUb3VjaEFjdGlvbiIsIl9yZW1vdmUiLCJfZmluZFJlY29nbml6ZXJCeUV2ZW50Iiwic2V0VG91Y2hBY3Rpb24iLCJyZXNldE1vdXNlQ2FuY2VsbGVyIiwiSEFTX05BVElWRV9UQSIsInRvdWNoQWN0aW9uIiwiR0VTVFVSRV9LRVkiLCJIQU5ETEVEX09CSiIsIlRPVUNIX0FDVElPTiIsIlRBUF9ESVNUQU5DRSIsIlRSQUNLX0RJU1RBTkNFIiwiVFJBQ0tfTEVOR1RIIiwiTU9VU0VfVElNRU9VVCIsIk1PVVNFX0VWRU5UUyIsIk1PVVNFX1dISUNIX1RPX0JVVFRPTlMiLCJNT1VTRV9IQVNfQlVUVE9OUyIsIk1vdXNlRXZlbnQiLCJidXR0b25zIiwiU1VQUE9SVFNfUEFTU0lWRSIsIm9wdHMiLCJJU19UT1VDSF9PTkxZIiwiR2VzdHVyZVJlY29nbml6ZXIiLCJtb3VzZWRvd24iLCJtb3VzZW1vdmUiLCJtb3VzZXVwIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwiY2xpY2siLCJtb3VzZUNhbmNlbGxlciIsIm1vdXNlRXZlbnQiLCJzYyIsInNvdXJjZUNhcGFiaWxpdGllcyIsImZpcmVzVG91Y2hFdmVudHMiLCJza2lwIiwiUE9JTlRFUlNUQVRFIiwibW91c2UiLCJzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIiLCJzZXR1cCIsImVuIiwiaWdub3JlTW91c2UiLCJtb3VzZUlnbm9yZUpvYiIsInVuc2V0IiwiZGVib3VuY2UiLCJoYXNMZWZ0TW91c2VCdXR0b24iLCJ3aGljaCIsImJ1dHRvbiIsImlzU3ludGhldGljQ2xpY2siLCJiY3IiLCJwYWdlWCIsInBhZ2VZIiwiYm90dG9tIiwic2Nyb2xsRGVjaWRlZCIsImZpcnN0VG91Y2hBY3Rpb24iLCJ0YSIsInRyYWNrRG9jdW1lbnQiLCJzdGF0ZU9iaiIsIm1vdmVmbiIsInVwZm4iLCJ1bnRyYWNrRG9jdW1lbnQiLCJwYXNzaXZlIiwiZ2VzdHVyZXMiLCJyZWNvZ25pemVycyIsImVsZW1lbnRGcm9tUG9pbnQiLCJuZXh0Iiwib2xkTmV4dCIsImhhbmRsZWQiLCJjdXJyZW50VGFyZ2V0IiwiZ29iaiIsImdzIiwiY2hhbmdlZFRvdWNoZXMiLCJ0b3VjaGVzIiwiaWRlbnRpZmllciIsImZsb3ciLCJwcmV2ZW50IiwiY2FuY2VsYWJsZSIsImV2VHlwZSIsInJlY29nbml6ZXIiLCJkZXBzIiwiZGVwIiwiZ2QiLCJfY291bnQiLCJyZWNvZyIsImVtaXRzIiwiZXZOYW1lIiwiX2ZpcmUiLCJidWJibGVzIiwiY29tcG9zZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicHJldmVudGVyIiwic291cmNlRXZlbnQiLCJlbmQiLCJzZWxmIiwic3RhdGUiLCJzdGFydGVkIiwibW92ZXMiLCJhZGRNb3ZlIiwibW92ZSIsImhhc01vdmVkRW5vdWdoIiwiY3QiLCJzZWNvbmRsYXN0IiwibGFzdG1vdmUiLCJkZHgiLCJkZHkiLCJob3ZlciIsIk5hTiIsInNhdmUiLCJmb3J3YXJkIiwiZmluZE9yaWdpbmFsVGFyZ2V0IiwiZGVib3VuY2VyUXVldWUiLCJlbnF1ZXVlRGVib3VuY2VyIiwiZmx1c2hEZWJvdW5jZXJzIiwiZGlkRmx1c2giLCJzaGFkeURPTSIsImRlYm91bmNlcnMiLCJTY29waW5nU2hpbSIsIm5ld0luc3RhbmNlIiwiSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbiIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJ3cml0YWJsZSIsIkRhdGFUZW1wbGF0ZSIsIk11dGFibGVEYXRhVGVtcGxhdGUiLCJ1cGdyYWRlVGVtcGxhdGUiLCJzZXRQcm90b3R5cGVPZiIsIlRlbXBsYXRlSW5zdGFuY2VCYXNlIiwiX2NvbmZpZ3VyZVByb3BlcnRpZXMiLCJjaGlsZHJlbiIsIl9fdGVtcGxhdGl6ZUluc3RhbmNlIiwiX190ZW1wbGF0aXplT3duZXIiLCJfX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18iLCJfc2hvd0hpZGVDaGlsZHJlbiIsIl9fdGVtcGxhdGl6ZU9wdGlvbnMiLCJpbnN0YW5jZVByb3BzIiwiaXByb3AiLCJocHJvcCIsIl9faG9zdFByb3BzIiwicGFyZW50TW9kZWwiLCJfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZSIsInRlbXBsYXRlSG9zdCIsImhpZGUiLCJfX3BvbHltZXJUZXh0Q29udGVudF9fIiwiX19wb2x5bWVyRGlzcGxheV9fIiwiZGlzcGxheSIsIl9fcGFyZW50TW9kZWwiLCJNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UiLCJmaW5kTWV0aG9kSG9zdCIsImNyZWF0ZVRlbXBsYXRpemVyQ2xhc3MiLCJhZGROb3RpZnlFZmZlY3RzIiwiYWRkUHJvcGFnYXRlRWZmZWN0cyIsInVzZXJGb3J3YXJkSG9zdFByb3AiLCJmb3J3YXJkSG9zdFByb3AiLCJ0ZW1wbGF0aXplVGVtcGxhdGVDbGFzcyIsIlBST1BFUlRZX0VGRkVDVF9UWVBFUyIsImNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdCIsIl9fZGF0YVByb3RvIiwiaG9zdFByb3AiLCJ1c2VyTm90aWZ5SW5zdGFuY2VQcm9wIiwibm90aWZ5SW5zdGFuY2VQcm9wIiwiY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0IiwiY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QiLCJpbnN0UHJvcCIsIm5vdGlmeUhvc3RQcm9wIiwiVGVtcGxhdGl6ZSIsInRlbXBsYXRpemUiLCJvd25lciIsImJhc2VDbGFzcyIsInRlbXBsYXRpemVJbnN0YW5jZUNsYXNzIiwibW9kZWxGb3JFbGVtZW50IiwiZG9tUmVwZWF0QmFzZSIsIkRvbVJlcGVhdCIsImFzIiwiU3RyaW5nIiwiaW5kZXhBcyIsIml0ZW1zSW5kZXhBcyIsInNvcnQiLCJGdW5jdGlvbiIsInJlbmRlcmVkSXRlbUNvdW50IiwiaW5pdGlhbENvdW50IiwidGFyZ2V0RnJhbWVyYXRlIiwiX3RhcmdldEZyYW1lVGltZSIsIl9faW5zdGFuY2VzIiwiX19saW1pdCIsIl9fcG9vbCIsIl9fcmVuZGVyRGVib3VuY2VyIiwiX19pdGVtc0lkeFRvSW5zdElkeCIsIl9fY2h1bmtDb3VudCIsIl9fbGFzdENodW5rVGltZSIsIl9fc29ydEZuIiwiX19maWx0ZXJGbiIsIl9fb2JzZXJ2ZVBhdGhzIiwiX19jdG9yIiwiX19pc0RldGFjaGVkIiwiX19kZXRhY2hJbnN0YW5jZSIsIl9fYXR0YWNoSW5zdGFuY2UiLCJxdWVyeVNlbGVjdG9yIiwiX19yZW5kZXIiLCJjaGlsZExpc3QiLCJpJCIsIm1ldGhvZEhvc3QiLCJfX2dldE1ldGhvZEhvc3QiLCJfX2RlYm91bmNlUmVuZGVyIiwicmF0ZSIsInBlcmZvcm1hbmNlIiwiX19yZXF1ZXN0UmVuZGVyQ2h1bmsiLCJfX3JlbmRlckNodW5rIiwiY3VyckNodW5rVGltZSIsInJhdGlvIiwiY2hhbmdlIiwiX19oYW5kbGVJdGVtUGF0aCIsIl9faW5pdGlhbGl6ZUNodW5raW5nIiwicGF0aHMiLCJfX2Vuc3VyZVRlbXBsYXRpemVkIiwiX19hcHBseUZ1bGxSZWZyZXNoIiwiX3NldFJlbmRlcmVkSXRlbUNvdW50IiwiX190cnlSZW5kZXJDaHVuayIsImlzbnRJZHhUb0l0ZW1zSWR4IiwiaXRlbXNJZHhUb0luc3RJZHgiLCJpbnN0SWR4IiwibGltaXQiLCJpdGVtSWR4IiwiX19pbnNlcnRJbnN0YW5jZSIsIl9fZGV0YWNoQW5kUmVtb3ZlSW5zdGFuY2UiLCJfX3N0YW1wSW5zdGFuY2UiLCJiZWZvcmVSb3ciLCJiZWZvcmVOb2RlIiwiaGlkZGVuIiwiaXRlbXNQYXRoIiwiaXRlbXNJZHgiLCJwYXJzZUludCIsIml0ZW1TdWJQYXRoIiwiX19oYW5kbGVPYnNlcnZlZFBhdGhzIiwiaXRlbVBhdGgiLCJpbnN0YW5jZSIsIlBhcGVyUmlwcGxlQmVoYXZpb3IiLCJub2luayIsIl9yaXBwbGVDb250YWluZXIiLCJfYnV0dG9uU3RhdGVDaGFuZ2VkIiwiZm9jdXNlZCIsImVuc3VyZVJpcHBsZSIsIl9kb3duSGFuZGxlciIsInByZXNzZWQiLCJvcHRUcmlnZ2VyaW5nRXZlbnQiLCJoYXNSaXBwbGUiLCJfcmlwcGxlIiwiX2NyZWF0ZVJpcHBsZSIsInJpcHBsZUNvbnRhaW5lciIsImRvbUNvbnRhaW5lciIsInJvb3RUYXJnZXQiLCJkZWVwQ29udGFpbnMiLCJ1aURvd25BY3Rpb24iLCJnZXRSaXBwbGUiLCJfbm9pbmtDaGFuZ2VkIiwiTGF5ZXJHcm91cCIsImdldExheWVySWQiLCJjbGVhckxheWVycyIsImdldExheWVyIiwiZ2V0TGF5ZXJzIiwic2V0WkluZGV4IiwiekluZGV4IiwibGF5ZXJHcm91cCIsIkNSUyIsInByb2plY3Rpb24iLCJ0cmFuc2Zvcm1hdGlvbiIsInVudHJhbnNmb3JtZWRQb2ludCIsIkxOMiIsImluZmluaXRlIiwid3JhcExhdCIsImxhdFNoaWZ0IiwibG5nU2hpZnQiLCJuZXdTdyIsIm5ld05lIiwibWFya2VyIiwiTWFya2VyIiwiZHJhZ2dhYmxlIiwia2V5Ym9hcmQiLCJ0aXRsZSIsInpJbmRleE9mZnNldCIsInJpc2VPbkhvdmVyIiwicmlzZU9mZnNldCIsIl9pbml0SWNvbiIsInVwZGF0ZSIsIl9yZW1vdmVJY29uIiwiX3JlbW92ZVNoYWRvdyIsIm9sZExhdExuZyIsInNldFpJbmRleE9mZnNldCIsInNldEljb24iLCJfcG9wdXAiLCJiaW5kUG9wdXAiLCJfaWNvbiIsIl9zZXRQb3MiLCJjbGFzc1RvQWRkIiwiYWRkSWNvbiIsIm1vdXNlb3ZlciIsIm1vdXNlb3V0IiwiX3Jlc2V0WkluZGV4IiwibmV3U2hhZG93IiwiX3NoYWRvdyIsImFkZFNoYWRvdyIsIl91cGRhdGVPcGFjaXR5IiwiX2luaXRJbnRlcmFjdGlvbiIsIl96SW5kZXgiLCJfdXBkYXRlWkluZGV4Iiwib3B0IiwiX2dldFBvcHVwQW5jaG9yIiwicG9wdXBBbmNob3IiLCJfZ2V0VG9vbHRpcEFuY2hvciIsInRvb2x0aXBBbmNob3IiLCJTVEFSVCIsIkVORCIsInBvaW50ZXJkb3duIiwiTVNQb2ludGVyRG93biIsIk1PVkUiLCJEcmFnZ2FibGUiLCJjbGlja1RvbGVyYW5jZSIsImRyYWdTdGFydFRhcmdldCIsIl9lbGVtZW50IiwiX2RyYWdTdGFydFRhcmdldCIsIl9wcmV2ZW50T3V0bGluZSIsIl9vbkRvd24iLCJfZHJhZ2dpbmciLCJmaW5pc2hEcmFnIiwic2hpZnRLZXkiLCJfbW92aW5nIiwiX3N0YXJ0UG9pbnQiLCJfb25Nb3ZlIiwiX29uVXAiLCJuZXdQb2ludCIsIl9zdGFydFBvcyIsIl9sYXN0VGFyZ2V0IiwiU1ZHRWxlbWVudEluc3RhbmNlIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJfbmV3UG9zIiwiX2FuaW1SZXF1ZXN0IiwiX2xhc3RFdmVudCIsIl91cGRhdGVQb3NpdGlvbiIsIkltYWdlT3ZlcmxheSIsImNyb3NzT3JpZ2luIiwiZXJyb3JPdmVybGF5VXJsIiwiX3VybCIsIl9pbWFnZSIsIl9pbml0SW1hZ2UiLCJzdHlsZU9wdHMiLCJzZXRVcmwiLCJzZXRCb3VuZHMiLCJvbnNlbGVjdHN0YXJ0Iiwib25tb3VzZW1vdmUiLCJvbmxvYWQiLCJvbmVycm9yIiwiX292ZXJsYXlPbkVycm9yIiwiaW1hZ2UiLCJlcnJvclVybCIsImltYWdlT3ZlcmxheSIsIkRpdk92ZXJsYXkiLCJfc291cmNlIiwiX3JlbW92ZVRpbWVvdXQiLCJfYWRqdXN0UGFuIiwiZ2V0Q29udGVudCIsIl9jb250ZW50Iiwic2V0Q29udGVudCIsInZpc2liaWxpdHkiLCJfdXBkYXRlQ29udGVudCIsIl91cGRhdGVMYXlvdXQiLCJpc09wZW4iLCJfY29udGVudE5vZGUiLCJoYXNDaGlsZE5vZGVzIiwiX2dldEFuY2hvciIsIl9jb250YWluZXJCb3R0b20iLCJfY29udGFpbmVyTGVmdCIsIl9jb250YWluZXJXaWR0aCIsInRpbGVMYXllciIsIlRpbGVMYXllciIsInN1YmRvbWFpbnMiLCJlcnJvclRpbGVVcmwiLCJ6b29tT2Zmc2V0IiwidG1zIiwiem9vbVJldmVyc2UiLCJkZXRlY3RSZXRpbmEiLCJ0aWxlU2l6ZSIsIl9vblRpbGVSZW1vdmUiLCJub1JlZHJhdyIsImNyZWF0ZVRpbGUiLCJkb25lIiwidGlsZSIsIl90aWxlT25Mb2FkIiwiX3RpbGVPbkVycm9yIiwiZ2V0VGlsZVVybCIsIl9nZXRTdWJkb21haW4iLCJfZ2V0Wm9vbUZvclVybCIsImludmVydGVkWSIsIl9nbG9iYWxUaWxlUmFuZ2UiLCJfdGlsZVpvb20iLCJ0aWxlUG9pbnQiLCJfYWJvcnRMb2FkaW5nIiwiX3RpbGVzIiwiY29tcGxldGUiLCJ0aWxlTGF5ZXJXTVMiLCJUaWxlTGF5ZXJXTVMiLCJkZWZhdWx0V21zUGFyYW1zIiwic2VydmljZSIsInJlcXVlc3QiLCJzdHlsZXMiLCJmb3JtYXQiLCJ0cmFuc3BhcmVudCIsInZlcnNpb24iLCJ3bXNQYXJhbXMiLCJfY3JzIiwiX3dtc1ZlcnNpb24iLCJwYXJzZUZsb2F0IiwicHJvamVjdGlvbktleSIsInRpbGVCb3VuZHMiLCJfdGlsZUNvb3Jkc1RvQm91bmRzIiwiYmJveCIsInNldFBhcmFtcyIsIkVQU0c0MzI2IiwiTG9uTGF0IiwicG9seWxpbmUiLCJMaW5lVXRpbCIsIlBvbHlsaW5lIiwic21vb3RoRmFjdG9yIiwibm9DbGlwIiwiX3NldExhdExuZ3MiLCJnZXRMYXRMbmdzIiwiX2xhdGxuZ3MiLCJzZXRMYXRMbmdzIiwiaXNFbXB0eSIsImNsb3Nlc3RMYXllclBvaW50IiwibWluRGlzdGFuY2UiLCJtaW5Qb2ludCIsImNsb3Nlc3QiLCJqTGVuIiwiX3BhcnRzIiwiaGFsZkRpc3QiLCJzZWdEaXN0IiwiZGlzdCIsIl9yaW5ncyIsImFkZExhdExuZyIsIl9kZWZhdWx0U2hhcGUiLCJfY29udmVydExhdExuZ3MiLCJmbGF0IiwiX3Byb2plY3RMYXRsbmdzIiwicHJvamVjdGVkQm91bmRzIiwicmluZyIsIl9jbGlwUG9pbnRzIiwiayIsImxlbjIiLCJzZWdtZW50IiwiX3NpbXBsaWZ5UG9pbnRzIiwiX3VwZGF0ZVBvbHkiLCJjbG9zZWQiLCJwb2x5Z29uIiwiUG9seVV0aWwiLCJQb2x5Z29uIiwiZiIsImFyZWEiLCJjbGlwcGVkIiwiY2xpcFBvbHlnb24iLCJjc3NGcm9tTW9kdWxlcyIsImNzc0Zyb21Nb2R1bGUiLCJjc3NGcm9tVGVtcGxhdGUiLCJjc3NGcm9tTW9kdWxlSW1wb3J0cyIsIl9jc3NGcm9tTW9kdWxlSW1wb3J0cyIsIk1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SIiwiSU5DTFVERV9BVFRSIiwiaW1wb3J0TW9kdWxlIiwibW9kdWxlSWQiLCJQb2x5bWVyRG9tTW9kdWxlIiwidGVtcGxhdGVXaXRoQXNzZXRQYXRoIiwibW9kdWxlSWRzIiwibW9kdWxlcyIsIl9jc3NUZXh0IiwiZSQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0QXR0cmlidXRlIiwiaW1wb3J0RG9jIiwibGNNb2R1bGVzIiwiZmluZE1vZHVsZSIsInN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2siLCJEb21Nb2R1bGUiLCJfX2Fzc2V0cGF0aCIsIkhUTUxJbXBvcnRzIiwiaW1wb3J0Rm9yRWxlbWVudCIsInN0eWxlSW50ZXJmYWNlIiwiTGVnYWN5RWxlbWVudE1peGluIiwibGVnYWN5RWxlbWVudEJhc2UiLCJESVJFQ1RJT05fTUFQIiwiTGVnYWN5RWxlbWVudCIsImlzQXR0YWNoZWQiLCJfX2JvdW5kTGlzdGVuZXJzIiwiX2RlYm91bmNlcnMiLCJjcmVhdGVkIiwiYXR0YWNoZWQiLCJkZXRhY2hlZCIsImF0dHJpYnV0ZUNoYW5nZWQiLCJfX2hhc1JlZ2lzdGVyRmluaXNoZWQiLCJfcmVnaXN0ZXJlZCIsIl9lbnN1cmVBdHRyaWJ1dGVzIiwiX2FwcGx5TGlzdGVuZXJzIiwiX3NlcmlhbGl6ZVZhbHVlIiwiX2Rlc2VyaWFsaXplVmFsdWUiLCJhdHRyaWJ1dGUiLCJhcGkiLCJuJCIsImdldE93blByb3BlcnR5TmFtZXMiLCJwZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9jb250ZW50Rm9yVGVtcGxhdGUiLCJoYmwiLCJibCIsIl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlIiwiX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZSIsImRpcmVjdGlvbiIsInNsY3RyIiwicXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzIiwiY24iLCJ0YyIsIkNPTU1FTlRfTk9ERSIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJnZXRDb250ZW50Q2hpbGROb2RlcyIsInNob3VsZE9ic2VydmUiLCJqb2JOYW1lIiwid2FpdCIsIndhaXRUaW1lIiwidGFnIiwiZWx0Iiwic2V0UHJvcGVydGllcyIsIm9wdEFzeW5jIiwibG9hZEZuIiwiZXJyb3JGbiIsImJvb2wiLCJoYXNBdHRyaWJ1dGUiLCJ0cmFuc2Zvcm1UZXh0Iiwid2Via2l0VHJhbnNmb3JtIiwiYXJyYXlPclBhdGgiLCJhcnIiLCJsZXZlbCIsIl9sb2dnZXIiLCJEb2N1bWVudEZyYWdtZW50IiwidG9Dc3NUZXh0IiwicnVsZXNGb3JTdHlsZSIsImlzS2V5ZnJhbWVzU2VsZWN0b3IiLCJmb3JFYWNoUnVsZSIsImFwcGx5Q3NzIiwiY3JlYXRlU2NvcGVTdHlsZSIsImFwcGx5U3R5bGVQbGFjZUhvbGRlciIsImFwcGx5U3R5bGUiLCJpc1RhcmdldGVkQnVpbGQiLCJnZXRDc3NCdWlsZFR5cGUiLCJwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayIsInNldEVsZW1lbnRDbGFzc1JhdyIsImdldElzRXh0ZW5kcyIsInJ1bGUiLCJzdHlsZVJ1bGVDYWxsYmFjayIsImtleWZyYW1lc1J1bGVDYWxsYmFjayIsIm9ubHlBY3RpdmVSdWxlcyIsInNraXBSdWxlcyIsIm1hdGNoTWVkaWEiLCJtb25pa2VyIiwiY29udGV4dE5vZGUiLCJsYXN0SGVhZEFwcGx5Tm9kZSIsInBsYWNlSG9sZGVyIiwiY3JlYXRlQ29tbWVudCIsInNjb3BlIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJidWlsZFR5cGUiLCJmaW5kTWF0Y2hpbmdQYXJlbiIsImlubmVyIiwicHJlZml4Iiwic3VmZml4IiwiY29tbWEiLCJmYWxsYmFjayIsInR5cGVFeHRlbnNpb24iLCJleHRlbmRzIiwidGVtcGxhdGVNYXAiLCJkb2N1bWVudFdhaXQiLCJyZWFkeVByb21pc2UiLCJyZXNvbHZlRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWR5U3RhdGUiLCJ0aGVuIiwiQ3VzdG9tU3R5bGVQcm92aWRlciIsIlNFRU5fTUFSS0VSIiwiQ0FDSEVEX1NUWUxFIiwidHJhbnNmb3JtRm4iLCJ2YWxpZGF0ZUZuIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJlbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uIiwiY3VzdG9tU3R5bGUiLCJjcyIsImdldFN0eWxlRm9yQ3VzdG9tU3R5bGUiLCJzdHlsZVRvVHJhbnNmb3JtIiwiYWRkQ3VzdG9tU3R5bGUiLCJwcm9jZXNzU3R5bGVzIiwiZGVmaW5lUHJvcGVydGllcyIsIm5lZWRzRW5xdWV1ZSIsIkN1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlIiwiZ2VzdHVyZXMkMCIsIkdlc3R1cmVFdmVudExpc3RlbmVycyIsImJlZm9yZU5leHRSZW5kZXIiLCJhZnRlck5leHRSZW5kZXIiLCJzY2hlZHVsZWQiLCJiZWZvcmVSZW5kZXJRdWV1ZSIsImFmdGVyUmVuZGVyUXVldWUiLCJzY2hlZHVsZSIsImZsdXNoUXVldWUiLCJydW5RdWV1ZSIsInF1ZXVlIiwiY2FsbE1ldGhvZCIsImlzU2xvdCIsIkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIiLCJyZWR1Y2UiLCJfc2hhZHlDaGlsZHJlbk9ic2VydmVyIiwiX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIiLCJfY29ubmVjdGVkIiwiX3RhcmdldCIsIl9lZmZlY3RpdmVOb2RlcyIsIl9vYnNlcnZlciIsIl9zY2hlZHVsZWQiLCJfYm91bmRTY2hlZHVsZSIsIl9zY2hlZHVsZSIsImNvbm5lY3QiLCJfbGlzdGVuU2xvdHMiLCJvYnNlcnZlQ2hpbGRyZW4iLCJtdXRhdGlvbnMiLCJfcHJvY2Vzc011dGF0aW9ucyIsIl91bmxpc3RlblNsb3RzIiwidW5vYnNlcnZlQ2hpbGRyZW4iLCJfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMiLCJtdXRhdGlvbiIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJ0YWtlUmVjb3JkcyIsIm5ld05vZGVzIiwibmV3U3BsaWNlIiwiRURJVF9MRUFWRSIsIkVESVRfVVBEQVRFIiwiRURJVF9BREQiLCJFRElUX0RFTEVURSIsImNhbGNFZGl0RGlzdGFuY2VzIiwiY3VycmVudCIsImN1cnJlbnRTdGFydCIsImN1cnJlbnRFbmQiLCJvbGRTdGFydCIsIm9sZEVuZCIsInJvd0NvdW50IiwiY29sdW1uQ291bnQiLCJkaXN0YW5jZXMiLCJub3J0aCIsIndlc3QiLCJzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMiLCJlZGl0cyIsIm5vcnRoV2VzdCIsInJldmVyc2UiLCJjYWxjU3BsaWNlcyIsInByZWZpeENvdW50Iiwic3VmZml4Q291bnQiLCJtaW5MZW5ndGgiLCJzaGFyZWRQcmVmaXgiLCJzaGFyZWRTdWZmaXgiLCJvcHMiLCJvbGRJbmRleCIsInNlYXJjaExlbmd0aCIsImluZGV4MSIsImluZGV4MiIsImNvdW50IiwiY2FsY3VsYXRlU3BsaWNlcyIsImN1cnJlbnRWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCIkX2RvY3VtZW50Q29udGFpbmVyIiwiSXJvbkJ1dHRvblN0YXRlSW1wbCIsInRvZ2dsZXMiLCJhY3RpdmUiLCJwb2ludGVyRG93biIsInJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQiLCJhcmlhQWN0aXZlQXR0cmlidXRlIiwiZG93biIsInVwIiwidGFwIiwia2V5QmluZGluZ3MiLCJfbW91c2VFdmVudFJlIiwiX3RhcEhhbmRsZXIiLCJfdXNlckFjdGl2YXRlIiwiX2ZvY3VzQ2hhbmdlZCIsIl9kZXRlY3RLZXlib2FyZEZvY3VzIiwiX3NldFByZXNzZWQiLCJfc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCIsIl9zZXRQb2ludGVyRG93biIsIl91cEhhbmRsZXIiLCJfc3BhY2VLZXlEb3duSGFuZGxlciIsImtleWJvYXJkRXZlbnQiLCJsb2NhbFRhcmdldCIsImlzTGlnaHREZXNjZW5kYW50Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiX3NwYWNlS2V5VXBIYW5kbGVyIiwiX2FzeW5jQ2xpY2siLCJhc3luYyIsIl9wcmVzc2VkQ2hhbmdlZCIsIl9jaGFuZ2VkQnV0dG9uU3RhdGUiLCJfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQiLCJvbGRWYWx1ZSIsIl9hY3RpdmVDaGFuZ2VkIiwiX2NvbnRyb2xTdGF0ZUNoYW5nZWQiLCJkaXNhYmxlZCIsIklyb25CdXR0b25TdGF0ZSIsIktFWV9JREVOVElGSUVSIiwiS0VZX0NPREUiLCJNT0RJRklFUl9LRVlTIiwiS0VZX0NIQVIiLCJJREVOVF9DSEFSIiwiQVJST1dfS0VZIiwiU1BBQ0VfS0VZIiwiRVNDX0tFWSIsInRyYW5zZm9ybUtleSIsIm5vU3BlY2lhbENoYXJzIiwidmFsaWRLZXkiLCJsS2V5IiwidHJhbnNmb3JtS2V5SWRlbnRpZmllciIsImtleUlkZW50IiwiZnJvbUNoYXJDb2RlIiwidHJhbnNmb3JtS2V5Q29kZSIsImtleUNvZGUiLCJub3JtYWxpemVkS2V5Rm9yRXZlbnQiLCJrZXlFdmVudCIsImtleUlkZW50aWZpZXIiLCJrZXlDb21ib01hdGNoZXNFdmVudCIsImtleUNvbWJvIiwiaGFzTW9kaWZpZXJzIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJwYXJzZUtleUNvbWJvU3RyaW5nIiwia2V5Q29tYm9TdHJpbmciLCJjb21ibyIsInBhcnNlZEtleUNvbWJvIiwia2V5Q29tYm9QYXJ0IiwiZXZlbnRQYXJ0cyIsImtleU5hbWUiLCJwYXJzZUV2ZW50U3RyaW5nIiwiZXZlbnRTdHJpbmciLCJJcm9uQTExeUtleXNCZWhhdmlvciIsImtleUV2ZW50VGFyZ2V0Iiwic3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbiIsIl9ib3VuZEtleUhhbmRsZXJzIiwiX2ltcGVyYXRpdmVLZXlCaW5kaW5ncyIsInJlZ2lzdGVyZWQiLCJfcHJlcEtleUJpbmRpbmdzIiwiX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzIiwiX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMiLCJhZGRPd25LZXlCaW5kaW5nIiwiaGFuZGxlck5hbWUiLCJfcmVzZXRLZXlFdmVudExpc3RlbmVycyIsInJlbW92ZU93bktleUJpbmRpbmdzIiwia2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzIiwia2V5Q29tYm9zIiwiX2NvbGxlY3RLZXlCaW5kaW5ncyIsImJlaGF2aW9ycyIsIl9rZXlCaW5kaW5ncyIsIl9hZGRLZXlCaW5kaW5nIiwia2IxIiwia2IyIiwiYjIiLCJrZXlzIiwiYm91bmRLZXlIYW5kbGVyIiwiX29uS2V5QmluZGluZ0V2ZW50Iiwia2V5SGFuZGxlclR1cGxlIiwiX3RyaWdnZXJLZXlIYW5kbGVyIiwiSXJvbkNvbnRyb2xTdGF0ZSIsIl9vbGRUYWJJbmRleCIsIl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIiLCJfZm9jdXNCbHVySGFuZGxlciIsIl9faGFuZGxlRXZlbnRSZXRhcmdldGluZyIsInJlYWR5IiwiX3NldEZvY3VzZWQiLCJfZGlzYWJsZWRDaGFuZ2VkIiwicG9pbnRlckV2ZW50cyIsImJsdXIiLCJfY2hhbmdlZENvbnRyb2xTdGF0ZSIsIkVQU0czODU3IiwiRVBTRzkwMDkxMyIsIlNwaGVyaWNhbE1lcmNhdG9yIiwiTUFYX0xBVElUVURFIiwiYXRhbiIsInN2Z0NyZWF0ZSIsInBvaW50c1RvUGF0aCIsInJpbmdzIiwiYWRkUG9pbnRlckxpc3RlbmVyIiwicmVtb3ZlUG9pbnRlckxpc3RlbmVyIiwiUE9JTlRFUl9ET1dOIiwiUE9JTlRFUl9NT1ZFIiwiUE9JTlRFUl9VUCIsIlBPSU5URVJfQ0FOQ0VMIiwiVEFHX1dISVRFX0xJU1QiLCJfcG9pbnRlcnMiLCJfcG9pbnRlckRvY0xpc3RlbmVyIiwiX3BvaW50ZXJzQ291bnQiLCJfYWRkUG9pbnRlclN0YXJ0IiwiX2FkZFBvaW50ZXJNb3ZlIiwiX2FkZFBvaW50ZXJFbmQiLCJvbkRvd24iLCJwb2ludGVyVHlwZSIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwiX2hhbmRsZVBvaW50ZXIiLCJfZ2xvYmFsUG9pbnRlckRvd24iLCJfZ2xvYmFsUG9pbnRlck1vdmUiLCJfZ2xvYmFsUG9pbnRlclVwIiwicG9pbnRlcklkIiwib25Nb3ZlIiwib25VcCIsIlBvc0FuaW1hdGlvbiIsIl9lbCIsIl9pblByb2dyZXNzIiwiX2R1cmF0aW9uIiwiX2Vhc2VPdXRQb3dlciIsIl9vZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2FuaW1hdGUiLCJfc3RlcCIsIl9jb21wbGV0ZSIsIl9hbmltSWQiLCJfcnVuRnJhbWUiLCJfZWFzZU91dCIsInByb2dyZXNzIiwiSWNvbkRlZmF1bHQiLCJpY29uVXJsIiwiaWNvblJldGluYVVybCIsInNoYWRvd1VybCIsImljb25TaXplIiwic2hhZG93U2l6ZSIsImltYWdlUGF0aCIsIl9kZXRlY3RJY29uUGF0aCIsIkJveFpvb20iLCJEb3VibGVDbGlja1pvb20iLCJEcmFnIiwiS2V5Ym9hcmQiLCJTY3JvbGxXaGVlbFpvb20iLCJUYXAiLCJUb3VjaFpvb20iLCJBdHRyaWJ1dGlvbiIsIl9hdHRyaWJ1dGlvbnMiLCJzZXRQcmVmaXgiLCJhdHRyaWJzIiwicHJlZml4QW5kQXR0cmlicyIsIkxheWVycyIsIlpvb20iLCJTY2FsZSIsIlZpZGVvT3ZlcmxheSIsInZpZGVvT3ZlcmxheSIsIlBvcHVwIiwicG9wdXAiLCJUb29sdGlwIiwidG9vbHRpcCIsImdlb21ldHJ5VG9MYXllciIsImNvb3Jkc1RvTGF0TG5nIiwiY29vcmRzVG9MYXRMbmdzIiwibGF0TG5nVG9Db29yZHMiLCJsYXRMbmdzVG9Db29yZHMiLCJnZXRGZWF0dXJlIiwiYXNGZWF0dXJlIiwiR2VvSlNPTiIsImdlb0pTT04iLCJnZW9Kc29uIiwiZ3JpZExheWVyIiwiR3JpZExheWVyIiwidXBkYXRlV2hlbklkbGUiLCJ1cGRhdGVXaGVuWm9vbWluZyIsInVwZGF0ZUludGVydmFsIiwibWF4TmF0aXZlWm9vbSIsIm1pbk5hdGl2ZVpvb20iLCJub1dyYXAiLCJrZWVwQnVmZmVyIiwiX2xldmVscyIsIl9yZW1vdmVBbGxUaWxlcyIsIl9zZXRBdXRvWkluZGV4IiwiaXNMb2FkaW5nIiwiX2xvYWRpbmciLCJ2aWV3cHJlcmVzZXQiLCJfaW52YWxpZGF0ZUFsbCIsImdldFRpbGVTaXplIiwiY29tcGFyZSIsImVkZ2VaSW5kZXgiLCJpc0Zpbml0ZSIsIm5leHRGcmFtZSIsIndpbGxQcnVuZSIsImxvYWRlZCIsImZhZGUiLCJfb25PcGFxdWVUaWxlIiwiX25vUHJ1bmUiLCJfcHJ1bmVUaWxlcyIsIl9mYWRlRnJhbWUiLCJfdXBkYXRlTGV2ZWxzIiwiX29uVXBkYXRlTGV2ZWwiLCJfcmVtb3ZlVGlsZXNBdFpvb20iLCJfb25SZW1vdmVMZXZlbCIsIm9yaWdpbiIsIl9zZXRab29tVHJhbnNmb3JtIiwib2Zmc2V0V2lkdGgiLCJfb25DcmVhdGVMZXZlbCIsIl9sZXZlbCIsInJldGFpbiIsIl9yZXRhaW5QYXJlbnQiLCJfcmV0YWluQ2hpbGRyZW4iLCJfcmVtb3ZlVGlsZSIsIngyIiwieTIiLCJ6MiIsImNvb3JkczIiLCJfdGlsZUNvb3Jkc1RvS2V5IiwiYW5pbWF0aW5nIiwiX3NldFZpZXciLCJfY2xhbXBab29tIiwibm9QcnVuZSIsInRpbGVab29tIiwidGlsZVpvb21DaGFuZ2VkIiwiX3Jlc2V0R3JpZCIsIl9zZXRab29tVHJhbnNmb3JtcyIsIl90aWxlU2l6ZSIsIl9weEJvdW5kc1RvVGlsZVJhbmdlIiwiX3dyYXBYIiwiX3dyYXBZIiwiX2dldFRpbGVkUGl4ZWxCb3VuZHMiLCJtYXBab29tIiwicGl4ZWxDZW50ZXIiLCJoYWxmU2l6ZSIsInBpeGVsQm91bmRzIiwidGlsZVJhbmdlIiwidGlsZUNlbnRlciIsIm5vUHJ1bmVSYW5nZSIsIl9pc1ZhbGlkVGlsZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsIl9hZGRUaWxlIiwiX2tleVRvQm91bmRzIiwiX2tleVRvVGlsZUNvb3JkcyIsIm53UG9pbnQiLCJzZVBvaW50IiwiX2luaXRUaWxlIiwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IiwidGlsZVBvcyIsIl9nZXRUaWxlUG9zIiwiX3dyYXBDb29yZHMiLCJfdGlsZVJlYWR5IiwiX25vVGlsZXNUb0xvYWQiLCJuZXdDb29yZHMiLCJDYW52YXMiLCJfb25WaWV3UHJlUmVzZXQiLCJfcG9zdHBvbmVVcGRhdGVQYXRocyIsIl9kcmF3IiwiX29uTW91c2VNb3ZlIiwiX29uQ2xpY2siLCJfaGFuZGxlTW91c2VPdXQiLCJfY3R4IiwiX3JlZHJhd0JvdW5kcyIsIl9yZWRyYXciLCJfZHJhd25MYXllcnMiLCJfdXBkYXRlRGFzaEFycmF5Iiwib3JkZXIiLCJfb3JkZXIiLCJfZHJhd0xhc3QiLCJfZHJhd0ZpcnN0IiwiX3JlcXVlc3RSZWRyYXciLCJfZXh0ZW5kUmVkcmF3Qm91bmRzIiwiX2Rhc2hBcnJheSIsIl9yZWRyYXdSZXF1ZXN0IiwiX2NsZWFyIiwiY2xlYXJSZWN0IiwiYmVnaW5QYXRoIiwiY2xpcCIsIl9kcmF3aW5nIiwicmVzdG9yZSIsImNsb3NlUGF0aCIsIl9maWxsU3Ryb2tlIiwiYXJjIiwiZ2xvYmFsQWxwaGEiLCJmaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiY2xpY2tlZExheWVyIiwiX2ZpcmVFdmVudCIsIm1vdmluZyIsIl9oYW5kbGVNb3VzZUhvdmVyIiwiX2hvdmVyZWRMYXllciIsImNhbmRpZGF0ZUhvdmVyZWRMYXllciIsImNpcmNsZSIsIkNpcmNsZSIsImxlZ2FjeU9wdGlvbnMiLCJfbVJhZGl1cyIsImhhbGYiLCJsYXRSIiwibG5nUiIsImNsaXBwZWRQb2ludHMiLCJlZGdlcyIsIl9jb2RlIiwiU1ZHIiwiem9vbXN0YXJ0IiwiX29uWm9vbVN0YXJ0IiwiX3Jvb3RHcm91cCIsIl9zdmdTaXplIiwiX3NldFBhdGgiLCJnZW9qc29uIiwiYWRkRGF0YSIsImZlYXR1cmVzIiwiZmVhdHVyZSIsImdlb21ldHJpZXMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwiZGVmYXVsdE9wdGlvbnMiLCJyZXNldFN0eWxlIiwib25FYWNoRmVhdHVyZSIsIl9zZXRMYXllclN0eWxlIiwicG9pbnRUb0xheWVyIiwiX2Nvb3Jkc1RvTGF0TG5nIiwibGV2ZWxzRGVlcCIsIm5ld0dlb21ldHJ5IiwiUG9pbnRUb0dlb0pTT04iLCJ0b0dlb0pTT04iLCJtdWx0aSIsImhvbGVzIiwidG9NdWx0aVBvaW50IiwiaXNHZW9tZXRyeUNvbGxlY3Rpb24iLCJqc29ucyIsImpzb24iLCJNZXJjYXRvciIsIlJfTUlOT1IiLCJ0bXAiLCJjb24iLCJ0cyIsInRhbiIsInBoaSIsImRwaGkiLCJ5YW1sIiwicmVxdWlyZSIsIkdHTWFwVmlld2VyIiwiY29uZmlnIiwibWFwVGl0bGUiLCJiYXNlU291cmNlIiwiYmFzZUZvcm1hdCIsInNlbGVjdGVkT3ZlcmxheSIsIndtc0dyb3VwcyIsImdlb2pzb25MYXllcnMiLCJiYXNlTWFwcyIsIm92ZXJsYXlNYXBzIiwic2VhcmNoTWFya2VycyIsIl9tYXJrZXJzR3JvdXAiLCJmZXRjaCIsImluaXRpYWxpemVNYXAiLCJpbml0aWFsaXplU2VhcmNoIiwicmVzcG9uc2UiLCJyanNvbiIsInNhZmVMb2FkIiwiZmxhdHRlbmVkTGF5ZXJzIiwiaW50ZXJhY3Rpb24iLCJ2aXNpYmxlIiwiaGFzaCIsIm1hY2hpbmVOYW1lIiwid21zRGVmYXVsdFNvdXJjZSIsIl9zZWxlY3RlZEJhc2VtYXAiLCJiYXNlTGF5ZXJzIiwib3ZlcmxheVNlbGVjdCIsImpRdWVyeSIsImF1dG9jb21wbGV0ZSIsInByZXZlbnRCYWRRdWVyaWVzIiwiZGVmZXJSZXF1ZXN0QnkiLCJtaW5DaGFycyIsInNlcnZpY2VVcmwiLCJwYXJhbU5hbWUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJhZGRyZXNzZXMiLCJKU09OIiwic3VnZ2VzdGlvbnMiLCJhZGRyZXNzIiwib25TZWFyY2hTdGFydCIsIm9uU2VhcmNoQ29tcGxldGUiLCJxIiwib25TZWxlY3QiLCJjdXJyVmlzaWJsZSIsImV4Y2x1c2l2ZXMiLCJfcGFyc2VMYXllcnMiLCJyZXNldFZpZXdPblNlbGVjdCIsImluaXRpYWxDZW50ZXIiLCJpbml0aWFsWm9vbSIsImJhY2tncm91bmRJbWFnZSIsImxheWVyc01lbnUiLCJ0b2dnbGUiLCJvdmVybGF5Iiwid21zTGF5ZXJzIiwiaWRlbnRpZnkiLCJpbmZvRm9ybWF0IiwibWFya2Vyc0RhdGEiLCJzZWxlY3RlZCIsIm5ld092ZXJsYXkiLCJkZWZhdWx0Q2xhc3MiLCJkb3dubG9hZFVSTCIsImh0bWwiLCJtb2RhbCIsIm1pY3JvdGFzayIsIm5hdGl2ZVByb3BlcnRpZXMiLCJzYXZlQWNjZXNzb3JWYWx1ZSIsIlByb3BlcnR5QWNjZXNzb3JzIiwiYSQiLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJfX3NlcmlhbGl6aW5nIiwiX19kYXRhSW52YWxpZCIsIl9fZGF0YUluc3RhbmNlUHJvcHMiLCJfaW5pdGlhbGl6ZVByb3BlcnRpZXMiLCJfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyIsIm91dFZhbHVlIiwiY2hhbmdlZCIsIl9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzIiwiX3Byb3BlcnRpZXNDaGFuZ2VkIiwidGVtcGxhdGVFeHRlbnNpb25zIiwid3JhcFRlbXBsYXRlRXh0ZW5zaW9uIiwicmVwbGFjZUNoaWxkIiwiYXR0cmlidXRlcyIsImZpbmRUZW1wbGF0ZU5vZGUiLCJwYXJlbnRJbmZvIiwicGFyZW50SW5kZXgiLCJhcHBseUlkVG9NYXAiLCJhcHBseUV2ZW50TGlzdGVuZXIiLCJhcHBseVRlbXBsYXRlQ29udGVudCIsIl90ZW1wbGF0ZUluZm8iLCJjcmVhdGVOb2RlRXZlbnRIYW5kbGVyIiwiVGVtcGxhdGVTdGFtcCIsImRlY29yYXRlIiwiX19ub0luc2VydGlvblBvaW50IiwiaGFzSW5zZXJ0aW9uUG9pbnQiLCJvdXRlclRlbXBsYXRlSW5mbyIsInN0cmlwV2hpdGVTcGFjZSIsIl9wYXJzZVRlbXBsYXRlQ29udGVudCIsIl9wYXJzZVRlbXBsYXRlTm9kZSIsIl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUiLCJfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMiLCJoYXNBdHRyaWJ1dGVzIiwiX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyIsImNoaWxkSW5mbyIsImluZm9JbmRleCIsImF0dHJzIiwiX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlIiwiaG9zdEF0dHJpYnV0ZXMiLCJyb2xlIiwidGFiaW5kZXgiLCJ0cmFjayIsIl9vbnRyYWNrIiwiX3RyYWNrU3RhcnQiLCJfdHJhY2tNb3ZlIiwiX3RyYWNrRW5kIiwiX3dpZHRoIiwidG9nZ2xlQmFyIiwiX3RyYWNrQ2hlY2tlZCIsImNoZWNrZWQiLCJ0b2dnbGVCdXR0b24iLCJfeCIsInRyYW5zbGF0ZTNkIiwicmlwcGxlIiwiQXBwbHlTaGltVXRpbHMiLCJhcHBseVNoaW0iLCJBcHBseVNoaW1JbnRlcmZhY2UiLCJjdXN0b21TdHlsZUludGVyZmFjZSIsImVuc3VyZSIsImludmFsaWRhdGUiLCJ0cmFuc2Zvcm1DdXN0b21TdHlsZSIsImZsdXNoQ3VzdG9tU3R5bGVzIiwiZWxlbWVudE5hbWUiLCJhc3QiLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsInNoYWRvd0NoaWxkcmVuIiwidGVtcGxhdGVJc1ZhbGlkIiwidGVtcGxhdGVJc1ZhbGlkYXRpbmciLCJzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZSIsImFwcGx5U2hpbUludGVyZmFjZSIsImVsZW1lbnRFeHRlbmRzIiwiQXBwbHlTaGltIiwiQVBQTFlfTkFNRV9DTEVBTiIsIklOSVRJQUxfSU5IRVJJVCIsIk1JWElOX1ZBUl9TRVAiLCJQcm9wZXJ0eUVudHJ5IiwiRGVwZW5kYW50c0VudHJ5IiwiTWl4aW5NYXBFbnRyeSIsIk1peGluTWFwIiwiZGVwZW5kYW50cyIsImludmFsaWRDYWxsYmFjayIsIl9jdXJyZW50RWxlbWVudCIsIl9tZWFzdXJlRWxlbWVudCIsInRyYW5zZm9ybVN0eWxlIiwidHJhbnNmb3JtUnVsZXMiLCJ0cmFuc2Zvcm1SdWxlIiwidHJhbnNmb3JtQ3NzVGV4dCIsIm1hdGNoVGV4dCIsInZhbHVlUHJvcGVydHkiLCJ2YWx1ZU1peGluIiwiX3Byb2R1Y2VDc3NQcm9wZXJ0aWVzIiwiX2NvbnN1bWVDc3NQcm9wZXJ0aWVzIiwiYWxsIiwibWl4aW5OYW1lIiwiYXBwbHlQb3MiLCJhZnRlckFwcGx5UG9zIiwidGV4dEJlZm9yZUFwcGx5IiwidGV4dEFmdGVyQXBwbHkiLCJkZWZhdWx0cyIsIl9jc3NUZXh0VG9NYXAiLCJyZXBsYWNlbWVudCIsIl9hdEFwcGx5VG9Dc3NQcm9wZXJ0aWVzIiwiZmFsbGJhY2tzIiwidmFycyIsIm1peGluRW50cnkiLCJfZ2V0SW5pdGlhbFZhbHVlRm9yUHJvcGVydHkiLCJvdXQiLCJzcCIsIl9yZXBsYWNlSW5pdGlhbE9ySW5oZXJpdCIsIm1peGluQXNQcm9wZXJ0aWVzIiwibWl4aW5WYWx1ZXMiLCJjb21iaW5lZFByb3BzIiwibmVlZFRvSW52YWxpZGF0ZSIsIl9pbnZhbGlkYXRlTWl4aW5FbnRyeSIsImludmFsaWRhdGVUZW1wbGF0ZSIsImlzVmFsaWRhdGluZyIsInN0YXJ0VmFsaWRhdGluZyIsImVsZW1lbnRzQXJlSW52YWxpZCIsIkNVUlJFTlRfVkVSU0lPTiIsIk5FWFRfVkVSU0lPTiIsIlZBTElEQVRJTkdfVkVSU0lPTiIsInByb21pc2UiLCJfdmFsaWRhdGluZyIsIndoZW5JbXBvcnRzUmVhZHkiLCJpbXBvcnRIcmVmIiwicmVsIiwiY2xlYW51cCIsImxvYWRMaXN0ZW5lciIsImVycm9yTGlzdGVuZXIiLCJfX2R5bmFtaWNJbXBvcnRMb2FkZWQiLCJtZXRhUHJvcHMiLCJiZWZvcmVSZWdpc3RlciIsIm1peGluQmVoYXZpb3JzIiwic3VwZXJCZWhhdmlvcnMiLCJmbGF0dGVuQmVoYXZpb3JzIiwiX21peGluQmVoYXZpb3JzIiwiR2VuZXJhdGVDbGFzc0Zyb21JbmZvIiwiZXhjbHVkZSIsIlBvbHltZXJHZW5lcmF0ZWQiLCJfZW5zdXJlQXR0cmlidXRlIiwiZ2VuZXJhdGVkRnJvbSIsIlRlbXBsYXRpemVyVXNlciIsIlRlbXBsYXRpemVyIiwiX3RlbXBsYXRpemVyVGVtcGxhdGUiLCJjdG9yIiwiX3BhcmVudE1vZGVsIiwiX2luc3RhbmNlUHJvcHMiLCJfZm9yd2FyZEhvc3RQcm9wVjIiLCJfbm90aWZ5SW5zdGFuY2VQcm9wVjIiLCJkb21CaW5kQmFzZSIsIkRvbUJpbmQiLCJfX2NoaWxkcmVuIiwicmVuZGVyIiwiX19yZW1vdmVDaGlsZHJlbiIsIl9faW5zZXJ0Q2hpbGRyZW4iLCJEb21JZiIsImlmIiwicmVzdGFtcCIsIl9faW52YWxpZFByb3BzIiwiX19pbnN0YW5jZSIsIl9sYXN0SWYiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiX190ZWFyZG93bkluc3RhbmNlIiwiX19lbnN1cmVJbnN0YW5jZSIsIl9fc3luY0hvc3RQcm9wZXJ0aWVzIiwicHJldmlvdXNTaWJsaW5nIiwiQXJyYXlTZWxlY3Rvck1peGluIiwiZWxlbWVudEJhc2UiLCJzZWxlY3RlZEl0ZW0iLCJfX2xhc3RJdGVtcyIsIl9fbGFzdE11bHRpIiwiX19zZWxlY3RlZE1hcCIsIml0ZW1zSW5mbyIsIm5ld0l0ZW1zIiwibGFzdEl0ZW1zIiwibGFzdE11bHRpIiwiY2xlYXJTZWxlY3Rpb24iLCJfX2FwcGx5U3BsaWNlcyIsIl9fZGVzZWxlY3RDaGFuZ2VkSWR4IiwiX191cGRhdGVMaW5rcyIsInNpZHgiLCJkZWxldGUiLCJsaW5rUGF0aHMiLCJpc1NlbGVjdGVkIiwiX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4IiwiZGVzZWxlY3QiLCJzZWxlY3RJbmRleCIsImNsZWFyIiwiZGVzZWxlY3RJbmRleCIsImJhc2VBcnJheVNlbGVjdG9yIiwiQXJyYXlTZWxlY3RvciIsIkN1c3RvbVN0eWxlIiwiX3N0eWxlIiwiTXV0YWJsZURhdGFCZWhhdmlvciIsIk9wdGlvbmFsTXV0YWJsZURhdGFCZWhhdmlvciIsIlBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwiLCJfY2hlY2tlZENoYW5nZWQiLCJQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IiLCJJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwiLCJfaGFzSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IiLCJfZ2V0VmFsaWRpdHkiLCJfdmFsdWUiLCJyZXF1aXJlZCIsIl9yZXF1aXJlZENoYW5nZWQiLCJfdmFsdWVDaGFuZ2VkIiwiSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IiLCJJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEiLCJJcm9uVmFsaWRhdGFibGVCZWhhdmlvciIsInZhbGlkYXRvciIsImludmFsaWQiLCJfaW52YWxpZENoYW5nZWQiLCJfdmFsaWRhdG9yIiwiYnlLZXkiLCJoYXNWYWxpZGF0b3IiLCJ2YWxpZGF0ZSIsIklyb25NZXRhIiwibWV0YURhdGFzIiwiX19tZXRhIiwiX19jb21wdXRlTWV0YSIsIm1ldGEiLCJfc2VsZkNoYW5nZWQiLCJJcm9uRm9ybUVsZW1lbnRCZWhhdmlvciIsIl9wYXJlbnRGb3JtIiwiUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwiLCJfZm9jdXNlZENoYW5nZWQiLCJob2xkRG93biIsIlBhcGVySW5reUZvY3VzQmVoYXZpb3IiLCJVdGlsaXR5IiwieDEiLCJ5MSIsInhEZWx0YSIsInlEZWx0YSIsIkVsZW1lbnRNZXRyaWNzIiwiYm91bmRpbmdSZWN0IiwiZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb20iLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsIlJpcHBsZSIsIndhdmUiLCJ3YXZlQ29udGFpbmVyIiwiYmFja2dyb3VuZENvbG9yIiwicmVzZXRJbnRlcmFjdGlvblN0YXRlIiwiTUFYX1JBRElVUyIsInJlY2VudGVycyIsIm1vdXNlRG93bkVsYXBzZWQiLCJtb3VzZURvd25TdGFydCIsIm1vdXNlVXBTdGFydCIsIm1vdXNlVXBFbGFwc2VkIiwibW91c2VEb3duRWxhcHNlZFNlY29uZHMiLCJtb3VzZVVwRWxhcHNlZFNlY29uZHMiLCJtb3VzZUludGVyYWN0aW9uU2Vjb25kcyIsImluaXRpYWxPcGFjaXR5Iiwib3BhY2l0eURlY2F5VmVsb2NpdHkiLCJ3aWR0aDIiLCJjb250YWluZXJNZXRyaWNzIiwiaGVpZ2h0MiIsIndhdmVSYWRpdXMiLCJ0aW1lTm93Iiwib3V0ZXJPcGFjaXR5Iiwid2F2ZU9wYWNpdHkiLCJpc09wYWNpdHlGdWxseURlY2F5ZWQiLCJtYXhSYWRpdXMiLCJpc1Jlc3RpbmdBdE1heFJhZGl1cyIsImlzQW5pbWF0aW9uQ29tcGxldGUiLCJ0cmFuc2xhdGlvbkZyYWN0aW9uIiwieE5vdyIsInhFbmQiLCJ4U3RhcnQiLCJ5Tm93IiwieUVuZCIsInlTdGFydCIsImlzTW91c2VEb3duIiwic2xpZGVEaXN0YW5jZSIsImRyYXciLCJ0cmFuc2xhdGVTdHJpbmciLCJkb3duQWN0aW9uIiwieENlbnRlciIsInlDZW50ZXIiLCJ1cEFjdGlvbiIsInJpcHBsZXMiLCJfYW5pbWF0aW5nIiwiX2JvdW5kQW5pbWF0ZSIsImdldE93bmVyUm9vdCIsImxpc3RlbiIsInVubGlzdGVuIiwic2hvdWxkS2VlcEFuaW1hdGluZyIsInNpbXVsYXRlZFJpcHBsZSIsImFkZFJpcHBsZSIsInVpVXBBY3Rpb24iLCJvbkFuaW1hdGlvbkNvbXBsZXRlIiwiYmFja2dyb3VuZCIsIndhdmVzIiwiX3NldEFuaW1hdGluZyIsInJlbW92ZVJpcHBsZSIsInJpcHBsZUluZGV4IiwiX29uRW50ZXJLZXlkb3duIiwiX29uU3BhY2VLZXlkb3duIiwiX29uU3BhY2VLZXl1cCIsIl9ob2xkRG93bkNoYW5nZWQiLCJuZXdWYWwiLCJvbGRWYWwiLCJhZGREb3VibGVUYXBMaXN0ZW5lciIsInJlbW92ZURvdWJsZVRhcExpc3RlbmVyIiwiX3RvdWNoc3RhcnQiLCJfdG91Y2hlbmQiLCJfcHJlIiwiZG91YmxlVGFwIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaEVuZCIsIm5ld1RvdWNoIiwiZGJsY2xpY2siLCJNYXJrZXJEcmFnIiwiX21hcmtlciIsIl9kcmFnZ2FibGUiLCJkcmFnc3RhcnQiLCJfb25EcmFnU3RhcnQiLCJkcmFnIiwiX29uRHJhZyIsImRyYWdlbmQiLCJfb25EcmFnRW5kIiwiX29sZExhdExuZyIsImNsb3NlUG9wdXAiLCJzaGFkb3ciLCJpY29uUG9zIiwiTGVhZmxldE1hcCIsInpvb21Db250cm9sIiwiYXR0cmlidXRpb25QcmVmaXgiLCJfY2hpbGRyZW5PYnNlcnZlciIsImluZXJ0aWFEZWNlbGVyYXRpb24iLCJpbmVydGlhTWF4U3BlZWQiLCJ0YXBUb2xlcmFuY2UiLCJhdHRyQ29udHJvbCIsInNsb3QiLCJfYmluZERlcGVuZGVuY2llcyIsIl9wYW5lIiwib3ZlcmxheVBhbmUiLCJfcmVzZXRTdGF0ZVRpbWVvdXQiLCJfZGVzdHJveSIsIl9vbk1vdXNlRG93biIsIl9yZXNldFN0YXRlIiwiX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlIiwiY29udGV4dG1lbnUiLCJfb25Nb3VzZVVwIiwia2V5ZG93biIsIl9vbktleURvd24iLCJfYm94IiwiX2ZpbmlzaCIsImJveFpvb21Cb3VuZHMiLCJkb3VibGVDbGlja1pvb20iLCJfb25Eb3VibGVDbGljayIsIm9sZFpvb20iLCJpbmVydGlhIiwid29ybGRDb3B5SnVtcCIsIm1heEJvdW5kc1Zpc2Nvc2l0eSIsIl9vblByZURyYWdMaW1pdCIsIl9vblByZURyYWdXcmFwIiwiX3Bvc2l0aW9ucyIsIl90aW1lcyIsIl9vZmZzZXRMaW1pdCIsIl92aXNjb3NpdHkiLCJfbGFzdFRpbWUiLCJfbGFzdFBvcyIsIl9hYnNQb3MiLCJweENlbnRlciIsInB4V29ybGRDZW50ZXIiLCJfaW5pdGlhbFdvcmxkT2Zmc2V0IiwiX3dvcmxkV2lkdGgiLCJfdmlzY291c0xpbWl0IiwidGhyZXNob2xkIiwid29ybGRXaWR0aCIsImhhbGZXaWR0aCIsIm5ld1gxIiwibmV3WDIiLCJuZXdYIiwibm9JbmVydGlhIiwiZWFzZSIsInNwZWVkVmVjdG9yIiwic3BlZWQiLCJsaW1pdGVkU3BlZWQiLCJsaW1pdGVkU3BlZWRWZWN0b3IiLCJkZWNlbGVyYXRpb25EdXJhdGlvbiIsImtleWJvYXJkUGFuRGVsdGEiLCJrZXlDb2RlcyIsIl9zZXRQYW5EZWx0YSIsIl9zZXRab29tRGVsdGEiLCJfb25Gb2N1cyIsIl9vbkJsdXIiLCJfYWRkSG9va3MiLCJfcmVtb3ZlSG9va3MiLCJfZm9jdXNlZCIsImRvY0VsIiwic2Nyb2xsVG8iLCJwYW5EZWx0YSIsIl9wYW5LZXlzIiwiY29kZXMiLCJfem9vbUtleXMiLCJzY3JvbGxXaGVlbFpvb20iLCJ3aGVlbERlYm91bmNlVGltZSIsIndoZWVsUHhQZXJab29tTGV2ZWwiLCJfb25XaGVlbFNjcm9sbCIsIl9kZWx0YSIsIl9sYXN0TW91c2VQb3MiLCJfcGVyZm9ybVpvb20iLCJkMiIsImQzIiwiZDQiLCJfZmlyZUNsaWNrIiwiX2hvbGRUaW1lb3V0IiwiX2lzVGFwVmFsaWQiLCJfc2ltdWxhdGVFdmVudCIsInNpbXVsYXRlZEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInRvdWNoWm9vbSIsImJvdW5jZUF0Wm9vbUxpbWl0cyIsIl9vblRvdWNoU3RhcnQiLCJfem9vbWluZyIsIl9jZW50ZXJQb2ludCIsIl9zdGFydExhdExuZyIsIl9waW5jaFN0YXJ0TGF0TG5nIiwiX3N0YXJ0RGlzdCIsIl9zdGFydFpvb20iLCJfb25Ub3VjaE1vdmUiLCJfb25Ub3VjaEVuZCIsIm1vdmVGbiIsImNvbGxhcHNlZCIsImF1dG9aSW5kZXgiLCJoaWRlU2luZ2xlQmFzZSIsInNvcnRMYXllcnMiLCJzb3J0RnVuY3Rpb24iLCJsYXllckEiLCJsYXllckIiLCJuYW1lQSIsIm5hbWVCIiwib3ZlcmxheXMiLCJfbGF5ZXJDb250cm9sSW5wdXRzIiwiX2xhc3RaSW5kZXgiLCJfaGFuZGxpbmdDbGljayIsIl9hZGRMYXllciIsIl9jaGVja0Rpc2FibGVkTGF5ZXJzIiwiX29uTGF5ZXJDaGFuZ2UiLCJfZXhwYW5kSWZOb3RDb2xsYXBzZWQiLCJhZGRCYXNlTGF5ZXIiLCJhZGRPdmVybGF5IiwiX2dldExheWVyIiwiZXhwYW5kIiwiX2Zvcm0iLCJhY2NlcHRhYmxlSGVpZ2h0Iiwib2Zmc2V0VG9wIiwiY29sbGFwc2UiLCJmb3JtIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJfbGF5ZXJzTGluayIsIl9iYXNlTGF5ZXJzTGlzdCIsIl9zZXBhcmF0b3IiLCJfb3ZlcmxheXNMaXN0IiwiYmFzZUxheWVyc1ByZXNlbnQiLCJvdmVybGF5c1ByZXNlbnQiLCJiYXNlTGF5ZXJzQ291bnQiLCJfYWRkSXRlbSIsIl9jcmVhdGVSYWRpb0VsZW1lbnQiLCJyYWRpb0h0bWwiLCJyYWRpb0ZyYWdtZW50IiwibGFiZWwiLCJpbnB1dCIsImRlZmF1bHRDaGVja2VkIiwibGF5ZXJJZCIsIl9vbklucHV0Q2xpY2siLCJob2xkZXIiLCJpbnB1dHMiLCJhZGRlZExheWVycyIsInJlbW92ZWRMYXllcnMiLCJfZXhwYW5kIiwiX2NvbGxhcHNlIiwiem9vbUluVGV4dCIsInpvb21JblRpdGxlIiwiem9vbU91dFRleHQiLCJ6b29tT3V0VGl0bGUiLCJ6b29tTmFtZSIsIl96b29tSW5CdXR0b24iLCJfY3JlYXRlQnV0dG9uIiwiX3pvb21JbiIsIl96b29tT3V0QnV0dG9uIiwiX3pvb21PdXQiLCJfdXBkYXRlRGlzYWJsZWQiLCJfZGlzYWJsZWQiLCJtYXhXaWR0aCIsIm1ldHJpYyIsImltcGVyaWFsIiwiX2FkZFNjYWxlcyIsIl9tU2NhbGUiLCJfaVNjYWxlIiwibWF4TWV0ZXJzIiwiX3VwZGF0ZVNjYWxlcyIsIl91cGRhdGVNZXRyaWMiLCJfdXBkYXRlSW1wZXJpYWwiLCJtZXRlcnMiLCJfZ2V0Um91bmROdW0iLCJfdXBkYXRlU2NhbGUiLCJtYXhGZWV0IiwibWF4TWlsZXMiLCJtaWxlcyIsImZlZXQiLCJwb3cxMCIsImF1dG9wbGF5IiwibG9vcCIsIndhc0VsZW1lbnRTdXBwbGllZCIsInZpZCIsImNsYXNzIiwib25sb2FkZWRkYXRhIiwidmlkZW8iLCJtaW5XaWR0aCIsIm1heEhlaWdodCIsImF1dG9QYW4iLCJhdXRvUGFuUGFkZGluZ1RvcExlZnQiLCJhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IiwiYXV0b1BhblBhZGRpbmciLCJrZWVwSW5WaWV3IiwiY2xvc2VCdXR0b24iLCJhdXRvQ2xvc2UiLCJvcGVuT24iLCJvcGVuUG9wdXAiLCJjbG9zZU9uQ2xpY2siLCJjbG9zZVBvcHVwT25DbGljayIsInByZWNsaWNrIiwiX2Nsb3NlIiwid3JhcHBlciIsIl93cmFwcGVyIiwiX3RpcENvbnRhaW5lciIsIl90aXAiLCJfY2xvc2VCdXR0b24iLCJfb25DbG9zZUJ1dHRvbkNsaWNrIiwid2hpdGVTcGFjZSIsIm9mZnNldEhlaWdodCIsInNjcm9sbGVkQ2xhc3MiLCJtYXJnaW5Cb3R0b20iLCJjb250YWluZXJIZWlnaHQiLCJjb250YWluZXJXaWR0aCIsImxheWVyUG9zIiwiY29udGFpbmVyUG9zIiwiX3BvcHVwSGFuZGxlcnNBZGRlZCIsIl9vcGVuUG9wdXAiLCJrZXlwcmVzcyIsIl9vbktleVByZXNzIiwiX21vdmVQb3B1cCIsInVuYmluZFBvcHVwIiwidG9nZ2xlUG9wdXAiLCJpc1BvcHVwT3BlbiIsInNldFBvcHVwQ29udGVudCIsImdldFBvcHVwIiwicGVybWFuZW50Iiwic3RpY2t5IiwiY2xvc2VUb29sdGlwIiwiX3NldFBvc2l0aW9uIiwidG9vbHRpcFBvaW50IiwidG9vbHRpcFdpZHRoIiwidG9vbHRpcEhlaWdodCIsIm9wZW5Ub29sdGlwIiwiYmluZFRvb2x0aXAiLCJfdG9vbHRpcCIsIl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyIsInVuYmluZFRvb2x0aXAiLCJfdG9vbHRpcEhhbmRsZXJzQWRkZWQiLCJfbW92ZVRvb2x0aXAiLCJfb3BlblRvb2x0aXAiLCJ0b2dnbGVUb29sdGlwIiwiaXNUb29sdGlwT3BlbiIsInNldFRvb2x0aXBDb250ZW50IiwiZ2V0VG9vbHRpcCIsIkRpdkljb24iLCJkaXZJY29uIiwiRGVmYXVsdCIsImJnUG9zIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiV01TIiwid21zIiwiUmVjdGFuZ2xlIiwicmVjdGFuZ2xlIiwiX2JvdW5kc1RvTGF0TG5ncyIsInZtbENyZWF0ZSIsIm5hbWVzcGFjZXMiLCJ2bWxNaXhpbiIsImNvb3Jkc2l6ZSIsIl9zdHJva2UiLCJfZmlsbCIsInN0cm9rZWQiLCJmaWxsZWQiLCJkYXNoU3R5bGUiLCJlbmRjYXAiLCJqb2luc3R5bGUiLCJfZ2V0UGFuZVJlbmRlcmVyIiwicHJlZmVyQ2FudmFzIiwiTGVhZmxldFdNU0dyb3VwIiwid21zU291cmNlIiwic3ViTGF5ZXJzIiwiX3dtc09wdGlvbnMiLCJpbmZvX2Zvcm1hdCIsIlNvdXJjZSIsIm5ld1ZhbHVlIiwicmVwbGFjZUFsbFN1YkxheWVycyIsInRpbGVkIiwidW50aWxlZCIsIl9zdWJMYXllcnMiLCJfb3ZlcmxheSIsImNyZWF0ZU92ZXJsYXkiLCJvdmVybGF5T3B0aW9ucyIsInJlZnJlc2hPdmVybGF5IiwiaXNCYWNrIiwibmV3U3ViTGF5ZXJzIiwiZXZ0IiwiZ2V0SWRlbnRpZnlMYXllcnMiLCJnZXRGZWF0dXJlSW5mbyIsInNob3dGZWF0dXJlSW5mbyIsImdldEZlYXR1cmVJbmZvUGFyYW1zIiwic2hvd1dhaXRpbmciLCJhamF4IiwiaGlkZVdhaXRpbmciLCJwYXJzZUZlYXR1cmVJbmZvIiwiaWRlbnRpZnlMYXllcnMiLCJ1cGRhdGVXbXNQYXJhbXMiLCJpbmZvUGFyYW1zIiwiY3Vyc29yIiwibGF5ZXJOYW1lIiwiYWRkU3ViTGF5ZXIiLCJnZXRTb3VyY2VGb3JVcmwiLCJfbmFtZSIsInJlbW92ZVN1YkxheWVyIiwic291cmNlcyIsIk92ZXJsYXkiLCJfY3VycmVudE92ZXJsYXkiLCJfY3VycmVudFVybCIsImdldEltYWdlVXJsIiwiX3N3YXAiLCJ3bXNWZXJzaW9uIiwicHN0ciIsIlhNTEh0dHBSZXF1ZXN0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwib3BlbiIsInNlbmQiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJMZWFmbGV0V01TTGF5ZXIiLCJMZWFmbGV0VGlsZUxheWVyIiwibGVhZmxldExheWVyIiwiaGludHMiLCJMZWFmbGV0R2VvSlNPTiIsIm91dGxpbmVDb2xvciIsImNsdXN0ZXIiLCJtYXhDbHVzdGVyUmFkaXVzIiwiX2NsdXN0ZXJHcm91cCIsInNob3dDb3ZlcmFnZU9uSG92ZXIiLCJfY2lyY2xlTWFrZXJPcHRpb25zIiwiX2dlb0pTT05PcHRpb25zIiwiX2NsdXN0ZXJQb2ludHMiLCJfc2ltcGxlUG9pbnRzIiwiX2dlb0pTT05MYXllciIsIl9nZW5lcmF0ZVBvcHVwQ29udGVudCIsInJvd3MiLCJmaWVsZE5hbWUiLCJ0eHQiLCJjaGFyQXQiLCJzdWJzdHIiLCJyZXMiLCJfYWRkR2VvSlNPTkxheWVyIiwibm9Db25mbGljdCIsIm9sZEwiLCJleHBvcnRzIiwiUHJvamVjdGlvbiIsIkVQU0czMzk1IiwiU2ltcGxlIiwiTWFya2VyQ2x1c3Rlckdyb3VwIiwiTWFya2VyQ2x1c3RlciIsImljb25DcmVhdGVGdW5jdGlvbiIsImNsdXN0ZXJQYW5lIiwic3BpZGVyZnlPbk1heFpvb20iLCJ6b29tVG9Cb3VuZHNPbkNsaWNrIiwic2luZ2xlTWFya2VyTW9kZSIsImRpc2FibGVDbHVzdGVyaW5nQXRab29tIiwicmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHMiLCJhbmltYXRlQWRkaW5nTWFya2VycyIsInNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyIiwic3BpZGVyTGVnUG9seWxpbmVPcHRpb25zIiwiY2h1bmtlZExvYWRpbmciLCJjaHVua0ludGVydmFsIiwiY2h1bmtEZWxheSIsImNodW5rUHJvZ3Jlc3MiLCJwb2x5Z29uT3B0aW9ucyIsIl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uIiwiX2ZlYXR1cmVHcm91cCIsIl9ub25Qb2ludEdyb3VwIiwiX2luWm9vbUFuaW1hdGlvbiIsIl9uZWVkc0NsdXN0ZXJpbmciLCJfbmVlZHNSZW1vdmluZyIsIl9jdXJyZW50U2hvd25Cb3VuZHMiLCJfcXVldWUiLCJfY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzIiwiX2NoaWxkTWFya2VyRHJhZ1N0YXJ0IiwiX2NoaWxkTWFya2VyTW92ZWQiLCJfY2hpbGRNYXJrZXJEcmFnRW5kIiwiX3dpdGhBbmltYXRpb24iLCJfbm9BbmltYXRpb24iLCJfbWFya2VyQ2x1c3RlciIsIk1hcmtlckNsdXN0ZXJOb25BbmltYXRlZCIsImFkZExheWVycyIsIl91bnNwaWRlcmZ5IiwiX21heFpvb20iLCJfdG9wQ2x1c3RlckxldmVsIiwiX3JlY2FsY3VsYXRlQm91bmRzIiwiX3JlZnJlc2hDbHVzdGVyc0ljb25zIiwidmlzaWJsZUxheWVyIiwiY3VycmVudFpvb20iLCJfX3BhcmVudCIsIl9hbmltYXRpb25BZGRMYXllciIsIl9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkIiwicmVtb3ZlTGF5ZXJzIiwiX2FycmF5U3BsaWNlIiwiX3Vuc3BpZGVyZnlMYXllciIsIl9yZW1vdmVMYXllciIsImNsdXN0ZXJTaG93IiwibGF5ZXJzQXJyYXkiLCJza2lwTGF5ZXJBZGRFdmVudCIsImZnIiwibnBnIiwiY2h1bmtlZCIsIm9yaWdpbmFsQXJyYXkiLCJnZXRUaW1lIiwicHJvY2VzcyIsIl9leHRyYWN0Tm9uR3JvdXBMYXllcnMiLCJnZXRDaGlsZENvdW50IiwiZ2V0QWxsQ2hpbGRNYXJrZXJzIiwib3RoZXJNYXJrZXIiLCJfcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwIiwibmVlZHNDbHVzdGVyaW5nIiwibGF5ZXJzQXJyYXkyIiwibDIiLCJfZ3JpZENsdXN0ZXJzIiwiX2dyaWRVbmNsdXN0ZXJlZCIsIl9ub2FuaW1hdGlvblVuc3BpZGVyZnkiLCJfZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnMiLCJuZWVkc1JlbW92aW5nIiwidGhpc05lZWRzUmVtb3ZpbmciLCJhbkFycmF5IiwiX2dyb3VwIiwiem9vbVRvU2hvd0xheWVyIiwic2hvd01hcmtlciIsInNwaWRlcmZ5Iiwiem9vbVRvQm91bmRzIiwiX21heExhdCIsIm5ld2xhdGxuZyIsIl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMiLCJfem9vbUVuZCIsIl9zcGlkZXJmaWVyT25BZGQiLCJfYmluZEV2ZW50cyIsIl91bmJpbmRFdmVudHMiLCJfc3BpZGVyZmllck9uUmVtb3ZlIiwiX2hpZGVDb3ZlcmFnZSIsImdldFZpc2libGVQYXJlbnQiLCJ2TWFya2VyIiwiX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQiLCJncmlkVW5jbHVzdGVyZWQiLCJyZW1vdmVPYmplY3QiLCJfX2RyYWdTdGFydCIsIl9pZ25vcmVNb3ZlIiwiX21vdmVDaGlsZCIsInJlbW92ZUZyb21EaXN0YW5jZUdyaWQiLCJkb250VXBkYXRlTWFwIiwiZ3JpZENsdXN0ZXJzIiwiX21hcmtlcnMiLCJfY2hpbGRDb3VudCIsIl9ib3VuZHNOZWVkVXBkYXRlIiwiX2NMYXRMbmciLCJhZGRPYmplY3QiLCJfY2hpbGRDbHVzdGVycyIsIl9pY29uTmVlZHNVcGRhdGUiLCJfaXNPcklzUGFyZW50Iiwib2VsIiwiY2hpbGRDb3VudCIsIl96b29tT3JTcGlkZXJmeSIsIl9zaG93Q292ZXJhZ2UiLCJib3R0b21DbHVzdGVyIiwiX3Nob3duUG9seWdvbiIsIl9zcGlkZXJmaWVkIiwiZ2V0Q29udmV4SHVsbCIsIl9tZXJnZVNwbGl0Q2x1c3RlcnMiLCJfcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAiLCJyYWRpdXNGbiIsIkRpc3RhbmNlR3JpZCIsIm1hcmtlclBvaW50IiwiX292ZXJyaWRlTWFya2VySWNvbiIsImdldE5lYXJPYmplY3QiLCJfYWRkQ2hpbGQiLCJuZXdDbHVzdGVyIiwibGFzdFBhcmVudCIsIl91cGRhdGVJY29uIiwiX2VucXVldWUiLCJfcXVldWVUaW1lb3V0IiwiX3Byb2Nlc3NRdWV1ZSIsIl9hbmltYXRpb25TdGFydCIsIl9hbmltYXRpb25ab29tSW4iLCJfYW5pbWF0aW9uWm9vbU91dCIsIl9tYXBCb3VuZHNJbmZpbml0ZSIsIl9jaGVja0JvdW5kc01heExhdCIsIm1heExhdCIsIl9hZGRUb01hcCIsImdyb3VwIiwib3V0cHV0IiwicHJldmlvdXNab29tTGV2ZWwiLCJuZXdab29tTGV2ZWwiLCJfcmVjdXJzaXZlbHkiLCJzdGFydFBvcyIsIl9pc1NpbmdsZVBhcmVudCIsImNsdXN0ZXJIaWRlIiwiX2ZvcmNlTGF5b3V0IiwiX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZSIsIl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyIsIl9hbmltYXRpb25FbmQiLCJfYW5pbWF0aW9uWm9vbU91dFNpbmdsZSIsIm1lIiwiX3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW5BbmRBZGRTZWxmVG9NYXAiLCJtYXJrZXJDbHVzdGVyR3JvdXAiLCJzdG9yYWdlQXJyYXkiLCJmaXRCb3VuZHNPcHRpb25zIiwiY2hpbGRDbHVzdGVycyIsImJvdW5kc1pvb20iLCJuZXdDbHVzdGVycyIsIl9pY29uT2JqIiwibmV3MSIsImlzTm90aWZpY2F0aW9uRnJvbUNoaWxkIiwiX3NldENsdXN0ZXJDZW50ZXIiLCJjaGlsZCIsIl9yZXNldEJvdW5kcyIsImxhdFN1bSIsImxuZ1N1bSIsInRvdGFsQ291bnQiLCJjaGlsZExhdExuZyIsIl93TGF0TG5nIiwiX2JhY2t1cExhdGxuZyIsIl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluIiwiY20iLCJtYXBNaW5ab29tIiwiem9vbUxldmVsIiwibm0iLCJfcmVzdG9yZVBvc2l0aW9uIiwicHJldmlvdXNCb3VuZHMiLCJleGNlcHRCb3VuZHMiLCJib3VuZHNUb0FwcGx5VG8iLCJ6b29tTGV2ZWxUb1N0YXJ0Iiwiem9vbUxldmVsVG9TdG9wIiwicnVuQXRFdmVyeUxldmVsIiwicnVuQXRCb3R0b21MZXZlbCIsIm9wYWNpdHlXaGVuVW5jbHVzdGVyZWQiLCJjZWxsU2l6ZSIsIl9jZWxsU2l6ZSIsIl9zcUNlbGxTaXplIiwiX2dyaWQiLCJfb2JqZWN0UG9pbnQiLCJfZ2V0Q29vcmQiLCJncmlkIiwicm93IiwiY2VsbCIsInVwZGF0ZU9iamVjdCIsImVhY2hPYmplY3QiLCJvYmplY3RQb2ludCIsImNsb3Nlc3REaXN0U3EiLCJjb29yZCIsIlF1aWNrSHVsbCIsImdldERpc3RhbnQiLCJjcHQiLCJ2WSIsInZYIiwiZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmUiLCJiYXNlTGluZSIsImxhdExuZ3MiLCJtYXhEIiwibWF4UHQiLCJwdCIsIm1heFBvaW50IiwiYnVpbGRDb252ZXhIdWxsIiwiY29udmV4SHVsbEJhc2VMaW5lcyIsIm1pbkxhdCIsIm1heExuZyIsIm1pbkxuZyIsIm1heExhdFB0IiwibWluTGF0UHQiLCJtYXhMbmdQdCIsIm1pbkxuZ1B0IiwibWluUHQiLCJjaCIsImNoaWxkTWFya2VycyIsIl8yUEkiLCJfY2lyY2xlRm9vdFNlcGFyYXRpb24iLCJfY2lyY2xlU3RhcnRBbmdsZSIsIl9zcGlyYWxGb290U2VwYXJhdGlvbiIsIl9zcGlyYWxMZW5ndGhTdGFydCIsIl9zcGlyYWxMZW5ndGhGYWN0b3IiLCJfY2lyY2xlU3BpcmFsU3dpdGNob3ZlciIsInBvc2l0aW9ucyIsIl9nZW5lcmF0ZVBvaW50c1NwaXJhbCIsIl9nZW5lcmF0ZVBvaW50c0NpcmNsZSIsIl9hbmltYXRpb25TcGlkZXJmeSIsInVuc3BpZGVyZnkiLCJ6b29tRGV0YWlscyIsIl9hbmltYXRpb25VbnNwaWRlcmZ5IiwiY2VudGVyUHQiLCJjaXJjdW1mZXJlbmNlIiwibGVnTGVuZ3RoIiwiYW5nbGVTdGVwIiwiYW5nbGUiLCJzZXBhcmF0aW9uIiwibGVuZ3RoRmFjdG9yIiwiX3ByZVNwaWRlcmZ5TGF0bG5nIiwiX3NwaWRlckxlZyIsImxlZ09wdGlvbnMiLCJsZWciLCJ0aGlzTGF5ZXJMYXRMbmciLCJ0aGlzTGF5ZXJQb3MiLCJmaW5hbExlZ09wYWNpdHkiLCJsZWdQYXRoIiwiZ2V0VG90YWxMZW5ndGgiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwibm9uQW5pbWF0YWJsZSIsInN0aWxsVGhlcmVDaGlsZENvdW50IiwiX3Vuc3BpZGVyZnlXcmFwcGVyIiwiX3Vuc3BpZGVyZnlab29tU3RhcnQiLCJfdW5zcGlkZXJmeVpvb21BbmltIiwicmVmcmVzaENsdXN0ZXJzIiwiX2ZsYWdQYXJlbnRzSWNvbnNOZWVkVXBkYXRlIiwiX3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VycyIsInJlZnJlc2hJY29uT3B0aW9ucyIsImRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzIiwiZ2xvYmFsIiwianN5YW1sIiwiVHlwZSIsIlNjaGVtYSIsIkZBSUxTQUZFX1NDSEVNQSIsIkpTT05fU0NIRU1BIiwiQ09SRV9TQ0hFTUEiLCJERUZBVUxUX1NBRkVfU0NIRU1BIiwiREVGQVVMVF9GVUxMX1NDSEVNQSIsImxvYWQiLCJsb2FkQWxsIiwic2FmZUxvYWRBbGwiLCJkdW1wIiwic2FmZUR1bXAiLCJZQU1MRXhjZXB0aW9uIiwiTUlOSU1BTF9TQ0hFTUEiLCJTQUZFX1NDSEVNQSIsIkRFRkFVTFRfU0NIRU1BIiwic2NhbiIsImNvbXBvc2UiLCJhZGRDb25zdHJ1Y3RvciIsImlzTm90aGluZyIsInRvQXJyYXkiLCJpc05lZ2F0aXZlWmVybyIsIk5FR0FUSVZFX0lORklOSVRZIiwiY29tcGlsZWRUeXBlTWFwIiwiVCIsInN0eWxlQWxpYXNlcyIsIkUiLCJzY2hlbWEiLCJfIiwiaW5kZW50Iiwic2tpcEludmFsaWQiLCJmbG93TGV2ZWwiLCJzdHlsZU1hcCIsInNvcnRLZXlzIiwibm9SZWZzIiwibm9Db21wYXRNb2RlIiwiY29uZGVuc2VGbG93IiwiaW1wbGljaXRUeXBlcyIsImNvbXBpbGVkSW1wbGljaXQiLCJleHBsaWNpdFR5cGVzIiwiY29tcGlsZWRFeHBsaWNpdCIsImR1cGxpY2F0ZXMiLCJ1c2VkRHVwbGljYXRlcyIsIlUiLCJKIiwiUSIsImVlIiwiRyIsIkgiLCJaIiwiVyIsIksiLCJ0ZSIsIlYiLCJCIiwiWSIsIlAiLCJYIiwiaCIsImNoYXJDb2RlQXQiLCJ1ZSIsIkQiLCJjZSIsIm9lIiwiYWUiLCJyZSIsImciLCJBIiwiQyIsImluc3RhbmNlT2YiLCJwcmVkaWNhdGUiLCJyZXByZXNlbnQiLCJkZWZhdWx0U3R5bGUiLCJNIiwiSSIsIk8iLCJOIiwicmVhc29uIiwibWFyayIsImNhcHR1cmVTdGFja1RyYWNlIiwiZmlsZW5hbWUiLCJvbldhcm5pbmciLCJsZWdhY3kiLCJsaXN0ZW5lciIsInR5cGVNYXAiLCJsaW5lIiwibGluZVN0YXJ0IiwibGluZUluZGVudCIsImRvY3VtZW50cyIsImFuY2hvck1hcCIsInRhZ01hcCIsImNvbnN0cnVjdCIsImNoZWNrTGluZUJyZWFrcyIsIllBTUwiLCJUQUciLCJidWZmZXIiLCJjb2x1bW4iLCJnZXRTbmlwcGV0Iiwic2NhbGFyIiwic2VxdWVuY2UiLCJtYXBwaW5nIiwiaW1wbGljaXQiLCJleHBsaWNpdCIsImxvYWRLaW5kIiwiREVGQVVMVCIsImV2ZXJ5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJsb3dlcmNhc2UiLCJjYW1lbGNhc2UiLCJQT1NJVElWRV9JTkZJTklUWSIsImJpbmFyeSIsIm9jdGFsIiwiZGVjaW1hbCIsImhleGFkZWNpbWFsIiwiZXNwcmltYSIsIm11bHRpbGluZSIsImlnbm9yZUNhc2UiLCJjYW5vbmljYWwiLCJVVEMiLCJzZXRUaW1lIiwidG9JU09TdHJpbmciXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztRQ2xEZ0JBLE0sR0FBQUEsTTtRQXlCQUMsSSxHQUFBQSxJO1FBb0JBQyxLLEdBQUFBLEs7UUFjQUMsUSxHQUFBQSxRO1FBZ0NBQyxPLEdBQUFBLE87UUFTQUMsTyxHQUFBQSxPO1FBSUFDLFMsR0FBQUEsUztRQU9BQyxJLEdBQUFBLEk7UUFNQUMsVSxHQUFBQSxVO1FBTUFDLFUsR0FBQUEsVTtRQWVBQyxjLEdBQUFBLGM7UUFlQUMsUSxHQUFBQSxRO1FBc0JBQyxPLEdBQUFBLE87UUF3Q0FDLGdCLEdBQUFBLGdCO1FBVUFDLGUsR0FBQUEsZTtBQTVPaEI7Ozs7OztBQU1PLElBQUlDLDBCQUFTQyxPQUFPRCxNQUFwQjtBQUNQQyxPQUFPRCxNQUFQLEdBQWdCLFVBQVVFLEdBQVYsRUFBZTtBQUFFLFFBQU9BLEdBQVA7QUFBYSxDQUE5Qzs7QUFFQTtBQUNBO0FBQ08sU0FBU2pCLE1BQVQs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dXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDkwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAxZDNiZWM0MTJmZWVjNWU4NzEyNyIsIi8qXHJcbiAqIEBuYW1lc3BhY2UgVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XHJcbk9iamVjdC5mcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmo7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gZXh0ZW5kKGRlc3Q6IE9iamVjdCwgc3JjPzogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoZGVzdCkge1xyXG5cdHZhciBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0Zm9yIChqID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRmb3IgKGkgaW4gc3JjKSB7XHJcblx0XHRcdGRlc3RbaV0gPSBzcmNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkZXN0O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW09iamVjdC5jcmVhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGUpXHJcbmV4cG9ydCB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdHJldHVybiBmdW5jdGlvbiAocHJvdG8pIHtcclxuXHRcdEYucHJvdG90eXBlID0gcHJvdG87XHJcblx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkLCBsaWtlIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXHJcbi8vIEhhcyBhIGBMLmJpbmQoKWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5kKGZuLCBvYmopIHtcclxuXHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdGlmIChmbi5iaW5kKSB7XHJcblx0XHRyZXR1cm4gZm4uYmluZC5hcHBseShmbiwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuXHR9XHJcblxyXG5cdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHR9O1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuLy8gTGFzdCB1bmlxdWUgSUQgdXNlZCBieSBbYHN0YW1wKClgXSgjdXRpbC1zdGFtcClcclxuZXhwb3J0IHZhciBsYXN0SWQgPSAwO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiBhbiBvYmplY3QsIGFzc2lnaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrbGFzdElkO1xyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0Lyplc2xpbnQtZW5hYmxlICovXHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0aHJvdHRsZShmbjogRnVuY3Rpb24sIHRpbWU6IE51bWJlciwgY29udGV4dDogT2JqZWN0KTogRnVuY3Rpb25cclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGZ1bmN0aW9uIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gc2NvcGUgYGNvbnRleHRgXHJcbi8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG4vLyBgZm5gIHdpbGwgYmUgY2FsbGVkIG5vIG1vcmUgdGhhbiBvbmUgdGltZSBwZXIgZ2l2ZW4gYW1vdW50IG9mIGB0aW1lYC4gVGhlIGFyZ3VtZW50c1xyXG4vLyByZWNlaXZlZCBieSB0aGUgYm91bmQgZnVuY3Rpb24gd2lsbCBiZSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGJpbmRpbmcgdGhlXHJcbi8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuLy8gSGFzIGFuIGBMLnRocm90dGxlYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB0aW1lLCBjb250ZXh0KSB7XHJcblx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcclxuXHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdGlmIChhcmdzKSB7XHJcblx0XHRcdHdyYXBwZXJGbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuXHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxyXG5cdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGNhbGwgYW5kIGxvY2sgdW50aWwgbGF0ZXJcclxuXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0c2V0VGltZW91dChsYXRlciwgdGltZSk7XHJcblx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiB3cmFwcGVyRm47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCBtb2R1bG8gYHJhbmdlYCBpbiBzdWNoIGEgd2F5IHNvIGl0IGxpZXMgd2l0aGluXHJcbi8vIGByYW5nZVswXWAgYW5kIGByYW5nZVsxXWAuIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGFsd2F5cyBzbWFsbGVyIHRoYW5cclxuLy8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwTnVtKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcblx0dmFyIG1heCA9IHJhbmdlWzFdLFxyXG5cdCAgICBtaW4gPSByYW5nZVswXSxcclxuXHQgICAgZCA9IG1heCAtIG1pbjtcclxuXHRyZXR1cm4geCA9PT0gbWF4ICYmIGluY2x1ZGVNYXggPyB4IDogKCh4IC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBmYWxzZUZuKCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG5leHBvcnQgZnVuY3Rpb24gZmFsc2VGbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG4vLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBkaWdpdHM/OiBOdW1iZXIpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIHJvdW5kZWQgdG8gYGRpZ2l0c2AgZGVjaW1hbHMsIG9yIHRvIDUgZGVjaW1hbHMgYnkgZGVmYXVsdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIGRpZ2l0cykge1xyXG5cdHZhciBwb3cgPSBNYXRoLnBvdygxMCwgZGlnaXRzIHx8IDUpO1xyXG5cdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0cmltKHN0cjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtTdHJpbmcucHJvdG90eXBlLnRyaW1dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltKVxyXG5leHBvcnQgZnVuY3Rpb24gdHJpbShzdHIpIHtcclxuXHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyOiBTdHJpbmcpOiBTdHJpbmdbXVxyXG4vLyBUcmltcyBhbmQgc3BsaXRzIHRoZSBzdHJpbmcgb24gd2hpdGVzcGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgcGFydHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cikge1xyXG5cdHJldHVybiB0cmltKHN0cikuc3BsaXQoL1xccysvKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxyXG4vLyBNZXJnZXMgdGhlIGdpdmVuIHByb3BlcnRpZXMgdG8gdGhlIGBvcHRpb25zYCBvZiB0aGUgYG9iamAgb2JqZWN0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBvcHRpb25zLiBTZWUgYENsYXNzIG9wdGlvbnNgLiBIYXMgYW4gYEwuc2V0T3B0aW9uc2Agc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcHRpb25zKG9iaiwgb3B0aW9ucykge1xyXG5cdGlmICghb2JqLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIHtcclxuXHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBjcmVhdGUob2JqLm9wdGlvbnMpIDoge307XHJcblx0fVxyXG5cdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0b2JqLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLm9wdGlvbnM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmo6IE9iamVjdCwgZXhpc3RpbmdVcmw/OiBTdHJpbmcsIHVwcGVyY2FzZT86IEJvb2xlYW4pOiBTdHJpbmdcclxuLy8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG4vLyB0cmFuc2xhdGVzIHRvIGAnP2E9Zm9vJmI9YmFyJ2AuIElmIGBleGlzdGluZ1VybGAgaXMgc2V0LCB0aGUgcGFyYW1ldGVycyB3aWxsXHJcbi8vIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQuIElmIGB1cHBlcmNhc2VgIGlzIGB0cnVlYCwgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsXHJcbi8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtU3RyaW5nKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdHZhciBwYXJhbXMgPSBbXTtcclxuXHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdH1cclxuXHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxufVxyXG5cclxudmFyIHRlbXBsYXRlUmUgPSAvXFx7ICooW1xcd19cXC1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuZnVuY3Rpb24gZ2V0UHJlZml4ZWQobmFtZSkge1xyXG5cdHJldHVybiB3aW5kb3dbJ3dlYmtpdCcgKyBuYW1lXSB8fCB3aW5kb3dbJ21veicgKyBuYW1lXSB8fCB3aW5kb3dbJ21zJyArIG5hbWVdO1xyXG59XHJcblxyXG52YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuLy8gZmFsbGJhY2sgZm9yIElFIDctOFxyXG5mdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAodGltZSAtIGxhc3RUaW1lKSk7XHJcblxyXG5cdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lVG9DYWxsKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciByZXF1ZXN0Rm4gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcbmV4cG9ydCB2YXIgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHRcdGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNsZWFyVGltZW91dChpZCk7IH07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QsIGltbWVkaWF0ZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuLy8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG4vLyBgY29udGV4dGAgaWYgZ2l2ZW4uIFdoZW4gYGltbWVkaWF0ZWAgaXMgc2V0LCBgZm5gIGlzIGNhbGxlZCBpbW1lZGlhdGVseSBpZlxyXG4vLyB0aGUgYnJvd3NlciBkb2Vzbid0IGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yXHJcbi8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuLy8gb3RoZXJ3aXNlIGl0J3MgZGVsYXllZC4gUmV0dXJucyBhIHJlcXVlc3QgSUQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuLCBjb250ZXh0LCBpbW1lZGlhdGUpIHtcclxuXHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRmbi5jYWxsKGNvbnRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBiaW5kKGZuLCBjb250ZXh0KSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuLy8gQ2FuY2VscyBhIHByZXZpb3VzIGByZXF1ZXN0QW5pbUZyYW1lYC4gU2VlIGFsc28gW3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZSkuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQpIHtcclxuXHRpZiAoaWQpIHtcclxuXHRcdGNhbmNlbEZuLmNhbGwod2luZG93LCBpZCk7XHJcblx0fVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9VdGlsLmpzIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5leHBvcnQgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG5cdFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbi8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OX0VORCA9XHJcblx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbi8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXQoaWQpIHtcclxuXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbi8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcblx0cmV0dXJuIGVsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudC5sYXN0Q2hpbGQgIT09IGVsKSB7XHJcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRvQmFjayhlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGZpcnN0IGNoaWxkIG9mIGl0cyBwYXJlbnQsIHNvIGl0IHJlbmRlcnMgYmVoaW5kIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvQmFjayhlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHBhcmVudC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgY29udGFpbnMgYG5hbWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0fVxyXG5cdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBBZGRzIGBuYW1lYCB0byB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgY2xhc3NlcyA9IFV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICghaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0c2V0Q2xhc3MoZWwsIChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuYW1lKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuLy8gUmVtb3ZlcyBgbmFtZWAgZnJvbSB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzZXRDbGFzcyhlbCwgVXRpbC50cmltKCgnICcgKyBnZXRDbGFzcyhlbCkgKyAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKSkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBTZXRzIHRoZSBlbGVtZW50J3MgY2xhc3MuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBpbiBjYXNlIG9mIFNWRyBlbGVtZW50XHJcblx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50KTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzKGVsKSB7XHJcblx0cmV0dXJuIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQgPyBlbC5jbGFzc05hbWUgOiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldE9wYWNpdHkoZWw6IEhUTUxFbGVtZW50LCBvcGFjaXR5OiBOdW1iZXIpXHJcbi8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG4vLyBgb3BhY2l0eWAgbXVzdCBiZSBhIG51bWJlciBmcm9tIGAwYCB0byBgMWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsLCB2YWx1ZSkge1xyXG5cdGlmICgnb3BhY2l0eScgaW4gZWwuc3R5bGUpIHtcclxuXHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblx0XHRfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBfc2V0T3BhY2l0eUlFKGVsLCB2YWx1ZSkge1xyXG5cdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHQgICAgZmlsdGVyTmFtZSA9ICdEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYSc7XHJcblxyXG5cdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdHRyeSB7XHJcblx0XHRmaWx0ZXIgPSBlbC5maWx0ZXJzLml0ZW0oZmlsdGVyTmFtZSk7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHQvLyBpdCBpc24ndCBuZWVkZWQgYW5kIGJyZWFrcyB0cmFuc3BhcmVudCBwbmdzLlxyXG5cdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdH1cclxuXHJcblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcclxuXHJcblx0aWYgKGZpbHRlcikge1xyXG5cdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRmaWx0ZXIuT3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzOiBTdHJpbmdbXSk6IFN0cmluZ3xmYWxzZVxyXG4vLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcbi8vIHRoYXQgaXMgYSB2YWxpZCBzdHlsZSBuYW1lIGZvciBhbiBlbGVtZW50LiBJZiBubyBzdWNoIG5hbWUgaXMgZm91bmQsXHJcbi8vIGl0IHJldHVybnMgZmFsc2UuIFVzZWZ1bCBmb3IgdmVuZG9yLXByZWZpeGVkIHN0eWxlcyBsaWtlIGB0cmFuc2Zvcm1gLlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcclxuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChwcm9wc1tpXSBpbiBzdHlsZSkge1xyXG5cdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG4vLyBSZXNldHMgdGhlIDNEIENTUyB0cmFuc2Zvcm0gb2YgYGVsYCBzbyBpdCBpcyB0cmFuc2xhdGVkIGJ5IGBvZmZzZXRgIHBpeGVsc1xyXG4vLyBhbmQgb3B0aW9uYWxseSBzY2FsZWQgYnkgYHNjYWxlYC4gRG9lcyBub3QgaGF2ZSBhbiBlZmZlY3QgaWYgdGhlXHJcbi8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcblx0dmFyIHBvcyA9IG9mZnNldCB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblxyXG5cdGVsLnN0eWxlW1RSQU5TRk9STV0gPVxyXG5cdFx0KEJyb3dzZXIuaWUzZCA/XHJcblx0XHRcdCd0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknIDpcclxuXHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcblx0XHQoc2NhbGUgPyAnIHNjYWxlKCcgKyBzY2FsZSArICcpJyA6ICcnKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCwgcG9zaXRpb246IFBvaW50KVxyXG4vLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG4vLyB1c2luZyBDU1MgdHJhbnNsYXRlIG9yIHRvcC9sZWZ0IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlclxyXG4vLyAodXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gcG9zaXRpb24gaXRzIGxheWVycykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbCwgcG9pbnQpIHtcclxuXHJcblx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdGVsLl9sZWFmbGV0X3BvcyA9IHBvaW50O1xyXG5cdC8qZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbmV4cG9ydCB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21VdGlsLmpzIiwid2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCBvYmopIHsgcmV0dXJuIHByb3A7IH1cblxuLyoqIEBuYW1lc3BhY2UgKi9cbmxldCBQb2x5bWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9ib290LmpzIiwiaW1wb3J0IHtpc0FycmF5LCBmb3JtYXROdW19IGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Qb2ludC5qcyIsImltcG9ydCB7c3ZnQ3JlYXRlfSBmcm9tICcuLi9sYXllci92ZWN0b3IvU1ZHLlV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG5leHBvcnQgdmFyIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdztcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZWx0OTogQm9vbGVhbjsgYHRydWVgIGZvciBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBsZXNzIHRoYW4gOS5cclxuZXhwb3J0IHZhciBpZWx0OSA9IGllICYmICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuLy8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcbmV4cG9ydCB2YXIgZWRnZSA9ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbmV4cG9ydCB2YXIgd2Via2l0ID0gdXNlckFnZW50Q29udGFpbnMoJ3dlYmtpdCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbmV4cG9ydCB2YXIgYW5kcm9pZCA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxuZXhwb3J0IHZhciBhbmRyb2lkMjMgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAyJykgfHwgdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMycpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbmV4cG9ydCB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG5leHBvcnQgdmFyIGNocm9tZSA9IHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbmV4cG9ydCB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbmV4cG9ydCB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5leHBvcnQgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuZXhwb3J0IHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuZXhwb3J0IHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbmV4cG9ydCB2YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyBUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4vLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbi8vIHRvdWNoIGV2ZW50cy5cclxuZXhwb3J0IHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4uXHJcbmV4cG9ydCB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxuZXhwb3J0IHZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbmV4cG9ydCB2YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4vLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuZXhwb3J0IHZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0Jyb3dzZXIuanMiLCJpbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge2FkZFBvaW50ZXJMaXN0ZW5lciwgcmVtb3ZlUG9pbnRlckxpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LlBvaW50ZXInO1xyXG5pbXBvcnQge2FkZERvdWJsZVRhcExpc3RlbmVyLCByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Eb3VibGVUYXAnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBEb21FdmVudFxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET00gZXZlbnRzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRXZlbnQpLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICovXHJcblxyXG4vLyBJbnNwaXJlZCBieSBKb2huIFJlc2lnLCBEZWFuIEVkd2FyZHMgYW5kIFlVSSBhZGRFdmVudCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiAoYGZuYCkgdG8gYSBwYXJ0aWN1bGFyIERPTSBldmVudCB0eXBlIG9mIHRoZVxyXG4vLyBlbGVtZW50IGBlbGAuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lclxyXG4vLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG4vLyBzcGFjZS1zZXBhcmF0ZWQgdHlwZXMgKGUuZy4gYCdjbGljayBkYmxjbGljaydgKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgc2V0IG9mIHR5cGUvbGlzdGVuZXIgcGFpcnMsIGUuZy4gYHtjbGljazogb25DbGljaywgbW91c2Vtb3ZlOiBvbk1vdXNlTW92ZX1gXHJcbmV4cG9ydCBmdW5jdGlvbiBvbihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxudmFyIGV2ZW50c0tleSA9ICdfbGVhZmxldF9ldmVudHMnO1xyXG5cclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCxcclxuLy8gaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIERPTSBldmVudCBmcm9tIHRoZSBlbGVtZW50LlxyXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbi8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBSZW1vdmVzIGFsbCBrbm93biBldmVudCBsaXN0ZW5lcnNcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCBqLCBvYmpbZXZlbnRzS2V5XVtqXSk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiBhZGREb3VibGVUYXBMaXN0ZW5lciAmJlxyXG5cdCAgICAgICAgICAgIShCcm93c2VyLnBvaW50ZXIgJiYgQnJvd3Nlci5jaHJvbWUpKSB7XHJcblx0XHQvLyBDaHJvbWUgPjU1IGRvZXMgbm90IG5lZWQgdGhlIHN5bnRoZXRpYyBkYmxjbGlja3MgZnJvbSBhZGREb3VibGVUYXBMaXN0ZW5lclxyXG5cdFx0Ly8gU2VlICM1MTgwXHJcblx0XHRhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIEJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0cmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2V3aGVlbCcpIHtcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ud2hlZWwnIGluIG9iaiA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCcsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuXHRcdFx0XHR0eXBlID09PSAnbW91c2VlbnRlcicgPyAnbW91c2VvdmVyJyA6XHJcblx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IG51bGw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG4vLyBTdG9wIHRoZSBnaXZlbiBldmVudCBmcm9tIHByb3BhZ2F0aW9uIHRvIHBhcmVudCBlbGVtZW50cy4gVXNlZCBpbnNpZGUgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uczpcclxuLy8gYGBganNcclxuLy8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4vLyBcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2KTtcclxuLy8gfSk7XHJcbi8vIGBgYFxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcclxuXHJcblx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRlLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgPSB0cnVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0fVxyXG5cdHNraXBwZWQoZSk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnbW91c2V3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ21vdXNld2hlZWwnLCBzdG9wUHJvcGFnYXRpb24pO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdjbGljaydgLCBgJ2RvdWJsZWNsaWNrJ2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljaycsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0YWRkT25lKGVsLCAnY2xpY2snLCBmYWtlU3RvcCk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldik6IHRoaXNcclxuLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcChlKSB7XHJcblx0cHJldmVudERlZmF1bHQoZSk7XHJcblx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbi8vIGBjb250YWluZXJgIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG5cdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHR9XHJcblxyXG5cdHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHRlLmNsaWVudFkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3ApO1xyXG59XHJcblxyXG4vLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG4vLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQoQnJvd3Nlci53aW4gJiYgQnJvd3Nlci5jaHJvbWUpID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLmdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbnZhciBza2lwRXZlbnRzID0ge307XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmFrZVN0b3AoZSkge1xyXG5cdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBza2lwcGVkKGUpIHtcclxuXHR2YXIgZXZlbnRzID0gc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0cmV0dXJuIGV2ZW50cztcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbnZhciBsYXN0Q2xpY2s7XHJcblxyXG4vLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcbmZ1bmN0aW9uIGZpbHRlckNsaWNrKGUsIGhhbmRsZXIpIHtcclxuXHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCkpLFxyXG5cdCAgICBlbGFwc2VkID0gbGFzdENsaWNrICYmICh0aW1lU3RhbXAgLSBsYXN0Q2xpY2spO1xyXG5cclxuXHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdC8vIG9uIHRoZSBzYW1lIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZmFyIGZhc3RlcjtcclxuXHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRzdG9wKGUpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRsYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdGhhbmRsZXIoZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuZXhwb3J0IHtvbiBhcyBhZGRMaXN0ZW5lcn07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuZXhwb3J0IHtvZmYgYXMgcmVtb3ZlTGlzdGVuZXJ9O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5qcyIsImltcG9ydCB7IExlZ2FjeUVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgJy4vbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCAnLi9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWJpbmQuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWlmLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanMnO1xuaW1wb3J0ICcuL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzJztcbmV4cG9ydCBjb25zdCBCYXNlID0gTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KS5wcm90b3R5cGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCB7RVBTRzM4NTd9IGZyb20gJy4uL2dlby9jcnMvQ1JTLkVQU0czODU3JztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge0JvdW5kcywgdG9Cb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuLi9kb20vUG9zQW5pbWF0aW9uJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBVdGlsLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBEb21VdGlsLlRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHREb21FdmVudC5vbih0aGlzLl9wcm94eSwgRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG5cdFx0XHRcdG9wdGlvbnMucGFuID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0XHR6b29tOiB6b29tXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcblx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21vdmUoXHJcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSk7XHJcblxyXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm1pblpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Wm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdXBwZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21heFpvb21dKCNtYXAtbWF4em9vbSkgb3B0aW9uKS5cclxuXHRzZXRNYXhab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm1heFpvb20gPSB6b29tO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQgJiYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9QYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5KSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIGhhbmRsZXIuYWRkVG9cclxuXHQvLyBUT0RPIEFwcHJvcGlhdGUgZG9jcyBzZWN0aW9uP1xyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGFkZEhhbmRsZXIobmFtZTogU3RyaW5nLCBIYW5kbGVyQ2xhc3M6IEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBuZXcgYEhhbmRsZXJgIHRvIHRoZSBtYXAsIGdpdmVuIGl0cyBuYW1lIGFuZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuXHRhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XHJcblx0XHRpZiAoIUhhbmRsZXJDbGFzcykgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcblx0XHRcdGhhbmRsZXIuZW5hYmxlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmUoKTogdGhpc1xyXG5cdC8vIERlc3Ryb3lzIHRoZSBtYXAgYW5kIGNsZWFycyBhbGwgcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cyh0cnVlKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY29udGFpbmVySWQgIT09IHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYmVpbmcgcmV1c2VkIGJ5IGFub3RoZXIgaW5zdGFuY2UnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZDtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcklkO1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0Lyplc2xpbnQtZW5hYmxlICovXHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lcklkID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcblx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGk7XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9wYW5lcykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9wYW5lcyA9IFtdO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX21hcFBhbmU7XHJcblx0XHRkZWxldGUgdGhpcy5fcmVuZGVyZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgY3JlYXRlUGFuZShuYW1lOiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDcmVhdGVzIGEgbmV3IFttYXAgcGFuZV0oI21hcC1wYW5lKSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSxcclxuXHQvLyB0aGVuIHJldHVybnMgaXQuIFRoZSBwYW5lIGlzIGNyZWF0ZWQgYXMgYSBjaGlsZCBvZiBgY29udGFpbmVyYCwgb3JcclxuXHQvLyBhcyBhIGNoaWxkIG9mIHRoZSBtYWluIG1hcCBwYW5lIGlmIG5vdCBzZXQuXHJcblx0Y3JlYXRlUGFuZTogZnVuY3Rpb24gKG5hbWUsIGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LXBhbmUnICsgKG5hbWUgPyAnIGxlYWZsZXQtJyArIG5hbWUucmVwbGFjZSgnUGFuZScsICcnKSArICctcGFuZScgOiAnJyksXHJcblx0XHQgICAgcGFuZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAobmFtZSkge1xyXG5cdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBnaXZlbiBib3VuZHMgZml0IHRvIHRoZSBtYXBcclxuXHQvLyB2aWV3IGluIGl0cyBlbnRpcmV0eS4gSWYgYGluc2lkZWAgKG9wdGlvbmFsKSBpcyBzZXQgdG8gYHRydWVgLCB0aGUgbWV0aG9kXHJcblx0Ly8gaW5zdGVhZCByZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIG1hcCB2aWV3IGZpdHMgaW50b1xyXG5cdC8vIHRoZSBnaXZlbiBib3VuZHMgaW4gaXRzIGVudGlyZXR5LlxyXG5cdGdldEJvdW5kc1pvb206IGZ1bmN0aW9uIChib3VuZHMsIGluc2lkZSwgcGFkZGluZykgeyAvLyAoTGF0TG5nQm91bmRzWywgQm9vbGVhbiwgUG9pbnRdKSAtPiBOdW1iZXJcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblx0XHRwYWRkaW5nID0gdG9Qb2ludChwYWRkaW5nIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0dmFyIHpvb20gPSB0aGlzLmdldFpvb20oKSB8fCAwLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIG53ID0gYm91bmRzLmdldE5vcnRoV2VzdCgpLFxyXG5cdFx0ICAgIHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkaW5nKSxcclxuXHRcdCAgICBib3VuZHNTaXplID0gdG9Cb3VuZHModGhpcy5wcm9qZWN0KHNlLCB6b29tKSwgdGhpcy5wcm9qZWN0KG53LCB6b29tKSkuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMSxcclxuXHRcdCAgICBzY2FsZXggPSBzaXplLnggLyBib3VuZHNTaXplLngsXHJcblx0XHQgICAgc2NhbGV5ID0gc2l6ZS55IC8gYm91bmRzU2l6ZS55LFxyXG5cdFx0ICAgIHNjYWxlID0gaW5zaWRlID8gTWF0aC5tYXgoc2NhbGV4LCBzY2FsZXkpIDogTWF0aC5taW4oc2NhbGV4LCBzY2FsZXkpO1xyXG5cclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCB8fCAwLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgMCk7XHJcblxyXG5cdFx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuY2xvbmUoKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsQm91bmRzKCk6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBtYXAgdmlldyBpbiBwcm9qZWN0ZWQgcGl4ZWxcclxuXHQvLyBjb29yZGluYXRlcyAoc29tZXRpbWVzIHVzZWZ1bCBpbiBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KHRvTGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKHRvUG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QodG9MYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKHRvTGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZ0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcyk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nQm91bmRzYCB3aXRoIHRoZSBzYW1lIHNpemUgYXMgdGhlIGdpdmVuIG9uZSwgZW5zdXJpbmcgdGhhdFxyXG5cdC8vIGl0cyBjZW50ZXIgaXMgd2l0aGluIHRoZSBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIHRoZSBjZW50ZXIgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcywgYW5kIHRoZSBtYWpvcml0eSBvZiB0aGUgYm91bmRzXHJcblx0Ly8gb3ZlcmxhcHMgdGhlIENSUydzIGJvdW5kcy5cclxuXHR3cmFwTGF0TG5nQm91bmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nQm91bmRzKHRvTGF0TG5nQm91bmRzKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKHRvTGF0TG5nKGxhdGxuZzEpLCB0b0xhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnNcclxuXHQvLyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRvUG9pbnQocG9pbnQpKTtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KHRvTGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZVxyXG5cdC8vIG1hcCBjb250YWluZXIgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gRG9tRXZlbnQuZ2V0TW91c2VQb3NpdGlvbihlLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF5ZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXRMbmcoZXY6IE1vdXNlRXZlbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIHdoZXJlIHRoZVxyXG5cdC8vIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF0TG5nOiBmdW5jdGlvbiAoZSkgeyAvLyAoTW91c2VFdmVudClcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBtYXAgaW5pdGlhbGl6YXRpb24gbWV0aG9kc1xyXG5cclxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgdGhpcyk7XHJcblx0XHR0aGlzLl9jb250YWluZXJJZCA9IFV0aWwuc3RhbXAoY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHR0aGlzLl9mYWRlQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuZmFkZUFuaW1hdGlvbiAmJiBCcm93c2VyLmFueTNkO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEJyb3dzZXIudG91Y2ggPyAnIGxlYWZsZXQtdG91Y2gnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5zYWZhcmkgPyAnIGxlYWZsZXQtc2FmYXJpJyA6ICcnKSArXHJcblx0XHRcdCh0aGlzLl9mYWRlQW5pbWF0ZWQgPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9yIG92ZXJsYXlzIChgUGF0aGBzKSwgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciB0b29sdGlwLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhKSB7XHJcblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcblx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsIGluY2x1ZGluZyB6b29tXHJcblx0XHQvLyBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsIGluY2x1ZGluZyBwYW4gYW5kXHJcblx0XHQvLyBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBoYXMgY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0b3BwZWRcclxuXHRcdC8vIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyBEb21FdmVudC5vZmYgOiBEb21FdmVudC5vbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdG9uT2ZmKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcycsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZGc2cjVoaGIvXHJcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2ZpbmRFdmVudFRhcmdldHM6IGZ1bmN0aW9uIChlLCB0eXBlKSB7XHJcblx0XHR2YXIgdGFyZ2V0cyA9IFtdLFxyXG5cdFx0ICAgIHRhcmdldCxcclxuXHRcdCAgICBpc0hvdmVyID0gdHlwZSA9PT0gJ21vdXNlb3V0JyB8fCB0eXBlID09PSAnbW91c2VvdmVyJyxcclxuXHRcdCAgICBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXHJcblx0XHQgICAgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR3aGlsZSAoc3JjKSB7XHJcblx0XHRcdHRhcmdldCA9IHRoaXMuX3RhcmdldHNbVXRpbC5zdGFtcChzcmMpXTtcclxuXHRcdFx0aWYgKHRhcmdldCAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAncHJlY2xpY2snKSAmJiAhZS5fc2ltdWxhdGVkICYmIHRoaXMuX2RyYWdnYWJsZU1vdmVkKHRhcmdldCkpIHtcclxuXHRcdFx0XHQvLyBQcmV2ZW50IGZpcmluZyBjbGljayBhZnRlciB5b3UganVzdCBkcmFnZ2VkIGFuIG9iamVjdC5cclxuXHRcdFx0XHRkcmFnZ2luZyA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRhcmdldCAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyICYmICFEb21FdmVudC5pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHsgYnJlYWs7IH1cclxuXHRcdFx0XHR0YXJnZXRzLnB1c2godGFyZ2V0KTtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlcikgeyBicmVhazsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChzcmMgPT09IHRoaXMuX2NvbnRhaW5lcikgeyBicmVhazsgfVxyXG5cdFx0XHRzcmMgPSBzcmMucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGggJiYgIWRyYWdnaW5nICYmICFpc0hvdmVyICYmIERvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkge1xyXG5cdFx0XHR0YXJnZXRzID0gW3RoaXNdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZURPTUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQgfHwgRG9tRXZlbnQuc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ2tleXByZXNzJykge1xyXG5cdFx0XHQvLyBwcmV2ZW50cyBvdXRsaW5lIHdoZW4gY2xpY2tpbmcgb24ga2V5Ym9hcmQtZm9jdXNhYmxlIGVsZW1lbnRcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZShlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCB0YXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCB0YXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZS5fc3RvcHBlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR0YXJnZXRzID0gKHRhcmdldHMgfHwgW10pLmNvbmNhdCh0aGlzLl9maW5kRXZlbnRUYXJnZXRzKGUsIHR5cGUpKTtcclxuXHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdO1xyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ2tleXByZXNzJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSAodGFyZ2V0Lm9wdGlvbnMgJiYgJ2ljb24nIGluIHRhcmdldC5vcHRpb25zKTtcclxuXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuXHRcdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyA9PT0gZmFsc2UgJiYgVXRpbC5pbmRleE9mKHRoaXMuX21vdXNlRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lKSB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciBwaXhlbE9yaWdpbiA9IGNlbnRlciAmJiB6b29tICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHR0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pIDpcclxuXHRcdFx0dGhpcy5nZXRQaXhlbE9yaWdpbigpO1xyXG5cdFx0cmV0dXJuIHBpeGVsT3JpZ2luLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2dldE5ld1BpeGVsT3JpZ2luOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ1RvTmV3TGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0b0JvdW5kcyhbXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KVxyXG5cdFx0XSk7XHJcblx0fSxcclxuXHJcblx0Ly8gbGF5ZXIgcG9pbnQgb2YgdGhlIGN1cnJlbnQgY2VudGVyXHJcblx0X2dldENlbnRlckxheWVyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gb2Zmc2V0IG9mIHRoZSBzcGVjaWZpZWQgcGxhY2UgdG8gdGhlIGN1cnJlbnQgY2VudGVyIGluIHBpeGVsc1xyXG5cdF9nZXRDZW50ZXJPZmZzZXQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpLnN1YnRyYWN0KHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IGNlbnRlciBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdENlbnRlcjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgYm91bmRzKSB7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGNlbnRlcjsgfVxyXG5cclxuXHRcdHZhciBjZW50ZXJQb2ludCA9IHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHQvLyBJZiBvZmZzZXQgaXMgbGVzcyB0aGFuIGEgcGl4ZWwsIGlnbm9yZS5cclxuXHRcdC8vIFRoaXMgcHJldmVudHMgdW5zdGFibGUgcHJvamVjdGlvbnMgZnJvbSBnZXR0aW5nIGludG9cclxuXHRcdC8vIGFuIGluZmluaXRlIGxvb3Agb2YgdGlueSBvZmZzZXRzLlxyXG5cdFx0aWYgKG9mZnNldC5yb3VuZCgpLmVxdWFscyhbMCwgMF0pKSB7XHJcblx0XHRcdHJldHVybiBjZW50ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KGNlbnRlclBvaW50LmFkZChvZmZzZXQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3Qgb2Zmc2V0IGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBib3VuZHMpIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBvZmZzZXQ7IH1cclxuXHJcblx0XHR2YXIgdmlld0JvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBuZXdCb3VuZHMgPSBuZXcgQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSB0b0JvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoZHgsIGR5KTtcclxuXHR9LFxyXG5cclxuXHRfcmVib3VuZDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XHJcblx0XHRyZXR1cm4gbGVmdCArIHJpZ2h0ID4gMCA/XHJcblx0XHRcdE1hdGgucm91bmQobGVmdCAtIHJpZ2h0KSAvIDIgOlxyXG5cdFx0XHRNYXRoLm1heCgwLCBNYXRoLmNlaWwobGVmdCkpIC0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihyaWdodCkpO1xyXG5cdH0sXHJcblxyXG5cdF9saW1pdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHR2YXIgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2Zsb29yKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBwcm94eSA9IHRoaXMuX3Byb3h5ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXByb3h5IGxlYWZsZXQtem9vbS1hbmltYXRlZCcpO1xyXG5cdFx0dGhpcy5fcGFuZXMubWFwUGFuZS5hcHBlbmRDaGlsZChwcm94eSk7XHJcblxyXG5cdFx0dGhpcy5vbignem9vbWFuaW0nLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHR2YXIgcHJvcCA9IERvbVV0aWwuVFJBTlNGT1JNLFxyXG5cdFx0XHQgICAgdHJhbnNmb3JtID0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF07XHJcblxyXG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcclxuXHJcblx0XHRcdC8vIHdvcmthcm91bmQgZm9yIGNhc2Ugd2hlbiB0cmFuc2Zvcm0gaXMgdGhlIHNhbWUgYW5kIHNvIHRyYW5zaXRpb25lbmQgZXZlbnQgaXMgbm90IGZpcmVkXHJcblx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcclxuXHRcdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMub24oJ2xvYWQgbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0XHQgICAgeiA9IHRoaXMuZ2V0Wm9vbSgpO1xyXG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybSh0aGlzLl9wcm94eSwgdGhpcy5wcm9qZWN0KGMsIHopLCB0aGlzLmdldFpvb21TY2FsZSh6LCAxKSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9vbigndW5sb2FkJywgdGhpcy5fZGVzdHJveUFuaW1Qcm94eSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2Rlc3Ryb3lBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3Byb3h5KTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9wcm94eTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoc3RhcnRBbmltKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xyXG5cclxuXHRcdFx0Ly8gcmVtZW1iZXIgd2hhdCBjZW50ZXIvem9vbSB0byBzZXQgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdFx0dGhpcy5fYW5pbWF0ZVRvWm9vbSA9IHpvb207XHJcblxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgb24gZXZlcnkgZnJhbWUgb2YgYSB6b29tIGFuaW1hdGlvblxyXG5cdFx0dGhpcy5maXJlKCd6b29tYW5pbScsIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb20sXHJcblx0XHRcdG5vVXBkYXRlOiBub1VwZGF0ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gV29yayBhcm91bmQgd2Via2l0IG5vdCBmaXJpbmcgJ3RyYW5zaXRpb25lbmQnLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzY4OSwgMjY5M1xyXG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCwgdGhpcyksIDI1MCk7XHJcblx0fSxcclxuXHJcblx0X29uWm9vbVRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXpvb20tYW5pbScpO1xyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSk7XHJcblxyXG5cdFx0Ly8gVGhpcyBhbmltIGZyYW1lIHNob3VsZCBwcmV2ZW50IGFuIG9ic2N1cmUgaU9TIHdlYmtpdCB0aWxlIGxvYWRpbmcgcmFjZSBjb25kaXRpb24uXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBzZWN0aW9uXHJcblxyXG4vLyBAZmFjdG9yeSBMLm1hcChpZDogU3RyaW5nLCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gdGhlIERPTSBJRCBvZiBhIGA8ZGl2PmAgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbi8vXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLm1hcChlbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiBhbiBpbnN0YW5jZSBvZiBhIGA8ZGl2PmAgSFRNTCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hcChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFwKGlkLCBvcHRpb25zKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9NYXAuanMiLCJpbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoIWEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdHZhciBwb2ludHMgPSBiID8gW2EsIGJdIDogYTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQocG9pbnRzW2ldKTtcclxuXHR9XHJcbn1cclxuXHJcbkJvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBleHRlbmQocG9pbnQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIEV4dGVuZHMgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludC5cclxuXHRleHRlbmQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtaW46IFBvaW50XHJcblx0XHQvLyBUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHQvLyBAcHJvcGVydHkgbWF4OiBQb2ludFxyXG5cdFx0Ly8gVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdGlmICghdGhpcy5taW4gJiYgIXRoaXMubWF4KSB7XHJcblx0XHRcdHRoaXMubWluID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5taW4ueCA9IE1hdGgubWluKHBvaW50LngsIHRoaXMubWluLngpO1xyXG5cdFx0XHR0aGlzLm1heC54ID0gTWF0aC5tYXgocG9pbnQueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihwb2ludC55LCB0aGlzLm1pbi55KTtcclxuXHRcdFx0dGhpcy5tYXgueSA9IE1hdGgubWF4KHBvaW50LnksIHRoaXMubWF4LnkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIocm91bmQ/OiBCb29sZWFuKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLm1heC54LCB0aGlzLm1pbi55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFRvcExlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5taW5gXSgjYm91bmRzLW1pbikpLlxyXG5cdGdldFRvcExlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1pbjsgLy8gbGVmdCwgdG9wXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21SaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGJvdHRvbS1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzIChpLmUuIFtgdGhpcy5tYXhgXSgjYm91bmRzLW1heCkpLlxyXG5cdGdldEJvdHRvbVJpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXg7IC8vIHJpZ2h0LCBib3R0b21cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBib3VuZHNcclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhwb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gdG9Qb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gdG9Cb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRcdG1pbiA9IG9iai5taW47XHJcblx0XHRcdG1heCA9IG9iai5tYXg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtaW4gPSBtYXggPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChtaW4ueCA+PSB0aGlzLm1pbi54KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueCA8PSB0aGlzLm1heC54KSAmJlxyXG5cdFx0ICAgICAgIChtaW4ueSA+PSB0aGlzLm1pbi55KSAmJlxyXG5cdFx0ICAgICAgIChtYXgueSA8PSB0aGlzLm1heC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIGludGVyc2VjdCBpZiB0aGV5IGhhdmUgYXQgbGVhc3Qgb25lIHBvaW50IGluIGNvbW1vbi5cclxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhJbnRlcnNlY3RzID0gKG1heDIueCA+PSBtaW4ueCkgJiYgKG1pbjIueCA8PSBtYXgueCksXHJcblx0XHQgICAgeUludGVyc2VjdHMgPSAobWF4Mi55ID49IG1pbi55KSAmJiAobWluMi55IDw9IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geEludGVyc2VjdHMgJiYgeUludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXAgaWYgdGhlaXIgaW50ZXJzZWN0aW9uIGlzIGFuIGFyZWEuXHJcblx0b3ZlcmxhcHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeE92ZXJsYXBzID0gKG1heDIueCA+IG1pbi54KSAmJiAobWluMi54IDwgbWF4LngpLFxyXG5cdFx0ICAgIHlPdmVybGFwcyA9IChtYXgyLnkgPiBtaW4ueSkgJiYgKG1pbjIueSA8IG1heC55KTtcclxuXHJcblx0XHRyZXR1cm4geE92ZXJsYXBzICYmIHlPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Cb3VuZHMuanMiLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNldHRpbmcgYG1heE1hcmdpbmAgdG8gYSBzbWFsbCBudW1iZXIuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAob2JqLCBtYXhNYXJnaW4pIHtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IE1hdGgubWF4KFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxhdCAtIG9iai5sYXQpLFxyXG5cdFx0ICAgICAgICBNYXRoLmFicyh0aGlzLmxuZyAtIG9iai5sbmcpKTtcclxuXHJcblx0XHRyZXR1cm4gbWFyZ2luIDw9IChtYXhNYXJnaW4gPT09IHVuZGVmaW5lZCA/IDEuMEUtOSA6IG1heE1hcmdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlcykuXHJcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiAnTGF0TG5nKCcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxhdCwgcHJlY2lzaW9uKSArICcsICcgK1xyXG5cdFx0ICAgICAgICBVdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEVhcnRoLmRpc3RhbmNlKHRoaXMsIHRvTGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBFYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnMvMmAgbWV0ZXJzIGFwYXJ0IGZyb20gdGhlIGBMYXRMbmdgLlxyXG5cdHRvQm91bmRzOiBmdW5jdGlvbiAoc2l6ZUluTWV0ZXJzKSB7XHJcblx0XHR2YXIgbGF0QWNjdXJhY3kgPSAxODAgKiBzaXplSW5NZXRlcnMgLyA0MDA3NTAxNyxcclxuXHRcdCAgICBsbmdBY2N1cmFjeSA9IGxhdEFjY3VyYWN5IC8gTWF0aC5jb3MoKE1hdGguUEkgLyAxODApICogdGhpcy5sYXQpO1xyXG5cclxuXHRcdHJldHVybiB0b0xhdExuZ0JvdW5kcyhcclxuXHRcdCAgICAgICAgW3RoaXMubGF0IC0gbGF0QWNjdXJhY3ksIHRoaXMubG5nIC0gbG5nQWNjdXJhY3ldLFxyXG5cdFx0ICAgICAgICBbdGhpcy5sYXQgKyBsYXRBY2N1cmFjeSwgdGhpcy5sbmcgKyBsbmdBY2N1cmFjeV0pO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9MYXRMbmcoYSwgYiwgYykge1xyXG5cdGlmIChhIGluc3RhbmNlb2YgTGF0TG5nKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH1cclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IExhdExuZyhhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoYSwgYiwgYyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vTGF0TG5nLmpzIiwiaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBiaWdnZXIgYm91bmRzIGNyZWF0ZWQgYnkgZXh0ZW5kaW5nIHRoZSBjdXJyZW50IGJvdW5kcyBieSBhIGdpdmVuIHBlcmNlbnRhZ2UgaW4gZWFjaCBkaXJlY3Rpb24uXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcywgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgbWF4TWFyZ2luKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpLCBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNWYWxpZCgpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJvdW5kcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXHJcblx0aXNWYWxpZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMuX3NvdXRoV2VzdCAmJiB0aGlzLl9ub3J0aEVhc3QpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIFRPRE8gSW50ZXJuYXRpb25hbCBkYXRlIGxpbmU/XHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxOiBMYXRMbmcsIGNvcm5lcjI6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyB0d28gZGlhZ29uYWxseSBvcHBvc2l0ZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMobGF0bG5nczogTGF0TG5nW10pXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgZGVmaW5lZCBieSB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50cyBpdCBjb250YWlucy4gVmVyeSB1c2VmdWwgZm9yIHpvb21pbmcgdGhlIG1hcCB0byBmaXQgYSBwYXJ0aWN1bGFyIHNldCBvZiBsb2NhdGlvbnMgd2l0aCBbYGZpdEJvdW5kc2BdKCNtYXAtZml0Ym91bmRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nQm91bmRzKGEsIGIpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEsIGIpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL0xhdExuZ0JvdW5kcy5qcyIsImltcG9ydCB7IEVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGliL21peGlucy9lbGVtZW50LW1peGluLmpzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICogZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sXG4gKiBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uLlxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXInc1xuICogICBrZXkgbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZyxcbiAqICAgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbiwgYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvblxuICovXG5jb25zdCBFbGVtZW50ID0gRWxlbWVudE1peGluKEhUTUxFbGVtZW50KTtcbmV4cG9ydCB7IEVsZW1lbnQgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMiLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuTWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuZXhwb3J0IHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZGVzY3JpYmVzIHRoZSBsYXllciBkYXRhLCBlLmcuIFwiwqkgTWFwYm94XCIuXG5cdFx0YXR0cmlidXRpb246IG51bGwsXG5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0LyogQHNlY3Rpb25cblx0ICogQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG5cdCAqXG5cdCAqIEBtZXRob2QgYWRkVG8obWFwOiBNYXB8TGF5ZXJHcm91cCk6IHRoaXNcblx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcCBvciBsYXllciBncm91cC5cblx0ICovXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVGcm9tKG1hcDogTWFwKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBnaXZlbiBtYXBcblx0cmVtb3ZlRnJvbTogZnVuY3Rpb24gKG9iaikge1xuXHRcdGlmIChvYmopIHtcblx0XHRcdG9iai5yZW1vdmVMYXllcih0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRQYW5lKG5hbWU/IDogU3RyaW5nKTogSFRNTEVsZW1lbnRcblx0Ly8gUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCByZXByZXNlbnRpbmcgdGhlIG5hbWVkIHBhbmUgb24gdGhlIG1hcC4gSWYgYG5hbWVgIGlzIG9taXR0ZWQsIHJldHVybnMgdGhlIHBhbmUgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKG5hbWUgPyAodGhpcy5vcHRpb25zW25hbWVdIHx8IG5hbWUpIDogdGhpcy5vcHRpb25zLnBhbmUpO1xuXHR9LFxuXG5cdGFkZEludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHR0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldID0gdGhpcztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRBdHRyaWJ1dGlvbjogU3RyaW5nXG5cdC8vIFVzZWQgYnkgdGhlIGBhdHRyaWJ1dGlvbiBjb250cm9sYCwgcmV0dXJucyB0aGUgW2F0dHJpYnV0aW9uIG9wdGlvbl0oI2dyaWRsYXllci1hdHRyaWJ1dGlvbikuXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGlvbiAmJiBtYXAuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbk1hcC5pbmNsdWRlKHtcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBtYXBcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghbGF5ZXIuX2xheWVyQWRkKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBvYmplY3QgaXMgbm90IGEgTGF5ZXIuJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sLnJlbW92ZUF0dHJpYnV0aW9uKGxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcblx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuXHRcdH1cblxuXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKFV0aWwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKFV0aWwuaXNBcnJheShsYXllcnMpID8gbGF5ZXJzIDogW2xheWVyc10pIDogW107XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pIHx8ICFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aGlzLl96b29tQm91bmRMYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVab29tTGltaXQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0pIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl96b29tQm91bmRMYXllcnNbaWRdO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlWm9vbUxldmVsczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaW5ab29tID0gSW5maW5pdHksXG5cdFx0ICAgIG1heFpvb20gPSAtSW5maW5pdHksXG5cdFx0ICAgIG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcblxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXS5vcHRpb25zO1xuXG5cdFx0XHRtaW5ab29tID0gb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyBtaW5ab29tIDogTWF0aC5taW4obWluWm9vbSwgb3B0aW9ucy5taW5ab29tKTtcblx0XHRcdG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/IG1heFpvb20gOiBNYXRoLm1heChtYXhab29tLCBvcHRpb25zLm1heFpvb20pO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tID09PSAtSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtYXhab29tO1xuXHRcdHRoaXMuX2xheWVyc01pblpvb20gPSBtaW5ab29tID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1pblpvb207XG5cblx0XHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xuXHRcdC8vIEBldmVudCB6b29tbGV2ZWxzY2hhbmdlOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG51bWJlciBvZiB6b29tbGV2ZWxzIG9uIHRoZSBtYXAgaXMgY2hhbmdlZCBkdWVcblx0XHQvLyB0byBhZGRpbmcgb3IgcmVtb3ZpbmcgYSBsYXllci5cblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01heFpvb20gJiYgdGhpcy5nZXRab29tKCkgPiB0aGlzLl9sYXllcnNNYXhab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWF4Wm9vbSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2xheWVyc01pblpvb20gJiYgdGhpcy5nZXRab29tKCkgPCB0aGlzLl9sYXllcnNNaW5ab29tKSB7XG5cdFx0XHR0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXIuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIHVuaXF1ZSBnbG9iYWwgaWQgZm9yIGRlZHVwaW5nIG1peGlucy5cbmxldCBkZWR1cGVJZCA9IDA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIE1peGluRnVuY3Rpb24oKXt9XG4vKiogQHR5cGUgeyhXZWFrTWFwIHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4vKiogQHR5cGUgeyhPYmplY3QgfCB1bmRlZmluZWQpfSAqL1xuTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpblNldDtcblxuZXhwb3J0IGNvbnN0IGRlZHVwaW5nTWl4aW4gPSBmdW5jdGlvbihtaXhpbikge1xuICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgaWYgKCFtaXhpbkFwcGxpY2F0aW9ucykge1xuICAgIG1peGluQXBwbGljYXRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICB9XG4gIC8vIG1haW50YWluIGEgdW5pcXVlIGlkIGZvciBlYWNoIG1peGluXG4gIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgZnVuY3Rpb24gZGVkdXBpbmdNaXhpbihiYXNlKSB7XG4gICAgbGV0IGJhc2VTZXQgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhiYXNlKS5fX21peGluU2V0O1xuICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgbGV0IGV4dGVuZGVkID0gbWFwLmdldChiYXNlKTtcbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICBtYXAuc2V0KGJhc2UsIGV4dGVuZGVkKTtcbiAgICB9XG4gICAgLy8gY29weSBpbmhlcml0ZWQgbWl4aW4gc2V0IGZyb20gdGhlIGV4dGVuZGVkIGNsYXNzLCBvciB0aGUgYmFzZSBjbGFzc1xuICAgIC8vIE5PVEU6IHdlIGF2b2lkIHVzZSBvZiBTZXQgaGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlciAoSUUxMSlcbiAgICAvLyBjYW5ub3QgZXh0ZW5kIGEgYmFzZSBTZXQgdmlhIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBsZXQgbWl4aW5TZXQgPSBPYmplY3QuY3JlYXRlKC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0IHx8IGJhc2VTZXQgfHwgbnVsbCk7XG4gICAgbWl4aW5TZXRbbWl4aW5EZWR1cGVJZF0gPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0ID0gbWl4aW5TZXQ7XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xuICB9XG5cbiAgcmV0dXJuIGRlZHVwaW5nTWl4aW47XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcyIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG4vKlxuXHRMLkhhbmRsZXIgaXMgYSBiYXNlIGNsYXNzIGZvciBoYW5kbGVyIGNsYXNzZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5IHRvIGluamVjdFxuXHRpbnRlcmFjdGlvbiBmZWF0dXJlcyBsaWtlIGRyYWdnaW5nIHRvIGNsYXNzZXMgbGlrZSBNYXAgYW5kIE1hcmtlci5cbiovXG5cbi8vIEBjbGFzcyBIYW5kbGVyXG4vLyBAYWthIEwuSGFuZGxlclxuLy8gQWJzdHJhY3QgY2xhc3MgZm9yIG1hcCBpbnRlcmFjdGlvbiBoYW5kbGVyc1xuXG5leHBvcnQgdmFyIEhhbmRsZXIgPSBDbGFzcy5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlKCk6IHRoaXNcblx0Ly8gRW5hYmxlcyB0aGUgaGFuZGxlclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5hZGRIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpOiB0aGlzXG5cdC8vIERpc2FibGVzIHRoZSBoYW5kbGVyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnJlbW92ZUhvb2tzKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBlbmFibGVkKCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhhbmRsZXIgaXMgZW5hYmxlZFxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZW5hYmxlZDtcblx0fVxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIENsYXNzZXMgaW5oZXJpdGluZyBmcm9tIGBIYW5kbGVyYCBtdXN0IGltcGxlbWVudCB0aGUgdHdvIGZvbGxvd2luZyBtZXRob2RzOlxuXHQvLyBAbWV0aG9kIGFkZEhvb2tzKClcblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGhhbmRsZXIgaXMgZW5hYmxlZCwgc2hvdWxkIGFkZCBldmVudCBob29rcy5cblx0Ly8gQG1ldGhvZCByZW1vdmVIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGRpc2FibGVkLCBzaG91bGQgcmVtb3ZlIHRoZSBldmVudCBob29rcyBhZGRlZCBwcmV2aW91c2x5LlxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvSGFuZGxlci5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxuLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG5sZXQgQXN5bmNJbnRlcmZhY2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLy8gTWljcm90YXNrIGltcGxlbWVudGVkIHVzaW5nIE11dGF0aW9uIE9ic2VydmVyXG5sZXQgbWljcm90YXNrQ3VyckhhbmRsZSA9IDA7XG5sZXQgbWljcm90YXNrTGFzdEhhbmRsZSA9IDA7XG5sZXQgbWljcm90YXNrQ2FsbGJhY2tzID0gW107XG5sZXQgbWljcm90YXNrTm9kZUNvbnRlbnQgPSAwO1xubGV0IG1pY3JvdGFza05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5uZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobWljcm90YXNrRmx1c2gpLm9ic2VydmUobWljcm90YXNrTm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuZnVuY3Rpb24gbWljcm90YXNrRmx1c2goKSB7XG4gIGNvbnN0IGxlbiA9IG1pY3JvdGFza0NhbGxiYWNrcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgY2IgPSBtaWNyb3Rhc2tDYWxsYmFja3NbaV07XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZTsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG1pY3JvdGFza0NhbGxiYWNrcy5zcGxpY2UoMCwgbGVuKTtcbiAgbWljcm90YXNrTGFzdEhhbmRsZSArPSBsZW47XG59XG5cbmV4cG9ydCBjb25zdCB0aW1lT3V0ID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIHN1Yi1tb2R1bGUgd2l0aCB0aGUgYXN5bmMgaW50ZXJmYWNlIHByb3ZpZGluZyB0aGUgcHJvdmlkZWRcbiAgICogZGVsYXkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja3MgaW4gbXNcbiAgICogQHJldHVybiB7QXN5bmNJbnRlcmZhY2V9IEFuIGFzeW5jIHRpbWVvdXQgaW50ZXJmYWNlXG4gICAqL1xuICBhZnRlcihkZWxheSkge1xuICAgIHJldHVybiAge1xuICAgICAgcnVuKGZuKSB7IHJldHVybiBzZXRUaW1lb3V0KGZuLCBkZWxheSk7IH0sXG4gICAgICBjYW5jZWw6IHdpbmRvdy5jbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGluIHRoZSBuZXh0IHRhc2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW46IHdpbmRvdy5zZXRUaW1lb3V0LmJpbmQod2luZG93KSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGB0aW1lT3V0YCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxufTtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbkZyYW1lID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bjogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyksXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgYW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWw6IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbn07XG5cbmV4cG9ydCBjb25zdCBpZGxlUGVyaW9kID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKElkbGVEZWFkbGluZSl9IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGZuKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID9cbiAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKSA6XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmbiwgMTYpO1xuICB9LFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGlkbGVQZXJpb2RgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA/XG4gICAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGhhbmRsZSkgOlxuICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWljcm9UYXNrID0ge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oY2FsbGJhY2spIHtcbiAgICBtaWNyb3Rhc2tOb2RlLnRleHRDb250ZW50ID0gbWljcm90YXNrTm9kZUNvbnRlbnQrKztcbiAgICBtaWNyb3Rhc2tDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIG1pY3JvdGFza0N1cnJIYW5kbGUrKztcbiAgfSxcblxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYG1pY3JvVGFza2AgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIGNvbnN0IGlkeCA9IGhhbmRsZSAtIG1pY3JvdGFza0xhc3RIYW5kbGU7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBpZiAoIW1pY3JvdGFza0NhbGxiYWNrc1tpZHhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhc3luYyBoYW5kbGU6ICcgKyBoYW5kbGUpO1xuICAgICAgfVxuICAgICAgbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcyIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5FYXJ0aFxuICpcbiAqIFNlcnZlcyBhcyB0aGUgYmFzZSBmb3IgQ1JTIHRoYXQgYXJlIGdsb2JhbCBzdWNoIHRoYXQgdGhleSBjb3ZlciB0aGUgZWFydGguXG4gKiBDYW4gb25seSBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciBvdGhlciBDUlMgYW5kIGNhbm5vdCBiZSB1c2VkIGRpcmVjdGx5LFxuICogc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIGBjb2RlYCwgYHByb2plY3Rpb25gIG9yIGB0cmFuc2Zvcm1hdGlvbmAuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBtZXRlcnMuXG4gKi9cblxuZXhwb3J0IHZhciBFYXJ0aCA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0d3JhcExuZzogWy0xODAsIDE4MF0sXG5cblx0Ly8gTWVhbiBFYXJ0aCBSYWRpdXMsIGFzIHJlY29tbWVuZGVkIGZvciB1c2UgYnlcblx0Ly8gdGhlIEludGVybmF0aW9uYWwgVW5pb24gb2YgR2VvZGVzeSBhbmQgR2VvcGh5c2ljcyxcblx0Ly8gc2VlIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuXHRSOiA2MzcxMDAwLFxuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBwb2ludHMgdXNpbmcgc3BoZXJpY2FsIGxhdyBvZiBjb3NpbmVzIGFwcHJveGltYXRpb25cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIHJhZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0ICAgIGxhdDEgPSBsYXRsbmcxLmxhdCAqIHJhZCxcblx0XHQgICAgbGF0MiA9IGxhdGxuZzIubGF0ICogcmFkLFxuXHRcdCAgICBhID0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArXG5cdFx0ICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MoKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpICogcmFkKTtcblxuXHRcdHJldHVybiB0aGlzLlIgKiBNYXRoLmFjb3MoTWF0aC5taW4oYSwgMSkpO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0ICcuLi91dGlscy9zZXR0aW5ncy5qcyc7XG5pbXBvcnQgeyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIH0gZnJvbSAnLi4vdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IGZsdXNoIGFzIGZsdXNoJDAsIGVucXVldWVEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5cbmNvbnN0IHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbi8qKlxuICogQGNvbnN0IHtmdW5jdGlvbih0aGlzOkVsZW1lbnQsIHN0cmluZyk6IGJvb2xlYW59XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gYGVsZW1lbnQubWF0Y2hlc2Agc2hpbS5cbiAqXG4gKiBAZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yXG4gKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGVjayBzZWxlY3RvciBhZ2FpbnN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gbWF0Y2hcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbm9kZSBtYXRjaGVkIHNlbGVjdG9yXG4gKi9cbmNvbnN0IG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xufTtcblxuLyoqXG4gKiBOb2RlIEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gKiBgdGFyZ2V0YCBpcyBhIGBOb2RlYC5cbiAqL1xuY2xhc3MgRG9tQXBpIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIFBvbHltZXIuZG9tIGhlbHBlciBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIHRoYXRcbiAgICogbGlzdGVucyBmb3Igbm9kZSBjaGFuZ2VzIG9uIHRoaXMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gZGlyZWN0IG9yIGRpc3RyaWJ1dGVkIGNoaWxkcmVuXG4gICAqICAgb2YgdGhpcyBlbGVtZW50IGNoYW5nZXNcbiAgICogQHJldHVybiB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBPYnNlcnZlciBpbnN0YW5jZVxuICAgKi9cbiAgb2JzZXJ2ZU5vZGVzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMubm9kZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuIG9ic2VydmVyIHByZXZpb3VzbHkgY3JlYXRlZCB2aWEgYG9ic2VydmVOb2Rlc2BcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IG9ic2VydmVySGFuZGxlIE9ic2VydmVyIGluc3RhbmNlXG4gICAqICAgdG8gZGlzY29ubmVjdC5cbiAgICovXG4gIHVub2JzZXJ2ZU5vZGVzKG9ic2VydmVySGFuZGxlKSB7XG4gICAgb2JzZXJ2ZXJIYW5kbGUuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVkIGFzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgQVBJIG9ubHkuICBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqL1xuICBub3RpZnlPYnNlcnZlcigpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgbm9kZSBpcyBjb250YWluZWQgd2l0aCB0aGlzIGVsZW1lbnQnc1xuICAgKiBsaWdodC1ET00gY2hpbGRyZW4gb3Igc2hhZG93IHJvb3QsIGluY2x1ZGluZyBhbnkgbmVzdGVkIHNoYWRvdyByb290c1xuICAgKiBvZiBjaGlsZHJlbiB0aGVyZWluLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byB0ZXN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGNvbnRhaW5lZCB3aXRoaW5cbiAgICogICB0aGlzIGVsZW1lbnQncyBsaWdodCBvciBzaGFkb3cgRE9NLlxuICAgKi9cbiAgZGVlcENvbnRhaW5zKG5vZGUpIHtcbiAgICBpZiAodGhpcy5ub2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG4gPSBub2RlO1xuICAgIGxldCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gd2FsayBmcm9tIG5vZGUgdG8gYHRoaXNgIG9yIGBkb2N1bWVudGBcbiAgICB3aGlsZSAobiAmJiBuICE9PSBkb2MgJiYgbiAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAvLyB1c2UgbG9naWNhbCBwYXJlbnRub2RlLCBvciBuYXRpdmUgU2hhZG93Um9vdCBob3N0XG4gICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIG4gPT09IHRoaXMubm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBub2RlLiAgRXF1aXZhbGVudCB0byBgZ2V0Um9vZE5vZGUoKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRvcCBtb3N0IGVsZW1lbnQgaW4gdGhlIGRvbSB0cmVlIGluIHdoaWNoIHRoZSBub2RlXG4gICAqIGV4aXN0cy4gSWYgdGhlIG5vZGUgaXMgY29ubmVjdGVkIHRvIGEgZG9jdW1lbnQgdGhpcyBpcyBlaXRoZXIgYVxuICAgKiBzaGFkb3dSb290IG9yIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBpdCBtYXkgYmUgdGhlIG5vZGVcbiAgICogaXRzZWxmIG9yIGEgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIGl0LlxuICAgKi9cbiAgZ2V0T3duZXJSb290KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc2xvdCBlbGVtZW50cywgcmV0dXJucyB0aGUgbm9kZXMgYXNzaWduZWQgdG8gdGhlIHNsb3Q7IG90aGVyd2lzZVxuICAgKiBhbiBlbXB0eSBhcnJheS4gSXQgaXMgZXF1aXZhbGVudCB0byBgPHNsb3Q+LmFkZGlnbmVkTm9kZXMoe2ZsYXR0ZW46dHJ1ZX0pYC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IEFycmF5IG9mIGFzc2lnbmVkIG5vZGVzXG4gICAqL1xuICBnZXREaXN0cmlidXRlZE5vZGVzKCkge1xuICAgIHJldHVybiAodGhpcy5ub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSA/XG4gICAgICB0aGlzLm5vZGUuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pIDpcbiAgICAgIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHNsb3RzIHRoaXMgZWxlbWVudCB3YXMgZGlzdHJpYnV0ZWQgdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxTbG90RWxlbWVudD59IERlc2NyaXB0aW9uXG4gICAqL1xuICBnZXREZXN0aW5hdGlvbkluc2VydGlvblBvaW50cygpIHtcbiAgICBsZXQgaXAkID0gW107XG4gICAgbGV0IG4gPSB0aGlzLm5vZGUuYXNzaWduZWRTbG90O1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpcCQucHVzaChuKTtcbiAgICAgIG4gPSBuLmFzc2lnbmVkU2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIGlwJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBvd25lckRvY3VtZW50YCBmb3IgdGhpcyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBpbXBvcnRcbiAgICogQHBhcmFtIHtib29sZWFufSBkZWVwIFRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIGNsb25lZCBkZWVwbHkgZHVyaW5nXG4gICAqICAgaW1wb3J0XG4gICAqIEByZXR1cm4ge05vZGV9IENsb25lIG9mIGdpdmVuIG5vZGUgaW1wb3J0ZWQgdG8gdGhpcyBvd25lciBkb2N1bWVudFxuICAgKi9cbiAgaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG4gICAgbGV0IGRvYyA9IHRoaXMubm9kZSBpbnN0YW5jZW9mIERvY3VtZW50ID8gdGhpcy5ub2RlIDpcbiAgICAgIHRoaXMubm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBkb2MuaW1wb3J0Tm9kZShub2RlLCBkZWVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIGFsbCBjaGlsZCBub2RlcyBhbmQgbm9kZXMgYXNzaWduZWRcbiAgICogdG8gY2hpbGQgc2xvdHMuXG4gICAqL1xuICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgIHJldHVybiBGbGF0dGVuZWROb2Rlc09ic2VydmVyLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMubm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZpbHRlcmVkIGxpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzIGZvciB0aGlzIGVsZW1lbnQgYmFzZWRcbiAgICogb24gdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gZmlsdGVyIG5vZGVzIGFnYWluc3RcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50c1xuICAgKi9cbiAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgbGV0IGMkID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgbGV0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpPTAsIGw9YyQubGVuZ3RoLCBjOyAoaTxsKSAmJiAoYz1jJFtpXSk7IGkrKykge1xuICAgICAgaWYgKChjLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiZcbiAgICAgICAgICBtYXRjaGVzU2VsZWN0b3IoYywgc2VsZWN0b3IpKSB7XG4gICAgICAgIGxpc3QucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHNoYWRvdyByb290cywgcmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB3aXRoaW4gdGhpc1xuICAgKiBzaGFkb3cgcm9vdC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IEN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICovXG4gIGdldCBhY3RpdmVFbGVtZW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5ub2RlO1xuICAgIHJldHVybiBub2RlLl9hY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBub2RlLl9hY3RpdmVFbGVtZW50IDogbm9kZS5hY3RpdmVFbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRNZXRob2RzKHByb3RvLCBtZXRob2RzKSB7XG4gIGZvciAobGV0IGk9MDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICBwcm90b1ttZXRob2RdID0gLyoqIEB0aGlzIHtEb21BcGl9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVttZXRob2RdLmFwcGx5KHRoaXMubm9kZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yd2FyZFByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mb3J3YXJkTWV0aG9kcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICdjbG9uZU5vZGUnLCAnYXBwZW5kQ2hpbGQnLCAnaW5zZXJ0QmVmb3JlJywgJ3JlbW92ZUNoaWxkJyxcbiAgJ3JlcGxhY2VDaGlsZCcsICdzZXRBdHRyaWJ1dGUnLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgJ3F1ZXJ5U2VsZWN0b3InLCAncXVlcnlTZWxlY3RvckFsbCdcbl0pO1xuXG5mb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgJ3BhcmVudE5vZGUnLCAnZmlyc3RDaGlsZCcsICdsYXN0Q2hpbGQnLFxuICAnbmV4dFNpYmxpbmcnLCAncHJldmlvdXNTaWJsaW5nJywgJ2ZpcnN0RWxlbWVudENoaWxkJyxcbiAgJ2xhc3RFbGVtZW50Q2hpbGQnLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnLFxuICAnY2hpbGROb2RlcycsICdjaGlsZHJlbicsICdjbGFzc0xpc3QnXG5dKTtcblxuZm9yd2FyZFByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJ1xuXSk7XG5cblxuLyoqXG4gKiBFdmVudCBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICogYHRhcmdldGAgaXMgYW4gYEV2ZW50YC5cbiAqL1xuY2xhc3MgRXZlbnRBcGkge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIG9uIHRoZSBgY29tcG9zZWRQYXRoYCBvZiB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZSB0aGlzIGV2ZW50IHdhcyBkaXNwYXRjaGVkIHRvXG4gICAqL1xuICBnZXQgcm9vdFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIGxvY2FsIChyZS10YXJnZXRlZCkgdGFyZ2V0IGZvciB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGxvY2FsVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgY29tcG9zZWRQYXRoYCBmb3IgdGhpcyBldmVudC5cbiAgICovXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydCB7IERvbUFwaSB9O1xuXG5leHBvcnQgY29uc3QgZG9tID0gZnVuY3Rpb24ob2JqKSB7XG4gIG9iaiA9IG9iaiB8fCBkb2N1bWVudDtcbiAgaWYgKCFvYmouX19kb21BcGkpIHtcbiAgICBsZXQgaGVscGVyO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgaGVscGVyID0gbmV3IEV2ZW50QXBpKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlbHBlciA9IG5ldyBEb21BcGkob2JqKTtcbiAgICB9XG4gICAgb2JqLl9fZG9tQXBpID0gaGVscGVyO1xuICB9XG4gIHJldHVybiBvYmouX19kb21BcGk7XG59O1xuXG5leHBvcnQgeyBtYXRjaGVzU2VsZWN0b3IgfTtcbmV4cG9ydCB7IGZsdXNoJDAgYXMgZmx1c2ggfTtcbmV4cG9ydCB7IGVucXVldWVEZWJvdW5jZXIgYXMgYWRkRGVib3VuY2VyIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ2JyaW5nVG9CYWNrJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoZSBGZWF0dXJlIEdyb3VwIChjcmVhdGVkIGZyb20gYm91bmRzIGFuZCBjb29yZGluYXRlcyBvZiBpdHMgY2hpbGRyZW4pLlxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVyczogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvRmVhdHVyZUdyb3VwLmpzIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBhdHRhY2ggbGlzdGVuZXIgKHdpdGhvdXQgc3ludGFjdGljIHN1Z2FyIG5vdylcclxuXHRfb246IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xyXG5cclxuXHRcdC8qIGdldC9pbml0IGxpc3RlbmVycyBmb3IgdHlwZSAqL1xyXG5cdFx0dmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIXR5cGVMaXN0ZW5lcnMpIHtcclxuXHRcdFx0dHlwZUxpc3RlbmVycyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0eXBlTGlzdGVuZXJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZXh0ID09PSB0aGlzKSB7XHJcblx0XHRcdC8vIExlc3MgbWVtb3J5IGZvb3RwcmludC5cclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdHZhciBuZXdMaXN0ZW5lciA9IHtmbjogZm4sIGN0eDogY29udGV4dH0sXHJcblx0XHQgICAgbGlzdGVuZXJzID0gdHlwZUxpc3RlbmVycztcclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuICYmIGxpc3RlbmVyc1tpXS5jdHggPT09IGNvbnRleHQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFmbikge1xyXG5cdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3Agc28gdGhleSBhcmUgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhIHR5cGUgaWYgZnVuY3Rpb24gaXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHJcblx0XHRcdC8vIGZpbmQgZm4gYW5kIHJlbW92ZSBpdFxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRpZiAobC5jdHggIT09IGNvbnRleHQpIHsgY29udGludWU7IH1cclxuXHRcdFx0XHRpZiAobC5mbiA9PT0gZm4pIHtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgdGhlIHJlbW92ZWQgbGlzdGVuZXIgdG8gbm9vcCBzbyB0aGF0J3Mgbm90IGNhbGxlZCBpZiByZW1vdmUgaGFwcGVucyBpbiBmaXJlXHJcblx0XHRcdFx0XHRsLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBVdGlsLmV4dGVuZCh7fSwgZGF0YSwge3R5cGU6IHR5cGUsIHRhcmdldDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudCA9ICh0aGlzLl9maXJpbmdDb3VudCArIDEpIHx8IDE7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0XHRsLmZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYSBwYXJ0aWN1bGFyIGV2ZW50IHR5cGUgaGFzIGFueSBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIHByb3BhZ2F0ZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAobGlzdGVuZXJzICYmIGxpc3RlbmVycy5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRpZiAocHJvcGFnYXRlKSB7XHJcblx0XHRcdC8vIGFsc28gY2hlY2sgcGFyZW50cyBmb3IgbGlzdGVuZXJzIGlmIGV2ZW50IHByb3BhZ2F0ZXNcclxuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50UGFyZW50c1tpZF0ubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9uY2Uo4oCmKTogdGhpc1xyXG5cdC8vIEJlaGF2ZXMgYXMgW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pLCBleGNlcHQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBnZXQgZmlyZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG5cdG9uY2U6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5vbmNlKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub2ZmKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGhhbmRsZXIsIGNvbnRleHQpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0Ly8gYWRkIGEgbGlzdGVuZXIgdGhhdCdzIGV4ZWN1dGVkIG9uY2UgYW5kIHJlbW92ZWQgYWZ0ZXIgdGhhdFxyXG5cdFx0cmV0dXJuIHRoaXNcclxuXHRcdCAgICAub24odHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0ICAgIC5vbih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV0gPSBvYmo7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBVdGlsLmV4dGVuZCh7bGF5ZXI6IGUudGFyZ2V0fSwgZSksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIGFsaWFzZXM7IHdlIHNob3VsZCBkaXRjaCB0aG9zZSBldmVudHVhbGx5XHJcblxyXG4vLyBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uKOKApilgXSgjZXZlbnRlZC1vbilcclxuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudHMub247XHJcblxyXG4vLyBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZijigKYpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5cclxuLy8gQG1ldGhvZCBjbGVhckFsbEV2ZW50TGlzdGVuZXJzKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYoKWBdKCNldmVudGVkLW9mZilcclxuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMuY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IEV2ZW50cy5vZmY7XHJcblxyXG4vLyBAbWV0aG9kIGFkZE9uZVRpbWVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbmNlKOKApilgXSgjZXZlbnRlZC1vbmNlKVxyXG5FdmVudHMuYWRkT25lVGltZUV2ZW50TGlzdGVuZXIgPSBFdmVudHMub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5FdmVudHMuZmlyZUV2ZW50ID0gRXZlbnRzLmZpcmU7XHJcblxyXG4vLyBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJzKOKApik6IEJvb2xlYW5cclxuLy8gQWxpYXMgdG8gW2BsaXN0ZW5zKOKApilgXSgjZXZlbnRlZC1saXN0ZW5zKVxyXG5FdmVudHMuaGFzRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMubGlzdGVucztcclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRlZCA9IENsYXNzLmV4dGVuZChFdmVudHMpO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvRXZlbnRzLmpzIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xyXG5cclxuLy8gQGNsYXNzIENsYXNzXHJcbi8vIEBha2EgTC5DbGFzc1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gQHVuaW5oZXJpdGFibGVcclxuXHJcbi8vIFRoYW5rcyB0byBKb2huIFJlc2lnIGFuZCBEZWFuIEVkd2FyZHMgZm9yIGluc3BpcmF0aW9uIVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENsYXNzKCkge31cclxuXHJcbkNsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZXh0ZW5kKHByb3BzOiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFtFeHRlbmRzIHRoZSBjdXJyZW50IGNsYXNzXSgjY2xhc3MtaW5oZXJpdGFuY2UpIGdpdmVuIHRoZSBwcm9wZXJ0aWVzIHRvIGJlIGluY2x1ZGVkLlxyXG5cdC8vIFJldHVybnMgYSBKYXZhc2NyaXB0IGZ1bmN0aW9uIHRoYXQgaXMgYSBjbGFzcyBjb25zdHJ1Y3RvciAodG8gYmUgY2FsbGVkIHdpdGggYG5ld2ApLlxyXG5cdHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJyAmJiBpICE9PSAnX19zdXBlcl9fJykge1xyXG5cdFx0XHROZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuXHRpZiAocHJvcHMuc3RhdGljcykge1xyXG5cdFx0VXRpbC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLnN0YXRpY3M7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm9wcy5vcHRpb25zID0gVXRpbC5leHRlbmQoVXRpbC5jcmVhdGUocHJvdG8ub3B0aW9ucyksIHByb3BzLm9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHJcblx0cHJvdG8uX2luaXRIb29rcyA9IFtdO1xyXG5cclxuXHQvLyBhZGQgbWV0aG9kIGZvciBjYWxsaW5nIGFsbCBob29rc1xyXG5cdHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAocGFyZW50UHJvdG8uY2FsbEluaXRIb29rcykge1xyXG5cdFx0XHRwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvdG8uX2luaXRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwcm90by5faW5pdEhvb2tzW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIEBmdW5jdGlvbiBpbmNsdWRlKHByb3BlcnRpZXM6IE9iamVjdCk6IHRoaXNcclxuLy8gW0luY2x1ZGVzIGEgbWl4aW5dKCNjbGFzcy1pbmNsdWRlcykgaW50byB0aGUgY3VycmVudCBjbGFzcy5cclxuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0VXRpbC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkSW5pdEhvb2soZm46IEZ1bmN0aW9uKTogdGhpc1xyXG4vLyBBZGRzIGEgW2NvbnN0cnVjdG9yIGhvb2tdKCNjbGFzcy1jb25zdHJ1Y3Rvci1ob29rcykgdG8gdGhlIGNsYXNzLlxyXG5DbGFzcy5hZGRJbml0SG9vayA9IGZ1bmN0aW9uIChmbikgeyAvLyAoRnVuY3Rpb24pIHx8IChTdHJpbmcsIGFyZ3MuLi4pXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cclxuXHR2YXIgaW5pdCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpc1tmbl0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcyA9IHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgfHwgW107XHJcblx0dGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGluaXQpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMoaW5jbHVkZXMpIHtcclxuXHRpZiAoIUwgfHwgIUwuTWl4aW4pIHsgcmV0dXJuOyB9XHJcblxyXG5cdGluY2x1ZGVzID0gVXRpbC5pc0FycmF5KGluY2x1ZGVzKSA/IGluY2x1ZGVzIDogW2luY2x1ZGVzXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmNsdWRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGluY2x1ZGVzW2ldID09PSBMLk1peGluLkV2ZW50cykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQgaW5jbHVkZSBvZiBMLk1peGluLkV2ZW50czogJyArXHJcblx0XHRcdFx0J3RoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgJyArXHJcblx0XHRcdFx0J3BsZWFzZSBpbmhlcml0IGZyb20gTC5FdmVudGVkIGluc3RlYWQuJywgbmV3IEVycm9yKCkuc3RhY2spO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQ2xhc3MuanMiLCJpbXBvcnQge1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXHJcbiAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjogYSBzZXQgb2YgY29lZmZpY2llbnRzIGBhYCwgYGJgLCBgY2AsIGBkYFxyXG4gKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IEwudHJhbnNmb3JtYXRpb24oMiwgNSwgLTEsIDEwKSxcclxuICogXHRwID0gTC5wb2ludCgxLCAyKSxcclxuICogXHRwMiA9IHRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShwKSwgLy8gIEwucG9pbnQoNywgOClcclxuICogXHRwMyA9IHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHAyKTsgLy8gIEwucG9pbnQoMSwgMilcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIGZhY3RvcnkgbmV3IEwuVHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBDcmVhdGVzIGEgYFRyYW5zZm9ybWF0aW9uYCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24oYSwgYiwgYywgZCkge1xyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkpIHtcclxuXHRcdC8vIHVzZSBhcnJheSBwcm9wZXJ0aWVzXHJcblx0XHR0aGlzLl9hID0gYVswXTtcclxuXHRcdHRoaXMuX2IgPSBhWzFdO1xyXG5cdFx0dGhpcy5fYyA9IGFbMl07XHJcblx0XHR0aGlzLl9kID0gYVszXTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn1cclxuXHJcblRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcblx0Ly8gT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkgeyAvLyAoUG9pbnQsIE51bWJlcikgLT4gUG9pbnRcclxuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm0ocG9pbnQuY2xvbmUoKSwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlc3RydWN0aXZlIHRyYW5zZm9ybSAoZmFzdGVyKVxyXG5cdF90cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHBvaW50LnggPSBzY2FsZSAqICh0aGlzLl9hICogcG9pbnQueCArIHRoaXMuX2IpO1xyXG5cdFx0cG9pbnQueSA9IHNjYWxlICogKHRoaXMuX2MgKiBwb2ludC55ICsgdGhpcy5fZCk7XHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCwgb3B0aW9uYWxseSBkaXZpZGVkXHJcblx0Ly8gYnkgdGhlIGdpdmVuIHNjYWxlLiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dW50cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHtcclxuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIGZhY3RvcnkgTC50cmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gSW5zdGFudGlhdGVzIGEgVHJhbnNmb3JtYXRpb24gb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGNvZWZmaWNpZW50czogQXJyYXkpOiBUcmFuc2Zvcm1hdGlvblxyXG4vLyBFeHBlY3RzIGFuIGNvZWZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uLmpzIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG91Y2h9IGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuZXhwb3J0IHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHBhdGggbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9CYWNrKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzXG5cdFx0dGhpcy5fcHJvamVjdCgpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9jbGlja1RvbGVyYW5jZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHVzZWQgd2hlbiBkb2luZyBoaXQgZGV0ZWN0aW9uIGZvciBDYW52YXMgbGF5ZXJzXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwKSArICh0b3VjaCA/IDEwIDogMCk7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvUGF0aC5qcyIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5aW5lIHBvaW50cyBwcm9jZXNzaW5nLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBtYWtlIHBvbHlsaW5lcyBsaWdodG5pbmctZmFzdC5cclxuICovXHJcblxyXG4vLyBTaW1wbGlmeSBwb2x5bGluZSB3aXRoIHZlcnRleCByZWR1Y3Rpb24gYW5kIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbi5cclxuLy8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcbi8vIEBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHM6IFBvaW50W10sIHRvbGVyYW5jZTogTnVtYmVyKTogUG9pbnRbXVxyXG4vLyBEcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvbHlsaW5lIHdoaWxlIHJldGFpbmluZ1xyXG4vLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG4vLyBbRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtKS5cclxuLy8gVXNlZCBmb3IgYSBodWdlIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gcHJvY2Vzc2luZy9kaXNwbGF5aW5nIExlYWZsZXQgcG9seWxpbmVzIGZvclxyXG4vLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcbi8vIHNpbXBsaWZpY2F0aW9uIChsZXNzZXIgdmFsdWUgbWVhbnMgaGlnaGVyIHF1YWxpdHkgYnV0IHNsb3dlciBhbmQgd2l0aCBtb3JlIHBvaW50cykuXHJcbi8vIEFsc28gcmVsZWFzZWQgYXMgYSBzZXBhcmF0ZWQgbWljcm8tbGlicmFyeSBbU2ltcGxpZnkuanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5jb20vc2ltcGxpZnktanMvKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XHJcblx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuXHR9XHJcblxyXG5cdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDE6IHZlcnRleCByZWR1Y3Rpb25cclxuXHQgICAgcG9pbnRzID0gX3JlZHVjZVBvaW50cyhwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0ICAgIC8vIHN0YWdlIDI6IERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvblxyXG5cdCAgICBwb2ludHMgPSBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKTtcclxuXHJcblx0cmV0dXJuIHBvaW50cztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgYHBgIGFuZCBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIE1hdGguc3FydChfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCB0cnVlKSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcG9pbnQgZnJvbSBhIHBvaW50IGBwYCBvbiBhIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxufVxyXG5cclxuLy8gRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9MaW5lVXRpbC5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxubGV0IENTU19VUkxfUlggPSAvKHVybFxcKCkoW14pXSopKFxcKSkvZztcbmxldCBBQlNfVVJMID0gLyheXFwvKXwoXiMpfCheW1xcdy1cXGRdKjopLztcbmxldCB3b3JraW5nVVJMO1xubGV0IHJlc29sdmVEb2M7XG4vKipcbiAqIFJlc29sdmVzIHRoZSBnaXZlbiBVUkwgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYGJhc2VVcmknLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHJlc29sdmVcbiAqIEBwYXJhbSB7P3N0cmluZz19IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgVVJMXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVVcmwodXJsLCBiYXNlVVJJKSB7XG4gIGlmICh1cmwgJiYgQUJTX1VSTC50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIExhenkgZmVhdHVyZSBkZXRlY3Rpb24uXG4gIGlmICh3b3JraW5nVVJMID09PSB1bmRlZmluZWQpIHtcbiAgICB3b3JraW5nVVJMID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICB1LnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgICAgIHdvcmtpbmdVUkwgPSAodS5ocmVmID09PSAnaHR0cDovL2EvYyUyMGQnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBmYWlsXG4gICAgfVxuICB9XG4gIGlmICghYmFzZVVSSSkge1xuICAgIGJhc2VVUkkgPSBkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG4gIGlmICh3b3JraW5nVVJMKSB7XG4gICAgcmV0dXJuIChuZXcgVVJMKHVybCwgYmFzZVVSSSkpLmhyZWY7XG4gIH1cbiAgLy8gRmFsbGJhY2sgdG8gY3JlYXRpbmcgYW4gYW5jaG9yIGludG8gYSBkaXNjb25uZWN0ZWQgZG9jdW1lbnQuXG4gIGlmICghcmVzb2x2ZURvYykge1xuICAgIHJlc29sdmVEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3RlbXAnKTtcbiAgICByZXNvbHZlRG9jLmJhc2UgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICByZXNvbHZlRG9jLmhlYWQuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5iYXNlKTtcbiAgICByZXNvbHZlRG9jLmFuY2hvciA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHJlc29sdmVEb2MuYm9keS5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmFuY2hvcik7XG4gIH1cbiAgcmVzb2x2ZURvYy5iYXNlLmhyZWYgPSBiYXNlVVJJO1xuICByZXNvbHZlRG9jLmFuY2hvci5ocmVmID0gdXJsO1xuICByZXR1cm4gcmVzb2x2ZURvYy5hbmNob3IuaHJlZiB8fCB1cmw7XG5cbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhbnkgcmVsYXRpdmUgVVJMJ3MgaW4gdGhlIGdpdmVuIENTUyB0ZXh0IGFnYWluc3QgdGhlIHByb3ZpZGVkXG4gKiBgb3duZXJEb2N1bWVudGAncyBgYmFzZVVSSWAuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHQgQ1NTIHRleHQgdG8gcHJvY2Vzc1xuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAqIEByZXR1cm4ge3N0cmluZ30gUHJvY2Vzc2VkIENTUyB0ZXh0IHdpdGggcmVzb2x2ZWQgVVJMJ3NcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNzcyhjc3NUZXh0LCBiYXNlVVJJKSB7XG4gIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoQ1NTX1VSTF9SWCwgZnVuY3Rpb24obSwgcHJlLCB1cmwsIHBvc3QpIHtcbiAgICByZXR1cm4gcHJlICsgJ1xcJycgK1xuICAgICAgcmVzb2x2ZVVybCh1cmwucmVwbGFjZSgvW1wiJ10vZywgJycpLCBiYXNlVVJJKSArXG4gICAgICAnXFwnJyArIHBvc3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIGZyb20gYSBnaXZlbiBgdXJsYC4gVGhlIHBhdGggaW5jbHVkZXMgdGhlIHRyYWlsaW5nXG4gKiBgL2AgZnJvbSB0aGUgdXJsLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHRyYW5zZm9ybVxuICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHBhdGhGcm9tVXJsKHVybCkge1xuICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQ3NzIH07XG5leHBvcnQgeyByZXNvbHZlVXJsIH07XG5leHBvcnQgeyBwYXRoRnJvbVVybCB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmluZGV4T2YoJy4nKSA+PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm9vdChwYXRoKSB7XG4gIGxldCBkb3RJbmRleCA9IHBhdGguaW5kZXhPZignLicpO1xuICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZG90SW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB7XG4gIC8vICAgICBiYXNlLnN0YXJ0c1dpdGgocGF0aCArICcuJyk7XG4gIHJldHVybiBiYXNlLmluZGV4T2YocGF0aCArICcuJykgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgcGF0aC5zdGFydHNXaXRoKGJhc2UgKyAnLicpO1xuICByZXR1cm4gcGF0aC5pbmRleE9mKGJhc2UgKyAnLicpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKGJhc2UsIG5ld0Jhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIG5ld0Jhc2UgKyBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoYmFzZSwgcGF0aCkge1xuICByZXR1cm4gKGJhc2UgPT09IHBhdGgpIHx8XG4gICAgICAgICBpc0FuY2VzdG9yKGJhc2UsIHBhdGgpIHx8XG4gICAgICAgICBpc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXJncyA9IHBhdGhbaV0udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaj0wOyBqPGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhcmdzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXQocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemUocGF0aCkuc3BsaXQoJy4nKTtcbiAgfVxuICByZXR1cm4gcGF0aC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQocm9vdCwgcGF0aCwgaW5mbykge1xuICBsZXQgcHJvcCA9IHJvb3Q7XG4gIGxldCBwYXJ0cyA9IHNwbGl0KHBhdGgpO1xuICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTFdIGFuZCBkZXJlZmVyZW5jZVxuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgfVxuICBpZiAoaW5mbykge1xuICAgIGluZm8ucGF0aCA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgfVxuICByZXR1cm4gcHJvcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChyb290LCBwYXRoLCB2YWx1ZSkge1xuICBsZXQgcHJvcCA9IHJvb3Q7XG4gIGxldCBwYXJ0cyA9IHNwbGl0KHBhdGgpO1xuICBsZXQgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTJdIGFuZCBkZXJlZmVyZW5jZVxuICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgcHJvcCA9IHByb3BbcGFydF07XG4gICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgdmFsdWUgdG8gb2JqZWN0IGF0IGVuZCBvZiBwYXRoXG4gICAgcHJvcFtsYXN0XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFNpbXBsZSBwcm9wZXJ0eSBzZXRcbiAgICBwcm9wW3BhdGhdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRGVlcCA9IGlzUGF0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcGF0aC5qcyIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCAnLi9taXhpbi5qcyc7XG5pbXBvcnQgJy4vYXN5bmMuanMnO1xuXG4vKiogQHR5cGVkZWYge3tydW46IGZ1bmN0aW9uKGZ1bmN0aW9uKCksIG51bWJlcj0pOm51bWJlciwgY2FuY2VsOiBmdW5jdGlvbihudW1iZXIpfX0gKi9cbmxldCBBc3luY01vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEBzdW1tYXJ5IENvbGxhcHNlIG11bHRpcGxlIGNhbGxiYWNrcyBpbnRvIG9uZSBpbnZvY2F0aW9uIGFmdGVyIGEgdGltZXIuXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5jbGFzcyBEZWJvdW5jZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9hc3luY01vZHVsZSA9IG51bGw7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NoZWR1bGVyOyB0aGF0IGlzLCBhIG1vZHVsZSB3aXRoIHRoZSBBc3luYyBpbnRlcmZhY2UsXG4gICAqIGEgY2FsbGJhY2sgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIHJ1biBmdW5jdGlvblxuICAgKiBmcm9tIHRoZSBhc3luYyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IUFzeW5jTW9kdWxlfSBhc3luY01vZHVsZSBPYmplY3Qgd2l0aCBBc3luYyBpbnRlcmZhY2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuLlxuICAgKi9cbiAgc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gYXN5bmNNb2R1bGU7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lciA9IHRoaXMuX2FzeW5jTW9kdWxlLnJ1bigoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX2FzeW5jTW9kdWxlLmNhbmNlbCh0aGlzLl90aW1lcik7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGbHVzaGVzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVyICE9IG51bGw7XG4gIH1cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlciBpZiBubyBkZWJvdW5jZXIgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gKiBvciBpdCBjYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgb3RoZXJ3aXNlLiBUaGUgZm9sbG93aW5nXG4gKiBleGFtcGxlIHNob3dzIGhvdyBhIGRlYm91bmNlciBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhXG4gKiBtaWNyb3Rhc2sgYW5kIFwiZGVib3VuY2VkXCIgc3VjaCB0aGF0IHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBpc1xuICogY2FsbGVkIG9uY2UuIEFkZCB0aGlzIG1ldGhvZCB0byBhIGN1c3RvbSBlbGVtZW50OlxuICpcbiAqIF9kZWJvdW5jZVdvcmsoKSB7XG4gKiAgIHRoaXMuX2RlYm91bmNlSm9iID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UodGhpcy5fZGVib3VuY2VKb2IsXG4gKiAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaywgKCkgPT4ge1xuICogICAgIHRoaXMuX2RvV29yaygpO1xuICogICB9KTtcbiAqIH1cbiAqXG4gKiBJZiB0aGUgYF9kZWJvdW5jZVdvcmtgIG1ldGhvZCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lXG4gKiBtaWNyb3Rhc2ssIHRoZSBgX2RvV29ya2AgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGF0IHRoZSBuZXh0XG4gKiBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAqXG4gKiBOb3RlOiBJbiB0ZXN0aW5nIGl0IGlzIG9mdGVuIGNvbnZlbmllbnQgdG8gYXZvaWQgYXN5bmNocm9ueS4gVG8gYWNjb21wbGlzaFxuICogdGhpcyB3aXRoIGEgZGVib3VuY2VyLCB5b3UgY2FuIHVzZSBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYCBhbmRcbiAqIGBQb2x5bWVyLmZsdXNoYC4gRm9yIGV4YW1wbGUsIGV4dGVuZCB0aGUgYWJvdmUgZXhhbXBsZSBieSBhZGRpbmdcbiAqIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fZGVib3VuY2VKb2IpYCBhdCB0aGUgZW5kIG9mIHRoZVxuICogYF9kZWJvdW5jZVdvcmtgIG1ldGhvZC4gVGhlbiBpbiBhIHRlc3QsIGNhbGwgYFBvbHltZXIuZmx1c2hgIHRvIGVuc3VyZVxuICogdGhlIGRlYm91bmNlciBoYXMgY29tcGxldGVkLlxuICpcbiAqIEBwYXJhbSB7RGVib3VuY2VyP30gZGVib3VuY2VyIERlYm91bmNlciBvYmplY3QuXG4gKiBAcGFyYW0geyFBc3luY01vZHVsZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAqIEByZXR1cm4geyFEZWJvdW5jZXJ9IFJldHVybnMgYSBkZWJvdW5jZXIgb2JqZWN0LlxuICovXG4gIHN0YXRpYyBkZWJvdW5jZShkZWJvdW5jZXIsIGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgIGlmIChkZWJvdW5jZXIgaW5zdGFuY2VvZiBEZWJvdW5jZXIpIHtcbiAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVib3VuY2VyID0gbmV3IERlYm91bmNlcigpO1xuICAgIH1cbiAgICBkZWJvdW5jZXIuc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIGRlYm91bmNlcjtcbiAgfVxufVxuXG5leHBvcnQgeyBEZWJvdW5jZXIgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZGVib3VuY2UuanMiLCJpbXBvcnQgeyBDbGFzcyB9IGZyb20gJy4vY2xhc3MuanMnO1xuXG5leHBvcnQgY29uc3QgUG9seW1lciA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgLy8gaWYgaW5wdXQgaXMgYSBgY2xhc3NgIChha2EgYSBmdW5jdGlvbiB3aXRoIGEgcHJvdG90eXBlKSwgdXNlIHRoZSBwcm90b3R5cGVcbiAgLy8gcmVtZW1iZXIgdGhhdCB0aGUgYGNvbnN0cnVjdG9yYCB3aWxsIG5ldmVyIGJlIGNhbGxlZFxuICBsZXQga2xhc3M7XG4gIGlmICh0eXBlb2YgaW5mbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGtsYXNzID0gaW5mbztcbiAgfSBlbHNlIHtcbiAgICBrbGFzcyA9IENsYXNzKGluZm8pO1xuICB9XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShrbGFzcy5pcywgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKGtsYXNzKSk7XG4gIHJldHVybiBrbGFzcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzIiwiaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcblxuLy8gQ29tbW9uIGltcGxlbWVudGF0aW9uIGZvciBtaXhpbiAmIGJlaGF2aW9yXG5mdW5jdGlvbiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UoaW5zdCwgcHJvcGVydHksIHZhbHVlLCBvbGQsIG11dGFibGVEYXRhKSB7XG4gIGxldCBpc09iamVjdDtcbiAgaWYgKG11dGFibGVEYXRhKSB7XG4gICAgaXNPYmplY3QgPSAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCk7XG4gICAgLy8gUHVsbCBgb2xkYCBmb3IgT2JqZWN0cyBmcm9tIHRlbXAgY2FjaGUsIGJ1dCB0cmVhdCBgbnVsbGAgYXMgYSBwcmltaXRpdmVcbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIG9sZCA9IGluc3QuX19kYXRhVGVtcFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIC8vIFN0cmljdCBlcXVhbGl0eSBjaGVjaywgYnV0IHJldHVybiBmYWxzZSBmb3IgTmFOPT09TmFOXG4gIGxldCBzaG91bGRDaGFuZ2UgPSAob2xkICE9PSB2YWx1ZSAmJiAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSk7XG4gIC8vIE9iamVjdHMgYXJlIHN0b3JlZCBpbiB0ZW1wb3JhcnkgY2FjaGUgKGNsZWFyZWQgYXQgZW5kIG9mXG4gIC8vIHR1cm4pLCB3aGljaCBpcyB1c2VkIGZvciBkaXJ0eS1jaGVja2luZ1xuICBpZiAoaXNPYmplY3QgJiYgc2hvdWxkQ2hhbmdlKSB7XG4gICAgaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBzaG91bGRDaGFuZ2U7XG59XG5cbmV4cG9ydCBjb25zdCBNdXRhYmxlRGF0YSA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICAgKi9cbiAgY2xhc3MgTXV0YWJsZURhdGEgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgICAqIGNhY2hlIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0cnVlKTtcbiAgICB9XG5cbiAgfVxuICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gIE11dGFibGVEYXRhLnByb3RvdHlwZS5tdXRhYmxlRGF0YSA9IGZhbHNlO1xuXG4gIHJldHVybiBNdXRhYmxlRGF0YTtcblxufSk7XG5cbmV4cG9ydCBjb25zdCBPcHRpb25hbE11dGFibGVEYXRhID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQG1peGluQ2xhc3NcbiAgICogQHBvbHltZXJcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAgICovXG4gIGNsYXNzIE9wdGlvbmFsTXV0YWJsZURhdGEgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW5jZS1sZXZlbCBmbGFnIGZvciBjb25maWd1cmluZyB0aGUgZGlydHktY2hlY2tpbmcgc3RyYXRlZ3lcbiAgICAgICAgICogZm9yIHRoaXMgZWxlbWVudC4gIFdoZW4gdHJ1ZSwgT2JqZWN0cyBhbmQgQXJyYXlzIHdpbGwgc2tpcCBkaXJ0eVxuICAgICAgICAgKiBjaGVja2luZywgb3RoZXJ3aXNlIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBtdXRhYmxlRGF0YTogQm9vbGVhblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICAgKlxuICAgICAqIFdoZW4gYHRoaXMubXV0YWJsZURhdGFgIGlzIHRydWUgb24gdGhpcyBpbnN0YW5jZSwgdGhpcyBtZXRob2RcbiAgICAgKiBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGAgY2FjaGVcbiAgICAgKiAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9wdGlvbmFsTXV0YWJsZURhdGE7XG5cbn0pO1xuXG4vLyBFeHBvcnQgZm9yIHVzZSBieSBsZWdhY3kgYmVoYXZpb3Jcbk11dGFibGVEYXRhLl9tdXRhYmxlUHJvcGVydHlDaGFuZ2UgPSBtdXRhYmxlUHJvcGVydHlDaGFuZ2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9tdXRhYmxlLWRhdGEuanMiLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuLi8uLi9jb3JlL0NsYXNzJztcclxuaW1wb3J0IHtzZXRPcHRpb25zfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0IHtyZXRpbmF9IGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgSWNvblxyXG4gKiBAYWthIEwuSWNvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJY29uID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEljb24gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogKioocmVxdWlyZWQpKiogVGhlIFVSTCB0byB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91ciBzY3JpcHQgcGF0aCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25SZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIGEgcmV0aW5hIHNpemVkIHZlcnNpb24gb2YgdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXJcclxuXHQgKiBzY3JpcHQgcGF0aCkuIFVzZWQgZm9yIFJldGluYSBzY3JlZW4gZGV2aWNlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblNpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIGljb24gaW1hZ2UgaW4gcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uQW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBUaGUgaWNvblxyXG5cdCAqIHdpbGwgYmUgYWxpZ25lZCBzbyB0aGF0IHRoaXMgcG9pbnQgaXMgYXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi4gQ2VudGVyZWRcclxuXHQgKiBieSBkZWZhdWx0IGlmIHNpemUgaXMgc3BlY2lmaWVkLCBhbHNvIGNhbiBiZSBzZXQgaW4gQ1NTIHdpdGggbmVnYXRpdmUgbWFyZ2lucy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9wdXBBbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiBUaGUgVVJMIHRvIHRoZSBpY29uIHNoYWRvdyBpbWFnZS4gSWYgbm90IHNwZWNpZmllZCwgbm8gc2hhZG93IGltYWdlIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93UmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1NpemU6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFNpemUgb2YgdGhlIHNoYWRvdyBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd0FuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBzaGFkb3cgKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpICh0aGUgc2FtZVxyXG5cdCAqIGFzIGljb25BbmNob3IgaWYgbm90IHNwZWNpZmllZCkuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHQgKiBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byBib3RoIGljb24gYW5kIHNoYWRvdyBpbWFnZXMuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRzZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlSWNvbihvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGljb24gaGFzIHRvIGJlIHNob3duLCByZXR1cm5zIGEgYDxpbWc+YCBIVE1MIGVsZW1lbnRcclxuXHQvLyBzdHlsZWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zLlxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlU2hhZG93KG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQXMgYGNyZWF0ZUljb25gLCBidXQgZm9yIHRoZSBzaGFkb3cgYmVuZWF0aCBpdC5cclxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignc2hhZG93Jywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUljb246IGZ1bmN0aW9uIChuYW1lLCBvbGRJY29uKSB7XHJcblx0XHR2YXIgc3JjID0gdGhpcy5fZ2V0SWNvblVybChuYW1lKTtcclxuXHJcblx0XHRpZiAoIXNyYykge1xyXG5cdFx0XHRpZiAobmFtZSA9PT0gJ2ljb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdpY29uVXJsIG5vdCBzZXQgaW4gSWNvbiBvcHRpb25zIChzZWUgdGhlIGRvY3MpLicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbWcgPSB0aGlzLl9jcmVhdGVJbWcoc3JjLCBvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0lNRycgPyBvbGRJY29uIDogbnVsbCk7XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gcG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gcG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiByZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGljb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSWNvbihvcHRpb25zKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLmpzIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG5cbi8qXG4gKiBAY2xhc3MgUmVuZGVyZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLlJlbmRlcmVyXG4gKlxuICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIHJlbmRlcmVyIGltcGxlbWVudGF0aW9ucyAoYFNWR2AsIGBDYW52YXNgKS4gSGFuZGxlcyB0aGVcbiAqIERPTSBjb250YWluZXIgb2YgdGhlIHJlbmRlcmVyLCBpdHMgYm91bmRzLCBhbmQgaXRzIHpvb20gYW5pbWF0aW9uLlxuICpcbiAqIEEgYFJlbmRlcmVyYCB3b3JrcyBhcyBhbiBpbXBsaWNpdCBsYXllciBncm91cCBmb3IgYWxsIGBQYXRoYHMgLSB0aGUgcmVuZGVyZXJcbiAqIGl0c2VsZiBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCB0byB0aGUgbWFwLiBBbGwgcGF0aHMgdXNlIGEgcmVuZGVyZXIsIHdoaWNoIGNhblxuICogYmUgaW1wbGljaXQgKHRoZSBtYXAgd2lsbCBkZWNpZGUgdGhlIHR5cGUgb2YgcmVuZGVyZXIgYW5kIHVzZSBpdCBhdXRvbWF0aWNhbGx5KVxuICogb3IgZXhwbGljaXQgKHVzaW5nIHRoZSBbYHJlbmRlcmVyYF0oI3BhdGgtcmVuZGVyZXIpIG9wdGlvbiBvZiB0aGUgcGF0aCkuXG4gKlxuICogRG8gbm90IHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgYFNWR2AgYW5kIGBDYW52YXNgIGluc3RlYWQuXG4gKlxuICogQGV2ZW50IHVwZGF0ZTogRXZlbnRcbiAqIEZpcmVkIHdoZW4gdGhlIHJlbmRlcmVyIHVwZGF0ZXMgaXRzIGJvdW5kcywgY2VudGVyIGFuZCB6b29tLCBmb3IgZXhhbXBsZSB3aGVuXG4gKiBpdHMgbWFwIGhhcyBtb3ZlZFxuICovXG5cbmV4cG9ydCB2YXIgUmVuZGVyZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcblx0XHQvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cblx0XHRwYWRkaW5nOiAwLjFcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRVdGlsLnN0YW1wKHRoaXMpO1xuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmpzIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge2xhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fSxcblxuXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuXHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyByb290UGF0aCBhcyByb290UGF0aCQwIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCAqIGFzIGNhc2VNYXAkMCBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjYW1lbFRvRGFzaENhc2UgfSBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjc3NGcm9tTW9kdWxlSW1wb3J0cywgY3NzRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmpzJztcbmltcG9ydCB7IHJlc29sdmVVcmwgYXMgcmVzb2x2ZVVybCQwIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuaW1wb3J0IHsgRG9tTW9kdWxlIH0gZnJvbSAnLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuXG5leHBvcnQgY29uc3QgRWxlbWVudE1peGluID0gZGVkdXBpbmdNaXhpbihiYXNlID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqL1xuICBjb25zdCBwb2x5bWVyRWxlbWVudEJhc2UgPSBQcm9wZXJ0eUVmZmVjdHMoYmFzZSk7XG5cbiAgbGV0IGNhc2VNYXAgPSBjYXNlTWFwJDA7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBwcm9wZXJ0aWVzYCBvYmplY3Qgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3I6XG4gICAqICgxKSBzdXBlciBjaGFpbiBtaXhlcyB0b2d0aGVyIHRvIG1ha2UgYHByb3BlcnRpZXNGb3JDbGFzc2Agd2hpY2ggaXNcbiAgICogdGhlbiB1c2VkIHRvIG1ha2UgYG9ic2VydmVkQXR0cmlidXRlc2AuXG4gICAqICgyKSBwcm9wZXJ0aWVzIGVmZmVjdHMgYW5kIG9ic2VydmVycyBhcmUgY3JlYXRlZCBmcm9tIGl0IGF0IGBmaW5hbGl6ZWAgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIG93biBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25Qcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAga2xhc3MuX19vd25Qcm9wZXJ0aWVzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgncHJvcGVydGllcycsIGtsYXNzKSkgP1xuICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3BlcnRpZXMgOiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fb3duUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgb2JzZXJ2ZXJzYCBhcnJheSBzcGVjaWZpY2FsbHkgb24gYGtsYXNzYC4gVXNlIGZvclxuICAgKiBzZXR0aW5nIHVwIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBvd24gb2JzZXJ2ZXJzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293bk9ic2VydmVycycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fb3duT2JzZXJ2ZXJzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnb2JzZXJ2ZXJzJywga2xhc3MpKSA/XG4gICAgICAgIC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykub2JzZXJ2ZXJzIDogW107XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX293bk9ic2VydmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXhlcyBgcHJvcHNgIGludG8gYGZsYXR0ZW5lZFByb3BzYCBidXQgdXBncmFkZXMgc2hvcnRoYW5kIHR5cGVcbiAgICogc3ludGF4IHRvIHsgdHlwZTogVHlwZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmbGF0dGVuZWRQcm9wcyBCYWcgdG8gY29sbGVjdCBmbGF0dGVuZWQgcHJvcGVydGllcyBpbnRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBhZGQgdG8gYGZsYXR0ZW5lZFByb3BzYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnB1dCBgZmxhdHRlbmVkUHJvcHNgIGJhZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmxhdHRlblByb3BlcnRpZXMoZmxhdHRlbmVkUHJvcHMsIHByb3BzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgbGV0IG8gPSBwcm9wc1twXTtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7IHR5cGU6IG8gfTtcbiAgICAgIH1cbiAgICAgIGZsYXR0ZW5lZFByb3BzW3BdID0gbztcbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFByb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmbGF0dGVuZWQgbGlzdCBvZiBwcm9wZXJ0aWVzIG1peGVkIHRvZ2V0aGVyIGZyb20gdGhlIGNoYWluIG9mIGFsbFxuICAgKiBjb25zdHJ1Y3RvcidzIGBjb25maWcucHJvcGVydGllc2AuIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGNyZWF0ZVxuICAgKiAoMSkgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgKiAoMikgY2xhc3MgcHJvcGVydHkgZGVmYXVsdCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge1BvbHltZXJFbGVtZW50UHJvcGVydGllc30gRmxhdHRlbmVkIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBhIHByb3BlcnR5IGZvciBzb21lIHJlYXNvbj9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2NsYXNzUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID1cbiAgICAgIGZsYXR0ZW5Qcm9wZXJ0aWVzKHt9LCBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpKTtcbiAgICAgIGxldCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2xhc3MucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUocHJvcGVydGllc0ZvckNsYXNzKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovKHN1cGVyQ3RvcikpKSxcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAqIFRoaXMgbGlzdCBpcyBjcmVhdGVkIGFzIGFuIG9wdGltaXphdGlvbiBzaW5jZSBpdCBpcyBhIHN1YnNldCBvZlxuICAgKiB0aGUgbGlzdCByZXR1cm5lZCBmcm9tIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgLlxuICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBpbiBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCB0byBzZXQgcHJvcGVydHkgZGVmYXVsdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqICAgdGhhdCBoYXZlIGRlZmF1bHQgdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyA9IG51bGw7XG4gICAgICBsZXQgcHJvcHMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICBsZXQgaW5mbyA9IHByb3BzW3BdO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBpbmZvKSB7XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0c1twXSA9IGluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGBrbGFzc2AgaGFzIGZpbmFsaXplZC4gQ2FsbGVkIGluIGBFbGVtZW50Q2xhc3MuZmluYWxpemUoKWBcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIG1ldGFwcm9ncmFtbWluZyBmb3IgdGhpcyBjbGFzcyBoYXMgYmVlblxuICAgKiAgIGNvbXBsZXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzQ2xhc3NGaW5hbGl6ZWQoa2xhc3MpIHtcbiAgICByZXR1cm4ga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19maW5hbGl6ZWQnLCBrbGFzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgLiBFbnN1cmVzIHRoaXMgYGtsYXNzYCBhbmRcbiAgICogKmFsbCBzdXBlcmNsYXNzZXMqIGFyZSBmaW5hbGl6ZWQgYnkgdHJhdmVyc2luZyB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAqIGFuZCBjYWxsaW5nIGBrbGFzcy5maW5hbGl6ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIoa2xhc3MpIHtcbiAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICB9XG4gICAgZmluYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhIGBrbGFzc2AgYmFzZWQgb24gYSBzdGFpYyBga2xhc3MuY29uZmlnYCBvYmplY3QgYW5kXG4gICAqIGEgYHRlbXBsYXRlYC4gVGhpcyBpbmNsdWRlcyBjcmVhdGluZyBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogZm9yIHByb3BlcnRpZXMgaW4gYGNvbmZpZ2AgYW5kIHRoZSBgdGVtcGxhdGVgIGFzIHdlbGwgYXMgcHJlcGFyaW5nIHRoZVxuICAgKiBgdGVtcGxhdGVgIGZvciBzdGFtcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzKGtsYXNzKSB7XG4gICAga2xhc3MuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgIGxldCBwcm90byA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvdG90eXBlO1xuICAgIGlmIChrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2lzJywga2xhc3MpKSAmJiBrbGFzcy5pcykge1xuICAgICAgcmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cbiAgICBsZXQgcHJvcHMgPSBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wcyk7XG4gICAgfVxuICAgIGxldCBvYnNlcnZlcnMgPSBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcyk7XG4gICAgaWYgKG9ic2VydmVycykge1xuICAgICAgZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgcHJvcHMpO1xuICAgIH1cbiAgICAvLyBub3RlOiBjcmVhdGUgXCJ3b3JraW5nXCIgdGVtcGxhdGUgdGhhdCBpcyBmaW5hbGl6ZWQgYXQgaW5zdGFuY2UgdGltZVxuICAgIGxldCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHQuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgICAgIHRlbXBsYXRlID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfVxuICAgICAgcHJvdG8uX3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYHByb3BlcnRpZXNgIG9iamVjdC5cbiAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogc3VwcG9ydGluZywgb2JzZXJ2ZXJzLCByZWZsZWN0aW5nIHRvIGF0dHJpYnV0ZXMsIGNoYW5nZSBub3RpZmljYXRpb24sXG4gICAqIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCByZWFkIG9ubHkgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgICBhbmQgZWZmZWN0cyB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBGbGF0dGVuZWQgYmFnIG9mIHByb3BlcnR5IGRlc2NyaXB0b3JzIGZvclxuICAgKiAgICB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgcCwgcHJvcGVydGllc1twXSwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYG9ic2VydmVyc2AgYXJyYXkuXG4gICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgb2JzZXJ2ZXJzLlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVycyBGbGF0dGVuZWQgYXJyYXkgb2Ygb2JzZXJ2ZXIgZGVzY3JpcHRvcnMgZm9yXG4gICAqICAgdGhpcyBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZHluYW1pY0ZucyBPYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBhbnkgcHJvcGVydGllc1xuICAgKiAgIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdCB3aGVuIHRoZSBmdW5jdGlvblxuICAgKiAgIHJlZmVyZW5jZSBpcyBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZU9ic2VydmVycyhwcm90bywgb2JzZXJ2ZXJzLCBkeW5hbWljRm5zKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgb2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm90by5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIob2JzZXJ2ZXJzW2ldLCBkeW5hbWljRm5zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBlZmZlY3RzIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBOb3RlLCBvbmNlIGEgcHJvcGVydHkgaGFzIGJlZW4gc2V0IHRvXG4gICAqIGByZWFkT25seWAsIGBjb21wdXRlZGAsIGByZWZsZWN0VG9BdHRyaWJ1dGVgLCBvciBgbm90aWZ5YFxuICAgKiB0aGVzZSB2YWx1ZXMgbWF5IG5vdCBiZSBjaGFuZ2VkLiBGb3IgZXhhbXBsZSwgYSBzdWJjbGFzcyBjYW5ub3RcbiAgICogYWx0ZXIgdGhlc2Ugc2V0dGluZ3MuIEhvd2V2ZXIsIGFkZGl0aW9uYWwgYG9ic2VydmVyc2AgbWF5IGJlIGFkZGVkXG4gICAqIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIFRoZSBpbmZvIG9iamVjdCBzaG91bGQgbWF5IGNvbnRhaW4gcHJvcGVydHkgbWV0YWRhdGEgYXMgZm9sbG93czpcbiAgICpcbiAgICogKiBgdHlwZWA6IHtmdW5jdGlvbn0gdHlwZSB0byB3aGljaCBhbiBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIHByb3BlcnR5XG4gICAqIGlzIGRlc2VyaWFsaXplZC4gTm90ZSB0aGUgcHJvcGVydHkgaXMgY2FtZWwtY2FzZWQgZnJvbSBhIGRhc2gtY2FzZWRcbiAgICogYXR0cmlidXRlLiBGb3IgZXhhbXBsZSwgJ2Zvby1iYXInIGF0dHJpYnV0ZSBpcyBkZXJzaWFsaXplZCB0byBhXG4gICAqIHByb3BlcnR5IG5hbWVkICdmb29CYXInLlxuICAgKlxuICAgKiAqIGByZWFkT25seWA6IHtib29sZWFufSBjcmVhdGVzIGEgcmVhZE9ubHkgcHJvcGVydHkgYW5kXG4gICAqIG1ha2VzIGEgcHJpdmF0ZSBzZXR0ZXIgZm9yIHRoZSBwcml2YXRlIG9mIHRoZSBmb3JtICdfc2V0Rm9vJyBmb3IgYVxuICAgKiBwcm9wZXJ0eSAnZm9vJyxcbiAgICpcbiAgICogKiBgY29tcHV0ZWRgOiB7c3RyaW5nfSBjcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkuIEEgY29tcHV0ZWQgcHJvcGVydHlcbiAgICogYWxzbyBhdXRvbWF0aWNhbGx5IGlzIHNldCB0byBgcmVhZE9ubHk6IHRydWVgLiBUaGUgdmFsdWUgaXMgY2FsY3VsYXRlZFxuICAgKiBieSBydW5uaW5nIGEgbWV0aG9kIGFuZCBhcmd1bWVudHMgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gRm9yXG4gICAqIGV4YW1wbGUgJ2NvbXB1dGUoZm9vKScgd2lsbCBjb21wdXRlIGEgZ2l2ZW4gcHJvcGVydHkgd2hlbiB0aGVcbiAgICogJ2ZvbycgcHJvcGVydHkgY2hhbmdlcyBieSBleGVjdXRpbmcgdGhlICdjb21wdXRlJyBtZXRob2QuIFRoaXMgbWV0aG9kXG4gICAqIG11c3QgcmV0dXJuIHRoZSBjb21wdXRlZCB2YWx1ZS5cbiAgICpcbiAgICogKiBgcmVmbGVjdFRvQXR0cml1dGVgOiB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlZmxlY3RlZFxuICAgKiB0byBhbiBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS4gTm90ZSwgdGhlIGF0dHJpYnV0ZSBpcyBkYXNoLWNhc2VkXG4gICAqIHNvIGEgcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicgaXMgcmVmbGVjdGVkIGFzICdmb28tYmFyJy5cbiAgICpcbiAgICogKiBgbm90aWZ5YDoge2Jvb2xlYW59IHNlbmRzIGEgbm9uLWJ1YmJsaW5nIG5vdGlmaWNhdGlvbiBldmVudCB3aGVuXG4gICAqIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSBwcm9wZXJ0eSBuYW1lZCAnZm9vJyBzZW5kcyBhblxuICAgKiBldmVudCBuYW1lZCAnZm9vLWNoYW5nZWQnIHdpdGggYGV2ZW50LmRldGFpbGAgc2V0IHRvIHRoZSB2YWx1ZSBvZlxuICAgKiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqICogb2JzZXJ2ZXI6IHtzdHJpbmd9IG5hbWUgb2YgYSBtZXRob2QgdGhhdCBydW5zIHdoZW4gdGhlIHByb3BlcnR5XG4gICAqIGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmUgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKS5cbiAgICpcbiAgICogTm90ZTogVXNlcnMgbWF5IHdhbnQgY29udHJvbCBvdmVyIG1vZGlmeWluZyBwcm9wZXJ0eVxuICAgKiBlZmZlY3RzIHZpYSBzdWJjbGFzc2luZy4gRm9yIGV4YW1wbGUsIGEgdXNlciBtaWdodCB3YW50IHRvIG1ha2UgYVxuICAgKiByZWZsZWN0VG9BdHRyaWJ1dGUgcHJvcGVydHkgbm90IGRvIHNvIGluIGEgc3ViY2xhc3MuIFdlJ3ZlIGNob3NlbiB0b1xuICAgKiBkaXNhYmxlIHRoaXMgYmVjYXVzZSBpdCBsZWFkcyB0byBhZGRpdGlvbmFsIGNvbXBsaWNhdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGEgcmVhZE9ubHkgZWZmZWN0IGdlbmVyYXRlcyBhIHNwZWNpYWwgc2V0dGVyLiBJZiBhIHN1YmNsYXNzXG4gICAqIGRpc2FibGVzIHRoZSBlZmZlY3QsIHRoZSBzZXR0ZXIgd291bGQgZmFpbCB1bmV4cGVjdGVkbHkuXG4gICAqIEJhc2VkIG9uIGZlZWRiYWNrLCB3ZSBtYXkgd2FudCB0byB0cnkgdG8gbWFrZSBlZmZlY3RzIG1vcmUgbWFsbGVhYmxlXG4gICAqIGFuZC9vciBwcm92aWRlIGFuIGFkdmFuY2VkIGFwaSBmb3IgbWFuaXB1bGF0aW5nIHRoZW0uXG4gICAqIEFsc28gY29uc2lkZXIgYWRkaW5nIHdhcm5pbmdzIHdoZW4gYW4gZWZmZWN0IGNhbm5vdCBiZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIEluZm8gb2JqZWN0IGZyb20gd2hpY2ggdG8gY3JlYXRlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqIFN1cHBvcnRlZCBrZXlzOlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWxsUHJvcHMgRmxhdHRlbmVkIG1hcCBvZiBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXNcbiAgICogICBlbGVtZW50IChpbmNsdWRpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIG5hbWUsIGluZm8sIGFsbFByb3BzKSB7XG4gICAgLy8gY29tcHV0ZWQgZm9yY2VzIHJlYWRPbmx5Li4uXG4gICAgaWYgKGluZm8uY29tcHV0ZWQpIHtcbiAgICAgIGluZm8ucmVhZE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBOb3RlLCBzaW5jZSBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZE9ubHksIHRoaXMgcHJldmVudHNcbiAgICAvLyBhZGRpbmcgYWRkaXRpb25hbCBjb21wdXRlZCBwcm9wZXJ0eSBlZmZlY3RzICh3aGljaCBsZWFkcyB0byBhIGNvbmZ1c2luZ1xuICAgIC8vIHNldHVwIHdoZXJlIG11bHRpcGxlIHRyaWdnZXJzIGZvciBzZXR0aW5nIGEgcHJvcGVydHkpXG4gICAgLy8gV2hpbGUgd2UgZG8gaGF2ZSBgaGFzQ29tcHV0ZWRFZmZlY3RgIHRoaXMgaXMgc2V0IG9uIHRoZSBwcm9wZXJ0eSdzXG4gICAgLy8gZGVwZW5kZW5jaWVzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAgICBpZiAoaW5mby5jb21wdXRlZCAgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkobmFtZSwgaW5mby5jb21wdXRlZCwgYWxsUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWFkT25seSAmJiAhcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShuYW1lLCAhaW5mby5jb21wdXRlZCk7XG4gICAgfVxuICAgIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSAmJiAhcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgaWYgKGluZm8ubm90aWZ5ICYmICFwcm90by5faGFzTm90aWZ5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhZGQgb2JzZXJ2ZXJcbiAgICBpZiAoaW5mby5vYnNlcnZlcikge1xuICAgICAgcHJvdG8uX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIobmFtZSwgaW5mby5vYnNlcnZlciwgYWxsUHJvcHNbaW5mby5vYnNlcnZlcl0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGFuIGVsZW1lbnQgYHByb3RvYCB0byBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gYHRlbXBsYXRlYC5cbiAgICogVGhlIGVsZW1lbnQgbmFtZSBgaXNgIGFuZCBleHRlbmRzIGBleHRgIG11c3QgYmUgc3BlY2lmaWVkIGZvciBTaGFkeUNTU1xuICAgKiBzdHlsZSBzY29waW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJvY2VzcyBhbmQgYmluZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBVUkwgYWdhaW5zdCB3aGljaCB0byByZXNvbHZlIHVybHMgaW5cbiAgICogICBzdHlsZSBlbGVtZW50IGNzc1RleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlzIFRhZyBuYW1lIChvciB0eXBlIGV4dGVuc2lvbiBuYW1lKSBmb3IgdGhpcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gZXh0IEZvciB0eXBlIGV4dGVuc2lvbnMsIHRoZSB0YWcgbmFtZSB0aGF0IHdhcyBleHRlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVUZW1wbGF0ZShwcm90bywgdGVtcGxhdGUsIGJhc2VVUkksIGlzLCBleHQpIHtcbiAgICAvLyBzdXBwb3J0IGBpbmNsdWRlPVwibW9kdWxlLW5hbWVcImBcbiAgICBsZXQgY3NzVGV4dCA9XG4gICAgICBjc3NGcm9tTW9kdWxlSW1wb3J0cyhpcykgK1xuICAgICAgY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKTtcbiAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgICAgIHRlbXBsYXRlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBpcywgZXh0KTtcbiAgICB9XG4gICAgcHJvdG8uX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQHVucmVzdHJpY3RlZFxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqL1xuICBjbGFzcyBQb2x5bWVyRWxlbWVudCBleHRlbmRzIHBvbHltZXJFbGVtZW50QmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBDdXN0b20gRWxlbWVudHMgVjEgQVBJLiAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xuICAgICAqIGEgbGlzdCBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYSBmbGF0dGVuaW5nIG9mIGFsbCBwcm9wZXJ0aWVzXG4gICAgICogZGVjbGFyZWQgaW4gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYCBmb3IgdGhpcyBlbGVtZW50IGFuZCBhbnlcbiAgICAgKiBzdXBlcmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gT2JzZXJ2ZWQgYXR0cmlidXRlIGxpc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX29ic2VydmVkQXR0cmlidXRlcycsIHRoaXMpKSkge1xuICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICBsZXQgcHJvcGVydGllcyA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGNhbWVsVG9EYXNoQ2FzZShwcm9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcyA9IGxpc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIGNyZWF0ZWQgdG9cbiAgICAgKiBlbnN1cmUgdGhhdCBjbGFzcyBmaW5hbGl6YXRpb24gd29yayBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICogTWF5IGJlIGNhbGxlZCBieSB1c2VycyB0byBlYWdlcmx5IHBlcmZvcm0gY2xhc3MgZmluYWxpemF0aW9uIHdvcmtcbiAgICAgKiBwcmlvciB0byB0aGUgY3JlYXRpb24gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBDbGFzcyBmaW5hbGl6YXRpb24gd29yayBnZW5lcmFsbHkgaW5jbHVkZXMgbWV0YS1wcm9ncmFtbWluZyBzdWNoIGFzXG4gICAgICogY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBhbnkgcHJvcGVydHkgZWZmZWN0IG1ldGFkYXRhIG5lZWRlZCBmb3JcbiAgICAgKiB0aGUgZmVhdHVyZXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzRmluYWxpemVkKHRoaXMpKSB7XG4gICAgICAgIGZpbmFsaXplQ2xhc3NBbmRTdXBlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoaXMgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqXG4gICAgICogSWYgYSBgc3RhdGljIGdldCBpcygpYCBnZXR0ZXIgaXMgZGVmaW5lZCwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gIGluIGEgYGRvbS1tb2R1bGVgIHdob3NlIGBpZGBcbiAgICAgKiBtYXRjaGVzIHRoaXMgZWxlbWVudCdzIGBpc2AuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgdG8gcmV0dXJuIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHRoZSBgaXNgIGdldHRlciBpcyB1bm5lY2Vzc2FyeSkuIFRoZSB0ZW1wbGF0ZSByZXR1cm5lZFxuICAgICAqIG1heSBiZSBlaXRoZXIgYW4gYEhUTUxUZW1wbGF0ZUVsZW1lbnRgIG9yIGEgc3RyaW5nIHRoYXQgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHN1YmNsYXNzaW5nLCBpZiB0aGUgc3VwZXIgY2xhc3Mgb3ZlcnJvZGUgdGhlIGRlZmF1bHRcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICAgKiB0ZW1wbGF0ZSB2aWEgYSBgZG9tLW1vZHVsZWAsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIGdldHRlciBhbmRcbiAgICAgKiByZXR1cm4gYFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKWAuXG4gICAgICpcbiAgICAgKiBJZiBhIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gbW9kaWZ5IHRoZSBzdXBlciBjbGFzcyB0ZW1wbGF0ZSwgaXQgc2hvdWxkXG4gICAgICogY2xvbmUgaXQgcmF0aGVyIHRoYW4gbW9kaWZ5IGl0IGluIHBsYWNlLiAgSWYgdGhlIGdldHRlciBkb2VzIGV4cGVuc2l2ZVxuICAgICAqIHdvcmsgc3VjaCBhcyBjbG9uaW5nL21vZGlmeWluZyBhIHRlbXBsYXRlLCBpdCBzaG91bGQgbWVtb2l6ZSB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZTpcbiAgICAgKlxuICAgICAqICAgbGV0IG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICBjbGFzcyBNeVN1YkNsYXNzIGV4dGVuZHMgTXlTdXBlckNsYXNzIHtcbiAgICAgKiAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgKiAgICAgICBpZiAoIW1lbW9pemVkVGVtcGxhdGUpIHtcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUgPSBzdXBlci50ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICAgICAgICBsZXQgc3ViQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqICAgICAgICAgc3ViQ29udGVudC50ZXh0Q29udGVudCA9ICdUaGlzIGNhbWUgZnJvbSBNeVN1YkNsYXNzJztcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChzdWJDb250ZW50KTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgICAgcmV0dXJuIG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR8c3RyaW5nfSBUZW1wbGF0ZSB0byBiZSBzdGFtcGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfdGVtcGxhdGUnLCB0aGlzKSkpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydChcbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgICAvLyBub3RlOiBpbXBsZW1lbnRlZCBzbyBhIHN1YmNsYXNzIGNhbiByZXRyaWV2ZSB0aGUgc3VwZXJcbiAgICAgICAgICAvLyB0ZW1wbGF0ZTsgY2FsbCB0aGUgc3VwZXIgaW1wbCB0aGlzIHdheSBzbyB0aGF0IGB0aGlzYCBwb2ludHNcbiAgICAgICAgICAvLyB0byB0aGUgc3VwZXJjbGFzcy5cbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRoIG1hdGNoaW5nIHRoZSB1cmwgZnJvbSB3aGljaCB0aGUgZWxlbWVudCB3YXMgaW1wb3J0ZWQuXG4gICAgICogVGhpcyBwYXRoIGlzIHVzZWQgdG8gcmVzb2x2ZSB1cmwncyBpbiB0ZW1wbGF0ZSBzdHlsZSBjc3NUZXh0LlxuICAgICAqIFRoZSBgaW1wb3J0UGF0aGAgcHJvcGVydHkgaXMgYWxzbyBzZXQgb24gZWxlbWVudCBpbnN0YW5jZXMgYW5kIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGJpbmRpbmdzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgcGF0aC5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBtYXRjaGluZyB0aGUgdXJsIGNvbnRhaW5pbmcgYSBgZG9tLW1vZHVsZWAgZWxlbWVudFxuICAgICAqIG1hdGNoaW5nIHRoaXMgZWxlbWVudCdzIHN0YXRpYyBgaXNgIHByb3BlcnR5LlxuICAgICAqIE5vdGUsIHRoaXMgcGF0aCBzaG91bGQgY29udGFpbiBhIHRyYWlsaW5nIGAvYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGltcG9ydCBwYXRoIGZvciB0aGlzIGVsZW1lbnQgY2xhc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGltcG9ydFBhdGgoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX2ltcG9ydFBhdGgnLCB0aGlzKSkpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydCgvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAodGhpcykuaXMpO1xuICAgICAgICAgIHRoaXMuX2ltcG9ydFBhdGggPSBtb2R1bGUgPyBtb2R1bGUuYXNzZXRwYXRoIDogJycgfHxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fdGVtcGxhdGU7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMucm9vdFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuaW1wb3J0UGF0aDtcbiAgICAgIC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlIHwgSFRNTEVsZW1lbnQgfCBTaGFkb3dSb290fSAqL1xuICAgICAgdGhpcy5yb290O1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU5vZGU+fSAqL1xuICAgICAgdGhpcy4kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgdG8gZW5zdXJlIGNsYXNzXG4gICAgICogbWV0YXByb2dyYW1taW5nIHJlbGF0ZWQgdG8gcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzIGhhc1xuICAgICAqIGNvbXBsZXRlZCAoY2FsbHMgYGZpbmFsaXplYCkuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGluaXRpYWxpemVzIGFueSBwcm9wZXJ0eSBkZWZhdWx0cyBwcm92aWRlZCB2aWEgYHZhbHVlYCBpblxuICAgICAqIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIGluc3RhbmNlQ291bnQrKztcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuZmluYWxpemUoKTtcbiAgICAgIGNvbnN0IGltcG9ydFBhdGggPSB0aGlzLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAvLyBub3RlOiBmaW5hbGl6ZSB0ZW1wbGF0ZSB3aGVuIHdlIGhhdmUgYWNjZXNzIHRvIGBsb2NhbE5hbWVgIHRvXG4gICAgICAvLyBhdm9pZCBkZXBlbmRlbmNlIG9uIGBpc2AgZm9yIHBvbHlmaWxsaW5nIHN0eWxpbmcuXG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiYgIXRoaXMuX3RlbXBsYXRlLl9fcG9seW1lckZpbmFsaXplZCkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBiYXNlVVJJID1cbiAgICAgICAgICBpbXBvcnRQYXRoID8gcmVzb2x2ZVVybCQwKGltcG9ydFBhdGgpIDogJyc7XG4gICAgICAgIGZpbmFsaXplVGVtcGxhdGUoLyoqIEB0eXBlIHshUG9seW1lckVsZW1lbnR9ICovKHRoaXMuX19wcm90b19fKSwgdGhpcy5fdGVtcGxhdGUsIGJhc2VVUkksXG4gICAgICAgICAgLyoqQHR5cGUgeyFIVE1MRWxlbWVudH0qLyh0aGlzKS5sb2NhbE5hbWUpO1xuICAgICAgfVxuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAvLyBzZXQgcGF0aCBkZWZhdWx0c1xuICAgICAgdGhpcy5yb290UGF0aCA9IHJvb3RQYXRoJDA7XG4gICAgICB0aGlzLmltcG9ydFBhdGggPSBpbXBvcnRQYXRoO1xuICAgICAgLy8gYXBwbHkgcHJvcGVydHkgZGVmYXVsdHMuLi5cbiAgICAgIGxldCBwJCA9IHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIGlmICghcCQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcCBpbiBwJCkge1xuICAgICAgICBsZXQgaW5mbyA9IHAkW3BdO1xuICAgICAgICAvLyBEb24ndCBzZXQgZGVmYXVsdCB2YWx1ZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG93biBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgICAgLy8gaGFwcGVucyB3aGVuIGEgYHByb3BlcnRpZXNgIHByb3BlcnR5IHdpdGggZGVmYXVsdCBidXQgbm8gZWZmZWN0cyBoYWRcbiAgICAgICAgLy8gYSBwcm9wZXJ0eSBzZXQgKGUuZy4gYm91bmQpIGJ5IGl0cyBob3N0IGJlZm9yZSB1cGdyYWRlXG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHR5cGVvZiBpbmZvLnZhbHVlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgaW5mby52YWx1ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAgIGluZm8udmFsdWU7XG4gICAgICAgICAgLy8gU2V0IHZpYSBgX3NldFByb3BlcnR5YCBpZiB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgdG8gZW5hYmxlXG4gICAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHJlYWRPbmx5IHByb3BlcnR5IGRlZmF1bHRzXG4gICAgICAgICAgaWYgKHRoaXMuX2hhc0FjY2Vzc29yKHApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZW5hYmxlcyB0aGUgcHJvcGVydHkgZWZmZWN0cyBzeXN0ZW0gYW5kXG4gICAgICogZmx1c2hlcyBhbnkgcGVuZGluZyBwcm9wZXJ0aWVzLCBhbmQgdXBkYXRlcyBzaGltbWVkIENTUyBwcm9wZXJ0aWVzXG4gICAgICogd2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZy9jdXN0b20gcHJvcGVydGllcyBwb2x5ZmlsbC5cbiAgICAgKlxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICAgIC8qKlxuICAgICAqIFN0YW1wcyB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fdGVtcGxhdGUpO1xuICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlFZmZlY3RzYCdzIGBfcmVhZHlDbGllbnRzYCBjYWxsLiBBdHRhY2hlc1xuICAgICAqIGVsZW1lbnQgZG9tIGJ5IGNhbGxpbmcgYF9hdHRhY2hEb21gIHdpdGggdGhlIGRvbSBzdGFtcGVkIGZyb20gdGhlXG4gICAgICogZWxlbWVudCdzIHRlbXBsYXRlIHZpYSBgX3N0YW1wVGVtcGxhdGVgLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3NcbiAgICAgKiBjbGllbnQgZG9tIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IHByaW9yIHRvIGFueSBvYnNlcnZlcnNcbiAgICAgKiBydW5uaW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9hdHRhY2hEb20oLyoqIEB0eXBlIHtTdGFtcGVkVGVtcGxhdGV9ICovKHRoaXMucm9vdCkpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHN1cGVyLl9yZWFkeUNsaWVudHMgaGVyZSBzZXRzIHRoZSBjbGllbnRzIGluaXRpYWxpemVkIGZsYWcuXG4gICAgICAvLyBXZSBtdXN0IHdhaXQgdG8gZG8gdGhpcyB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGNyZWF0ZWQvYXR0YWNoZWRcbiAgICAgIC8vIHNvIHRoYXQgdGhpcyBmbGFnIGNhbiBiZSBjaGVja2VkIHRvIHByZXZlbnQgbm90aWZpY2F0aW9ucyBmaXJlZFxuICAgICAgLy8gZHVyaW5nIHRoaXMgcHJvY2VzcyBmcm9tIGJlaW5nIGhhbmRsZWQgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgc3VwZXIuX3JlYWR5Q2xpZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gZWxlbWVudCdzIHN0YW1wZWQgZG9tIHRvIGl0c2VsZi4gQnkgZGVmYXVsdCxcbiAgICAgKiB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgYHNoYWRvd1Jvb3RgIGFuZCBhZGRzIHRoZSBkb20gdG8gaXQuXG4gICAgICogSG93ZXZlciwgdGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWxsb3cgYW4gZWxlbWVudFxuICAgICAqIHRvIHB1dCBpdHMgZG9tIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdSZXR1cm59XG4gICAgICogQHBhcmFtIHtTdGFtcGVkVGVtcGxhdGV9IGRvbSB0byBhdHRhY2ggdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7U2hhZG93Um9vdH0gbm9kZSB0byB3aGljaCB0aGUgZG9tIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIF9hdHRhY2hEb20oZG9tKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRvd0RPTSBub3QgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBtb3ZlIHRvIGNvbXBpbGUtdGltZSBjb25kaXRpb25hbCB3aGVuIHN1cHBvcnRlZFxuICAgICAgICAnUG9seW1lci5FbGVtZW50IGNhbiBjcmVhdGUgZG9tIGFzIGNoaWxkcmVuIGluc3RlYWQgb2YgaW4gJyArXG4gICAgICAgICdTaGFkb3dET00gYnkgc2V0dGluZyBgdGhpcy5yb290ID0gdGhpcztcXGAgYmVmb3JlIFxcYHJlYWR5XFxgLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBhdHRyaWJ1dGVzIGRlY2xhcmVkIGluIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YSBhcmVcbiAgICAgKiBkZXNlcmlhbGl6ZWQgdXNpbmcgdGhlaXIgYHR5cGVgIGluZm9ybWF0aW9uIHRvIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICogc2FtZSBuYW1lLiAgXCJEYXNoLWNhc2VkXCIgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWx6ZWQgdG8gXCJjYW1lbENhc2VcIlxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICBsZXQgdHlwZSA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKVtwcm9wZXJ0eV0udHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gICAgICogc2hpbW1lZCBzdHlsZXMgaW4gdGhpcyBlbGVtZW50IChhbmQgaXRzIHN1YnRyZWUpIHRvIGJlIHVwZGF0ZWRcbiAgICAgKiBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3B0aW9uYWwgcGFyYW1ldGVyIG92ZXJyaWRlcyBpbmxpbmUgY3VzdG9tIHByb3BlcnR5IHN0eWxlcyB3aXRoIGFuXG4gICAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgICAqIGFyZSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTogYHRoaXMudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgICAqXG4gICAgICogVGhlc2UgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgdW5sZXNzIGEgdmFsdWUgb2YgYG51bGxgIGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICAgKiAgIGFwcGx5IHRvIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICB1cGRhdGVTdHlsZXMocHJvcGVydGllcykge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV3cml0ZXMgYSBnaXZlbiBVUkwgcmVsYXRpdmUgdG8gYSBiYXNlIFVSTC4gVGhlIGJhc2UgVVJMIGRlZmF1bHRzIHRvXG4gICAgICogdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBgZG9tLW1vZHVsZWAgZm9yXG4gICAgICogdGhpcyBlbGVtZW50LiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBVUkwgYmVmb3JlIGFuZCBhZnRlclxuICAgICAqIGJ1bmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJhc2UgT3B0aW9uYWwgYmFzZSBVUkwgdG8gcmVzb2x2ZSBhZ2FpbnN0LCBkZWZhdWx0c1xuICAgICAqIHRvIHRoZSBlbGVtZW50J3MgYGltcG9ydFBhdGhgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXdyaXR0ZW4gVVJMIHJlbGF0aXZlIHRvIGJhc2VcbiAgICAgKi9cbiAgICByZXNvbHZlVXJsKHVybCwgYmFzZSkge1xuICAgICAgaWYgKCFiYXNlICYmIHRoaXMuaW1wb3J0UGF0aCkge1xuICAgICAgICBiYXNlID0gcmVzb2x2ZVVybCQwKHRoaXMuaW1wb3J0UGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZVVybCQwKHVybCwgYmFzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2AgdG8gYWRkIG1hcCBvZiBkeW5hbWljIGZ1bmN0aW9ucyBvblxuICAgICAqIHRlbXBsYXRlIGluZm8sIGZvciBjb25zdW1wdGlvbiBieSBgUHJvcGVydHlFZmZlY3RzYCB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICogY29kZS4gVGhpcyBtYXAgZGV0ZXJtaW5lcyB3aGljaCBtZXRob2QgdGVtcGxhdGVzIHNob3VsZCBoYXZlIGFjY2Vzc29yc1xuICAgICAqIGNyZWF0ZWQgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zIHx8IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBvbHltZXJFbGVtZW50O1xufSk7XG5cbmV4cG9ydCBsZXQgaW5zdGFuY2VDb3VudCA9IDA7XG5leHBvcnQgY29uc3QgcmVnaXN0cmF0aW9ucyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gX3JlZ0xvZyhwcm90b3R5cGUpIHtcbiAgY29uc29sZS5sb2coJ1snICsgcHJvdG90eXBlLmlzICsgJ106IHJlZ2lzdGVyZWQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHByb3RvdHlwZSkge1xuICByZWdpc3RyYXRpb25zLnB1c2gocHJvdG90eXBlKTtcbiAgdW5kZWZpbmVkICYmIF9yZWdMb2cocHJvdG90eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR1bXBSZWdpc3RyYXRpb25zKCkge1xuICByZWdpc3RyYXRpb25zLmZvckVhY2goX3JlZ0xvZyk7XG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTdHlsZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRG9jdW1lbnQocHJvcHMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IHBhdGhGcm9tVXJsIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5cbi8qKlxuICogTGVnYWN5IHNldHRpbmdzLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xuY29uc3Qgc2V0dGluZ3MgPSB1bmRlZmluZWQgfHwge307XG5leHBvcnQgY29uc3QgdXNlU2hhZG93ID0gISh3aW5kb3cuU2hhZHlET00pO1xuZXhwb3J0IGNvbnN0IHVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMgPSBCb29sZWFuKCF3aW5kb3cuU2hhZHlDU1MgfHwgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyk7XG5leHBvcnQgY29uc3QgdXNlTmF0aXZlQ3VzdG9tRWxlbWVudHMgPSAhKHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKTtcbmV4cG9ydCB7IHNldHRpbmdzIGFzIFNldHRpbmdzIH07XG5cbi8qKlxuICogR2xvYmFsbHkgc2V0dGFibGUgcHJvcGVydHkgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvXG4gKiBgUG9seW1lci5FbGVtZW50TWl4aW5gIGluc3RhbmNlcywgdXNlZnVsIGZvciBiaW5kaW5nIGluIHRlbXBsYXRlcyB0b1xuICogbWFrZSBVUkwncyByZWxhdGl2ZSB0byBhbiBhcHBsaWNhdGlvbidzIHJvb3QuICBEZWZhdWx0cyB0byB0aGUgbWFpblxuICogZG9jdW1lbnQgVVJMLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlcnMuICBJdCBtYXkgYmUgdXNlZnVsIHRvIHNldFxuICogYFBvbHltZXIucm9vdFBhdGhgIHRvIHByb3ZpZGUgYSBzdGFibGUgYXBwbGljYXRpb24gbW91bnQgcGF0aCB3aGVuXG4gKiB1c2luZyBjbGllbnQgc2lkZSByb3V0aW5nLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCByb290UGF0aCA9IHVuZGVmaW5lZCB8fFxuICBwYXRoRnJvbVVybChkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuZXhwb3J0IHsgcm9vdFBhdGggfTtcblxuZXhwb3J0IGNvbnN0IHNldFJvb3RQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICByb290UGF0aCA9IHBhdGg7XG59O1xuXG4vKipcbiAqIEEgZ2xvYmFsIGNhbGxiYWNrIHVzZWQgdG8gc2FuaXRpemUgYW55IHZhbHVlIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgRE9NLiBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuICpcbiAqICAgICBQb2x5bWVyID0ge1xuICogICAgICAgc2FuaXRpemVET01WYWx1ZTogZnVuY3Rpb24odmFsdWUsIG5hbWUsIHR5cGUsIG5vZGUpIHsgLi4uIH1cbiAqICAgICB9XG4gKlxuICogV2hlcmU6XG4gKlxuICogYHZhbHVlYCBpcyB0aGUgdmFsdWUgdG8gc2FuaXRpemUuXG4gKiBgbmFtZWAgaXMgdGhlIG5hbWUgb2YgYW4gYXR0cmlidXRlIG9yIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaHJlZikuXG4gKiBgdHlwZWAgaW5kaWNhdGVzIHdoZXJlIHRoZSB2YWx1ZSBpcyBiZWluZyBpbnNlcnRlZDogb25lIG9mIHByb3BlcnR5LCBhdHRyaWJ1dGUsIG9yIHRleHQuXG4gKiBgbm9kZWAgaXMgdGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIGJlaW5nIGluc2VydGVkLlxuICpcbiAqIEB0eXBlIHsoZnVuY3Rpb24oKixzdHJpbmcsc3RyaW5nLE5vZGUpOiopfHVuZGVmaW5lZH1cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCBzYW5pdGl6ZURPTVZhbHVlID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH07XG5cbmV4cG9ydCBjb25zdCBzZXRTYW5pdGl6ZURPTVZhbHVlID0gZnVuY3Rpb24obmV3U2FuaXRpemVET01WYWx1ZSkge1xuICBzYW5pdGl6ZURPTVZhbHVlID0gbmV3U2FuaXRpemVET01WYWx1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5jb25zdCBjYXNlTWFwID0ge307XG5jb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuY29uc3QgQ0FNRUxfVE9fREFTSCA9IC8oW0EtWl0pL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICByZXR1cm4gY2FzZU1hcFtkYXNoXSB8fCAoXG4gICAgY2FzZU1hcFtkYXNoXSA9IGRhc2guaW5kZXhPZignLScpIDwgMCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoREFTSF9UT19DQU1FTCxcbiAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbFRvRGFzaENhc2UoY2FtZWwpIHtcbiAgcmV0dXJuIGNhc2VNYXBbY2FtZWxdIHx8IChcbiAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHJvb3QgYXMgcm9vdCQwLCBpc0FuY2VzdG9yLCBpc0Rlc2NlbmRhbnQsIGdldCBhcyBnZXQkMCwgdHJhbnNsYXRlLCBpc1BhdGggYXMgaXNQYXRoJDAsIHNldCBhcyBzZXQkMCwgbm9ybWFsaXplIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwIGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoQ2FzZSBhcyBjYW1lbFRvRGFzaENhc2UkMCwgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlBY2Nlc3NvcnMgfSBmcm9tICcuL3Byb3BlcnR5LWFjY2Vzc29ycy5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVN0YW1wIH0gZnJvbSAnLi90ZW1wbGF0ZS1zdGFtcC5qcyc7XG5pbXBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtPYmplY3R9ICovXG5jb25zdCBDYXNlTWFwID0gY2FzZU1hcDtcblxuLy8gTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHVuaXF1ZSBJRCB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0cyB0cmlnZ2VyZWRcbi8vIGZyb20gbXVsdGlwbGUgcHJvcGVydGllcyBpbiB0aGUgc2FtZSB0dXJuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIFByb3BlcnR5IGVmZmVjdCB0eXBlczsgZWZmZWN0cyBhcmUgc3RvcmVkIG9uIHRoZSBwcm90b3R5cGUgdXNpbmcgdGhlc2Uga2V5c1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVFlQRVMgPSB7XG4gIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgUkVGTEVDVDogJ19fcmVmbGVjdEVmZmVjdHMnLFxuICBOT1RJRlk6ICdfX25vdGlmeUVmZmVjdHMnLFxuICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICBPQlNFUlZFOiAnX19vYnNlcnZlRWZmZWN0cycsXG4gIFJFQURfT05MWTogJ19fcmVhZE9ubHknXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBuYW1lOiAoc3RyaW5nIHwgdW5kZWZpbmVkKSxcbiAqIHN0cnVjdHVyZWQ6IChib29sZWFuIHwgdW5kZWZpbmVkKSxcbiAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIGluZm86ID8sXG4gKiB0cmlnZ2VyOiAoIURhdGFUcmlnZ2VyIHwgdW5kZWZpbmVkKSxcbiAqIGZuOiAoIUZ1bmN0aW9uIHwgdW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IERhdGFFZmZlY3Q7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5sZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBtb2RlbCBoYXMgYW4gb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gKlxuICogUHJvcGVydHkgZWZmZWN0cyBhcmUgc3RvcmVkIGFzIGFycmF5cyBvZiBlZmZlY3RzIGJ5IHByb3BlcnR5IGluIGEgbWFwLFxuICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAqXG4gKiAgIF9fY29tcHV0ZUVmZmVjdHM6IHtcbiAqICAgICBmb286IFsgLi4uIF0sXG4gKiAgICAgYmFyOiBbIC4uLiBdXG4gKiAgIH1cbiAqXG4gKiBJZiB0aGUgbW9kZWwgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IG1hcCBmb3IgdGhlIHR5cGUsIG9uZSBpcyBjcmVhdGVkXG4gKiBhbmQgcmV0dXJuZWQuICBJZiBpdCBkb2VzLCBidXQgaXQgaXMgbm90IGFuIG93biBwcm9wZXJ0eSAoaS5lLiB0aGVcbiAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gKiBzZXQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5lZCwgcmVhZHkgZm9yIG5ldyBlZmZlY3RzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFByb3BlcnR5IGVmZmVjdCB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnN1cmVPd25FZmZlY3RNYXAobW9kZWwsIHR5cGUpIHtcbiAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgaWYgKCFlZmZlY3RzKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0ge307XG4gIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShtb2RlbFt0eXBlXSk7XG4gICAgZm9yIChsZXQgcCBpbiBlZmZlY3RzKSB7XG4gICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICBsZXQgaW5zdEZ4ID0gZWZmZWN0c1twXSA9IEFycmF5KHByb3RvRngubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwcm90b0Z4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlZmZlY3RzO1xufVxuXG4vLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSdW5zIGFsbCBlZmZlY3RzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgdGhlIGdpdmVuIHNldCBvZiBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdD19IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHMoaW5zdCwgZWZmZWN0cywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGlmIChlZmZlY3RzKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgaWYgKHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSkge1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgbGlzdCBvZiBlZmZlY3RzIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZHVwZUlkIENvdW50ZXIgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSBwcm9wcyBDaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Kn0gb2xkUHJvcHMgT2xkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgZGVkdXBlSWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICBsZXQgcmFuID0gZmFsc2U7XG4gIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QkMChwcm9wKSA6IHByb3A7XG4gIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gIGlmIChmeHMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ZnhzLmxlbmd0aCwgZng7IChpPGwpICYmIChmeD1meHNbaV0pOyBpKyspIHtcbiAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgaWYgKGZ4LmluZm8pIHtcbiAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgfVxuICAgICAgICBmeC5mbihpbnN0LCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGZ4LmluZm8sIGhhc1BhdGhzLCBleHRyYUFyZ3MpO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmFuO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHByb3BlcnR5L3BhdGggdGhhdCBoYXMgY2hhbmdlZCBtYXRjaGVzIHRoZSB0cmlnZ2VyXG4gKiBjcml0ZXJpYSBmb3IgYW4gZWZmZWN0LiAgQSB0cmlnZ2VyIGlzIGEgZGVzY3JpcHRvciB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICogZS5nLiBmb3IgYGZvby5iYXIuKmA6XG4gKiBgYGBcbiAqIHRyaWdnZXI6IHtcbiAqICAgbmFtZTogJ2EuYicsXG4gKiAgIHN0cnVjdHVyZWQ6IHRydWUsXG4gKiAgIHdpbGRjYXJkOiB0cnVlXG4gKiB9XG4gKiBgYGBcbiAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIG9yIHByb3BlcnR5IHRoYXQgY2hhbmdlZFxuICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXRoIG1hdGNoZWQgdGhlIHRyaWdnZXJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgaWYgKHRyaWdnZXIpIHtcbiAgICBsZXQgdHJpZ2dlclBhdGggPSB0cmlnZ2VyLm5hbWU7XG4gICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgKHRyaWdnZXIuc3RydWN0dXJlZCAmJiBpc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICh0cmlnZ2VyLndpbGRjYXJkICYmIGlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAqXG4gKiBDYWxscyB0aGUgbWV0aG9kIHdpdGggYGluZm8ubWV0aG9kTmFtZWAgb24gdGhlIGluc3RhbmNlLCBwYXNzaW5nIHRoZVxuICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgZm4gPSBpbnN0W2luZm8ubWV0aG9kTmFtZV07XG4gIGxldCBjaGFuZ2VkUHJvcCA9IGluZm8ucHJvcGVydHk7XG4gIGlmIChmbikge1xuICAgIGZuLmNhbGwoaW5zdCwgaW5zdC5fX2RhdGFbY2hhbmdlZFByb3BdLCBvbGRQcm9wc1tjaGFuZ2VkUHJvcF0pO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgXCJub3RpZnlcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogd2lsbCBkaXNwYXRjaCBwYXRoIG5vdGlmaWNhdGlvbiBldmVudHMgaW4gdGhlIGNhc2UgdGhhdCB0aGUgcHJvcGVydHlcbiAqIGNoYW5nZWQgd2FzIGEgcGF0aCBhbmQgdGhlIHJvb3QgcHJvcGVydHkgZm9yIHRoYXQgcGF0aCBkaWRuJ3QgaGF2ZSBhXG4gKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gKiBgbm90aWZ5OiB0cnVlYCB0byBlbnN1cmUgb2JqZWN0IHN1Yi1wcm9wZXJ0eSBub3RpZmljYXRpb25zIHdlcmVcbiAqIHNlbnQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IG5vdGlmeVByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIG5vdGlmeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdHMoaW5zdCwgbm90aWZ5UHJvcHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgLy8gTm90aWZ5XG4gIGxldCBmeHMgPSBpbnN0W1RZUEVTLk5PVElGWV07XG4gIGxldCBub3RpZmllZDtcbiAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgLy8gVHJ5IG5vcm1hbCBub3RpZnkgZWZmZWN0czsgaWYgbm9uZSwgZmFsbCBiYWNrIHRvIHRyeSBwYXRoIG5vdGlmaWNhdGlvblxuICBmb3IgKGxldCBwcm9wIGluIG5vdGlmeVByb3BzKSB7XG4gICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICBpZiAoZnhzICYmIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBmeHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRmx1c2ggaG9zdCBpZiB3ZSBhY3R1YWxseSBub3RpZmllZCBhbmQgaG9zdCB3YXMgYmF0Y2hpbmdcbiAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgLy8gYW4gaXNzdWUgd2l0aCBhIGhvc3Qgb2JzZXJ2aW5nIGRhdGEgY2hhbmdlcyBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gIGxldCBob3N0O1xuICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB3aXRoIHBhdGggaW5mb3JtYXRpb24gaW4gdGhlIGRldGFpbFxuICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgbm90aWZpZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVBhdGgoaW5zdCwgcGF0aCwgcHJvcHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IHJvb3QkMChwYXRoKTtcbiAgaWYgKHJvb3RQcm9wZXJ0eSAhPT0gcGF0aCkge1xuICAgIGxldCBldmVudE5hbWUgPSBjYW1lbFRvRGFzaENhc2UkMChyb290UHJvcGVydHkpICsgJy1jaGFuZ2VkJztcbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgcHJvcHNbcGF0aF0sIHBhdGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgdG8gaW5kaWNhdGUgYSBwcm9wZXJ0eSAob3IgcGF0aClcbiAqIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHBhdGggSWYgYSBzdWItcGF0aCBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZWQsIHRoZSBwYXRoXG4gKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICogQHByaXZhdGVcbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpIHtcbiAgbGV0IGRldGFpbCA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcXVldWVQcm9wZXJ0eTogdHJ1ZVxuICB9O1xuICBpZiAocGF0aCkge1xuICAgIGRldGFpbC5wYXRoID0gcGF0aDtcbiAgfVxuICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gKlxuICogRGlzcGF0Y2hlcyBhIG5vbi1idWJibGluZyBldmVudCBuYW1lZCBgaW5mby5ldmVudE5hbWVgIG9uIHRoZSBpbnN0YW5jZVxuICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdCQwKHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICBsZXQgcGF0aCA9IHJvb3RQcm9wZXJ0eSAhPSBwcm9wZXJ0eSA/IHByb3BlcnR5IDogbnVsbDtcbiAgbGV0IHZhbHVlID0gcGF0aCA/IGdldCQwKGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAocGF0aCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBwcm9wc1twcm9wZXJ0eV07ICAvLyBzcGVjaWZpY2FsbHkgZm9yIC5zcGxpY2VzXG4gIH1cbiAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBpbmZvLmV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIDItd2F5IG5vdGlmaWNhdGlvbiBldmVudHMuIFJlY2VpdmVzIGNvbnRleHRcbiAqIGluZm9ybWF0aW9uIGNhcHR1cmVkIGluIHRoZSBgYWRkTm90aWZ5TGlzdGVuZXJgIGNsb3N1cmUgZnJvbSB0aGVcbiAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5vdGlmaWVkIHByb3BlcnR5IHRvIHRoZSBob3N0IHByb3BlcnR5IG9yIHBhdGguICBJZlxuICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gKiBzY29wZSdzIG5hbWUgZm9yIHRoYXQgcGF0aCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSBoYW5kbGluZyB0aGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbVByb3AgQ2hpbGQgZWxlbWVudCBwcm9wZXJ0eSB0aGF0IHdhcyBib3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVnYXRlIFdoZXRoZXIgdGhlIGJpbmRpbmcgd2FzIG5lZ2F0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihldmVudCwgaW5zdCwgZnJvbVByb3AsIHRvUGF0aCwgbmVnYXRlKSB7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICBsZXQgZnJvbVBhdGggPSBkZXRhaWwgJiYgZGV0YWlsLnBhdGg7XG4gIGlmIChmcm9tUGF0aCkge1xuICAgIHRvUGF0aCA9IHRyYW5zbGF0ZShmcm9tUHJvcCwgdG9QYXRoLCBmcm9tUGF0aCk7XG4gICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZXZlbnQudGFyZ2V0W2Zyb21Qcm9wXTtcbiAgfVxuICB2YWx1ZSA9IG5lZ2F0ZSA/ICF2YWx1ZSA6IHZhbHVlO1xuICBpZiAoIWluc3RbVFlQRVMuUkVBRF9PTkxZXSB8fCAhaW5zdFtUWVBFUy5SRUFEX09OTFldW3RvUGF0aF0pIHtcbiAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgJiYgKCFkZXRhaWwgfHwgIWRldGFpbC5xdWV1ZVByb3BlcnR5KSkge1xuICAgICAgaW5zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcInJlZmxlY3RcIiBlZmZlY3QuXG4gKlxuICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IHZhbHVlID0gaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgaW5mby5hdHRyTmFtZSwgJ2F0dHJpYnV0ZScsIC8qKiBAdHlwZSB7Tm9kZX0gKi8oaW5zdCkpO1xuICB9XG4gIGluc3QuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGluZm8uYXR0ck5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSdW5zIFwiY29tcHV0ZWRcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogY29udGludWVzIHRvIHJ1biBjb21wdXRlZCBlZmZlY3RzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgZWFjaCBwYXNzIHVudGlsXG4gKiB0aGVyZSBhcmUgbm8gbW9yZSBuZXdseSBjb21wdXRlZCBwcm9wZXJ0aWVzLiAgVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAqIGNvbXB1dGVkIGJlZm9yZSBvdGhlciBlZmZlY3RzIChiaW5kaW5nIHByb3BhZ2F0aW9uLCBvYnNlcnZlcnMsIGFuZCBub3RpZnkpXG4gKiBydW4uXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0cyhpbnN0LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICBsZXQgY29tcHV0ZUVmZmVjdHMgPSBpbnN0W1RZUEVTLkNPTVBVVEVdO1xuICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICBsZXQgaW5wdXRQcm9wcyA9IGNoYW5nZWRQcm9wcztcbiAgICB3aGlsZSAocnVuRWZmZWN0cyhpbnN0LCBjb21wdXRlRWZmZWN0cywgaW5wdXRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgT2JqZWN0LmFzc2lnbihjaGFuZ2VkUHJvcHMsIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICBpbnB1dFByb3BzID0gaW5zdC5fX2RhdGFQZW5kaW5nO1xuICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImNvbXB1dGVkIHByb3BlcnR5XCIgZWZmZWN0IGJ5IHJ1bm5pbmcgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICogcmV0dXJuIHZhbHVlIHRvIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCByZXN1bHQgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbyk7XG4gIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gIGlmIChpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yICYmIGluc3QuX19kYXRhSGFzQWNjZXNzb3JbY29tcHV0ZWRQcm9wXSkge1xuICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eShjb21wdXRlZFByb3AsIHJlc3VsdCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdFtjb21wdXRlZFByb3BdID0gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgcGF0aCBjaGFuZ2VzIGJhc2VkIG9uIHBhdGggbGlua3Mgc2V0IHVwIHVzaW5nIHRoZSBgbGlua1BhdGhzYFxuICogQVBJLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdob3NlIHByb3BzIGFyZSBjaGFuZ2luZ1xuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgY2hhbmdlZCBwYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTGlua2VkUGF0aHMoaW5zdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IGxpbmtzID0gaW5zdC5fX2RhdGFMaW5rZWRQYXRocztcbiAgaWYgKGxpbmtzKSB7XG4gICAgbGV0IGxpbms7XG4gICAgZm9yIChsZXQgYSBpbiBsaW5rcykge1xuICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgIGlmIChpc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZXNjZW5kYW50KGIsIHBhdGgpKSB7XG4gICAgICAgIGxpbmsgPSB0cmFuc2xhdGUoYiwgYSwgcGF0aCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIC0tIGJpbmRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICogZm9yIGFsbCBwYXJ0IGRlcGVuZGVuY2llcyB0byBgdGVtcGxhdGVJbmZvYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgQmluZGluZyBraW5kLCBlaXRoZXIgJ3Byb3BlcnR5JywgJ2F0dHJpYnV0ZScsIG9yICd0ZXh0J1xuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUYXJnZXQgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGxpdGVyYWwgTGl0ZXJhbCB0ZXh0IHN1cnJvdW5kaW5nIGJpbmRpbmcgcGFydHMgKHNwZWNpZmllZFxuICogICBvbmx5IGZvciAncHJvcGVydHknIGJpbmRpbmdzLCBzaW5jZSB0aGVzZSBtdXN0IGJlIGluaXRpYWxpemVkIGFzIHBhcnRcbiAqICAgb2YgYm9vdC11cClcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgLy8gQ3JlYXRlIGJpbmRpbmcgbWV0YWRhdGEgYW5kIGFkZCB0byBub2RlSW5mb1xuICBub2RlSW5mby5iaW5kaW5ncyA9IG5vZGVJbmZvLmJpbmRpbmdzIHx8IFtdO1xuICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgbm9kZUluZm8uYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgLy8gQWRkIGxpc3RlbmVyIGluZm8gdG8gYmluZGluZyBtZXRhZGF0YVxuICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICBsZXQge2V2ZW50LCBuZWdhdGV9ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyRXZlbnQgPSBldmVudCB8fCAoQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UodGFyZ2V0KSArICctY2hhbmdlZCcpO1xuICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gIH1cbiAgLy8gQWRkIFwicHJvcGFnYXRlXCIgcHJvcGVydHkgZWZmZWN0cyB0byB0ZW1wbGF0ZUluZm9cbiAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gIGZvciAobGV0IGk9MDsgaTxiaW5kaW5nLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzW2ldO1xuICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRoZSBnaXZlbiBgdGVtcGxhdGVJbmZvYCBmb3IgdGhlIGdpdmVuIGJpbmRpbmdcbiAqIHBhcnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICogICBydW5uaW5nIG9uXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGludG8gYG5vZGVJbmZvTGlzdGAgZm9yIHRoaXMgbm9kZVxuICovXG5mdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICBpZiAoIXBhcnQubGl0ZXJhbCkge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09ICdhdHRyaWJ1dGUnICYmIGJpbmRpbmcudGFyZ2V0WzBdID09PSAnLScpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBzdGFydGluZyBjaGFyYWN0ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgbGV0IGluZm8gPSB7IGluZGV4LCBiaW5kaW5nLCBwYXJ0LCBldmFsdWF0b3I6IGNvbnN0cnVjdG9yIH07XG4gICAgICBmb3IgKGxldCBqPTA7IGo8ZGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gcGFyc2VBcmcodHJpZ2dlcik7XG4gICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IuX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCB0cmlnZ2VyLnJvb3RQcm9wZXJ0eSwge1xuICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgIGluZm8sIHRyaWdnZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJiaW5kaW5nXCIgKHByb3BlcnR5L3BhdGggYmluZGluZykgZWZmZWN0LlxuICpcbiAqIE5vdGUgdGhhdCBiaW5kaW5nIHN5bnRheCBpcyBvdmVycmlkYWJsZSB2aWEgYF9wYXJzZUJpbmRpbmdzYCBhbmRcbiAqIGBfZXZhbHVhdGVCaW5kaW5nYC4gIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgX2V2YWx1YXRlQmluZGluZ2AgZm9yIGFueVxuICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAqIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIF9wYXRoXyBiaW5kaW5ncyB2aWEgY3VzdG9tIGJpbmRpbmcgcGFydHMsXG4gKiBhcyB0aGlzIGlzIHNwZWNpZmljIHRvIFBvbHltZXIncyBwYXRoIGJpbmRpbmcgc3ludGF4LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlTGlzdCBMaXN0IG9mIG5vZGVzIGFzc29jaWF0ZWQgd2l0aCBgbm9kZUluZm9MaXN0YCB0ZW1wbGF0ZVxuICogICBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQmluZGluZ0VmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzLCBub2RlTGlzdCkge1xuICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICBsZXQgYmluZGluZyA9IGluZm8uYmluZGluZztcbiAgbGV0IHBhcnQgPSBpbmZvLnBhcnQ7XG4gIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAvLyBlLmcuOiBmb289XCJ7e29iai5zdWJ9fVwiLCBwYXRoOiAnb2JqLnN1Yi5wcm9wJywgc2V0ICdmb28ucHJvcCc9b2JqLnN1Yi5wcm9wXG4gIGlmIChoYXNQYXRocyAmJiBwYXJ0LnNvdXJjZSAmJiAocGF0aC5sZW5ndGggPiBwYXJ0LnNvdXJjZS5sZW5ndGgpICYmXG4gICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvcltiaW5kaW5nLnRhcmdldF0pIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twYXRoXTtcbiAgICBwYXRoID0gdHJhbnNsYXRlKHBhcnQuc291cmNlLCBiaW5kaW5nLnRhcmdldCwgcGF0aCk7XG4gICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgdmFsdWUgPSBpbmZvLmV2YWx1YXRvci5fZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgIC8vIFByb3BhZ2F0ZSB2YWx1ZSB0byBjaGlsZFxuICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhbiBcImJpbmRpbmdcIiAoYmluZGluZykgZWZmZWN0IHRvIGEgbm9kZSxcbiAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSBvd25pbmcgdGhlIGJpbmRpbmcgZWZmZWN0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGFyZ2V0IG5vZGUgZm9yIGJpbmRpbmdcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpIHtcbiAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgaWYgKHNhbml0aXplRE9NVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNhbml0aXplRE9NVmFsdWUodmFsdWUsIGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLmtpbmQsIG5vZGUpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ1xuICAgIGluc3QuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8obm9kZSksIHZhbHVlLCBiaW5kaW5nLnRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvcGVydHkgYmluZGluZ1xuICAgIGxldCBwcm9wID0gYmluZGluZy50YXJnZXQ7XG4gICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgaWYgKCFub2RlW1RZUEVTLlJFQURfT05MWV0gfHwgIW5vZGVbVFlQRVMuUkVBRF9PTkxZXVtwcm9wXSkge1xuICAgICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgIHtcbiAgICAgIGluc3QuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gKiBlZmZlY3QgbWV0YWRhdGEsIGFzIHdlbGwgYXMgaGFuZGxpbmcgZm9yIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEByZXR1cm4geyp9IFRyYW5zZm9ybWVkIHZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCkge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgc3RvcmFnZVtwYXJ0LmNvbXBvdW5kSW5kZXhdID0gdmFsdWU7XG4gICAgdmFsdWUgPSBzdG9yYWdlLmpvaW4oJycpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgIT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZXJpYWxpemUgYHVuZGVmaW5lZGAgdG8gYFwidW5kZWZpbmVkXCJgXG4gICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgIChub2RlLmxvY2FsTmFtZSA9PSAnaW5wdXQnICYmIGJpbmRpbmcudGFyZ2V0ID09ICd2YWx1ZScpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBiaW5kaW5nJ3MgbWV0YWRhdGEgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgdG8gYWxsb3dcbiAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAqIGFkZGVkOlxuICogLSB1c2VkIGN1cmx5IGJyYWNlc1xuICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gKiAtIGlzIG5vdCBhIHRleHRDb250ZW50IGJpbmRpbmdcbiAqIC0gaXMgbm90IGNvbXBvdW5kXG4gKlxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIDItd2F5IGxpc3RlbmVyIHNob3VsZCBiZSBhZGRlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykge1xuICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgIGJpbmRpbmcua2luZCAhPSAnYXR0cmlidXRlJyAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICd0ZXh0JyAmJlxuICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgYmluZGluZy5wYXJ0c1swXS5tb2RlID09PSAneyc7XG59XG5cbi8qKlxuICogU2V0dXAgY29tcG91bmQgYmluZGluZyBzdG9yYWdlIHN0cnVjdHVyZXMsIG5vdGlmeSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdFxuICogcmVmZXJlbmNlcyBvbnRvIHRoZSBib3VuZCBub2RlTGlzdC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRoYXQgYmFzIGJlZW4gcHJldmlvdXNseSBib3VuZFxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBCaW5kaW5ncyhpbnN0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gIGxldCB7bm9kZUxpc3QsIG5vZGVJbmZvTGlzdH0gPSB0ZW1wbGF0ZUluZm87XG4gIGlmIChub2RlSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaW5mbyA9IG5vZGVJbmZvTGlzdFtpXTtcbiAgICAgIGxldCBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZyk7XG4gICAgICAgICAgYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuX19kYXRhSG9zdCA9IGluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYF9fZGF0YUNvbXBvdW5kU3RvcmFnZWAgbG9jYWwgc3RvcmFnZSBvbiBhIGJvdW5kIG5vZGUgd2l0aFxuICogaW5pdGlhbCBsaXRlcmFsIGRhdGEgZm9yIGNvbXBvdW5kIGJpbmRpbmdzLCBhbmQgc2V0cyB0aGUgam9pbmVkXG4gKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAqXG4gKiBXaGVuIGNoYW5nZXMgdG8gY29tcG91bmQgcGFydHMgb2NjdXIsIHRoZXkgYXJlIGZpcnN0IHNldCBpbnRvIHRoZSBjb21wb3VuZFxuICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAqIHRoZSBmaW5hbCB2YWx1ZSBzZXQgdG8gdGhlIHByb3BlcnR5L2F0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fFxuICAgICAgKG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlID0ge30pO1xuICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgLy8gQ29weSBsaXRlcmFscyBmcm9tIHBhcnRzIGludG8gc3RvcmFnZSBmb3IgdGhpcyBiaW5kaW5nXG4gICAgbGV0IGxpdGVyYWxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaXRlcmFsc1tqXSA9IHBhcnRzW2pdLmxpdGVyYWw7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBzdG9yYWdlW3RhcmdldF0gPSBsaXRlcmFscztcbiAgICAvLyBDb25maWd1cmUgcHJvcGVydGllcyB3aXRoIHRoZWlyIGxpdGVyYWwgcGFydHNcbiAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICBub2RlW3RhcmdldF0gPSBiaW5kaW5nLmxpdGVyYWw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIENoaWxkIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5saXN0ZW5lckV2ZW50KSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmxpc3RlbmVyRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihlLCBpbnN0LCBiaW5kaW5nLnRhcmdldCwgcGFydC5zb3VyY2UsIHBhcnQubmVnYXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyBmb3IgZWFjaCBhcmd1bWVudCBpbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSAoYW5kXG4gKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICogcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHByb3BlcnR5IGVmZmVjdCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAqIEBwYXJhbSB7Kj19IG1ldGhvZEluZm8gRWZmZWN0LXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluXG4gKiAgIG1ldGhvZCBlZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LiBOb3RlLFxuICogICBkZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgc3RhdGljIChzaWcuc3RhdGljIGlzIHRydWUpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRWZmZWN0KG1vZGVsLCBzaWcsIHR5cGUsIGVmZmVjdEZuLCBtZXRob2RJbmZvLCBkeW5hbWljRm4pIHtcbiAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgKHR5cGVvZiBkeW5hbWljRm4gIT09ICdvYmplY3QnIHx8IGR5bmFtaWNGbltzaWcubWV0aG9kTmFtZV0pKTtcbiAgbGV0IGluZm8gPSB7XG4gICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgYXJnczogc2lnLmFyZ3MsXG4gICAgbWV0aG9kSW5mbyxcbiAgICBkeW5hbWljRm5cbiAgfTtcbiAgZm9yIChsZXQgaT0wLCBhcmc7IChpPHNpZy5hcmdzLmxlbmd0aCkgJiYgKGFyZz1zaWcuYXJnc1tpXSk7IGkrKykge1xuICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChhcmcucm9vdFByb3BlcnR5LCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mbywgdHJpZ2dlcjogYXJnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGR5bmFtaWNGbikge1xuICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChzaWcubWV0aG9kTmFtZSwgdHlwZSwge1xuICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyBtYXJzaGFsZWQgZnJvbSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZVxuICogYmFzZWQgb24gdGhlIG1ldGhvZCBzaWduYXR1cmUgY29udGFpbmVkIGluIHRoZSBlZmZlY3QgbWV0YWRhdGEuXG4gKlxuICogTXVsdGktcHJvcGVydHkgb2JzZXJ2ZXJzLCBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICogZnVuY3Rpb25zIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBpbnZva2UgdGhlIG1ldGhvZCwgdGhlbiB1c2UgdGhlIHJldHVyblxuICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbWV0aG9kIGludm9jYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBsZXQgY29udGV4dCA9IGluc3QuX21ldGhvZEhvc3QgfHwgaW5zdDtcbiAgbGV0IGZuID0gY29udGV4dFtpbmZvLm1ldGhvZE5hbWVdO1xuICBpZiAoZm4pIHtcbiAgICBsZXQgYXJncyA9IG1hcnNoYWxBcmdzKGluc3QuX19kYXRhLCBpbmZvLmFyZ3MsIHByb3BlcnR5LCBwcm9wcyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2FybignbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5cbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgYmluZGluZ1xuY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbmNvbnN0IE5VTUJFUiA9ICcoPzonICsgJ1stK10/WzAtOV0qXFxcXC4/WzAtOV0rKD86W2VFXVstK10/WzAtOV0rKT8nICsgJyknO1xuY29uc3QgU1FVT1RFX1NUUklORyA9ICcoPzonICsgJ1xcJyg/OlteXFwnXFxcXFxcXFxdfFxcXFxcXFxcLikqXFwnJyArICcpJztcbmNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG5jb25zdCBTVFJJTkcgPSAnKD86JyArIFNRVU9URV9TVFJJTkcgKyAnfCcgKyBEUVVPVEVfU1RSSU5HICsgJyknO1xuY29uc3QgQVJHVU1FTlQgPSAnKD86KCcgKyBJREVOVCArICd8JyArIE5VTUJFUiArICd8JyArICBTVFJJTkcgKyAnKVxcXFxzKicgKyAnKSc7XG5jb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuY29uc3QgQVJHVU1FTlRfTElTVCA9ICcoPzonICsgJ1xcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIEFSR1VNRU5UUyArICc/JyArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbmNvbnN0IEJJTkRJTkcgPSAnKCcgKyBJREVOVCArICdcXFxccyonICsgQVJHVU1FTlRfTElTVCArICc/JyArICcpJzsgLy8gR3JvdXAgM1xuY29uc3QgT1BFTl9CUkFDS0VUID0gJyhcXFxcW1xcXFxbfHt7KScgKyAnXFxcXHMqJztcbmNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbmNvbnN0IE5FR0FURSA9ICcoPzooISlcXFxccyopPyc7IC8vIEdyb3VwIDJcbmNvbnN0IEVYUFJFU1NJT04gPSBPUEVOX0JSQUNLRVQgKyBORUdBVEUgKyBCSU5ESU5HICsgQ0xPU0VfQlJBQ0tFVDtcbmNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHN0cmluZyBmcm9tIGJpbmRpbmcgcGFydHMgb2YgYWxsIHRoZSBsaXRlcmFsIHBhcnRzXG4gKlxuICogQHBhcmFtIHshQXJyYXk8QmluZGluZ1BhcnQ+fSBwYXJ0cyBBbGwgcGFydHMgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBtYWRlIGZyb20gdGhlIGxpdGVyYWwgcGFydHNcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykge1xuICBsZXQgcyA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbGl0ZXJhbCA9IHBhcnRzW2ldLmxpdGVyYWw7XG4gICAgcyArPSBsaXRlcmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHN0cmluZyBmb3IgYSBtZXRob2Qgc2lnbmF0dXJlLCBhbmQgcmV0dXJucyBhIG1ldGFkYXRhXG4gKiBkZXNjcmliaW5nIHRoZSBtZXRob2QgaW4gdGVybXMgb2YgYG1ldGhvZE5hbWVgLCBgc3RhdGljYCAod2hldGhlciBhbGwgdGhlXG4gKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICogICBmb3VuZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU1ldGhvZChleHByZXNzaW9uKSB7XG4gIC8vIHRyaWVzIHRvIG1hdGNoIHZhbGlkIGphdmFzY3JpcHQgcHJvcGVydHkgbmFtZXNcbiAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgaWYgKG0pIHtcbiAgICBsZXQgbWV0aG9kTmFtZSA9IG1bMV07XG4gICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgaWYgKG1bMl0udHJpbSgpKSB7XG4gICAgICAvLyByZXBsYWNlIGVzY2FwZWQgY29tbWFzIHdpdGggY29tbWEgZW50aXR5LCBzcGxpdCBvbiB1bi1lc2NhcGVkIGNvbW1hc1xuICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgIHJldHVybiBwYXJzZUFyZ3MoYXJncywgc2lnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICogc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdC4gU2V0cyB0aGUgYHN0YXRpY2AgcHJvcGVydHkgdG8gZmFsc2UgaWYgYW55XG4gKiBhcmd1bWVudCBpcyBhIG5vbi1saXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGFyZ0xpc3QgQXJyYXkgb2YgYXJndW1lbnQgbmFtZXNcbiAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gIHNpZy5hcmdzID0gYXJnTGlzdC5tYXAoZnVuY3Rpb24ocmF3QXJnKSB7XG4gICAgbGV0IGFyZyA9IHBhcnNlQXJnKHJhd0FyZyk7XG4gICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgc2lnLnN0YXRpYyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gaW5kaXZpZHVhbCBhcmd1bWVudCwgYW5kIHJldHVybnMgYW4gYXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqICAge1xuICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAqICAgICBsaXRlcmFsOiBmYWxzZSwgICAgICAgLy8gd2hldGhlciBhcmd1bWVudCBpcyBhIGxpdGVyYWxcbiAqICAgICBzdHJ1Y3R1cmVkOiBmYWxzZSwgICAgLy8gd2hldGhlciB0aGUgcHJvcGVydHkgaXMgYSBwYXRoXG4gKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gKiAgICAgd2lsZGNhcmQ6IGZhbHNlICAgICAgIC8vIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHdhcyBhIHdpbGRjYXJkICcuKicgcGF0aFxuICogICB9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhd0FyZyBUaGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICogQHJldHVybiB7IU1ldGhvZEFyZ30gQXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZyhyYXdBcmcpIHtcbiAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICBsZXQgYXJnID0gcmF3QXJnLnRyaW0oKVxuICAgIC8vIHJlcGxhY2UgY29tbWEgZW50aXR5IHdpdGggY29tbWFcbiAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgLy8gcmVwYWlyIGV4dHJhIGVzY2FwZSBzZXF1ZW5jZXM7IG5vdGUgb25seSBjb21tYXMgc3RyaWN0bHkgbmVlZFxuICAgIC8vIGVzY2FwaW5nLCBidXQgd2UgYWxsb3cgYW55IG90aGVyIGNoYXIgdG8gYmUgZXNjYXBlZCBzaW5jZSBpdHNcbiAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgLnJlcGxhY2UoL1xcXFwoLikvZywgJ1xcJDEnKVxuICAgIDtcbiAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICBsZXQgYSA9IHtcbiAgICBuYW1lOiBhcmcsXG4gICAgdmFsdWU6ICcnLFxuICAgIGxpdGVyYWw6IGZhbHNlXG4gIH07XG4gIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gIGxldCBmYyA9IGFyZ1swXTtcbiAgaWYgKGZjID09PSAnLScpIHtcbiAgICBmYyA9IGFyZ1sxXTtcbiAgfVxuICBpZiAoZmMgPj0gJzAnICYmIGZjIDw9ICc5Jykge1xuICAgIGZjID0gJyMnO1xuICB9XG4gIHN3aXRjaChmYykge1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOlxuICAgICAgYS52YWx1ZSA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gaWYgbm90IGxpdGVyYWwsIGxvb2sgZm9yIHN0cnVjdHVyZWQgcGF0aFxuICBpZiAoIWEubGl0ZXJhbCkge1xuICAgIGEucm9vdFByb3BlcnR5ID0gcm9vdCQwKGFyZyk7XG4gICAgLy8gZGV0ZWN0IHN0cnVjdHVyZWQgcGF0aCAoaGFzIGRvdHMpXG4gICAgYS5zdHJ1Y3R1cmVkID0gaXNQYXRoJDAoYXJnKTtcbiAgICBpZiAoYS5zdHJ1Y3R1cmVkKSB7XG4gICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICBpZiAoYS53aWxkY2FyZCkge1xuICAgICAgICBhLm5hbWUgPSBhcmcuc2xpY2UoMCwgLTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICogb2YgYXJndW1lbnQgbWV0YWRhdGEuXG4gKlxuICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gKiB3aGVuIHRoZSBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIGEgcmVzdWx0IG9mIGEgcGF0aCBub3RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHshQXJyYXk8IU1ldGhvZEFyZz59IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggbmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgbWV0aG9kIGVmZmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBBcnJheSBvZiBhcmd1bWVudCB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxBcmdzKGRhdGEsIGFyZ3MsIHBhdGgsIHByb3BzKSB7XG4gIGxldCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgIGxldCBuYW1lID0gYXJnLm5hbWU7XG4gICAgbGV0IHY7XG4gICAgaWYgKGFyZy5saXRlcmFsKSB7XG4gICAgICB2ID0gYXJnLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLnN0cnVjdHVyZWQpIHtcbiAgICAgICAgdiA9IGdldCQwKGRhdGEsIG5hbWUpO1xuICAgICAgICAvLyB3aGVuIGRhdGEgaXMgbm90IHN0b3JlZCBlLmcuIGBzcGxpY2VzYFxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgLy8gT25seSBzZW5kIHRoZSBhY3R1YWwgcGF0aCBjaGFuZ2VkIGluZm8gaWYgdGhlIGNoYW5nZSB0aGF0XG4gICAgICAvLyBjYXVzZWQgdGhlIG9ic2VydmVyIHRvIHJ1biBtYXRjaGVkIHRoZSB3aWxkY2FyZFxuICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICBsZXQgbWF0Y2hlcyA9IChwYXRoLmluZGV4T2YobmFtZSkgPT09IDAgJiYgIWJhc2VDaGFuZ2VkKTtcbiAgICAgIHZhbHVlc1tpXSA9IHtcbiAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWF0Y2hlcyA/IHByb3BzW3BhdGhdIDogdixcbiAgICAgICAgYmFzZTogdlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2ldID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gZGF0YSBhcGlcblxuLyoqXG4gKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICpcbiAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBzcGxpY2VzKSB7XG4gIGxldCBzcGxpY2VzUGF0aCA9IHBhdGggKyAnLnNwbGljZXMnO1xuICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICBpbnN0Lm5vdGlmeVBhdGgocGF0aCArICcubGVuZ3RoJywgYXJyYXkubGVuZ3RoKTtcbiAgLy8gTnVsbCBoZXJlIHRvIGFsbG93IHBvdGVudGlhbGx5IGxhcmdlIHNwbGljZSByZWNvcmRzIHRvIGJlIEdDJ2VkLlxuICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAqIHRoZSBkZXNjcmliZWQgbXV0YXRpb25cbiAqXG4gKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRoZSBhcnJheSBtdXRhdGlvbiBvY2N1cnJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSByZW1vdmVkIEFycmF5IG9mIHJlbW92ZWQgaXRlbXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZShpbnN0LCBhcnJheSwgcGF0aCwgaW5kZXgsIGFkZGVkQ291bnQsIHJlbW92ZWQpIHtcbiAgbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgW3tcbiAgICBpbmRleDogaW5kZXgsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIG9iamVjdDogYXJyYXksXG4gICAgdHlwZTogJ3NwbGljZSdcbiAgfV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXItY2FzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN0cmluZyB0byB1cHBlcmNhc2VcbiAqIEByZXR1cm4ge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwcGVyKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xufVxuXG5leHBvcnQgY29uc3QgUHJvcGVydHlFZmZlY3RzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFRlbXBsYXRlU3RhbXAoUHJvcGVydHlBY2Nlc3NvcnMoc3VwZXJDbGFzcykpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqIEBleHRlbmRzIHtwcm9wZXJ0eUVmZmVjdHNCYXNlfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUVmZmVjdHMgZXh0ZW5kcyBwcm9wZXJ0eUVmZmVjdHNCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5O1xuICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgIC8qKiBAdHlwZSB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgICB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVRlbXA7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19jb21wdXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlZmxlY3RFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3Byb3BhZ2F0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19vYnNlcnZlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICByZXR1cm4gVFlQRVM7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICBob3N0U3RhY2sucmVnaXN0ZXJIb3N0KHRoaXMpO1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgIC8vIE1heSBiZSBzZXQgb24gaW5zdGFuY2UgcHJpb3IgdG8gdXBncmFkZVxuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gdGhpcy5fX2RhdGFIb3N0IHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgKiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBpbml0aWFsaXppbmcgcHJvcGVydGllcyBmcm9tXG4gICAgICogdGhlIHByb3RvdHlwZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgdGhpcy5fX2RhdGEgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIHNldHRpbmdcbiAgICAgKiBgX3NldFByb3BlcnR5YCdzIGBzaG91bGROb3RpZnk6IHRydWVgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgbGV0IHJlYWRPbmx5ID0gdGhpc1tUWVBFUy5SRUFEX09OTFldO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIXJlYWRPbmx5IHx8ICFyZWFkT25seVtwcm9wXSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHRoaXMuX19kYXRhUGVuZGluZyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BdID0gdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm90b3R5cGUgc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGFkZFByb3BlcnR5RWZmZWN0YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCB0eXBlID09IFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcHJvcGVydHkgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoZSBlZmZlY3Qgd2FzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgbGV0IGlkeCA9IGVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBwcm9wZXJ0eSBlZmZlY3RcbiAgICAgKiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3R5cGVdO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0cyAmJiBlZmZlY3RzW3Byb3BlcnR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlYWQgb25seVwiXG4gICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJub3RpZnlcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc05vdGlmeUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUmVmbGVjdEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwiY29tcHV0ZWRcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLkNPTVBVVEUpO1xuICAgIH1cblxuICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHBlbmRpbmcgcHJvcGVydHkgb3IgcGF0aC4gIElmIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoIGluXG4gICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAqIHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICogZm9yIHRoZSBwdWJsaWMgQVBJIChgc2V0YCwgYHNldFByb3BlcnRpZXNgLCBgbm90aWZ5UGF0aGAsIGFuZCBwcm9wZXJ0eVxuICAgICAqIGNoYW5nZSBsaXN0ZW5lcnMgdmlhIHt7Li4ufX0gYmluZGluZ3MpLCBzdWNoIHRoYXQgaXQgaXMgb25seSBkb25lXG4gICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAqIGFsc28gc2V0cyBhIGBfX2RhdGFIYXNQYXRoc2AgZmxhZyBvbiB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCB0b1xuICAgICAqIGZhc3QtcGF0aCBzbG93ZXIgcGF0aC1tYXRjaGluZyBjb2RlIGluIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIGhvc3QgcGF0aHMuXG4gICAgICpcbiAgICAgKiBgcGF0aGAgY2FuIGJlIGEgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2YgcGF0aCBwYXJ0cyBhcyBhY2NlcHRlZCBieSB0aGVcbiAgICAgKiBwdWJsaWMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgKiAgY2F1c2UgYSBwcm9wZXJ0eSBub3RpZmljYXRpb24gZXZlbnQgZGlzcGF0Y2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1BhdGhOb3RpZmljYXRpb24gSWYgdGhlIHBhdGggYmVpbmcgc2V0IGlzIGEgcGF0aFxuICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgKiAgIHRvIHNldCBhbmQgbm90aWZ5IHRoZSBjaGFuZ2UuICBJbiB0aGUgbGF0dGVyIGBmYWxzZWAgY2FzZSwgYSBkaXJ0eVxuICAgICAqICAgY2hlY2sgaXMgcGVyZm9ybWVkIGFuZCB0aGVuIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHBhdGggYmVmb3JlXG4gICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkvcGF0aCB3YXMgZW5xdWV1ZWQgaW5cbiAgICAgKiAgIHRoZSBwZW5kaW5nIGNoYW5nZXMgYmFnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBzaG91bGROb3RpZnksIGlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgIHJvb3QkMChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGgpICE9PSBwYXRoKSB7XG4gICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgcGF0aHMgaW50byB0aGUgc3lzdGVtOyBmcm9tIGhlcmVcbiAgICAgICAgLy8gdGhlIG9ubHkgZGlydHkgY2hlY2tzIGFyZSBhZ2FpbnN0IHRoZSBgX19kYXRhVGVtcGAgY2FjaGUgdG8gcHJldmVudFxuICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIC8vIG9mIGEgY2hhbmdlIGFscmVhZHkgc2V0IHRvIGEgcGF0aCAoaXNQYXRoTm90aWZpY2F0aW9uOiB0cnVlKSxcbiAgICAgICAgLy8gd2UgYWx3YXlzIGxldCB0aGUgY2hhbmdlIHRocm91Z2ggYW5kIHNraXAgdGhlIGBzZXRgIHNpbmNlIGl0IHdhc1xuICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmICghaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbGV0IG9sZCA9IGdldCQwKHRoaXMsIHBhdGgpO1xuICAgICAgICAgIHBhdGggPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNldCQwKHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgLy8gVXNlIHByb3BlcnR5LWFjY2Vzc29yJ3Mgc2ltcGxlciBkaXJ0eSBjaGVja1xuICAgICAgICAgIGlmICghcGF0aCB8fCAhc3VwZXIuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHBhdGgsIHZhbHVlLCBvbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSkpIHtcbiAgICAgICAgICBjb21wdXRlTGlua2VkUGF0aHModGhpcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG1ha2VzIGEgYmVzdC1lZmZvcnQgYXQgYmluZGluZyBpbnRlcm9wOlxuICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICogcmUtc2V0dGluZyB0aGUgc2FtZSB2YWx1ZSAoZS5nLiBzZXR0aW5nIGA8aW5wdXQ+LnZhbHVlYCByZXNldHMgdGhlXG4gICAgICogY3Vyc29yIHBvc2l0aW9uKSwgc28gd2UgZG8gYSBkaXJ0eS1jaGVjayBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUuXG4gICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgKiBhY2NlcHQgb2JqZWN0cywgd2UgZXhwbGljaXRseSByZS1zZXQgb2JqZWN0IGNoYW5nZXMgY29taW5nIGZyb20gdGhlXG4gICAgICogUG9seW1lciB3b3JsZCAod2hpY2ggbWF5IGluY2x1ZGUgZGVlcCBvYmplY3QgY2hhbmdlcyB3aXRob3V0IHRoZVxuICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIC8vIEl0IGlzIGEganVkZ21lbnQgY2FsbCB0aGF0IHJlc2V0dGluZyBwcmltaXRpdmVzIGlzXG4gICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgLy8gaW1wbGVtZW50IGEgd2hpdGVsaXN0IG9mIHRhZyAmIHByb3BlcnR5IHZhbHVlcyB0aGF0IHNob3VsZCBuZXZlclxuICAgICAgLy8gYmUgcmVzZXQgKGUuZy4gPGlucHV0Pi52YWx1ZSAmJiA8c2VsZWN0Pi52YWx1ZSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBpbnRyb2R1Y2Ugc3BlY2lhbFxuICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICpcbiAgICAgKiAxLiBBbnkgdmFsdWUgc2V0IHRvIGEgcGF0aCAoZS5nLiAnb2JqLnByb3AnOiA0MiBvciAnb2JqLnByb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICogMi4gT2JqZWN0IHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgIGFuZCBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0XG4gICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgKiAzLiBQcmltaXRpdmUgdmFsdWUgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IDQyKVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFgXG4gICAgICpcbiAgICAgKiBUaGUgZGlydHktY2hlY2sgaXMgaW1wb3J0YW50IHRvIHByZXZlbnQgY3ljbGVzIGR1ZSB0byB0d28td2F5XG4gICAgICogbm90aWZpY2F0aW9uLCBidXQgcGF0aHMgYW5kIG9iamVjdHMgYXJlIG9ubHkgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGFueVxuICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAqIGNsZWFyZWQgd2hlbiB0aGUgbGFzdCBgX3Byb3BlcnRpZXNDaGFnZWRgIGV4aXRzLiBUaGlzIGlzIHNvOlxuICAgICAqIGEuIGFueSBjYWNoZWQgYXJyYXkgcGF0aHMgKGUuZy4gJ2FycmF5LjMucHJvcCcpIG1heSBiZSBpbnZhbGlkYXRlZFxuICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICogICAgc2luY2UgcGF0aCBjaGFuZ2VzIGFyZSBkaXJ0eS1jaGVja2VkIGF0IHVzZXIgZW50cnkgcG9pbnRzIGxpa2UgYHNldGBcbiAgICAgKiBiLiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBvbmx5IGxhc3RzIG9uZSB0dXJuIHRvIGFsbG93IHRoZSB1c2VyXG4gICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICogICAgYW5kIGhhdmUgYWxsIHN1Yi1wcm9wZXJ0aWVzIHJlLXByb3BhZ2F0ZWQgaW4gYSBzdWJzZXF1ZW50IHR1cm4uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgKiBwYXRocywgc2luY2UgYSBzcGxpY2UgY2FuIGhhcHBlbiBkdXJpbmcgdGhlIHNhbWUgdHVybiAod2l0aCBwYXRob2xvZ2ljYWxcbiAgICAgKiB1c2VyIGNvZGUpOyB3ZSBjb3VsZCBpbnRyb2R1Y2UgYSBcImZpeHVwXCIgZm9yIHRlbXBvcmFyaWx5IGNhY2hlZCBhcnJheVxuICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgVHJ1ZSBpZiBwcm9wZXJ0eSBzaG91bGQgZmlyZSBub3RpZmljYXRpb25cbiAgICAgKiAgIGV2ZW50IChhcHBsaWVzIG9ubHkgZm9yIGBub3RpZnk6IHRydWVgIHByb3BlcnRpZXMpXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgbGV0IGlzUGF0aCA9IHRoaXMuX19kYXRhSGFzUGF0aHMgJiYgaXNQYXRoJDAocHJvcGVydHkpO1xuICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgcHJldlByb3BzW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICghKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXRocyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2YgdHVybiksXG4gICAgICAgIC8vIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nLCBhbGwgb3RoZXJzIHN0b3JlZCBpbiBfX2RhdGFcbiAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgY2hhbmdlcyBnbyBpbnRvIHBlbmRpbmcgcHJvcGVydHkgYmFnLCBwYXNzZWQgdG8gX3Byb3BlcnRpZXNDaGFuZ2VkXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgLy8gVHJhY2sgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3RpZnkgc2VwYXJhdGVseVxuICAgICAgICBpZiAoaXNQYXRoIHx8ICh0aGlzW1RZUEVTLk5PVElGWV0gJiYgdGhpc1tUWVBFUy5OT1RJRlldW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5W3Byb3BlcnR5XSA9IHNob3VsZE5vdGlmeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgYWxsIGFjY2Vzc29ycyBzZXQgYHNob3VsZE5vdGlmeWBcbiAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcmAncyBkZWZhdWx0IGFzeW5jIHF1ZXVpbmcgb2ZcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYDogaWYgYF9fZGF0YVJlYWR5YCBpcyBmYWxzZSAoaGFzIG5vdCB5ZXQgYmVlblxuICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIHN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2xpZW50IG9uIGEgbGlzdCBvZiBwZW5kaW5nIGNsaWVudHMsIHdob3NlXG4gICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgKiBgX2ZsdXNoQ2xpZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzIHx8IFtdO1xuICAgICAgaWYgKGNsaWVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFueSBjbGllbnRzIHByZXZpb3VzbHkgZW5xdWV1ZWQgdmlhIGBfZW5xdWV1ZUNsaWVudGAsIGNhdXNpbmdcbiAgICAgKiB0aGVpciBgX2ZsdXNoUHJvcGVydGllc2AgbWV0aG9kIHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCB3aGVyZSBhY2Nlc3NvcnMgYXJlIHR1cm5lZCBvbjsgaW1wb3J0YW50bHksXG4gICAgICAgIC8vIHRoaXMgaXMgYWZ0ZXIgY2xpZW50cyBoYXZlIGZ1bGx5IHJlYWRpZWQsIHByb3ZpZGluZyBhIGd1YXJhbnRlZVxuICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAvLyBoYW5kbGVzIHR3byBjb3JuZXIgY2FzZXM6XG4gICAgLy8gKDEpIGNsaWVudHMgZmx1c2ggcHJvcGVybHkgd2hlbiBjb25uZWN0ZWQvZW5hYmxlZCBiZWZvcmUgdGhlIGhvc3RcbiAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgLy8gICAoYSkgVGVtcGxhdGl6ZSBzdGFtcHMgd2l0aCBubyBwcm9wZXJ0aWVzIGFuZCBkb2VzIG5vdCBmbHVzaCBhbmRcbiAgICAvLyAgIChiKSB0aGUgaW5zdGFuY2UgaXMgaW5zZXJ0ZWQgaW50byBkb20gYW5kXG4gICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAvLyAoMikgY2xpZW50cyBlbmFibGUgcHJvcGVybHkgd2hlbiBub3QgY29ubmVjdGVkL2VuYWJsZWQgd2hlbiB0aGUgaG9zdFxuICAgIC8vIGZsdXNoZXM7IGUuZy5cbiAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgIC8vICAgKGIpIGEgaG9zdCBzZXRzIGEgcHJvcGVydHksIGNhdXNpbmcgc3RhbXBlZCBkb20gdG8gZmx1c2hcbiAgICAvLyAgIChjKSB0aGUgc3RhbXBlZCBkb20gZW5hYmxlcy5cbiAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgbGV0IGNsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgaWYgKGNsaWVudHMpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgY2xpZW50ID0gY2xpZW50c1tpXTtcbiAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICBjbGllbnQuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudC5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgKiBgX2ZsdXNoUHJvcGVydGllc2AgY2FsbCBvbiBjbGllbnQgZG9tIGFuZCBiZWZvcmUgYW55IGVsZW1lbnRcbiAgICAgKiBvYnNlcnZlcnMgYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGJhZyBvZiBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHRoaXMgaW5zdGFuY2UsIGFuZFxuICAgICAqIHN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzIGFsbCBlZmZlY3RzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIGEgYmF0Y2guXG4gICAgICpcbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtdXN0IGJlIHNpbXBsZSBwcm9wZXJ0aWVzLCBub3QgcGF0aHMuICBCYXRjaGVkXG4gICAgICogcGF0aCBwcm9wYWdhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBvbmUgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2hvc2Uga2V5IGlzXG4gICAgICogICBhIHByb3BlcnR5IGFuZCB2YWx1ZSBpcyB0aGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgKiAgIGBwcm9wc2Agd2lsbCBiZSBzZXQuIEJ5IGRlZmF1bHQsIGBzZXRQcm9wZXJ0aWVzYCB3aWxsIG5vdCBzZXRcbiAgICAgKiAgIGByZWFkT25seTogdHJ1ZWAgcm9vdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKHByb3BzLCBzZXRSZWFkT25seSkge1xuICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2V0UmVhZE9ubHkgfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldW3BhdGhdKSB7XG4gICAgICAgICAgLy9UT0RPKGtzY2hhYWYpOiBleHBsaWNpdGx5IGRpc2FsbG93IHBhdGhzIGluIHNldFByb3BlcnR5P1xuICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAvLyBpbiB0aGUgYGluZm9gIG9iamVjdCwgYW5kIHlvdSBjb3VsZCBkbyBzb21lIG9kZCB0aGluZ3MgYmF0Y2hpbmdcbiAgICAgICAgICAvLyBwYXRocywgZS5nLiB7J2Zvby5iYXInOiB7Li4ufSwgJ2Zvbyc6IG51bGx9XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICogc2lkZSBlZmZlY3RzIGFyZSBub3QgZW5hYmxlZCB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGZ1bGx5IHJlYWR5LlxuICAgICAqIEFsc28gY2FsbHMgYF9mbHVzaENsaWVudHNgIGNhbGxiYWNrIHRvIGVuc3VyZSBjbGllbnQgZG9tIGlzIGVuYWJsZWRcbiAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCBgc3VwZXIucmVhZHkoKWAgaXMgbm90IGNhbGxlZCBoZXJlIGFzIGl0XG4gICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgIC8vIHRvIGVuYWJsZSBhY2Nlc3NvcnMgdG8gcHJvdmlkZSBhIGd1YXJhbnRlZSB0aGF0IGNsaWVudHMgYXJlIHJlYWR5XG4gICAgICAvLyBiZWZvcmUgcHJvY2Vzc2luZyBhbnkgYWNjZXNzb3JzIHNpZGUgZWZmZWN0cy5cbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgLy8gSWYgbm8gZGF0YSB3YXMgcGVuZGluZywgYF9mbHVzaFByb3BlcnRpZXNgIHdpbGwgbm90IGBmbHVzaENsaWVudHNgXG4gICAgICAvLyBzbyBlbnN1cmUgdGhpcyBpcyBkb25lLlxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgIC8vIFRoZXJlZm9yZSBhIGZsdXNoIGlzIG5lY2Vzc2FyeSBoZXJlIGlmIGRhdGEgaGFzIGJlZW4gc2V0LlxuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUFjY2Vzc29yc2AncyBwcm9wZXJ0aWVzIGNoYW5nZWQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAqIGEgc3BlY2lmaWMgb3JkZXIgKGNvbXB1dGUsIHByb3BhZ2F0ZSwgcmVmbGVjdCwgb2JzZXJ2ZSwgbm90aWZ5KS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGxldCBjID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhbmdlZFByb3BzIHx8IHt9KTtcbiAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGxldCBoYXNQYXRocyA9IHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAvLyBDb21wdXRlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkNvbXB1dGVkRWZmZWN0cyh0aGlzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgLy8gYnV0IGFmdGVyIGNvbXB1dGluZyBlZmZlY3RzIGhhdmUgYSBjaGFuY2UgdG8gYWRkIHRvIHRoZW1cbiAgICAgIGxldCBub3RpZnlQcm9wcyA9IHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIC8vIFByb3BhZ2F0ZSBwcm9wZXJ0aWVzIHRvIGNsaWVudHNcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIC8vIFJlZmxlY3QgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBPYnNlcnZlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5PQlNFUlZFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgaWYgKG5vdGlmeVByb3BzKSB7XG4gICAgICAgIHJ1bk5vdGlmeUVmZmVjdHModGhpcywgbm90aWZ5UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIHRlbXBvcmFyeSBjYWNoZSBhdCBlbmQgb2YgdHVyblxuICAgICAgaWYgKHRoaXMuX19kYXRhQ291bnRlciA9PSAxKSB7XG4gICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwcm9wYWdhdGUgYW55IHByb3BlcnR5IGNoYW5nZXMgdG8gc3RhbXBlZCB0ZW1wbGF0ZSBub2Rlc1xuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgaWYgKHRoaXNbVFlQRVMuUFJPUEFHQVRFXSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUFJPUEFHQVRFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB3aGlsZSAodGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICBoYXNQYXRocywgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgKiBhcmUgcm91dGVkIHRvIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBmcm9tIFNvdXJjZSBwYXRoIHRvIGxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxpbmtQYXRocyh0bywgZnJvbSkge1xuICAgICAgdG8gPSBub3JtYWxpemUodG8pO1xuICAgICAgZnJvbSA9IG5vcm1hbGl6ZShmcm9tKTtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzIHx8IHt9O1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBwYXRoIHRvIHVubGluayBzaG91bGQgYmUgdGhlIHRhcmdldCAoYHRvYCkgdXNlZCB3aGVuXG4gICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBUYXJnZXQgcGF0aCB0byB1bmxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVubGlua1BhdGhzKHBhdGgpIHtcbiAgICAgIHBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1twYXRoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhhdCBhbiBhcnJheSBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICB0aGlzLml0ZW1zLnNwbGljZSgxLCAxLCB7bmFtZTogJ1NhbSd9KTtcbiAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVNwbGljZXMoJ2l0ZW1zJywgW1xuICAgICAqICAgICAgIHsgaW5kZXg6IDEsIHJlbW92ZWQ6IFt7bmFtZTogJ1RvZGQnfV0sIGFkZGVkQ291bnQ6IDEsIG9iZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJyB9LFxuICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIG9yZGVyZWRcbiAgICAgKiAgIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB0byB0aGUgYXJyYXkuIEVhY2ggcmVjb3JkIHNob3VsZCBoYXZlIHRoZVxuICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAgICAqIGluZGV4OiBpbmRleCBhdCB3aGljaCB0aGUgY2hhbmdlIG9jY3VycmVkXG4gICAgICogICAgKiByZW1vdmVkOiBhcnJheSBvZiBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAqICAgICogb2JqZWN0OiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgaW4gcXVlc3Rpb25cbiAgICAgKiAgICAqIHR5cGU6IHRoZSBzdHJpbmcgbGl0ZXJhbCAnc3BsaWNlJ1xuICAgICAqXG4gICAgICogICBOb3RlIHRoYXQgc3BsaWNlIHJlY29yZHMgX211c3RfIGJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZXkgYXJlXG4gICAgICogICByZXBvcnRlZCBpbiBpbmRleCBvcmRlciAocmF3IHJlc3VsdHMgZnJvbSBgT2JqZWN0Lm9ic2VydmVgIGFyZSBub3RcbiAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICogQHB1YmxpY1xuICAgICovXG4gICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBub3RpZnlTcGxpY2VzKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHNwbGljZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVhZGluZyBhIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW4gZGVyZWZlcmVuY2luZyB1bmRlZmluZWRcbiAgICAgKiBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byByZWFkLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgZm9vLmJhci5iYXpgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgdXNlcnMuMTIubmFtZWAgb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgKiAgIGlzIHVuZGVmaW5lZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIHJvb3QpIHtcbiAgICAgIHJldHVybiBnZXQkMChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAqIGVsZW1lbnRzIGJvdW5kIHRvIHRoZSBzYW1lIHBhdGguXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgKiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW5cbiAgICAgKiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZCBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byB3cml0ZS4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYCdmb28uYmFyLmJheidgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgJ3VzZXJzLjEyLm5hbWUnYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiAgIFdoZW4gc3BlY2lmaWVkLCBubyBub3RpZmljYXRpb24gd2lsbCBvY2N1ci5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBzZXQocGF0aCwgdmFsdWUsIHJvb3QpIHtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHNldCQwKHJvb3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgZW5kIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBwdXNoIG9udG8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucHVzaCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBsZW4sIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcG9wKHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucG9wKCk7XG4gICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBhcnJheS5sZW5ndGgsIDAsIFtyZXRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAqIGZyb20gdGhlIGFycmF5IGFuZCBpbnNlcnRzIDAgb3IgbW9yZSBuZXcgaXRlbXMgaW4gdGhlaXIgcGxhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgSW5kZXggZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZy9pbnNlcnRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50IE51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3BsaWNlKHBhdGgsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGggOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAvLyBOb3JtYWxpemUgZmFuY3kgbmF0aXZlIHNwbGljZSBoYW5kbGluZyBvZiBjcmF6eSBzdGFydCB2YWx1ZXNcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBhcnJheS5sZW5ndGggLSBNYXRoLmZsb29yKC1zdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzdGFydCwgaXRlbXMubGVuZ3RoLCByZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2hpZnQocGF0aCkge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5zaGlmdCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bnNoaWZ0KHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB0aGlzLml0ZW0udXNlci5uYW1lID0gJ0JvYic7XG4gICAgICogICAgIHRoaXMubm90aWZ5UGF0aCgnaXRlbS51c2VyLm5hbWUnKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgVmFsdWUgYXQgdGhlIHBhdGggKG9wdGlvbmFsKS5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBub3RpZnlQYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCBwcm9wUGF0aDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIHZhbHVlID0gZ2V0JDAodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgIHByb3BQYXRoID0gaW5mby5wYXRoO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICBwcm9wUGF0aCA9IG5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXRoID0gLyoqIEB0eXBle3N0cmluZ30gKi8ocGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3BQYXRoLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICBpZiAocHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IHByb3BlcnR5fVxuICAgICAgfSk7XG4gICAgICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KG1ldGhvZE5hbWUsIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgb2JzZXJ2ZXIgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuT0JTRVJWRSwgcnVuTWV0aG9kRWZmZWN0LCBudWxsLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgIGZuOiBydW5Ob3RpZnlFZmZlY3QsXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICBsZXQgYXR0ciA9IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KTtcbiAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSAnICsgcHJvcGVydHkgKyAnIGNhbm5vdCBiZSByZWZsZWN0ZWQgdG8gYXR0cmlidXRlICcgK1xuICAgICAgICAgIGF0dHIgKyAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgc3RhcnRpbmcgYXR0cmlidXRlIG5hbWUuIFVzZSBhIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSB0aGlzZWFkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QsIHtcbiAgICAgICAgICBmbjogcnVuUmVmbGVjdEVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBhdHRyTmFtZTogYXR0clxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgY29tcHV0ZWQgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuQ09NUFVURSwgcnVuQ29tcHV0ZWRFZmZlY3QsIHByb3BlcnR5LCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhbiBhY2Nlc3NvciBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGFuZCBhZGRzXG4gICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyBzZXQuICBFZmZlY3RzIGFyZSBncm91cGVkIGJ5IFwidHlwZVwiLCB3aGljaFxuICAgICAqIHJvdWdobHkgY29ycmVzcG9uZHMgdG8gYSBwaGFzZSBpbiBlZmZlY3QgcHJvY2Vzc2luZy4gIFRoZSBlZmZlY3RcbiAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAqXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBmbjogZWZmZWN0RnVuY3Rpb24sIC8vIFJlZmVyZW5jZSB0byBmdW5jdGlvbiB0byBjYWxsIHRvIHBlcmZvcm0gZWZmZWN0XG4gICAgICogICAgICAgaW5mbzogeyAuLi4gfSAgICAgICAvLyBFZmZlY3QgbWV0YWRhdGEgcGFzc2VkIHRvIGZ1bmN0aW9uXG4gICAgICogICAgICAgdHJpZ2dlcjogeyAgICAgICAgICAvLyBPcHRpb25hbCB0cmlnZ2VyaW5nIG1ldGFkYXRhOyBpZiBub3QgcHJvdmlkZWRcbiAgICAgKiAgICAgICAgIG5hbWU6IHN0cmluZyAgICAgIC8vIHRoZSBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIGEgd2lsZGNhcmRcbiAgICAgKiAgICAgICAgIHN0cnVjdHVyZWQ6IGJvb2xlYW5cbiAgICAgKiAgICAgICAgIHdpbGRjYXJkOiBib29sZWFuXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICogdHlwZTpcbiAgICAgKlxuICAgICAqIDEuIENPTVBVVEVcbiAgICAgKiAyLiBQUk9QQUdBVEVcbiAgICAgKiAzLiBSRUZMRUNUXG4gICAgICogNC4gT0JTRVJWRVxuICAgICAqIDUuIE5PVElGWVxuICAgICAqXG4gICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICpcbiAgICAgKiAgICAgZWZmZWN0RnVuY3Rpb24oaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICogZXhwcmVzc2lvbiwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHRcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmU6IGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYC4gIEVhY2ggYXJndW1lbnRcbiAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAqIHByb3RvdHlwZSAob3IgaW5zdGFuY2UpLCBvciBtYXkgYmUgYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAqIGV2ZW50cyB0byBub3RpZnkgb2YgY2hhbmdlcyB0byB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWQtb25seSBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyIChlLmcuIGBfc2V0TXlQcm9wKClgIGZvclxuICAgICAqIHByb3BlcnR5IGBteVByb3BgKSwgcGFzcyBgdHJ1ZWAgZm9yIGBwcm90ZWN0ZWRTZXR0ZXJgLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgdGhlIHByb3BlcnR5IHdpbGwgaGF2ZSBvdGhlciBwcm9wZXJ0eSBlZmZlY3RzLCB0aGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QsIGJlZm9yZSBhZGRpbmcgb3RoZXIgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiB0byBhIChkYXNoLWNhc2VkKSBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIGNoYW5nZXMuICBUaGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0IGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBmb3IgdGhlbSwgYW5kIHRoZW4gZW5zdXJlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIGNyZWF0ZWQgZm9yIGFueVxuICAgICAqIGRlcGVuZGVudCBwcm9wZXJ0aWVzIGluIHRoZSB0ZW1wbGF0ZS4gIEJpbmRpbmcgZWZmZWN0cyBmb3IgYm91bmRcbiAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICogdGVtcGxhdGVzIGNhbiBiZSBlZmZpY2llbnRseSBzdGFtcGVkIGFuZCB1bnN0YW1wZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAqICAgYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gYmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYmluZFRlbXBsYXRlYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIHRoZSBwcm90b3R5cGUgKGZvciBwcm90b3R5cGljYWwgdGVtcGxhdGVcbiAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgKiBhbmQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgcnVudGltZUJpbmRpbmc6IHRydWVgIGJ5IGBfc3RhbXBUZW1wbGF0ZWAgdG9cbiAgICAgKiBjcmVhdGUgYW5kIGxpbmsgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogICBiaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluc3RhbmNlQmluZGluZyBXaGVuIGZhbHNlIChkZWZhdWx0KSwgcGVyZm9ybXNcbiAgICAgKiAgIFwicHJvdG90eXBpY2FsXCIgYmluZGluZyBvZiB0aGUgdGVtcGxhdGUgYW5kIG92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHlcbiAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgKiAgIGBfc3RhbXBUZW1wbGF0ZWApLCB0aGUgdGVtcGxhdGUgaW5mbyBpcyBpbnN0YW5jZWQgYW5kIGxpbmtlZCBpbnRvXG4gICAgICogICB0aGUgbGlzdCBvZiBib3VuZCB0ZW1wbGF0ZXMuXG4gICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgKiAgIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBpbmZvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIGluc3RhbmNlQmluZGluZykge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAvLyBPcHRpbWl6YXRpb246IHNpbmNlIHRoaXMgaXMgY2FsbGVkIHR3aWNlIGZvciBwcm90by1ib3VuZCB0ZW1wbGF0ZXMsXG4gICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHJlY3JlYXRlIGFjY2Vzc29ycyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBwcmUtYm91bmRcbiAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlQmluZGluZykge1xuICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgLy8gYW5kIGxpbmsgaW50byBsaXN0IG9mIHRlbXBsYXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyhPYmplY3QuY3JlYXRlKHRlbXBsYXRlSW5mbykpO1xuICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgaWYgKCF3YXNQcmVCb3VuZCAmJiB0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCB8fCB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IGxhc3Q7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX190ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3BlcnR5IGVmZmVjdCB0byB0aGUgZ2l2ZW4gdGVtcGxhdGUgbWV0YWRhdGEsIHdoaWNoIGlzIHJ1blxuICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICogaGFzIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQgdmlhIGBfYmluZFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIHRvIGFkZCBlZmZlY3QgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgIGxldCBlZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgfHwge307XG4gICAgICBsZXQgcHJvcEVmZmVjdHMgPSBlZmZlY3RzW3Byb3BdID0gZWZmZWN0c1twcm9wXSB8fCBbXTtcbiAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAqIFBvbHltZXIgdGVtcGxhdGUgZmVhdHVyZXMsIGluY2x1ZGluZyBkYXRhIGJpbmRpbmdzLCBkZWNsYXJhdGl2ZSBldmVudFxuICAgICAqIGxpc3RlbmVycywgYW5kIHRoZSBgdGhpcy4kYCBtYXAgb2YgYGlkYCdzIHRvIG5vZGVzLiAgQSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICogRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICogYHNoYWR5Y3NzYCBwb2x5ZmlsbCBsaW1pdGF0aW9ucywgb25seSBzdHlsZXMgZnJvbSB0ZW1wbGF0ZXMgcHJlcGFyZWRcbiAgICAgKiB1c2luZyBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCB3aWxsIGJlIGNvcnJlY3RseSBwb2x5ZmlsbGVkIChzY29wZWRcbiAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAqIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBlbGVtZW50LiBBcyBzdWNoLFxuICAgICAqIGFueSBzdHlsZXMgcmVxdWlyZWQgYnkgaW4gcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlcyBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBjcmVhdGVkIGRvbSBpcyBgX2VucXVldWVDbGllbnRgJ2QgdG8gdGhpcyBlbGVtZW50IHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgIGhvc3RTdGFjay5iZWdpbkhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgZG9tID0gc3VwZXIuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyh0aGlzLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpKTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZS1pbnN0YW5jZS1zcGVjaWZpYyBkYXRhIHRvIGluc3RhbmNlZCB0ZW1wbGF0ZUluZm9cbiAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgIC8vIENhcHR1cmUgY2hpbGQgbm9kZXMgdG8gYWxsb3cgdW5zdGFtcGluZyBvZiBub24tcHJvdG90eXBpY2FsIHRlbXBsYXRlc1xuICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbj1kb20uZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgc2V0dXBCaW5kaW5ncyh0aGlzLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgLy8gRmx1c2ggcHJvcGVydGllcyBpbnRvIHRlbXBsYXRlIG5vZGVzIGlmIGFscmVhZHkgYm9vdGVkXG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIHRoaXMuX19kYXRhLCBudWxsLFxuICAgICAgICAgIGZhbHNlLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCB1bmJpbmRzIHRoZSBub2RlcyBwcmV2aW91c2x5IGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBEb2N1bWVudEZyYWdtZW50IHJldHVybmVkIGZyb20gYF9zdGFtcFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVN0YW1wZWRUZW1wbGF0ZX0gZG9tIERvY3VtZW50RnJhZ21lbnQgcHJldmlvdXNseSByZXR1cm5lZFxuICAgICAqICAgZnJvbSBgX3N0YW1wVGVtcGxhdGVgIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZXMgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlQm91bmREb20oZG9tKSB7XG4gICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IGRvbS50ZW1wbGF0ZUluZm87XG4gICAgICBpZiAodGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID09IHRlbXBsYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBzdGFtcGVkIG5vZGVzXG4gICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBgVGV4dE5vZGVgJ3MnIGB0ZXh0Q29udGVudGAuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3Mobm9kZS50ZXh0Q29udGVudCwgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGV4dENvbnRlbnQgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIC8vIE5PVEU6IGRlZmF1bHQgdG8gYSBzcGFjZSBoZXJlIHNvIHRoZSB0ZXh0Tm9kZSByZW1haW5zOyBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB8fCAnICc7XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAndGV4dCcsICd0ZXh0Q29udGVudCcsIHBhcnRzKTtcbiAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGF0dHJpYnV0ZXMuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3ModmFsdWUsIHRlbXBsYXRlSW5mbyk7XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgLy8gQXR0cmlidXRlIG9yIHByb3BlcnR5XG4gICAgICAgIGxldCBvcmlnTmFtZSA9IG5hbWU7XG4gICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gPT0gJyQnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGF0dHJpYnV0ZSBiaW5kaW5ncyB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgIGlmIChsaXRlcmFsICYmIGtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBhdHRyaWJ1dGUgYmVmb3JlIHJlbW92aW5nLCBzaW5jZSBJRSB3b24ndCBhbGxvdyByZW1vdmluZ1xuICAgICAgICAvLyBgdmFsdWVgIGF0dHJpYnV0ZSBpZiBpdCBwcmV2aW91c2x5IGhhZCBhIHZhbHVlIChjYW4ndFxuICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgIC8vIGNhbid0IGJlIHNldCB1c2luZyBzZXRBdHRyaWJ1dGUpXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiBvcmlnTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFubm90YXRpb25cbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAvLyBDYXNlIGhhY2tlcnk6IGF0dHJpYnV0ZXMgYXJlIGxvd2VyLWNhc2UsIGJ1dCBiaW5kIHRhcmdldHNcbiAgICAgICAgLy8gKHByb3BlcnRpZXMpIGFyZSBjYXNlIHNlbnNpdGl2ZS4gR2FtYml0IGlzIHRvIG1hcCBkYXNoLWNhc2UgdG9cbiAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5ncyBhcmUgZXhjZXB0ZWQuXG4gICAgICAgIGlmIChraW5kID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgbmFtZSA9IGRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIG5hbWUsIHBhcnRzLCBsaXRlcmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICogYXMgYF9ob3N0Xzxwcm9wZXJ0eT5gLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgLy8gTWVyZ2UgaG9zdCBwcm9wcyBpbnRvIG91dGVyIHRlbXBsYXRlIGFuZCBhZGQgYmluZGluZ3NcbiAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgbGV0IG1vZGUgPSAneyc7XG4gICAgICBmb3IgKGxldCBzb3VyY2UgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAncHJvcGVydHknLCAnX2hvc3RfJyArIHNvdXJjZSwgcGFydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICogdGV4dENvbnRlbnQpIGludG8gYmluZGluZyBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgKiBtZXRhZGF0YSAgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0ZXh0XG4gICAgICogYW5kIGFueSBcImxpdGVyYWxcIiB0ZXh0IGluIGJldHdlZW4uICBBbnkgbm9uLWxpdGVyYWwgcGFydHMgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICogZmllbGRzIG9mIGVhY2ggXCJwYXJ0XCIgaW4gdGhlIHJldHVybmVkIGFycmF5IGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgYmluZGluZyB0byB1cGRhdGVcbiAgICAgKiAtIGBsaXRlcmFsYCAtIFN0cmluZyBjb250YWluaW5nIHRleHQgaWYgdGhlIHBhcnQgcmVwcmVzZW50cyBhIGxpdGVyYWw7XG4gICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAqXG4gICAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBmb3IgdXNlIGJ5IGBfZXZhbHVhdGVCaW5kaW5nYCBtYXkgYmUgcHJvdmlkZWQgaW5cbiAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhhbmRsZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBiaW5kaW5nc1xuICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICogLSBQcm9wZXJ0eSBiaW5kaW5nOiBgW1twcm9wXV1gXG4gICAgICogLSBQYXRoIGJpbmRpbmc6IGBbW29iamVjdC5wcm9wXV1gXG4gICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAqIC0gVHdvLXdheSBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBge3twcm9wfX1gLCBge3tvYmplY3QucHJvcH19YCwgYHt7IXByb3B9fWAgb3IgYHt7IW9iamVjdC5wcm9wfX1gXG4gICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBgW1tjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWAsIGBbWyFjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIEN1cnJlbnQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHtBcnJheTwhQmluZGluZ1BhcnQ+fSBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZUJpbmRpbmdzKHRleHQsIHRlbXBsYXRlSW5mbykge1xuICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtO1xuICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAvLyBSZWdleCBtYXRjaGVzOlxuICAgICAgLy8gICAgICAgIEl0ZXJhdGlvbiAxOiAgSXRlcmF0aW9uIDI6XG4gICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgIC8vIG1bMl06ICcnICAgICAgICAgICAgJyEnXG4gICAgICAvLyBtWzNdOiAncHJvcCcgICAgICAgICdjb21wdXRlKGZvbyxiYXIpJ1xuICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCBsaXRlcmFsIHBhcnRcbiAgICAgICAgaWYgKG0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYmluZGluZyBwYXJ0XG4gICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IEJvb2xlYW4obVsyXSk7XG4gICAgICAgIGxldCBzb3VyY2UgPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgIGlmIChtb2RlID09ICd7JyAmJiAoY29sb24gPSBzb3VyY2UuaW5kZXhPZignOjonKSkgPiAwKSB7XG4gICAgICAgICAgbm90aWZ5RXZlbnQgPSBzb3VyY2Uuc3Vic3RyaW5nKGNvbG9uICsgMik7XG4gICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgY3VzdG9tRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICBsZXQge2FyZ3MsIG1ldGhvZE5hbWV9ID0gc2lnbmF0dXJlO1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucztcbiAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgc2lnbmF0dXJlLmR5bmFtaWNGbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFByb3BlcnR5IG9yIHBhdGhcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgZXZlbnQ6IG5vdGlmeUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIGEgZmluYWwgbGl0ZXJhbCBwYXJ0XG4gICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaXRlcmFsID0gdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGxpdGVyYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgKiBvbmUgb3IgbW9yZSBjaGFuZ2VkIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICogICBiaW5kaW5nIGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7QmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSB0aGUgYmluZGluZyBwYXJ0IGV2YWx1YXRlZCB0b1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgdmFsdWUgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBwYXJ0LnNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGggIT0gcGFydC5zb3VyY2UpIHtcbiAgICAgICAgdmFsdWUgPSBnZXQkMChpbnN0LCBwYXJ0LnNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzUGF0aHMgJiYgaXNQYXRoJDAocGF0aCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldCQwKGluc3QsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW5zdC5fX2RhdGFbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0Lm5lZ2F0ZSkge1xuICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIG1ha2UgYSB0eXBpbmcgZm9yIGNsb3N1cmUgOlBcbiAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICByZXR1cm4gUHJvcGVydHlFZmZlY3RzO1xufSk7XG5cbi8qKlxuICogSGVscGVyIGFwaSBmb3IgZW5xdWVpbmcgY2xpZW50IGRvbSBjcmVhdGVkIGJ5IGEgaG9zdCBlbGVtZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGNhbGxlZC4gRWxlbWVudHMgYXR0YWNoIHRoZWlyIGNsaWVudCBkb20gdG9cbiAqIHRoZW1zZWx2ZXMgYXQgYHJlYWR5YCB0aW1lIHdoaWNoIHJlc3VsdHMgZnJvbSB0aGlzIGZpcnN0IGZsdXNoLlxuICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gKiBjcmVhdGVzIGlzIGZsdXNoZWQgYmVmb3JlIHRoZSBlbGVtZW50IGl0c2VsZiAoaS5lLiBjbGllbnQgYHJlYWR5YFxuICogZmlyZXMgYmVmb3JlIGhvc3QgYHJlYWR5YCkuXG4gKlxuICogSG93ZXZlciwgaWYgYF9mbHVzaFByb3BlcnRpZXNgIGlzIGNhbGxlZCAqYmVmb3JlKiBhbiBlbGVtZW50IGlzIGNvbm5lY3RlZCxcbiAqIGFzIGZvciBleGFtcGxlIGBUZW1wbGF0aXplYCBkb2VzLCB0aGlzIG9yZGVyaW5nIGd1YXJhbnRlZSBjYW5ub3QgYmVcbiAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gKiByZWNlaXZlIGRhdGEgZG8gYmVjb21lIGVucXVldWVkIGNsaWVudHMgYW5kIGFyZSBwcm9wZXJseSBvcmRlcmVkIGJ1dFxuICogdW5ib3VuZCBlbGVtZW50cyBhcmUgbm90LilcbiAqXG4gKiBUbyBtYWludGFpbiB0aGUgZGVzaXJlZCBcImNsaWVudCBiZWZvcmUgaG9zdFwiIG9yZGVyaW5nIGd1YXJhbnRlZSBmb3IgdGhpc1xuICogY2FzZSB3ZSByZWx5IG9uIHRoZSBcImhvc3Qgc3RhY2suIENsaWVudCBub2RlcyByZWdpc3RlcnMgdGhlbXNlbHZlcyB3aXRoXG4gKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAqIGlzIHJlYWRpZWQgaW4gdGhlIHByb3BlciBvcmRlciwgbWFpbnRhaW5pbmcgdGhlIGRlc2lyZWQgZ3VhcmFudGVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmxldCBob3N0U3RhY2sgPSB7XG5cbiAgc3RhY2s6IFtdLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYWRkIHRvIGhvc3RTdGFja1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgcmVnaXN0ZXJIb3N0KGluc3QpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIGxldCBob3N0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtcbiAgICAgIGhvc3QuX2VucXVldWVDbGllbnQoaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goaW5zdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBlbmQgaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgZW5kSG9zdGluZyhpbnN0KSB7XG4gICAgbGV0IHN0YWNrTGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBsZXQgbmF0aXZlU2hhZG93ID0gISh3aW5kb3dbJ1NoYWR5RE9NJ10gJiYgd2luZG93WydTaGFkeURPTSddWydpblVzZSddKTtcbmV4cG9ydCBsZXQgbmF0aXZlQ3NzVmFyaWFibGVzO1xuXG4vKipcbiAqIEBwYXJhbSB7KFNoYWR5Q1NTT3B0aW9ucyB8IFNoYWR5Q1NTSW50ZXJmYWNlKT19IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIGNhbGNDc3NWYXJpYWJsZXMoc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzWydzaGltY3NzcHJvcGVydGllcyddKSB7XG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY2hyb21lIDQ5IGhhcyBzZW1pLXdvcmtpbmcgY3NzIHZhcnMsIGNoZWNrIGlmIGJveC1zaGFkb3cgd29ya3NcbiAgICAvLyBzYWZhcmkgOS4xIGhhcyBhIHJlY2FsYyBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTU3ODJcbiAgICAvLyBIb3dldmVyLCBzaGltIGNzcyBjdXN0b20gcHJvcGVydGllcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBTaGFkeURPTSBlbmFibGVkLFxuICAgIC8vIHNvIGZhbGwgYmFjayBvbiBuYXRpdmUgaWYgd2UgZG8gbm90IGRldGVjdCBTaGFkeURPTVxuICAgIC8vIEVkZ2UgMTU6IGN1c3RvbSBwcm9wZXJ0aWVzIHVzZWQgaW4gOjpiZWZvcmUgYW5kIDo6YWZ0ZXIgd2lsbCBhbHNvIGJlIHVzZWQgaW4gdGhlIHBhcmVudCBlbGVtZW50XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTI0MTQyNTcvXG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gbmF0aXZlU2hhZG93IHx8IEJvb2xlYW4oIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pICYmXG4gICAgICB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoJ2JveC1zaGFkb3cnLCAnMCAwIDAgdmFyKC0tZm9vKScpKTtcbiAgfVxufVxuXG5pZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MgIT09IHVuZGVmaW5lZCkge1xuICBuYXRpdmVDc3NWYXJpYWJsZXMgPSB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzO1xufSBlbHNlIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgY2FsY0Nzc1ZhcmlhYmxlcyh3aW5kb3cuU2hhZHlDU1MpO1xuICAvLyByZXNldCB3aW5kb3cgdmFyaWFibGUgdG8gbGV0IFNoYWR5Q1NTIEFQSSB0YWtlIGl0cyBwbGFjZVxuICB3aW5kb3cuU2hhZHlDU1MgPSB1bmRlZmluZWQ7XG59IGVsc2Uge1xuICBjYWxjQ3NzVmFyaWFibGVzKHdpbmRvd1snV2ViQ29tcG9uZW50cyddICYmIHdpbmRvd1snV2ViQ29tcG9uZW50cyddWydmbGFncyddKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS1zZXR0aW5ncy5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qXG5FeHRyZW1lbHkgc2ltcGxlIGNzcyBwYXJzZXIuIEludGVuZGVkIHRvIGJlIG5vdCBtb3JlIHRoYW4gd2hhdCB3ZSBuZWVkXG5hbmQgZGVmaW5pdGVseSBub3QgbmVjZXNzYXJpbHkgY29ycmVjdCA9KS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbmNsYXNzIFN0eWxlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3N0YXJ0J10gPSAwO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ2VuZCddID0gMDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwcmV2aW91cyddID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwYXJlbnQnXSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTdHlsZU5vZGU+fSAqL1xuICAgIHRoaXNbJ3J1bGVzJ10gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZENzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ2Nzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzWydhdFJ1bGUnXSA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3R5cGUnXSA9IDA7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1sna2V5ZnJhbWVzTmFtZSddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1snc2VsZWN0b3InXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZFNlbGVjdG9yJ10gPSAnJztcbiAgfVxufVxuXG5leHBvcnQge1N0eWxlTm9kZX1cblxuLy8gZ2l2ZW4gYSBzdHJpbmcgb2YgY3NzLCByZXR1cm4gYSBzaW1wbGUgcnVsZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gIHRleHQgPSBjbGVhbih0ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ3NzKGxleCh0ZXh0KSwgdGV4dCk7XG59XG5cbi8vIHJlbW92ZSBzdHVmZiB3ZSBkb24ndCBjYXJlIGFib3V0IHRoYXQgbWF5IGhpbmRlciBwYXJzaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuKGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5jb21tZW50cywgJycpLnJlcGxhY2UoUlgucG9ydCwgJycpO1xufVxuXG4vLyBzdXBlciBzaW1wbGUgey4uLn0gbGV4ZXIgdGhhdCByZXR1cm5zIGEgbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gIGxldCByb290ID0gbmV3IFN0eWxlTm9kZSgpO1xuICByb290WydzdGFydCddID0gMDtcbiAgcm9vdFsnZW5kJ10gPSB0ZXh0Lmxlbmd0aFxuICBsZXQgbiA9IHJvb3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGV4dFtpXSA9PT0gT1BFTl9CUkFDRSkge1xuICAgICAgaWYgKCFuWydydWxlcyddKSB7XG4gICAgICAgIG5bJ3J1bGVzJ10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGxldCBwID0gbjtcbiAgICAgIGxldCBwcmV2aW91cyA9IHBbJ3J1bGVzJ11bcFsncnVsZXMnXS5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgbiA9IG5ldyBTdHlsZU5vZGUoKTtcbiAgICAgIG5bJ3N0YXJ0J10gPSBpICsgMTtcbiAgICAgIG5bJ3BhcmVudCddID0gcDtcbiAgICAgIG5bJ3ByZXZpb3VzJ10gPSBwcmV2aW91cztcbiAgICAgIHBbJ3J1bGVzJ10ucHVzaChuKTtcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09IENMT1NFX0JSQUNFKSB7XG4gICAgICBuWydlbmQnXSA9IGkgKyAxO1xuICAgICAgbiA9IG5bJ3BhcmVudCddIHx8IHJvb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290O1xufVxuXG4vLyBhZGQgc2VsZWN0b3JzL2Nzc1RleHQgdG8gbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5mdW5jdGlvbiBwYXJzZUNzcyhub2RlLCB0ZXh0KSB7XG4gIGxldCB0ID0gdGV4dC5zdWJzdHJpbmcobm9kZVsnc3RhcnQnXSwgbm9kZVsnZW5kJ10gLSAxKTtcbiAgbm9kZVsncGFyc2VkQ3NzVGV4dCddID0gbm9kZVsnY3NzVGV4dCddID0gdC50cmltKCk7XG4gIGlmIChub2RlWydwYXJlbnQnXSkge1xuICAgIGxldCBzcyA9IG5vZGVbJ3ByZXZpb3VzJ10gPyBub2RlWydwcmV2aW91cyddWydlbmQnXSA6IG5vZGVbJ3BhcmVudCddWydzdGFydCddO1xuICAgIHQgPSB0ZXh0LnN1YnN0cmluZyhzcywgbm9kZVsnc3RhcnQnXSAtIDEpO1xuICAgIHQgPSBfZXhwYW5kVW5pY29kZUVzY2FwZXModCk7XG4gICAgdCA9IHQucmVwbGFjZShSWC5tdWx0aXBsZVNwYWNlcywgJyAnKTtcbiAgICAvLyBUT0RPKHNvcnZlbGwpOiBhZCBob2M7IG1ha2Ugc2VsZWN0b3IgaW5jbHVkZSBvbmx5IGFmdGVyIGxhc3QgO1xuICAgIC8vIGhlbHBzIHdpdGggbWl4aW4gc3ludGF4XG4gICAgdCA9IHQuc3Vic3RyaW5nKHQubGFzdEluZGV4T2YoJzsnKSArIDEpO1xuICAgIGxldCBzID0gbm9kZVsncGFyc2VkU2VsZWN0b3InXSA9IG5vZGVbJ3NlbGVjdG9yJ10gPSB0LnRyaW0oKTtcbiAgICBub2RlWydhdFJ1bGUnXSA9IChzLmluZGV4T2YoQVRfU1RBUlQpID09PSAwKTtcbiAgICAvLyBub3RlLCBzdXBwb3J0IGEgc3Vic2V0IG9mIHJ1bGUgdHlwZXMuLi5cbiAgICBpZiAobm9kZVsnYXRSdWxlJ10pIHtcbiAgICAgIGlmIChzLmluZGV4T2YoTUVESUFfU1RBUlQpID09PSAwKSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLk1FRElBX1JVTEU7XG4gICAgICB9IGVsc2UgaWYgKHMubWF0Y2goUlgua2V5ZnJhbWVzUnVsZSkpIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG4gICAgICAgIG5vZGVbJ2tleWZyYW1lc05hbWUnXSA9XG4gICAgICAgICAgbm9kZVsnc2VsZWN0b3InXS5zcGxpdChSWC5tdWx0aXBsZVNwYWNlcykucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMCkge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5NSVhJTl9SVUxFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuU1RZTEVfUlVMRTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgaWYgKHIkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSByJC5sZW5ndGgsIHI7XG4gICAgICAoaSA8IGwpICYmIChyID0gciRbaV0pOyBpKyspIHtcbiAgICAgIHBhcnNlQ3NzKHIsIHRleHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBjb252ZXJzaW9uIG9mIHNvcnQgdW5pY29kZSBlc2NhcGVzIHdpdGggc3BhY2VzIGxpa2UgYFxcMzMgYCAoYW5kIGxvbmdlcikgaW50b1xuICogZXhwYW5kZWQgZm9ybSB0aGF0IGRvZXNuJ3QgcmVxdWlyZSB0cmFpbGluZyBzcGFjZSBgXFwwMDAwMzNgXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBfZXhwYW5kVW5pY29kZUVzY2FwZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFswLTlhLWZdezEsNn0pXFxzL2dpLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29kZSA9IGFyZ3VtZW50c1sxXSxcbiAgICAgIHJlcGVhdCA9IDYgLSBjb2RlLmxlbmd0aDtcbiAgICB3aGlsZSAocmVwZWF0LS0pIHtcbiAgICAgIGNvZGUgPSAnMCcgKyBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFwnICsgY29kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogc3RyaW5naWZ5IHBhcnNlZCBjc3MuXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFuPX0gcHJlc2VydmVQcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IHRleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBwcmVzZXJ2ZVByb3BlcnRpZXMsIHRleHQgPSAnJykge1xuICAvLyBjYWxjIHJ1bGUgY3NzVGV4dFxuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBpZiAobm9kZVsnY3NzVGV4dCddIHx8IG5vZGVbJ3J1bGVzJ10pIHtcbiAgICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICAgIGlmIChyJCAmJiAhX2hhc01peGluUnVsZXMociQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjtcbiAgICAgICAgKGkgPCBsKSAmJiAociA9IHIkW2ldKTsgaSsrKSB7XG4gICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnkociwgcHJlc2VydmVQcm9wZXJ0aWVzLCBjc3NUZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3NzVGV4dCA9IHByZXNlcnZlUHJvcGVydGllcyA/IG5vZGVbJ2Nzc1RleHQnXSA6XG4gICAgICAgIHJlbW92ZUN1c3RvbVByb3BzKG5vZGVbJ2Nzc1RleHQnXSk7XG4gICAgICBjc3NUZXh0ID0gY3NzVGV4dC50cmltKCk7XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICBjc3NUZXh0ID0gJyAgJyArIGNzc1RleHQgKyAnXFxuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZW1pdCBydWxlIGlmIHRoZXJlIGlzIGNzc1RleHRcbiAgaWYgKGNzc1RleHQpIHtcbiAgICBpZiAobm9kZVsnc2VsZWN0b3InXSkge1xuICAgICAgdGV4dCArPSBub2RlWydzZWxlY3RvciddICsgJyAnICsgT1BFTl9CUkFDRSArICdcXG4nO1xuICAgIH1cbiAgICB0ZXh0ICs9IGNzc1RleHQ7XG4gICAgaWYgKG5vZGVbJ3NlbGVjdG9yJ10pIHtcbiAgICAgIHRleHQgKz0gQ0xPU0VfQlJBQ0UgKyAnXFxuXFxuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHlsZU5vZGU+fSBydWxlc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2hhc01peGluUnVsZXMocnVsZXMpIHtcbiAgbGV0IHIgPSBydWxlc1swXTtcbiAgcmV0dXJuIEJvb2xlYW4ocikgJiYgQm9vbGVhbihyWydzZWxlY3RvciddKSAmJiByWydzZWxlY3RvciddLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wcyhjc3NUZXh0KSB7XG4gIGNzc1RleHQgPSByZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudChjc3NUZXh0KTtcbiAgcmV0dXJuIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dFxuICAgIC5yZXBsYWNlKFJYLmN1c3RvbVByb3AsICcnKVxuICAgIC5yZXBsYWNlKFJYLm1peGluUHJvcCwgJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0XG4gICAgLnJlcGxhY2UoUlgubWl4aW5BcHBseSwgJycpXG4gICAgLnJlcGxhY2UoUlgudmFyQXBwbHksICcnKTtcbn1cblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgdHlwZXMgPSB7XG4gIFNUWUxFX1JVTEU6IDEsXG4gIEtFWUZSQU1FU19SVUxFOiA3LFxuICBNRURJQV9SVUxFOiA0LFxuICBNSVhJTl9SVUxFOiAxMDAwXG59XG5cbmNvbnN0IE9QRU5fQlJBQ0UgPSAneyc7XG5jb25zdCBDTE9TRV9CUkFDRSA9ICd9JztcblxuLy8gaGVscGVyIHJlZ2V4cCdzXG5jb25zdCBSWCA9IHtcbiAgY29tbWVudHM6IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sXG4gIHBvcnQ6IC9AaW1wb3J0W147XSo7L2dpbSxcbiAgY3VzdG9tUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFxuICBtaXhpblByb3A6IC8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxcbiAgbWl4aW5BcHBseTogL0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxcbiAgdmFyQXBwbHk6IC9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sXG4gIGtleWZyYW1lc1J1bGU6IC9eQFteXFxzXSprZXlmcmFtZXMvLFxuICBtdWx0aXBsZVNwYWNlczogL1xccysvZ1xufVxuXG5jb25zdCBWQVJfU1RBUlQgPSAnLS0nO1xuY29uc3QgTUVESUFfU1RBUlQgPSAnQG1lZGlhJztcbmNvbnN0IEFUX1NUQVJUID0gJ0AnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY3NzLXBhcnNlLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuZXhwb3J0IGNvbnN0IFZBUl9BU1NJR04gPSAvKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2k7XG5leHBvcnQgY29uc3QgTUlYSU5fTUFUQ0ggPSAvKD86XnxcXFcrKUBhcHBseVxccypcXCg/KFteKTtcXG5dKilcXCk/L2dpO1xuZXhwb3J0IGNvbnN0IFZBUl9DT05TVU1FRCA9IC8oLS1bXFx3LV0rKVxccyooWzosOyldfCQpL2dpO1xuZXhwb3J0IGNvbnN0IEFOSU1BVElPTl9NQVRDSCA9IC8oYW5pbWF0aW9uXFxzKjopfChhbmltYXRpb24tbmFtZVxccyo6KS87XG5leHBvcnQgY29uc3QgTUVESUFfTUFUQ0ggPSAvQG1lZGlhXFxzKC4qKS87XG5leHBvcnQgY29uc3QgSVNfVkFSID0gL14tLS87XG5leHBvcnQgY29uc3QgQlJBQ0tFVEVEID0gL1xce1tefV0qXFx9L2c7XG5leHBvcnQgY29uc3QgSE9TVF9QUkVGSVggPSAnKD86XnxbXi4jWzpdKSc7XG5leHBvcnQgY29uc3QgSE9TVF9TVUZGSVggPSAnKCR8Wy46W1xcXFxzPit+XSknO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXJlZ2V4LmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBNSVhJTl9NQVRDSCwgVkFSX0FTU0lHTiB9IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gIC8vIHJlbW92ZSBwcmV2aW91cyBwcm9wZXJ0aWVzXG4gIGZvciAobGV0IHAgaW4gcHJvcGVydGllcykge1xuICAgIC8vIE5PVEU6IGZvciBiYyB3aXRoIHNoaW0sIGRvbid0IGFwcGx5IG51bGwgdmFsdWVzLlxuICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHAsIHByb3BlcnRpZXNbcF0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgLyoqXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3QgdmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICB9XG59XG5cbi8qKlxuICogcmV0dXJuIHRydWUgaWYgYGNzc1RleHRgIGNvbnRhaW5zIGEgbWl4aW4gZGVmaW5pdGlvbiBvciBjb25zdW1wdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RNaXhpbihjc3NUZXh0KSB7XG4gIGNvbnN0IGhhcyA9IE1JWElOX01BVENILnRlc3QoY3NzVGV4dCkgfHwgVkFSX0FTU0lHTi50ZXN0KGNzc1RleHQpO1xuICAvLyByZXNldCBzdGF0ZSBvZiB0aGUgcmVnZXhlc1xuICBNSVhJTl9NQVRDSC5sYXN0SW5kZXggPSAwO1xuICBWQVJfQVNTSUdOLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiBoYXM7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tdXRpbHMuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyB0aW1lT3V0IH0gZnJvbSAnLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuL2RlYm91bmNlLmpzJztcblxuLy8gZGV0ZWN0IG5hdGl2ZSB0b3VjaCBhY3Rpb24gc3VwcG9ydFxubGV0IEhBU19OQVRJVkVfVEEgPSB0eXBlb2YgZG9jdW1lbnQuaGVhZC5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ3N0cmluZyc7XG5sZXQgR0VTVFVSRV9LRVkgPSAnX19wb2x5bWVyR2VzdHVyZXMnO1xubGV0IEhBTkRMRURfT0JKID0gJ19fcG9seW1lckdlc3R1cmVzSGFuZGxlZCc7XG5sZXQgVE9VQ0hfQUNUSU9OID0gJ19fcG9seW1lckdlc3R1cmVzVG91Y2hBY3Rpb24nO1xuLy8gcmFkaXVzIGZvciB0YXAgYW5kIHRyYWNrXG5sZXQgVEFQX0RJU1RBTkNFID0gMjU7XG5sZXQgVFJBQ0tfRElTVEFOQ0UgPSA1O1xuLy8gbnVtYmVyIG9mIGxhc3QgTiB0cmFjayBwb3NpdGlvbnMgdG8ga2VlcFxubGV0IFRSQUNLX0xFTkdUSCA9IDI7XG5cbi8vIERpc2FibGluZyBcIm1vdXNlXCIgaGFuZGxlcnMgZm9yIDI1MDBtcyBpcyBlbm91Z2hcbmxldCBNT1VTRV9USU1FT1VUID0gMjUwMDtcbmxldCBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdjbGljayddO1xuLy8gYW4gYXJyYXkgb2YgYml0bWFzayB2YWx1ZXMgZm9yIG1hcHBpbmcgTW91c2VFdmVudC53aGljaCB0byBNb3VzZUV2ZW50LmJ1dHRvbnNcbmxldCBNT1VTRV9XSElDSF9UT19CVVRUT05TID0gWzAsIDEsIDQsIDJdO1xubGV0IE1PVVNFX0hBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgTW91c2VFdmVudCgndGVzdCcsIHtidXR0b25zOiAxfSkuYnV0dG9ucyA9PT0gMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyogZXNsaW50IG5vLWVtcHR5OiBbXCJlcnJvclwiLCB7IFwiYWxsb3dFbXB0eUNhdGNoXCI6IHRydWUgfV0gKi9cbi8vIGNoZWNrIGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyc1xubGV0IFNVUFBPUlRTX1BBU1NJVkUgPSBmYWxzZTtcbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7Z2V0OiBmdW5jdGlvbigpIHtTVVBQT1JUU19QQVNTSVZFID0gdHJ1ZTt9fSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoKGUpIHt9XG59KSgpO1xuXG4vLyBDaGVjayBmb3IgdG91Y2gtb25seSBkZXZpY2VzXG5sZXQgSVNfVE9VQ0hfT05MWSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQKD86W29hXWR8aG9uZSl8QW5kcm9pZC8pO1xuXG5sZXQgR2VzdHVyZVJlY29nbml6ZXIgPSBmdW5jdGlvbigpe307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7fTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWR9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vkb3duO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlbW92ZTtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZXVwO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoc3RhcnQ7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2htb3ZlO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoZW5kO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLmNsaWNrO1xuXG4vLyB0b3VjaCB3aWxsIG1ha2Ugc3ludGhldGljIG1vdXNlIGV2ZW50c1xuLy8gYHByZXZlbnREZWZhdWx0YCBvbiB0b3VjaGVuZCB3aWxsIGNhbmNlbCB0aGVtLFxuLy8gYnV0IHRoaXMgYnJlYWtzIGA8aW5wdXQ+YCBmb2N1cyBhbmQgbGluayBjbGlja3Ncbi8vIGRpc2FibGUgbW91c2UgaGFuZGxlcnMgZm9yIE1PVVNFX1RJTUVPVVQgbXMgYWZ0ZXJcbi8vIGEgdG91Y2hlbmQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbmxldCBtb3VzZUNhbmNlbGxlciA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgLy8gQ2hlY2sgZm9yIHNvdXJjZUNhcGFiaWxpdGllcywgdXNlZCB0byBkaXN0aW5ndWlzaCBzeW50aGV0aWMgZXZlbnRzXG4gIC8vIGlmIG1vdXNlRXZlbnQgZGlkIG5vdCBjb21lIGZyb20gYSBkZXZpY2UgdGhhdCBmaXJlcyB0b3VjaCBldmVudHMsXG4gIC8vIGl0IHdhcyBtYWRlIGJ5IGEgcmVhbCBtb3VzZSBhbmQgc2hvdWxkIGJlIGNvdW50ZWRcbiAgLy8gaHR0cDovL3dpY2cuZ2l0aHViLmlvL0lucHV0RGV2aWNlQ2FwYWJpbGl0aWVzLyNkb20taW5wdXRkZXZpY2VjYXBhYmlsaXRpZXMtZmlyZXN0b3VjaGV2ZW50c1xuICBsZXQgc2MgPSBtb3VzZUV2ZW50LnNvdXJjZUNhcGFiaWxpdGllcztcbiAgaWYgKHNjICYmICFzYy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNraXAgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICBtb3VzZUV2ZW50W0hBTkRMRURfT0JKXSA9IHtza2lwOiB0cnVlfTtcbiAgLy8gZGlzYWJsZSBcImdob3N0IGNsaWNrc1wiXG4gIGlmIChtb3VzZUV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICBsZXQgcGF0aCA9IG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoICYmIG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSA9PT0gUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbW91c2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXR1cCBUcnVlIHRvIGFkZCwgZmFsc2UgdG8gcmVtb3ZlLlxuICovXG5mdW5jdGlvbiBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIoc2V0dXApIHtcbiAgbGV0IGV2ZW50cyA9IElTX1RPVUNIX09OTFkgPyBbJ2NsaWNrJ10gOiBNT1VTRV9FVkVOVFM7XG4gIGZvciAobGV0IGkgPSAwLCBlbjsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGVuID0gZXZlbnRzW2ldO1xuICAgIGlmIChzZXR1cCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZU1vdXNlKGUpIHtcbiAgaWYgKCFQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IpIHtcbiAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIodHJ1ZSk7XG4gIH1cbiAgbGV0IHVuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKCk7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IG51bGw7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gbnVsbDtcbiAgfTtcbiAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iXG4gICAgICAsIHRpbWVPdXQuYWZ0ZXIoTU9VU0VfVElNRU9VVClcbiAgICAgICwgdW5zZXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgZXZlbnQgdG8gdGVzdCBmb3IgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICogQHJldHVybiB7Ym9vbGVhbn0gaGFzIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAqL1xuZnVuY3Rpb24gaGFzTGVmdE1vdXNlQnV0dG9uKGV2KSB7XG4gIGxldCB0eXBlID0gZXYudHlwZTtcbiAgLy8gZXhpdCBlYXJseSBpZiB0aGUgZXZlbnQgaXMgbm90IGEgbW91c2UgZXZlbnRcbiAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBldi5idXR0b24gaXMgbm90IHJlbGlhYmxlIGZvciBtb3VzZW1vdmUgKDAgaXMgb3ZlcmxvYWRlZCBhcyBib3RoIGxlZnQgYnV0dG9uIGFuZCBubyBidXR0b25zKVxuICAvLyBpbnN0ZWFkIHdlIHVzZSBldi5idXR0b25zIChiaXRtYXNrIG9mIGJ1dHRvbnMpIG9yIGZhbGwgYmFjayB0byBldi53aGljaCAoZGVwcmVjYXRlZCwgMCBmb3Igbm8gYnV0dG9ucywgMSBmb3IgbGVmdCBidXR0b24pXG4gIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9ucyA9IGV2LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBldi5idXR0b25zO1xuICAgIGlmICgoZXYgaW5zdGFuY2VvZiB3aW5kb3cuTW91c2VFdmVudCkgJiYgIU1PVVNFX0hBU19CVVRUT05TKSB7XG4gICAgICBidXR0b25zID0gTU9VU0VfV0hJQ0hfVE9fQlVUVE9OU1tldi53aGljaF0gfHwgMDtcbiAgICB9XG4gICAgLy8gYnV0dG9ucyBpcyBhIGJpdG1hc2ssIGNoZWNrIHRoYXQgdGhlIGxlZnQgYnV0dG9uIGJpdCBpcyBzZXQgKDEpXG4gICAgcmV0dXJuIEJvb2xlYW4oYnV0dG9ucyAmIDEpO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9uID0gZXYuYnV0dG9uID09PSB1bmRlZmluZWQgPyAwIDogZXYuYnV0dG9uO1xuICAgIC8vIGV2LmJ1dHRvbiBpcyAwIGluIG1vdXNlZG93bi9tb3VzZXVwL2NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBhY3RpdmF0aW9uXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0NsaWNrKGV2KSB7XG4gIGlmIChldi50eXBlID09PSAnY2xpY2snKSB7XG4gICAgLy8gZXYuZGV0YWlsIGlzIDAgZm9yIEhUTUxFbGVtZW50LmNsaWNrIGluIG1vc3QgYnJvd3NlcnNcbiAgICBpZiAoZXYuZGV0YWlsID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaW4gdGhlIHdvcnN0IGNhc2UsIGNoZWNrIHRoYXQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgaXMgd2l0aGluXG4gICAgLy8gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICAgIC8vIFRoYW5rcyBJRSAxMCA+OihcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZXYpO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBhbiBlbGVtZW50IHNvIHdlIGNhbiB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuICAgIC8vIGlmIG5vdCwganVzdCBhc3N1bWUgaXQgaXMgYSBzeW50aGV0aWMgY2xpY2tcbiAgICBpZiAoIXQubm9kZVR5cGUgfHwgLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmNyID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyB1c2UgcGFnZSB4L3kgdG8gYWNjb3VudCBmb3Igc2Nyb2xsaW5nXG4gICAgbGV0IHggPSBldi5wYWdlWCwgeSA9IGV2LnBhZ2VZO1xuICAgIC8vIGV2IGlzIGEgc3ludGhldGljIGNsaWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldFxuICAgIHJldHVybiAhKCh4ID49IGJjci5sZWZ0ICYmIHggPD0gYmNyLnJpZ2h0KSAmJiAoeSA+PSBiY3IudG9wICYmIHkgPD0gYmNyLmJvdHRvbSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IFBPSU5URVJTVEFURSA9IHtcbiAgbW91c2U6IHtcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgbW91c2VJZ25vcmVKb2I6IG51bGxcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgaWQ6IC0xLFxuICAgIHNjcm9sbERlY2lkZWQ6IGZhbHNlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpcnN0VG91Y2hBY3Rpb24oZXYpIHtcbiAgbGV0IHRhID0gJ2F1dG8nO1xuICBsZXQgcGF0aCA9IGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKTtcbiAgaWYgKHBhdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBwYXRoW2ldO1xuICAgICAgaWYgKG5bVE9VQ0hfQUNUSU9OXSkge1xuICAgICAgICB0YSA9IG5bVE9VQ0hfQUNUSU9OXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YTtcbn1cblxuZnVuY3Rpb24gdHJhY2tEb2N1bWVudChzdGF0ZU9iaiwgbW92ZWZuLCB1cGZuKSB7XG4gIHN0YXRlT2JqLm1vdmVmbiA9IG1vdmVmbjtcbiAgc3RhdGVPYmoudXBmbiA9IHVwZm47XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVmbik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB1cGZuKTtcbn1cblxuZnVuY3Rpb24gdW50cmFja0RvY3VtZW50KHN0YXRlT2JqKSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0YXRlT2JqLm1vdmVmbik7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdGF0ZU9iai51cGZuKTtcbiAgc3RhdGVPYmoubW92ZWZuID0gbnVsbDtcbiAgc3RhdGVPYmoudXBmbiA9IG51bGw7XG59XG5cbi8vIHVzZSBhIGRvY3VtZW50LXdpZGUgdG91Y2hlbmQgbGlzdGVuZXIgdG8gc3RhcnQgdGhlIGdob3N0LWNsaWNrIHByZXZlbnRpb24gbWVjaGFuaXNtXG4vLyBVc2UgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGlmIHN1cHBvcnRlZCwgdG8gbm90IGFmZmVjdCBzY3JvbGxpbmcgcGVyZm9ybWFuY2VcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaWdub3JlTW91c2UsIFNVUFBPUlRTX1BBU1NJVkUgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZSk7XG5cbmV4cG9ydCBjb25zdCBnZXN0dXJlcyA9IHt9O1xuZXhwb3J0IGNvbnN0IHJlY29nbml6ZXJzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwVGFyZ2V0RmluZCh4LCB5KSB7XG4gIGxldCBub2RlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgbGV0IG5leHQgPSBub2RlO1xuICAvLyB0aGlzIGNvZGUgcGF0aCBpcyBvbmx5IHRha2VuIHdoZW4gbmF0aXZlIFNoYWRvd0RPTSBpcyB1c2VkXG4gIC8vIGlmIHRoZXJlIGlzIGEgc2hhZG93cm9vdCwgaXQgbWF5IGhhdmUgYSBub2RlIGF0IHgveVxuICAvLyBpZiB0aGVyZSBpcyBub3QgYSBzaGFkb3dyb290LCBleGl0IHRoZSBsb29wXG4gIHdoaWxlIChuZXh0ICYmIG5leHQuc2hhZG93Um9vdCAmJiAhd2luZG93LlNoYWR5RE9NKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYSBub2RlIGF0IHgveSBpbiB0aGUgc2hhZG93cm9vdCwgbG9vayBkZWVwZXJcbiAgICBsZXQgb2xkTmV4dCA9IG5leHQ7XG4gICAgbmV4dCA9IG5leHQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIC8vIG9uIFNhZmFyaSwgZWxlbWVudEZyb21Qb2ludCBtYXkgcmV0dXJuIHRoZSBzaGFkb3dSb290IGhvc3RcbiAgICBpZiAob2xkTmV4dCA9PT0gbmV4dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZE9yaWdpbmFsVGFyZ2V0KGV2KSB7XG4gIC8vIHNoYWRvd2RvbVxuICBpZiAoZXYuY29tcG9zZWRQYXRoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7RXZlbnRUYXJnZXR9ICovKGV2LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgfVxuICAvLyBzaGFkeWRvbVxuICByZXR1cm4gZXYudGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2hhbmRsZU5hdGl2ZShldikge1xuICBsZXQgaGFuZGxlZDtcbiAgbGV0IHR5cGUgPSBldi50eXBlO1xuICBsZXQgbm9kZSA9IGV2LmN1cnJlbnRUYXJnZXQ7XG4gIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gIGlmICghZ29iaikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZ3MgPSBnb2JqW3R5cGVdO1xuICBpZiAoIWdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZXZbSEFORExFRF9PQkpdKSB7XG4gICAgZXZbSEFORExFRF9PQkpdID0ge307XG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgNSkgPT09ICd0b3VjaCcpIHtcbiAgICAgIGV2ID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhldik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCBmaW5nZXJcbiAgICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLmlkID0gdC5pZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLmlkICE9PSB0LmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFIQVNfTkFUSVZFX1RBKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICBfaGFuZGxlVG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZWQgPSBldltIQU5ETEVEX09CSl07XG4gIC8vIHVzZWQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgaWYgKGhhbmRsZWQuc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyByZXNldCByZWNvZ25pemVyIHN0YXRlXG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgaWYgKHIuZmxvdyAmJiByLmZsb3cuc3RhcnQuaW5kZXhPZihldi50eXBlKSA+IC0xICYmIHIucmVzZXQpIHtcbiAgICAgICAgci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBlbmZvcmNlIGdlc3R1cmUgcmVjb2duaXplciBvcmRlclxuICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgIGhhbmRsZWRbci5uYW1lXSA9IHRydWU7XG4gICAgICByW3R5cGVdKGV2KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9oYW5kbGVUb3VjaEFjdGlvbihldikge1xuICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueCA9IHQuY2xpZW50WDtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueSA9IHQuY2xpZW50WTtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gdHJ1ZTtcbiAgICBsZXQgdGEgPSBmaXJzdFRvdWNoQWN0aW9uKGV2KTtcbiAgICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICAgIGxldCBkeCA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC54IC0gdC5jbGllbnRYKTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueSAtIHQuY2xpZW50WSk7XG4gICAgaWYgKCFldi5jYW5jZWxhYmxlKSB7XG4gICAgICAvLyBzY3JvbGxpbmcgaXMgaGFwcGVuaW5nXG4gICAgfSBlbHNlIGlmICh0YSA9PT0gJ25vbmUnKSB7XG4gICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXgnKSB7XG4gICAgICBwcmV2ZW50ID0gZHkgPiBkeDtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXknKSB7XG4gICAgICBwcmV2ZW50ID0gZHggPiBkeTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnQpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZlbnQoJ3RyYWNrJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKGdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICBfYWRkKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGlmIChnZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgX3JlbW92ZShub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9hZGQobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoIWdvYmopIHtcbiAgICBub2RlW0dFU1RVUkVfS0VZXSA9IGdvYmogPSB7fTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXAgPSBkZXBzW2ldO1xuICAgIC8vIGRvbid0IGFkZCBtb3VzZSBoYW5kbGVycyBvbiBpT1MgYmVjYXVzZSB0aGV5IGNhdXNlIGdyYXkgc2VsZWN0aW9uIG92ZXJsYXlzXG4gICAgaWYgKElTX1RPVUNIX09OTFkgJiYgTU9VU0VfRVZFTlRTLmluZGV4T2YoZGVwKSA+IC0xICYmIGRlcCAhPT0gJ2NsaWNrJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGdkID0gZ29ialtkZXBdO1xuICAgIGlmICghZ2QpIHtcbiAgICAgIGdvYmpbZGVwXSA9IGdkID0ge19jb3VudDogMH07XG4gICAgfVxuICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihkZXAsIF9oYW5kbGVOYXRpdmUpO1xuICAgIH1cbiAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAwKSArIDE7XG4gICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAwKSArIDE7XG4gIH1cbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG4gIGlmIChyZWNvZ25pemVyLnRvdWNoQWN0aW9uKSB7XG4gICAgc2V0VG91Y2hBY3Rpb24obm9kZSwgcmVjb2duaXplci50b3VjaEFjdGlvbik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoZ29iaikge1xuICAgIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgaWYgKGdkICYmIGdkW25hbWVdKSB7XG4gICAgICAgIGdkW25hbWVdID0gKGdkW25hbWVdIHx8IDEpIC0gMTtcbiAgICAgICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAxKSAtIDE7XG4gICAgICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZGVwLCBfaGFuZGxlTmF0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHJlY29nKSB7XG4gIHJlY29nbml6ZXJzLnB1c2gocmVjb2cpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29nLmVtaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ2VzdHVyZXNbcmVjb2cuZW1pdHNbaV1dID0gcmVjb2c7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKSB7XG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgZm9yIChsZXQgaiA9IDAsIG47IGogPCByLmVtaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBuID0gci5lbWl0c1tqXTtcbiAgICAgIGlmIChuID09PSBldk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VG91Y2hBY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgaWYgKEhBU19OQVRJVkVfVEEpIHtcbiAgICBub2RlLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgbm9kZVtUT1VDSF9BQ1RJT05dID0gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmlyZSh0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuICBsZXQgZXYgPSBuZXcgRXZlbnQodHlwZSwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBjb21wb3NlZDogdHJ1ZSB9KTtcbiAgZXYuZGV0YWlsID0gZGV0YWlsO1xuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG4gIC8vIGZvcndhcmQgYHByZXZlbnREZWZhdWx0YCBpbiBhIGNsZWFuIHdheVxuICBpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIGxldCBwcmV2ZW50ZXIgPSBkZXRhaWwucHJldmVudGVyIHx8IGRldGFpbC5zb3VyY2VFdmVudDtcbiAgICBpZiAocHJldmVudGVyICYmIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgcHJldmVudGVyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50KGV2TmFtZSkge1xuICBsZXQgcmVjb2duaXplciA9IF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKTtcbiAgaWYgKHJlY29nbml6ZXIuaW5mbykge1xuICAgIHJlY29nbml6ZXIuaW5mby5wcmV2ZW50ID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRNb3VzZUNhbmNlbGxlcigpIHtcbiAgaWYgKFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYi5mbHVzaCgpO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ2Rvd251cCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICB9LFxuICBlbWl0czogWydkb3duJywgJ3VwJ10sXG5cbiAgaW5mbzoge1xuICAgIG1vdmVmbjogbnVsbCxcbiAgICB1cGZuOiBudWxsXG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgIH1cbiAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgIH07XG4gICAgdHJhY2tEb2N1bWVudCh0aGlzLmluZm8sIG1vdmVmbiwgdXBmbik7XG4gICAgdGhpcy5fZmlyZSgnZG93bicsIHQsIGUpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCdkb3duJywgX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCd1cCcsIF9maW5kT3JpZ2luYWxUYXJnZXQoZSksIGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXZlbnRlclxuICAgKi9cbiAgX2ZpcmU6IGZ1bmN0aW9uKHR5cGUsIHRhcmdldCwgZXZlbnQsIHByZXZlbnRlcikge1xuICAgIF9maXJlKHRhcmdldCwgdHlwZSwge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlcixcbiAgICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWdpc3Rlcih7XG4gIG5hbWU6ICd0cmFjaycsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10sXG4gIGZsb3c6IHtcbiAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndHJhY2snXSxcblxuICBpbmZvOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0YXRlOiAnc3RhcnQnLFxuICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgIG1vdmVzOiBbXSxcbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIGFkZE1vdmU6IGZ1bmN0aW9uKG1vdmUpIHtcbiAgICAgIGlmICh0aGlzLm1vdmVzLmxlbmd0aCA+IFRSQUNLX0xFTkdUSCkge1xuICAgICAgICB0aGlzLm1vdmVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vdmVzLnB1c2gobW92ZSk7XG4gICAgfSxcbiAgICBtb3ZlZm46IG51bGwsXG4gICAgdXBmbjogbnVsbCxcbiAgICBwcmV2ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8uc3RhdGUgPSAnc3RhcnQnO1xuICAgIHRoaXMuaW5mby5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbmZvLm1vdmVzID0gW107XG4gICAgdGhpcy5pbmZvLnggPSAwO1xuICAgIHRoaXMuaW5mby55ID0gMDtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNNb3ZlZEVub3VnaDogZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgZHggPSBNYXRoLmFicyh0aGlzLmluZm8ueCAtIHgpO1xuICAgIGxldCBkeSA9IE1hdGguYWJzKHRoaXMuaW5mby55IC0geSk7XG4gICAgcmV0dXJuIChkeCA+PSBUUkFDS19ESVNUQU5DRSB8fCBkeSA+PSBUUkFDS19ESVNUQU5DRSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGxldCB4ID0gZS5jbGllbnRYLCB5ID0gZS5jbGllbnRZO1xuICAgICAgaWYgKHNlbGYuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgLy8gZmlyc3QgbW92ZSBpcyAnc3RhcnQnLCBzdWJzZXF1ZW50IG1vdmVzIGFyZSAnbW92ZScsIG1vdXNldXAgaXMgJ2VuZCdcbiAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gc2VsZi5pbmZvLnN0YXJ0ZWQgPyAoZS50eXBlID09PSAnbW91c2V1cCcgPyAnZW5kJyA6ICd0cmFjaycpIDogJ3N0YXJ0JztcbiAgICAgICAgaWYgKHNlbGYuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgIC8vIGFsd2F5cyBfZmlyZSBcImVuZFwiXG4gICAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fZmlyZSh0LCBlKTtcbiAgICAgICAgc2VsZi5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChzZWxmLmluZm8uc3RhcnRlZCkge1xuICAgICAgICBtb3ZlZm4oZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5IGxpc3RlbmVyc1xuICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgfTtcbiAgICAvLyBhZGQgdGVtcG9yYXJ5IGRvY3VtZW50IGxpc3RlbmVycyBhcyBtb3VzZSByZXRhcmdldHNcbiAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICB0aGlzLmluZm8ueCA9IGUuY2xpZW50WDtcbiAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB0aGlzLmluZm8ueCA9IGN0LmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBjdC5jbGllbnRZO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGxldCB4ID0gY3QuY2xpZW50WCwgeSA9IGN0LmNsaWVudFk7XG4gICAgaWYgKHRoaXMuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgIGlmICh0aGlzLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICB0aGlzLl9maXJlKHQsIGN0KTtcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICd0cmFjayc7XG4gICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgLy8gb25seSB0cmFja2VuZCBpZiB0cmFjayB3YXMgc3RhcnRlZCBhbmQgbm90IGFib3J0ZWRcbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIC8vIHJlc2V0IHN0YXJ0ZWQgc3RhdGUgb24gdXBcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgdGhpcy5pbmZvLmFkZE1vdmUoe3g6IGN0LmNsaWVudFgsIHk6IGN0LmNsaWVudFl9KTtcbiAgICAgIHRoaXMuX2ZpcmUodCwgY3QsIGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2hcbiAgICovXG4gIF9maXJlOiBmdW5jdGlvbih0YXJnZXQsIHRvdWNoKSB7XG4gICAgbGV0IHNlY29uZGxhc3QgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDJdO1xuICAgIGxldCBsYXN0bW92ZSA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGR4ID0gbGFzdG1vdmUueCAtIHRoaXMuaW5mby54O1xuICAgIGxldCBkeSA9IGxhc3Rtb3ZlLnkgLSB0aGlzLmluZm8ueTtcbiAgICBsZXQgZGR4LCBkZHkgPSAwO1xuICAgIGlmIChzZWNvbmRsYXN0KSB7XG4gICAgICBkZHggPSBsYXN0bW92ZS54IC0gc2Vjb25kbGFzdC54O1xuICAgICAgZGR5ID0gbGFzdG1vdmUueSAtIHNlY29uZGxhc3QueTtcbiAgICB9XG4gICAgX2ZpcmUodGFyZ2V0LCAndHJhY2snLCB7XG4gICAgICBzdGF0ZTogdGhpcy5pbmZvLnN0YXRlLFxuICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICBkeDogZHgsXG4gICAgICBkeTogZHksXG4gICAgICBkZHg6IGRkeCxcbiAgICAgIGRkeTogZGR5LFxuICAgICAgc291cmNlRXZlbnQ6IHRvdWNoLFxuICAgICAgaG92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVlcFRhcmdldEZpbmQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ3RhcCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ2NsaWNrJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ2NsaWNrJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndGFwJ10sXG4gIGluZm86IHtcbiAgICB4OiBOYU4sXG4gICAgeTogTmFOLFxuICAgIHByZXZlbnQ6IGZhbHNlXG4gIH0sXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8ueCA9IE5hTjtcbiAgICB0aGlzLmluZm8ueSA9IE5hTjtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICB9LFxuICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICBzYXZlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgdGhpcy5zYXZlKGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAqL1xuICBjbGljazogZnVuY3Rpb24oZSkge1xuICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZChlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuc2F2ZShlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuZm9yd2FyZChlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtFdmVudCB8IFRvdWNofSBlXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBwcmV2ZW50ZXJcbiAgICovXG4gIGZvcndhcmQ6IGZ1bmN0aW9uKGUsIHByZXZlbnRlcikge1xuICAgIGxldCBkeCA9IE1hdGguYWJzKGUuY2xpZW50WCAtIHRoaXMuaW5mby54KTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhlLmNsaWVudFkgLSB0aGlzLmluZm8ueSk7XG4gICAgLy8gZmluZCBvcmlnaW5hbCB0YXJnZXQgZnJvbSBgcHJldmVudGVyYCBmb3IgVG91Y2hFdmVudHMsIG9yIGBlYCBmb3IgTW91c2VFdmVudHNcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoKHByZXZlbnRlciB8fCBlKSk7XG4gICAgLy8gZHgsZHkgY2FuIGJlIE5hTiBpZiBgY2xpY2tgIGhhcyBiZWVuIHNpbXVsYXRlZCBhbmQgdGhlcmUgd2FzIG5vIGBkb3duYCBmb3IgYHN0YXJ0YFxuICAgIGlmIChpc05hTihkeCkgfHwgaXNOYU4oZHkpIHx8IChkeCA8PSBUQVBfRElTVEFOQ0UgJiYgZHkgPD0gVEFQX0RJU1RBTkNFKSB8fCBpc1N5bnRoZXRpY0NsaWNrKGUpKSB7XG4gICAgICAvLyBwcmV2ZW50IHRhcHMgZnJvbSBiZWluZyBnZW5lcmF0ZWQgaWYgYW4gZXZlbnQgaGFzIGNhbmNlbGVkIHRoZW1cbiAgICAgIGlmICghdGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgX2ZpcmUodCwgJ3RhcCcsIHtcbiAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgeTogZS5jbGllbnRZLFxuICAgICAgICAgIHNvdXJjZUV2ZW50OiBlLFxuICAgICAgICAgIHByZXZlbnRlcjogcHJldmVudGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBmaW5kT3JpZ2luYWxUYXJnZXQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0O1xuZXhwb3J0IGNvbnN0IGFkZCA9IGFkZExpc3RlbmVyO1xuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IHJlbW92ZUxpc3RlbmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxubGV0IGRlYm91bmNlclF1ZXVlID0gW107XG5cbmV4cG9ydCBjb25zdCBlbnF1ZXVlRGVib3VuY2VyID0gZnVuY3Rpb24oZGVib3VuY2VyKSB7XG4gIGRlYm91bmNlclF1ZXVlLnB1c2goZGVib3VuY2VyKTtcbn07XG5cbmZ1bmN0aW9uIGZsdXNoRGVib3VuY2VycygpIHtcbiAgY29uc3QgZGlkRmx1c2ggPSBCb29sZWFuKGRlYm91bmNlclF1ZXVlLmxlbmd0aCk7XG4gIHdoaWxlIChkZWJvdW5jZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICB0cnkge1xuICAgICAgZGVib3VuY2VyUXVldWUuc2hpZnQoKS5mbHVzaCgpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZEZsdXNoO1xufVxuXG5leHBvcnQgY29uc3QgZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgbGV0IHNoYWR5RE9NLCBkZWJvdW5jZXJzO1xuICBkbyB7XG4gICAgc2hhZHlET00gPSB3aW5kb3cuU2hhZHlET00gJiYgU2hhZHlET00uZmx1c2goKTtcbiAgICBpZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSkge1xuICAgICAgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltLmZsdXNoKCk7XG4gICAgfVxuICAgIGRlYm91bmNlcnMgPSBmbHVzaERlYm91bmNlcnMoKTtcbiAgfSB3aGlsZSAoc2hhZHlET00gfHwgZGVib3VuY2Vycyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5qcyIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IFByb3BlcnR5RWZmZWN0cyB9IGZyb20gJy4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcbmltcG9ydCB7IE11dGFibGVEYXRhIH0gZnJvbSAnLi4vbWl4aW5zL211dGFibGUtZGF0YS5qcyc7XG5cbi8vIEJhc2UgY2xhc3MgZm9yIEhUTUxUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5zaW9uIHRoYXQgaGFzIHByb3BlcnR5IGVmZmVjdHNcbi8vIG1hY2hpbmVyeSBmb3IgcHJvcGFnYXRpbmcgaG9zdCBwcm9wZXJ0aWVzIHRvIGNoaWxkcmVuLiBUaGlzIGlzIGFuIEVTNVxuLy8gY2xhc3Mgb25seSBiZWNhdXNlIEJhYmVsIChpbmNvcnJlY3RseSkgcmVxdWlyZXMgc3VwZXIoKSBpbiB0aGUgY2xhc3Ncbi8vIGNvbnN0cnVjdG9yIGV2ZW4gdGhvdWdoIG5vIGB0aGlzYCBpcyB1c2VkIGFuZCBpdCByZXR1cm5zIGFuIGluc3RhbmNlLlxubGV0IG5ld0luc3RhbmNlID0gbnVsbDtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SFRNTFRlbXBsYXRlRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbigpIHsgcmV0dXJuIG5ld0luc3RhbmNlOyB9XG5IVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbixcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9XG59KTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKiBAZXh0ZW5kcyB7SFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbn1cbiAqL1xuY29uc3QgRGF0YVRlbXBsYXRlID0gUHJvcGVydHlFZmZlY3RzKEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24pO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICogQGV4dGVuZHMge0RhdGFUZW1wbGF0ZX1cbiAqL1xuY29uc3QgTXV0YWJsZURhdGFUZW1wbGF0ZSA9IE11dGFibGVEYXRhKERhdGFUZW1wbGF0ZSk7XG5cbi8vIEFwcGxpZXMgYSBEYXRhVGVtcGxhdGUgc3ViY2xhc3MgdG8gYSA8dGVtcGxhdGU+IGluc3RhbmNlXG5mdW5jdGlvbiB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGNvbnN0cnVjdG9yKSB7XG4gIG5ld0luc3RhbmNlID0gdGVtcGxhdGU7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZih0ZW1wbGF0ZSwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgbmV3IGNvbnN0cnVjdG9yKCk7XG4gIG5ld0luc3RhbmNlID0gbnVsbDtcbn1cblxuLy8gQmFzZSBjbGFzcyBmb3IgVGVtcGxhdGVJbnN0YW5jZSdzXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICovXG5jb25zdCBiYXNlID0gUHJvcGVydHlFZmZlY3RzKGNsYXNzIHt9KTtcblxuLyoqXG4gKiBAcG9seW1lclxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuY2xhc3MgVGVtcGxhdGVJbnN0YW5jZUJhc2UgZXh0ZW5kcyBiYXNlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2NvbmZpZ3VyZVByb3BlcnRpZXMocHJvcHMpO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fX2RhdGFIb3N0KTtcbiAgICAvLyBTYXZlIGxpc3Qgb2Ygc3RhbXBlZCBjaGlsZHJlblxuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGxldCBuID0gdGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgY2hpbGRyZW4ucHVzaChuKTtcbiAgICAgIG4uX190ZW1wbGF0aXplSW5zdGFuY2UgPSB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX3RlbXBsYXRpemVPd25lci5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18pIHtcbiAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4odHJ1ZSk7XG4gICAgfVxuICAgIC8vIEZsdXNoIHByb3BzIG9ubHkgd2hlbiBwcm9wcyBhcmUgcGFzc2VkIGlmIGluc3RhbmNlIHByb3BzIGV4aXN0XG4gICAgLy8gb3Igd2hlbiB0aGVyZSBpc24ndCBpbnN0YW5jZSBwcm9wcy5cbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICBpZiAoKHByb3BzICYmIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykgfHwgIW9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBnaXZlbiBgcHJvcHNgIGJ5IGNhbGxpbmcgYF9zZXRQZW5kaW5nUHJvcGVydHlgLiBBbHNvXG4gICAqIHNldHMgYW55IHByb3BlcnRpZXMgc3RvcmVkIGluIGBfX2hvc3RQcm9wc2AuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydHkgbmFtZS12YWx1ZSBwYWlycyB0byBzZXQuXG4gICAqL1xuICBfY29uZmlndXJlUHJvcGVydGllcyhwcm9wcykge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChsZXQgaXByb3AgaW4gb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICAgIGlmIChpcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShpcHJvcCwgcHJvcHNbaXByb3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBocHJvcCBpbiB0aGlzLl9faG9zdFByb3BzKSB7XG4gICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaHByb3AsIHRoaXMuX19kYXRhSG9zdFsnX2hvc3RfJyArIGhwcm9wXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGb3J3YXJkcyBhIGhvc3QgcHJvcGVydHkgdG8gdGhpcyBpbnN0YW5jZS4gIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAgKiBjYWxsZWQgb24gaW5zdGFuY2VzIGZyb20gdGhlIGBvcHRpb25zLmZvcndhcmRIb3N0UHJvcGAgY2FsbGJhY2tcbiAgICogdG8gcHJvcGFnYXRlIGNoYW5nZXMgb2YgaG9zdCBwcm9wZXJ0aWVzIHRvIGVhY2ggaW5zdGFuY2UuXG4gICAqXG4gICAqIE5vdGUgdGhpcyBtZXRob2QgZW5xdWV1ZXMgdGhlIGNoYW5nZSwgd2hpY2ggYXJlIGZsdXNoZWQgYXMgYSBiYXRjaC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgb3IgcGF0aCBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGZvcndhcmRcbiAgICovXG4gIGZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcCwgdmFsdWUsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgdGhpcy5fX2RhdGFIb3N0Ll9lbnF1ZXVlQ2xpZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5fbWV0aG9kSG9zdCAmJiB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnMucGFyZW50TW9kZWwpIHtcbiAgICAgIC8vIElmIHRoaXMgaW5zdGFuY2Ugc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBwYXJlbnQgbW9kZWwsIGRlY29yYXRlXG4gICAgICAvLyBldmVudHMgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZSBhcyBgbW9kZWxgXG4gICAgICB0aGlzLl9tZXRob2RIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgZS5tb2RlbCA9IHRoaXM7XG4gICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGRlbGVnYXRlIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3QgKHdoaWNoIGNvdWxkIGJlKVxuICAgICAgLy8gYW5vdGhlciB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgICAgbGV0IHRlbXBsYXRlSG9zdCA9IHRoaXMuX19kYXRhSG9zdC5fX2RhdGFIb3N0O1xuICAgICAgaWYgKHRlbXBsYXRlSG9zdCkge1xuICAgICAgICB0ZW1wbGF0ZUhvc3QuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIG9yIGhpZGVzIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0b3AgbGV2ZWwgY2hpbGQgZWxlbWVudHMuIEZvclxuICAgKiB0ZXh0IG5vZGVzLCBgdGV4dENvbnRlbnRgIGlzIHJlbW92ZWQgd2hpbGUgXCJoaWRkZW5cIiBhbmQgcmVwbGFjZWQgd2hlblxuICAgKiBcInNob3duLlwiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZSBTZXQgdG8gdHJ1ZSB0byBoaWRlIHRoZSBjaGlsZHJlbjtcbiAgICogc2V0IHRvIGZhbHNlIHRvIHNob3cgdGhlbS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZSkge1xuICAgIGxldCBjID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpPTA7IGk8Yy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBjW2ldO1xuICAgICAgLy8gSWdub3JlIG5vbi1jaGFuZ2VzXG4gICAgICBpZiAoQm9vbGVhbihoaWRlKSAhPSBCb29sZWFuKG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSkge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgbi5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIG4udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9IG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobi5zdHlsZSkge1xuICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICBuLl9fcG9seW1lckRpc3BsYXlfXyA9IG4uc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gbi5fX3BvbHltZXJEaXNwbGF5X187XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyA9IGhpZGU7XG4gICAgICBpZiAobi5fc2hvd0hpZGVDaGlsZHJlbikge1xuICAgICAgICBuLl9zaG93SGlkZUNoaWxkcmVuKGhpZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGVzIGRlZmF1bHQgcHJvcGVydHktZWZmZWN0cyBpbXBsZW1lbnRhdGlvbiB0byBpbnRlcmNlcHRcbiAgICogdGV4dENvbnRlbnQgYmluZGluZ3Mgd2hpbGUgY2hpbGRyZW4gYXJlIFwiaGlkZGVuXCIgYW5kIGNhY2hlIGluXG4gICAqIHByaXZhdGUgc3RvcmFnZSBmb3IgbGF0ZXIgcmV0cmlldmFsLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChub2RlLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyAmJlxuICAgICAgICBub2RlLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFICYmIHByb3AgPT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgbm9kZS5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLl9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBwYXJlbnQgbW9kZWxcbiAgICogaXMgZWl0aGVyIGFub3RoZXIgdGVtcGxhdGl6ZSBpbnN0YW5jZSB0aGF0IGhhZCBvcHRpb24gYHBhcmVudE1vZGVsOiB0cnVlYCxcbiAgICogb3IgZWxzZSB0aGUgaG9zdCBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gVGhlIHBhcmVudCBtb2RlbCBvZiB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBnZXQgcGFyZW50TW9kZWwoKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5fX3BhcmVudE1vZGVsO1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIGxldCBvcHRpb25zO1xuICAgICAgbW9kZWwgPSB0aGlzO1xuICAgICAgZG8ge1xuICAgICAgICAvLyBBIHRlbXBsYXRlIGluc3RhbmNlJ3MgYF9fZGF0YUhvc3RgIGlzIGEgPHRlbXBsYXRlPlxuICAgICAgICAvLyBgbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0YCBpcyB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAgICAgIG1vZGVsID0gbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0O1xuICAgICAgfSB3aGlsZSAoKG9wdGlvbnMgPSBtb2RlbC5fX3RlbXBsYXRpemVPcHRpb25zKSAmJiAhb3B0aW9ucy5wYXJlbnRNb2RlbCk7XG4gICAgICB0aGlzLl9fcGFyZW50TW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG59XG5cbi8qKiBAdHlwZSB7IURhdGFUZW1wbGF0ZX0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2RhdGFIb3N0O1xuLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3B0aW9ucztcbi8qKiBAdHlwZSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9tZXRob2RIb3N0O1xuLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyO1xuLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9faG9zdFByb3BzO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1RlbXBsYXRlSW5zdGFuY2VCYXNlfVxuICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gKi9cbmNvbnN0IE11dGFibGVUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IE11dGFibGVEYXRhKFRlbXBsYXRlSW5zdGFuY2VCYXNlKTtcblxuZnVuY3Rpb24gZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpIHtcbiAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAvLyBhcHByb3hpbWF0ZSB0aGlzIHZpYSBjb29wZXJhdGlvbiB3aXRoIG91ciBkYXRhSG9zdCBhbHdheXMgc2V0dGluZ1xuICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICBsZXQgdGVtcGxhdGVIb3N0ID0gdGVtcGxhdGUuX19kYXRhSG9zdDtcbiAgcmV0dXJuIHRlbXBsYXRlSG9zdCAmJiB0ZW1wbGF0ZUhvc3QuX21ldGhvZEhvc3QgfHwgdGVtcGxhdGVIb3N0O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuLyoqXG4gKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICAvLyBBbm9ueW1vdXMgY2xhc3MgY3JlYXRlZCBieSB0aGUgdGVtcGxhdGl6ZVxuICBsZXQgYmFzZSA9IG9wdGlvbnMubXV0YWJsZURhdGEgP1xuICAgIE11dGFibGVUZW1wbGF0ZUluc3RhbmNlQmFzZSA6IFRlbXBsYXRlSW5zdGFuY2VCYXNlO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKi9cbiAgbGV0IGtsYXNzID0gY2xhc3MgZXh0ZW5kcyBiYXNlIHsgfTtcbiAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnMgPSBvcHRpb25zO1xuICBrbGFzcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICByZXR1cm4ga2xhc3M7XG59XG5cbi8qKlxuICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICovXG5mdW5jdGlvbiBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgbGV0IHVzZXJGb3J3YXJkSG9zdFByb3AgPSBvcHRpb25zLmZvcndhcmRIb3N0UHJvcDtcbiAgaWYgKHVzZXJGb3J3YXJkSG9zdFByb3ApIHtcbiAgICAvLyBQcm92aWRlIGRhdGEgQVBJIGFuZCBwcm9wZXJ0eSBlZmZlY3RzIG9uIG1lbW9pemVkIHRlbXBsYXRlIGNsYXNzXG4gICAgbGV0IGtsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVUZW1wbGF0ZUNsYXNzO1xuICAgIGlmICgha2xhc3MpIHtcbiAgICAgIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/IE11dGFibGVEYXRhVGVtcGxhdGUgOiBEYXRhVGVtcGxhdGU7XG4gICAgICBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcyA9XG4gICAgICAgIGNsYXNzIFRlbXBsYXRpemVkVGVtcGxhdGUgZXh0ZW5kcyBiYXNlIHt9O1xuICAgICAgLy8gQWRkIHRlbXBsYXRlIC0gPmluc3RhbmNlcyBlZmZlY3RzXG4gICAgICAvLyBhbmQgaG9zdCA8LSB0ZW1wbGF0ZSBlZmZlY3RzXG4gICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICAgIGZvciAobGV0IHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoJ19ob3N0XycgKyBwcm9wLFxuICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuUFJPUEFHQVRFLFxuICAgICAgICAgIHtmbjogY3JlYXRlRm9yd2FyZEhvc3RQcm9wRWZmZWN0KHByb3AsIHVzZXJGb3J3YXJkSG9zdFByb3ApfSk7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkoJ19ob3N0XycgKyBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBrbGFzcyk7XG4gICAgLy8gTWl4IGFueSBwcmUtYm91bmQgZGF0YSBpbnRvIF9fZGF0YTsgbm8gbmVlZCB0byBmbHVzaCB0aGlzIHRvXG4gICAgLy8gaW5zdGFuY2VzIHNpbmNlIHRoZXkgcHVsbCBmcm9tIHRoZSB0ZW1wbGF0ZSBhdCBpbnN0YW5jZS10aW1lXG4gICAgaWYgKHRlbXBsYXRlLl9fZGF0YVByb3RvKSB7XG4gICAgICAvLyBOb3RlLCBnZW5lcmFsbHkgYF9fZGF0YVByb3RvYCBjb3VsZCBiZSBjaGFpbmVkLCBidXQgaXQncyBndWFyYW50ZWVkXG4gICAgICAvLyB0byBub3QgYmUgc2luY2UgdGhpcyBpcyBhIHZhbmlsbGEgdGVtcGxhdGUgd2UganVzdCBhZGRlZCBlZmZlY3RzIHRvXG4gICAgICBPYmplY3QuYXNzaWduKHRlbXBsYXRlLl9fZGF0YSwgdGVtcGxhdGUuX19kYXRhUHJvdG8pO1xuICAgIH1cbiAgICAvLyBDbGVhciBhbnkgcGVuZGluZyBkYXRhIGZvciBwZXJmb3JtYW5jZVxuICAgIHRlbXBsYXRlLl9fZGF0YVRlbXAgPSB7fTtcbiAgICB0ZW1wbGF0ZS5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB0ZW1wbGF0ZS5fX2RhdGFPbGQgPSBudWxsO1xuICAgIHRlbXBsYXRlLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuZnVuY3Rpb24gY3JlYXRlRm9yd2FyZEhvc3RQcm9wRWZmZWN0KGhvc3RQcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb3J3YXJkSG9zdFByb3AodGVtcGxhdGUsIHByb3AsIHByb3BzKSB7XG4gICAgdXNlckZvcndhcmRIb3N0UHJvcC5jYWxsKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgcHJvcC5zdWJzdHJpbmcoJ19ob3N0XycubGVuZ3RoKSwgcHJvcHNbcHJvcF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICBkZWxldGUgaG9zdFByb3BzW2lwcm9wXTtcbiAgICBsZXQgdXNlck5vdGlmeUluc3RhbmNlUHJvcCA9IG9wdGlvbnMubm90aWZ5SW5zdGFuY2VQcm9wO1xuICAgIGlmICh1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGlwcm9wLFxuICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLk5PVElGWSxcbiAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaXByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApfSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmZvcndhcmRIb3N0UHJvcCAmJiB0ZW1wbGF0ZS5fX2RhdGFIb3N0KSB7XG4gICAgZm9yIChsZXQgaHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGhwcm9wLFxuICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLk5PVElGWSxcbiAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpbnN0UHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SW5zdGFuY2VQcm9wKGluc3QsIHByb3AsIHByb3BzKSB7XG4gICAgdXNlck5vdGlmeUluc3RhbmNlUHJvcC5jYWxsKGluc3QuX190ZW1wbGF0aXplT3duZXIsXG4gICAgICBpbnN0LCBwcm9wLCBwcm9wc1twcm9wXSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUhvc3RQcm9wRWZmZWN0KCkge1xuICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SG9zdFByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICBpbnN0Ll9fZGF0YUhvc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCgnX2hvc3RfJyArIHByb3AsIHByb3BzW3Byb3BdLCB0cnVlLCB0cnVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlcyB0aGF0IHV0aWxpemVcbiAqIFBvbHltZXIncyBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyIGZlYXR1cmVzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICogICAgIC8vIEluc3RhbmNlIHRoZSB0ZW1wbGF0ZSB3aXRoIGFuIGluaXRpYWwgZGF0YSBtb2RlbFxuICogICAgIGxldCBpbnN0YW5jZSA9IG5ldyBUZW1wbGF0ZUNsYXNzKHtteVByb3A6ICdpbml0aWFsJ30pO1xuICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGVsZW1lbnQncyBzaGFkb3cgRE9NXG4gKiAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICogICAgIC8vIENoYW5naW5nIGEgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlIHdpbGwgcHJvcGFnYXRlIHRvIGJpbmRpbmdzXG4gKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gKlxuICogVGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5IHBhc3NlZCB0byBgdGVtcGxhdGl6ZWAgYWxsb3dzIGZvciBjdXN0b21pemluZ1xuICogZmVhdHVyZXMgb2YgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBjbGFzcywgaW5jbHVkaW5nIGhvdyBvdXRlci1zY29wZSBob3N0XG4gKiBwcm9wZXJ0aWVzIHNob3VsZCBiZSBmb3J3YXJkZWQgaW50byB0ZW1wbGF0ZSBpbnN0YW5jZXMsIGhvdyBhbnkgaW5zdGFuY2VcbiAqIHByb3BlcnRpZXMgYWRkZWQgaW50byB0aGUgdGVtcGxhdGUncyBzY29wZSBzaG91bGQgYmUgbm90aWZpZWQgb3V0IHRvXG4gKiB0aGUgaG9zdCwgYW5kIHdoZXRoZXIgdGhlIGluc3RhbmNlIHNob3VsZCBiZSBkZWNvcmF0ZWQgYXMgYSBcInBhcmVudCBtb2RlbFwiXG4gKiBvZiBhbnkgZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogICAgIC8vIEN1c3RvbXplIHByb3BlcnR5IGZvcndhcmRpbmcgYW5kIGV2ZW50IG1vZGVsIGRlY29yYXRpb25cbiAqICAgICBsZXQgVGVtcGxhdGVDbGFzcyA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gKiAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAqICAgICAgIGluc3RhbmNlUHJvcHM6IHsuLi59LFxuICogICAgICAgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gKiAgICAgICBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlc1xuICogICB1dGlsaXppbmcgUG9seW1lciB0ZW1wbGF0aW5nIGZlYXR1cmVzLlxuICovXG5cbmNvbnN0IFRlbXBsYXRpemUgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgY2xhc3MgYm91bmQgdG8gdGhlXG4gICAqIGA8dGVtcGxhdGU+YCBwcm92aWRlZC4gIEluc3RhbmNpbmcgdGhlIGNsYXNzIHdpbGwgcmVzdWx0IGluIHRoZVxuICAgKiB0ZW1wbGF0ZSBiZWluZyBzdGFtcGVkIGludG8gZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGFzIHRoZSBpbnN0YW5jZSdzXG4gICAqIGByb290YCBwcm9wZXJ0eSwgYWZ0ZXIgd2hpY2ggaXQgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBET00uXG4gICAqXG4gICAqIFRlbXBsYXRlcyBtYXkgdXRpbGl6ZSBhbGwgUG9seW1lciBkYXRhLWJpbmRpbmcgZmVhdHVyZXMgYXMgd2VsbCBhc1xuICAgKiBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMuICBFdmVudCBsaXN0ZW5lcnMgYW5kIGlubGluZSBjb21wdXRpbmdcbiAgICogZnVuY3Rpb25zIGluIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgaG9zdCBvZiB0aGUgdGVtcGxhdGUuXG4gICAqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciByZXR1cm5lZCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudCBkaWN0aW9uYXJ5IG9mIGluaXRpYWxcbiAgICogcHJvcGVydHkgdmFsdWVzIHRvIHByb3BhZ2F0ZSBpbnRvIHRlbXBsYXRlIGJpbmRpbmdzLiAgQWRkaXRpb25hbGx5XG4gICAqIGhvc3QgcHJvcGVydGllcyBjYW4gYmUgZm9yd2FyZGVkIGluLCBhbmQgaW5zdGFuY2UgcHJvcGVydGllcyBjYW4gYmVcbiAgICogbm90aWZpZWQgb3V0IGJ5IHByb3ZpZGluZyBvcHRpb25hbCBjYWxsYmFja3MgaW4gdGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBWYWxpZCBjb25maWd1cmF0aW9uIGluIGBvcHRpb25zYCBhcmUgYXMgZm9sbG93czpcbiAgICpcbiAgICogLSBgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlbiBhIHByb3BlcnR5IHJlZmVyZW5jZWRcbiAgICogICBpbiB0aGUgdGVtcGxhdGUgY2hhbmdlZCBvbiB0aGUgdGVtcGxhdGUncyBob3N0LiBBcyB0aGlzIGxpYnJhcnkgZG9lc1xuICAgKiAgIG5vdCByZXRhaW4gcmVmZXJlbmNlcyB0byB0ZW1wbGF0ZXMgaW5zdGFuY2VkIGJ5IHRoZSB1c2VyLCBpdCBpcyB0aGVcbiAgICogICB0ZW1wbGF0aXplIG93bmVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZm9yd2FyZCBob3N0IHByb3BlcnR5IGNoYW5nZXMgaW50b1xuICAgKiAgIHVzZXItc3RhbXBlZCBpbnN0YW5jZXMuICBUaGUgYGluc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpYFxuICAgKiAgICBtZXRob2Qgb24gdGhlIGdlbmVyYXRlZCBjbGFzcyBzaG91bGQgYmUgY2FsbGVkIHRvIGZvcndhcmQgaG9zdFxuICAgKiAgIHByb3BlcnRpZXMgaW50byB0aGUgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBwcm9wZXJ0eS1jaGFuZ2VkXG4gICAqICAgbm90aWZpY2F0aW9ucy4gQW55IHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUgdGhhdCBhcmUgbm90XG4gICAqICAgZGVmaW5lZCBpbiBgaW5zdGFuY2VQcm9wc2Agd2lsbCBiZSBub3RpZmllZCB1cCB0byB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAqICAgYXV0b21hdGljYWxseS5cbiAgICogLSBgaW5zdGFuY2VQcm9wc2A6IERpY3Rpb25hcnkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkXG4gICAqICAgdG8gdGhlIGluc3RhbmNlIGJ5IHRoZSB0ZW1wbGF0aXplIG93bmVyLiAgVGhlc2UgcHJvcGVydGllcyBzaGFkb3cgYW55XG4gICAqICAgaG9zdCBwcm9wZXJ0aWVzLCBhbmQgY2hhbmdlcyB3aXRoaW4gdGhlIHRlbXBsYXRlIHRvIHRoZXNlIHByb3BlcnRpZXNcbiAgICogICB3aWxsIHJlc3VsdCBpbiBgbm90aWZ5SW5zdGFuY2VQcm9wYCBiZWluZyBjYWxsZWQuXG4gICAqIC0gYG11dGFibGVEYXRhYDogV2hlbiBgdHJ1ZWAsIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgd2lsbCBza2lwIHN0cmljdFxuICAgKiAgIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAqICAgXCJkaXJ0eVwiKS5cbiAgICogLSBgbm90aWZ5SW5zdGFuY2VQcm9wKGluc3RhbmNlLCBwcm9wZXJ0eSwgdmFsdWUpYDogQ2FsbGVkIHdoZW5cbiAgICogICBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBjaGFuZ2VzLiAgVXNlcnMgbWF5IGNob29zZSB0byBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAgIG9uIGUuZy4gdGhlIG93bmVyIHRvIG5vdGlmeSB0aGUgY2hhbmdlLlxuICAgKiAtIGBwYXJlbnRNb2RlbGA6IFdoZW4gYHRydWVgLCBldmVudHMgaGFuZGxlZCBieSBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnNcbiAgICogICAoYG9uLWV2ZW50PVwiaGFuZGxlclwiYCkgd2lsbCBiZSBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHkgcG9pbnRpbmdcbiAgICogICB0byB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhhdCBzdGFtcGVkIGl0LiAgSXQgd2lsbCBhbHNvIGJlIHJldHVybmVkXG4gICAqICAgZnJvbSBgaW5zdGFuY2UucGFyZW50TW9kZWxgIGluIGNhc2VzIHdoZXJlIHRlbXBsYXRlIGluc3RhbmNlIG5lc3RpbmdcbiAgICogICBjYXVzZXMgYW4gaW5uZXIgbW9kZWwgdG8gc2hhZG93IGFuIG91dGVyIG1vZGVsLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNsYXNzIHJldHVybmVkIGZyb20gYHRlbXBsYXRpemVgIGlzIGdlbmVyYXRlZCBvbmx5IG9uY2VcbiAgICogZm9yIGEgZ2l2ZW4gYDx0ZW1wbGF0ZT5gIHVzaW5nIGBvcHRpb25zYCBmcm9tIHRoZSBmaXJzdCBjYWxsIGZvciB0aGF0XG4gICAqIHRlbXBsYXRlLCBhbmQgdGhlIGNhY2hlZCBjbGFzcyBpcyByZXR1cm5lZCBmb3IgYWxsIHN1YnNlcXVlbnQgY2FsbHMgdG9cbiAgICogYHRlbXBsYXRpemVgIGZvciB0aGF0IHRlbXBsYXRlLiAgQXMgc3VjaCwgYG9wdGlvbnNgIGNhbGxiYWNrcyBzaG91bGQgbm90XG4gICAqIGNsb3NlIG92ZXIgb3duZXItc3BlY2lmaWMgcHJvcGVydGllcyBzaW5jZSBvbmx5IHRoZSBmaXJzdCBgb3B0aW9uc2AgaXNcbiAgICogdXNlZDsgcmF0aGVyLCBjYWxsYmFja3MgYXJlIGNhbGxlZCBib3VuZCB0byB0aGUgYG93bmVyYCwgYW5kIHNvIGNvbnRleHRcbiAgICogbmVlZGVkIGZyb20gdGhlIGNhbGxiYWNrcyAoc3VjaCBhcyByZWZlcmVuY2VzIHRvIGBpbnN0YW5jZXNgIHN0YW1wZWQpXG4gICAqIHNob3VsZCBiZSBzdG9yZWQgb24gdGhlIGBvd25lcmAgc3VjaCB0aGF0IHRoZXkgY2FuIGJlIHJldHJpZXZlZCB2aWEgYHRoaXNgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5UZW1wbGF0aXplXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHRlbXBsYXRpemVcbiAgICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IG93bmVyIE93bmVyIG9mIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZXM7XG4gICAqICAgYW55IG9wdGlvbmFsIGNhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoaXMgb3duZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIGRpY3Rpb25hcnkgKHNlZSBzdW1tYXJ5IGZvciBkZXRhaWxzKVxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UpfSBHZW5lcmF0ZWQgY2xhc3MgYm91bmQgdG8gdGhlIHRlbXBsYXRlXG4gICAqICAgcHJvdmlkZWRcbiAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAqL1xuICB0ZW1wbGF0aXplKHRlbXBsYXRlLCBvd25lciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi8ob3B0aW9ucyB8fCB7fSk7XG4gICAgaWYgKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgPHRlbXBsYXRlPiBjYW4gb25seSBiZSB0ZW1wbGF0aXplZCBvbmNlJyk7XG4gICAgfVxuICAgIHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAgbGV0IHRlbXBsYXRlSW5mbyA9IG93bmVyLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAvLyBHZXQgbWVtb2l6ZWQgYmFzZSBjbGFzcyBmb3IgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSwgd2hpY2hcbiAgICAvLyBpbmNsdWRlcyBwcm9wZXJ0eSBlZmZlY3RzIGZvciBiaW5kaW5nIHRlbXBsYXRlICYgZm9yd2FyZGluZ1xuICAgIGxldCBiYXNlQ2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZUluc3RhbmNlQ2xhc3M7XG4gICAgaWYgKCFiYXNlQ2xhc3MpIHtcbiAgICAgIGJhc2VDbGFzcyA9IGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgICB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZUluc3RhbmNlQ2xhc3MgPSBiYXNlQ2xhc3M7XG4gICAgfVxuICAgIC8vIEhvc3QgcHJvcGVydHkgZm9yd2FyZGluZyBtdXN0IGJlIGluc3RhbGxlZCBvbnRvIHRlbXBsYXRlIGluc3RhbmNlXG4gICAgYWRkUHJvcGFnYXRlRWZmZWN0cyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgICAvLyBTdWJjbGFzcyBiYXNlIGNsYXNzIGFuZCBhZGQgcmVmZXJlbmNlIGZvciB0aGlzIHNwZWNpZmljIHRlbXBsYXRlXG4gICAgbGV0IGtsYXNzID0gY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSBleHRlbmRzIGJhc2VDbGFzcyB7fTtcbiAgICBrbGFzcy5wcm90b3R5cGUuX21ldGhvZEhvc3QgPSBmaW5kTWV0aG9kSG9zdCh0ZW1wbGF0ZSk7XG4gICAga2xhc3MucHJvdG90eXBlLl9fZGF0YUhvc3QgPSB0ZW1wbGF0ZTtcbiAgICBrbGFzcy5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXIgPSBvd25lcjtcbiAgICBrbGFzcy5wcm90b3R5cGUuX19ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgIHJldHVybiAvKiogQHR5cGUge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9ICovKGtsYXNzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoXG4gICAqIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzXG4gICAqIGNvbnRhaW5lZCBpbi4gQSB0ZW1wbGF0ZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgVGVtcGxhdGVJbnN0YW5jZUJhc2VgLCBhbmQgc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgIGxldCBtb2RlbCA9IG1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5UZW1wbGF0aXplXG4gICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGhlIG1vZGVsIHdpbGwgYmUgcmV0dXJuZWQgZm9yXG4gICAqICAgZWxlbWVudHMgc3RhbXBlZCBmcm9tIHRoaXMgdGVtcGxhdGVcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gVGVtcGxhdGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZVxuICAgKiAgIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBlbGVtZW50XG4gICAqL1xuICBtb2RlbEZvckVsZW1lbnQodGVtcGxhdGUsIG5vZGUpIHtcbiAgICBsZXQgbW9kZWw7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIC8vIEFuIGVsZW1lbnQgd2l0aCBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIG1hcmtzIHRoZSB0b3AgYm91bmRhcnlcbiAgICAgIC8vIG9mIGEgc2NvcGU7IHdhbGsgdXAgdW50aWwgd2UgZmluZCBvbmUsIGFuZCB0aGVuIGVuc3VyZSB0aGF0XG4gICAgICAvLyBpdHMgX19kYXRhSG9zdCBtYXRjaGVzIGB0aGlzYCwgbWVhbmluZyB0aGlzIGRvbS1yZXBlYXQgc3RhbXBlZCBpdFxuICAgICAgaWYgKChtb2RlbCA9IG5vZGUuX190ZW1wbGF0aXplSW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIEZvdW5kIGFuIGVsZW1lbnQgc3RhbXBlZCBieSBhbm90aGVyIHRlbXBsYXRlOyBrZWVwIHdhbGtpbmcgdXBcbiAgICAgICAgLy8gZnJvbSBpdHMgX19kYXRhSG9zdFxuICAgICAgICBpZiAobW9kZWwuX19kYXRhSG9zdCAhPSB0ZW1wbGF0ZSkge1xuICAgICAgICAgIG5vZGUgPSBtb2RlbC5fX2RhdGFIb3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RpbGwgaW4gYSB0ZW1wbGF0ZSBzY29wZSwga2VlcCBnb2luZyB1cCB1bnRpbFxuICAgICAgICAvLyBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIGlzIGZvdW5kXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5leHBvcnQgeyBUZW1wbGF0aXplIH07XG5leHBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzIiwiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uLy4uL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBhcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwLCBUZW1wbGF0aXplIH0gZnJvbSAnLi4vdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyBlbnF1ZXVlRGVib3VuY2VyLCBmbHVzaCB9IGZyb20gJy4uL3V0aWxzL2ZsdXNoLmpzJztcbmltcG9ydCB7IE9wdGlvbmFsTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcbmltcG9ydCB7IG1hdGNoZXMsIHRyYW5zbGF0ZSB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuaW1wb3J0IHsgdGltZU91dCwgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuXG5sZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAqL1xuY29uc3QgZG9tUmVwZWF0QmFzZSA9IE9wdGlvbmFsTXV0YWJsZURhdGEoRWxlbWVudCk7XG5cbi8qKlxuICogVGhlIGA8ZG9tLXJlcGVhdD5gIGVsZW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHN0YW1wIGFuZCBiaW5kcyBvbmUgaW5zdGFuY2VcbiAqIG9mIHRlbXBsYXRlIGNvbnRlbnQgdG8gZWFjaCBvYmplY3QgaW4gYSB1c2VyLXByb3ZpZGVkIGFycmF5LlxuICogYGRvbS1yZXBlYXRgIGFjY2VwdHMgYW4gYGl0ZW1zYCBwcm9wZXJ0eSwgYW5kIG9uZSBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGVcbiAqIGlzIHN0YW1wZWQgZm9yIGVhY2ggaXRlbSBpbnRvIHRoZSBET00gYXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBgZG9tLXJlcGVhdGBcbiAqIGVsZW1lbnQuICBUaGUgYGl0ZW1gIHByb3BlcnR5IHdpbGwgYmUgc2V0IG9uIGVhY2ggaW5zdGFuY2UncyBiaW5kaW5nXG4gKiBzY29wZSwgdGh1cyB0ZW1wbGF0ZXMgc2hvdWxkIGJpbmQgdG8gc3ViLXByb3BlcnRpZXMgb2YgYGl0ZW1gLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gKlxuICogICA8dGVtcGxhdGU+XG4gKlxuICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIj5cbiAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgIDwvdGVtcGxhdGU+XG4gKlxuICogICA8c2NyaXB0PlxuICogICAgIFBvbHltZXIoe1xuICogICAgICAgaXM6ICdlbXBsb3llZS1saXN0JyxcbiAqICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gKiAgICAgICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAqICAgICAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICBdO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICogICA8IC9zY3JpcHQ+XG4gKlxuICogPC9kb20tbW9kdWxlPlxuICogYGBgXG4gKlxuICogTm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byBpdGVtcyBzdWItcHJvcGVydGllcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0ZW1wbGF0ZVxuICogaW5zdGFuY2VzLCB3aGljaCB3aWxsIHVwZGF0ZSB2aWEgdGhlIG5vcm1hbCBzdHJ1Y3R1cmVkIGRhdGEgbm90aWZpY2F0aW9uIHN5c3RlbS5cbiAqXG4gKiBNdXRhdGlvbnMgdG8gdGhlIGBpdGVtc2AgYXJyYXkgaXRzZWxmIHNob3VsZCBiZSBtYWRlIHVzaW5nIHRoZSBBcnJheVxuICogbXV0YXRpb24gQVBJJ3Mgb24gYFBvbHltZXIuQmFzZWAgKGBwdXNoYCwgYHBvcGAsIGBzcGxpY2VgLCBgc2hpZnRgLFxuICogYHVuc2hpZnRgKSwgYW5kIHRlbXBsYXRlIGluc3RhbmNlcyB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBkYXRhIGluIHRoZVxuICogYXJyYXkuXG4gKlxuICogRXZlbnRzIGNhdWdodCBieSBldmVudCBoYW5kbGVycyB3aXRoaW4gdGhlIGBkb20tcmVwZWF0YCB0ZW1wbGF0ZSB3aWxsIGJlXG4gKiBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHksIHdoaWNoIHJlcHJlc2VudHMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gKiBlYWNoIHRlbXBsYXRlIGluc3RhbmNlLiAgVGhlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIFBvbHltZXIuQmFzZSwgYW5kIHNob3VsZFxuICogYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgb24gdGhlIGluc3RhbmNlLCBmb3IgZXhhbXBsZVxuICogYGV2ZW50Lm1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB0aGUgbW9kZWwgZm9yIGEgdGVtcGxhdGUgaW5zdGFuY2UgZm9yIGFuIGVsZW1lbnQgc3RhbXBlZCBieVxuICogYSBgZG9tLXJlcGVhdGAgY2FuIGJlIG9idGFpbmVkIHVzaW5nIHRoZSBgbW9kZWxGb3JFbGVtZW50YCBBUEkgb24gdGhlXG4gKiBgZG9tLXJlcGVhdGAgdGhhdCBzdGFtcGVkIGl0LCBmb3IgZXhhbXBsZVxuICogYHRoaXMuJC5kb21SZXBlYXQubW9kZWxGb3JFbGVtZW50KGV2ZW50LnRhcmdldCkuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtgLlxuICogVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBtYW5pcHVsYXRpbmcgaW5zdGFuY2UgZGF0YSBvZiBldmVudCB0YXJnZXRzIG9idGFpbmVkXG4gKiBieSBldmVudCBoYW5kbGVycyBvbiBwYXJlbnRzIG9mIHRoZSBgZG9tLXJlcGVhdGAgKGV2ZW50IGRlbGVnYXRpb24pLlxuICpcbiAqIEEgdmlldy1zcGVjaWZpYyBmaWx0ZXIvc29ydCBtYXkgYmUgYXBwbGllZCB0byBlYWNoIGBkb20tcmVwZWF0YCBieSBzdXBwbHlpbmcgYVxuICogYGZpbHRlcmAgYW5kL29yIGBzb3J0YCBwcm9wZXJ0eS4gIFRoaXMgbWF5IGJlIGEgc3RyaW5nIHRoYXQgbmFtZXMgYSBmdW5jdGlvbiBvblxuICogdGhlIGhvc3QsIG9yIGEgZnVuY3Rpb24gbWF5IGJlIGFzc2lnbmVkIHRvIHRoZSBwcm9wZXJ0eSBkaXJlY3RseS4gIFRoZSBmdW5jdGlvbnNcbiAqIHNob3VsZCBpbXBsZW1lbnRlZCBmb2xsb3dpbmcgdGhlIHN0YW5kYXJkIGBBcnJheWAgZmlsdGVyL3NvcnQgQVBJLlxuICpcbiAqIEluIG9yZGVyIHRvIHJlLXJ1biB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb25zIGJhc2VkIG9uIGNoYW5nZXMgdG8gc3ViLWZpZWxkc1xuICogb2YgYGl0ZW1zYCwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2ZcbiAqIGBpdGVtYCBzdWItZmllbGRzIHRoYXQgc2hvdWxkIGNhdXNlIGEgcmUtZmlsdGVyL3NvcnQgd2hlbiBtb2RpZmllZC4gIElmXG4gKiB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb24gZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG5vdCBjb250YWluZWQgaW4gYGl0ZW1zYCxcbiAqIHRoZSB1c2VyIHNob3VsZCBvYnNlcnZlIGNoYW5nZXMgdG8gdGhvc2UgcHJvcGVydGllcyBhbmQgY2FsbCBgcmVuZGVyYCB0byB1cGRhdGVcbiAqIHRoZSB2aWV3IGJhc2VkIG9uIHRoZSBkZXBlbmRlbmN5IGNoYW5nZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZm9yIGFuIGBkb20tcmVwZWF0YCB3aXRoIGEgZmlsdGVyIG9mIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogYGBganNcbiAqIGlzRW5naW5lZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICByZXR1cm4gaXRlbS50eXBlID09ICdlbmdpbmVlcicgfHwgaXRlbS5tYW5hZ2VyLnR5cGUgPT0gJ2VuZ2luZWVyJztcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZW4gdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBzaG91bGQgYmUgY29uZmlndXJlZCBhcyBmb2xsb3dzOlxuICpcbiAqIGBgYGh0bWxcbiAqIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIlxuICogICAgICAgICAgIGZpbHRlcj1cImlzRW5naW5lZXJcIiBvYnNlcnZlPVwidHlwZSBtYW5hZ2VyLnR5cGVcIj5cbiAqIGBgYFxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBleHRlbmRzIHtkb21SZXBlYXRCYXNlfVxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBzdGFtcGluZyBpbnN0YW5jZSBvZiBhIHRlbXBsYXRlIGJvdW5kIHRvXG4gKiAgIGl0ZW1zIGluIGFuIGFycmF5LlxuICovXG5jbGFzcyBEb21SZXBlYXQgZXh0ZW5kcyBkb21SZXBlYXRCYXNlIHtcblxuICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLXJlcGVhdCc7IH1cblxuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAqIGByZW5kZXJgLlxuICAgICAqXG4gICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgKi9cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZGV0ZXJtaW5pbmcgaG93IG1hbnkgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogdG8gc3RhbXAgYW5kIHRoYXQgdGhhdCBlYWNoIHRlbXBsYXRlIGluc3RhbmNlIHNob3VsZCBiaW5kIHRvLlxuICAgICAgICovXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgYXJyYXlcbiAgICAgICAqIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICAgKi9cbiAgICAgIGFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpdGVtJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIHdpdGggdGhlIGluZGV4XG4gICAgICAgKiBvZiB0aGUgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcy5cbiAgICAgICAqIE5vdGUsIGZvciB0aGUgaW5kZXggaW4gdGhlIGB0aGlzLml0ZW1zYCBhcnJheSwgdXNlIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAqIGBpdGVtc0luZGV4QXNgIHByb3BlcnR5LlxuICAgICAgICovXG4gICAgICBpbmRleEFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpbmRleCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXkuIE5vdGUsIGZvciB0aGUgaW5kZXggb2ZcbiAgICAgICAqIHRoaXMgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcyxcbiAgICAgICAqIHVzZSB0aGUgdmFsdWUgb2YgdGhlIGBpbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAqL1xuICAgICAgaXRlbXNJbmRleEFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpdGVtc0luZGV4J1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGRldGVybWluZSB0aGUgc29ydCBvcmRlciBvZiB0aGUgaXRlbXMuICBUaGlzXG4gICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LnNvcnRgLlxuICAgICAgICogVXNpbmcgYSBzb3J0IGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAqL1xuICAgICAgc29ydDoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX3NvcnRDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIGl0ZW1zIG91dCBvZiB0aGUgdmlldy4gIFRoaXNcbiAgICAgICAqIHByb3BlcnR5IHNob3VsZCBlaXRoZXIgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcsIGluZGljYXRpbmcgYSBtZXRob2RcbiAgICAgICAqIG5hbWUgb24gdGhlIGVsZW1lbnQncyBob3N0LCBvciBlbHNlIGJlIGFuIGFjdHVhbCBmdW5jdGlvbi4gIFRoZVxuICAgICAgICogZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBzb3J0IGZ1bmN0aW9uIHBhc3NlZCB0byBgQXJyYXkuZmlsdGVyYC5cbiAgICAgICAqIFVzaW5nIGEgZmlsdGVyIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAqL1xuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICBvYnNlcnZlcjogJ19fZmlsdGVyQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB1c2luZyBhIGBmaWx0ZXJgIG9yIGBzb3J0YCBmdW5jdGlvbiwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eVxuICAgICAgICogc2hvdWxkIGJlIHNldCB0byBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBuYW1lcyBvZiBpdGVtXG4gICAgICAgKiBzdWItZmllbGRzIHRoYXQgc2hvdWxkIHRyaWdnZXIgYSByZS1zb3J0IG9yIHJlLWZpbHRlciB3aGVuIGNoYW5nZWQuXG4gICAgICAgKiBUaGVzZSBzaG91bGQgZ2VuZXJhbGx5IGJlIGZpZWxkcyBvZiBgaXRlbWAgdGhhdCB0aGUgc29ydCBvciBmaWx0ZXJcbiAgICAgICAqIGZ1bmN0aW9uIGRlcGVuZHMgb24uXG4gICAgICAgKi9cbiAgICAgIG9ic2VydmU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19fb2JzZXJ2ZUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgZGVsYXlgIHByb3BlcnR5XG4gICAgICAgKiBkZXRlcm1pbmVzIGEgZGVib3VuY2UgdGltZSBhZnRlciBhIGNoYW5nZSB0byBvYnNlcnZlZCBpdGVtXG4gICAgICAgKiBwcm9wZXJ0aWVzIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGUgZmlsdGVyIG9yIHNvcnQgaXMgcmUtcnVuLlxuICAgICAgICogVGhpcyBpcyB1c2VmdWwgaW4gcmF0ZS1saW1pdGluZyBzaHVmZmluZyBvZiB0aGUgdmlldyB3aGVuXG4gICAgICAgKiBpdGVtIGNoYW5nZXMgbWF5IGJlIGZyZXF1ZW50LlxuICAgICAgICovXG4gICAgICBkZWxheTogTnVtYmVyLFxuXG4gICAgICAvKipcbiAgICAgICAqIENvdW50IG9mIGN1cnJlbnRseSByZW5kZXJlZCBpdGVtcyBhZnRlciBgZmlsdGVyYCAoaWYgYW55KSBoYXMgYmVlbiBhcHBsaWVkLlxuICAgICAgICogSWYgXCJjaHVua2luZyBtb2RlXCIgaXMgZW5hYmxlZCwgYHJlbmRlcmVkSXRlbUNvdW50YCBpcyB1cGRhdGVkIGVhY2ggdGltZSBhXG4gICAgICAgKiBzZXQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIGlzIHJlbmRlcmVkLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgcmVuZGVyZWRJdGVtQ291bnQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIERlZmluZXMgYW4gaW5pdGlhbCBjb3VudCBvZiB0ZW1wbGF0ZSBpbnN0YW5jZXMgdG8gcmVuZGVyIGFmdGVyIHNldHRpbmdcbiAgICAgICAqIHRoZSBgaXRlbXNgIGFycmF5LCBiZWZvcmUgdGhlIG5leHQgcGFpbnQsIGFuZCBwdXRzIHRoZSBgZG9tLXJlcGVhdGBcbiAgICAgICAqIGludG8gXCJjaHVua2luZyBtb2RlXCIuICBUaGUgcmVtYWluaW5nIGl0ZW1zIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmVuZGVyZWRcbiAgICAgICAqIGluY3JlbWVudGFsbHkgYXQgZWFjaCBhbmltYXRpb24gZnJhbWUgdGhlcm9mIHVudGlsIGFsbCBpbnN0YW5jZXMgaGF2ZVxuICAgICAgICogYmVlbiByZW5kZXJlZC5cbiAgICAgICAqL1xuICAgICAgaW5pdGlhbENvdW50OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2luaXRpYWxpemVDaHVua2luZydcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiBgaW5pdGlhbENvdW50YCBpcyB1c2VkLCB0aGlzIHByb3BlcnR5IGRlZmluZXMgYSBmcmFtZSByYXRlIHRvXG4gICAgICAgKiB0YXJnZXQgYnkgdGhyb3R0bGluZyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyByZW5kZXJlZCBlYWNoIGZyYW1lIHRvXG4gICAgICAgKiBub3QgZXhjZWVkIHRoZSBidWRnZXQgZm9yIHRoZSB0YXJnZXQgZnJhbWUgcmF0ZS4gIFNldHRpbmcgdGhpcyB0byBhXG4gICAgICAgKiBoaWdoZXIgbnVtYmVyIHdpbGwgYWxsb3cgbG93ZXIgbGF0ZW5jeSBhbmQgaGlnaGVyIHRocm91Z2hwdXQgZm9yXG4gICAgICAgKiB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgYnV0IHdpbGwgcmVzdWx0IGluIGEgbG9uZ2VyIHRpbWUgZm9yIHRoZVxuICAgICAgICogcmVtYWluaW5nIGl0ZW1zIHRvIGNvbXBsZXRlIHJlbmRlcmluZy5cbiAgICAgICAqL1xuICAgICAgdGFyZ2V0RnJhbWVyYXRlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDIwXG4gICAgICB9LFxuXG4gICAgICBfdGFyZ2V0RnJhbWVUaW1lOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVGcmFtZVRpbWUodGFyZ2V0RnJhbWVyYXRlKSdcbiAgICAgIH1cblxuICAgIH07XG5cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgIHJldHVybiBbICdfX2l0ZW1zQ2hhbmdlZChpdGVtcy4qKScgXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX2luc3RhbmNlcyA9IFtdO1xuICAgIHRoaXMuX19saW1pdCA9IEluZmluaXR5O1xuICAgIHRoaXMuX19wb29sID0gW107XG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IG51bGw7XG4gICAgdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgdGhpcy5fX2NodW5rQ291bnQgPSBudWxsO1xuICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gbnVsbDtcbiAgICB0aGlzLl9fc29ydEZuID0gbnVsbDtcbiAgICB0aGlzLl9fZmlsdGVyRm4gPSBudWxsO1xuICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSBudWxsO1xuICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IG51bGw7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMuX19pc0RldGFjaGVkID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fX2RldGFjaEluc3RhbmNlKGkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgLy8gb25seSBwZXJmb3JtIGF0dGFjaG1lbnQgaWYgdGhlIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgaWYgKHRoaXMuX19pc0RldGFjaGVkKSB7XG4gICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX19hdHRhY2hJbnN0YW5jZShpLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9fZW5zdXJlVGVtcGxhdGl6ZWQoKSB7XG4gICAgLy8gVGVtcGxhdGl6aW5nIChnZW5lcmF0aW5nIHRoZSBpbnN0YW5jZSBjb25zdHJ1Y3RvcikgbmVlZHMgdG8gd2FpdFxuICAgIC8vIHVudGlsIHJlYWR5LCBzaW5jZSB3b24ndCBoYXZlIGl0cyB0ZW1wbGF0ZSBjb250ZW50IGhhbmRlZCBiYWNrIHRvXG4gICAgLy8gaXQgdW50aWwgdGhlblxuICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIC8vIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLXJlcGVhdCByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGVtcGxhdGUgaW5zdGFuY2UgcHJvcHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSBmb3J3YXJkaW5nXG4gICAgICBsZXQgaW5zdGFuY2VQcm9wcyA9IHt9O1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmFzXSA9IHRydWU7XG4gICAgICBpbnN0YW5jZVByb3BzW3RoaXMuaW5kZXhBc10gPSB0cnVlO1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLml0ZW1zSW5kZXhBc10gPSB0cnVlO1xuICAgICAgdGhpcy5fX2N0b3IgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgbXV0YWJsZURhdGE6IHRoaXMubXV0YWJsZURhdGEsXG4gICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZVByb3BzOiBpbnN0YW5jZVByb3BzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAgICAgKi9cbiAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgIGxldCBpJCA9IHRoaXMuX19pbnN0YW5jZXM7XG4gICAgICAgICAgZm9yIChsZXQgaT0wLCBpbnN0OyAoaTxpJC5sZW5ndGgpICYmIChpbnN0PWkkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBpbnN0LmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0IEluc3RhbmNlIHRvIG5vdGlmeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBub3RpZnlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBub3RpZnlcbiAgICAgICAgICovXG4gICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyh0aGlzLmFzLCBwcm9wKSkge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGluc3RbdGhpcy5pdGVtc0luZGV4QXNdO1xuICAgICAgICAgICAgaWYgKHByb3AgPT0gdGhpcy5hcykge1xuICAgICAgICAgICAgICB0aGlzLml0ZW1zW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXRoID0gdHJhbnNsYXRlKHRoaXMuYXMsICdpdGVtcy4nICsgaWR4LCBwcm9wKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5UGF0aChwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfX2dldE1ldGhvZEhvc3QoKSB7XG4gICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gICAgLy8gSW4gc2hhZG93IGRvbSwgdGhpcyBpcyBhbHdheXMgZ2V0Um9vdE5vZGUoKS5ob3N0LCBidXQgd2UgY2FuXG4gICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAgIC8vIGluc3RhbmNlIGNhdXNpbmcgaXQgdG8gZ2V0IGEgZGF0YUhvc3QuXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhSG9zdC5fbWV0aG9kSG9zdCB8fCB0aGlzLl9fZGF0YUhvc3Q7XG4gIH1cblxuICBfX3NvcnRDaGFuZ2VkKHNvcnQpIHtcbiAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgdGhpcy5fX3NvcnRGbiA9IHNvcnQgJiYgKHR5cGVvZiBzb3J0ID09ICdmdW5jdGlvbicgPyBzb3J0IDpcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtzb3J0XS5hcHBseShtZXRob2RIb3N0LCBhcmd1bWVudHMpOyB9KTtcbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9fZmlsdGVyQ2hhbmdlZChmaWx0ZXIpIHtcbiAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgdGhpcy5fX2ZpbHRlckZuID0gZmlsdGVyICYmICh0eXBlb2YgZmlsdGVyID09ICdmdW5jdGlvbicgPyBmaWx0ZXIgOlxuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2RIb3N0W2ZpbHRlcl0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2NvbXB1dGVGcmFtZVRpbWUocmF0ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoMTAwMC9yYXRlKTtcbiAgfVxuXG4gIF9faW5pdGlhbGl6ZUNodW5raW5nKCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxDb3VudCkge1xuICAgICAgdGhpcy5fX2xpbWl0ID0gdGhpcy5pbml0aWFsQ291bnQ7XG4gICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH1cblxuICBfX3RyeVJlbmRlckNodW5rKCkge1xuICAgIC8vIERlYm91bmNlZCBzbyB0aGF0IG11bHRpcGxlIGNhbGxzIHRocm91Z2ggYF9yZW5kZXJgIGJldHdlZW4gYW5pbWF0aW9uXG4gICAgLy8gZnJhbWVzIG9ubHkgcXVldWUgb25lIG5ldyByQUYgKGUuZy4gYXJyYXkgbXV0YXRpb24gJiBjaHVua2VkIHJlbmRlcilcbiAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLl9fbGltaXQgPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZXF1ZXN0UmVuZGVyQ2h1bmspO1xuICAgIH1cbiAgfVxuXG4gIF9fcmVxdWVzdFJlbmRlckNodW5rKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5fX3JlbmRlckNodW5rKCkpO1xuICB9XG5cbiAgX19yZW5kZXJDaHVuaygpIHtcbiAgICAvLyBTaW1wbGUgYXV0byBjaHVua1NpemUgdGhyb3R0bGluZyBhbGdvcml0aG0gYmFzZWQgb24gZmVlZGJhY2sgbG9vcDpcbiAgICAvLyBtZWFzdXJlIGFjdHVhbCB0aW1lIGJldHdlZW4gZnJhbWVzIGFuZCBzY2FsZSBjaHVuayBjb3VudCBieSByYXRpb1xuICAgIC8vIG9mIHRhcmdldC9hY3R1YWwgZnJhbWUgdGltZVxuICAgIGxldCBjdXJyQ2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgbGV0IHJhdGlvID0gdGhpcy5fdGFyZ2V0RnJhbWVUaW1lIC8gKGN1cnJDaHVua1RpbWUgLSB0aGlzLl9fbGFzdENodW5rVGltZSk7XG4gICAgdGhpcy5fX2NodW5rQ291bnQgPSBNYXRoLnJvdW5kKHRoaXMuX19jaHVua0NvdW50ICogcmF0aW8pIHx8IDE7XG4gICAgdGhpcy5fX2xpbWl0ICs9IHRoaXMuX19jaHVua0NvdW50O1xuICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gY3VyckNodW5rVGltZTtcbiAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gIH1cblxuICBfX29ic2VydmVDaGFuZ2VkKCkge1xuICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSB0aGlzLm9ic2VydmUgJiZcbiAgICAgIHRoaXMub2JzZXJ2ZS5yZXBsYWNlKCcuKicsICcuJykuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIF9faXRlbXNDaGFuZ2VkKGNoYW5nZSkge1xuICAgIGlmICh0aGlzLml0ZW1zICYmICFBcnJheS5pc0FycmF5KHRoaXMuaXRlbXMpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2RvbS1yZXBlYXQgZXhwZWN0ZWQgYXJyYXkgZm9yIGBpdGVtc2AsIGZvdW5kJywgdGhpcy5pdGVtcyk7XG4gICAgfVxuICAgIC8vIElmIHBhdGggd2FzIHRvIGFuIGl0ZW0gKGUuZy4gJ2l0ZW1zLjMnIG9yICdpdGVtcy4zLmZvbycpLCBmb3J3YXJkIHRoZVxuICAgIC8vIHBhdGggdG8gdGhhdCBpbnN0YW5jZSBzeW5jaHJvbm91c2x5IChyZXR1bnMgZmFsc2UgZm9yIG5vbi1pdGVtIHBhdGhzKVxuICAgIGlmICghdGhpcy5fX2hhbmRsZUl0ZW1QYXRoKGNoYW5nZS5wYXRoLCBjaGFuZ2UudmFsdWUpKSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBhcnJheSB3YXMgcmVzZXQgKCdpdGVtcycpIG9yIHNwbGljZWQgKCdpdGVtcy5zcGxpY2VzJyksXG4gICAgICAvLyBzbyBxdWV1ZSBhIGZ1bGwgcmVmcmVzaFxuICAgICAgdGhpcy5fX2luaXRpYWxpemVDaHVua2luZygpO1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9faGFuZGxlT2JzZXJ2ZWRQYXRocyhwYXRoKSB7XG4gICAgaWYgKHRoaXMuX19vYnNlcnZlUGF0aHMpIHtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhwYXRoLmluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgbGV0IHBhdGhzID0gdGhpcy5fX29ic2VydmVQYXRocztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKHBhdGhzW2ldKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyLCB0aGlzLmRlbGF5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6RG9tUmVwZWF0KX0gZm4gRnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gZGVsYXkgRGVsYXkgaW4gbXMgdG8gZGVib3VuY2UgYnkuXG4gICAqL1xuICBfX2RlYm91bmNlUmVuZGVyKGZuLCBkZWxheSA9IDApIHtcbiAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgLCBkZWxheSA+IDAgPyB0aW1lT3V0LmFmdGVyKGRlbGF5KSA6IG1pY3JvVGFza1xuICAgICAgICAsIGZuLmJpbmQodGhpcykpO1xuICAgIGVucXVldWVEZWJvdW5jZXIodGhpcy5fX3JlbmRlckRlYm91bmNlcik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICAvLyBRdWV1ZSB0aGlzIHJlcGVhdGVyLCB0aGVuIGZsdXNoIGFsbCBpbiBvcmRlclxuICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICBmbHVzaCgpO1xuICB9XG5cbiAgX19yZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9fZW5zdXJlVGVtcGxhdGl6ZWQoKSkge1xuICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19hcHBseUZ1bGxSZWZyZXNoKCk7XG4gICAgLy8gUmVzZXQgdGhlIHBvb2xcbiAgICAvLyBUT0RPKGtzY2hhYWYpOiBSZXVzZSBwb29sIGFjcm9zcyB0dXJucyBhbmQgbmVzdGVkIHRlbXBsYXRlc1xuICAgIC8vIE5vdyB0aGF0IG9iamVjdHMvYXJyYXlzIGFyZSByZS1ldmFsdWF0ZWQgd2hlbiBzZXQsIHdlIGNhbiBzYWZlbHlcbiAgICAvLyByZXVzZSBwb29sZWQgaW5zdGFuY2VzIGFjcm9zcyB0dXJucywgaG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGRlY2lkZVxuICAgIC8vIHNlbWFudGljcyByZWdhcmRpbmcgaG93IGxvbmcgdG8gaG9sZCwgaG93IG1hbnkgdG8gaG9sZCwgZXRjLlxuICAgIHRoaXMuX19wb29sLmxlbmd0aCA9IDA7XG4gICAgLy8gU2V0IHJlbmRlcmVkIGl0ZW0gY291bnRcbiAgICB0aGlzLl9zZXRSZW5kZXJlZEl0ZW1Db3VudCh0aGlzLl9faW5zdGFuY2VzLmxlbmd0aCk7XG4gICAgLy8gTm90aWZ5IHVzZXJzXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH0pKTtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgbW9yZSBpdGVtc1xuICAgIHRoaXMuX190cnlSZW5kZXJDaHVuaygpO1xuICB9XG5cbiAgX19hcHBseUZ1bGxSZWZyZXNoKCkge1xuICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG4gICAgbGV0IGlzbnRJZHhUb0l0ZW1zSWR4ID0gbmV3IEFycmF5KGl0ZW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpc250SWR4VG9JdGVtc0lkeFtpXSA9IGk7XG4gICAgfVxuICAgIC8vIEFwcGx5IHVzZXIgZmlsdGVyXG4gICAgaWYgKHRoaXMuX19maWx0ZXJGbikge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHggPSBpc250SWR4VG9JdGVtc0lkeC5maWx0ZXIoKGksIGlkeCwgYXJyYXkpID0+XG4gICAgICAgIHRoaXMuX19maWx0ZXJGbihpdGVtc1tpXSwgaWR4LCBhcnJheSkpO1xuICAgIH1cbiAgICAvLyBBcHBseSB1c2VyIHNvcnRcbiAgICBpZiAodGhpcy5fX3NvcnRGbikge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHguc29ydCgoYSwgYikgPT4gdGhpcy5fX3NvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pKTtcbiAgICB9XG4gICAgLy8gaXRlbXMtPmluc3QgbWFwIGtlcHQgZm9yIGl0ZW0gcGF0aCBmb3J3YXJkaW5nXG4gICAgY29uc3QgaXRlbXNJZHhUb0luc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHggPSB7fTtcbiAgICBsZXQgaW5zdElkeCA9IDA7XG4gICAgLy8gR2VuZXJhdGUgaW5zdGFuY2VzIGFuZCBhc3NpZ24gaXRlbXNcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKGlzbnRJZHhUb0l0ZW1zSWR4Lmxlbmd0aCwgdGhpcy5fX2xpbWl0KTtcbiAgICBmb3IgKDsgaW5zdElkeDxsaW1pdDsgaW5zdElkeCsrKSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICBsZXQgaXRlbUlkeCA9IGlzbnRJZHhUb0l0ZW1zSWR4W2luc3RJZHhdO1xuICAgICAgbGV0IGl0ZW0gPSBpdGVtc1tpdGVtSWR4XTtcbiAgICAgIGl0ZW1zSWR4VG9JbnN0SWR4W2l0ZW1JZHhdID0gaW5zdElkeDtcbiAgICAgIGlmIChpbnN0ICYmIGluc3RJZHggPCB0aGlzLl9fbGltaXQpIHtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuYXMsIGl0ZW0pO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgaW5zdGFuY2VzIGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICBmb3IgKGxldCBpPXRoaXMuX19pbnN0YW5jZXMubGVuZ3RoLTE7IGk+PWluc3RJZHg7IGktLSkge1xuICAgICAgdGhpcy5fX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGkpO1xuICAgIH1cbiAgfVxuXG4gIF9fZGV0YWNoSW5zdGFuY2UoaWR4KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgZm9yIChsZXQgaT0wOyBpPGluc3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBlbCA9IGluc3QuY2hpbGRyZW5baV07XG4gICAgICBpbnN0LnJvb3QuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIF9fYXR0YWNoSW5zdGFuY2UoaWR4LCBwYXJlbnQpIHtcbiAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaWR4XTtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc3Qucm9vdCwgdGhpcyk7XG4gIH1cblxuICBfX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX2RldGFjaEluc3RhbmNlKGlkeCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIHRoaXMuX19wb29sLnB1c2goaW5zdCk7XG4gICAgfVxuICAgIHRoaXMuX19pbnN0YW5jZXMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cblxuICBfX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgIGxldCBtb2RlbCA9IHt9O1xuICAgIG1vZGVsW3RoaXMuYXNdID0gaXRlbTtcbiAgICBtb2RlbFt0aGlzLmluZGV4QXNdID0gaW5zdElkeDtcbiAgICBtb2RlbFt0aGlzLml0ZW1zSW5kZXhBc10gPSBpdGVtSWR4O1xuICAgIHJldHVybiBuZXcgdGhpcy5fX2N0b3IobW9kZWwpO1xuICB9XG5cbiAgX19pbnNlcnRJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9fcG9vbC5wb3AoKTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgLy8gVE9ETyhrc2NoYWFmKTogSWYgdGhlIHBvb2wgaXMgc2hhcmVkIGFjcm9zcyB0dXJucywgaG9zdFByb3BzXG4gICAgICAvLyBuZWVkIHRvIGJlIHJlLXNldCB0byByZXVzZWQgaW5zdGFuY2VzIGluIGFkZGl0aW9uIHRvIGl0ZW1cbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmluZGV4QXMsIGluc3RJZHgpO1xuICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0ID0gdGhpcy5fX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgfVxuICAgIGxldCBiZWZvcmVSb3cgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHggKyAxXTtcbiAgICBsZXQgYmVmb3JlTm9kZSA9IGJlZm9yZVJvdyA/IGJlZm9yZVJvdy5jaGlsZHJlblswXSA6IHRoaXM7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnN0LnJvb3QsIGJlZm9yZU5vZGUpO1xuICAgIHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF0gPSBpbnN0O1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLy8gSW1wbGVtZW50cyBleHRlbnNpb24gcG9pbnQgZnJvbSBUZW1wbGF0aXplIG1peGluXG4gIF9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbikge1xuICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9faW5zdGFuY2VzW2ldLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGFzIGEgc2lkZSBlZmZlY3Qgb2YgYSBob3N0IGl0ZW1zLjxrZXk+LjxwYXRoPiBwYXRoIGNoYW5nZSxcbiAgLy8gcmVzcG9uc2libGUgZm9yIG5vdGlmeWluZyBpdGVtLjxwYXRoPiBjaGFuZ2VzIHRvIGluc3QgZm9yIGtleVxuICBfX2hhbmRsZUl0ZW1QYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgbGV0IGl0ZW1zUGF0aCA9IHBhdGguc2xpY2UoNik7IC8vICdpdGVtcy4nLmxlbmd0aCA9PSA2XG4gICAgbGV0IGRvdCA9IGl0ZW1zUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgbGV0IGl0ZW1zSWR4ID0gZG90IDwgMCA/IGl0ZW1zUGF0aCA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoMCwgZG90KTtcbiAgICAvLyBJZiBwYXRoIHdhcyBpbmRleCBpbnRvIGFycmF5Li4uXG4gICAgaWYgKGl0ZW1zSWR4ID09IHBhcnNlSW50KGl0ZW1zSWR4LCAxMCkpIHtcbiAgICAgIGxldCBpdGVtU3ViUGF0aCA9IGRvdCA8IDAgPyAnJyA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoZG90KzEpO1xuICAgICAgLy8gSWYgdGhlIHBhdGggaXMgb2JzZXJ2ZWQsIGl0IHdpbGwgdHJpZ2dlciBhIGZ1bGwgcmVmcmVzaFxuICAgICAgdGhpcy5fX2hhbmRsZU9ic2VydmVkUGF0aHMoaXRlbVN1YlBhdGgpO1xuICAgICAgLy8gTm90ZSwgZXZlbiBpZiBhIHJ1bGwgcmVmcmVzaCBpcyB0cmlnZ2VyZWQsIGFsd2F5cyBkbyB0aGUgcGF0aFxuICAgICAgLy8gbm90aWZpY2F0aW9uIGJlY2F1c2UgdW5sZXNzIG11dGFibGVEYXRhIGlzIHVzZWQgZm9yIGRvbS1yZXBlYXRcbiAgICAgIC8vIGFuZCBhbGwgZWxlbWVudHMgaW4gdGhlIGluc3RhbmNlIHN1YnRyZWUsIGEgZnVsbCByZWZyZXNoIG1heVxuICAgICAgLy8gbm90IHRyaWdnZXIgdGhlIHByb3BlciB1cGRhdGUuXG4gICAgICBsZXQgaW5zdElkeCA9IHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeFtpdGVtc0lkeF07XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICBsZXQgaXRlbVBhdGggPSB0aGlzLmFzICsgKGl0ZW1TdWJQYXRoID8gJy4nICsgaXRlbVN1YlBhdGggOiAnJyk7XG4gICAgICAgIC8vIFRoaXMgaXMgZWZmZWN0aXZlbHkgYG5vdGlmeVBhdGhgLCBidXQgYXZvaWRzIHNvbWUgb2YgdGhlIG92ZXJoZWFkXG4gICAgICAgIC8vIG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChpdGVtUGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAgICogdGhpcyBgZG9tLXJlcGVhdGAuXG4gICAqXG4gICAqIE5vdGUsIHRvIG1vZGlmeSBzdWItcHJvcGVydGllcyBvZiB0aGUgaXRlbSxcbiAgICogYG1vZGVsRm9yRWxlbWVudChlbCkuc2V0KCdpdGVtLjxzdWItcHJvcD4nLCB2YWx1ZSlgXG4gICAqIHNob3VsZCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gdGhlIGl0ZW0uXG4gICAqIEByZXR1cm4geyp9IEl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgaXRlbUZvckVsZW1lbnQoZWwpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLm1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW3RoaXMuYXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluc3QgaW5kZXggZm9yIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5IHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgKiBJZiBgc29ydGAgaXMgcHJvdmlkZWQsIHRoZSBpbmRleCB3aWxsIHJlZmxlY3QgdGhlIHNvcnRlZCBvcmRlciAocmF0aGVyXG4gICAqIHRoYW4gdGhlIG9yaWdpbmFsIGFycmF5IG9yZGVyKS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpbmRleC5cbiAgICogQHJldHVybiB7Kn0gUm93IGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudCAobm90ZSB0aGlzIG1heVxuICAgKiAgIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBhcnJheSBpbmRleCBpZiBhIHVzZXIgYHNvcnRgIGlzIGFwcGxpZWQpLlxuICAgKi9cbiAgaW5kZXhGb3JFbGVtZW50KGVsKSB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmluZGV4QXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2YgYFBvbHltZXIuQmFzZWAsIGFuZFxuICAgKiBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgKiAgIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIFRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMudGVtcGxhdGUsIGVsKTtcbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21SZXBlYXQuaXMsIERvbVJlcGVhdCk7XG5cbmV4cG9ydCB7IERvbVJlcGVhdCB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmpzJztcbmltcG9ydCB7IElyb25CdXR0b25TdGF0ZUltcGwgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJSaXBwbGVCZWhhdmlvciA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IHdpbGwgbm90IHByb2R1Y2UgYSByaXBwbGUgZWZmZWN0IHdoZW4gaW50ZXJhY3RlZFxuICAgICAqIHdpdGggdmlhIHRoZSBwb2ludGVyLlxuICAgICAqL1xuICAgIG5vaW5rOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgb2JzZXJ2ZXI6ICdfbm9pbmtDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgX3JpcHBsZUNvbnRhaW5lcjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZWxlbWVudCBpc1xuICAgKiBmb2N1c2VkLlxuICAgKi9cbiAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNlZCkge1xuICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGluIGBJcm9uQnV0dG9uU3RhdGVgLCBlbnN1cmVzXG4gICAqIGEgcmlwcGxlIGVmZmVjdCBpcyBjcmVhdGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgaW4gYSBgcHJlc3NlZGAgc3RhdGUuXG4gICAqL1xuICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgSXJvbkJ1dHRvblN0YXRlSW1wbC5fZG93bkhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyB0aGlzIGVsZW1lbnQgY29udGFpbnMgYSByaXBwbGUgZWZmZWN0LiBGb3Igc3RhcnR1cCBlZmZpY2llbmN5XG4gICAqIHRoZSByaXBwbGUgZWZmZWN0IGlzIGR5bmFtaWNhbGx5IG9uIGRlbWFuZCB3aGVuIG5lZWRlZC5cbiAgICogQHBhcmFtIHshRXZlbnQ9fSBvcHRUcmlnZ2VyaW5nRXZlbnQgKG9wdGlvbmFsKSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAgICogcmlwcGxlLlxuICAgKi9cbiAgZW5zdXJlUmlwcGxlOiBmdW5jdGlvbihvcHRUcmlnZ2VyaW5nRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIHRoaXMuX3JpcHBsZSA9IHRoaXMuX2NyZWF0ZVJpcHBsZSgpO1xuICAgICAgdGhpcy5fcmlwcGxlLm5vaW5rID0gdGhpcy5ub2luaztcbiAgICAgIHZhciByaXBwbGVDb250YWluZXIgPSB0aGlzLl9yaXBwbGVDb250YWluZXIgfHwgdGhpcy5yb290O1xuICAgICAgaWYgKHJpcHBsZUNvbnRhaW5lcikge1xuICAgICAgICBkb20ocmlwcGxlQ29udGFpbmVyKS5hcHBlbmRDaGlsZCh0aGlzLl9yaXBwbGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSByaXBwbGUgY29udGFpbmVyXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBob3N0IGluc3RlYWQgb2YgdGhlIHJvb3QgYmVjYXVzZSBkaXN0cmlidXRlZCB0ZXh0XG4gICAgICAgIC8vIG5vZGVzIGFyZSBub3QgdmFsaWQgZXZlbnQgdGFyZ2V0c1xuICAgICAgICB2YXIgZG9tQ29udGFpbmVyID0gZG9tKHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IGRvbShvcHRUcmlnZ2VyaW5nRXZlbnQpLnJvb3RUYXJnZXQ7XG4gICAgICAgIGlmIChkb21Db250YWluZXIuZGVlcENvbnRhaW5zKCAvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKSB7XG4gICAgICAgICAgdGhpcy5fcmlwcGxlLnVpRG93bkFjdGlvbihvcHRUcmlnZ2VyaW5nRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQgdXNlZCBieSB0aGlzIGVsZW1lbnQgdG8gY3JlYXRlXG4gICAqIHJpcHBsZSBlZmZlY3RzLiBUaGUgZWxlbWVudCdzIHJpcHBsZSBpcyBjcmVhdGVkIG9uIGRlbWFuZCwgd2hlblxuICAgKiBuZWNlc3NhcnksIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgZm9yY2UgdGhlXG4gICAqIHJpcHBsZSB0byBiZSBjcmVhdGVkLlxuICAgKi9cbiAgZ2V0UmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgIHJldHVybiB0aGlzLl9yaXBwbGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGVsZW1lbnQgY3VycmVudGx5IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1JpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fcmlwcGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBlbGVtZW50J3MgcmlwcGxlIGVmZmVjdCB2aWEgY3JlYXRpbmcgYSBgPHBhcGVyLXJpcHBsZT5gLlxuICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjdXN0b21pemUgdGhlIHJpcHBsZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshUGFwZXJSaXBwbGVFbGVtZW50fSBSZXR1cm5zIGEgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50LlxuICAgKi9cbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IVBhcGVyUmlwcGxlRWxlbWVudH0gKi8gKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1yaXBwbGUnKSk7XG4gIH0sXG5cbiAgX25vaW5rQ2hhbmdlZDogZnVuY3Rpb24obm9pbmspIHtcbiAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgdGhpcy5fcmlwcGxlLm5vaW5rID0gbm9pbms7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIGdyb3VwLlxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBncm91cC5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGlkOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgZnJvbSB0aGUgZ3JvdXAuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gbGF5ZXIgaW4gdGhpcy5fbGF5ZXJzID8gbGF5ZXIgOiB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgdGhpcy5fbGF5ZXJzW2lkXSkge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2lkXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBoYXNMYXllcihpZDogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiAhIWxheWVyICYmIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xlYXJMYXllcnMoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYWxsIHRoZSBsYXllcnMgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEl0ZXJhdGVzIG92ZXIgdGhlIGxheWVycyBvZiB0aGUgZ3JvdXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuXHQvLyBgYGBqc1xyXG5cdC8vIGdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHQvLyBcdGxheWVyLmJpbmRQb3B1cCgnSGVsbG8nKTtcclxuXHQvLyB9KTtcclxuXHQvLyBgYGBcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVyKGlkOiBOdW1iZXIpOiBMYXllclxyXG5cdC8vIFJldHVybnMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElELlxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJzKCk6IExheWVyW11cclxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbGF5ZXJzIGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsYXllcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllcnMucHVzaCh0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDYWxscyBgc2V0WkluZGV4YCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyB0aGUgei1pbmRleC5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnc2V0WkluZGV4JywgekluZGV4KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVySWQobGF5ZXI6IExheWVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgaW50ZXJuYWwgSUQgZm9yIGEgbGF5ZXJcclxuXHRnZXRMYXllcklkOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHJldHVybiBVdGlsLnN0YW1wKGxheWVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF5ZXJHcm91cChsYXllcnM/OiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbmV4cG9ydCB2YXIgbGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IExheWVyR3JvdXAobGF5ZXJzKTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9MYXllckdyb3VwLmpzIiwiXHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuQmFzZVxyXG4gKiBPYmplY3QgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db29yZGluYXRlX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLmpzIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi4vTGF5ZXInO1xyXG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJEcmFnfSBmcm9tICcuL01hcmtlci5EcmFnJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdHRpdGxlOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGljb24gaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4T2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBCeSBkZWZhdWx0LCBtYXJrZXIgaW1hZ2VzIHpJbmRleCBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgbGF0aXR1ZGUuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3Ugd2FudCB0byBwdXQgdGhlIG1hcmtlciBvbiB0b3Agb2YgYWxsIG90aGVycyAob3IgYmVsb3cpLCBzcGVjaWZ5aW5nIGEgaGlnaCB2YWx1ZSBsaWtlIGAxMDAwYCAob3IgaGlnaCBuZWdhdGl2ZSB2YWx1ZSwgcmVzcGVjdGl2ZWx5KS5cclxuXHRcdHpJbmRleE9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT25Ib3ZlcjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBtYXJrZXIgd2lsbCBnZXQgb24gdG9wIG9mIG90aGVycyB3aGVuIHlvdSBob3ZlciB0aGUgbW91c2Ugb3ZlciBpdC5cclxuXHRcdHJpc2VPbkhvdmVyOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPZmZzZXQ6IE51bWJlciA9IDI1MFxyXG5cdFx0Ly8gVGhlIHotaW5kZXggb2Zmc2V0IHVzZWQgZm9yIHRoZSBgcmlzZU9uSG92ZXJgIGZlYXR1cmUuXHJcblx0XHRyaXNlT2Zmc2V0OiAyNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnbWFya2VyUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIG1hcmtlcnMgaWNvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ21hcmtlclBhbmUnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIG1hcmtlciB3aWxsIHRyaWdnZXIgdGhlIHNhbWUgZXZlbnQgb24gdGhlIG1hcFxyXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXHJcblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IGxhdExuZyhsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLl96b29tQW5pbWF0ZWQgJiYgbWFwLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGlmICh0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcuZW5hYmxlZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5kcmFnZ2FibGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLnJlbW92ZUhvb2tzKCk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgdGhpcy5kcmFnZ2luZztcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIG1vdmVkIHZpYSBbYHNldExhdExuZ2BdKCNtYXJrZXItc2V0bGF0bG5nKSBvciBieSBbZHJhZ2dpbmddKCNtYXJrZXItZHJhZ2dpbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCB7b2xkTGF0TG5nOiBvbGRMYXRMbmcsIGxhdGxuZzogdGhpcy5fbGF0bG5nfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXhPZmZzZXQob2Zmc2V0OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleCBvZmZzZXRdKCNtYXJrZXItemluZGV4b2Zmc2V0KSBvZiB0aGUgbWFya2VyLlxyXG5cdHNldFpJbmRleE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9IG9mZnNldDtcclxuXHRcdHJldHVybiB0aGlzLnVwZGF0ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0SWNvbihpY29uOiBJY29uKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBpY29uLlxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXAsIHRoaXMuX3BvcHVwLm9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pY29uO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvcHRpb25zLmFsdCkge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgnc2hhZG93UGFuZScpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yIHx8IFswLCAwXTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvciB8fCBbMCwgMF07XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMiLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQGFrYSBMLkRyYWdnYWJsZVxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBBIGNsYXNzIGZvciBtYWtpbmcgRE9NIGVsZW1lbnRzIGRyYWdnYWJsZSAoaW5jbHVkaW5nIHRvdWNoIHN1cHBvcnQpLlxyXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGVsZW1lbnRUb0RyYWcpO1xyXG4gKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBTVEFSVCA9IEJyb3dzZXIudG91Y2ggPyAndG91Y2hzdGFydCBtb3VzZWRvd24nIDogJ21vdXNlZG93bic7XHJcbnZhciBFTkQgPSB7XHJcblx0bW91c2Vkb3duOiAnbW91c2V1cCcsXHJcblx0dG91Y2hzdGFydDogJ3RvdWNoZW5kJyxcclxuXHRwb2ludGVyZG93bjogJ3RvdWNoZW5kJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2hlbmQnXHJcbn07XHJcbnZhciBNT1ZFID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNlbW92ZScsXHJcblx0dG91Y2hzdGFydDogJ3RvdWNobW92ZScsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaG1vdmUnLFxyXG5cdE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcblx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdHRoaXMuZmluaXNoRHJhZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyB8fCBlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSAmJiAhZS50b3VjaGVzKSkgeyByZXR1cm47IH1cclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0aGlzOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUodGhpcy5fZWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG5cdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBNT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgRU5EW2UudHlwZV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxID8gZS50b3VjaGVzWzBdIDogZSksXHJcblx0XHQgICAgbmV3UG9pbnQgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3UG9pbnQuc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgc3RhcnRzXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcblx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRpZiAoKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpICYmICh0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSkge1xyXG5cdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fbGFzdEV2ZW50ID0gZTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcuXHJcblx0XHR0aGlzLmZpcmUoJ2RyYWcnLCBlKTtcclxuXHR9LFxyXG5cclxuXHRfb25VcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpIGluIE1PVkUpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBNT1ZFW2ldLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIEVORFtpXSwgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHRcdFx0Ly8gZW5zdXJlIGRyYWcgaXMgbm90IGZpcmVkIGFmdGVyIGRyYWdlbmRcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBkcmFnIGVuZHMuXHJcblx0XHRcdHRoaXMuZmlyZSgnZHJhZ2VuZCcsIHtcclxuXHRcdFx0XHRkaXN0YW5jZTogdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9EcmFnZ2FibGUuanMiLCJpbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cDovL3d3dy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIGltYWdlIHdpbGwgaGF2ZSBpdHMgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIGltYWdlIHBpeGVsIGRhdGEuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvck92ZXJsYXlVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIG92ZXJsYXkgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgb3ZlcmxheSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JPdmVybGF5VXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxyXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IFt6SW5kZXhdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4KSBvZiB0aGUgdGlsZSBsYXllci5cclxuXHRcdHpJbmRleDogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBpbWFnZS4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pbWFnZSk7XHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pbWFnZSk7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0T3BhY2l0eShvcGFjaXR5OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgb3ZlcmxheS5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlT3B0cykge1xyXG5cdFx0aWYgKHN0eWxlT3B0cy5vcGFjaXR5KSB7XHJcblx0XHRcdHRoaXMuc2V0T3BhY2l0eShzdHlsZU9wdHMub3BhY2l0eSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBvdmVybGF5cy5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gdXJsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gVXBkYXRlIHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0ge1xyXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldCxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZDogc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpIDogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFt6SW5kZXhdKCNpbWFnZW92ZXJsYXktemluZGV4KSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBHZXQgdGhlIGJvdW5kcyB0aGF0IHRoaXMgSW1hZ2VPdmVybGF5IGNvdmVyc1xyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxJbWFnZUVsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTEltYWdlRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gRG9tVXRpbC5jcmVhdGUoJ2ltZycsXHJcblx0XHRcdFx0J2xlYWZsZXQtaW1hZ2UtbGF5ZXIgJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnbGVhZmxldC16b29tLWFuaW1hdGVkJyA6ICcnKSArXHJcblx0XHRcdFx0ICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XHJcblxyXG5cdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHRpbWcub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdGltZy5vbmxvYWQgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cdFx0aW1nLm9uZXJyb3IgPSBVdGlsLmJpbmQodGhpcy5fb3ZlcmxheU9uRXJyb3IsIHRoaXMsICdlcnJvcicpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy56SW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHModGhpcy5fYm91bmRzLCBlLnpvb20sIGUuY2VudGVyKS5taW47XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgYm91bmRzID0gbmV3IEJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkpLFxyXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oaW1hZ2UsIGJvdW5kcy5taW4pO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRpbWFnZS5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb3ZlcmxheU9uRXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIEBldmVudCBlcnJvcjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0dGhpcy5maXJlKCdlcnJvcicpO1xyXG5cclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvck92ZXJsYXlVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGhpcy5fdXJsICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aGlzLl91cmwgPSBlcnJvclVybDtcclxuXHRcdFx0dGhpcy5faW1hZ2Uuc3JjID0gZXJyb3JVcmw7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsOiBTdHJpbmcsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogSW1hZ2VPdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSBpbWFnZSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuZXhwb3J0IHZhciBpbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEltYWdlT3ZlcmxheSh1cmwsIGJvdW5kcywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIHBvcHVwIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuZXhwb3J0IHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb2Zmc2V0OiBQb2ludCA9IFBvaW50KDAsIDcpXHJcblx0XHQvLyBUaGUgb2Zmc2V0IG9mIHRoZSBwb3B1cCBwb3NpdGlvbi4gVXNlZnVsIHRvIGNvbnRyb2wgdGhlIGFuY2hvclxyXG5cdFx0Ly8gb2YgdGhlIHBvcHVwIHdoZW4gb3BlbmluZyBpdCBvbiBzb21lIG92ZXJsYXlzLlxyXG5cdFx0b2Zmc2V0OiBbMCwgN10sXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdwb3B1cFBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBwb3B1cCB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogJ3BvcHVwUGFuZSdcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9yZW1vdmVUaW1lb3V0KTtcclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChEb21VdGlsLnJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiBwb3B1cC5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBBbGlhcyBmb3IgW2dldENvbnRlbnQoKV0oI3BvcHVwLWdldGNvbnRlbnQpXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIHBvcHVwIGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIHBvcHVwIGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBwb3B1cCBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIHRvIHRoZSBiYWNrIG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub2RlID0gdGhpcy5fY29udGVudE5vZGU7XHJcblx0XHR2YXIgY29udGVudCA9ICh0eXBlb2YgdGhpcy5fY29udGVudCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLl9jb250ZW50KHRoaXMuX3NvdXJjZSB8fCB0aGlzKSA6IHRoaXMuX2NvbnRlbnQ7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRub2RlLmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuXHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvRGl2T3ZlcmxheS5qcyIsImltcG9ydCB7R3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyXHJcbiAqIEBpbmhlcml0cyBHcmlkTGF5ZXJcclxuICogQGFrYSBMLlRpbGVMYXllclxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgdGlsZSBsYXllcnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHA6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJ30pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICogQGV4YW1wbGVcclxuICpcclxuICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gKlxyXG4gKiBgYGBcclxuICogJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL3tmb299L3t6fS97eH0ve3l9LnBuZycsIHtmb286ICdiYXInfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllciA9IEdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWluWm9vbTogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IDE4XHJcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHN1YmRvbWFpbnM6IFN0cmluZ3xTdHJpbmdbXSA9ICdhYmMnXHJcblx0XHQvLyBTdWJkb21haW5zIG9mIHRoZSB0aWxlIHNlcnZpY2UuIENhbiBiZSBwYXNzZWQgaW4gdGhlIGZvcm0gb2Ygb25lIHN0cmluZyAod2hlcmUgZWFjaCBsZXR0ZXIgaXMgYSBzdWJkb21haW4gbmFtZSkgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuXHRcdHN1YmRvbWFpbnM6ICdhYmMnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JUaWxlVXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSB0aWxlIGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIHRpbGUgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yVGlsZVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT2Zmc2V0OiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSBvZmZzZXQgd2l0aCB0aGlzIHZhbHVlLlxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRtczogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIGludmVyc2VzIFkgYXhpcyBudW1iZXJpbmcgZm9yIHRpbGVzICh0dXJuIHRoaXMgb24gZm9yIFtUTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS5cclxuXHRcdHRtczogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tUmV2ZXJzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgcmV2ZXJzZWQgKGBtYXhab29tIC0gem9vbWAgaW5zdGVhZCBvZiBgem9vbWApXHJcblx0XHR6b29tUmV2ZXJzZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBkZXRlY3RSZXRpbmE6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgIGFuZCB1c2VyIGlzIG9uIGEgcmV0aW5hIGRpc3BsYXksIGl0IHdpbGwgcmVxdWVzdCBmb3VyIHRpbGVzIG9mIGhhbGYgdGhlIHNwZWNpZmllZCBzaXplIGFuZCBhIGJpZ2dlciB6b29tIGxldmVsIGluIHBsYWNlIG9mIG9uZSB0byB1dGlsaXplIHRoZSBoaWdoIHJlc29sdXRpb24uXHJcblx0XHRkZXRlY3RSZXRpbmE6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvICcnLiBUaGlzIGlzIG5lZWRlZCBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgdGlsZSBwaXhlbCBkYXRhLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGRldGVjdGluZyByZXRpbmEgZGlzcGxheXMsIGFkanVzdGluZyB0aWxlU2l6ZSBhbmQgem9vbSBsZXZlbHNcclxuXHRcdGlmIChvcHRpb25zLmRldGVjdFJldGluYSAmJiBCcm93c2VyLnJldGluYSAmJiBvcHRpb25zLm1heFpvb20gPiAwKSB7XHJcblxyXG5cdFx0XHRvcHRpb25zLnRpbGVTaXplID0gTWF0aC5mbG9vcihvcHRpb25zLnRpbGVTaXplIC8gMik7XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHRcdFx0XHRvcHRpb25zLm1heFpvb20tLTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20rKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3B0aW9ucy5taW5ab29tID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5ab29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuc3ViZG9tYWlucyA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0b3B0aW9ucy5zdWJkb21haW5zID0gb3B0aW9ucy5zdWJkb21haW5zLnNwbGl0KCcnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTM3XHJcblx0XHRpZiAoIUJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9waWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnbG9hZCcsIFV0aWwuYmluZCh0aGlzLl90aWxlT25Mb2FkLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblx0XHREb21FdmVudC5vbih0aWxlLCAnZXJyb3InLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uRXJyb3IsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSAnJztcclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0IEFsdCB0YWcgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBrZWVwIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBVUkwgYW5kIGZvciBjb21wbGlhbmNlIHJlYXNvbnNcclxuXHRcdCBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvSDY3XHJcblx0XHQqL1xyXG5cdFx0dGlsZS5hbHQgPSAnJztcclxuXHJcblx0XHQvKlxyXG5cdFx0IFNldCByb2xlPVwicHJlc2VudGF0aW9uXCIgdG8gZm9yY2Ugc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoaXNcclxuXHRcdCBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEvcm9sZXMjdGV4dGFsdGVybmF0aXZlY29tcHV0YXRpb25cclxuXHRcdCovXHJcblx0XHR0aWxlLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuXHJcblx0XHR0aWxlLnNyYyA9IHRoaXMuZ2V0VGlsZVVybChjb29yZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXHJcblx0Ly8gQHVuaW5oZXJpdGFibGVcclxuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIG1pZ2h0IHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxyXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVVybChjb29yZHM6IE9iamVjdCk6IFN0cmluZ1xyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIHJldHVybnMgdGhlIFVSTCBmb3IgYSB0aWxlIGdpdmVuIGl0cyBjb29yZGluYXRlcy5cclxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIGN1c3RvbSB0aWxlIFVSTCBuYW1pbmcgc2NoZW1lcy5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0cjogQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuXHRcdFx0eDogY29vcmRzLngsXHJcblx0XHRcdHk6IGNvb3Jkcy55LFxyXG5cdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuXHRcdH07XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG5cdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBVdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgVXRpbC5leHRlbmQoZGF0YSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkxvYWQ6IGZ1bmN0aW9uIChkb25lLCB0aWxlKSB7XHJcblx0XHQvLyBGb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMzMzMlxyXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHtcclxuXHRcdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZG9uZSwgdGhpcywgbnVsbCwgdGlsZSksIDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZG9uZShudWxsLCB0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uRXJyb3I6IGZ1bmN0aW9uIChkb25lLCB0aWxlLCBlKSB7XHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRpbGUuc3JjICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBVdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRVBTRzQzMjYnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB3bXNQYXJhbXMuaGVpZ2h0ID0gb3B0aW9ucy50aWxlU2l6ZSAqIChvcHRpb25zLmRldGVjdFJldGluYSAmJiByZXRpbmEgPyAyIDogMSk7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKSxcclxuXHRcdCAgICBudyA9IHRoaXMuX2Nycy5wcm9qZWN0KHRpbGVCb3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgIHNlID0gdGhpcy5fY3JzLnByb2plY3QodGlsZUJvdW5kcy5nZXRTb3V0aEVhc3QoKSksXHJcblxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHRcdCAgICBbc2UueSwgbncueCwgbncueSwgc2UueF0gOlxyXG5cdFx0XHQgICAgW253LngsIHNlLnksIHNlLngsIG53LnldKS5qb2luKCcsJyksXHJcblxyXG5cdFx0ICAgIHVybCA9IFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHVybCArXHJcblx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKlxyXG4gKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHNDMyNiA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IExvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHNDMyNi5qcyIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanMiLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0IFszNy43NywgLTEyMi40M10sXG4gKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICogXTtcbiAqIGBgYFxuICovXG5cblxuZXhwb3J0IHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdGNsb3Nlc3RMYXllclBvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5LFxuXHRcdCAgICBtaW5Qb2ludCA9IG51bGwsXG5cdFx0ICAgIGNsb3Nlc3QgPSBMaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xuXHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IExpbmVVdGlsLmlzRmxhdChsYXRsbmdzKTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZmxhdCkge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0b0xhdExuZyhsYXRsbmdzW2ldKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChyZXN1bHRbaV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5nc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHRpZiAodGhpcy5fYm91bmRzLmlzVmFsaWQoKSAmJiBweEJvdW5kcy5pc1ZhbGlkKCkpIHtcblx0XHRcdHB4Qm91bmRzLm1pbi5fc3VidHJhY3QocCk7XG5cdFx0XHRweEJvdW5kcy5tYXguX2FkZChwKTtcblx0XHRcdHRoaXMuX3B4Qm91bmRzID0gcHhCb3VuZHM7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IHR1cm5zIGxhdGxuZ3MgaW50byBhIHNldCBvZiByaW5ncyB3aXRoIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRfcHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcykge1xuXHRcdHZhciBmbGF0ID0gbGF0bG5nc1swXSBpbnN0YW5jZW9mIExhdExuZyxcblx0XHQgICAgbGVuID0gbGF0bG5ncy5sZW5ndGgsXG5cdFx0ICAgIGksIHJpbmc7XG5cblx0XHRpZiAoZmxhdCkge1xuXHRcdFx0cmluZyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJpbmdbaV0gPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHRwcm9qZWN0ZWRCb3VuZHMuZXh0ZW5kKHJpbmdbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2gocmluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyhsYXRsbmdzW2ldLCByZXN1bHQsIHByb2plY3RlZEJvdW5kcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNsaXAgcG9seWxpbmUgYnkgcmVuZGVyZXIgYm91bmRzIHNvIHRoYXQgd2UgaGF2ZSBsZXNzIHRvIHJlbmRlciBmb3IgcGVyZm9ybWFuY2Vcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcztcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIGksIGosIGssIGxlbiwgbGVuMiwgc2VnbWVudCwgcG9pbnRzO1xuXG5cdFx0Zm9yIChpID0gMCwgayA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSB0aGlzLl9yaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBMaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTGluZVV0aWwuc2ltcGxpZnkocGFydHNbaV0sIHRvbGVyYW5jZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NsaXBQb2ludHMoKTtcblx0XHR0aGlzLl9zaW1wbGlmeVBvaW50cygpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpO1xuXHR9LFxuXG5cdC8vIE5lZWRlZCBieSB0aGUgYENhbnZhc2AgcmVuZGVyZXIgZm9yIGludGVyYWN0aXZpdHlcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwLCBjbG9zZWQpIHtcblx0XHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcblxuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gaGl0IGRldGVjdGlvbiBmb3IgcG9seWxpbmVzXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdGlmIChMaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmUobGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuXG4vLyBSZXRyb2NvbXBhdC4gQWxsb3cgcGx1Z2lucyB0byBzdXBwb3J0IExlYWZsZXQgdmVyc2lvbnMgYmVmb3JlIGFuZCBhZnRlciAxLjEuXG5Qb2x5bGluZS5fZmxhdCA9IExpbmVVdGlsLl9mbGF0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvUG9seWxpbmUuanMiLCJpbXBvcnQge1BvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0ICogYXMgUG9seVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9seVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBha2EgTC5Qb2x5Z29uXG4gKiBAaW5oZXJpdHMgUG9seWxpbmVcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlnb24gb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlsaW5lYC5cbiAqXG4gKiBOb3RlIHRoYXQgcG9pbnRzIHlvdSBwYXNzIHdoZW4gY3JlYXRpbmcgYSBwb2x5Z29uIHNob3VsZG4ndCBoYXZlIGFuIGFkZGl0aW9uYWwgbGFzdCBwb2ludCBlcXVhbCB0byB0aGUgZmlyc3Qgb25lIOKAlCBpdCdzIGJldHRlciB0byBmaWx0ZXIgb3V0IHN1Y2ggcG9pbnRzLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWdvbiBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dO1xuICpcbiAqIHZhciBwb2x5Z29uID0gTC5wb2x5Z29uKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWdvblxuICogbWFwLmZpdEJvdW5kcyhwb2x5Z29uLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB3aXRoIHRoZSBmaXJzdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIG91dGVyIHNoYXBlIGFuZCB0aGUgb3RoZXIgYXJyYXlzIHJlcHJlc2VudGluZyBob2xlcyBpbiB0aGUgb3V0ZXIgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogICBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV0sIC8vIG91dGVyIHJpbmdcbiAqICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbMzcuMjksIC0xMDguNThdLFs0MC43MSwgLTEwOC41OF0sWzQwLjcxLCAtMTAyLjUwXSxbMzcuMjksIC0xMDIuNTBdXSAvLyBob2xlXG4gKiAgIF0sXG4gKiAgIFsgLy8gc2Vjb25kIHBvbHlnb25cbiAqICAgICBbWzQxLCAtMTExLjAzXSxbNDUsIC0xMTEuMDRdLFs0NSwgLTEwNC4wNV0sWzQxLCAtMTA0LjA1XV1cbiAqICAgXVxuICogXTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgUG9seWdvbiA9IFBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0cDEgPSBwYXJ0W2pdO1xuXHRcdFx0XHRwMiA9IHBhcnRba107XG5cblx0XHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcblx0XHRcdFx0XHRpbnNpZGUgPSAhaW5zaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYWxzbyBjaGVjayBpZiBpdCdzIG9uIHBvbHlnb24gc3Ryb2tlXG5cdFx0cmV0dXJuIGluc2lkZSB8fCBQb2x5bGluZS5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQuY2FsbCh0aGlzLCBwLCB0cnVlKTtcblx0fVxuXG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnBvbHlnb24obGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb24obGF0bG5ncywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5Z29uLmpzIiwiaW1wb3J0IHsgcmVzb2x2ZUNzcyB9IGZyb20gJy4vcmVzb2x2ZS11cmwuanMnO1xuXG5jb25zdCBNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUiA9ICdsaW5rW3JlbD1pbXBvcnRdW3R5cGV+PWNzc10nO1xuY29uc3QgSU5DTFVERV9BVFRSID0gJ2luY2x1ZGUnO1xuXG5mdW5jdGlvbiBpbXBvcnRNb2R1bGUobW9kdWxlSWQpIHtcbiAgY29uc3QgLyoqIFBvbHltZXIuRG9tTW9kdWxlICovIFBvbHltZXJEb21Nb2R1bGUgPSBjdXN0b21FbGVtZW50cy5nZXQoJ2RvbS1tb2R1bGUnKTtcbiAgaWYgKCFQb2x5bWVyRG9tTW9kdWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFBvbHltZXJEb21Nb2R1bGUuaW1wb3J0KG1vZHVsZUlkKTtcbn1cblxuLyoqIEB0eXBlZGVmIHt7YXNzZXRwYXRoOiBzdHJpbmd9fSAqL1xubGV0IHRlbXBsYXRlV2l0aEFzc2V0UGF0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZXMobW9kdWxlSWRzKSB7XG4gIGxldCBtb2R1bGVzID0gbW9kdWxlSWRzLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3NzVGV4dCArPSBjc3NGcm9tTW9kdWxlKG1vZHVsZXNbaV0pO1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZShtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIGlmIChtICYmIG0uX2Nzc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIG1vZHVsZSBpbXBvcnRzOiA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+XG4gICAgbGV0IGNzc1RleHQgPSBfY3NzRnJvbU1vZHVsZUltcG9ydHMobSk7XG4gICAgLy8gaW5jbHVkZSBjc3MgZnJvbSB0aGUgZmlyc3QgdGVtcGxhdGUgaW4gdGhlIG1vZHVsZVxuICAgIGxldCB0ID0gbS5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgIGlmICh0KSB7XG4gICAgICBjc3NUZXh0ICs9IGNzc0Zyb21UZW1wbGF0ZSh0LCAvKiogQHR5cGUge3RlbXBsYXRlV2l0aEFzc2V0UGF0aH0gKi8obSkuYXNzZXRwYXRoKTtcbiAgICB9XG4gICAgbS5fY3NzVGV4dCA9IGNzc1RleHQgfHwgbnVsbDtcbiAgfVxuICBpZiAoIW0pIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHN0eWxlIGRhdGEgaW4gbW9kdWxlIG5hbWVkJywgbW9kdWxlSWQpO1xuICB9XG4gIHJldHVybiBtICYmIG0uX2Nzc1RleHQgfHwgJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpIHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgLy8gaWYgZWxlbWVudCBpcyBhIHRlbXBsYXRlLCBnZXQgY29udGVudCBmcm9tIGl0cyAuY29udGVudFxuICBsZXQgZSQgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gIGZvciAobGV0IGk9MDsgaSA8IGUkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGUgPSBlJFtpXTtcbiAgICAvLyBzdXBwb3J0IHN0eWxlIHNoYXJpbmcgYnkgYWxsb3dpbmcgc3R5bGVzIHRvIFwiaW5jbHVkZVwiXG4gICAgLy8gb3RoZXIgZG9tLW1vZHVsZXMgdGhhdCBjb250YWluIHN0eWxpbmdcbiAgICBsZXQgaW5jbHVkZSA9IGUuZ2V0QXR0cmlidXRlKElOQ0xVREVfQVRUUik7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGNzc1RleHQgKz0gY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSk7XG4gICAgfVxuICAgIGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTtcbiAgICBjc3NUZXh0ICs9IGJhc2VVUkkgP1xuICAgICAgcmVzb2x2ZUNzcyhlLnRleHRDb250ZW50LCBiYXNlVVJJKSA6IGUudGV4dENvbnRlbnQ7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIHJldHVybiBtID8gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG0pIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlKSB7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIGxldCBwJCA9IG1vZHVsZS5xdWVyeVNlbGVjdG9yQWxsKE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SKTtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcCQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcCA9IHAkW2ldO1xuICAgIGlmIChwLmltcG9ydCkge1xuICAgICAgbGV0IGltcG9ydERvYyA9IHAuaW1wb3J0O1xuICAgICAgLy8gTk9URTogcG9seWZpbGwgYWZmb3JkYW5jZS5cbiAgICAgIC8vIHVuZGVyIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbCwgdGhlcmUgd2lsbCBiZSBubyAnYm9keScsXG4gICAgICAvLyBidXQgdGhlIGltcG9ydCBwc2V1ZG8tZG9jIGNhbiBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAgbGV0IGNvbnRhaW5lciA9IGltcG9ydERvYy5ib2R5ID8gaW1wb3J0RG9jLmJvZHkgOiBpbXBvcnREb2M7XG4gICAgICBjc3NUZXh0ICs9XG4gICAgICAgIHJlc29sdmVDc3MoY29udGFpbmVyLnRleHRDb250ZW50LFxuICAgICAgICAgIGltcG9ydERvYy5iYXNlVVJJKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3N0eWxlLWdhdGhlci5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlVXJsLCBwYXRoRnJvbVVybCB9IGZyb20gJy4uL3V0aWxzL3Jlc29sdmUtdXJsLmpzJztcblxubGV0IG1vZHVsZXMgPSB7fTtcbmxldCBsY01vZHVsZXMgPSB7fTtcbmZ1bmN0aW9uIGZpbmRNb2R1bGUoaWQpIHtcbiAgcmV0dXJuIG1vZHVsZXNbaWRdIHx8IGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXTtcbn1cblxuZnVuY3Rpb24gc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayhpbnN0KSB7XG4gIGlmIChpbnN0LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpIHtcbiAgICBjb25zb2xlLndhcm4oJ2RvbS1tb2R1bGUgJXMgaGFzIHN0eWxlIG91dHNpZGUgdGVtcGxhdGUnLCBpbnN0LmlkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgZG9tLW1vZHVsZWAgZWxlbWVudCByZWdpc3RlcnMgdGhlIGRvbSBpdCBjb250YWlucyB0byB0aGUgbmFtZSBnaXZlblxuICogYnkgdGhlIG1vZHVsZSdzIGlkIGF0dHJpYnV0ZS4gSXQgcHJvdmlkZXMgYSB1bmlmaWVkIGRhdGFiYXNlIG9mIGRvbVxuICogYWNjZXNzaWJsZSB2aWEgaXRzIHN0YXRpYyBgaW1wb3J0YCBBUEkuXG4gKlxuICogQSBrZXkgdXNlIGNhc2Ugb2YgYGRvbS1tb2R1bGVgIGlzIGZvciBwcm92aWRpbmcgY3VzdG9tIGVsZW1lbnQgYDx0ZW1wbGF0ZT5gc1xuICogdmlhIEhUTUwgaW1wb3J0cyB0aGF0IGFyZSBwYXJzZWQgYnkgdGhlIG5hdGl2ZSBIVE1MIHBhcnNlciwgdGhhdCBjYW4gYmVcbiAqIHJlbG9jYXRlZCBkdXJpbmcgYSBidW5kbGluZyBwYXNzIGFuZCBzdGlsbCBsb29rZWQgdXAgYnkgYGlkYC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA8ZG9tLW1vZHVsZSBpZD1cImZvb1wiPlxuICogICAgICAgPGltZyBzcmM9XCJzdHVmZi5wbmdcIj5cbiAqICAgICA8L2RvbS1tb2R1bGU+XG4gKlxuICogVGhlbiBpbiBjb2RlIGluIHNvbWUgb3RoZXIgbG9jYXRpb24gdGhhdCBjYW5ub3QgYWNjZXNzIHRoZSBkb20tbW9kdWxlIGFib3ZlXG4gKlxuICogICAgIGxldCBpbWcgPSBjdXN0b21FbGVtZW50cy5nZXQoJ2RvbS1tb2R1bGUnKS5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IHByb3ZpZGVzIGEgcmVnaXN0cnkgb2YgcmVsb2NhdGFibGUgRE9NIGNvbnRlbnRcbiAqICAgYnkgYGlkYCB0aGF0IGlzIGFnbm9zdGljIHRvIGJ1bmRsaW5nLlxuICogQHVucmVzdHJpY3RlZFxuICovXG5jbGFzcyBEb21Nb2R1bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ2lkJ107IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgY3NzIGBzZWxlY3RvcmAgaW4gdGhlIG1vZHVsZVxuICAgKiByZWdpc3RlcmVkIGJ5IGBpZGAuIEZvciBleGFtcGxlLCB0aGlzLmltcG9ydCgnZm9vJywgJ2ltZycpO1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBkb20tbW9kdWxlIGluIHdoaWNoIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3RvciBUaGUgY3NzIHNlbGVjdG9yIGJ5IHdoaWNoIHRvIGZpbmQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGVsZW1lbnQgd2hpY2ggbWF0Y2hlcyBgc2VsZWN0b3JgIGluIHRoZVxuICAgKiBtb2R1bGUgcmVnaXN0ZXJlZCBhdCB0aGUgc3BlY2lmaWVkIGBpZGAuXG4gICAqL1xuICBzdGF0aWMgaW1wb3J0KGlkLCBzZWxlY3Rvcikge1xuICAgIGlmIChpZCkge1xuICAgICAgbGV0IG0gPSBmaW5kTW9kdWxlKGlkKTtcbiAgICAgIGlmIChtICYmIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5yZWdpc3RlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGlzIGBkb20tbW9kdWxlYC5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSB3aWxsIGRpZmZlciBmcm9tIHRoaXMgZWxlbWVudCdzIGBvd25lckRvY3VtZW50YCBpbiB0aGVcbiAgICogZm9sbG93aW5nIHdheXM6XG4gICAqIC0gVGFrZXMgaW50byBhY2NvdW50IGFueSBgYXNzZXRwYXRoYCBhdHRyaWJ1dGUgYWRkZWQgZHVyaW5nIGJ1bmRsaW5nXG4gICAqICAgdG8gaW5kaWNhdGUgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBidW5kbGVkIGxvY2F0aW9uXG4gICAqIC0gVXNlcyB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwncyBgaW1wb3J0Rm9yRWxlbWVudGAgQVBJIHRvIGVuc3VyZVxuICAgKiAgIHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgZG9jdW1lbnQncyBsb2NhdGlvbiBzaW5jZVxuICAgKiAgIGBvd25lckRvY3VtZW50YCBpcyBub3QgY3VycmVudGx5IHBvbHlmaWxsZWRcbiAgICovXG4gIGdldCBhc3NldHBhdGgoKSB7XG4gICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYXNzZXRwYXRoLlxuICAgIGlmICghdGhpcy5fX2Fzc2V0cGF0aCkge1xuICAgICAgLy8gbm90ZTogYXNzZXRwYXRoIHNldCB2aWEgYW4gYXR0cmlidXRlIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhpc1xuICAgICAgLy8gZWxlbWVudCdzIGxvY2F0aW9uOyBhY2NvbW9kYXRlIHBvbHlmaWxsZWQgSFRNTEltcG9ydHNcbiAgICAgIGNvbnN0IG93bmVyID0gd2luZG93LkhUTUxJbXBvcnRzICYmIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQgP1xuICAgICAgICBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50KHRoaXMpIHx8IGRvY3VtZW50IDogdGhpcy5vd25lckRvY3VtZW50O1xuICAgICAgY29uc3QgdXJsID0gcmVzb2x2ZVVybChcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2Fzc2V0cGF0aCcpIHx8ICcnLCBvd25lci5iYXNlVVJJKTtcbiAgICAgIHRoaXMuX19hc3NldHBhdGggPSBwYXRoRnJvbVVybCh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX2Fzc2V0cGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgdGhlIGRvbS1tb2R1bGUgYXQgYSBnaXZlbiBpZC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkXG4gICAqIHdoZW4gYSBkb20tbW9kdWxlIGlzIGltcGVyYXRpdmVseSBjcmVhdGVkLiBGb3JcbiAgICogZXhhbXBsZSwgYGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RvbS1tb2R1bGUnKS5yZWdpc3RlcignZm9vJylgLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGlkIFRoZSBpZCBhdCB3aGljaCB0byByZWdpc3RlciB0aGUgZG9tLW1vZHVsZS5cbiAgICovXG4gIHJlZ2lzdGVyKGlkKSB7XG4gICAgaWQgPSBpZCB8fCB0aGlzLmlkO1xuICAgIGlmIChpZCkge1xuICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgLy8gc3RvcmUgaWQgc2VwYXJhdGUgZnJvbSBsb3dlcmNhc2VkIGlkIHNvIHRoYXRcbiAgICAgIC8vIGluIGFsbCBjYXNlcyBtaXhlZENhc2UgaWQgd2lsbCBzdG9yZWQgZGlzdGluY3RseVxuICAgICAgLy8gYW5kIGxvd2VyY2FzZSB2ZXJzaW9uIGlzIGEgZmFsbGJhY2tcbiAgICAgIG1vZHVsZXNbaWRdID0gdGhpcztcbiAgICAgIGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XG4gICAgICBzdHlsZU91dHNpZGVUZW1wbGF0ZUNoZWNrKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5Eb21Nb2R1bGUucHJvdG90eXBlWydtb2R1bGVzJ10gPSBtb2R1bGVzO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2RvbS1tb2R1bGUnLCBEb21Nb2R1bGUpO1xuXG5leHBvcnQgeyBEb21Nb2R1bGUgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5qcyIsImltcG9ydCAnLi4vLi4vLi4vLi4vQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvYXBwbHktc2hpbS5qcyc7XG5pbXBvcnQgeyBFbGVtZW50TWl4aW4gfSBmcm9tICcuLi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgeyBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuLi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IGltcG9ydEhyZWYgYXMgaW1wb3J0SHJlZiQwIH0gZnJvbSAnLi4vdXRpbHMvaW1wb3J0LWhyZWYuanMnO1xuaW1wb3J0ICcuLi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvdW5yZXNvbHZlZC5qcyc7XG5pbXBvcnQgeyBkb20gYXMgZG9tJDAsIG1hdGNoZXNTZWxlY3RvciB9IGZyb20gJy4vcG9seW1lci5kb20uanMnO1xuaW1wb3J0IHsgc2V0VG91Y2hBY3Rpb24gfSBmcm9tICcuLi91dGlscy9nZXN0dXJlcy5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyB0aW1lT3V0LCBtaWNyb1Rhc2sgfSBmcm9tICcuLi91dGlscy9hc3luYy5qcyc7XG5pbXBvcnQgeyBnZXQgYXMgZ2V0JDAgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcblxubGV0IHN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTO1xuXG5leHBvcnQgY29uc3QgTGVnYWN5RWxlbWVudE1peGluID0gZGVkdXBpbmdNaXhpbigoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgKi9cbiAgY29uc3QgbGVnYWN5RWxlbWVudEJhc2UgPSBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMoRWxlbWVudE1peGluKGJhc2UpKTtcblxuICAvKipcbiAgICogTWFwIG9mIHNpbXBsZSBuYW1lcyB0byB0b3VjaCBhY3Rpb24gbmFtZXNcbiAgICogQGRpY3RcbiAgICovXG4gIGNvbnN0IERJUkVDVElPTl9NQVAgPSB7XG4gICAgJ3gnOiAncGFuLXgnLFxuICAgICd5JzogJ3Bhbi15JyxcbiAgICAnbm9uZSc6ICdub25lJyxcbiAgICAnYWxsJzogJ2F1dG8nXG4gIH07XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBleHRlbmRzIHtsZWdhY3lFbGVtZW50QmFzZX1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfTGVnYWN5RWxlbWVudE1peGlufVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBMZWdhY3lFbGVtZW50IGV4dGVuZHMgbGVnYWN5RWxlbWVudEJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5yb290ID0gdGhpcztcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuaXNBdHRhY2hlZDtcbiAgICAgIC8qKiBAdHlwZSB7V2Vha01hcDwhRWxlbWVudCwgIU9iamVjdDxzdHJpbmcsICFGdW5jdGlvbj4+fSAqL1xuICAgICAgdGhpcy5fX2JvdW5kTGlzdGVuZXJzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBGdW5jdGlvbj59ICovXG4gICAgICB0aGlzLl9kZWJvdW5jZXJzO1xuICAgICAgdGhpcy5jcmVhdGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgdGhlIGBjb25zdHJ1Y3RvcmAsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgY3JlYXRlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgYXR0YWNoZWRgIG1ldGhvZC5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLmlzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hdHRhY2hlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBjb25uZWN0ZWRDYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgYXR0YWNoZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIHdoaWNoIGFkZHMgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGRldGFjaGVkYCBtZXRob2QuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmRldGFjaGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBkZXRhY2hlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBvdmVycmlkZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYFxuICAgICAqIHdoaWNoIGFkZHMgdGhlIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRyaWJ1dGVDaGFuZ2VkYCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgYXR0cmlidXRlQ2hhbmdlZENoYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgKiBhZGQgc3VwcG9ydCBmb3IgY2xhc3MgaW5pdGlhbGl6YXRpb24gdmlhIHRoZSBgX3JlZ2lzdGVyZWRgIGNhbGxiYWNrLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIG9ubHkgd2hlbiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ19faGFzUmVnaXN0ZXJGaW5pc2hlZCcpKSB7XG4gICAgICAgIHByb3RvLl9faGFzUmVnaXN0ZXJGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQoKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYW4gZWxlbWVudCBpcyBpbml0aWFsaXppbmcuXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gY2xhc3MgcmVnaXN0cmF0aW9uIHRpbWVcbiAgICAgKiB3b3JrLiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGVuc3VyZSB0aGUgd29yayBpcyBwZXJmb3JtZWRcbiAgICAgKiBvbmx5IG9uY2UgZm9yIHRoZSBjbGFzcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlZ2lzdGVyZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgKiBhZGQgc3VwcG9ydCBmb3IgaW5zdGFsbGluZyBgaG9zdEF0dHJpYnV0ZXNgIGFuZCBgbGlzdGVuZXJzYC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgdGhpcy5fZW5zdXJlQXR0cmlidXRlcygpO1xuICAgICAgdGhpcy5fYXBwbHlMaXN0ZW5lcnMoKTtcbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhbiBlbGVtZW50IGhhcyByZXF1aXJlZCBhdHRyaWJ1dGVzLiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudFxuICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0byBzZXQgdGhlXG4gICAgICogZWxlbWVudCdzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmUgc3VyZVxuICAgICAqIHRvIGNoZWNrIGFuZCBub3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYXR0cmlidXRlcyBhZGRlZCBieVxuICAgICAqIHRoZSB1c2VyIG9mIHRoZSBlbGVtZW50LiBUeXBpY2FsbHksIHNldHRpbmcgYXR0cmlidXRlcyBzaG91bGQgYmUgbGVmdFxuICAgICAqIHRvIHRoZSBlbGVtZW50IHVzZXIgYW5kIG5vdCBkb25lIGhlcmU7IHJlYXNvbmFibGUgZXhjZXB0aW9ucyBpbmNsdWRlXG4gICAgICogc2V0dGluZyBhcmlhIHJvbGVzIGFuZCBmb2N1c2FiaWxpdHkuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9lbnN1cmVBdHRyaWJ1dGVzKCkge31cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICogaXMgYmVpbmcgcmVhZGllZCB2aWEgYHJlYWR5YC4gVXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRvXG4gICAgICogYWRkIGFueSByZXF1aXJlZCBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBJbiBwZXJmb3JtYW5jZSBjcml0aWNhbCBlbGVtZW50cywgdGhlIHdvcmsgZG9uZSBoZXJlIHNob3VsZCBiZSBrZXB0XG4gICAgICogdG8gYSBtaW5pbXVtIHNpbmNlIGl0IGlzIGRvbmUgYmVmb3JlIHRoZSBlbGVtZW50IGlzIHJlbmRlcmVkLiBJblxuICAgICAqIHRoZXNlIGVsZW1lbnRzLCBjb25zaWRlciBhZGRpbmcgbGlzdGVuZXJzIGFzeWNocm9ub3VzbHkgc28gYXMgbm90IHRvXG4gICAgICogYmxvY2sgcmVuZGVyLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYXBwbHlMaXN0ZW5lcnMoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gVG8gY3VzdG9taXplXG4gICAgICogaG93IHByb3BlcnRpZXMgYXJlIHNlcmlhbGl6ZWQgdG8gYXR0cmlidXRlcyBmb3IgYXR0cmlidXRlIGJpbmRpbmdzIGFuZFxuICAgICAqIGByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVgIHByb3BlcnRpZXMgYXMgd2VsbCBhcyB0aGlzIG1ldGhvZCwgb3ZlcnJpZGVcbiAgICAgKiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHByb3ZpZGVkIGJ5IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZGVzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFNlcmlhbGl6ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gIFRvIGN1c3RvbWl6ZVxuICAgICAqIGhvdyBhdHRyaWJ1dGVzIGFyZSBkZXNlcmlhbGl6ZWQgdG8gcHJvcGVydGllcyBmb3IgaW5cbiAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3ZlcnJpZGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2RcbiAgICAgKiBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIGRlc2VyaWFsaXplXG4gICAgICogQHBhcmFtIHsqfSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0b1xuICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiB0aGUgYHR5cGVgIGdpdmVuLlxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplKHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gcmVmZWN0LlxuICAgICAqL1xuICAgIHJlZmxlY3RQcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdHlwZWQgdmFsdWUgdG8gYW4gSFRNTCBhdHRyaWJ1dGUgb24gYSBub2RlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHNldCBhdHRyaWJ1dGUgdG8uXG4gICAgICovXG4gICAgc2VyaWFsaXplVmFsdWVUb0F0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlLCBub2RlKSB7XG4gICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHByb3BlcnRpZXMgKGluY2x1ZGluZyBhY2Nlc3NvciBkZXNjcmlwdG9ycykgZnJvbSBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcGkgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHByb3RvdHlwZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGV4dGVuZChwcm90b3R5cGUsIGFwaSkge1xuICAgICAgaWYgKCEocHJvdG90eXBlICYmIGFwaSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZSB8fCBhcGk7XG4gICAgICB9XG4gICAgICBsZXQgbiQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcGkpO1xuICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxuJC5sZW5ndGgpICYmIChuPW4kW2ldKTsgaSsrKSB7XG4gICAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXBpLCBuKTtcbiAgICAgICAgaWYgKHBkKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbiwgcGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvdG90eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGlzIG1ldGhvZCB1c2VzIGEgc2ltcGxlIGBmb3IuLi5pbmAgc3RyYXRlZ3kgZm9yIGVudW1lcmF0aW5nXG4gICAgICogcHJvcGVydGllcy4gIFRvIGVuc3VyZSBvbmx5IGBvd25Qcm9wZXJ0aWVzYCBhcmUgY29waWVkIGZyb20gc291cmNlXG4gICAgICogdG8gdGFyZ2V0IGFuZCB0aGF0IGFjY2Vzc29yIGltcGxlbWVudGF0aW9ucyBhcmUgY29waWVkLCB1c2UgYGV4dGVuZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRhcmdldCBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqL1xuICAgIG1peGluKHRhcmdldCwgc291cmNlKSB7XG4gICAgICBmb3IgKGxldCBpIGluIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvbiB3aGljaCB0byBzZXQgdGhlIHByb3RvdHlwZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBwcm90b3R5cGUgdGhhdCB3aWxsIGJlIHNldCBvbiB0aGUgZ2l2ZW5cbiAgICAgKiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGdpdmVuIGBvYmplY3RgIHdpdGggaXRzIHByb3RvdHlwZSBzZXRcbiAgICAgKiB0byB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LlxuICAgICAqL1xuICAgIGNoYWluT2JqZWN0KG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgICBpZiAob2JqZWN0ICYmIHByb3RvdHlwZSAmJiBvYmplY3QgIT09IHByb3RvdHlwZSkge1xuICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKiAqKioqIEJlZ2luIFRlbXBsYXRlICoqKiogKi9cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGBpbXBvcnROb2RlYCBvbiB0aGUgYGNvbnRlbnRgIG9mIHRoZSBgdGVtcGxhdGVgIHNwZWNpZmllZCBhbmRcbiAgICAgKiByZXR1cm5zIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgaW1wb3J0ZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgSFRNTCB0ZW1wbGF0ZSBlbGVtZW50IHRvIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IERvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkXG4gICAgICogICB0ZW1wbGF0ZSBjb250ZW50LlxuICAgICovXG4gICAgaW5zdGFuY2VUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmNvbnN0cnVjdG9yLl9jb250ZW50Rm9yVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IGRvbSA9IC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi9cbiAgICAgICAgKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKiAqKioqIEJlZ2luIEV2ZW50cyAqKioqICovXG5cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlcyBhIGN1c3RvbSBldmVudCB3aXRoIGFuIG9wdGlvbmFsIGRldGFpbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIE5hbWUgb2YgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0geyo9fSBkZXRhaWwgRGV0YWlsIHZhbHVlIGNvbnRhaW5pbmcgZXZlbnQtc3BlY2lmaWNcbiAgICAgKiAgIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHt7IGJ1YmJsZXM6IChib29sZWFufHVuZGVmaW5lZCksIGNhbmNlbGFibGU6IChib29sZWFufHVuZGVmaW5lZCksIGNvbXBvc2VkOiAoYm9vbGVhbnx1bmRlZmluZWQpIH09fVxuICAgICAqICBvcHRpb25zIE9iamVjdCBzcGVjaWZ5aW5nIG9wdGlvbnMuICBUaGVzZSBtYXkgaW5jbHVkZTpcbiAgICAgKiAgYGJ1YmJsZXNgIChib29sZWFuLCBkZWZhdWx0cyB0byBgdHJ1ZWApLFxuICAgICAqICBgY2FuY2VsYWJsZWAgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlKSwgYW5kXG4gICAgICogIGBub2RlYCBvbiB3aGljaCB0byBmaXJlIHRoZSBldmVudCAoSFRNTEVsZW1lbnQsIGRlZmF1bHRzIHRvIGB0aGlzYCkuXG4gICAgICogQHJldHVybiB7RXZlbnR9IFRoZSBuZXcgZXZlbnQgdGhhdCB3YXMgZmlyZWQuXG4gICAgICovXG4gICAgZmlyZSh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgZGV0YWlsID0gKGRldGFpbCA9PT0gbnVsbCB8fCBkZXRhaWwgPT09IHVuZGVmaW5lZCkgPyB7fSA6IGRldGFpbDtcbiAgICAgIGxldCBldmVudCA9IG5ldyBFdmVudCh0eXBlLCB7XG4gICAgICAgIGJ1YmJsZXM6IG9wdGlvbnMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogQm9vbGVhbihvcHRpb25zLmNhbmNlbGFibGUpLFxuICAgICAgICBjb21wb3NlZDogb3B0aW9ucy5jb21wb3NlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZTogb3B0aW9ucy5jb21wb3NlZFxuICAgICAgfSk7XG4gICAgICBldmVudC5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCB0aGlzO1xuICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGEgZ2l2ZW4gZWxlbWVudCxcbiAgICAgKiBsYXRlIGJvdW5kIHRvIGEgbmFtZWQgbWV0aG9kIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIGFkZCBldmVudCBsaXN0ZW5lciB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBjYWxsLlxuICAgICAqL1xuICAgIGxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGxldCBoYmwgPSB0aGlzLl9fYm91bmRMaXN0ZW5lcnMgfHxcbiAgICAgICAgKHRoaXMuX19ib3VuZExpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCkpO1xuICAgICAgbGV0IGJsID0gaGJsLmdldChub2RlKTtcbiAgICAgIGlmICghYmwpIHtcbiAgICAgICAgYmwgPSB7fTtcbiAgICAgICAgaGJsLnNldChub2RlLCBibCk7XG4gICAgICB9XG4gICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgIGlmICghYmxba2V5XSkge1xuICAgICAgICBibFtrZXldID0gdGhpcy5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShcbiAgICAgICAgICBub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhIGdpdmVuIGVsZW1lbnQsXG4gICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gc3RvcCBsaXN0ZW5pbmcgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBoYW5kbGVyIG1ldGhvZCBvbiBgdGhpc2AgdG8gbm90IGNhbGxcbiAgICAgYW55bW9yZS5cbiAgICAgKi9cbiAgICB1bmxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGxldCBibCA9IHRoaXMuX19ib3VuZExpc3RlbmVycyAmJiB0aGlzLl9fYm91bmRMaXN0ZW5lcnMuZ2V0KG5vZGUpO1xuICAgICAgbGV0IGtleSA9IGV2ZW50TmFtZSArIG1ldGhvZE5hbWU7XG4gICAgICBsZXQgaGFuZGxlciA9IGJsICYmIGJsW2tleV07XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgYmxba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc2Nyb2xsaW5nIGJlaGF2aW9yIHRvIGFsbCBkaXJlY3Rpb24sIG9uZSBkaXJlY3Rpb24sIG9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBWYWxpZCBzY3JvbGwgZGlyZWN0aW9uczpcbiAgICAgKiAgIC0gJ2FsbCc6IHNjcm9sbCBpbiBhbnkgZGlyZWN0aW9uXG4gICAgICogICAtICd4Jzogc2Nyb2xsIG9ubHkgaW4gdGhlICd4JyBkaXJlY3Rpb25cbiAgICAgKiAgIC0gJ3knOiBzY3JvbGwgb25seSBpbiB0aGUgJ3knIGRpcmVjdGlvblxuICAgICAqICAgLSAnbm9uZSc6IGRpc2FibGUgc2Nyb2xsaW5nIGZvciB0aGlzIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZGlyZWN0aW9uIERpcmVjdGlvbiB0byBhbGxvdyBzY3JvbGxpbmdcbiAgICAgKiBEZWZhdWx0cyB0byBgYWxsYC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgc2Nyb2xsIGRpcmVjdGlvbiBzZXR0aW5nLlxuICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxEaXJlY3Rpb24oZGlyZWN0aW9uLCBub2RlKSB7XG4gICAgICBzZXRUb3VjaEFjdGlvbiggKG5vZGUgfHwgdGhpcyksIERJUkVDVElPTl9NQVBbZGlyZWN0aW9uXSB8fCAnYXV0bycpO1xuICAgIH1cbiAgICAvKiAqKioqIEVuZCBFdmVudHMgKioqKiAqL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJ1biBgcXVlcnlTZWxlY3RvcmAgb24gdGhpcyBsb2NhbCBET00gc2NvcGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBQb2x5bWVyLmRvbSh0aGlzLnJvb3QpLnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbGN0ciBTZWxlY3RvciB0byBydW4gb24gdGhpcyBsb2NhbCBET00gc2NvcGVcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBFbGVtZW50IGZvdW5kIGJ5IHRoZSBzZWxlY3Rvciwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgJCQoc2xjdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBlbGVtZW50IHdob3NlIGxvY2FsIGRvbSB3aXRoaW4gd2hpY2ggdGhpcyBlbGVtZW50XG4gICAgICogaXMgY29udGFpbmVkLiBUaGlzIGlzIGEgc2hvcnRoYW5kIGZvclxuICAgICAqIGB0aGlzLmdldFJvb3ROb2RlKCkuaG9zdGAuXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IGRvbUhvc3QoKSB7XG4gICAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIHJldHVybiAocm9vdCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpID8gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCA6IHJvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhpcyBlbGVtZW50IHRvIGRpc3RyaWJ1dGUgaXRzIGNoaWxkcmVuIHRvIGl0cyBsb2NhbCBkb20uXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBhcyBvZiBQb2x5bWVyIDIuMC4yIGFuZCBpcyBwcm92aWRlZCBvbmx5XG4gICAgICogZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIGRpc3RyaWJ1dGVDb250ZW50KCkge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSB0aGUgZWZmZWN0aXZlIGNoaWxkTm9kZXMuIFRoZSBlZmZlY3RpdmVcbiAgICAgKiBjaGlsZE5vZGVzIGxpc3QgaXMgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQncyBjaGlsZE5vZGVzIGV4Y2VwdCB0aGF0XG4gICAgICogYW55IGA8Y29udGVudD5gIGVsZW1lbnRzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkXG4gICAgICogdG8gdGhlIGA8Y29udGVudD5gLCB0aGUgcmVzdWx0IG9mIGl0cyBgZ2V0RGlzdHJpYnV0ZWROb2Rlc2AgbWV0aG9kLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkIG5vZGVzLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoZG9tJDAodGhpcykpLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXQgbWF0Y2hcbiAgICAgKiBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkcmVuIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkIHRvXG4gICAgICogY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIHRoYXQgbWF0Y2ggc2VsZWN0b3IuXG4gICAgICovXG4gICAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoZG9tJDAodGhpcykpLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3RvcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZHJlbi4gVGhlIGVmZmVjdGl2ZVxuICAgICAqIGNoaWxkcmVuIGxpc3QgaXMgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQncyBjaGlsZHJlbiBleGNlcHQgdGhhdFxuICAgICAqIGFueSBgPGNvbnRlbnQ+YCBlbGVtZW50cyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgbGlzdCBvZiBlbGVtZW50c1xuICAgICAqIGRpc3RyaWJ1dGVkIHRvIHRoZSBgPGNvbnRlbnQ+YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZUNoaWxkcmVuKCkge1xuICAgICAgbGV0IGxpc3QgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbigvKiogQHR5cGUge05vZGV9ICovIG4pIHtcbiAgICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIHRleHQgY29udGVudCB0aGF0IGlzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICAgICAqIHRleHQgY29udGVudCdzIG9mIHRoZSBlbGVtZW50J3MgZWZmZWN0aXZlIGNoaWxkTm9kZXMgKHRoZSBlbGVtZW50c1xuICAgICAqIHJldHVybmVkIGJ5IDxhIGhyZWY9XCIjZ2V0RWZmZWN0aXZlQ2hpbGROb2Rlcz5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzPC9hPi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVUZXh0Q29udGVudCgpIHtcbiAgICAgIGxldCBjbiA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgbGV0IHRjID0gW107XG4gICAgICBmb3IgKGxldCBpPTAsIGM7IChjID0gY25baV0pOyBpKyspIHtcbiAgICAgICAgaWYgKGMubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdGMucHVzaChjLnRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRjLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVmZmVjdGl2ZSBjaGlsZE5vZGUgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0XG4gICAgICogbWF0Y2ggYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZCBub2RlcyBvciBlbGVtZW50cyBkaXN0cmlidXRlZFxuICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3Q8Tm9kZT59IEZpcnN0IGVmZmVjdGl2ZSBjaGlsZCBub2RlIHRoYXQgbWF0Y2hlcyBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBxdWVyeUVmZmVjdGl2ZUNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICBsZXQgZSQgPSB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICByZXR1cm4gZSQgJiYgZSRbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkTm9kZXMgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0XG4gICAgICogbWF0Y2ggYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZCBub2RlcyBvciBlbGVtZW50cyBkaXN0cmlidXRlZFxuICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZlY3RpdmUgY2hpbGQgbm9kZXMgdGhhdCBtYXRjaCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBxdWVyeUFsbEVmZmVjdGl2ZUNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c2xvdD5gLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBlbGVtZW50IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgYDxzbG90PmAgaW4gaXRzIGxvY2FsIERPTSxcbiAgICAgKiBhbiBvcHRpb25hbCBzZWxlY3RvciBtYXkgYmUgcGFzc2VkIHRvIGNob29zZSB0aGUgZGVzaXJlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBzbGN0ciBDU1Mgc2VsZWN0b3IgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICogICBgPHNsb3Q+YC4gIERlZmF1bHRzIHRvIGBjb250ZW50YC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlIGA8c2xvdD5gLlxuICAgICAqL1xuICAgIGdldENvbnRlbnRDaGlsZE5vZGVzKHNsY3RyKSB7XG4gICAgICBsZXQgY29udGVudCA9IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNsY3RyIHx8ICdzbG90Jyk7XG4gICAgICByZXR1cm4gY29udGVudCA/IC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovKGRvbSQwKGNvbnRlbnQpKS5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50IGNoaWxkcmVuIGRpc3RyaWJ1dGVkIHRvIHRoaXMgZWxlbWVudCdzXG4gICAgICogYDxzbG90PmAuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHNcbiAgICAgKiBsb2NhbCBET00sIGFuIG9wdGlvbmFsIHNlbGVjdG9yIG1heSBiZSBwYXNzZWQgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICogY29udGVudC4gIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgZ2V0Q29udGVudENoaWxkTm9kZXNgIGluIHRoYXQgb25seVxuICAgICAqIGVsZW1lbnRzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2xjdHIgQ1NTIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAqICAgYDxjb250ZW50PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIG5vZGVzIGZvciB0aGVcbiAgICAgKiAgIGA8c2xvdD5gLlxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIGdldENvbnRlbnRDaGlsZHJlbihzbGN0cikge1xuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fSAqLyh0aGlzLmdldENvbnRlbnRDaGlsZE5vZGVzKHNsY3RyKS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gbm9kZSBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgKi9cbiAgICBpc0xpZ2h0RGVzY2VuZGFudChub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcyAhPT0gbm9kZSAmJiB0aGlzLmNvbnRhaW5zKG5vZGUpICYmXG4gICAgICAgICAgdGhpcy5nZXRSb290Tm9kZSgpID09PSBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGlzIGVsZW1lbnQncyBsb2NhbCBET00gdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG5vZGUgaXMgaW4gdGhpcyBlbGVtZW50J3MgbG9jYWwgRE9NIHRyZWUuXG4gICAgICovXG4gICAgaXNMb2NhbERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdCA9PT0gbm9kZS5nZXRSb290Tm9kZSgpO1xuICAgIH1cblxuICAgIC8vIE5PVEU6IHNob3VsZCBub3cgYmUgaGFuZGxlZCBieSBTaGFkeUNzcyBsaWJyYXJ5LlxuICAgIHNjb3BlU3VidHJlZShjb250YWluZXIsIHNob3VsZE9ic2VydmUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIHN0eWxlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBjc3MgcHJvcGVydHkgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbXB1dGVkIGNzcyBwcm9wZXJ0eSB2YWx1ZSBmb3IgdGhlIGdpdmVuXG4gICAgICogYHByb3BlcnR5YC5cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBzdHlsZUludGVyZmFjZS5nZXRDb21wdXRlZFN0eWxlVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8vIGRlYm91bmNlXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBkZWJvdW5jZWAgdG8gY29sbGFwc2UgbXVsdGlwbGUgcmVxdWVzdHMgZm9yIGEgbmFtZWQgdGFzayBpbnRvXG4gICAgICogb25lIGludm9jYXRpb24gd2hpY2ggaXMgbWFkZSBhZnRlciB0aGUgd2FpdCB0aW1lIGhhcyBlbGFwc2VkIHdpdGhcbiAgICAgKiBubyBuZXcgcmVxdWVzdC4gIElmIG5vIHdhaXQgdGltZSBpcyBnaXZlbiwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gICAgICogYXQgbWljcm90YXNrIHRpbWluZyAoZ3VhcmFudGVlZCBiZWZvcmUgcGFpbnQpLlxuICAgICAqXG4gICAgICogICAgIGRlYm91bmNlZENsaWNrQWN0aW9uKGUpIHtcbiAgICAgKiAgICAgICAvLyB3aWxsIG5vdCBjYWxsIGBwcm9jZXNzQ2xpY2tgIG1vcmUgdGhhbiBvbmNlIHBlciAxMDBtc1xuICAgICAqICAgICAgIHRoaXMuZGVib3VuY2UoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgIHRoaXMucHJvY2Vzc0NsaWNrKCk7XG4gICAgICogICAgICAgfSAxMDApO1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBTdHJpbmcgdG8gaW5kZW50aWZ5IHRoZSBkZWJvdW5jZSBqb2IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCAod2l0aCBgdGhpc2BcbiAgICAgKiAgIGNvbnRleHQpIHdoZW4gdGhlIHdhaXQgdGltZSBlbGFwc2VzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IE9wdGlvbmFsIHdhaXQgdGltZSBpbiBtaWxsaXNlY29uZHMgKG1zKSBhZnRlciB0aGVcbiAgICAgKiAgIGxhc3Qgc2lnbmFsIHRoYXQgbXVzdCBlbGFwc2UgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2BcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBkZWJvdW5jZXIgb2JqZWN0IG9uIHdoaWNoIGV4aXN0cyB0aGVcbiAgICAgKiBmb2xsb3dpbmcgbWV0aG9kczogYGlzQWN0aXZlKClgIHJldHVybnMgdHJ1ZSBpZiB0aGUgZGVib3VuY2VyIGlzXG4gICAgICogYWN0aXZlOyBgY2FuY2VsKClgIGNhbmNlbHMgdGhlIGRlYm91bmNlciBpZiBpdCBpcyBhY3RpdmU7XG4gICAgICogYGZsdXNoKClgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGRlYm91bmNlZCBjYWxsYmFjayBpZiB0aGUgZGVib3VuY2VyXG4gICAgICogaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGRlYm91bmNlKGpvYk5hbWUsIGNhbGxiYWNrLCB3YWl0KSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIHJldHVybiB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgICAgdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXVxuICAgICAgICAgICwgd2FpdCA+IDAgPyB0aW1lT3V0LmFmdGVyKHdhaXQpIDogbWljcm9UYXNrXG4gICAgICAgICAgLCBjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBuYW1lZCBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUgKGhhcyBub3QgeWV0IGZpcmVkKS5cbiAgICAgKi9cbiAgICBpc0RlYm91bmNlckFjdGl2ZShqb2JOYW1lKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgcmV0dXJuICEhKGRlYm91bmNlciAmJiBkZWJvdW5jZXIuaXNBY3RpdmUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgY2FsbHMgdGhlIGRlYm91bmNlciBgY2FsbGJhY2tgIGFuZCBpbmFjdGl2YXRlcyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgKi9cbiAgICBmbHVzaERlYm91bmNlcihqb2JOYW1lKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICBkZWJvdW5jZXIuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIuICBUaGUgYGNhbGxiYWNrYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICovXG4gICAgY2FuY2VsRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICBpZiAoZGVib3VuY2VyKSB7XG4gICAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gYXN5bmNyb25vdXNseS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQgKGlmIG5vIHdhaXRUaW1lIGlzIHNwZWNpZmllZCksIGFzeW5jIGNhbGxiYWNrcyBhcmUgcnVuIGF0XG4gICAgICogbWljcm90YXNrIHRpbWluZywgd2hpY2ggd2lsbCBvY2N1ciBiZWZvcmUgcGFpbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuLCBib3VuZCB0byBgdGhpc2AuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSB3YWl0VGltZSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgdGhlXG4gICAgICogICBgY2FsbGJhY2tgLiAgSWYgdW5zcGVjaWZpZWQgb3IgMCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgcnVuIGF0IG1pY3JvdGFza1xuICAgICAqICAgdGltaW5nIChiZWZvcmUgcGFpbnQpLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBhc3luYyBqb2IuXG4gICAgICovXG4gICAgYXN5bmMoY2FsbGJhY2ssIHdhaXRUaW1lKSB7XG4gICAgICByZXR1cm4gd2FpdFRpbWUgPiAwID8gdGltZU91dC5ydW4oY2FsbGJhY2suYmluZCh0aGlzKSwgd2FpdFRpbWUpIDpcbiAgICAgICAgICB+bWljcm9UYXNrLnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFuIGFzeW5jIG9wZXJhdGlvbiBzdGFydGVkIHdpdGggYGFzeW5jYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gb3JpZ2luYWwgYGFzeW5jYCBjYWxsIHRvXG4gICAgICogICBjYW5jZWwuXG4gICAgICovXG4gICAgY2FuY2VsQXN5bmMoaGFuZGxlKSB7XG4gICAgICBoYW5kbGUgPCAwID8gbWljcm9UYXNrLmNhbmNlbCh+aGFuZGxlKSA6XG4gICAgICAgICAgdGltZU91dC5jYW5jZWwoaGFuZGxlKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlclxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBlbGVtZW50IGFuZCBjb25maWd1cmluZyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSFRNTCBlbGVtZW50IHRhZyB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbmZpZ3VyZSBvbiB0aGVcbiAgICAgKiAgICBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBOZXdseSBjcmVhdGVkIGFuZCBjb25maWd1cmVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgY3JlYXRlKHRhZywgcHJvcHMpIHtcbiAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgaWYgKGVsdC5zZXRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgZWx0LnNldFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IG4gaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGVsdFtuXSA9IHByb3BzW25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGltcG9ydGluZyBhbiBIVE1MIGRvY3VtZW50IGltcGVyYXRpdmVseS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYDxsaW5rIHJlbD1cImltcG9ydFwiPmAgZWxlbWVudCB3aXRoXG4gICAgICogdGhlIHByb3ZpZGVkIFVSTCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgbG9hZGluZy5cbiAgICAgKiBJbiB0aGUgYG9ubG9hZGAgY2FsbGJhY2ssIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSBvZiB0aGUgYGxpbmtgXG4gICAgICogZWxlbWVudCB3aWxsIGNvbnRhaW4gdGhlIGltcG9ydGVkIGRvY3VtZW50IGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVVJMIHRvIGRvY3VtZW50IHRvIGxvYWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydCBzdWNjZXNzZnVsbHlcbiAgICAgKiAgIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmVycm9yIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydFxuICAgICAqICAgdW5zdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0QXN5bmMgVHJ1ZSBpZiB0aGUgaW1wb3J0IHNob3VsZCBiZSBsb2FkZWQgYGFzeW5jYC5cbiAgICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybiB7SFRNTExpbmtFbGVtZW50fSBUaGUgbGluayBlbGVtZW50IGZvciB0aGUgVVJMIHRvIGJlIGxvYWRlZC5cbiAgICAgKi9cbiAgICBpbXBvcnRIcmVmKGhyZWYsIG9ubG9hZCwgb25lcnJvciwgb3B0QXN5bmMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgbGV0IGxvYWRGbiA9IG9ubG9hZCA/IG9ubG9hZC5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgIGxldCBlcnJvckZuID0gb25lcnJvciA/IG9uZXJyb3IuYmluZCh0aGlzKSA6IG51bGw7XG4gICAgICByZXR1cm4gaW1wb3J0SHJlZiQwKGhyZWYsIGxvYWRGbiwgZXJyb3JGbiwgb3B0QXN5bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZvciBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzLCB3aGljaCBpcyBzb21ldGltZXMgc3RpbGxcbiAgICAgKiBwcmVmaXhlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byB0ZXN0IHRoZSBzZWxlY3RvciBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGVsZW1lbnQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAgICovXG4gICAgZWxlbWVudE1hdGNoZXMoc2VsZWN0b3IsIG5vZGUpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzU2VsZWN0b3IoIChub2RlIHx8IHRoaXMpLCBzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBvciBvZmYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBIVE1MIGF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYm9vbCBCb29sZWFuIHRvIGZvcmNlIHRoZSBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmV2ZXJzZWQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBOb2RlIHRvIHRhcmdldC4gIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICB0b2dnbGVBdHRyaWJ1dGUobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGJvb2wgPSAhbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoYm9vbCkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYSBDU1MgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIGNsYXNzIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBib29sIEJvb2xlYW4gdG8gZm9yY2UgdGhlIGNsYXNzIG9uIG9yIG9mZi5cbiAgICAgKiAgICBXaGVuIHVuc3BlY2lmaWVkLCB0aGUgc3RhdGUgb2YgdGhlIGNsYXNzIHdpbGwgYmUgcmV2ZXJzZWQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBOb2RlIHRvIHRhcmdldC4gIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICB0b2dnbGVDbGFzcyhuYW1lLCBib29sLCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgYm9vbCA9ICFub2RlLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChib29sKSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcy1wbGF0Zm9ybSBoZWxwZXIgZm9yIHNldHRpbmcgYW4gZWxlbWVudCdzIENTUyBgdHJhbnNmb3JtYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2Zvcm1UZXh0IFRyYW5zZm9ybSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHRvLlxuICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYFxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1UZXh0LCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIG5vZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtVGV4dDtcbiAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcy1wbGF0Zm9ybSBoZWxwZXIgZm9yIHNldHRpbmcgYW4gZWxlbWVudCdzIENTUyBgdHJhbnNsYXRlM2RgXG4gICAgICogcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBYIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geiBaIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0by5cbiAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgdHJhbnNsYXRlM2QoeCwgeSwgeiwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoJyArIHggKyAnLCcgKyB5ICsgJywnICsgeiArICcpJywgbm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gYW4gYXJyYXksIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBhcnJheSBpcyBzcGVjaWZpZWQgYnkgcGF0aCwgYSBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzXG4gICAgICogZ2VuZXJhdGVkLCBzbyB0aGF0IG9ic2VydmVycywgZGF0YSBiaW5kaW5ncyBhbmQgY29tcHV0ZWRcbiAgICAgKiBwcm9wZXJ0aWVzIHdhdGNoaW5nIHRoYXQgcGF0aCBjYW4gdXBkYXRlLlxuICAgICAqXG4gICAgICogSWYgdGhlIGFycmF5IGlzIHBhc3NlZCBkaXJlY3RseSwgKipubyBjaGFuZ2VcbiAgICAgKiBub3RpZmljYXRpb24gaXMgZ2VuZXJhdGVkKiouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gYXJyYXlPclBhdGggUGF0aCB0byBhcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgaXRlbVxuICAgICAqICAgKG9yIHRoZSBhcnJheSBpdHNlbGYpLlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBpdGVtIHJlbW92ZWQuXG4gICAgICovXG4gICAgYXJyYXlEZWxldGUoYXJyYXlPclBhdGgsIGl0ZW0pIHtcbiAgICAgIGxldCBpbmRleDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5T3JQYXRoKSkge1xuICAgICAgICBpbmRleCA9IGFycmF5T3JQYXRoLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5T3JQYXRoLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBhcnIgPSBnZXQkMCh0aGlzLCBhcnJheU9yUGF0aCk7XG4gICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGFycmF5T3JQYXRoLCBpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGxvZ2dpbmdcblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYC9gd2FybmAvYGVycm9yYCBhcyBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbCBPbmUgb2YgJ2xvZycsICd3YXJuJywgJ2Vycm9yJ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF9sb2dnZXIobGV2ZWwsIGFyZ3MpIHtcbiAgICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBzd2l0Y2gobGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnbG9nJzpcbiAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBjb25zb2xlW2xldmVsXSguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmxvZ2AgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF9sb2coLi4uYXJncykge1xuICAgICAgdGhpcy5fbG9nZ2VyKCdsb2cnLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLndhcm5gIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfd2FybiguLi5hcmdzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIoJ3dhcm4nLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmVycm9yYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX2Vycm9yKC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMuX2xvZ2dlcignZXJyb3InLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgbWVzc2FnZSB1c2luZyB0aGUgZWxlbWVudCB0eXBlIGFuIGEgbWV0aG9kIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgbmFtZSB0byBhc3NvY2lhdGUgd2l0aCBtZXNzYWdlXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIGZvciBgY29uc29sZWBcbiAgICAgKiAgIGxvZ2dpbmcuXG4gICAgICovXG4gICAgX2xvZ2YobWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIFsnWyVzOjolc10nLCB0aGlzLmlzLCBtZXRob2ROYW1lLCAuLi5hcmdzXTtcbiAgICB9XG5cbiAgfVxuXG4gIExlZ2FjeUVsZW1lbnQucHJvdG90eXBlLmlzID0gJyc7XG5cbiAgcmV0dXJuIExlZ2FjeUVsZW1lbnQ7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7bmF0aXZlU2hhZG93LCBuYXRpdmVDc3NWYXJpYWJsZXN9IGZyb20gJy4vc3R5bGUtc2V0dGluZ3MuanMnO1xuaW1wb3J0IHtwYXJzZSwgc3RyaW5naWZ5LCB0eXBlcywgU3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7TUVESUFfTUFUQ0h9IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xTdHlsZU5vZGV9IHJ1bGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFN0eWxlTm9kZSk9fSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Dc3NUZXh0IChydWxlcywgY2FsbGJhY2spIHtcbiAgaWYgKCFydWxlcykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAodHlwZW9mIHJ1bGVzID09PSAnc3RyaW5nJykge1xuICAgIHJ1bGVzID0gcGFyc2UocnVsZXMpO1xuICB9XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGZvckVhY2hSdWxlKHJ1bGVzLCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeShydWxlcywgbmF0aXZlQ3NzVmFyaWFibGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0ZvclN0eWxlKHN0eWxlKSB7XG4gIGlmICghc3R5bGVbJ19fY3NzUnVsZXMnXSAmJiBzdHlsZS50ZXh0Q29udGVudCkge1xuICAgIHN0eWxlWydfX2Nzc1J1bGVzJ10gPSBwYXJzZShzdHlsZS50ZXh0Q29udGVudCk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlWydfX2Nzc1J1bGVzJ10gfHwgbnVsbDtcbn1cblxuLy8gVGVzdHMgaWYgYSBydWxlIGlzIGEga2V5ZnJhbWVzIHNlbGVjdG9yLCB3aGljaCBsb29rcyBhbG1vc3QgZXhhY3RseVxuLy8gbGlrZSBhIG5vcm1hbCBzZWxlY3RvciBidXQgaXMgbm90IChpdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIHNjb3Bpbmdcbi8vIGZvciBleGFtcGxlKS5cbi8qKlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IHJ1bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0tleWZyYW1lc1NlbGVjdG9yKHJ1bGUpIHtcbiAgcmV0dXJuIEJvb2xlYW4ocnVsZVsncGFyZW50J10pICYmXG4gIHJ1bGVbJ3BhcmVudCddWyd0eXBlJ10gPT09IHR5cGVzLktFWUZSQU1FU19SVUxFO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gc3R5bGVSdWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBrZXlmcmFtZXNSdWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9ubHlBY3RpdmVSdWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaFJ1bGUobm9kZSwgc3R5bGVSdWxlQ2FsbGJhY2ssIGtleWZyYW1lc1J1bGVDYWxsYmFjaywgb25seUFjdGl2ZVJ1bGVzKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2tpcFJ1bGVzID0gZmFsc2U7XG4gIGxldCB0eXBlID0gbm9kZVsndHlwZSddO1xuICBpZiAob25seUFjdGl2ZVJ1bGVzKSB7XG4gICAgaWYgKHR5cGUgPT09IHR5cGVzLk1FRElBX1JVTEUpIHtcbiAgICAgIGxldCBtYXRjaE1lZGlhID0gbm9kZVsnc2VsZWN0b3InXS5tYXRjaChNRURJQV9NQVRDSCk7XG4gICAgICBpZiAobWF0Y2hNZWRpYSkge1xuICAgICAgICAvLyBpZiBydWxlIGlzIGEgbm9uIG1hdGNoaW5nIEBtZWRpYSBydWxlLCBza2lwIHN1YnJ1bGVzXG4gICAgICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEobWF0Y2hNZWRpYVsxXSkubWF0Y2hlcykge1xuICAgICAgICAgIHNraXBSdWxlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUgPT09IHR5cGVzLlNUWUxFX1JVTEUpIHtcbiAgICBzdHlsZVJ1bGVDYWxsYmFjayhub2RlKTtcbiAgfSBlbHNlIGlmIChrZXlmcmFtZXNSdWxlQ2FsbGJhY2sgJiZcbiAgICB0eXBlID09PSB0eXBlcy5LRVlGUkFNRVNfUlVMRSkge1xuICAgIGtleWZyYW1lc1J1bGVDYWxsYmFjayhub2RlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSB0eXBlcy5NSVhJTl9SVUxFKSB7XG4gICAgc2tpcFJ1bGVzID0gdHJ1ZTtcbiAgfVxuICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICBpZiAociQgJiYgIXNraXBSdWxlcykge1xuICAgIGZvciAobGV0IGk9MCwgbD1yJC5sZW5ndGgsIHI7IChpPGwpICYmIChyPXIkW2ldKTsgaSsrKSB7XG4gICAgICBmb3JFYWNoUnVsZShyLCBzdHlsZVJ1bGVDYWxsYmFjaywga2V5ZnJhbWVzUnVsZUNhbGxiYWNrLCBvbmx5QWN0aXZlUnVsZXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBhZGQgYSBzdHJpbmcgb2YgY3NzVGV4dCB0byB0aGUgZG9jdW1lbnQuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9uaWtlclxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gY29udGV4dE5vZGVcbiAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUNzcyhjc3NUZXh0LCBtb25pa2VyLCB0YXJnZXQsIGNvbnRleHROb2RlKSB7XG4gIGxldCBzdHlsZSA9IGNyZWF0ZVNjb3BlU3R5bGUoY3NzVGV4dCwgbW9uaWtlcik7XG4gIGFwcGx5U3R5bGUoc3R5bGUsIHRhcmdldCwgY29udGV4dE5vZGUpO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NvcGVTdHlsZShjc3NUZXh0LCBtb25pa2VyKSB7XG4gIGxldCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSk7XG4gIGlmIChtb25pa2VyKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdzY29wZScsIG1vbmlrZXIpO1xuICB9XG4gIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIFRyYWNrIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBhZGRlZCBzdHlsZSBmb3IgcGxhY2luZyBwbGFjZWhvbGRlcnNcbiAqIEB0eXBlIHtOb2RlfVxuICovXG5sZXQgbGFzdEhlYWRBcHBseU5vZGUgPSBudWxsO1xuXG4vLyBpbnNlcnQgYSBjb21tZW50IG5vZGUgYXMgYSBzdHlsaW5nIHBvc2l0aW9uIHBsYWNlaG9sZGVyLlxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9uaWtlclxuICogQHJldHVybiB7IUNvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlUGxhY2VIb2xkZXIobW9uaWtlcikge1xuICBsZXQgcGxhY2VIb2xkZXIgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcgU2hhZHkgRE9NIHN0eWxlcyBmb3IgJyArXG4gICAgbW9uaWtlciArICcgJyk7XG4gIGxldCBhZnRlciA9IGxhc3RIZWFkQXBwbHlOb2RlID9cbiAgICBsYXN0SGVhZEFwcGx5Tm9kZVsnbmV4dFNpYmxpbmcnXSA6IG51bGw7XG4gIGxldCBzY29wZSA9IGRvY3VtZW50LmhlYWQ7XG4gIHNjb3BlLmluc2VydEJlZm9yZShwbGFjZUhvbGRlciwgYWZ0ZXIgfHwgc2NvcGUuZmlyc3RDaGlsZCk7XG4gIGxhc3RIZWFkQXBwbHlOb2RlID0gcGxhY2VIb2xkZXI7XG4gIHJldHVybiBwbGFjZUhvbGRlcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcGFyYW0gez9Ob2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7P05vZGV9IGNvbnRleHROb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlKHN0eWxlLCB0YXJnZXQsIGNvbnRleHROb2RlKSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCBkb2N1bWVudC5oZWFkO1xuICBsZXQgYWZ0ZXIgPSAoY29udGV4dE5vZGUgJiYgY29udGV4dE5vZGUubmV4dFNpYmxpbmcpIHx8XG4gICAgdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gIHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGFmdGVyKTtcbiAgaWYgKCFsYXN0SGVhZEFwcGx5Tm9kZSkge1xuICAgIGxhc3RIZWFkQXBwbHlOb2RlID0gc3R5bGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gb25seSB1cGRhdGUgbGFzdEhlYWRBcHBseU5vZGUgaWYgdGhlIG5ldyBzdHlsZSBpcyBpbnNlcnRlZCBhZnRlciB0aGUgb2xkIGxhc3RIZWFkQXBwbHlOb2RlXG4gICAgbGV0IHBvc2l0aW9uID0gc3R5bGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obGFzdEhlYWRBcHBseU5vZGUpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHtcbiAgICAgIGxhc3RIZWFkQXBwbHlOb2RlID0gc3R5bGU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJ1aWxkVHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGFyZ2V0ZWRCdWlsZChidWlsZFR5cGUpIHtcbiAgcmV0dXJuIG5hdGl2ZVNoYWRvdyA/IGJ1aWxkVHlwZSA9PT0gJ3NoYWRvdycgOiBidWlsZFR5cGUgPT09ICdzaGFkeSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3NzQnVpbGRUeXBlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjc3MtYnVpbGQnKTtcbn1cblxuLyoqXG4gKiBXYWxrIGZyb20gdGV4dFtzdGFydF0gbWF0Y2hpbmcgcGFyZW5zIGFuZFxuICogcmV0dXJucyBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgZW5kIHBhcmVuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ1BhcmVuKHRleHQsIHN0YXJ0KSB7XG4gIGxldCBsZXZlbCA9IDA7XG4gIGZvciAobGV0IGk9c3RhcnQsIGw9dGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGV4dFtpXSA9PT0gJygnKSB7XG4gICAgICBsZXZlbCsrO1xuICAgIH0gZWxzZSBpZiAodGV4dFtpXSA9PT0gJyknKSB7XG4gICAgICBpZiAoLS1sZXZlbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nKX0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrKHN0ciwgY2FsbGJhY2spIHtcbiAgLy8gZmluZCAndmFyKCdcbiAgbGV0IHN0YXJ0ID0gc3RyLmluZGV4T2YoJ3ZhcignKTtcbiAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgIC8vIG5vIHZhcj8sIGV2ZXJ5dGhpbmcgaXMgcHJlZml4XG4gICAgcmV0dXJuIGNhbGxiYWNrKHN0ciwgJycsICcnLCAnJyk7XG4gIH1cbiAgLy8ke3ByZWZpeH12YXIoJHtpbm5lcn0pJHtzdWZmaXh9XG4gIGxldCBlbmQgPSBmaW5kTWF0Y2hpbmdQYXJlbihzdHIsIHN0YXJ0ICsgMyk7XG4gIGxldCBpbm5lciA9IHN0ci5zdWJzdHJpbmcoc3RhcnQgKyA0LCBlbmQpO1xuICBsZXQgcHJlZml4ID0gc3RyLnN1YnN0cmluZygwLCBzdGFydCk7XG4gIC8vIHN1ZmZpeCBtYXkgaGF2ZSBvdGhlciB2YXJpYWJsZXNcbiAgbGV0IHN1ZmZpeCA9IHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrKHN0ci5zdWJzdHJpbmcoZW5kICsgMSksIGNhbGxiYWNrKTtcbiAgbGV0IGNvbW1hID0gaW5uZXIuaW5kZXhPZignLCcpO1xuICAvLyB2YWx1ZSBhbmQgZmFsbGJhY2sgYXJncyBzaG91bGQgYmUgdHJpbW1lZCB0byBtYXRjaCBpbiBwcm9wZXJ0eSBsb29rdXBcbiAgaWYgKGNvbW1hID09PSAtMSkge1xuICAgIC8vIHZhcmlhYmxlLCBubyBmYWxsYmFja1xuICAgIHJldHVybiBjYWxsYmFjayhwcmVmaXgsIGlubmVyLnRyaW0oKSwgJycsIHN1ZmZpeCk7XG4gIH1cbiAgLy8gdmFyKCR7dmFsdWV9LCR7ZmFsbGJhY2t9KVxuICBsZXQgdmFsdWUgPSBpbm5lci5zdWJzdHJpbmcoMCwgY29tbWEpLnRyaW0oKTtcbiAgbGV0IGZhbGxiYWNrID0gaW5uZXIuc3Vic3RyaW5nKGNvbW1hICsgMSkudHJpbSgpO1xuICByZXR1cm4gY2FsbGJhY2socHJlZml4LCB2YWx1ZSwgZmFsbGJhY2ssIHN1ZmZpeCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVsZW1lbnRDbGFzc1JhdyhlbGVtZW50LCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIHNldEF0dHJpYnV0ZSBwcm92aWRlZCBieSBTaGFkeURPTSB3aGVuIHNldEF0dHJpYnV0ZSBpcyBwYXRjaGVkXG4gIGlmIChuYXRpdmVTaGFkb3cpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93WydTaGFkeURPTSddWyduYXRpdmVNZXRob2RzJ11bJ3NldEF0dHJpYnV0ZSddLmNhbGwoZWxlbWVudCwgJ2NsYXNzJywgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50IHwge2lzOiBzdHJpbmcsIGV4dGVuZHM6IHN0cmluZ319IGVsZW1lbnRcbiAqIEByZXR1cm4ge3tpczogc3RyaW5nLCB0eXBlRXh0ZW5zaW9uOiBzdHJpbmd9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNFeHRlbmRzKGVsZW1lbnQpIHtcbiAgbGV0IGxvY2FsTmFtZSA9IGVsZW1lbnRbJ2xvY2FsTmFtZSddO1xuICBsZXQgaXMgPSAnJywgdHlwZUV4dGVuc2lvbiA9ICcnO1xuICAvKlxuICBOT1RFOiB0ZWNobmljYWxseSwgdGhpcyBjYW4gYmUgd3JvbmcgZm9yIGNlcnRhaW4gc3ZnIGVsZW1lbnRzXG4gIHdpdGggYC1gIGluIHRoZSBuYW1lIGxpa2UgYDxmb250LWZhY2U+YFxuICAqL1xuICBpZiAobG9jYWxOYW1lKSB7XG4gICAgaWYgKGxvY2FsTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgaXMgPSBsb2NhbE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVFeHRlbnNpb24gPSBsb2NhbE5hbWU7XG4gICAgICBpcyA9IChlbGVtZW50LmdldEF0dHJpYnV0ZSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaXMnKSkgfHwgJyc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlzID0gLyoqIEB0eXBlIHs/fSAqLyhlbGVtZW50KS5pcztcbiAgICB0eXBlRXh0ZW5zaW9uID0gLyoqIEB0eXBlIHs/fSAqLyhlbGVtZW50KS5leHRlbmRzO1xuICB9XG4gIHJldHVybiB7aXMsIHR5cGVFeHRlbnNpb259O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtdXRpbC5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAhSFRNTFRlbXBsYXRlRWxlbWVudD59XG4gKi9cbmNvbnN0IHRlbXBsYXRlTWFwID0ge307XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZU1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3RlbXBsYXRlLW1hcC5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtQcm9taXNlPHZvaWQ+fSAqL1xubGV0IHJlYWR5UHJvbWlzZSA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKD9mdW5jdGlvbigpKX0gKi9cbmxldCB3aGVuUmVhZHkgPSB3aW5kb3dbJ0hUTUxJbXBvcnRzJ10gJiYgd2luZG93WydIVE1MSW1wb3J0cyddWyd3aGVuUmVhZHknXSB8fCBudWxsO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKCl9ICovXG5sZXQgcmVzb2x2ZUZuO1xuXG4vKipcbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKCl9IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRvY3VtZW50V2FpdChjYWxsYmFjaykge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdoZW5SZWFkeSkge1xuICAgICAgd2hlblJlYWR5KGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlYWR5UHJvbWlzZSkge1xuICAgICAgICByZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge3Jlc29sdmVGbiA9IHJlc29sdmV9KTtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICByZXNvbHZlRm4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYWR5UHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7IGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7IH0pO1xuICAgIH1cbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9kb2N1bWVudC13YWl0LmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZG9jdW1lbnRXYWl0IGZyb20gJy4vZG9jdW1lbnQtd2FpdC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0hUTUxTdHlsZUVsZW1lbnQgfCB7Z2V0U3R5bGU6IGZ1bmN0aW9uKCk6SFRNTFN0eWxlRWxlbWVudH19XG4gKi9cbmV4cG9ydCBsZXQgQ3VzdG9tU3R5bGVQcm92aWRlcjtcblxuY29uc3QgU0VFTl9NQVJLRVIgPSAnX19zZWVuQnlTaGFkeUNTUyc7XG5jb25zdCBDQUNIRURfU1RZTEUgPSAnX19zaGFkeUNTU0NhY2hlZFN0eWxlJztcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSAqL1xubGV0IHRyYW5zZm9ybUZuID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oKX0gKi9cbmxldCB2YWxpZGF0ZUZuID0gbnVsbDtcblxuLyoqXG5UaGlzIGludGVyZmFjZSBpcyBwcm92aWRlZCB0byBhZGQgZG9jdW1lbnQtbGV2ZWwgPHN0eWxlPiBlbGVtZW50cyB0byBTaGFkeUNTUyBmb3IgcHJvY2Vzc2luZy5cblRoZXNlIHN0eWxlcyBtdXN0IGJlIHByb2Nlc3NlZCBieSBTaGFkeUNTUyB0byBzaW11bGF0ZSBTaGFkb3dSb290IHVwcGVyLWJvdW5kIGVuY2Fwc3VsYXRpb24gZnJvbSBvdXRzaWRlIHN0eWxlc1xuSW4gYWRkaXRpb24sIHRoZXNlIHN0eWxlcyBtYXkgYWxzbyBuZWVkIHRvIGJlIHByb2Nlc3NlZCBmb3IgQGFwcGx5IHJ1bGVzIGFuZCBDU1MgQ3VzdG9tIFByb3BlcnRpZXNcblxuVG8gYWRkIGRvY3VtZW50LWxldmVsIHN0eWxlcyB0byBTaGFkeUNTUywgb25lIGNhbiBjYWxsIGBTaGFkeUNTUy5hZGREb2N1bWVudFN0eWxlKHN0eWxlRWxlbWVudClgIG9yIGBTaGFkeUNTUy5hZGREb2N1bWVudFN0eWxlKHtnZXRTdHlsZTogKCkgPT4gc3R5bGVFbGVtZW50fSlgXG5cbkluIGFkZGl0aW9uLCBpZiB0aGUgcHJvY2VzcyB1c2VkIHRvIGRpc2NvdmVyIGRvY3VtZW50LWxldmVsIHN0eWxlcyBjYW4gYmUgc3luY2hyb25vdXNseSBmbHVzaGVkLCBvbmUgc2hvdWxkIHNldCBgU2hhZHlDU1MuZG9jdW1lbnRTdHlsZUZsdXNoYC5cblRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBjYWxjdWxhdGluZyBzdHlsZXMuXG5cbkFuIGV4YW1wbGUgdXNhZ2Ugb2YgdGhlIGRvY3VtZW50LWxldmVsIHN0eWxpbmcgYXBpIGNhbiBiZSBmb3VuZCBpbiBgZXhhbXBsZXMvZG9jdW1lbnQtc3R5bGUtbGliLmpzYFxuXG5AdW5yZXN0cmljdGVkXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tU3R5bGVJbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgeyFBcnJheTwhQ3VzdG9tU3R5bGVQcm92aWRlcj59ICovXG4gICAgdGhpc1snY3VzdG9tU3R5bGVzJ10gPSBbXTtcbiAgICB0aGlzWydlbnF1ZXVlZCddID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFF1ZXVlIGEgdmFsaWRhdGlvbiBmb3IgbmV3IGN1c3RvbSBzdHlsZXMgdG8gYmF0Y2ggc3R5bGUgcmVjYWxjdWxhdGlvbnNcbiAgICovXG4gIGVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKSB7XG4gICAgaWYgKHRoaXNbJ2VucXVldWVkJ10gfHwgIXZhbGlkYXRlRm4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpc1snZW5xdWV1ZWQnXSA9IHRydWU7XG4gICAgZG9jdW1lbnRXYWl0KHZhbGlkYXRlRm4pO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICAgKi9cbiAgYWRkQ3VzdG9tU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoIXN0eWxlW1NFRU5fTUFSS0VSXSkge1xuICAgICAgc3R5bGVbU0VFTl9NQVJLRVJdID0gdHJ1ZTtcbiAgICAgIHRoaXNbJ2N1c3RvbVN0eWxlcyddLnB1c2goc3R5bGUpO1xuICAgICAgdGhpcy5lbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFDdXN0b21TdHlsZVByb3ZpZGVyfSBjdXN0b21TdHlsZVxuICAgKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fVxuICAgKi9cbiAgZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShjdXN0b21TdHlsZSkge1xuICAgIGlmIChjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdKSB7XG4gICAgICByZXR1cm4gY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXTtcbiAgICB9XG4gICAgbGV0IHN0eWxlO1xuICAgIGlmIChjdXN0b21TdHlsZVsnZ2V0U3R5bGUnXSkge1xuICAgICAgc3R5bGUgPSBjdXN0b21TdHlsZVsnZ2V0U3R5bGUnXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZSA9IGN1c3RvbVN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBcnJheTwhQ3VzdG9tU3R5bGVQcm92aWRlcj59XG4gICAqL1xuICBwcm9jZXNzU3R5bGVzKCkge1xuICAgIGNvbnN0IGNzID0gdGhpc1snY3VzdG9tU3R5bGVzJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VzdG9tU3R5bGUgPSBjc1tpXTtcbiAgICAgIGlmIChjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoY3VzdG9tU3R5bGUpO1xuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIC8vIEhUTUxJbXBvcnRzIHBvbHlmaWxsIG1heSBoYXZlIGNsb25lZCB0aGUgc3R5bGUgaW50byB0aGUgbWFpbiBkb2N1bWVudCxcbiAgICAgICAgLy8gd2hpY2ggaXMgcmVmZXJlbmNlZCB3aXRoIF9fYXBwbGllZEVsZW1lbnQuXG4gICAgICAgIGNvbnN0IHN0eWxlVG9UcmFuc2Zvcm0gPSAvKiogQHR5cGUgeyFIVE1MU3R5bGVFbGVtZW50fSAqLyhzdHlsZVsnX19hcHBsaWVkRWxlbWVudCddIHx8IHN0eWxlKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybUZuKSB7XG4gICAgICAgICAgdHJhbnNmb3JtRm4oc3R5bGVUb1RyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXSA9IHN0eWxlVG9UcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcztcbiAgfVxufVxuXG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ2FkZEN1c3RvbVN0eWxlJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUuYWRkQ3VzdG9tU3R5bGU7XG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ2dldFN0eWxlRm9yQ3VzdG9tU3R5bGUnXSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRTdHlsZUZvckN1c3RvbVN0eWxlO1xuQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlWydwcm9jZXNzU3R5bGVzJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUucHJvY2Vzc1N0eWxlcztcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLCB7XG4gICd0cmFuc2Zvcm1DYWxsYmFjayc6IHtcbiAgICAvKiogQHJldHVybiB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gKi9cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtRm47XG4gICAgfSxcbiAgICAvKiogQHBhcmFtIHs/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSBmbiAqL1xuICAgIHNldChmbikge1xuICAgICAgdHJhbnNmb3JtRm4gPSBmbjtcbiAgICB9XG4gIH0sXG4gICd2YWxpZGF0ZUNhbGxiYWNrJzoge1xuICAgIC8qKiBAcmV0dXJuIHs/ZnVuY3Rpb24oKX0gKi9cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVGbjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKCl9IGZuXG4gICAgICogQHRoaXMge0N1c3RvbVN0eWxlSW50ZXJmYWNlfVxuICAgICAqL1xuICAgIHNldChmbikge1xuICAgICAgbGV0IG5lZWRzRW5xdWV1ZSA9IGZhbHNlO1xuICAgICAgaWYgKCF2YWxpZGF0ZUZuKSB7XG4gICAgICAgIG5lZWRzRW5xdWV1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YWxpZGF0ZUZuID0gZm47XG4gICAgICBpZiAobmVlZHNFbnF1ZXVlKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gIH1cbn0pXG5cbi8qKiBAdHlwZWRlZiB7e1xuICogY3VzdG9tU3R5bGVzOiAhQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+LFxuICogYWRkQ3VzdG9tU3R5bGU6IGZ1bmN0aW9uKCFDdXN0b21TdHlsZVByb3ZpZGVyKSxcbiAqIGdldFN0eWxlRm9yQ3VzdG9tU3R5bGU6IGZ1bmN0aW9uKCFDdXN0b21TdHlsZVByb3ZpZGVyKTogSFRNTFN0eWxlRWxlbWVudCxcbiAqIGZpbmRTdHlsZXM6IGZ1bmN0aW9uKCksXG4gKiB0cmFuc2Zvcm1DYWxsYmFjazogP2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KSxcbiAqIHZhbGlkYXRlQ2FsbGJhY2s6ID9mdW5jdGlvbigpXG4gKiB9fVxuICovXG5leHBvcnQgbGV0IEN1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0ICogYXMgZ2VzdHVyZXMkMCBmcm9tICcuLi91dGlscy9nZXN0dXJlcy5qcyc7XG5cbi8qKlxuICogQGNvbnN0IHtQb2x5bWVyLkdlc3R1cmVzfVxuICovXG5jb25zdCBnZXN0dXJlcyA9IGdlc3R1cmVzJDA7XG5cbmV4cG9ydCBjb25zdCBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gICAqL1xuICBjbGFzcyBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgIF9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFnZXN0dXJlcy5hZGRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgIHN1cGVyLl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZ2VzdHVyZXMucmVtb3ZlTGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSkge1xuICAgICAgICBzdXBlci5fcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gR2VzdHVyZUV2ZW50TGlzdGVuZXJzO1xuXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5sZXQgc2NoZWR1bGVkID0gZmFsc2U7XG5sZXQgYmVmb3JlUmVuZGVyUXVldWUgPSBbXTtcbmxldCBhZnRlclJlbmRlclF1ZXVlID0gW107XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICBzY2hlZHVsZWQgPSB0cnVlO1xuICAvLyBiZWZvcmUgbmV4dCByZW5kZXJcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGZsdXNoUXVldWUoYmVmb3JlUmVuZGVyUXVldWUpO1xuICAgIC8vIGFmdGVyIHRoZSByZW5kZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcnVuUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmbHVzaFF1ZXVlKHF1ZXVlKSB7XG4gIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICBjYWxsTWV0aG9kKHF1ZXVlLnNoaWZ0KCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG4gIGZvciAobGV0IGk9MCwgbD1xdWV1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjYWxsTWV0aG9kKHF1ZXVlLnNoaWZ0KCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxNZXRob2QoaW5mbykge1xuICBjb25zdCBjb250ZXh0ID0gaW5mb1swXTtcbiAgY29uc3QgY2FsbGJhY2sgPSBpbmZvWzFdO1xuICBjb25zdCBhcmdzID0gaW5mb1syXTtcbiAgdHJ5IHtcbiAgICBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICB3aGlsZSAoYmVmb3JlUmVuZGVyUXVldWUubGVuZ3RoIHx8IGFmdGVyUmVuZGVyUXVldWUubGVuZ3RoKSB7XG4gICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgZmx1c2hRdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgfVxuICBzY2hlZHVsZWQgPSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZU5leHRSZW5kZXIoY29udGV4dCwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICBzY2hlZHVsZSgpO1xuICB9XG4gIGJlZm9yZVJlbmRlclF1ZXVlLnB1c2goW2NvbnRleHQsIGNhbGxiYWNrLCBhcmdzXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZnRlck5leHRSZW5kZXIoY29udGV4dCwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICBzY2hlZHVsZSgpO1xuICB9XG4gIGFmdGVyUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbn1cblxuZXhwb3J0IHsgZmx1c2ggfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5qcyIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfSBmcm9tICcuL2FycmF5LXNwbGljZS5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuL2FzeW5jLmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGVgIGlzIGEgc2xvdCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgc2xvdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTbG90KG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKTtcbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuIFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBjb25zaXN0c1xuICogb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLFxuICogdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICpcbiAqIFRoZSBwcm92aWRlZCBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aGVuZXZlciBhbnkgY2hhbmdlIHRvIHRoaXMgbGlzdFxuICogb2YgZmxhdHRlbmVkIG5vZGVzIG9jY3Vycywgd2hlcmUgYW4gYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBhIG5vZGUgaXNcbiAqIGNvbnNpZGVyZWQgYSBjaGFuZ2UuIFRoZSBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0XG4gKiBjb250YWluaW5nIGFuIGFycmF5IG9mIGFueSBgYWRkZWROb2Rlc2AgYW5kIGByZW1vdmVkTm9kZXNgLlxuICpcbiAqIE5vdGU6IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYXN5bmNocm9ub3VzIHRvIGFueSBjaGFuZ2VzXG4gKiBhdCBhIG1pY3JvdGFzayBjaGVja3BvaW50LiBUaGlzIGlzIGJlY2F1c2Ugb2JzZXJ2YXRpb24gaXMgcGVyZm9ybWVkIHVzaW5nXG4gKiBgTXV0YXRpb25PYnNlcnZlcmAgYW5kIHRoZSBgPHNsb3Q+YCBlbGVtZW50J3MgYHNsb3RjaGFuZ2VgIGV2ZW50IHdoaWNoXG4gKiBhcmUgYXN5bmNocm9ub3VzLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuXG4gKi9cbmNsYXNzIEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICogVGhpcyBsaXN0IGNvbnNpc3RzIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlblxuICAgKiB0aGF0IGFyZSBgPHNsb3Q+YCBlbGVtZW50cywgdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICAgKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gICAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gICAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTFNsb3RFbGVtZW50fSBub2RlIFRoZSBub2RlIGZvciB3aGljaCB0byByZXR1cm4gdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAqL1xuICBzdGF0aWMgZ2V0RmxhdHRlbmVkTm9kZXMobm9kZSkge1xuICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5tYXAobm9kZSA9PiB7XG4gICAgICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MU2xvdEVsZW1lbnR9ICovIChub2RlKS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgfVxuICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCBOb2RlIG9uIHdoaWNoIHRvIGxpc3RlbiBmb3IgY2hhbmdlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlcmUgYXJlIGFkZGl0aW9uc1xuICAgKiBvciByZW1vdmFscyBmcm9tIHRoZSB0YXJnZXQncyBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gW107XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbiAgICB0aGlzLl9ib3VuZFNjaGVkdWxlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9O1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGFuIG9ic2VydmVyLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAqIGEgYEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIGlzIGNyZWF0ZWQuIEl0IHNob3VsZCBvbmx5IGJlIGNhbGxlZCB0b1xuICAgKiByZS1hY3RpdmF0ZSBhbiBvYnNlcnZlciB0aGF0IGhhcyBiZWVuIGRlYWN0aXZhdGVkIHZpYSB0aGUgYGRpc2Nvbm5lY3RgIG1ldGhvZC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICB0aGlzLl9saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgU2hhZHlET00ub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3RhcmdldCwgKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLm9ic2VydmUodGhpcy5fdGFyZ2V0LCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGZsYXR0ZW5lZCBub2RlcyBvYnNlcnZlci4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHdoZW4gY2hhbmdlcyB0byBmbGF0dGVuZWQgbm9kZXNcbiAgICogb2NjdXIuIFRoZSBgY29ubmVjdGAgbWV0aG9kIG1heSBiZSBzdWJzZXF1ZW50bHkgY2FsbGVkIHRvIHJlYWN0aXZhdGVcbiAgICogdGhlIG9ic2VydmVyLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91bmxpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICBTaGFkeURPTS51bm9ic2VydmVDaGlsZHJlbih0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gIH1cblxuICBfc2NoZWR1bGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBtaWNyb1Rhc2sucnVuKCgpID0+IHRoaXMuZmx1c2goKSk7XG4gICAgfVxuICB9XG5cbiAgX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cblxuICBfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgaWYgKG11dGF0aW9ucykge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgaWYgKG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyhtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyhtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgdGhlIG9ic2VydmVyIGNhdXNpbmcgYW55IHBlbmRpbmcgY2hhbmdlcyB0byBiZSBpbW1lZGlhdGVseVxuICAgKiBkZWxpdmVyZWQgdGhlIG9ic2VydmVyIGNhbGxiYWNrLiBCeSBkZWZhdWx0IHRoZXNlIGNoYW5nZXMgYXJlIGRlbGl2ZXJlZFxuICAgKiBhc3luY2hyb25vdXNseSBhdCB0aGUgbmV4dCBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwZW5kaW5nIGNoYW5nZXMgY2F1c2VkIHRoZSBvYnNlcnZlclxuICAgKiBjYWxsYmFjayB0byBydW4uXG4gICAqL1xuICBmbHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgIH1cbiAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgYWRkZWROb2RlczogW10sXG4gICAgICByZW1vdmVkTm9kZXM6IFtdXG4gICAgfTtcbiAgICBsZXQgbmV3Tm9kZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMuX3RhcmdldCk7XG4gICAgbGV0IHNwbGljZXMgPSBjYWxjdWxhdGVTcGxpY2VzKG5ld05vZGVzLFxuICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMpO1xuICAgIC8vIHByb2Nlc3MgcmVtb3ZhbHNcbiAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqPTAsIG47IChqIDwgcy5yZW1vdmVkLmxlbmd0aCkgJiYgKG49cy5yZW1vdmVkW2pdKTsgaisrKSB7XG4gICAgICAgIGluZm8ucmVtb3ZlZE5vZGVzLnB1c2gobik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByb2Nlc3MgYWRkc1xuICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGo9cy5pbmRleDsgaiA8IHMuaW5kZXggKyBzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICBpbmZvLmFkZGVkTm9kZXMucHVzaChuZXdOb2Rlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gbmV3Tm9kZXM7XG4gICAgbGV0IGRpZEZsdXNoID0gZmFsc2U7XG4gICAgaWYgKGluZm8uYWRkZWROb2Rlcy5sZW5ndGggfHwgaW5mby5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBkaWRGbHVzaCA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5fdGFyZ2V0LCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZEZsdXNoO1xuICB9XG5cbiAgX2xpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91bmxpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCB7IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5mdW5jdGlvbiBuZXdTcGxpY2UoaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpIHtcbiAgcmV0dXJuIHtcbiAgICBpbmRleDogaW5kZXgsXG4gICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICBhZGRlZENvdW50OiBhZGRlZENvdW50XG4gIH07XG59XG5cbmNvbnN0IEVESVRfTEVBVkUgPSAwO1xuY29uc3QgRURJVF9VUERBVEUgPSAxO1xuY29uc3QgRURJVF9BREQgPSAyO1xuY29uc3QgRURJVF9ERUxFVEUgPSAzO1xuXG4vLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzICpiYXNlZCogb24gdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBMZXZlbnNodGVpblxuLy8gXCJlZGl0XCIgZGlzdGFuY2UuIFRoZSBvbmUgY2hhbmdlIGlzIHRoYXQgXCJ1cGRhdGVzXCIgYXJlIHRyZWF0ZWQgYXMgdHdvXG4vLyBlZGl0cyAtIG5vdCBvbmUuIFdpdGggQXJyYXkgc3BsaWNlcywgYW4gdXBkYXRlIGlzIHJlYWxseSBhIGRlbGV0ZVxuLy8gZm9sbG93ZWQgYnkgYW4gYWRkLiBCeSByZXRhaW5pbmcgdGhpcywgd2Ugb3B0aW1pemUgZm9yIFwia2VlcGluZ1wiIHRoZVxuLy8gbWF4aW11bSBhcnJheSBpdGVtcyBpbiB0aGUgb3JpZ2luYWwgYXJyYXkuIEZvciBleGFtcGxlOlxuLy9cbi8vICAgJ3h4eHgxMjMnIC0+ICcxMjN5eXl5J1xuLy9cbi8vIFdpdGggMS1lZGl0IHVwZGF0ZXMsIHRoZSBzaG9ydGVzdCBwYXRoIHdvdWxkIGJlIGp1c3QgdG8gdXBkYXRlIGFsbCBzZXZlblxuLy8gY2hhcmFjdGVycy4gV2l0aCAyLWVkaXQgdXBkYXRlcywgd2UgZGVsZXRlIDQsIGxlYXZlIDMsIGFuZCBhZGQgNC4gVGhpc1xuLy8gbGVhdmVzIHRoZSBzdWJzdHJpbmcgJzEyMycgaW50YWN0LlxuZnVuY3Rpb24gY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICAvLyBcIkRlbGV0aW9uXCIgY29sdW1uc1xuICBsZXQgcm93Q291bnQgPSBvbGRFbmQgLSBvbGRTdGFydCArIDE7XG4gIGxldCBjb2x1bW5Db3VudCA9IGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgKyAxO1xuICBsZXQgZGlzdGFuY2VzID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAvLyBcIkFkZGl0aW9uXCIgcm93cy4gSW5pdGlhbGl6ZSBudWxsIGNvbHVtbi5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgZGlzdGFuY2VzW2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgICBkaXN0YW5jZXNbaV1bMF0gPSBpO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBudWxsIHJvd1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbkNvdW50OyBqKyspXG4gICAgZGlzdGFuY2VzWzBdW2pdID0gajtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGNvbHVtbkNvdW50OyBqKyspIHtcbiAgICAgIGlmIChlcXVhbHMoY3VycmVudFtjdXJyZW50U3RhcnQgKyBqIC0gMV0sIG9sZFtvbGRTdGFydCArIGkgLSAxXSkpXG4gICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpIC0gMV1bal0gKyAxO1xuICAgICAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpXVtqIC0gMV0gKyAxO1xuICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBub3J0aCA8IHdlc3QgPyBub3J0aCA6IHdlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlcztcbn1cblxuLy8gVGhpcyBzdGFydHMgYXQgdGhlIGZpbmFsIHdlaWdodCwgYW5kIHdhbGtzIFwiYmFja3dhcmRcIiBieSBmaW5kaW5nXG4vLyB0aGUgbWluaW11bSBwcmV2aW91cyB3ZWlnaHQgcmVjdXJzaXZlbHkgdW50aWwgdGhlIG9yaWdpbiBvZiB0aGUgd2VpZ2h0XG4vLyBtYXRyaXguXG5mdW5jdGlvbiBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoZGlzdGFuY2VzKSB7XG4gIGxldCBpID0gZGlzdGFuY2VzLmxlbmd0aCAtIDE7XG4gIGxldCBqID0gZGlzdGFuY2VzWzBdLmxlbmd0aCAtIDE7XG4gIGxldCBjdXJyZW50ID0gZGlzdGFuY2VzW2ldW2pdO1xuICBsZXQgZWRpdHMgPSBbXTtcbiAgd2hpbGUgKGkgPiAwIHx8IGogPiAwKSB7XG4gICAgaWYgKGkgPT0gMCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICBqLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGogPT0gMCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICBpLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IG5vcnRoV2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqXTtcbiAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaV1baiAtIDFdO1xuXG4gICAgbGV0IG1pbjtcbiAgICBpZiAod2VzdCA8IG5vcnRoKVxuICAgICAgbWluID0gd2VzdCA8IG5vcnRoV2VzdCA/IHdlc3QgOiBub3J0aFdlc3Q7XG4gICAgZWxzZVxuICAgICAgbWluID0gbm9ydGggPCBub3J0aFdlc3QgPyBub3J0aCA6IG5vcnRoV2VzdDtcblxuICAgIGlmIChtaW4gPT0gbm9ydGhXZXN0KSB7XG4gICAgICBpZiAobm9ydGhXZXN0ID09IGN1cnJlbnQpIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX0xFQVZFKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9VUERBVEUpO1xuICAgICAgICBjdXJyZW50ID0gbm9ydGhXZXN0O1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgai0tO1xuICAgIH0gZWxzZSBpZiAobWluID09IHdlc3QpIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgaS0tO1xuICAgICAgY3VycmVudCA9IHdlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgai0tO1xuICAgICAgY3VycmVudCA9IG5vcnRoO1xuICAgIH1cbiAgfVxuXG4gIGVkaXRzLnJldmVyc2UoKTtcbiAgcmV0dXJuIGVkaXRzO1xufVxuXG4vKipcbiAqIFNwbGljZSBQcm9qZWN0aW9uIGZ1bmN0aW9uczpcbiAqXG4gKiBBIHNwbGljZSBtYXAgaXMgYSByZXByZXNlbnRhdGlvbiBvZiBob3cgYSBwcmV2aW91cyBhcnJheSBvZiBpdGVtc1xuICogd2FzIHRyYW5zZm9ybWVkIGludG8gYSBuZXcgYXJyYXkgb2YgaXRlbXMuIENvbmNlcHR1YWxseSBpdCBpcyBhIGxpc3Qgb2ZcbiAqIHR1cGxlcyBvZlxuICpcbiAqICAgPGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50PlxuICpcbiAqIHdoaWNoIGFyZSBrZXB0IGluIGFzY2VuZGluZyBpbmRleCBvcmRlciBvZi4gVGhlIHR1cGxlIHJlcHJlc2VudHMgdGhhdCBhdFxuICogdGhlIHxpbmRleHwsIHxyZW1vdmVkfCBzZXF1ZW5jZSBvZiBpdGVtcyB3ZXJlIHJlbW92ZWQsIGFuZCBjb3VudGluZyBmb3J3YXJkXG4gKiBmcm9tIHxpbmRleHwsIHxhZGRlZENvdW50fCBpdGVtcyB3ZXJlIGFkZGVkLlxuICovXG5cbi8qKlxuICogTGFja2luZyBpbmRpdmlkdWFsIHNwbGljZSBtdXRhdGlvbiBpbmZvcm1hdGlvbiwgdGhlIG1pbmltYWwgc2V0IG9mXG4gKiBzcGxpY2VzIGNhbiBiZSBzeW50aGVzaXplZCBnaXZlbiB0aGUgcHJldmlvdXMgc3RhdGUgYW5kIGZpbmFsIHN0YXRlIG9mIGFuXG4gKiBhcnJheS4gVGhlIGJhc2ljIGFwcHJvYWNoIGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWRpdCBkaXN0YW5jZSBtYXRyaXggYW5kXG4gKiBjaG9vc2UgdGhlIHNob3J0ZXN0IHBhdGggdGhyb3VnaCBpdC5cbiAqXG4gKiBDb21wbGV4aXR5OiBPKGwgKiBwKVxuICogICBsOiBUaGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGFycmF5XG4gKiAgIHA6IFRoZSBsZW5ndGggb2YgdGhlIG9sZCBhcnJheVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGN1cnJlbnQgVGhlIGN1cnJlbnQgXCJjaGFuZ2VkXCIgYXJyYXkgZm9yIHdoaWNoIHRvXG4gKiBjYWxjdWxhdGUgc3BsaWNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50U3RhcnQgU3RhcnRpbmcgaW5kZXggaW4gdGhlIGBjdXJyZW50YCBhcnJheSBmb3JcbiAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBjdXJyZW50YCBhcnJheSBmb3JcbiAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBvbGQgVGhlIG9yaWdpbmFsIFwidW5jaGFuZ2VkXCIgYXJyYXkgdG8gY29tcGFyZSBgY3VycmVudGBcbiAqIGFnYWluc3QgdG8gZGV0ZXJtaW5lIHNwbGljZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2xkU3RhcnQgU3RhcnRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvbGRFbmQgRW5kaW5nIGluZGV4IGluIHRoZSBgb2xkYCBhcnJheSBmb3JcbiAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzcGxpY2UgcmVjb3JkIG9iamVjdHMuIEVhY2ggb2YgdGhlc2VcbiAqIGNvbnRhaW5zOiBgaW5kZXhgIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgc3BsaWNlIG9jY3VycmVkOyBgcmVtb3ZlZGBcbiAqIHRoZSBhcnJheSBvZiByZW1vdmVkIGl0ZW1zIGZyb20gdGhpcyBsb2NhdGlvbjsgYGFkZGVkQ291bnRgIHRoZSBudW1iZXJcbiAqIG9mIGl0ZW1zIGFkZGVkIGF0IHRoaXMgbG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNhbGNTcGxpY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgbGV0IHByZWZpeENvdW50ID0gMDtcbiAgbGV0IHN1ZmZpeENvdW50ID0gMDtcbiAgbGV0IHNwbGljZTtcblxuICBsZXQgbWluTGVuZ3RoID0gTWF0aC5taW4oY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCwgb2xkRW5kIC0gb2xkU3RhcnQpO1xuICBpZiAoY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkU3RhcnQgPT0gMClcbiAgICBwcmVmaXhDb3VudCA9IHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCk7XG5cbiAgaWYgKGN1cnJlbnRFbmQgPT0gY3VycmVudC5sZW5ndGggJiYgb2xkRW5kID09IG9sZC5sZW5ndGgpXG4gICAgc3VmZml4Q291bnQgPSBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGggLSBwcmVmaXhDb3VudCk7XG5cbiAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICBvbGRTdGFydCArPSBwcmVmaXhDb3VudDtcbiAgY3VycmVudEVuZCAtPSBzdWZmaXhDb3VudDtcbiAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuXG4gIGlmIChjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkRW5kIC0gb2xkU3RhcnQgPT0gMClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKGN1cnJlbnRTdGFydCA9PSBjdXJyZW50RW5kKSB7XG4gICAgc3BsaWNlID0gbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIDApO1xuICAgIHdoaWxlIChvbGRTdGFydCA8IG9sZEVuZClcbiAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZFN0YXJ0KytdKTtcblxuICAgIHJldHVybiBbIHNwbGljZSBdO1xuICB9IGVsc2UgaWYgKG9sZFN0YXJ0ID09IG9sZEVuZClcbiAgICByZXR1cm4gWyBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCkgXTtcblxuICBsZXQgb3BzID0gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKFxuICAgICAgY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpKTtcblxuICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gIGxldCBzcGxpY2VzID0gW107XG4gIGxldCBpbmRleCA9IGN1cnJlbnRTdGFydDtcbiAgbGV0IG9sZEluZGV4ID0gb2xkU3RhcnQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoKG9wc1tpXSkge1xuICAgICAgY2FzZSBFRElUX0xFQVZFOlxuICAgICAgICBpZiAoc3BsaWNlKSB7XG4gICAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgICAgICAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfVVBEQVRFOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFRElUX0FERDpcbiAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfREVMRVRFOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3BsaWNlKSB7XG4gICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gIH1cbiAgcmV0dXJuIHNwbGljZXM7XG59XG5cbmZ1bmN0aW9uIHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaExlbmd0aDsgaSsrKVxuICAgIGlmICghZXF1YWxzKGN1cnJlbnRbaV0sIG9sZFtpXSkpXG4gICAgICByZXR1cm4gaTtcbiAgcmV0dXJuIHNlYXJjaExlbmd0aDtcbn1cblxuZnVuY3Rpb24gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gIGxldCBpbmRleDEgPSBjdXJyZW50Lmxlbmd0aDtcbiAgbGV0IGluZGV4MiA9IG9sZC5sZW5ndGg7XG4gIGxldCBjb3VudCA9IDA7XG4gIHdoaWxlIChjb3VudCA8IHNlYXJjaExlbmd0aCAmJiBlcXVhbHMoY3VycmVudFstLWluZGV4MV0sIG9sZFstLWluZGV4Ml0pKVxuICAgIGNvdW50Kys7XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGxpY2VzKGN1cnJlbnQsIHByZXZpb3VzKSB7XG4gIHJldHVybiBjYWxjU3BsaWNlcyhjdXJyZW50LCAwLCBjdXJyZW50Lmxlbmd0aCwgcHJldmlvdXMsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcbiAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gcHJldmlvdXNWYWx1ZTtcbn1cblxuZXhwb3J0IHsgY2FsY3VsYXRlU3BsaWNlcyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGN1c3RvbS1zdHlsZT5cbiAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgaHRtbCB7XG5cbiAgICAgIC8qIE1hdGVyaWFsIERlc2lnbiBjb2xvciBwYWxldHRlIGZvciBHb29nbGUgcHJvZHVjdHMgKi9cblxuICAgICAgLS1nb29nbGUtcmVkLTEwMDogI2Y0YzdjMztcbiAgICAgIC0tZ29vZ2xlLXJlZC0zMDA6ICNlNjdjNzM7XG4gICAgICAtLWdvb2dsZS1yZWQtNTAwOiAjZGI0NDM3O1xuICAgICAgLS1nb29nbGUtcmVkLTcwMDogI2M1MzkyOTtcblxuICAgICAgLS1nb29nbGUtYmx1ZS0xMDA6ICNjNmRhZmM7XG4gICAgICAtLWdvb2dsZS1ibHVlLTMwMDogIzdiYWFmNztcbiAgICAgIC0tZ29vZ2xlLWJsdWUtNTAwOiAjNDI4NWY0O1xuICAgICAgLS1nb29nbGUtYmx1ZS03MDA6ICMzMzY3ZDY7XG5cbiAgICAgIC0tZ29vZ2xlLWdyZWVuLTEwMDogI2I3ZTFjZDtcbiAgICAgIC0tZ29vZ2xlLWdyZWVuLTMwMDogIzU3YmI4YTtcbiAgICAgIC0tZ29vZ2xlLWdyZWVuLTUwMDogIzBmOWQ1ODtcbiAgICAgIC0tZ29vZ2xlLWdyZWVuLTcwMDogIzBiODA0MztcblxuICAgICAgLS1nb29nbGUteWVsbG93LTEwMDogI2ZjZThiMjtcbiAgICAgIC0tZ29vZ2xlLXllbGxvdy0zMDA6ICNmN2NiNGQ7XG4gICAgICAtLWdvb2dsZS15ZWxsb3ctNTAwOiAjZjRiNDAwO1xuICAgICAgLS1nb29nbGUteWVsbG93LTcwMDogI2YwOTMwMDtcblxuICAgICAgLS1nb29nbGUtZ3JleS0xMDA6ICNmNWY1ZjU7XG4gICAgICAtLWdvb2dsZS1ncmV5LTMwMDogI2UwZTBlMDtcbiAgICAgIC0tZ29vZ2xlLWdyZXktNTAwOiAjOWU5ZTllO1xuICAgICAgLS1nb29nbGUtZ3JleS03MDA6ICM2MTYxNjE7XG5cbiAgICAgIC8qIE1hdGVyaWFsIERlc2lnbiBjb2xvciBwYWxldHRlIGZyb20gb25saW5lIHNwZWMgZG9jdW1lbnQgKi9cblxuICAgICAgLS1wYXBlci1yZWQtNTA6ICNmZmViZWU7XG4gICAgICAtLXBhcGVyLXJlZC0xMDA6ICNmZmNkZDI7XG4gICAgICAtLXBhcGVyLXJlZC0yMDA6ICNlZjlhOWE7XG4gICAgICAtLXBhcGVyLXJlZC0zMDA6ICNlNTczNzM7XG4gICAgICAtLXBhcGVyLXJlZC00MDA6ICNlZjUzNTA7XG4gICAgICAtLXBhcGVyLXJlZC01MDA6ICNmNDQzMzY7XG4gICAgICAtLXBhcGVyLXJlZC02MDA6ICNlNTM5MzU7XG4gICAgICAtLXBhcGVyLXJlZC03MDA6ICNkMzJmMmY7XG4gICAgICAtLXBhcGVyLXJlZC04MDA6ICNjNjI4Mjg7XG4gICAgICAtLXBhcGVyLXJlZC05MDA6ICNiNzFjMWM7XG4gICAgICAtLXBhcGVyLXJlZC1hMTAwOiAjZmY4YTgwO1xuICAgICAgLS1wYXBlci1yZWQtYTIwMDogI2ZmNTI1MjtcbiAgICAgIC0tcGFwZXItcmVkLWE0MDA6ICNmZjE3NDQ7XG4gICAgICAtLXBhcGVyLXJlZC1hNzAwOiAjZDUwMDAwO1xuXG4gICAgICAtLXBhcGVyLXBpbmstNTA6ICNmY2U0ZWM7XG4gICAgICAtLXBhcGVyLXBpbmstMTAwOiAjZjhiYmQwO1xuICAgICAgLS1wYXBlci1waW5rLTIwMDogI2Y0OGZiMTtcbiAgICAgIC0tcGFwZXItcGluay0zMDA6ICNmMDYyOTI7XG4gICAgICAtLXBhcGVyLXBpbmstNDAwOiAjZWM0MDdhO1xuICAgICAgLS1wYXBlci1waW5rLTUwMDogI2U5MWU2MztcbiAgICAgIC0tcGFwZXItcGluay02MDA6ICNkODFiNjA7XG4gICAgICAtLXBhcGVyLXBpbmstNzAwOiAjYzIxODViO1xuICAgICAgLS1wYXBlci1waW5rLTgwMDogI2FkMTQ1NztcbiAgICAgIC0tcGFwZXItcGluay05MDA6ICM4ODBlNGY7XG4gICAgICAtLXBhcGVyLXBpbmstYTEwMDogI2ZmODBhYjtcbiAgICAgIC0tcGFwZXItcGluay1hMjAwOiAjZmY0MDgxO1xuICAgICAgLS1wYXBlci1waW5rLWE0MDA6ICNmNTAwNTc7XG4gICAgICAtLXBhcGVyLXBpbmstYTcwMDogI2M1MTE2MjtcblxuICAgICAgLS1wYXBlci1wdXJwbGUtNTA6ICNmM2U1ZjU7XG4gICAgICAtLXBhcGVyLXB1cnBsZS0xMDA6ICNlMWJlZTc7XG4gICAgICAtLXBhcGVyLXB1cnBsZS0yMDA6ICNjZTkzZDg7XG4gICAgICAtLXBhcGVyLXB1cnBsZS0zMDA6ICNiYTY4Yzg7XG4gICAgICAtLXBhcGVyLXB1cnBsZS00MDA6ICNhYjQ3YmM7XG4gICAgICAtLXBhcGVyLXB1cnBsZS01MDA6ICM5YzI3YjA7XG4gICAgICAtLXBhcGVyLXB1cnBsZS02MDA6ICM4ZTI0YWE7XG4gICAgICAtLXBhcGVyLXB1cnBsZS03MDA6ICM3YjFmYTI7XG4gICAgICAtLXBhcGVyLXB1cnBsZS04MDA6ICM2YTFiOWE7XG4gICAgICAtLXBhcGVyLXB1cnBsZS05MDA6ICM0YTE0OGM7XG4gICAgICAtLXBhcGVyLXB1cnBsZS1hMTAwOiAjZWE4MGZjO1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTIwMDogI2UwNDBmYjtcbiAgICAgIC0tcGFwZXItcHVycGxlLWE0MDA6ICNkNTAwZjk7XG4gICAgICAtLXBhcGVyLXB1cnBsZS1hNzAwOiAjYWEwMGZmO1xuXG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTUwOiAjZWRlN2Y2O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS0xMDA6ICNkMWM0ZTk7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTIwMDogI2IzOWRkYjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtMzAwOiAjOTU3NWNkO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS00MDA6ICM3ZTU3YzI7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTUwMDogIzY3M2FiNztcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNjAwOiAjNWUzNWIxO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS03MDA6ICM1MTJkYTg7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTgwMDogIzQ1MjdhMDtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtOTAwOiAjMzExYjkyO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS1hMTAwOiAjYjM4OGZmO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS1hMjAwOiAjN2M0ZGZmO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS1hNDAwOiAjNjUxZmZmO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS1hNzAwOiAjNjIwMGVhO1xuXG4gICAgICAtLXBhcGVyLWluZGlnby01MDogI2U4ZWFmNjtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTEwMDogI2M1Y2FlOTtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTIwMDogIzlmYThkYTtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTMwMDogIzc5ODZjYjtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTQwMDogIzVjNmJjMDtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTUwMDogIzNmNTFiNTtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTYwMDogIzM5NDlhYjtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTcwMDogIzMwM2Y5ZjtcbiAgICAgIC0tcGFwZXItaW5kaWdvLTgwMDogIzI4MzU5MztcbiAgICAgIC0tcGFwZXItaW5kaWdvLTkwMDogIzFhMjM3ZTtcbiAgICAgIC0tcGFwZXItaW5kaWdvLWExMDA6ICM4YzllZmY7XG4gICAgICAtLXBhcGVyLWluZGlnby1hMjAwOiAjNTM2ZGZlO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTQwMDogIzNkNWFmZTtcbiAgICAgIC0tcGFwZXItaW5kaWdvLWE3MDA6ICMzMDRmZmU7XG5cbiAgICAgIC0tcGFwZXItYmx1ZS01MDogI2UzZjJmZDtcbiAgICAgIC0tcGFwZXItYmx1ZS0xMDA6ICNiYmRlZmI7XG4gICAgICAtLXBhcGVyLWJsdWUtMjAwOiAjOTBjYWY5O1xuICAgICAgLS1wYXBlci1ibHVlLTMwMDogIzY0YjVmNjtcbiAgICAgIC0tcGFwZXItYmx1ZS00MDA6ICM0MmE1ZjU7XG4gICAgICAtLXBhcGVyLWJsdWUtNTAwOiAjMjE5NmYzO1xuICAgICAgLS1wYXBlci1ibHVlLTYwMDogIzFlODhlNTtcbiAgICAgIC0tcGFwZXItYmx1ZS03MDA6ICMxOTc2ZDI7XG4gICAgICAtLXBhcGVyLWJsdWUtODAwOiAjMTU2NWMwO1xuICAgICAgLS1wYXBlci1ibHVlLTkwMDogIzBkNDdhMTtcbiAgICAgIC0tcGFwZXItYmx1ZS1hMTAwOiAjODJiMWZmO1xuICAgICAgLS1wYXBlci1ibHVlLWEyMDA6ICM0NDhhZmY7XG4gICAgICAtLXBhcGVyLWJsdWUtYTQwMDogIzI5NzlmZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1hNzAwOiAjMjk2MmZmO1xuXG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNTA6ICNlMWY1ZmU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtMTAwOiAjYjNlNWZjO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTIwMDogIzgxZDRmYTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS0zMDA6ICM0ZmMzZjc7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNDAwOiAjMjliNmY2O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTUwMDogIzAzYTlmNDtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS02MDA6ICMwMzliZTU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNzAwOiAjMDI4OGQxO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTgwMDogIzAyNzdiZDtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS05MDA6ICMwMTU3OWI7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtYTEwMDogIzgwZDhmZjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hMjAwOiAjNDBjNGZmO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWE0MDA6ICMwMGIwZmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtYTcwMDogIzAwOTFlYTtcblxuICAgICAgLS1wYXBlci1jeWFuLTUwOiAjZTBmN2ZhO1xuICAgICAgLS1wYXBlci1jeWFuLTEwMDogI2IyZWJmMjtcbiAgICAgIC0tcGFwZXItY3lhbi0yMDA6ICM4MGRlZWE7XG4gICAgICAtLXBhcGVyLWN5YW4tMzAwOiAjNGRkMGUxO1xuICAgICAgLS1wYXBlci1jeWFuLTQwMDogIzI2YzZkYTtcbiAgICAgIC0tcGFwZXItY3lhbi01MDA6ICMwMGJjZDQ7XG4gICAgICAtLXBhcGVyLWN5YW4tNjAwOiAjMDBhY2MxO1xuICAgICAgLS1wYXBlci1jeWFuLTcwMDogIzAwOTdhNztcbiAgICAgIC0tcGFwZXItY3lhbi04MDA6ICMwMDgzOGY7XG4gICAgICAtLXBhcGVyLWN5YW4tOTAwOiAjMDA2MDY0O1xuICAgICAgLS1wYXBlci1jeWFuLWExMDA6ICM4NGZmZmY7XG4gICAgICAtLXBhcGVyLWN5YW4tYTIwMDogIzE4ZmZmZjtcbiAgICAgIC0tcGFwZXItY3lhbi1hNDAwOiAjMDBlNWZmO1xuICAgICAgLS1wYXBlci1jeWFuLWE3MDA6ICMwMGI4ZDQ7XG5cbiAgICAgIC0tcGFwZXItdGVhbC01MDogI2UwZjJmMTtcbiAgICAgIC0tcGFwZXItdGVhbC0xMDA6ICNiMmRmZGI7XG4gICAgICAtLXBhcGVyLXRlYWwtMjAwOiAjODBjYmM0O1xuICAgICAgLS1wYXBlci10ZWFsLTMwMDogIzRkYjZhYztcbiAgICAgIC0tcGFwZXItdGVhbC00MDA6ICMyNmE2OWE7XG4gICAgICAtLXBhcGVyLXRlYWwtNTAwOiAjMDA5Njg4O1xuICAgICAgLS1wYXBlci10ZWFsLTYwMDogIzAwODk3YjtcbiAgICAgIC0tcGFwZXItdGVhbC03MDA6ICMwMDc5NmI7XG4gICAgICAtLXBhcGVyLXRlYWwtODAwOiAjMDA2OTVjO1xuICAgICAgLS1wYXBlci10ZWFsLTkwMDogIzAwNGQ0MDtcbiAgICAgIC0tcGFwZXItdGVhbC1hMTAwOiAjYTdmZmViO1xuICAgICAgLS1wYXBlci10ZWFsLWEyMDA6ICM2NGZmZGE7XG4gICAgICAtLXBhcGVyLXRlYWwtYTQwMDogIzFkZTliNjtcbiAgICAgIC0tcGFwZXItdGVhbC1hNzAwOiAjMDBiZmE1O1xuXG4gICAgICAtLXBhcGVyLWdyZWVuLTUwOiAjZThmNWU5O1xuICAgICAgLS1wYXBlci1ncmVlbi0xMDA6ICNjOGU2Yzk7XG4gICAgICAtLXBhcGVyLWdyZWVuLTIwMDogI2E1ZDZhNztcbiAgICAgIC0tcGFwZXItZ3JlZW4tMzAwOiAjODFjNzg0O1xuICAgICAgLS1wYXBlci1ncmVlbi00MDA6ICM2NmJiNmE7XG4gICAgICAtLXBhcGVyLWdyZWVuLTUwMDogIzRjYWY1MDtcbiAgICAgIC0tcGFwZXItZ3JlZW4tNjAwOiAjNDNhMDQ3O1xuICAgICAgLS1wYXBlci1ncmVlbi03MDA6ICMzODhlM2M7XG4gICAgICAtLXBhcGVyLWdyZWVuLTgwMDogIzJlN2QzMjtcbiAgICAgIC0tcGFwZXItZ3JlZW4tOTAwOiAjMWI1ZTIwO1xuICAgICAgLS1wYXBlci1ncmVlbi1hMTAwOiAjYjlmNmNhO1xuICAgICAgLS1wYXBlci1ncmVlbi1hMjAwOiAjNjlmMGFlO1xuICAgICAgLS1wYXBlci1ncmVlbi1hNDAwOiAjMDBlNjc2O1xuICAgICAgLS1wYXBlci1ncmVlbi1hNzAwOiAjMDBjODUzO1xuXG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTUwOiAjZjFmOGU5O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi0xMDA6ICNkY2VkYzg7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTIwMDogI2M1ZTFhNTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tMzAwOiAjYWVkNTgxO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi00MDA6ICM5Y2NjNjU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTUwMDogIzhiYzM0YTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNjAwOiAjN2NiMzQyO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi03MDA6ICM2ODlmMzg7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTgwMDogIzU1OGIyZjtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tOTAwOiAjMzM2OTFlO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi1hMTAwOiAjY2NmZjkwO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi1hMjAwOiAjYjJmZjU5O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi1hNDAwOiAjNzZmZjAzO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi1hNzAwOiAjNjRkZDE3O1xuXG4gICAgICAtLXBhcGVyLWxpbWUtNTA6ICNmOWZiZTc7XG4gICAgICAtLXBhcGVyLWxpbWUtMTAwOiAjZjBmNGMzO1xuICAgICAgLS1wYXBlci1saW1lLTIwMDogI2U2ZWU5YztcbiAgICAgIC0tcGFwZXItbGltZS0zMDA6ICNkY2U3NzU7XG4gICAgICAtLXBhcGVyLWxpbWUtNDAwOiAjZDRlMTU3O1xuICAgICAgLS1wYXBlci1saW1lLTUwMDogI2NkZGMzOTtcbiAgICAgIC0tcGFwZXItbGltZS02MDA6ICNjMGNhMzM7XG4gICAgICAtLXBhcGVyLWxpbWUtNzAwOiAjYWZiNDJiO1xuICAgICAgLS1wYXBlci1saW1lLTgwMDogIzllOWQyNDtcbiAgICAgIC0tcGFwZXItbGltZS05MDA6ICM4Mjc3MTc7XG4gICAgICAtLXBhcGVyLWxpbWUtYTEwMDogI2Y0ZmY4MTtcbiAgICAgIC0tcGFwZXItbGltZS1hMjAwOiAjZWVmZjQxO1xuICAgICAgLS1wYXBlci1saW1lLWE0MDA6ICNjNmZmMDA7XG4gICAgICAtLXBhcGVyLWxpbWUtYTcwMDogI2FlZWEwMDtcblxuICAgICAgLS1wYXBlci15ZWxsb3ctNTA6ICNmZmZkZTc7XG4gICAgICAtLXBhcGVyLXllbGxvdy0xMDA6ICNmZmY5YzQ7XG4gICAgICAtLXBhcGVyLXllbGxvdy0yMDA6ICNmZmY1OWQ7XG4gICAgICAtLXBhcGVyLXllbGxvdy0zMDA6ICNmZmYxNzY7XG4gICAgICAtLXBhcGVyLXllbGxvdy00MDA6ICNmZmVlNTg7XG4gICAgICAtLXBhcGVyLXllbGxvdy01MDA6ICNmZmViM2I7XG4gICAgICAtLXBhcGVyLXllbGxvdy02MDA6ICNmZGQ4MzU7XG4gICAgICAtLXBhcGVyLXllbGxvdy03MDA6ICNmYmMwMmQ7XG4gICAgICAtLXBhcGVyLXllbGxvdy04MDA6ICNmOWE4MjU7XG4gICAgICAtLXBhcGVyLXllbGxvdy05MDA6ICNmNTdmMTc7XG4gICAgICAtLXBhcGVyLXllbGxvdy1hMTAwOiAjZmZmZjhkO1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTIwMDogI2ZmZmYwMDtcbiAgICAgIC0tcGFwZXIteWVsbG93LWE0MDA6ICNmZmVhMDA7XG4gICAgICAtLXBhcGVyLXllbGxvdy1hNzAwOiAjZmZkNjAwO1xuXG4gICAgICAtLXBhcGVyLWFtYmVyLTUwOiAjZmZmOGUxO1xuICAgICAgLS1wYXBlci1hbWJlci0xMDA6ICNmZmVjYjM7XG4gICAgICAtLXBhcGVyLWFtYmVyLTIwMDogI2ZmZTA4MjtcbiAgICAgIC0tcGFwZXItYW1iZXItMzAwOiAjZmZkNTRmO1xuICAgICAgLS1wYXBlci1hbWJlci00MDA6ICNmZmNhMjg7XG4gICAgICAtLXBhcGVyLWFtYmVyLTUwMDogI2ZmYzEwNztcbiAgICAgIC0tcGFwZXItYW1iZXItNjAwOiAjZmZiMzAwO1xuICAgICAgLS1wYXBlci1hbWJlci03MDA6ICNmZmEwMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLTgwMDogI2ZmOGYwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItOTAwOiAjZmY2ZjAwO1xuICAgICAgLS1wYXBlci1hbWJlci1hMTAwOiAjZmZlNTdmO1xuICAgICAgLS1wYXBlci1hbWJlci1hMjAwOiAjZmZkNzQwO1xuICAgICAgLS1wYXBlci1hbWJlci1hNDAwOiAjZmZjNDAwO1xuICAgICAgLS1wYXBlci1hbWJlci1hNzAwOiAjZmZhYjAwO1xuXG4gICAgICAtLXBhcGVyLW9yYW5nZS01MDogI2ZmZjNlMDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTEwMDogI2ZmZTBiMjtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTIwMDogI2ZmY2M4MDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTMwMDogI2ZmYjc0ZDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTQwMDogI2ZmYTcyNjtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTUwMDogI2ZmOTgwMDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTYwMDogI2ZiOGMwMDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTcwMDogI2Y1N2MwMDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTgwMDogI2VmNmMwMDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLTkwMDogI2U2NTEwMDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLWExMDA6ICNmZmQxODA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hMjAwOiAjZmZhYjQwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTQwMDogI2ZmOTEwMDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLWE3MDA6ICNmZjY1MDA7XG5cbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNTA6ICNmYmU5ZTc7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTEwMDogI2ZmY2NiYztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtMjAwOiAjZmZhYjkxO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS0zMDA6ICNmZjhhNjU7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTQwMDogI2ZmNzA0MztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNTAwOiAjZmY1NzIyO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS02MDA6ICNmNDUxMWU7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTcwMDogI2U2NGExOTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtODAwOiAjZDg0MzE1O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS05MDA6ICNiZjM2MGM7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLWExMDA6ICNmZjllODA7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLWEyMDA6ICNmZjZlNDA7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLWE0MDA6ICNmZjNkMDA7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLWE3MDA6ICNkZDJjMDA7XG5cbiAgICAgIC0tcGFwZXItYnJvd24tNTA6ICNlZmViZTk7XG4gICAgICAtLXBhcGVyLWJyb3duLTEwMDogI2Q3Y2NjODtcbiAgICAgIC0tcGFwZXItYnJvd24tMjAwOiAjYmNhYWE0O1xuICAgICAgLS1wYXBlci1icm93bi0zMDA6ICNhMTg4N2Y7XG4gICAgICAtLXBhcGVyLWJyb3duLTQwMDogIzhkNmU2MztcbiAgICAgIC0tcGFwZXItYnJvd24tNTAwOiAjNzk1NTQ4O1xuICAgICAgLS1wYXBlci1icm93bi02MDA6ICM2ZDRjNDE7XG4gICAgICAtLXBhcGVyLWJyb3duLTcwMDogIzVkNDAzNztcbiAgICAgIC0tcGFwZXItYnJvd24tODAwOiAjNGUzNDJlO1xuICAgICAgLS1wYXBlci1icm93bi05MDA6ICMzZTI3MjM7XG5cbiAgICAgIC0tcGFwZXItZ3JleS01MDogI2ZhZmFmYTtcbiAgICAgIC0tcGFwZXItZ3JleS0xMDA6ICNmNWY1ZjU7XG4gICAgICAtLXBhcGVyLWdyZXktMjAwOiAjZWVlZWVlO1xuICAgICAgLS1wYXBlci1ncmV5LTMwMDogI2UwZTBlMDtcbiAgICAgIC0tcGFwZXItZ3JleS00MDA6ICNiZGJkYmQ7XG4gICAgICAtLXBhcGVyLWdyZXktNTAwOiAjOWU5ZTllO1xuICAgICAgLS1wYXBlci1ncmV5LTYwMDogIzc1NzU3NTtcbiAgICAgIC0tcGFwZXItZ3JleS03MDA6ICM2MTYxNjE7XG4gICAgICAtLXBhcGVyLWdyZXktODAwOiAjNDI0MjQyO1xuICAgICAgLS1wYXBlci1ncmV5LTkwMDogIzIxMjEyMTtcblxuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNTA6ICNlY2VmZjE7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS0xMDA6ICNjZmQ4ZGM7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS0yMDA6ICNiMGJlYzU7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS0zMDA6ICM5MGE0YWU7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS00MDA6ICM3ODkwOWM7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS01MDA6ICM2MDdkOGI7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS02MDA6ICM1NDZlN2E7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS03MDA6ICM0NTVhNjQ7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS04MDA6ICMzNzQ3NGY7XG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS05MDA6ICMyNjMyMzg7XG5cbiAgICAgIC8qIG9wYWNpdHkgZm9yIGRhcmsgdGV4dCBvbiBhIGxpZ2h0IGJhY2tncm91bmQgKi9cbiAgICAgIC0tZGFyay1kaXZpZGVyLW9wYWNpdHk6IDAuMTI7XG4gICAgICAtLWRhcmstZGlzYWJsZWQtb3BhY2l0eTogMC4zODsgLyogb3IgaGludCB0ZXh0IG9yIGljb24gKi9cbiAgICAgIC0tZGFyay1zZWNvbmRhcnktb3BhY2l0eTogMC41NDtcbiAgICAgIC0tZGFyay1wcmltYXJ5LW9wYWNpdHk6IDAuODc7XG5cbiAgICAgIC8qIG9wYWNpdHkgZm9yIGxpZ2h0IHRleHQgb24gYSBkYXJrIGJhY2tncm91bmQgKi9cbiAgICAgIC0tbGlnaHQtZGl2aWRlci1vcGFjaXR5OiAwLjEyO1xuICAgICAgLS1saWdodC1kaXNhYmxlZC1vcGFjaXR5OiAwLjM7IC8qIG9yIGhpbnQgdGV4dCBvciBpY29uICovXG4gICAgICAtLWxpZ2h0LXNlY29uZGFyeS1vcGFjaXR5OiAwLjc7XG4gICAgICAtLWxpZ2h0LXByaW1hcnktb3BhY2l0eTogMS4wO1xuXG4gICAgfVxuXG4gIDwvc3R5bGU+XG48L2N1c3RvbS1zdHlsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvY29sb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25CdXR0b25TdGF0ZUltcGwgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgaXMgY3VycmVudGx5IGhvbGRpbmcgZG93biB0aGUgYnV0dG9uLlxuICAgICAqL1xuICAgIHByZXNzZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX3ByZXNzZWRDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSB3aXRoIGVhY2ggdGFwIG9yIHByZXNzXG4gICAgICogb2YgdGhlIHNwYWNlYmFyLlxuICAgICAqL1xuICAgIHRvZ2dsZXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiBpcyBhIHRvZ2dsZSBhbmQgaXMgY3VycmVudGx5IGluIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAgICovXG4gICAgYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYnkgYSBcInBvaW50ZXIsXCIgd2hpY2hcbiAgICAgKiBpcyBsb29zZWx5IGRlZmluZWQgYXMgbW91c2Ugb3IgdG91Y2ggaW5wdXQgKGJ1dCBzcGVjaWZpY2FsbHkgZXhjbHVkaW5nXG4gICAgICoga2V5Ym9hcmQgaW5wdXQpLlxuICAgICAqL1xuICAgIHBvaW50ZXJEb3duOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgZGV2aWNlIHRoYXQgY2F1c2VkIHRoZSBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcbiAgICAgKiB3YXMgYSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGFyaWEgYXR0cmlidXRlIHRvIGJlIHNldCBpZiB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpbiB0aGVcbiAgICAgKiBhY3RpdmUgc3RhdGUuXG4gICAgICovXG4gICAgYXJpYUFjdGl2ZUF0dHJpYnV0ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdhcmlhLXByZXNzZWQnLFxuICAgICAgb2JzZXJ2ZXI6ICdfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQnXG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgIGRvd246ICdfZG93bkhhbmRsZXInLFxuICAgIHVwOiAnX3VwSGFuZGxlcicsXG4gICAgdGFwOiAnX3RhcEhhbmRsZXInXG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19mb2N1c0NoYW5nZWQoZm9jdXNlZCknLFxuICAgICdfYWN0aXZlQ2hhbmdlZChhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpJ1xuICBdLFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ2VudGVyOmtleWRvd24nOiAnX2FzeW5jQ2xpY2snLFxuICAgICdzcGFjZTprZXlkb3duJzogJ19zcGFjZUtleURvd25IYW5kbGVyJyxcbiAgICAnc3BhY2U6a2V5dXAnOiAnX3NwYWNlS2V5VXBIYW5kbGVyJyxcbiAgfSxcblxuICBfbW91c2VFdmVudFJlOiAvXm1vdXNlLyxcblxuICBfdGFwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAvLyBhIHRhcCBpcyBuZWVkZWQgdG8gdG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGVcbiAgICAgIHRoaXMuX3VzZXJBY3RpdmF0ZSghdGhpcy5hY3RpdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBfZm9jdXNDaGFuZ2VkOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgdGhpcy5fZGV0ZWN0S2V5Ym9hcmRGb2N1cyhmb2N1c2VkKTtcblxuICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIF9kZXRlY3RLZXlib2FyZEZvY3VzOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCghdGhpcy5wb2ludGVyRG93biAmJiBmb2N1c2VkKTtcbiAgfSxcblxuICAvLyB0byBlbXVsYXRlIG5hdGl2ZSBjaGVja2JveCwgKGRlLSlhY3RpdmF0aW9ucyBmcm9tIGEgdXNlciBpbnRlcmFjdGlvbiBmaXJlXG4gIC8vICdjaGFuZ2UnIGV2ZW50c1xuICBfdXNlckFjdGl2YXRlOiBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUgIT09IGFjdGl2ZSkge1xuICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5fc2V0UG9pbnRlckRvd24odHJ1ZSk7XG4gICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKGZhbHNlKTtcbiAgfSxcblxuICBfdXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRQb2ludGVyRG93bihmYWxzZSk7XG4gICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICovXG4gIF9zcGFjZUtleURvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgdmFyIHRhcmdldCA9IGRvbShrZXlib2FyZEV2ZW50KS5sb2NhbFRhcmdldDtcblxuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAvLyBlbGVtZW50IHdpbGwgZGVhbCB3aXRoIGl0LlxuICAgIGlmICh0aGlzLmlzTGlnaHREZXNjZW5kYW50KC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpXG4gICAgICByZXR1cm47XG5cbiAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAga2V5Ym9hcmRFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAqL1xuICBfc3BhY2VLZXlVcEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgIHJldHVybjtcblxuICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgIHRoaXMuX2FzeW5jQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gIH0sXG5cbiAgLy8gdHJpZ2dlciBjbGljayBhc3luY2hyb25vdXNseSwgdGhlIGFzeW5jaHJvbnkgaXMgdXNlZnVsIHRvIGFsbG93IG9uZVxuICAvLyBldmVudCBoYW5kbGVyIHRvIHVud2luZCBiZWZvcmUgdHJpZ2dlcmluZyBhbm90aGVyIGV2ZW50XG4gIF9hc3luY0NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGljaygpO1xuICAgIH0sIDEpO1xuICB9LFxuXG4gIC8vIGFueSBvZiB0aGVzZSBjaGFuZ2VzIGFyZSBjb25zaWRlcmVkIGEgY2hhbmdlIHRvIGJ1dHRvbiBzdGF0ZVxuXG4gIF9wcmVzc2VkQ2hhbmdlZDogZnVuY3Rpb24ocHJlc3NlZCkge1xuICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICB9LFxuXG4gIF9hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZDogZnVuY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgaWYgKG9sZFZhbHVlICYmIG9sZFZhbHVlICE9IHZhbHVlICYmIHRoaXMuaGFzQXR0cmlidXRlKG9sZFZhbHVlKSkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUob2xkVmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfYWN0aXZlQ2hhbmdlZDogZnVuY3Rpb24oYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSB7XG4gICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICB9LFxuXG4gIF9jb250cm9sU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvLyBwcm92aWRlIGhvb2sgZm9yIGZvbGxvdy1vbiBiZWhhdmlvcnMgdG8gcmVhY3QgdG8gYnV0dG9uLXN0YXRlXG5cbiAgX2NoYW5nZWRCdXR0b25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKCk7IC8vIGFic3RyYWN0XG4gICAgfVxuICB9XG5cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uQnV0dG9uU3RhdGUgPSBbXG4gIElyb25BMTF5S2V5c0JlaGF2aW9yLFxuICBJcm9uQnV0dG9uU3RhdGVJbXBsXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcblxuLyoqXG4gKiBDaHJvbWUgdXNlcyBhbiBvbGRlciB2ZXJzaW9uIG9mIERPTSBMZXZlbCAzIEtleWJvYXJkIEV2ZW50c1xuICpcbiAqIE1vc3Qga2V5cyBhcmUgbGFiZWxlZCBhcyB0ZXh0LCBidXQgc29tZSBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLlxuICogVmFsdWVzIHRha2VuIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2tleXNldC5odG1sI0tleVNldC1TZXRcbiAqL1xudmFyIEtFWV9JREVOVElGSUVSID0ge1xuICAnVSswMDA4JzogJ2JhY2tzcGFjZScsXG4gICdVKzAwMDknOiAndGFiJyxcbiAgJ1UrMDAxQic6ICdlc2MnLFxuICAnVSswMDIwJzogJ3NwYWNlJyxcbiAgJ1UrMDA3Ric6ICdkZWwnXG59O1xuXG4vKipcbiAqIFNwZWNpYWwgdGFibGUgZm9yIEtleWJvYXJkRXZlbnQua2V5Q29kZS5cbiAqIEtleWJvYXJkRXZlbnQua2V5SWRlbnRpZmllciBpcyBiZXR0ZXIsIGFuZCBLZXlCb2FyZEV2ZW50LmtleSBpcyBldmVuIGJldHRlclxuICogdGhhbiB0aGF0LlxuICpcbiAqIFZhbHVlcyBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC5rZXlDb2RlI1ZhbHVlX29mX2tleUNvZGVcbiAqL1xudmFyIEtFWV9DT0RFID0ge1xuICA4OiAnYmFja3NwYWNlJyxcbiAgOTogJ3RhYicsXG4gIDEzOiAnZW50ZXInLFxuICAyNzogJ2VzYycsXG4gIDMzOiAncGFnZXVwJyxcbiAgMzQ6ICdwYWdlZG93bicsXG4gIDM1OiAnZW5kJyxcbiAgMzY6ICdob21lJyxcbiAgMzI6ICdzcGFjZScsXG4gIDM3OiAnbGVmdCcsXG4gIDM4OiAndXAnLFxuICAzOTogJ3JpZ2h0JyxcbiAgNDA6ICdkb3duJyxcbiAgNDY6ICdkZWwnLFxuICAxMDY6ICcqJ1xufTtcblxuLyoqXG4gKiBNT0RJRklFUl9LRVlTIG1hcHMgdGhlIHNob3J0IG5hbWUgZm9yIG1vZGlmaWVyIGtleXMgdXNlZCBpbiBhIGtleVxuICogY29tYm8gc3RyaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIHRoYXQgcmVmZXJlbmNlcyB0aG9zZSBzYW1lIGtleXNcbiAqIGluIGEgS2V5Ym9hcmRFdmVudCBpbnN0YW5jZS5cbiAqL1xudmFyIE1PRElGSUVSX0tFWVMgPSB7XG4gICdzaGlmdCc6ICdzaGlmdEtleScsXG4gICdjdHJsJzogJ2N0cmxLZXknLFxuICAnYWx0JzogJ2FsdEtleScsXG4gICdtZXRhJzogJ21ldGFLZXknXG59O1xuXG4vKipcbiAqIEtleWJvYXJkRXZlbnQua2V5IGlzIG1vc3RseSByZXByZXNlbnRlZCBieSBwcmludGFibGUgY2hhcmFjdGVyIG1hZGUgYnlcbiAqIHRoZSBrZXlib2FyZCwgd2l0aCB1bnByaW50YWJsZSBrZXlzIGxhYmVsZWQgbmljZWx5LlxuICpcbiAqIEhvd2V2ZXIsIG9uIE9TIFgsIEFsdCtjaGFyIGNhbiBtYWtlIGEgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBmb2xsb3dzIGFuXG4gKiBBcHBsZS1zcGVjaWZpYyBtYXBwaW5nLiBJbiB0aGlzIGNhc2UsIHdlIGZhbGwgYmFjayB0byAua2V5Q29kZS5cbiAqL1xudmFyIEtFWV9DSEFSID0gL1thLXowLTkqXS87XG5cbi8qKlxuICogTWF0Y2hlcyBhIGtleUlkZW50aWZpZXIgc3RyaW5nLlxuICovXG52YXIgSURFTlRfQ0hBUiA9IC9VXFwrLztcblxuLyoqXG4gKiBNYXRjaGVzIGFycm93IGtleXMgaW4gR2Vja28gMjcuMCtcbiAqL1xudmFyIEFSUk9XX0tFWSA9IC9eYXJyb3cvO1xuXG4vKipcbiAqIE1hdGNoZXMgc3BhY2Uga2V5cyBldmVyeXdoZXJlIChub3RhYmx5IGluY2x1ZGluZyBJRTEwJ3MgZXhjZXB0aW9uYWwgbmFtZVxuICogYHNwYWNlYmFyYCkuXG4gKi9cbnZhciBTUEFDRV9LRVkgPSAvXnNwYWNlKGJhcik/LztcblxuLyoqXG4gKiBNYXRjaGVzIEVTQyBrZXkuXG4gKlxuICogVmFsdWUgZnJvbTogaHR0cDovL3czYy5naXRodWIuaW8vdWlldmVudHMta2V5LyNrZXktRXNjYXBlXG4gKi9cbnZhciBFU0NfS0VZID0gL15lc2NhcGUkLztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBLZXlCb2FyZEV2ZW50LmtleVxuICogQHBhcmFtIHtCb29sZWFufSBbbm9TcGVjaWFsQ2hhcnNdIExpbWl0cyB0aGUgdHJhbnNmb3JtYXRpb24gdG9cbiAqIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtS2V5KGtleSwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChrZXkpIHtcbiAgICB2YXIgbEtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsS2V5ID09PSAnICcgfHwgU1BBQ0VfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgIHZhbGlkS2V5ID0gJ3NwYWNlJztcbiAgICB9IGVsc2UgaWYgKEVTQ19LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSAnZXNjJztcbiAgICB9IGVsc2UgaWYgKGxLZXkubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmICghbm9TcGVjaWFsQ2hhcnMgfHwgS0VZX0NIQVIudGVzdChsS2V5KSkge1xuICAgICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBUlJPV19LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSBsS2V5LnJlcGxhY2UoJ2Fycm93JywgJycpO1xuICAgIH0gZWxzZSBpZiAobEtleSA9PSAnbXVsdGlwbHknKSB7XG4gICAgICAvLyBudW1wYWQgJyonIGNhbiBtYXAgdG8gTXVsdGlwbHkgb24gSUUvV2luZG93c1xuICAgICAgdmFsaWRLZXkgPSAnKic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkS2V5O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUlkZW50KSB7XG4gIHZhciB2YWxpZEtleSA9ICcnO1xuICBpZiAoa2V5SWRlbnQpIHtcbiAgICBpZiAoa2V5SWRlbnQgaW4gS0VZX0lERU5USUZJRVIpIHtcbiAgICAgIHZhbGlkS2V5ID0gS0VZX0lERU5USUZJRVJba2V5SWRlbnRdO1xuICAgIH0gZWxzZSBpZiAoSURFTlRfQ0hBUi50ZXN0KGtleUlkZW50KSkge1xuICAgICAga2V5SWRlbnQgPSBwYXJzZUludChrZXlJZGVudC5yZXBsYWNlKCdVKycsICcweCcpLCAxNik7XG4gICAgICB2YWxpZEtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5SWRlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0ga2V5SWRlbnQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkS2V5O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXlDb2RlKGtleUNvZGUpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChOdW1iZXIoa2V5Q29kZSkpIHtcbiAgICBpZiAoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKSB7XG4gICAgICAvLyBhc2NpaSBhLXpcbiAgICAgIC8vIGxvd2VyY2FzZSBpcyAzMiBvZmZzZXQgZnJvbSB1cHBlcmNhc2VcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGtleUNvZGUpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSAxMTIgJiYga2V5Q29kZSA8PSAxMjMpIHtcbiAgICAgIC8vIGZ1bmN0aW9uIGtleXMgZjEtZjEyXG4gICAgICB2YWxpZEtleSA9ICdmJyArIChrZXlDb2RlIC0gMTEyICsgMSk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpIHtcbiAgICAgIC8vIHRvcCAwLTkga2V5c1xuICAgICAgdmFsaWRLZXkgPSBTdHJpbmcoa2V5Q29kZSAtIDQ4KTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gOTYgJiYga2V5Q29kZSA8PSAxMDUpIHtcbiAgICAgIC8vIG51bSBwYWQgMC05XG4gICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gOTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZEtleSA9IEtFWV9DT0RFW2tleUNvZGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsaWRLZXk7XG59XG5cbi8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIG5vcm1hbGl6ZWQga2V5IGZvciBhIEtleWJvYXJkRXZlbnQuXG4gICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBrZXlFdmVudFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBTZXQgdG8gdHJ1ZSB0byBsaW1pdCBrZXlFdmVudC5rZXlcbiAgKiB0cmFuc2Zvcm1hdGlvbiB0byBhbHBoYS1udW1lcmljIGNoYXJzLiBUaGlzIGlzIHVzZWZ1bCB3aXRoIGtleVxuICAqIGNvbWJpbmF0aW9ucyBsaWtlIHNoaWZ0ICsgMiwgd2hpY2ggb24gRkYgZm9yIE1hY09TIHByb2R1Y2VzXG4gICoga2V5RXZlbnQua2V5ID0gQFxuICAqIFRvIGdldCAyIHJldHVybmVkLCBzZXQgbm9TcGVjaWFsQ2hhcnMgPSB0cnVlXG4gICogVG8gZ2V0IEAgcmV0dXJuZWQsIHNldCBub1NwZWNpYWxDaGFycyA9IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRLZXlGb3JFdmVudChrZXlFdmVudCwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgLy8gRmFsbCBiYWNrIGZyb20gLmtleSwgdG8gLmRldGFpbC5rZXkgZm9yIGFydGlmaWNhbCBrZXlib2FyZCBldmVudHMsXG4gIC8vIGFuZCB0aGVuIHRvIGRlcHJlY2F0ZWQgLmtleUlkZW50aWZpZXIgYW5kIC5rZXlDb2RlLlxuICBpZiAoa2V5RXZlbnQua2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUtleShrZXlFdmVudC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgfVxuICBpZiAoa2V5RXZlbnQuZGV0YWlsICYmIGtleUV2ZW50LmRldGFpbC5rZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmRldGFpbC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtS2V5SWRlbnRpZmllcihrZXlFdmVudC5rZXlJZGVudGlmaWVyKSB8fFxuICAgIHRyYW5zZm9ybUtleUNvZGUoa2V5RXZlbnQua2V5Q29kZSkgfHwgJyc7XG59XG5cbmZ1bmN0aW9uIGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkge1xuICAvLyBGb3IgY29tYm9zIHdpdGggbW9kaWZpZXJzIHdlIHN1cHBvcnQgb25seSBhbHBoYS1udW1lcmljIGtleXNcbiAgdmFyIGtleUV2ZW50ID0gbm9ybWFsaXplZEtleUZvckV2ZW50KGV2ZW50LCBrZXlDb21iby5oYXNNb2RpZmllcnMpO1xuICByZXR1cm4ga2V5RXZlbnQgPT09IGtleUNvbWJvLmtleSAmJlxuICAgICgha2V5Q29tYm8uaGFzTW9kaWZpZXJzIHx8IChcbiAgICAgICEhZXZlbnQuc2hpZnRLZXkgPT09ICEha2V5Q29tYm8uc2hpZnRLZXkgJiZcbiAgICAgICEhZXZlbnQuY3RybEtleSA9PT0gISFrZXlDb21iby5jdHJsS2V5ICYmXG4gICAgICAhIWV2ZW50LmFsdEtleSA9PT0gISFrZXlDb21iby5hbHRLZXkgJiZcbiAgICAgICEhZXZlbnQubWV0YUtleSA9PT0gISFrZXlDb21iby5tZXRhS2V5KVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpIHtcbiAgaWYgKGtleUNvbWJvU3RyaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcsXG4gICAgICBrZXk6IGtleUNvbWJvU3RyaW5nLFxuICAgICAgZXZlbnQ6ICdrZXlkb3duJ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGtleUNvbWJvU3RyaW5nLnNwbGl0KCcrJykucmVkdWNlKGZ1bmN0aW9uKHBhcnNlZEtleUNvbWJvLCBrZXlDb21ib1BhcnQpIHtcbiAgICB2YXIgZXZlbnRQYXJ0cyA9IGtleUNvbWJvUGFydC5zcGxpdCgnOicpO1xuICAgIHZhciBrZXlOYW1lID0gZXZlbnRQYXJ0c1swXTtcbiAgICB2YXIgZXZlbnQgPSBldmVudFBhcnRzWzFdO1xuXG4gICAgaWYgKGtleU5hbWUgaW4gTU9ESUZJRVJfS0VZUykge1xuICAgICAgcGFyc2VkS2V5Q29tYm9bTU9ESUZJRVJfS0VZU1trZXlOYW1lXV0gPSB0cnVlO1xuICAgICAgcGFyc2VkS2V5Q29tYm8uaGFzTW9kaWZpZXJzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkS2V5Q29tYm8ua2V5ID0ga2V5TmFtZTtcbiAgICAgIHBhcnNlZEtleUNvbWJvLmV2ZW50ID0gZXZlbnQgfHwgJ2tleWRvd24nO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRLZXlDb21ibztcbiAgfSwge1xuICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZy5zcGxpdCgnOicpLnNoaWZ0KClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpIHtcbiAgcmV0dXJuIGV2ZW50U3RyaW5nLnRyaW0oKS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihrZXlDb21ib1N0cmluZykge1xuICAgIHJldHVybiBwYXJzZUtleUNvbWJvU3RyaW5nKGtleUNvbWJvU3RyaW5nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBJcm9uQTExeUtleXNCZWhhdmlvciA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBFdmVudFRhcmdldCB0aGF0IHdpbGwgYmUgZmlyaW5nIHJlbGV2YW50IEtleWJvYXJkRXZlbnRzLiBTZXQgaXQgdG9cbiAgICAgKiBgbnVsbGAgdG8gZGlzYWJsZSB0aGUgbGlzdGVuZXJzLlxuICAgICAqIEB0eXBlIHs/RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAga2V5RXZlbnRUYXJnZXQ6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoaXMgcHJvcGVydHkgd2lsbCBjYXVzZSB0aGUgaW1wbGVtZW50aW5nIGVsZW1lbnQgdG9cbiAgICAgKiBhdXRvbWF0aWNhbGx5IHN0b3AgcHJvcGFnYXRpb24gb24gYW55IGhhbmRsZWQgS2V5Ym9hcmRFdmVudHMuXG4gICAgICovXG4gICAgc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBfYm91bmRLZXlIYW5kbGVyczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2UgdXNlIHRoaXMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBJRTEwIHdoZXJlIGluc3RhbmNlcyB3aWxsIGhhdmVcbiAgICAvLyBvd24gcHJvcGVydGllcyBvZiBldmVyeXRoaW5nIG9uIHRoZSBcInByb3RvdHlwZVwiLlxuICAgIF9pbXBlcmF0aXZlS2V5QmluZGluZ3M6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoa2V5RXZlbnRUYXJnZXQsIF9ib3VuZEtleUhhbmRsZXJzKSdcbiAgXSxcblxuXG4gIC8qKlxuICAgKiBUbyBiZSB1c2VkIHRvIGV4cHJlc3Mgd2hhdCBjb21iaW5hdGlvbiBvZiBrZXlzICB3aWxsIHRyaWdnZXIgdGhlIHJlbGF0aXZlXG4gICAqIGNhbGxiYWNrLiBlLmcuIGBrZXlCaW5kaW5nczogeyAnZXNjJzogJ19vbkVzY1ByZXNzZWQnfWBcbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqL1xuICBrZXlCaW5kaW5nczoge30sXG5cbiAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gaW1wZXJhdGl2ZWx5IGFkZCBhIGtleSBiaW5kaW5nIHRvIHRoZSBpbXBsZW1lbnRpbmdcbiAgICogZWxlbWVudC4gVGhpcyBpcyB0aGUgaW1wZXJhdGl2ZSBlcXVpdmFsZW50IG9mIGRlY2xhcmluZyBhIGtleWJpbmRpbmdcbiAgICogaW4gdGhlIGBrZXlCaW5kaW5nc2AgcHJvdG90eXBlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRTdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAqL1xuICBhZGRPd25LZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddID0gaGFuZGxlck5hbWU7XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIGNhbGxlZCwgd2lsbCByZW1vdmUgYWxsIGltcGVyYXRpdmVseS1hZGRlZCBrZXkgYmluZGluZ3MuXG4gICAqL1xuICByZW1vdmVPd25LZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzID0ge307XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBrZXlib2FyZCBldmVudCBtYXRjaGVzIGBldmVudFN0cmluZ2AuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50U3RyaW5nXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBrZXlib2FyZEV2ZW50TWF0Y2hlc0tleXM6IGZ1bmN0aW9uKGV2ZW50LCBldmVudFN0cmluZykge1xuICAgIHZhciBrZXlDb21ib3MgPSBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbWJvcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvc1tpXSwgZXZlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgX2NvbGxlY3RLZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleUJpbmRpbmdzID0gdGhpcy5iZWhhdmlvcnMubWFwKGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICByZXR1cm4gYmVoYXZpb3Iua2V5QmluZGluZ3M7XG4gICAgfSk7XG5cbiAgICBpZiAoa2V5QmluZGluZ3MuaW5kZXhPZih0aGlzLmtleUJpbmRpbmdzKSA9PT0gLTEpIHtcbiAgICAgIGtleUJpbmRpbmdzLnB1c2godGhpcy5rZXlCaW5kaW5ncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUJpbmRpbmdzO1xuICB9LFxuXG4gIF9wcmVwS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2tleUJpbmRpbmdzID0ge307XG5cbiAgICB0aGlzLl9jb2xsZWN0S2V5QmluZGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUJpbmRpbmdzKSB7XG4gICAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiBrZXlCaW5kaW5ncykge1xuICAgICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCBrZXlCaW5kaW5nc1tldmVudFN0cmluZ10pO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4gdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzKSB7XG4gICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICB9XG5cbiAgICAvLyBHaXZlIHByZWNlZGVuY2UgdG8gY29tYm9zIHdpdGggbW9kaWZpZXJzIHRvIGJlIGNoZWNrZWQgZmlyc3QuXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMuX2tleUJpbmRpbmdzKSB7XG4gICAgICB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdLnNvcnQoZnVuY3Rpb24gKGtiMSwga2IyKSB7XG4gICAgICAgIHZhciBiMSA9IGtiMVswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgIHZhciBiMiA9IGtiMlswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgIHJldHVybiAoYjEgPT09IGIyKSA/IDAgOiBiMSA/IC0xIDogMTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIF9hZGRLZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUNvbWJvKSB7XG4gICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gPVxuICAgICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gfHwgW107XG5cbiAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XS5wdXNoKFtcbiAgICAgICAga2V5Q29tYm8sXG4gICAgICAgIGhhbmRsZXJOYW1lXG4gICAgICBdKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfcmVzZXRLZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuXG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH0sXG5cbiAgX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMua2V5RXZlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5fa2V5QmluZGluZ3MpLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdO1xuICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlciA9IHRoaXMuX29uS2V5QmluZGluZ0V2ZW50LmJpbmQodGhpcywga2V5QmluZGluZ3MpO1xuXG4gICAgICB0aGlzLl9ib3VuZEtleUhhbmRsZXJzLnB1c2goW3RoaXMua2V5RXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyXSk7XG5cbiAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlIYW5kbGVyVHVwbGU7XG4gICAgdmFyIGtleUV2ZW50VGFyZ2V0O1xuICAgIHZhciBldmVudE5hbWU7XG4gICAgdmFyIGJvdW5kS2V5SGFuZGxlcjtcblxuICAgIHdoaWxlICh0aGlzLl9ib3VuZEtleUhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgLy8gTXkga2luZ2RvbSBmb3IgYmxvY2stc2NvcGUgYmluZGluZyBhbmQgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50Li5cbiAgICAgIGtleUhhbmRsZXJUdXBsZSA9IHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucG9wKCk7XG4gICAgICBrZXlFdmVudFRhcmdldCA9IGtleUhhbmRsZXJUdXBsZVswXTtcbiAgICAgIGV2ZW50TmFtZSA9IGtleUhhbmRsZXJUdXBsZVsxXTtcbiAgICAgIGJvdW5kS2V5SGFuZGxlciA9IGtleUhhbmRsZXJUdXBsZVsyXTtcblxuICAgICAga2V5RXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgfVxuICB9LFxuXG4gIF9vbktleUJpbmRpbmdFdmVudDogZnVuY3Rpb24oa2V5QmluZGluZ3MsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgZXZlbnQgaGFzIGJlZW4gYWxyZWFkeSBwcmV2ZW50ZWQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5Q29tYm8gPSBrZXlCaW5kaW5nc1tpXVswXTtcbiAgICAgIHZhciBoYW5kbGVyTmFtZSA9IGtleUJpbmRpbmdzW2ldWzFdO1xuICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcktleUhhbmRsZXIoa2V5Q29tYm8sIGhhbmRsZXJOYW1lLCBldmVudCk7XG4gICAgICAgIC8vIGV4aXQgdGhlIGxvb3AgaWYgZXZlbnREZWZhdWx0IHdhcyBwcmV2ZW50ZWRcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX3RyaWdnZXJLZXlIYW5kbGVyOiBmdW5jdGlvbihrZXlDb21ibywgaGFuZGxlck5hbWUsIGtleWJvYXJkRXZlbnQpIHtcbiAgICB2YXIgZGV0YWlsID0gT2JqZWN0LmNyZWF0ZShrZXlDb21ibyk7XG4gICAgZGV0YWlsLmtleWJvYXJkRXZlbnQgPSBrZXlib2FyZEV2ZW50O1xuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChrZXlDb21iby5ldmVudCwge1xuICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpc1toYW5kbGVyTmFtZV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQ29udHJvbFN0YXRlID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IGN1cnJlbnRseSBoYXMgZm9jdXMuXG4gICAgICovXG4gICAgZm9jdXNlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX2Rpc2FibGVkQ2hhbmdlZCcsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgX29sZFRhYkluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuXG4gICAgX2JvdW5kRm9jdXNCbHVySGFuZGxlcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c0JsdXJIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9faGFuZGxlRXZlbnRSZXRhcmdldGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNoYWRvd1Jvb3QgJiYgIUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfY2hhbmdlZENvbnRyb2xTdGF0ZShmb2N1c2VkLCBkaXNhYmxlZCknXG4gIF0sXG5cbiAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRm9jdXNCbHVySGFuZGxlciwgdHJ1ZSk7XG4gIH0sXG5cbiAgX2ZvY3VzQmx1ckhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gSW4gUG9seW1lciAyLjAsIHRoZSBsaWJyYXJ5IHRha2VzIGNhcmUgb2YgcmV0YXJnZXRpbmcgZXZlbnRzLlxuICAgIGlmIChFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGV2ZW50LnR5cGUgPT09ICdmb2N1cycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5PVEUoY2RhdGEpOiAgaWYgd2UgYXJlIGluIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsXG4gICAgLy8gZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZSB0byByZXRhcmdldGluZzsgaWYgd2UgYXJlIG5vdCBpblxuICAgIC8vIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWVcbiAgICAvLyB0byB0aGUgc2Vjb25kIGNvbmRpdGlvbmFsIHdoaWNoIGZpcmVzIGEgc3ludGhldGljIGV2ZW50ICh0aGF0IGlzIGFsc29cbiAgICAvLyBoYW5kbGVkKS4gSW4gZWl0aGVyIGNhc2UsIHdlIGNhbiBkaXNyZWdhcmQgYGV2ZW50LnBhdGhgLlxuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9faGFuZGxlRXZlbnRSZXRhcmdldGluZykge1xuICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8oZG9tKGV2ZW50KS5sb2NhbFRhcmdldCk7XG4gICAgICBpZiAoIXRoaXMuaXNMaWdodERlc2NlbmRhbnQodGFyZ2V0KSkge1xuICAgICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50LmJ1YmJsZXMsXG4gICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX2Rpc2FibGVkQ2hhbmdlZDogZnVuY3Rpb24oZGlzYWJsZWQsIG9sZCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB0aGlzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBkaXNhYmxlZCA/ICdub25lJyA6ICcnO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5fb2xkVGFiSW5kZXggPSB0aGlzLnRhYkluZGV4O1xuICAgICAgdGhpcy5fc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgICB0aGlzLnRhYkluZGV4ID0gLTE7XG4gICAgICB0aGlzLmJsdXIoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29sZFRhYkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGFiSW5kZXggPSB0aGlzLl9vbGRUYWJJbmRleDtcbiAgICB9XG4gIH0sXG5cbiAgX2NoYW5nZWRDb250cm9sU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIF9jb250cm9sU3RhdGVDaGFuZ2VkIGlzIGFic3RyYWN0LCBmb2xsb3ctb24gYmVoYXZpb3JzIG1heSBpbXBsZW1lbnQgaXRcbiAgICBpZiAodGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWJlaGF2aW9ycy9pcm9uLWNvbnRyb2wtc3RhdGUuanMiLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzM4NTcgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5leHBvcnQgdmFyIEVQU0c5MDA5MTMgPSBVdGlsLmV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzIiwiaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFByb2plY3Rpb25cclxuICogQHByb2plY3Rpb24gTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yXHJcbiAqXHJcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCB0aGUgbW9zdCBjb21tb24gcHJvamVjdGlvbiBmb3Igb25saW5lIG1hcHMsXHJcbiAqIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBBc3N1bWVzIHRoYXQgRWFydGggaXNcclxuICogYSBzcGhlcmUuIFVzZWQgYnkgdGhlIGBFUFNHOjM4NTdgIENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIFNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiA2Mzc4MTM3LFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdFx0dGhpcy5SICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHRcdCgyICogTWF0aC5hdGFuKE1hdGguZXhwKHBvaW50LnkgLyB0aGlzLlIpKSAtIChNYXRoLlBJIC8gMikpICogZCxcclxuXHRcdFx0cG9pbnQueCAqIGQgLyB0aGlzLlIpO1xyXG5cdH0sXHJcblxyXG5cdGJvdW5kczogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBkID0gNjM3ODEzNyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLy8gQG5hbWVzcGFjZSBTVkc7IEBzZWN0aW9uXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuU1ZHOlxuXG4vLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcbi8vIFJldHVybnMgYSBpbnN0YW5jZSBvZiBbU1ZHRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0VsZW1lbnQpLFxuLy8gY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZSBwYXNzZWQuIEZvciBleGFtcGxlLCB1c2luZyAnbGluZScgd2lsbCByZXR1cm5cbi8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cbmV4cG9ydCBmdW5jdGlvbiBzdmdDcmVhdGUobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vLyBAZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzOiBQb2ludFtdLCBjbG9zZWQ6IEJvb2xlYW4pOiBTdHJpbmdcbi8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcbi8vIGludG8gXCJNLi5MLi5MLi5cIiBpbnN0cnVjdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3MsIGNsb3NlZCkge1xuXHR2YXIgc3RyID0gJycsXG5cdGksIGosIGxlbiwgbGVuMiwgcG9pbnRzLCBwO1xuXG5cdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0cG9pbnRzID0gcmluZ3NbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdHN0ciArPSAoaiA/ICdMJyA6ICdNJykgKyBwLnggKyAnICcgKyBwLnk7XG5cdFx0fVxuXG5cdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdHN0ciArPSBjbG9zZWQgPyAoQnJvd3Nlci5zdmcgPyAneicgOiAneCcpIDogJyc7XG5cdH1cblxuXHQvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuXHRyZXR1cm4gc3RyIHx8ICdNMCAwJztcbn1cblxuXG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanMiLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxuXG52YXIgUE9JTlRFUl9ET1dOID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyAgIDogJ3BvaW50ZXJkb3duJyxcbiAgICBQT0lOVEVSX01PVkUgPSAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlck1vdmUnICAgOiAncG9pbnRlcm1vdmUnLFxuICAgIFBPSU5URVJfVVAgPSAgICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnLFxuICAgIFBPSU5URVJfQ0FOQ0VMID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyQ2FuY2VsJyA6ICdwb2ludGVyY2FuY2VsJyxcbiAgICBUQUdfV0hJVEVfTElTVCA9IFsnSU5QVVQnLCAnU0VMRUNUJywgJ09QVElPTiddLFxuXG4gICAgX3BvaW50ZXJzID0ge30sXG4gICAgX3BvaW50ZXJEb2NMaXN0ZW5lciA9IGZhbHNlO1xuXG4vLyBEb21FdmVudC5Eb3VibGVUYXAgbmVlZHMgdG8ga25vdyBhYm91dCB0aGlzXG5leHBvcnQgdmFyIF9wb2ludGVyc0NvdW50ID0gMDtcblxuLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuLy8gcmVmIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRfYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0X2FkZFBvaW50ZXJFbmQob2JqLCBoYW5kbGVyLCBpZCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKSB7XG5cdHZhciBoYW5kbGVyID0gb2JqWydfbGVhZmxldF8nICsgdHlwZSArIGlkXTtcblxuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBoYW5kbGVyLCBmYWxzZSk7XG5cblx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgaGFuZGxlciwgZmFsc2UpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyU3RhcnQob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25Eb3duID0gVXRpbC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSAmJiBlLnBvaW50ZXJUeXBlICE9PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFKSB7XG5cdFx0XHQvLyBJbiBJRTExLCBzb21lIHRvdWNoIGV2ZW50cyBuZWVkcyB0byBmaXJlIGZvciBmb3JtIGNvbnRyb2xzLCBvclxuXHRcdFx0Ly8gdGhlIGNvbnRyb2xzIHdpbGwgc3RvcCB3b3JraW5nLiBXZSBrZWVwIGEgd2hpdGVsaXN0IG9mIHRhZyBuYW1lcyB0aGF0XG5cdFx0XHQvLyBuZWVkIHRoZXNlIGV2ZW50cy4gRm9yIG90aGVyIHRhcmdldCB0YWdzLCB3ZSBwcmV2ZW50IGRlZmF1bHQgb24gdGhlIGV2ZW50LlxuXHRcdFx0aWYgKFRBR19XSElURV9MSVNULmluZGV4T2YoZS50YXJnZXQudGFnTmFtZSkgPCAwKSB7XG5cdFx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9KTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoc3RhcnQnICsgaWRdID0gb25Eb3duO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIG9uRG93biwgZmFsc2UpO1xuXG5cdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuXHRpZiAoIV9wb2ludGVyRG9jTGlzdGVuZXIpIHtcblx0XHQvLyB3ZSBsaXN0ZW4gZG9jdW1lbnRFbGVtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIF9nbG9iYWxQb2ludGVyTW92ZSwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgX2dsb2JhbFBvaW50ZXJVcCwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJEb3duKGUpIHtcblx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdF9wb2ludGVyc0NvdW50Kys7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyTW92ZShlKSB7XG5cdGlmIChfcG9pbnRlcnNbZS5wb2ludGVySWRdKSB7XG5cdFx0X3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2dsb2JhbFBvaW50ZXJVcChlKSB7XG5cdGRlbGV0ZSBfcG9pbnRlcnNbZS5wb2ludGVySWRdO1xuXHRfcG9pbnRlcnNDb3VudC0tO1xufVxuXG5mdW5jdGlvbiBfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKSB7XG5cdGUudG91Y2hlcyA9IFtdO1xuXHRmb3IgKHZhciBpIGluIF9wb2ludGVycykge1xuXHRcdGUudG91Y2hlcy5wdXNoKF9wb2ludGVyc1tpXSk7XG5cdH1cblx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcblxuXHRoYW5kbGVyKGUpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlck1vdmUob2JqLCBoYW5kbGVyLCBpZCkge1xuXHR2YXIgb25Nb3ZlID0gZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBkb24ndCBmaXJlIHRvdWNoIG1vdmVzIHdoZW4gbW91c2UgaXNuJ3QgZG93blxuXHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiBlLmJ1dHRvbnMgPT09IDApIHsgcmV0dXJuOyB9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNobW92ZScgKyBpZF0gPSBvbk1vdmU7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgb25Nb3ZlLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uVXAgPSBmdW5jdGlvbiAoZSkge1xuXHRcdF9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHR9O1xuXG5cdG9ialsnX2xlYWZsZXRfdG91Y2hlbmQnICsgaWRdID0gb25VcDtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9VUCwgb25VcCwgZmFsc2UpO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0NBTkNFTCwgb25VcCwgZmFsc2UpO1xufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcblxuXG4vKlxuICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICogZngucnVuKGVsLCBbMzAwLCA1MDBdLCAwLjUpO1xuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gKlxuICovXG5cbmV4cG9ydCB2YXIgUG9zQW5pbWF0aW9uID0gRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIEBtZXRob2QgcnVuKGVsOiBIVE1MRWxlbWVudCwgbmV3UG9zOiBQb2ludCwgZHVyYXRpb24/OiBOdW1iZXIsIGVhc2VMaW5lYXJpdHk/OiBOdW1iZXIpXG5cdC8vIFJ1biBhbiBhbmltYXRpb24gb2YgYSBnaXZlbiBlbGVtZW50IHRvIGEgbmV3IHBvc2l0aW9uLCBvcHRpb25hbGx5IHNldHRpbmdcblx0Ly8gZHVyYXRpb24gaW4gc2Vjb25kcyAoYDAuMjVgIGJ5IGRlZmF1bHQpIGFuZCBlYXNpbmcgbGluZWFyaXR5IGZhY3RvciAoM3JkXG5cdC8vIGFyZ3VtZW50IG9mIHRoZSBbY3ViaWMgYmV6aWVyIGN1cnZlXShodHRwOi8vY3ViaWMtYmV6aWVyLmNvbS8jMCwwLC41LDEpLFxuXHQvLyBgMC41YCBieSBkZWZhdWx0KS5cblx0cnVuOiBmdW5jdGlvbiAoZWwsIG5ld1BvcywgZHVyYXRpb24sIGVhc2VMaW5lYXJpdHkpIHtcblx0XHR0aGlzLnN0b3AoKTtcblxuXHRcdHRoaXMuX2VsID0gZWw7XG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwLjI1O1xuXHRcdHRoaXMuX2Vhc2VPdXRQb3dlciA9IDEgLyBNYXRoLm1heChlYXNlTGluZWFyaXR5IHx8IDAuNSwgMC4yKTtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihlbCk7XG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblxuXHRcdC8vIEBldmVudCBzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xuXG5cdFx0dGhpcy5fYW5pbWF0ZSgpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc3RvcCgpXG5cdC8vIFN0b3BzIHRoZSBhbmltYXRpb24gKGlmIGN1cnJlbnRseSBydW5uaW5nKS5cblx0c3RvcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3N0ZXAodHJ1ZSk7XG5cdFx0dGhpcy5fY29tcGxldGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFuaW1hdGlvbiBsb29wXG5cdFx0dGhpcy5fYW5pbUlkID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKHJvdW5kKSB7XG5cdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRpZiAocm91bmQpIHtcblx0XHRcdHBvcy5fcm91bmQoKTtcblx0XHR9XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgcG9zKTtcblxuXHRcdC8vIEBldmVudCBzdGVwOiBFdmVudFxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgdGhlIGFuaW1hdGlvbi5cblx0XHR0aGlzLmZpcmUoJ3N0ZXAnKTtcblx0fSxcblxuXHRfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltSWQpO1xuXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdC8vIEBldmVudCBlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcblx0fSxcblxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcblx0XHRyZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCB0aGlzLl9lYXNlT3V0UG93ZXIpO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZG9tL1Bvc0FuaW1hdGlvbi5qcyIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRJY29uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgSWNvbi5EZWZhdWx0YCB3aWxsIHRyeSB0byBhdXRvLWRldGVjdCB0aGUgYWJzb2x1dGUgbG9jYXRpb24gb2YgdGhlXG5cdFx0Ly8gYmx1ZSBpY29uIGltYWdlcy4gSWYgeW91IGFyZSBwbGFjaW5nIHRoZXNlIGltYWdlcyBpbiBhIG5vbi1zdGFuZGFyZFxuXHRcdC8vIHdheSwgc2V0IHRoaXMgb3B0aW9uIHRvIHBvaW50IHRvIHRoZSByaWdodCBhYnNvbHV0ZSBwYXRoLlxuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLmltYWdlUGF0aCB8fCBJY29uRGVmYXVsdC5pbWFnZVBhdGgpICsgSWNvbi5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLCBuYW1lKTtcblx0fSxcblxuXHRfZGV0ZWN0SWNvblBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZC1pbWFnZScpIHx8XG5cdFx0ICAgICAgICAgICBEb21VdGlsLmdldFN0eWxlKGVsLCAnYmFja2dyb3VuZEltYWdlJyk7XHQvLyBJRThcblxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG5cdFx0aWYgKHBhdGggPT09IG51bGwgfHwgcGF0aC5pbmRleE9mKCd1cmwnKSAhPT0gMCkge1xuXHRcdFx0cGF0aCA9ICcnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC9edXJsXFwoW1xcXCJcXCddPy8sICcnKS5yZXBsYWNlKC9tYXJrZXItaWNvblxcLnBuZ1tcXFwiXFwnXT9cXCkkLywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0ljb24uRGVmYXVsdC5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRhcCc7XG5NYXAuVGFwID0gVGFwO1xuaW1wb3J0IHtUb3VjaFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuVG91Y2hab29tJztcbk1hcC5Ub3VjaFpvb20gPSBUb3VjaFpvb207XG5cbmV4cG9ydCB7TWFwLCBjcmVhdGVNYXAgYXMgbWFwfSBmcm9tICcuL01hcCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9pbmRleC5qcyIsIlxyXG5pbXBvcnQge0NvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQXR0cmlidXRpb24gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcHJlZml4OiBTdHJpbmcgPSAnTGVhZmxldCdcclxuXHRcdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdFx0cHJlZml4OiAnPGEgaHJlZj1cImh0dHA6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPidcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9ucyA9IHt9O1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcblx0XHREb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdC8vIFRPRE8gdWdseSwgcmVmYWN0b3JcclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQcmVmaXgocHJlZml4OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdGV4dCBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy5cclxuXHRzZXRQcmVmaXg6IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wcmVmaXggPSBwcmVmaXg7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gYXR0cmlidXRpb24gdGV4dCAoZS5nLiBgJ1ZlY3RvciBkYXRhICZjb3B5OyBNYXBib3gnYCkuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0gPSAwO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdKys7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0LlxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSkge1xyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0tLTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xyXG5cdFx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW2ldKSB7XHJcblx0XHRcdFx0YXR0cmlicy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWZpeEFuZEF0dHJpYnMgPSBbXTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnByZWZpeCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XHJcblx0XHR9XHJcblx0XHRpZiAoYXR0cmlicy5sZW5ndGgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKGF0dHJpYnMuam9pbignLCAnKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IHByZWZpeEFuZEF0dHJpYnMuam9pbignIHwgJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIENvbnRyb2wgb3B0aW9uc1xyXG4vLyBAb3B0aW9uIGF0dHJpYnV0aW9uQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFthdHRyaWJ1dGlvbiBjb250cm9sXSgjY29udHJvbC1hdHRyaWJ1dGlvbikgaXMgYWRkZWQgdG8gdGhlIG1hcCBieSBkZWZhdWx0LlxyXG5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHRhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB7XHJcblx0XHRuZXcgQXR0cmlidXRpb24oKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDb250cm9sLkF0dHJpYnV0aW9uXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5hdHRyaWJ1dGlvbihvcHRpb25zOiBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbC5cclxuZXhwb3J0IHZhciBhdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuQXR0cmlidXRpb24uanMiLCJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvaW5kZXguanMiLCJleHBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmV4cG9ydCB7TGF5ZXJHcm91cCwgbGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcbmV4cG9ydCB7RmVhdHVyZUdyb3VwLCBmZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbiwgZ2VvbWV0cnlUb0xheWVyLCBjb29yZHNUb0xhdExuZywgY29vcmRzVG9MYXRMbmdzLCBsYXRMbmdUb0Nvb3JkcywgbGF0TG5nc1RvQ29vcmRzLCBnZXRGZWF0dXJlLCBhc0ZlYXR1cmV9IGZyb20gJy4vR2VvSlNPTic7XG5HZW9KU09OLmdlb21ldHJ5VG9MYXllciA9IGdlb21ldHJ5VG9MYXllcjtcbkdlb0pTT04uY29vcmRzVG9MYXRMbmcgPSBjb29yZHNUb0xhdExuZztcbkdlb0pTT04uY29vcmRzVG9MYXRMbmdzID0gY29vcmRzVG9MYXRMbmdzO1xuR2VvSlNPTi5sYXRMbmdUb0Nvb3JkcyA9IGxhdExuZ1RvQ29vcmRzO1xuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHMgPSBsYXRMbmdzVG9Db29yZHM7XG5HZW9KU09OLmdldEZlYXR1cmUgPSBnZXRGZWF0dXJlO1xuR2VvSlNPTi5hc0ZlYXR1cmUgPSBhc0ZlYXR1cmU7XG5leHBvcnQge0dlb0pTT04sIGdlb0pTT04sIGdlb0pzb259O1xuXG5leHBvcnQge0ltYWdlT3ZlcmxheSwgaW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5leHBvcnQge1ZpZGVvT3ZlcmxheSwgdmlkZW9PdmVybGF5fSBmcm9tICcuL1ZpZGVvT3ZlcmxheSc7XG5cbmV4cG9ydCB7RGl2T3ZlcmxheX0gZnJvbSAnLi9EaXZPdmVybGF5JztcbmV4cG9ydCB7UG9wdXAsIHBvcHVwfSBmcm9tICcuL1BvcHVwJztcbmV4cG9ydCB7VG9vbHRpcCwgdG9vbHRpcH0gZnJvbSAnLi9Ub29sdGlwJztcblxuZXhwb3J0ICogZnJvbSAnLi9tYXJrZXIvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi90aWxlL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdmVjdG9yL2luZGV4JztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvaW5kZXguanMiLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5cbi8qXG4gKiBAY2xhc3MgR3JpZExheWVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5HcmlkTGF5ZXJcbiAqXG4gKiBHZW5lcmljIGNsYXNzIGZvciBoYW5kbGluZyBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cy4gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHRpbGUgbGF5ZXJzIGFuZCByZXBsYWNlcyBgVGlsZUxheWVyLkNhbnZhc2AuXG4gKiBHcmlkTGF5ZXIgY2FuIGJlIGV4dGVuZGVkIHRvIGNyZWF0ZSBhIHRpbGVkIGdyaWQgb2YgSFRNTCBlbGVtZW50cyBsaWtlIGA8Y2FudmFzPmAsIGA8aW1nPmAgb3IgYDxkaXY+YC4gR3JpZExheWVyIHdpbGwgaGFuZGxlIGNyZWF0aW5nIGFuZCBhbmltYXRpbmcgdGhlc2UgRE9NIGVsZW1lbnRzIGZvciB5b3UuXG4gKlxuICpcbiAqIEBzZWN0aW9uIFN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBsYXllciwgZXh0ZW5kIEdyaWRMYXllciBhbmQgaW1wbGVtZW50IHRoZSBgY3JlYXRlVGlsZSgpYCBtZXRob2QsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGEgYFBvaW50YCBvYmplY3Qgd2l0aCB0aGUgYHhgLCBgeWAsIGFuZCBgemAgKHpvb20gbGV2ZWwpIGNvb3JkaW5hdGVzIHRvIGRyYXcgeW91ciB0aWxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3Jkcyl7XG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGdldCBhIGNhbnZhcyBjb250ZXh0IGFuZCBkcmF3IHNvbWV0aGluZyBvbiBpdCB1c2luZyBjb29yZHMueCwgY29vcmRzLnkgYW5kIGNvb3Jkcy56XG4gKiAgICAgICAgIHZhciBjdHggPSB0aWxlLmdldENvbnRleHQoJzJkJyk7XG4gKlxuICogICAgICAgICAvLyByZXR1cm4gdGhlIHRpbGUgc28gaXQgY2FuIGJlIHJlbmRlcmVkIG9uIHNjcmVlblxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uIEFzeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUaWxlIGNyZWF0aW9uIGNhbiBhbHNvIGJlIGFzeW5jaHJvbm91cywgdGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBhIHRoaXJkLXBhcnR5IGRyYXdpbmcgbGlicmFyeS4gT25jZSB0aGUgdGlsZSBpcyBmaW5pc2hlZCBkcmF3aW5nIGl0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGBkb25lKClgIGNhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgQ2FudmFzTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xuICogICAgIGNyZWF0ZVRpbGU6IGZ1bmN0aW9uKGNvb3JkcywgZG9uZSl7XG4gKiAgICAgICAgIHZhciBlcnJvcjtcbiAqXG4gKiAgICAgICAgIC8vIGNyZWF0ZSBhIDxjYW52YXM+IGVsZW1lbnQgZm9yIGRyYXdpbmdcbiAqICAgICAgICAgdmFyIHRpbGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdjYW52YXMnLCAnbGVhZmxldC10aWxlJyk7XG4gKlxuICogICAgICAgICAvLyBzZXR1cCB0aWxlIHdpZHRoIGFuZCBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXG4gKiAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuICogICAgICAgICB0aWxlLndpZHRoID0gc2l6ZS54O1xuICogICAgICAgICB0aWxlLmhlaWdodCA9IHNpemUueTtcbiAqXG4gKiAgICAgICAgIC8vIGRyYXcgc29tZXRoaW5nIGFzeW5jaHJvbm91c2x5IGFuZCBwYXNzIHRoZSB0aWxlIHRvIHRoZSBkb25lKCkgY2FsbGJhY2tcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGRvbmUoZXJyb3IsIHRpbGUpO1xuICogICAgICAgICB9LCAxMDAwKTtcbiAqXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb25cbiAqL1xuXG5cbmV4cG9ydCB2YXIgR3JpZExheWVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIEdyaWRMYXllciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRpbGVTaXplOiBOdW1iZXJ8UG9pbnQgPSAyNTZcblx0XHQvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRpbGVzIGluIHRoZSBncmlkLiBVc2UgYSBudW1iZXIgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZXF1YWwsIG9yIGBMLnBvaW50KHdpZHRoLCBoZWlnaHQpYCBvdGhlcndpc2UuXG5cdFx0dGlsZVNpemU6IDI1NixcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gT3BhY2l0eSBvZiB0aGUgdGlsZXMuIENhbiBiZSB1c2VkIGluIHRoZSBgY3JlYXRlVGlsZSgpYCBmdW5jdGlvbi5cblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuSWRsZTogQm9vbGVhbiA9IChkZXBlbmRzKVxuXHRcdC8vIExvYWQgbmV3IHRpbGVzIG9ubHkgd2hlbiBwYW5uaW5nIGVuZHMuXG5cdFx0Ly8gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBpbiBvcmRlciB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0cyBhbmQga2VlcCBzbW9vdGggbmF2aWdhdGlvbi5cblx0XHQvLyBgZmFsc2VgIG90aGVyd2lzZSBpbiBvcmRlciB0byBkaXNwbGF5IG5ldyB0aWxlcyBfZHVyaW5nXyBwYW5uaW5nLCBzaW5jZSBpdCBpcyBlYXN5IHRvIHBhbiBvdXRzaWRlIHRoZVxuXHRcdC8vIFtga2VlcEJ1ZmZlcmBdKCNncmlkbGF5ZXIta2VlcGJ1ZmZlcikgb3B0aW9uIGluIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0dXBkYXRlV2hlbklkbGU6IEJyb3dzZXIubW9iaWxlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVXaGVuWm9vbWluZzogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBCeSBkZWZhdWx0LCBhIHNtb290aCB6b29tIGFuaW1hdGlvbiAoZHVyaW5nIGEgW3RvdWNoIHpvb21dKCNtYXAtdG91Y2h6b29tKSBvciBhIFtgZmx5VG8oKWBdKCNtYXAtZmx5dG8pKSB3aWxsIHVwZGF0ZSBncmlkIGxheWVycyBldmVyeSBpbnRlZ2VyIHpvb20gbGV2ZWwuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB3aWxsIHVwZGF0ZSB0aGUgZ3JpZCBsYXllciBvbmx5IHdoZW4gdGhlIHNtb290aCBhbmltYXRpb24gZW5kcy5cblx0XHR1cGRhdGVXaGVuWm9vbWluZzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlSW50ZXJ2YWw6IE51bWJlciA9IDIwMFxuXHRcdC8vIFRpbGVzIHdpbGwgbm90IHVwZGF0ZSBtb3JlIHRoYW4gb25jZSBldmVyeSBgdXBkYXRlSW50ZXJ2YWxgIG1pbGxpc2Vjb25kcyB3aGVuIHBhbm5pbmcuXG5cdFx0dXBkYXRlSW50ZXJ2YWw6IDIwMCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZG93biB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1pblpvb206IDAsXG5cblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdXAgdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtYXhab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGhpZ2hlciB0aGFuIGBtYXhOYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1heE5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtYXhOYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG1pbk5hdGl2ZVpvb206IE51bWJlciA9IHVuZGVmaW5lZFxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcblx0XHQvLyB0aGUgdGlsZXMgb24gYWxsIHpvb20gbGV2ZWxzIGxvd2VyIHRoYW4gYG1pbk5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWluTmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1pbk5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbm9XcmFwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRoZSBsYXllciBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgYW50aW1lcmlkaWFuLiBJZiBgdHJ1ZWAsIHRoZVxuXHRcdC8vIEdyaWRMYXllciB3aWxsIG9ubHkgYmUgZGlzcGxheWVkIG9uY2UgYXQgbG93IHpvb20gbGV2ZWxzLiBIYXMgbm9cblx0XHQvLyBlZmZlY3Qgd2hlbiB0aGUgW21hcCBDUlNdKCNtYXAtY3JzKSBkb2Vzbid0IHdyYXAgYXJvdW5kLiBDYW4gYmUgdXNlZFxuXHRcdC8vIGluIGNvbWJpbmF0aW9uIHdpdGggW2Bib3VuZHNgXSgjZ3JpZGxheWVyLWJvdW5kcykgdG8gcHJldmVudCByZXF1ZXN0aW5nXG5cdFx0Ly8gdGlsZXMgb3V0c2lkZSB0aGUgQ1JTIGxpbWl0cy5cblx0XHRub1dyYXA6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndGlsZVBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgZ3JpZCBsYXllciB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0aWxlUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgdGlsZSBsYXllci4gRW1wdHkgYnkgZGVmYXVsdC5cblx0XHRjbGFzc05hbWU6ICcnLFxuXG5cdFx0Ly8gQG9wdGlvbiBrZWVwQnVmZmVyOiBOdW1iZXIgPSAyXG5cdFx0Ly8gV2hlbiBwYW5uaW5nIHRoZSBtYXAsIGtlZXAgdGhpcyBtYW55IHJvd3MgYW5kIGNvbHVtbnMgb2YgdGlsZXMgYmVmb3JlIHVubG9hZGluZyB0aGVtLlxuXHRcdGtlZXBCdWZmZXI6IDJcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRDb250YWluZXIoKTtcblxuXHRcdHRoaXMuX2xldmVscyA9IHt9O1xuXHRcdHRoaXMuX3RpbGVzID0ge307XG5cblx0XHR0aGlzLl9yZXNldFZpZXcoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuX2FkZFpvb21MaW1pdCh0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gbnVsbDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG5cdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG5cdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSBVdGlsLnRocm90dGxlKHRoaXMuX29uTW92ZUVuZCwgdGhpcy5vcHRpb25zLnVwZGF0ZUludGVydmFsLCB0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnRzLm1vdmUgPSB0aGlzLl9vbk1vdmU7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBMYXllcnMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgIHNoYWxsIHJlaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kLlxuXHQvLyBAbWV0aG9kIGNyZWF0ZVRpbGUoY29vcmRzOiBPYmplY3QsIGRvbmU/OiBGdW5jdGlvbik6IEhUTUxFbGVtZW50XG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG11c3QgYmUgb3ZlcnJpZGVuIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIGBHcmlkTGF5ZXJgLlxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGBjb29yZHNgLiBJZiB0aGUgYGRvbmVgIGNhbGxiYWNrXG5cdC8vIGlzIHNwZWNpZmllZCwgaXQgbXVzdCBiZSBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgZmluaXNoZWQgbG9hZGluZyBhbmQgZHJhd2luZy5cblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0fSxcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAbWV0aG9kIGdldFRpbGVTaXplOiBQb2ludFxuXHQvLyBOb3JtYWxpemVzIHRoZSBbdGlsZVNpemUgb3B0aW9uXSgjZ3JpZGxheWVyLXRpbGVzaXplKSBpbnRvIGEgcG9pbnQuIFVzZWQgYnkgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZC5cblx0Z2V0VGlsZVNpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcyA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcblx0XHRyZXR1cm4gcyBpbnN0YW5jZW9mIFBvaW50ID8gcyA6IG5ldyBQb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5KSB7IHJldHVybjsgfVxuXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLFxuXHRcdCAgICBuZXh0RnJhbWUgPSBmYWxzZSxcblx0XHQgICAgd2lsbFBydW5lID0gZmFsc2U7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICghdGlsZS5jdXJyZW50IHx8ICF0aWxlLmxvYWRlZCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHR2YXIgZmFkZSA9IE1hdGgubWluKDEsIChub3cgLSB0aWxlLmxvYWRlZCkgLyAyMDApO1xuXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHdpbGxQcnVuZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fb25PcGFxdWVUaWxlKHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BhcXVlVGlsZTogVXRpbC5mYWxzZUZuLFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllciAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVMZXZlbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXG5cdFx0ICAgIG1heFpvb20gPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTtcblxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0VXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfb25VcGRhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cblx0XHR0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cdH0sXG5cblx0X3JldGFpblBhcmVudDogZnVuY3Rpb24gKHgsIHksIHosIG1pblpvb20pIHtcblx0XHR2YXIgeDIgPSBNYXRoLmZsb29yKHggLyAyKSxcblx0XHQgICAgeTIgPSBNYXRoLmZsb29yKHkgLyAyKSxcblx0XHQgICAgejIgPSB6IC0gMSxcblx0XHQgICAgY29vcmRzMiA9IG5ldyBQb2ludCgreDIsICt5Mik7XG5cdFx0Y29vcmRzMi56ID0gK3oyO1xuXG5cdFx0dmFyIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMyKSxcblx0XHQgICAgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoejIgPiBtaW5ab29tKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmV0YWluUGFyZW50KHgyLCB5MiwgejIsIG1pblpvb20pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfcmV0YWluQ2hpbGRyZW46IGZ1bmN0aW9uICh4LCB5LCB6LCBtYXhab29tKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMiAqIHg7IGkgPCAyICogeCArIDI7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDIgKiB5OyBqIDwgMiAqIHkgKyAyOyBqKyspIHtcblxuXHRcdFx0XHR2YXIgY29vcmRzID0gbmV3IFBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG5cdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcblx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6ICsgMSA8IG1heFpvb20pIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcblx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuXHR9LFxuXG5cdF9jbGFtcFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1pbk5hdGl2ZVpvb20gJiYgem9vbSA8IG9wdGlvbnMubWluTmF0aXZlWm9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluTmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRpZiAodW5kZWZpbmVkICE9PSBvcHRpb25zLm1heE5hdGl2ZVpvb20gJiYgb3B0aW9ucy5tYXhOYXRpdmVab29tIDwgem9vbSkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gem9vbTtcblx0fSxcblxuXHRfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcblx0XHR2YXIgdGlsZVpvb20gPSB0aGlzLl9jbGFtcFpvb20oTWF0aC5yb3VuZCh6b29tKSk7XG5cdFx0aWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG5cdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG5cdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuXHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblxuXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuXHRcdFx0aWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbm9QcnVuZSkge1xuXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZsYWcgdG8gcHJldmVudCBfdXBkYXRlT3BhY2l0eSBmcm9tIHBydW5pbmcgdGlsZXMgZHVyaW5nXG5cdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcblx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybXM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgbGV2ZWwuem9vbSksXG5cdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuXHRcdGlmIChCcm93c2VyLmFueTNkKSB7XG5cdFx0XHREb21VdGlsLnNldFRyYW5zZm9ybShsZXZlbC5lbCwgdHJhbnNsYXRlLCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcblx0XHR9XG5cblx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0fSxcblxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShtYXBab29tLCB0aGlzLl90aWxlWm9vbSksXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcblx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhwaXhlbENlbnRlci5zdWJ0cmFjdChoYWxmU2l6ZSksIHBpeGVsQ2VudGVyLmFkZChoYWxmU2l6ZSkpO1xuXHR9LFxuXG5cdC8vIFByaXZhdGUgbWV0aG9kIHRvIGxvYWQgdGlsZXMgaW4gdGhlIGdyaWQncyBhY3RpdmUgem9vbSBsZXZlbCBhY2NvcmRpbmcgdG8gbWFwIGJvdW5kc1xuXHRfdXBkYXRlOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIW1hcCkgeyByZXR1cm47IH1cblx0XHR2YXIgem9vbSA9IHRoaXMuX2NsYW1wWm9vbShtYXAuZ2V0Wm9vbSgpKTtcblxuXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cblx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuXHRcdHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcblx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG5cdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG5cdFx0ICAgIHF1ZXVlID0gW10sXG5cdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgQm91bmRzKHRpbGVSYW5nZS5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW21hcmdpbiwgLW1hcmdpbl0pLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVSYW5nZS5nZXRUb3BSaWdodCgpLmFkZChbbWFyZ2luLCAtbWFyZ2luXSkpO1xuXG5cdFx0Ly8gU2FuaXR5IGNoZWNrOiBwYW5pYyBpZiB0aGUgdGlsZSByYW5nZSBjb250YWlucyBJbmZpbml0eSBzb21ld2hlcmUuXG5cdFx0aWYgKCEoaXNGaW5pdGUodGlsZVJhbmdlLm1pbi54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueSkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWF4LngpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC55KSkpIHsgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdGlsZXMnKTsgfVxuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuX3RpbGVzW2tleV0uY29vcmRzO1xuXHRcdFx0aWYgKGMueiAhPT0gdGhpcy5fdGlsZVpvb20gfHwgIW5vUHJ1bmVSYW5nZS5jb250YWlucyhuZXcgUG9pbnQoYy54LCBjLnkpKSkge1xuXHRcdFx0XHR0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG5cdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cblx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB0aGlzLl90aWxlWm9vbTtcblxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzVmFsaWRUaWxlKGNvb3JkcykpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuX3RpbGVzW3RoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpXSkge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goY29vcmRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgdGlsZSBxdWV1ZSB0byBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLmRpc3RhbmNlVG8odGlsZUNlbnRlcikgLSBiLmRpc3RhbmNlVG8odGlsZUNlbnRlcik7XG5cdFx0fSk7XG5cblx0XHRpZiAocXVldWUubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHQvLyBpZiBpdCdzIHRoZSBmaXJzdCBiYXRjaCBvZiB0aWxlcyB0byBsb2FkXG5cdFx0XHRpZiAoIXRoaXMuX2xvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fbG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdC8vIEBldmVudCBsb2FkaW5nOiBFdmVudFxuXHRcdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIHN0YXJ0cyBsb2FkaW5nIHRpbGVzLlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xvYWRpbmcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIERPTSBmcmFnbWVudCB0byBhcHBlbmQgdGlsZXMgaW4gb25lIGJhdGNoXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRUaWxlKHF1ZXVlW2ldLCBmcmFnbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xldmVsLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblx0XHR9XG5cdH0sXG5cblx0X2lzVmFsaWRUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIGNycyA9IHRoaXMuX21hcC5vcHRpb25zLmNycztcblxuXHRcdGlmICghY3JzLmluZmluaXRlKSB7XG5cdFx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQncyBvdXQgb2YgYm91bmRzIGFuZCBub3Qgd3JhcHBlZFxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZTtcblx0XHRcdGlmICgoIWNycy53cmFwTG5nICYmIChjb29yZHMueCA8IGJvdW5kcy5taW4ueCB8fCBjb29yZHMueCA+IGJvdW5kcy5tYXgueCkpIHx8XG5cdFx0XHQgICAgKCFjcnMud3JhcExhdCAmJiAoY29vcmRzLnkgPCBib3VuZHMubWluLnkgfHwgY29vcmRzLnkgPiBib3VuZHMubWF4LnkpKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5ib3VuZHMpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCBkb2Vzbid0IGludGVyc2VjdCB0aGUgYm91bmRzIGluIG9wdGlvbnNcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyhjb29yZHMpO1xuXHRcdHJldHVybiBsYXRMbmdCb3VuZHModGhpcy5vcHRpb25zLmJvdW5kcykub3ZlcmxhcHModGlsZUJvdW5kcyk7XG5cdH0sXG5cblx0X2tleVRvQm91bmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KSk7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjb29yZGluYXRlcyB0byBpdHMgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuXHRfdGlsZUNvb3Jkc1RvQm91bmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKSxcblxuXHRcdCAgICBud1BvaW50ID0gY29vcmRzLnNjYWxlQnkodGlsZVNpemUpLFxuXHRcdCAgICBzZVBvaW50ID0gbndQb2ludC5hZGQodGlsZVNpemUpLFxuXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMobncsIHNlKTtcblxuXHRcdGlmICghdGhpcy5vcHRpb25zLm5vV3JhcCkge1xuXHRcdFx0bWFwLndyYXBMYXRMbmdCb3VuZHMoYm91bmRzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8ga2V5IGZvciB0aGUgdGlsZSBjYWNoZVxuXHRfdGlsZUNvb3Jkc1RvS2V5OiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0cmV0dXJuIGNvb3Jkcy54ICsgJzonICsgY29vcmRzLnkgKyAnOicgKyBjb29yZHMuejtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNhY2hlIGtleSB0byBjb29yZGluYXRlc1xuXHRfa2V5VG9UaWxlQ29vcmRzOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGsgPSBrZXkuc3BsaXQoJzonKSxcblx0XHQgICAgY29vcmRzID0gbmV3IFBvaW50KCtrWzBdLCAra1sxXSk7XG5cdFx0Y29vcmRzLnogPSAra1syXTtcblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdERvbVV0aWwucmVtb3ZlKHRpbGUuZWwpO1xuXG5cdFx0ZGVsZXRlIHRoaXMuX3RpbGVzW2tleV07XG5cblx0XHQvLyBAZXZlbnQgdGlsZXVubG9hZDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVtb3ZlZCAoZS5nLiB3aGVuIGEgdGlsZSBnb2VzIG9mZiB0aGUgc2NyZWVuKS5cblx0XHR0aGlzLmZpcmUoJ3RpbGV1bmxvYWQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0Y29vcmRzOiB0aGlzLl9rZXlUb1RpbGVDb29yZHMoa2V5KVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUnKTtcblxuXHRcdHZhciB0aWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcblx0XHR0aWxlLnN0eWxlLndpZHRoID0gdGlsZVNpemUueCArICdweCc7XG5cdFx0dGlsZS5zdHlsZS5oZWlnaHQgPSB0aWxlU2l6ZS55ICsgJ3B4JztcblxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xuXG5cdFx0Ly8gdXBkYXRlIG9wYWNpdHkgb24gdGlsZXMgaW4gSUU3LTggYmVjYXVzZSBvZiBmaWx0ZXIgaW5oZXJpdGFuY2UgcHJvYmxlbXNcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSA8IDEpIHtcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXG5cdFx0Ly8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwNzhcblx0XHRpZiAoQnJvd3Nlci5hbmRyb2lkICYmICFCcm93c2VyLmFuZHJvaWQyMykge1xuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHR9XG5cdH0sXG5cblx0X2FkZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGNvbnRhaW5lcikge1xuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyhjb29yZHMpLFxuXHRcdCAgICBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHZhciB0aWxlID0gdGhpcy5jcmVhdGVUaWxlKHRoaXMuX3dyYXBDb29yZHMoY29vcmRzKSwgVXRpbC5iaW5kKHRoaXMuX3RpbGVSZWFkeSwgdGhpcywgY29vcmRzKSk7XG5cblx0XHR0aGlzLl9pbml0VGlsZSh0aWxlKTtcblxuXHRcdC8vIGlmIGNyZWF0ZVRpbGUgaXMgZGVmaW5lZCB3aXRoIGEgc2Vjb25kIGFyZ3VtZW50IChcImRvbmVcIiBjYWxsYmFjayksXG5cdFx0Ly8gd2Uga25vdyB0aGF0IHRpbGUgaXMgYXN5bmMgYW5kIHdpbGwgYmUgcmVhZHkgbGF0ZXI7IG90aGVyd2lzZVxuXHRcdGlmICh0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoIDwgMikge1xuXHRcdFx0Ly8gbWFyayB0aWxlIGFzIHJlYWR5LCBidXQgZGVsYXkgb25lIGZyYW1lIGZvciBvcGFjaXR5IGFuaW1hdGlvbiB0byBoYXBwZW5cblx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHR9XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRpbGUsIHRpbGVQb3MpO1xuXG5cdFx0Ly8gc2F2ZSB0aWxlIGluIGNhY2hlXG5cdFx0dGhpcy5fdGlsZXNba2V5XSA9IHtcblx0XHRcdGVsOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHMsXG5cdFx0XHRjdXJyZW50OiB0cnVlXG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcblx0XHQvLyBAZXZlbnQgdGlsZWxvYWRzdGFydDogVGlsZUV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgaXMgcmVxdWVzdGVkIGFuZCBzdGFydHMgbG9hZGluZy5cblx0XHR0aGlzLmZpcmUoJ3RpbGVsb2Fkc3RhcnQnLCB7XG5cdFx0XHR0aWxlOiB0aWxlLFxuXHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHR9KTtcblx0fSxcblxuXHRfdGlsZVJlYWR5OiBmdW5jdGlvbiAoY29vcmRzLCBlcnIsIHRpbGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvR3JpZExheWVyLmpzIiwiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gKiBub3QgZGlzcGxheSBwcm9wZXJseSBpbiBzb21lIGVkZ2UgY2FzZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENhbnZhcyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnZpZXdwcmVyZXNldCA9IHRoaXMuX29uVmlld1ByZVJlc2V0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X29uVmlld1ByZVJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gU2V0IGEgZmxhZyBzbyB0aGF0IGEgdmlld3ByZXJlc2V0K21vdmVlbmQrdmlld3Jlc2V0IG9ubHkgdXBkYXRlcyZyZWRyYXdzIG9uY2Vcblx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gdHJ1ZTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMpO1xuXG5cdFx0Ly8gUmVkcmF3IHZlY3RvcnMgc2luY2UgY2FudmFzIGlzIGNsZWFyZWQgdXBvbiByZW1vdmFsLFxuXHRcdC8vIGluIGNhc2Ugb2YgcmVtb3ZpbmcgdGhlIHJlbmRlcmVyIGl0c2VsZiBmcm9tIHRoZSBtYXAuXG5cdFx0dGhpcy5fZHJhdygpO1xuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdXNlTW92ZSwgMzIsIHRoaXMpLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudScsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVycyA9IHt9O1xuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXG5cdFx0Ly8gc2V0IGNhbnZhcyBzaXplIChhbHNvIGNsZWFyaW5nIGl0KTsgdXNlIGRvdWJsZSBzaXplIG9uIHJldGluYVxuXHRcdGNvbnRhaW5lci53aWR0aCA9IG0gKiBzaXplLng7XG5cdFx0Y29udGFpbmVyLmhlaWdodCA9IG0gKiBzaXplLnk7XG5cdFx0Y29udGFpbmVyLnN0eWxlLndpZHRoID0gc2l6ZS54ICsgJ3B4Jztcblx0XHRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcblxuXHRcdGlmIChCcm93c2VyLnJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7XG5cdFx0XHR0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzID0gZmFsc2U7XG5cdFx0XHR0aGlzLl91cGRhdGVQYXRocygpO1xuXHRcdH1cblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyID0ge1xuXHRcdFx0bGF5ZXI6IGxheWVyLFxuXHRcdFx0cHJldjogdGhpcy5fZHJhd0xhc3QsXG5cdFx0XHRuZXh0OiBudWxsXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fZHJhd0xhc3QpIHsgdGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyOyB9XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblx0XHR0aGlzLl9kcmF3Rmlyc3QgPSB0aGlzLl9kcmF3Rmlyc3QgfHwgdGhpcy5fZHJhd0xhc3Q7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9kcmF3Rmlyc3QgPSBuZXh0O1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBsYXllci5fb3JkZXI7XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW0wuc3RhbXAobGF5ZXIpXTtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHQvLyBSZWRyYXcgdGhlIHVuaW9uIG9mIHRoZSBsYXllcidzIG9sZCBwaXhlbFxuXHRcdC8vIGJvdW5kcyBhbmQgdGhlIG5ldyBwaXhlbCBib3VuZHMuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0XHQvLyBUaGUgcmVkcmF3IHdpbGwgZXh0ZW5kIHRoZSByZWRyYXcgYm91bmRzXG5cdFx0Ly8gd2l0aCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3VwZGF0ZURhc2hBcnJheShsYXllcik7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZURhc2hBcnJheTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHR2YXIgcGFydHMgPSBsYXllci5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgnLCcpLFxuXHRcdFx0ICAgIGRhc2hBcnJheSA9IFtdLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaEFycmF5LnB1c2goTnVtYmVyKHBhcnRzW2ldKSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2V4dGVuZFJlZHJhd0JvdW5kcyhsYXllcik7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IHRoaXMuX3JlZHJhd1JlcXVlc3QgfHwgVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG5cdH0sXG5cblx0X2V4dGVuZFJlZHJhd0JvdW5kczogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGxheWVyLl9weEJvdW5kcykge1xuXHRcdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzIHx8IG5ldyBCb3VuZHMoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQobGF5ZXIuX3B4Qm91bmRzLm1heC5hZGQoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdGlmICh0aGlzLl9yZWRyYXdCb3VuZHMpIHtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5taW4uX2Zsb29yKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWF4Ll9jZWlsKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY2xlYXIoKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcblx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmNsZWFyUmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxheWVyLCBib3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHM7XG5cdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLl9jdHgucmVjdChib3VuZHMubWluLngsIGJvdW5kcy5taW4ueSwgc2l6ZS54LCBzaXplLnkpO1xuXHRcdFx0dGhpcy5fY3R4LmNsaXAoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gdHJ1ZTtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKCFib3VuZHMgfHwgKGxheWVyLl9weEJvdW5kcyAmJiBsYXllci5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSkge1xuXHRcdFx0XHRsYXllci5fdXBkYXRlUGF0aCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2N0eC5yZXN0b3JlKCk7ICAvLyBSZXN0b3JlIHN0YXRlIGJlZm9yZSBjbGlwcGluZy5cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgaSwgaiwgbGVuMiwgcCxcblx0XHQgICAgcGFydHMgPSBsYXllci5fcGFydHMsXG5cdFx0ICAgIGxlbiA9IHBhcnRzLmxlbmd0aCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4O1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nIHx8IGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IGxheWVyLl9yYWRpdXMsXG5cdFx0ICAgIHMgPSAobGF5ZXIuX3JhZGl1c1kgfHwgcikgLyByO1xuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGxheWVyLm9wdGlvbnMgJiYgbGF5ZXIub3B0aW9ucy5fZGFzaEFycmF5IHx8IFtdKTtcblx0XHRcdH1cblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wdGlvbnMub3BhY2l0eTtcblx0XHRcdGN0eC5saW5lV2lkdGggPSBvcHRpb25zLndlaWdodDtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHgubGluZUNhcCA9IG9wdGlvbnMubGluZUNhcDtcblx0XHRcdGN0eC5saW5lSm9pbiA9IG9wdGlvbnMubGluZUpvaW47XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENhbnZhcyBvYnZpb3VzbHkgZG9lc24ndCBoYXZlIG1vdXNlIGV2ZW50cyBmb3IgaW5kaXZpZHVhbCBkcmF3biBvYmplY3RzLFxuXHQvLyBzbyB3ZSBlbXVsYXRlIHRoYXQgYnkgY2FsY3VsYXRpbmcgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBvbiBtb3VzZW1vdmUvY2xpY2sgbWFudWFsbHlcblxuXHRfb25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSwgbGF5ZXIsIGNsaWNrZWRMYXllcjtcblxuXHRcdGZvciAodmFyIG9yZGVyID0gdGhpcy5fZHJhd0ZpcnN0OyBvcmRlcjsgb3JkZXIgPSBvcmRlci5uZXh0KSB7XG5cdFx0XHRsYXllciA9IG9yZGVyLmxheWVyO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpICYmICF0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGxheWVyKSkge1xuXHRcdFx0XHRjbGlja2VkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaWNrZWRMYXllcikgIHtcblx0XHRcdERvbUV2ZW50LmZha2VTdG9wKGUpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtjbGlja2VkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZUhvdmVyKGUsIHBvaW50KTtcblx0fSxcblxuXG5cdF9oYW5kbGVNb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9ob3ZlcmVkTGF5ZXI7XG5cdFx0aWYgKGxheWVyKSB7XG5cdFx0XHQvLyBpZiB3ZSdyZSBsZWF2aW5nIHRoZSBsYXllciwgZmlyZSBtb3VzZW91dFxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG5cdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG5cdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFt0aGlzLl9ob3ZlcmVkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpZ25sZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2lnbmxlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvQ2FudmFzLmpzIiwiaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRWFydGgnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZSA9IENpcmNsZU1hcmtlci5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG5cdFx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIDAuNy54IGZhY3RvcnkgKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zPylcblx0XHRcdG9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGVnYWN5T3B0aW9ucywge3JhZGl1czogb3B0aW9uc30pO1xuXHRcdH1cblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmIChpc05hTih0aGlzLm9wdGlvbnMucmFkaXVzKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTicpOyB9XG5cblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgQ2lyY2xlIG9wdGlvbnNcblx0XHQvLyBAb3B0aW9uIHJhZGl1czogTnVtYmVyOyBSYWRpdXMgb2YgdGhlIGNpcmNsZSwgaW4gbWV0ZXJzLlxuXHRcdHRoaXMuX21SYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBoYWxmID0gW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzWSB8fCB0aGlzLl9yYWRpdXNdO1xuXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LnN1YnRyYWN0KGhhbGYpKSxcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKGhhbGYpKSk7XG5cdH0sXG5cblx0c2V0U3R5bGU6IFBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBFYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBNYXRoLm1heChNYXRoLnJvdW5kKHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueCksIDEpO1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IE1hdGgubWF4KE1hdGgucm91bmQocC55IC0gdG9wLnkpLCAxKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZS5qcyIsImltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4vTGluZVV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAqL1xyXG5cclxuLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdlbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGVyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcyIsImltcG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN2ZyksIFNWRyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IEFuZHJvaWQgMi54IGFuZCAzLnguXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnRcbiAqIFtWTUxdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9NYXJrdXBfTGFuZ3VhZ2UpXG4gKiAoYSBub3cgZGVwcmVjYXRlZCB0ZWNobm9sb2d5KSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluXG4gKiB0aGlzIGNhc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgU1ZHIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuc3ZnKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgU1ZHIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuc3ZnKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNWRyA9IFJlbmRlcmVyLmV4dGVuZCh7XG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHR9LFxuXG5cdF9vblpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIERyYWctdGhlbi1waW5jaCBpbnRlcmFjdGlvbnMgbWlnaHQgbWVzcyB1cCB0aGUgY2VudGVyIGFuZCB6b29tLlxuXHRcdC8vIEluIHRoaXMgY2FzZSwgdGhlIGVhc2llc3Qgd2F5IHRvIHByZXZlbnQgdGhpcyBpcyByZS1kbyB0aGUgcmVuZGVyZXJcblx0XHQvLyAgIGJvdW5kcyBhbmQgcGFkZGluZyB3aGVuIHRoZSB6b29taW5nIHN0YXJ0cy5cblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG5cdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFtiLm1pbi54LCBiLm1pbi55LCBzaXplLngsIHNpemUueV0uam9pbignICcpKTtcblxuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0Ly8gbWV0aG9kcyBiZWxvdyBhcmUgY2FsbGVkIGJ5IHZlY3RvciBsYXllcnMgaW1wbGVtZW50YXRpb25zXG5cblx0X2luaXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoID0gY3JlYXRlKCdwYXRoJyk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIFBhdGhcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEN1c3RvbSBjbGFzcyBuYW1lIHNldCBvbiBhbiBlbGVtZW50LiBPbmx5IGZvciBTVkcgcmVuZGVyZXIuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsIGxheWVyLm9wdGlvbnMuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHR9LFxuXG5cdF9hZGRQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuX3Jvb3RHcm91cCkgeyB0aGlzLl9pbml0Q29udGFpbmVyKCk7IH1cblx0XHR0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfcmVtb3ZlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCxcblx0XHQgICAgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAoIXBhdGgpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIG9wdGlvbnMub3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgb3B0aW9ucy53ZWlnaHQpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgb3B0aW9ucy5saW5lQ2FwKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBvcHRpb25zLmxpbmVKb2luKTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgb3B0aW9ucy5kYXNoQXJyYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaE9mZnNldCkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBvcHRpb25zLmRhc2hPZmZzZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5Jywgb3B0aW9ucy5maWxsT3BhY2l0eSk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgb3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIHBvaW50c1RvUGF0aChsYXllci5fcGFydHMsIGNsb3NlZCkpO1xuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LFxuXHRcdCAgICByID0gbGF5ZXIuX3JhZGl1cyxcblx0XHQgICAgcjIgPSBsYXllci5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0XHQnTScgKyAocC54IC0gcikgKyAnLCcgKyBwLnkgK1xuXHRcdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKEJyb3dzZXIudm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQGZhY3RvcnkgTC5zdmcob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgU1ZHIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gc3ZnKG9wdGlvbnMpIHtcblx0cmV0dXJuIEJyb3dzZXIuc3ZnIHx8IEJyb3dzZXIudm1sID8gbmV3IFNWRyhvcHRpb25zKSA6IG51bGw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuanMiLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtNYXJrZXJ9IGZyb20gJy4vbWFya2VyL01hcmtlcic7XHJcbmltcG9ydCB7Q2lyY2xlfSBmcm9tICcuL3ZlY3Rvci9DaXJjbGUnO1xyXG5pbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlTWFya2VyJztcclxuaW1wb3J0IHtQb2x5bGluZX0gZnJvbSAnLi92ZWN0b3IvUG9seWxpbmUnO1xyXG5pbXBvcnQge1BvbHlnb259IGZyb20gJy4vdmVjdG9yL1BvbHlnb24nO1xyXG5pbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgR2VvSlNPTlxyXG4gKiBAYWthIEwuR2VvSlNPTlxyXG4gKiBAaW5oZXJpdHMgRmVhdHVyZUdyb3VwXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBHZW9KU09OIG9iamVjdCBvciBhbiBhcnJheSBvZiBHZW9KU09OIG9iamVjdHMuIEFsbG93cyB5b3UgdG8gcGFyc2VcclxuICogR2VvSlNPTiBkYXRhIGFuZCBkaXNwbGF5IGl0IG9uIHRoZSBtYXAuIEV4dGVuZHMgYEZlYXR1cmVHcm91cGAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZ2VvSlNPTihkYXRhLCB7XHJcbiAqIFx0c3R5bGU6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAqIFx0XHRyZXR1cm4ge2NvbG9yOiBmZWF0dXJlLnByb3BlcnRpZXMuY29sb3J9O1xyXG4gKiBcdH1cclxuICogfSkuYmluZFBvcHVwKGZ1bmN0aW9uIChsYXllcikge1xyXG4gKiBcdHJldHVybiBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb247XHJcbiAqIH0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgR2VvSlNPTiA9IEZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgR2VvSlNPTiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvaW50VG9MYXllcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIGhvdyBHZW9KU09OIHBvaW50cyBzcGF3biBMZWFmbGV0IGxheWVycy4gSXQgaXMgaW50ZXJuYWxseVxyXG5cdCAqIGNhbGxlZCB3aGVuIGRhdGEgaXMgYWRkZWQsIHBhc3NpbmcgdGhlIEdlb0pTT04gcG9pbnQgZmVhdHVyZSBhbmQgaXRzIGBMYXRMbmdgLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIHNwYXduIGEgZGVmYXVsdCBgTWFya2VyYDpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uKGdlb0pzb25Qb2ludCwgbGF0bG5nKSB7XHJcblx0ICogXHRyZXR1cm4gTC5tYXJrZXIobGF0bG5nKTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHN0eWxlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgdGhlIGBQYXRoIG9wdGlvbnNgIGZvciBzdHlsaW5nIEdlb0pTT04gbGluZXMgYW5kIHBvbHlnb25zLFxyXG5cdCAqIGNhbGxlZCBpbnRlcm5hbGx5IHdoZW4gZGF0YSBpcyBhZGRlZC5cclxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0byBub3Qgb3ZlcnJpZGUgYW55IGRlZmF1bHRzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4ge31cclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG9uRWFjaEZlYXR1cmU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggY3JlYXRlZCBgRmVhdHVyZWAsIGFmdGVyIGl0IGhhc1xyXG5cdCAqIGJlZW4gY3JlYXRlZCBhbmQgc3R5bGVkLiBVc2VmdWwgZm9yIGF0dGFjaGluZyBldmVudHMgYW5kIHBvcHVwcyB0byBmZWF0dXJlcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBkbyBub3RoaW5nIHdpdGggdGhlIG5ld2x5IGNyZWF0ZWQgbGF5ZXJzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGZlYXR1cmUsIGxheWVyKSB7fVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBmaWx0ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgd2hldGhlciB0byBpbmNsdWRlIGEgZmVhdHVyZSBvciBub3QuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gaW5jbHVkZSBhbGwgZmVhdHVyZXM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB0cnVlO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKiBOb3RlOiBkeW5hbWljYWxseSBjaGFuZ2luZyB0aGUgYGZpbHRlcmAgb3B0aW9uIHdpbGwgaGF2ZSBlZmZlY3Qgb25seSBvbiBuZXdseVxyXG5cdCAqIGFkZGVkIGRhdGEuIEl0IHdpbGwgX25vdF8gcmUtZXZhbHVhdGUgYWxyZWFkeSBpbmNsdWRlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY29vcmRzVG9MYXRMbmc6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY29udmVydGluZyBHZW9KU09OIGNvb3JkaW5hdGVzIHRvIGBMYXRMbmdgcy5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0aGUgYGNvb3Jkc1RvTGF0TG5nYCBzdGF0aWMgbWV0aG9kLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBVdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllciApOiB0aGlzXHJcblx0Ly8gUmVzZXRzIHRoZSBnaXZlbiB2ZWN0b3IgbGF5ZXIncyBzdHlsZSB0byB0aGUgb3JpZ2luYWwgR2VvSlNPTiBzdHlsZSwgdXNlZnVsIGZvciByZXNldHRpbmcgc3R5bGUgYWZ0ZXIgaG92ZXIgZXZlbnRzLlxyXG5cdHJlc2V0U3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdGxheWVyLm9wdGlvbnMgPSBVdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgc3R5bGVzIG9mIEdlb0pTT04gdmVjdG9yIGxheWVycyB3aXRoIHRoZSBnaXZlbiBzdHlsZSBmdW5jdGlvbi5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBUaGVyZSBhcmUgc2V2ZXJhbCBzdGF0aWMgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2l0aG91dCBpbnN0YW50aWF0aW5nIEwuR2VvSlNPTjpcclxuXHJcbi8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcbi8vIENyZWF0ZXMgYSBgTGF5ZXJgIGZyb20gYSBnaXZlbiBHZW9KU09OIGZlYXR1cmUuIENhbiB1c2UgYSBjdXN0b21cclxuLy8gW2Bwb2ludFRvTGF5ZXJgXSgjZ2VvanNvbi1wb2ludHRvbGF5ZXIpIGFuZC9vciBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbixcclxuXHQgICAgY29vcmRzID0gZ2VvbWV0cnkgPyBnZW9tZXRyeS5jb29yZGluYXRlcyA6IG51bGwsXHJcblx0ICAgIGxheWVycyA9IFtdLFxyXG5cdCAgICBwb2ludFRvTGF5ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMucG9pbnRUb0xheWVyLFxyXG5cdCAgICBfY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcsXHJcblx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0Y2FzZSAnUG9pbnQnOlxyXG5cdFx0bGF0bG5nID0gX2Nvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRyZXR1cm4gcG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTWFya2VyKGxhdGxuZyk7XHJcblxyXG5cdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRsYXllcnMucHVzaChwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBNYXJrZXIobGF0bG5nKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0bGF0bG5ncyA9IGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBfY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnUG9seWdvbic6XHJcblx0Y2FzZSAnTXVsdGlQb2x5Z29uJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyAxIDogMiwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0Y2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGxheWVyID0gZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHR0eXBlOiAnRmVhdHVyZScsXHJcblx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRkZWZhdWx0OlxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdlb0pTT04gb2JqZWN0LicpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdgIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIDIgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSlcclxuLy8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHMpIHtcclxuXHRyZXR1cm4gbmV3IExhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuLy8gQ3JlYXRlcyBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgb2YgYExhdExuZ2BzIGZyb20gYSBHZW9KU09OIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4vLyBgbGV2ZWxzRGVlcGAgc3BlY2lmaWVzIHRoZSBuZXN0aW5nIGxldmVsICgwIGlzIGZvciBhbiBhcnJheSBvZiBwb2ludHMsIDEgZm9yIGFuIGFycmF5IG9mIGFycmF5cyBvZiBwb2ludHMsIGV0Yy4sIDAgYnkgZGVmYXVsdCkuXHJcbi8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGxldmVsc0RlZXAsIF9jb29yZHNUb0xhdExuZykge1xyXG5cdHZhciBsYXRsbmdzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXIpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0cHJlY2lzaW9uID0gdHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiA2O1xyXG5cdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmFsdCwgcHJlY2lzaW9uKV0gOlxyXG5cdFx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4pOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdzYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmdzKVxyXG4vLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkLCBwcmVjaXNpb24pIHtcclxuXHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRjb29yZHMucHVzaChsZXZlbHNEZWVwID9cclxuXHRcdFx0bGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3NbaV0sIGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG5cdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuXHR9XHJcblxyXG5cdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQpIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29vcmRzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmVhdHVyZShsYXllciwgbmV3R2VvbWV0cnkpIHtcclxuXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0XHRhc0ZlYXR1cmUobmV3R2VvbWV0cnkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYXNGZWF0dXJlKGdlb2pzb246IE9iamVjdCk6IE9iamVjdFxyXG4vLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuZXhwb3J0IGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uKSB7XHJcblx0aWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnIHx8IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0cmV0dXJuIGdlb2pzb247XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0cHJvcGVydGllczoge30sXHJcblx0XHRnZW9tZXRyeTogZ2VvanNvblxyXG5cdH07XHJcbn1cclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ1BvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCksIHByZWNpc2lvbilcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuQ2lyY2xlLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5DaXJjbGVNYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5bGluZVxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBtdWx0aSA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGhvbGVzID0gIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHRcdCAgICBtdWx0aSA9IGhvbGVzICYmICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDIgOiBob2xlcyA/IDEgOiAwLCB0cnVlLCBwcmVjaXNpb24pO1xyXG5cclxuXHRcdGlmICghaG9sZXMpIHtcclxuXHRcdFx0Y29vcmRzID0gW2Nvb3Jkc107XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ1BvbHlnb24nLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTGF5ZXJHcm91cFxyXG5MYXllckdyb3VwLmluY2x1ZGUoe1xyXG5cdHRvTXVsdGlQb2ludDogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHRjb29yZHMucHVzaChsYXllci50b0dlb0pTT04ocHJlY2lzaW9uKS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdNdWx0aVBvaW50JyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHA6Ly9nZW9qc29uLm9yZy9nZW9qc29uLXNwZWMuaHRtbCkgdG8gZGlzcGxheSBvbiB0aGUgbWFwXHJcbi8vICh5b3UgY2FuIGFsdGVybmF0aXZlbHkgYWRkIGl0IGxhdGVyIHdpdGggYGFkZERhdGFgIG1ldGhvZCkgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbmV4cG9ydCB2YXIgZ2VvSnNvbiA9IGdlb0pTT047XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvR2VvSlNPTi5qcyIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gVGFrZXMgaW50byBhY2NvdW50IHRoYXQgRWFydGggaXMgYSBnZW9pZCwgbm90IGEgcGVyZmVjdCBzcGhlcmUuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNZXJjYXRvciA9IHtcclxuXHRSOiA2Mzc4MTM3LFxyXG5cdFJfTUlOT1I6IDYzNTY3NTIuMzE0MjQ1MTc5LFxyXG5cclxuXHRib3VuZHM6IG5ldyBCb3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nICogZCAqIHIsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgZCA9IDE4MCAvIE1hdGguUEksXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgdHMgPSBNYXRoLmV4cCgtcG9pbnQueSAvIHIpLFxyXG5cdFx0ICAgIHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGRwaGkgPSAwLjEsIGNvbjsgaSA8IDE1ICYmIE1hdGguYWJzKGRwaGkpID4gMWUtNzsgaSsrKSB7XHJcblx0XHRcdGNvbiA9IGUgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRjb24gPSBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdFx0ZHBoaSA9IE1hdGguUEkgLyAyIC0gMiAqIE1hdGguYXRhbih0cyAqIGNvbikgLSBwaGk7XHJcblx0XHRcdHBoaSArPSBkcGhpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHBoaSAqIGQsIHBvaW50LnggKiBkIC8gcik7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanMiLCJpbXBvcnQgeyBFbGVtZW50IGFzIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0ICcuLi8uLi9AcG9seW1lci9wYXBlci10b2dnbGUtYnV0dG9uL3BhcGVyLXRvZ2dsZS1idXR0b24uanMnO1xuXG5pbXBvcnQgeyBGZWF0dXJlR3JvdXAgfSBmcm9tICcuLi8uLi9sZWFmbGV0L3NyYy9sYXllci9GZWF0dXJlR3JvdXAuanMnO1xuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5qcyc7XG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0ljb24uanMnO1xuaW1wb3J0IGljb24gZnJvbSAnLi4vLi4vbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmcnO1xuaW1wb3J0IGljb25TaGFkb3cgZnJvbSAnLi4vLi4vbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZyc7XG5cbmltcG9ydCB7IExlYWZsZXRNYXAgfSBmcm9tICcuLi8uLi9AZ2djaXR5L2xlYWZsZXQtbWFwL2xlYWZsZXQtbWFwLmpzJztcbmltcG9ydCB7IExlYWZsZXRXTVNHcm91cCB9IGZyb20gJy4uLy4uL0BnZ2NpdHkvbGVhZmxldC13bXMvbGVhZmxldC13bXMtZ3JvdXAuanMnO1xuaW1wb3J0IHsgTGVhZmxldFRpbGVMYXllciB9IGZyb20gJy4uLy4uL0BnZ2NpdHkvbGVhZmxldC10aWxlLWxheWVyL2xlYWZsZXQtdGlsZS1sYXllci5qcyc7XG5pbXBvcnQgeyBMZWFmbGV0R2VvSlNPTiB9IGZyb20gJy4uLy4uL0BnZ2NpdHkvbGVhZmxldC1nZW9qc29uL2xlYWZsZXQtZ2VvanNvbi1wb2ludHMuanMnO1xuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4uLy4uL2pzLXlhbWwvZGlzdC9qcy15YW1sLm1pbi5qcycpO1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4vYXBwLnRlbXBsYXRlLmh0bWwnO1xuXG5leHBvcnQgY2xhc3MgR0dNYXBWaWV3ZXIgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgbWFwVGl0bGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogJ0NpdHkgb2YgR2FyZGVuIEdyb3ZlIFB1YmxpYyBNYXBzJ1xuICAgICAgfSxcbiAgICAgIGZsYXQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3RcbiAgICAgIH0sXG4gICAgICBiYXNlU291cmNlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhc2VGb3JtYXQ6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWRPdmVybGF5OiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfb3ZlcmxheUNoYW5nZWQnXG4gICAgICB9LFxuICAgICAgd21zR3JvdXBzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB2YWx1ZTogW11cbiAgICAgIH0sXG4gICAgICBnZW9qc29uTGF5ZXJzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB2YWx1ZTogW11cbiAgICAgIH0sXG4gICAgICBiYXNlTWFwczoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcbiAgICAgIG92ZXJsYXlNYXBzOiB7XG4gICAgICAgIHR5cGU6IEFycmF5XG4gICAgICB9LFxuICAgICAgc2VhcmNoTWFya2Vyczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICBvYnNlcnZlcjogJ19tYXJrTWFwJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9tYXJrZXJzR3JvdXAgPSBuZXcgRmVhdHVyZUdyb3VwKFtdKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICBmZXRjaCh0aGlzLmNvbmZpZykudGhlbihyID0+IHIudGV4dCgpKVxuICAgICAgLnRoZW4odGhpcy5pbml0aWFsaXplTWFwLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplU2VhcmNoKCk7XG4gIH1cblxuICBpbml0aWFsaXplTWFwKHJlc3BvbnNlKSB7XG4gICAgbGV0IHJqc29uID0geWFtbC5zYWZlTG9hZChyZXNwb25zZSk7XG5cbiAgICB0aGlzLmJhc2VNYXBzID0gcmpzb24uYmFzZU1hcHM7XG4gICAgdGhpcy5vdmVybGF5TWFwcyA9IHJqc29uLm92ZXJsYXlNYXBzO1xuXG4gICAgaWYgKHRoaXMuZmxhdCAmJiB0aGlzLm92ZXJsYXlNYXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBjYW5ub3QgZW5hYmxlIGZsYXQgbW9kZSB3aXRoIG11bHRpcGxlIG92ZXJsYXlzIGF0IHRoaXMgdGltZS4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdmVybGF5TWFwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuZmxhdCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJqc29uLm1hcFRpdGxlKSB7XG4gICAgICB0aGlzLm1hcFRpdGxlID0gcmpzb24ubWFwVGl0bGU7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGdyb3VwcyBvZiBsYXllcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3ZlcmxheU1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBsID0gdGhpcy5vdmVybGF5TWFwc1tpXS5sYXllcnM7XG4gICAgICB0aGlzLm92ZXJsYXlNYXBzW2ldLmZsYXR0ZW5lZExheWVycyA9IFtdO1xuXG4gICAgICAvLyBpdGVyYXRlIHRocm91Z2ggbGF5ZXIgaW50ZXJhY3Rpb24gdHlwZXMgKG9wdGlvbmFscywgZXhjbHVzaXZlcywgYWx3YXlzIG9uLi4gaW4gdGhpcyBvcmRlcilcbiAgICAgIGZvciAobGV0IHQgb2YgWydvcHRpb25hbHMnLCAnZXhjbHVzaXZlcycsICdhbHdheXNPbiddKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheU1hcHNbaV0uZmxhdHRlbmVkTGF5ZXJzID0gdGhpcy5vdmVybGF5TWFwc1tpXS5mbGF0dGVuZWRMYXllcnMuY29uY2F0KGxbdF0pO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBhbGwgbGF5ZXJzXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbFt0XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxbdF1bal0uaW50ZXJhY3Rpb24gPSB0O1xuXG4gICAgICAgICAgLy8gYWx3YXlzIG9uIGxheWVycyBzaG91bGQgYWx3YXlzIGJlIHZpc2libGVcbiAgICAgICAgICBpZiAodCA9PT0gJ2Fsd2F5c09uJykge1xuICAgICAgICAgICAgbFt0XVtqXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxvY2F0aW9uLmhhc2ggIT09ICcnKSB7XG4gICAgICAgICAgICAgIGlmIChsW3RdW2pdLm1hY2hpbmVOYW1lID09PSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKSkge1xuICAgICAgICAgICAgICAgIGxbdF1bal0udmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbFt0XVtqXS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGb3IgY29udmVuaWVuY2UsIGFsbG93IHNvdXJjZSB0byBiZSBnbG9iYWxseSBkZWZpbmVkLCBidXQgcHJvcGFnYXRlIGl0IGhlcmUuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGxbdF1bal0udHlwZSA9PT0gJ3dtcycgfHwgbFt0XVtqXS50eXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAmJiBsW3RdW2pdLnNvdXJjZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBsW3RdW2pdLnR5cGUgPSAnd21zJztcbiAgICAgICAgICAgIGxbdF1bal0uc291cmNlID0gcmpzb24ud21zRGVmYXVsdFNvdXJjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGSVhNRTogaGFja3kgaGFyZGNvZGVkIGluaXRpYWwgdmlld1xuICAgIHRoaXMuX3NlbGVjdGVkQmFzZW1hcCA9IDA7XG4gICAgdGhpcy5iYXNlU291cmNlID0gdGhpcy5iYXNlTWFwc1swXS5zb3VyY2U7XG4gICAgdGhpcy5iYXNlRm9ybWF0ID0gdGhpcy5iYXNlTWFwc1swXS5mb3JtYXQ7XG4gICAgdGhpcy5iYXNlTGF5ZXJzID0gdGhpcy5iYXNlTWFwc1swXS5sYXllcnM7XG5cbiAgICB0aGlzLm92ZXJsYXlTZWxlY3QoKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTZWFyY2goKSB7XG4gICAgdGhpcy5fbWFya2Vyc0dyb3VwLmFkZFRvKHRoaXMubWFwKTtcblxuICAgIGpRdWVyeSgnI3NlYXJjaCcsIHRoaXMuc2hhZG93Um9vdCkuYXV0b2NvbXBsZXRlKHtcbiAgICAgIHByZXZlbnRCYWRRdWVyaWVzOiBmYWxzZSxcbiAgICAgIGRlZmVyUmVxdWVzdEJ5OiAyMDAsXG4gICAgICBtaW5DaGFyczogMyxcbiAgICAgIHNlcnZpY2VVcmw6ICcvL3d3dy5jaS5nYXJkZW4tZ3JvdmUuY2EudXMvbWFwcy9hcGkvYWRkcmVzc2VzL3NlYXJjaCcsXG4gICAgICBwYXJhbU5hbWU6ICdxJyxcbiAgICAgIC8vIHBhcmFtczogeyBsaW1pdDogMTAgfSxcbiAgICAgIHRyYW5zZm9ybVJlc3VsdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBhZGRyZXNzZXMgPSBKU09OLnBhcnNlKHJlc3BvbnNlKS5hZGRyZXNzZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VnZ2VzdGlvbnM6IGFkZHJlc3Nlcy5tYXAoZCA9PiAoeyB2YWx1ZTogZC5hZGRyZXNzLCBkYXRhOiBkIH0pKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TZWFyY2hTdGFydDogKCkgPT4gdGhpcy5zZXQoJ3NlYXJjaE1ha2VycycsIFtdKSxcbiAgICAgIG9uU2VhcmNoQ29tcGxldGU6IChxLCBzKSA9PiB0aGlzLnNldCgnc2VhcmNoTWFya2VycycsIHMubWFwKG9iaiA9PiAoXG4gICAgICAgIHsgY29vcmRzOiBbb2JqLmRhdGEubGF0aXR1ZGUsIG9iai5kYXRhLmxvbmdpdHVkZV0sIGFkZHJlc3M6IG9iai5kYXRhLmFkZHJlc3MgfVxuICAgICAgKSkpLFxuICAgICAgb25TZWxlY3Q6IG9iaiA9PiB0aGlzLnNldCgnc2VhcmNoTWFya2VycycsIFt7IGNvb3JkczogW29iai5kYXRhLmxhdGl0dWRlLCBvYmouZGF0YS5sb25naXR1ZGVdLCBhZGRyZXNzOiBvYmouZGF0YS5hZGRyZXNzIH1dKVxuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlTGF5ZXIoZXZlbnQpIHtcbiAgICAvLyBGaXJzdCBzYXZlIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgbGV0IGN1cnJWaXNpYmxlID0gZXZlbnQubW9kZWwubGF5ZXIudmlzaWJsZTtcblxuICAgIGlmIChldmVudC5tb2RlbC5sYXllci5pbnRlcmFjdGlvbiA9PT0gJ2V4Y2x1c2l2ZXMnKSB7XG4gICAgICAvLyBUdXJuIGFsbCBleGNsdXNpdmUgbGF5ZXJzIG9mZlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkT3ZlcmxheS5sYXllcnMuZXhjbHVzaXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNldCgnc2VsZWN0ZWRPdmVybGF5LmxheWVycy5leGNsdXNpdmVzLicgKyBpICsgJy52aXNpYmxlJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdG9nZ2xlIG9uIG9yaWdpbmFsIHN0YXRlXG4gICAgZXZlbnQubW9kZWwuc2V0KCdsYXllci52aXNpYmxlJywgIWN1cnJWaXNpYmxlKTtcblxuICAgIHRoaXMuX3BhcnNlTGF5ZXJzKHRoaXMuc2VsZWN0ZWRPdmVybGF5KTtcbiAgfVxuXG4gIG92ZXJsYXlTZWxlY3QoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkT3ZlcmxheSA9IChldmVudCkgPyBldmVudC5tb2RlbC5pdGVtIDogdGhpcy5vdmVybGF5TWFwc1swXTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkT3ZlcmxheS5yZXNldFZpZXdPblNlbGVjdCkge1xuICAgICAgdGhpcy5tYXAuZmx5VG8odGhpcy5zZWxlY3RlZE92ZXJsYXkuaW5pdGlhbENlbnRlciwgdGhpcy5zZWxlY3RlZE92ZXJsYXkuaW5pdGlhbFpvb20pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWEU6IEFjaHR1bmchIFViZXIgaGFja3khISFcbiAgc3dpdGNoQmFzZW1hcChldmVudCkge1xuICAgIGxldCBpZHggPSArK3RoaXMuX3NlbGVjdGVkQmFzZW1hcCAlIDI7XG4gICAgdGhpcy5iYXNlU291cmNlID0gdGhpcy5iYXNlTWFwc1tpZHhdLnNvdXJjZTtcbiAgICB0aGlzLmJhc2VGb3JtYXQgPSB0aGlzLmJhc2VNYXBzW2lkeF0uZm9ybWF0O1xuICAgIHRoaXMuYmFzZUxheWVycyA9IHRoaXMuYmFzZU1hcHNbaWR4XS5sYXllcnM7XG5cbiAgICBpZiAoaWR4ID09PSAxKSB7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi92ZWN0b3IucG5nKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi9hZXJpYWwucG5nKVwiO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUxheWVyc01lbnUoKSB7XG4gICAgbGV0IGxheWVyc01lbnUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignbWFpbiNsYXllcnMtbWVudScpO1xuICAgIGxheWVyc01lbnUuY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpO1xuICB9XG5cbiAgX3BhcnNlTGF5ZXJzKG92ZXJsYXkpIHtcbiAgICBsZXQgbGF5ZXJzID0gb3ZlcmxheS5mbGF0dGVuZWRMYXllcnM7XG4gICAgbGV0IHdtc0xheWVycyA9IHt9O1xuXG4gICAgLy8gcmVzZXRcbiAgICB0aGlzLnNldCgnd21zR3JvdXBzJywgW10pO1xuICAgIHRoaXMuc2V0KCdnZW9qc29uTGF5ZXJzJywgW10pO1xuXG4gICAgbGF5ZXJzXG4gICAgICAuZmlsdGVyKGwgPT4gbC52aXNpYmxlKVxuICAgICAgLmZvckVhY2gobCA9PiB7XG4gICAgICAgIGlmIChsLnR5cGUgPT09ICd3bXMnKSB7XG4gICAgICAgICAgLy8gZ3JvdXAgdGhlIHNvdXJjZXNcbiAgICAgICAgICB3bXNMYXllcnNbbC5zb3VyY2VdID0gd21zTGF5ZXJzW2wuc291cmNlXSB8fCB7IGxheWVyczogW10sIGlkZW50aWZ5OiBmYWxzZSwgaW5mb0Zvcm1hdDogbnVsbCB9O1xuICAgICAgICAgIHdtc0xheWVyc1tsLnNvdXJjZV0ubGF5ZXJzLnB1c2gobC5tYWNoaW5lTmFtZSk7XG4gICAgICAgICAgd21zTGF5ZXJzW2wuc291cmNlXS5pZGVudGlmeSA9IHdtc0xheWVyc1tsLnNvdXJjZV0uaWRlbnRpZnkgfHwgbC5pZGVudGlmeTtcbiAgICAgICAgICB3bXNMYXllcnNbbC5zb3VyY2VdLmluZm9Gb3JtYXQgPSB3bXNMYXllcnNbbC5zb3VyY2VdLmluZm9Gb3JtYXQgfHwgbC5pbmZvRm9ybWF0O1xuICAgICAgICB9IGVsc2UgaWYgKGwudHlwZSA9PT0gJ2dlb2pzb24nKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKCdnZW9qc29uTGF5ZXJzJywgbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgLy8gZmxhdHRlbmVkIHRoZSBncm91cGVkIFdNUyBzb3VyY2VzXG4gICAgZm9yIChsZXQgcyBpbiB3bXNMYXllcnMpIHtcbiAgICAgIHRoaXMucHVzaCgnd21zR3JvdXBzJywgeyBzb3VyY2U6IHMsIGxheWVyczogd21zTGF5ZXJzW3NdLmxheWVycywgaWRlbnRpZnk6IHdtc0xheWVyc1tzXS5pZGVudGlmeSB9KTtcbiAgICB9XG4gIH1cblxuICBfbWFya01hcChtYXJrZXJzRGF0YSkge1xuICAgIHRoaXMuX21hcmtlcnNHcm91cC5jbGVhckxheWVycygpO1xuICAgIGlmIChtYXJrZXJzRGF0YS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIG1hcmtlcnNEYXRhLmZvckVhY2gobSA9PiB7XG4gICAgICB0aGlzLl9tYXJrZXJzR3JvdXBcbiAgICAgICAgLmFkZExheWVyKG5ldyBNYXJrZXIobS5jb29yZHMsIHtcbiAgICAgICAgICBpY29uOiBuZXcgSWNvbih7XG4gICAgICAgICAgICBpY29uVXJsOiBpY29uLFxuICAgICAgICAgICAgc2hhZG93VXJsOiBpY29uU2hhZG93LFxuICAgICAgICAgICAgaWNvblNpemU6IFsyNSwgNDFdLFxuICAgICAgICAgICAgaWNvbkFuY2hvcjogWzEyLCA0MV0sXG4gICAgICAgICAgICBwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG4gICAgICAgICAgICB0b29sdGlwQW5jaG9yOiBbMTYsIC0yOF0sXG4gICAgICAgICAgICBzaGFkb3dTaXplOiBbNDEsIDQxXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pLmJpbmRQb3B1cChtLmFkZHJlc3MpKVxuICAgIH0pO1xuXG4gICAgaWYgKG1hcmtlcnNEYXRhLmxlbmd0aCA9PT0gMSkgdGhpcy5tYXAuZmx5VG8obWFya2Vyc0RhdGFbMF0uY29vcmRzKTtcbiAgICBlbHNlIHRoaXMubWFwLmZpdEJvdW5kcyh0aGlzLl9tYXJrZXJzR3JvdXAuZ2V0Qm91bmRzKCkpO1xuICB9XG5cbiAgX2lzQ3VycmVudEV4Y2x1c2l2ZShsYXllcikge1xuICAgIHJldHVybiBsYXllci52aXNpYmxlO1xuICB9XG5cbiAgX2lzQ3VycmVudE92ZXJsYXkoc2VsZWN0ZWQsIGl0ZW0pIHtcbiAgICByZXR1cm4gc2VsZWN0ZWQgPT09IGl0ZW07XG4gIH1cblxuICBfb3ZlcmxheUNoYW5nZWQobmV3T3ZlcmxheSkge1xuICAgIHRoaXMuX3BhcnNlTGF5ZXJzKG5ld092ZXJsYXkpO1xuICB9XG5cbiAgX292ZXJsYXlMYXllcnNTaG93KHNlbGVjdGVkLCBpdGVtKSB7XG4gICAgaWYgKHNlbGVjdGVkID09PSBpdGVtIHx8IHRoaXMuZmxhdCkgcmV0dXJuIFwiY29sbGFwc2Ugc2hvd1wiO1xuICAgIHJldHVybiBcImNvbGxhcHNlXCI7XG4gIH1cblxuICBfb3ZlcmxheUl0ZW1DbGFzcyhzZWxlY3RlZCwgaXRlbSkge1xuICAgIGxldCBkZWZhdWx0Q2xhc3MgPSBcIm92ZXJsYXktaXRlbSBkLWZsZXgganVzdGlmeS1jb250ZW50LXN0YXJ0XCI7XG4gICAgaWYgKHNlbGVjdGVkID09PSBpdGVtKSByZXR1cm4gZGVmYXVsdENsYXNzICsgJyBzZWxlY3RlZCc7XG4gICAgcmV0dXJuIGRlZmF1bHRDbGFzcztcbiAgfVxuXG4gIC8vIEZJWE1FOiBtYWtlIHRoaXMgbGVzcyBoYXJkY29kZXlcbiAgZG93bmxvYWRMYXllcihldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBpZiBtb2RhbCBpcyBub3QgYWxyZWFkeSBmb3VuZCBpbiBsaWdodCBET00sIHB1bGwgZnJvbSBzaGFkb3cgRE9NXG4gICAgbGV0IGRvbSA9IChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZG93bmxvYWQtbW9kYWwnKSkgPyBkb2N1bWVudCA6IHRoaXMuc2hhZG93Um9vdDtcblxuICAgIGxldCBsYXllciA9IGV2ZW50Lm1vZGVsLmxheWVyO1xuICAgIC8vIEZJWE1FOiBoYXJkY29kZWQgdXJsXG4gICAgbGV0IGRvd25sb2FkVVJMID0gYGh0dHBzOi8vd3d3LmNpLmdhcmRlbi1ncm92ZS5jYS51cy9nZW9zZXJ2ZXIvZ2lzL293cz9zZXJ2aWNlPVdGUyZ2ZXJzaW9uPTEuMC4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlTmFtZT0ke2xheWVyLm1hY2hpbmVOYW1lfWA7XG5cbiAgICBqUXVlcnkoJyNsYXllci1uYW1lJywgZG9tKS5odG1sKGxheWVyLm5hbWUpO1xuICAgIGpRdWVyeSgnI2dlb2pzb24tZG93bmxvYWQnLCBkb20pLmF0dHIoJ2hyZWYnLCBkb3dubG9hZFVSTCArICcmb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBqUXVlcnkoJyNjc3YtZG93bmxvYWQnLCBkb20pLmF0dHIoJ2hyZWYnLCBkb3dubG9hZFVSTCArICcmb3V0cHV0Rm9ybWF0PWNzdicpO1xuICAgIGpRdWVyeSgnI2ttbC1kb3dubG9hZCcsIGRvbSkuYXR0cignaHJlZicsIGRvd25sb2FkVVJMICsgJyZvdXRwdXRGb3JtYXQ9YXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWwreG1sJyk7XG4gICAgalF1ZXJ5KCcjc2hhcGVmaWxlLWRvd25sb2FkJywgZG9tKS5hdHRyKCdocmVmJywgZG93bmxvYWRVUkwgKyAnJm91dHB1dEZvcm1hdD1TSEFQRS1aSVAnKTtcbiAgICBqUXVlcnkoJyNkb3dubG9hZC1tb2RhbCcsIGRvbSkubW9kYWwoKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2dnLW1hcC12aWV3ZXInLCBHR01hcFZpZXdlcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vZ2ctbWFwLXZpZXdlci5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0ICogYXMgY2FzZU1hcCQwIGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcblxubGV0IGNhc2VNYXAgPSBjYXNlTWFwJDA7XG5cbmxldCBtaWNyb3Rhc2sgPSBtaWNyb1Rhc2s7XG5cbi8vIFNhdmUgbWFwIG9mIG5hdGl2ZSBwcm9wZXJ0aWVzOyB0aGlzIGZvcm1zIGEgYmxhY2tsaXN0IG9yIHByb3BlcnRpZXNcbi8vIHRoYXQgd29uJ3QgaGF2ZSB0aGVpciB2YWx1ZXMgXCJzYXZlZFwiIGJ5IGBzYXZlQWNjZXNzb3JWYWx1ZWAsIHNpbmNlXG4vLyByZWFkaW5nIGZyb20gYW4gSFRNTEVsZW1lbnQgYWNjZXNzb3IgZnJvbSB0aGUgY29udGV4dCBvZiBhIHByb3RvdHlwZSB0aHJvd3NcbmNvbnN0IG5hdGl2ZVByb3BlcnRpZXMgPSB7fTtcbmxldCBwcm90byA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbndoaWxlIChwcm90bykge1xuICBsZXQgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG4gIGZvciAobGV0IGk9MDsgaTxwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIG5hdGl2ZVByb3BlcnRpZXNbcHJvcHNbaV1dID0gdHJ1ZTtcbiAgfVxuICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG59XG5cbi8qKlxuICogVXNlZCB0byBzYXZlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBvdmVycmlkZGVuIHdpdGhcbiAqIGFuIGFjY2Vzc29yLiBJZiB0aGUgYG1vZGVsYCBpcyBhIHByb3RvdHlwZSwgdGhlIHZhbHVlcyB3aWxsIGJlIHNhdmVkXG4gKiBpbiBgX19kYXRhUHJvdG9gLCBhbmQgaXQncyB1cCB0byB0aGUgdXNlciAob3IgZG93bnN0cmVhbSBtaXhpbikgdG9cbiAqIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhlc2UgdmFsdWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3JzLlxuICogSWYgYG1vZGVsYCBpcyBhbHJlYWR5IGFuIGluc3RhbmNlIChpdCBoYXMgYSBgX19kYXRhYCBwcm9wZXJ0eSksIHRoZW5cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCBhcyBhIHBlbmRpbmcgcHJvcGVydHksIG1lYW5pbmcgdGhlIHVzZXIgc2hvdWxkXG4gKiBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYCB0byB0YWtlIGVmZmVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlQWNjZXNzb3JWYWx1ZShtb2RlbCwgcHJvcGVydHkpIHtcbiAgLy8gRG9uJ3QgcmVhZC9zdG9yZSB2YWx1ZSBmb3IgYW55IG5hdGl2ZSBwcm9wZXJ0aWVzIHNpbmNlIHRoZXkgY291bGQgdGhyb3dcbiAgaWYgKCFuYXRpdmVQcm9wZXJ0aWVzW3Byb3BlcnR5XSkge1xuICAgIGxldCB2YWx1ZSA9IG1vZGVsW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG1vZGVsLl9fZGF0YSkge1xuICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gaW5zdGFuY2U7IHVwZGF0ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gSXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBjYWxsIF9mbHVzaFByb3BlcnRpZXNcbiAgICAgICAgbW9kZWwuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkaW5nIGFjY2Vzc29yIHRvIHByb3RvOyBzYXZlIHByb3RvJ3MgdmFsdWUgZm9yIGluc3RhbmNlLXRpbWUgdXNlXG4gICAgICAgIGlmICghbW9kZWwuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKCFtb2RlbC5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2RhdGFQcm90bycsIG1vZGVsKSkpIHtcbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IE9iamVjdC5jcmVhdGUobW9kZWwuX19kYXRhUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLl9fZGF0YVByb3RvW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUHJvcGVydHlBY2Nlc3NvcnMgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgUHJvcGVydHlBY2Nlc3NvcnMgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIGFsbCBhdHRyaWJ1dGVzIGluIHRoZSBzdGFuZGFyZFxuICAgICAqIHN0YXRpYyBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIEF0dHJpYnV0ZSBuYW1lcyBhcmUgbWFwcGVkIHRvIHByb3BlcnR5IG5hbWVzIHVzaW5nIHRoZSBgZGFzaC1jYXNlYCB0b1xuICAgICAqIGBjYW1lbENhc2VgIGNvbnZlbnRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0aWVzRm9yQXR0cmlidXRlcygpIHtcbiAgICAgIGxldCBhJCA9IHRoaXMub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgYSQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IoY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UoYSRbaV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmc7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ291bnRlcjtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhRW5hYmxlZDtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhUmVhZHk7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUludmFsaWQ7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YTtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YU9sZDtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQcm90bztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvcjtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzO1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIG5hdGl2ZSBDdXN0b20gRWxlbWVudHMgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG9cbiAgICAgKiBzZXQgYW4gYXR0cmlidXRlIHZhbHVlIHRvIGEgcHJvcGVydHkgdmlhIGBfYXR0cmlidXRlVG9Qcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZSB0aGF0IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBOZXcgYXR0cmlidXRlIHZhbHVlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICpcbiAgICAgKiBQcm92aWRlZCBhcyBhbiBvdmVycmlkZSBwb2ludCBmb3IgcGVyZm9ybWluZyBhbnkgc2V0dXAgd29yayBwcmlvclxuICAgICAqIHRvIGluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgYWNjZXNzb3Igc3lzdGVtLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YSA9IHt9O1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhT2xkID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9fZGF0YVByb3RvKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXModGhpcy5fX2RhdGFQcm90byk7XG4gICAgICAgIHRoaXMuX19kYXRhUHJvdG8gPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gQ2FwdHVyZSBpbnN0YW5jZSBwcm9wZXJ0aWVzOyB0aGVzZSB3aWxsIGJlIHNldCBpbnRvIGFjY2Vzc29yc1xuICAgICAgLy8gZHVyaW5nIGZpcnN0IGZsdXNoLiBEb24ndCBzZXQgdGhlbSBoZXJlLCBzaW5jZSB3ZSB3YW50XG4gICAgICAvLyB0aGVzZSB0byBvdmVyd3JpdGUgZGVmYXVsdHMvY29uc3RydWN0b3IgYXNzaWdubWVudHNcbiAgICAgIGZvciAobGV0IHAgaW4gdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHNbcF0gPSB0aGlzW3BdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IGluc3RhbmNlIHRpbWUgd2l0aCBiYWcgb2YgcHJvcGVydGllcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiBieSBhY2Nlc3NvcnMgb24gdGhlIHByb3RvdHlwZSB3aGVuIGFjY2Vzc29ycyB3ZXJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzZXRzIHRoZXNlIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZVxuICAgICAqIHNldHRlciBhdCBpbnN0YW5jZSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocCwgcHJvcHNbcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCByZWFkeSB0aW1lIHdpdGggYmFnIG9mIGluc3RhbmNlIHByb3BlcnRpZXMgdGhhdCBvdmVyd3JvdGVcbiAgICAgKiBhY2Nlc3NvcnMgd2hlbiB0aGUgZWxlbWVudCB1cGdyYWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICogc2V0dGVyIGF0IHJlYWR5IHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGUgZWxlbWVudCBoYXMgdGhlIGdpdmVuIGF0dHJpYnV0ZS4gSWYgaXQgZG9lcyBub3QsXG4gICAgICogYXNzaWducyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBlbnN1cmUgaXMgc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIF9lbnN1cmVBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhbiBhdHRyaWJ1dGUgdG8gaXRzIGFzc29jaWF0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgc3RyaW5nIHRvXG4gICAgICogYSB0eXBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgdHlwZSB0byBkZXNlcmlhbGl6ZSB0by5cbiAgICAgKi9cbiAgICBfYXR0cmlidXRlVG9Qcm9wZXJ0eShhdHRyaWJ1dGUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAvLyBEb24ndCBkZXNlcmlhbGl6ZSBiYWNrIHRvIHByb3BlcnR5IGlmIGN1cnJlbnRseSByZWZsZWN0aW5nXG4gICAgICBpZiAoIXRoaXMuX19zZXJpYWxpemluZykge1xuICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhdHRyaWJ1dGUpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHRoaXMuX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgYSBwcm9wZXJ0eSB0byBpdHMgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gcmVmZWN0LlxuICAgICAqL1xuICAgIF9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSB0cnVlO1xuICAgICAgdmFsdWUgPSAoYXJndW1lbnRzLmxlbmd0aCA8IDMpID8gdGhpc1twcm9wZXJ0eV0gOiB2YWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLFxuICAgICAgICBhdHRyaWJ1dGUgfHwgY2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcGVydHkpKTtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHRvIGNvbnZlcnQgdGhlIHR5cGVkXG4gICAgICogdmFsdWUgdG8gYSBzdHJpbmcuICBJZiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQgKHRoaXMgaXMgdGhlIGRlZmF1bHQgZm9yIGJvb2xlYW5cbiAgICAgKiB0eXBlIGBmYWxzZWApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgKi9cbiAgICBfdmFsdWVUb05vZGVBdHRyaWJ1dGUobm9kZSwgdmFsdWUsIGF0dHJpYnV0ZSkge1xuICAgICAgbGV0IHN0ciA9IHRoaXMuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBzdHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gc2V0dGluZyBKUyBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICAgKiBIVE1MIGF0dHJpYnV0ZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgb24gUG9seW1lciBlbGVtZW50XG4gICAgICogcHJvdG90eXBlcyB0byBwcm92aWRlIHNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU3RyaW5nIHNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID8gJycgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiByZWFkaW5nIEhUTUwgYXR0cmlidXRlIHZhbHVlcyB0b1xuICAgICAqIEpTIHByb3BlcnRpZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgb24gUG9seW1lciBlbGVtZW50XG4gICAgICogcHJvdG90eXBlcyB0byBwcm92aWRlIGRlc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIGB0eXBlYHMuICBOb3RlLFxuICAgICAqIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBgdHlwZWAgZmllbGQgcHJvdmlkZWQgaW4gdGhlXG4gICAgICogYHByb3BlcnRpZXNgIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhIGdpdmVuIHByb3BlcnR5LCBhbmQgaXNcbiAgICAgKiBieSBjb252ZW50aW9uIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGlzIHVzZWQgYXMgYSBzZW50aW5lbCB2YWx1ZSB0b1xuICAgICAqIGluZGljYXRlIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0geyo9fSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0by5cbiAgICAgKiBAcmV0dXJuIHsqfSBUeXBlZCB2YWx1ZSBkZXNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIF9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICovXG4gICAgICBsZXQgb3V0VmFsdWU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgb3V0VmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICBvdXRWYWx1ZSA9ICh2YWx1ZSAhPT0gbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUgc3RyaW5nICovKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBub24tSlNPTiBsaXRlcmFscyBsaWtlIFN0cmluZ3MgYW5kIE51bWJlcnNcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUG9seW1lcjo6QXR0cmlidXRlczogY291bGRuJ3QgZGVjb2RlIEFycmF5IGFzIEpTT046ICR7dmFsdWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRGF0ZTpcbiAgICAgICAgICBvdXRWYWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0VmFsdWU7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tZmFsbHRocm91Z2ggKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXR0ZXIvZ2V0dGVyIHBhaXIgZm9yIHRoZSBuYW1lZCBwcm9wZXJ0eSB3aXRoIGl0cyBvd25cbiAgICAgKiBsb2NhbCBzdG9yYWdlLiAgVGhlIGdldHRlciByZXR1cm5zIHRoZSB2YWx1ZSBpbiB0aGUgbG9jYWwgc3RvcmFnZSxcbiAgICAgKiBhbmQgdGhlIHNldHRlciBjYWxscyBgX3NldFByb3BlcnR5YCwgd2hpY2ggdXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZVxuICAgICAqIGZvciB0aGUgcHJvcGVydHkgYW5kIGVucXVldWVzIGEgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIGEgcHJvdG90eXBlIG9yIGFuIGluc3RhbmNlLiAgQ2FsbGluZ1xuICAgICAqIHRoaXMgbWV0aG9kIG1heSBvdmVyd3JpdGUgYSBwcm9wZXJ0eSB2YWx1ZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uXG4gICAgICogdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBieSBjcmVhdGluZyB0aGUgYWNjZXNzb3IuICBXaGVuIGNhbGxpbmcgb25cbiAgICAgKiBhIHByb3RvdHlwZSwgYW55IG92ZXJ3cml0dGVuIHZhbHVlcyBhcmUgc2F2ZWQgaW4gYF9fZGF0YVByb3RvYCxcbiAgICAgKiBhbmQgaXQgaXMgdXAgdG8gdGhlIHN1YmNsYXNzZXIgdG8gZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aG9zZVxuICAgICAqIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvbiBhbiBpbnN0YW5jZSxcbiAgICAgKiB0aGUgb3ZlcndyaXR0ZW4gdmFsdWUgaXMgc2V0IHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAsIGFuZCB0aGVcbiAgICAgKiB1c2VyIHNob3VsZCBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYFxuICAgICAqIGZvciB0aGUgdmFsdWVzIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVhZE9ubHkgV2hlbiB0cnVlLCBubyBzZXR0ZXIgaXMgY3JlYXRlZDsgdGhlXG4gICAgICogICBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIHNldCB0aGUgcHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGF0YUhhc0FjY2Vzc29yJykpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSkge1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIHNhdmVBY2Nlc3NvclZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgLyoqIEB0aGlzIHtQcm9wZXJ0eUFjY2Vzc29yc30gKi9cbiAgICAgICAgICBzZXQ6IHJlYWRPbmx5ID8gZnVuY3Rpb24oKSB7fSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpYnJhcnkgY3JlYXRlZCBhbiBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGFjY2Vzc29yIHdhcyBjcmVhdGVkXG4gICAgICovXG4gICAgX2hhc0FjY2Vzc29yKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5ICh2aWEgYF9zZXRQZW5kaW5nUHJvcGVydHlgKVxuICAgICAqIGFuZCBlbnF1ZXVlcyBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSwgcmVjb3JkcyB0aGUgcHJldmlvdXMgdmFsdWUsXG4gICAgICogYW5kIGFkZHMgaXQgdG8gdGhlIHNldCBvZiBcInBlbmRpbmcgY2hhbmdlc1wiIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBlbnF1ZXVlIHRoZVxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGxldCBvbGQgPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICBsZXQgY2hhbmdlZCA9IHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0ge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgb2xkIGlzIGNhcHR1cmVkIGZyb20gdGhlIGxhc3QgdHVyblxuICAgICAgICBpZiAodGhpcy5fX2RhdGFPbGQgJiYgIShwcm9wZXJ0eSBpbiB0aGlzLl9fZGF0YU9sZCkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2RhdGFbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGhhcyBhIHBlbmRpbmcgY2hhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2lzUHJvcGVydHlQZW5kaW5nKHByb3ApIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX19kYXRhUGVuZGluZyAmJiAocHJvcCBpbiB0aGlzLl9fZGF0YVBlbmRpbmcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgcHJvcGVydGllcyBhcyBpbnZhbGlkLCBhbmQgZW5xdWV1ZXMgYW4gYXN5bmNcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhSW52YWxpZCAmJiB0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IHRydWU7XG4gICAgICAgIG1pY3JvdGFzay5ydW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUludmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRvIGVuYWJsZSBwcm9wZXJ0eSBhY2Nlc3NvciBwcm9jZXNzaW5nLiBCZWZvcmUgdGhpcyBtZXRob2QgaXNcbiAgICAgKiBjYWxsZWQgYWNjZXNzb3IgdmFsdWVzIHdpbGwgYmUgc2V0IGJ1dCBzaWRlIGVmZmVjdHMgYXJlXG4gICAgICogcXVldWVkLiBXaGVuIGNhbGxlZCwgYW55IHBlbmRpbmcgc2lkZSBlZmZlY3RzIG9jY3VyIGltbWVkaWF0ZWx5LlxuICAgICAqIEZvciBlbGVtZW50cywgZ2VuZXJhbGx5IGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgYSBub3JtYWwgc3BvdCB0byBkbyBzby5cbiAgICAgKiBJdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgYXMgaXQgb25seSB0dXJucyBvblxuICAgICAqIHByb3BlcnR5IGFjY2Vzc29ycyBvbmNlLlxuICAgICAqL1xuICAgIF9lbmFibGVQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcykge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXModGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKTtcbiAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2sgd2l0aCB0aGUgY3VycmVudCBzZXQgb2ZcbiAgICAgKiBwZW5kaW5nIGNoYW5nZXMgKGFuZCBvbGQgdmFsdWVzIHJlY29yZGVkIHdoZW4gcGVuZGluZyBjaGFuZ2VzIHdlcmVcbiAgICAgKiBzZXQpLCBhbmQgcmVzZXRzIHRoZSBwZW5kaW5nIHNldCBvZiBjaGFuZ2VzLiBHZW5lcmFsbHksIHRoaXMgbWV0aG9kXG4gICAgICogc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gdXNlciBjb2RlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZsdXNoUHJvcGVydGllcygpIHtcbiAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcgJiYgdGhpcy5fX2RhdGFPbGQpIHtcbiAgICAgICAgbGV0IGNoYW5nZWRQcm9wcyA9IHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyKys7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXNDaGFuZ2VkKHRoaXMuX19kYXRhLCBjaGFuZ2VkUHJvcHMsIHRoaXMuX19kYXRhT2xkKTtcbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIGNhbGxiYWNrIGNhbGxlZCB0aGUgZmlyc3QgdGltZSBwcm9wZXJ0aWVzIGFyZSBiZWluZyBmbHVzaGVkLlxuICAgICAqIFByaW9yIHRvIGByZWFkeWAsIGFsbCBwcm9wZXJ0eSBzZXRzIHRocm91Z2ggYWNjZXNzb3JzIGFyZSBxdWV1ZWQgYW5kXG4gICAgICogdGhlaXIgZWZmZWN0cyBhcmUgZmx1c2hlZCBhZnRlciB0aGlzIG1ldGhvZCByZXR1cm5zLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gaW1wbGVtZW50IGJlaGF2aW9yIHRoYXQgaXNcbiAgICAgKiBkZXBlbmRlbnQgb24gdGhlIGVsZW1lbnQgaGF2aW5nIGl0cyBwcm9wZXJ0aWVzIGluaXRpYWxpemVkLCBlLmcuXG4gICAgICogZnJvbSBkZWZhdWx0cyAoaW5pdGlhbGl6ZWQgZnJvbSBgY29uc3RydWN0b3JgLCBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCksXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHZhbHVlcyBwcm9wYWdhdGVkIGZyb20gaG9zdCBlLmcuIHZpYVxuICAgICAqIGJpbmRpbmdzLiAgYHN1cGVyLnJlYWR5KClgIG11c3QgYmUgY2FsbGVkIHRvIGVuc3VyZSB0aGUgZGF0YSBzeXN0ZW1cbiAgICAgKiBiZWNvbWVzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIC8vIFJ1biBub3JtYWwgZmx1c2hcbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIGFueSBwcm9wZXJ0aWVzIHdpdGggYWNjZXNzb3JzIGNyZWF0ZWQgdmlhXG4gICAgICogYF9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yYCBoYXZlIGJlZW4gc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjdXJyZW50UHJvcHMgQmFnIG9mIGFsbCBjdXJyZW50IGFjY2Vzc29yIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3RcbiAgICAgKiAgIGNhbGwgdG8gYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgKiAgIGluIGBjaGFuZ2VkUHJvcHNgXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSB2YWx1ZSBzaG91bGQgYmVcbiAgICAgKiBjb25zaWRlcmVkIGFzIGEgY2hhbmdlIGFuZCBjYXVzZSB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiB0byBiZSBlbnF1ZXVlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgYHRydWVgIGZvciBwcmltaXRpdmUgdHlwZXMgaWYgYVxuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayBmYWlscywgYW5kIHJldHVybnMgYHRydWVgIGZvciBhbGwgT2JqZWN0L0FycmF5cy5cbiAgICAgKiBUaGUgbWV0aG9kIGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBgTmFOYC5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGUuZy4gcHJvdmlkZSBzdHJpY3RlciBjaGVja2luZyBmb3JcbiAgICAgKiBPYmplY3RzL0FycmF5cyB3aGVuIHVzaW5nIGltbXV0YWJsZSBwYXR0ZXJucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogICBhbmQgZW5xdWV1ZSBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAgICAgIChvbGQgIT09IHZhbHVlICYmXG4gICAgICAgICAvLyBUaGlzIGVuc3VyZXMgKG9sZD09TmFOLCB2YWx1ZT09TmFOKSBhbHdheXMgcmV0dXJucyBmYWxzZVxuICAgICAgICAgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpXG4gICAgICApO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFByb3BlcnR5QWNjZXNzb3JzO1xuXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuXG4vLyAxLnggYmFja3dhcmRzLWNvbXBhdGlibGUgYXV0by13cmFwcGVyIGZvciB0ZW1wbGF0ZSB0eXBlIGV4dGVuc2lvbnNcbi8vIFRoaXMgaXMgYSBjbGVhciBsYXllcmluZyB2aW9sYXRpb24gYW5kIGdpdmVzIGZhdm9yZWQtbmF0aW9uIHN0YXR1cyB0b1xuLy8gZG9tLWlmIGFuZCBkb20tcmVwZWF0IHRlbXBsYXRlcy4gIFRoaXMgaXMgYSBjb25jZWl0IHdlJ3JlIGNob29zaW5nIHRvIGtlZXBcbi8vIGEuKSB0byBlYXNlIDEueCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBkdWUgdG8gbG9zcyBvZiBgaXNgLCBhbmRcbi8vIGIuKSB0byBtYWludGFpbiBpZi9yZXBlYXQgY2FwYWJpbGl0eSBpbiBwYXJzZXItY29uc3RyYWluZWQgZWxlbWVudHNcbi8vICAgICAoZS5nLiB0YWJsZSwgc2VsZWN0KSBpbiBsaWV1IG9mIG5hdGl2ZSBDRSB0eXBlIGV4dGVuc2lvbnMgd2l0aG91dFxuLy8gICAgIG1hc3NpdmUgbmV3IGludmVudGlvbiBpbiB0aGlzIHNwYWNlIChlLmcuIGRpcmVjdGl2ZSBzeXN0ZW0pXG5jb25zdCB0ZW1wbGF0ZUV4dGVuc2lvbnMgPSB7XG4gICdkb20taWYnOiB0cnVlLFxuICAnZG9tLXJlcGVhdCc6IHRydWVcbn07XG5mdW5jdGlvbiB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSkge1xuICBsZXQgaXMgPSBub2RlLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgaWYgKGlzICYmIHRlbXBsYXRlRXh0ZW5zaW9uc1tpc10pIHtcbiAgICBsZXQgdCA9IG5vZGU7XG4gICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgbm9kZSA9IHQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzKTtcbiAgICB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIHQpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQodCk7XG4gICAgd2hpbGUodC5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUodC5hdHRyaWJ1dGVzWzBdLm5hbWUsIHQuYXR0cmlidXRlc1swXS52YWx1ZSk7XG4gICAgICB0LnJlbW92ZUF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvKSB7XG4gIC8vIHJlY3Vyc2l2ZWx5IGFzY2VuZCB0cmVlIHVudGlsIHdlIGhpdCByb290XG4gIGxldCBwYXJlbnQgPSBub2RlSW5mby5wYXJlbnRJbmZvICYmIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8ucGFyZW50SW5mbyk7XG4gIC8vIHVud2luZCB0aGUgc3RhY2ssIHJldHVybmluZyB0aGUgaW5kZXhlZCBub2RlIGF0IGVhY2ggbGV2ZWxcbiAgaWYgKHBhcmVudCkge1xuICAgIC8vIG5vdGU6IG1hcmdpbmFsbHkgZmFzdGVyIHRoYW4gaW5kZXhpbmcgdmlhIGNoaWxkTm9kZXNcbiAgICAvLyAoaHR0cDovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1sb29rdXApXG4gICAgZm9yIChsZXQgbj1wYXJlbnQuZmlyc3RDaGlsZCwgaT0wOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChub2RlSW5mby5wYXJlbnRJbmRleCA9PT0gaSsrKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxufVxuXG4vLyBjb25zdHJ1Y3QgYCRgIG1hcCAoZnJvbSBpZCBhbm5vdGF0aW9ucylcbmZ1bmN0aW9uIGFwcGx5SWRUb01hcChpbnN0LCBtYXAsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5pZCkge1xuICAgIG1hcFtub2RlSW5mby5pZF0gPSBub2RlO1xuICB9XG59XG5cbi8vIGluc3RhbGwgZXZlbnQgbGlzdGVuZXJzIChmcm9tIGV2ZW50IGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlFdmVudExpc3RlbmVyKGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5ldmVudHMgJiYgbm9kZUluZm8uZXZlbnRzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGo9MCwgZSQ9bm9kZUluZm8uZXZlbnRzLCBlOyAoajxlJC5sZW5ndGgpICYmIChlPWUkW2pdKTsgaisrKSB7XG4gICAgICBpbnN0Ll9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGUubmFtZSwgZS52YWx1ZSwgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHB1c2ggY29uZmlndXJhdGlvbiByZWZlcmVuY2VzIGF0IGNvbmZpZ3VyZSB0aW1lXG5mdW5jdGlvbiBhcHBseVRlbXBsYXRlQ29udGVudChpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICBpZiAobm9kZUluZm8udGVtcGxhdGVJbmZvKSB7XG4gICAgbm9kZS5fdGVtcGxhdGVJbmZvID0gbm9kZUluZm8udGVtcGxhdGVJbmZvO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBjb250ZXh0ID0gY29udGV4dC5fbWV0aG9kSG9zdCB8fCBjb250ZXh0O1xuICBsZXQgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoY29udGV4dFttZXRob2ROYW1lXSkge1xuICAgICAgY29udGV4dFttZXRob2ROYW1lXShlLCBlLmRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignbGlzdGVuZXIgbWV0aG9kIGAnICsgbWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFuZGxlcjtcbn1cblxuZXhwb3J0IGNvbnN0IFRlbXBsYXRlU3RhbXAgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9UZW1wbGF0ZVN0YW1wfVxuICAgKi9cbiAgY2xhc3MgVGVtcGxhdGVTdGFtcCBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogU2NhbnMgYSB0ZW1wbGF0ZSB0byBwcm9kdWNlIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogVGVtcGxhdGUtc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiB0aGUgb2JqZWN0IHJldHVybmVkLCBhbmQgbm9kZS1cbiAgICAgKiBzcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIG9iamVjdHMgaW4gaXRzIGZsYXR0ZW5lZCBgbm9kZUluZm9MaXN0YFxuICAgICAqIGFycmF5LiAgT25seSBub2RlcyBpbiB0aGUgdGVtcGxhdGUgdGhhdCB3ZXJlIHBhcnNlZCBhcyBub2RlcyBvZlxuICAgICAqIGludGVyZXN0IGNvbnRhaW4gYW4gb2JqZWN0IGluIGBub2RlSW5mb0xpc3RgLiAgRWFjaCBgbm9kZUluZm9gIG9iamVjdFxuICAgICAqIGNvbnRhaW5zIGFuIGBpbmRleGAgKGBjaGlsZE5vZGVzYCBpbmRleCBpbiBwYXJlbnQpIGFuZCBvcHRpb25hbGx5XG4gICAgICogYHBhcmVudGAsIHdoaWNoIHBvaW50cyB0byBub2RlIGluZm8gb2YgaXRzIHBhcmVudCAoaW5jbHVkaW5nIGl0cyBpbmRleCkuXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0IHJldHVybmVkIGZyb20gdGhpcyBtZXRob2QgaGFzIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBzdHJ1Y3R1cmUgKG1hbnkgZmllbGRzIG9wdGlvbmFsKTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogICB7XG4gICAgICogICAgIC8vIEZsYXR0ZW5lZCBsaXN0IG9mIG5vZGUgbWV0YWRhdGEgKGZvciBub2RlcyB0aGF0IGdlbmVyYXRlZCBtZXRhZGF0YSlcbiAgICAgKiAgICAgbm9kZUluZm9MaXN0OiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgLy8gYGlkYCBhdHRyaWJ1dGUgZm9yIGFueSBub2RlcyB3aXRoIGlkJ3MgZm9yIGdlbmVyYXRpbmcgYCRgIG1hcFxuICAgICAqICAgICAgICAgaWQ6IHtzdHJpbmd9LFxuICAgICAqICAgICAgICAgLy8gYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBtZXRhZGF0YVxuICAgICAqICAgICAgICAgZXZlbnRzOiBbXG4gICAgICogICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICBuYW1lOiB7c3RyaW5nfSwgICAvLyBldmVudCBuYW1lXG4gICAgICogICAgICAgICAgICAgdmFsdWU6IHtzdHJpbmd9LCAgLy8gaGFuZGxlciBtZXRob2QgbmFtZVxuICAgICAqICAgICAgICAgICB9LCAuLi5cbiAgICAgKiAgICAgICAgIF0sXG4gICAgICogICAgICAgICAvLyBOb3RlcyB3aGVuIHRoZSB0ZW1wbGF0ZSBjb250YWluZWQgYSBgPHNsb3Q+YCBmb3Igc2hhZHkgRE9NXG4gICAgICogICAgICAgICAvLyBvcHRpbWl6YXRpb24gcHVycG9zZXNcbiAgICAgKiAgICAgICAgIGhhc0luc2VydGlvblBvaW50OiB7Ym9vbGVhbn0sXG4gICAgICogICAgICAgICAvLyBGb3IgbmVzdGVkIGA8dGVtcGxhdGU+YGAgbm9kZXMsIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqICAgICAgICAgdGVtcGxhdGVJbmZvOiB7b2JqZWN0fSwgLy8gbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICAvLyBNZXRhZGF0YSB0byBhbGxvdyBlZmZpY2llbnQgcmV0cmlldmFsIG9mIGluc3RhbmNlZCBub2RlXG4gICAgICogICAgICAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIHBhcmVudEluZm86IHtudW1iZXJ9LCAgIC8vIHJlZmVyZW5jZSB0byBwYXJlbnQgbm9kZUluZm8+XG4gICAgICogICAgICAgICBwYXJlbnRJbmRleDoge251bWJlcn0sICAvLyBpbmRleCBpbiBwYXJlbnQncyBgY2hpbGROb2Rlc2AgY29sbGVjdGlvblxuICAgICAqICAgICAgICAgaW5mb0luZGV4OiB7bnVtYmVyfSwgICAgLy8gaW5kZXggb2YgdGhpcyBgbm9kZUluZm9gIGluIGB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0YFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAgLi4uXG4gICAgICogICAgIF0sXG4gICAgICogICAgIC8vIFdoZW4gdHJ1ZSwgdGhlIHRlbXBsYXRlIGhhZCB0aGUgYHN0cmlwLXdoaXRlc3BhY2VgIGF0dHJpYnV0ZVxuICAgICAqICAgICAvLyBvciB3YXMgbmVzdGVkIGluIGEgdGVtcGxhdGUgd2l0aCB0aGF0IHNldHRpbmdcbiAgICAgKiAgICAgc3RyaXBXaGl0ZXNwYWNlOiB7Ym9vbGVhbn0sXG4gICAgICogICAgIC8vIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCBpcyBtb3ZlZCBpbnRvXG4gICAgICogICAgIC8vIGEgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGhlcmU7IHRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvXG4gICAgICogICAgIC8vIGF2b2lkIHRoZSBjb3N0IG9mIG5lc3RlZCB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgICogICAgIGNvbnRlbnQ6IHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAqICAgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qga2lja3Mgb2ZmIGEgcmVjdXJzaXZlIHRyZWV3YWxrIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgICBfcGFyc2VUZW1wbGF0ZSA8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAgX3BhcnNlVGVtcGxhdGVDb250ZW50ICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZSAgPC0tLS0tLS0tLS0tLXwtLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlIC0tKyAgfFxuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyAtLS0tLS0tLS0rXG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlc1xuICAgICAqICAgICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBtZXRhZGF0YSBhYm91dCB0ZW1wbGF0ZXNcbiAgICAgKiB0byBlaXRoZXIgYHRlbXBsYXRlSW5mb2Agb3IgYG5vZGVJbmZvYC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgYmUgZGVzdHJ1Y3RpdmUgdG8gdGhlIHRlbXBsYXRlLCBpbiB0aGF0XG4gICAgICogZS5nLiBldmVudCBhbm5vdGF0aW9ucyBtYXkgYmUgcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmcm9tIHRoZSBvdXRlclxuICAgICAqICAgdGVtcGxhdGUsIGZvciBwYXJzaW5nIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBQYXJzZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUsIG91dGVyVGVtcGxhdGVJbmZvKSB7XG4gICAgICAvLyBzaW5jZSBhIHRlbXBsYXRlIG1heSBiZSByZS11c2VkLCBtZW1vLWl6ZSBtZXRhZGF0YVxuICAgICAgaWYgKCF0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvID0ge307XG4gICAgICAgIHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QgPSBbXTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSA9XG4gICAgICAgICAgKG91dGVyVGVtcGxhdGVJbmZvICYmIG91dGVyVGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSkgfHxcbiAgICAgICAgICB0ZW1wbGF0ZS5oYXNBdHRyaWJ1dGUoJ3N0cmlwLXdoaXRlc3BhY2UnKTtcbiAgICAgICAgdGhpcy5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywge3BhcmVudDogbnVsbH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlLl90ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGFuZCBhZGRzIHRlbXBsYXRlIGFuZCBub2RlIG1ldGFkYXRhIGJhc2VkIG9uXG4gICAgICogdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGl0cyBgY2hpbGROb2Rlc2AgYW5kIGBhdHRyaWJ1dGVzYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbm9kZSBvciB0ZW1wbGF0ZSBzcGVjaWZpY1xuICAgICAqIG1ldGFkYXRhIGJhc2VkIG9uIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQ7XG4gICAgICBsZXQgZWxlbWVudCA9IC8qKiBAdHlwZSBFbGVtZW50ICovKG5vZGUpO1xuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdwcmVzZXJ2ZS1jb250ZW50JykpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgLy8gRm9yIFNoYWR5RG9tIG9wdGltaXphdGlvbiwgaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZXMgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIGNoaWxkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyB3cmFwcyB3aGl0ZWxpc3RlZCBsZWdhY3kgdGVtcGxhdGUgZXh0ZW5zaW9uc1xuICAgICAqIChgaXM9XCJkb20taWZcImAgYW5kIGBpcz1cImRvbS1yZXBlYXRcImApIHdpdGggdGhlaXIgZXF1aXZhbGVudCBlbGVtZW50XG4gICAgICogd3JhcHBlcnMsIGNvbGxhcHNlcyB0ZXh0IG5vZGVzLCBhbmQgc3RyaXBzIHdoaXRlc3BhY2UgZnJvbSB0aGUgdGVtcGxhdGVcbiAgICAgKiBpZiB0aGUgYHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlc3BhY2VgIHNldHRpbmcgd2FzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSByb290IFJvb3Qgbm9kZSB3aG9zZSBgY2hpbGROb2Rlc2Agd2lsbCBiZSBwYXJzZWRcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMocm9vdCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgZm9yIChsZXQgbm9kZT1yb290LmZpcnN0Q2hpbGQsIHBhcmVudEluZGV4PTAsIG5leHQ7IG5vZGU7IG5vZGU9bmV4dCkge1xuICAgICAgICAvLyBXcmFwIHRlbXBsYXRlc1xuICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIG5vZGUgPSB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29sbGFwc2UgYWRqYWNlbnQgdGV4dE5vZGVzOiBmaXhlcyBhbiBJRSBpc3N1ZSB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAvLyB0ZXh0IG5vZGVzIHRvIGJlIGluZXhwbGljYWJseSBzcGxpdCA9KFxuICAgICAgICAvLyBub3RlIHRoYXQgcm9vdC5ub3JtYWxpemUoKSBzaG91bGQgd29yayBidXQgZG9lcyBub3Qgc28gd2UgZG8gdGhpc1xuICAgICAgICAvLyBtYW51YWxseS5cbiAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGxldCAvKiogTm9kZSAqLyBuID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAobiAmJiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpKSB7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ICs9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBuZXh0ID0gbi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgICBuID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3B0aW9uYWxseSBzdHJpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgJiYgIW5vZGUudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZEluZm8gPSB7IHBhcmVudEluZGV4LCBwYXJlbnRJbmZvOiBub2RlSW5mbyB9O1xuICAgICAgICBpZiAodGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBjaGlsZEluZm8pKSB7XG4gICAgICAgICAgY2hpbGRJbmZvLmluZm9JbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QucHVzaCgvKiogQHR5cGUgeyFOb2RlSW5mb30gKi8oY2hpbGRJbmZvKSkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluY3JlbWVudCBpZiBub3QgcmVtb3ZlZFxuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcGFyZW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjb250ZW50IGZvciB0aGUgZ2l2ZW4gbmVzdGVkIGA8dGVtcGxhdGU+YC5cbiAgICAgKlxuICAgICAqIE5lc3RlZCB0ZW1wbGF0ZSBpbmZvIGlzIHN0b3JlZCBhcyBgdGVtcGxhdGVJbmZvYCBpbiB0aGUgY3VycmVudCBub2RlJ3NcbiAgICAgKiBgbm9kZUluZm9gLiBgdGVtcGxhdGUuY29udGVudGAgaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIGB0ZW1wbGF0ZUluZm9gLlxuICAgICAqIEl0IHdpbGwgdGhlbiBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGhvc3QgdG8gc2V0IGl0IGJhY2sgdG8gdGhlXG4gICAgICogdGVtcGxhdGUgYW5kIGZvciB1c2VycyBzdGFtcGluZyBuZXN0ZWQgdGVtcGxhdGVzIHRvIHVzZSB0aGVcbiAgICAgKiBgX2NvbnRlbnRGb3JUZW1wbGF0ZWAgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBjb250ZW50IGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICogKGFuIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlIChhIDx0ZW1wbGF0ZT4pXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogICB0aGF0IGluY2x1ZGVzIHRoZSB0ZW1wbGF0ZSBgbm9kZWBcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fcGFyc2VUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbyk7XG4gICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50ID1cbiAgICAgICAgbm9kZS5jb250ZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlLmNvbnRlbnQpO1xuICAgICAgbm9kZUluZm8udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlcyBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBmb3Igbm9kZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAvLyBNYWtlIGNvcHkgb2Ygb3JpZ2luYWwgYXR0cmlidXRlIGxpc3QsIHNpbmNlIHRoZSBvcmRlciBtYXkgY2hhbmdlXG4gICAgICAvLyBhcyBhdHRyaWJ1dGVzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZFxuICAgICAgbGV0IG5vdGVkID0gZmFsc2U7XG4gICAgICBsZXQgYXR0cnMgPSBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcyk7XG4gICAgICBmb3IgKGxldCBpPWF0dHJzLmxlbmd0aC0xLCBhOyAoYT1hdHRyc1tpXSk7IGktLSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGEubmFtZSwgYS52YWx1ZSkgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2luZ2xlIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG9cbiAgICAgKiBgbm9kZUluZm9gIGZvciBhdHRyaWJ1dGVzIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBhZGRzIG1ldGFkYXRhIGZvciBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIGF0dHJpYnV0ZXNcbiAgICAgKiBhbmQgYGlkYCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAvLyBldmVudHMgKG9uLSopXG4gICAgICBpZiAobmFtZS5zbGljZSgwLCAzKSA9PT0gJ29uLScpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIG5vZGVJbmZvLmV2ZW50cyA9IG5vZGVJbmZvLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgbm9kZUluZm8uZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUuc2xpY2UoMyksXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIGlkXG4gICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgIG5vZGVJbmZvLmlkID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBjb250ZW50YCBkb2N1bWVudCBmcmFnbWVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBQb2x5bWVyIHBlcmZvcm1zIGFuIG9wdGltaXphdGlvbiB0byBjYWNoZSBuZXN0ZWRcbiAgICAgKiB0ZW1wbGF0ZSBjb250ZW50IHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgZGVlcGx5IG5lc3RlZCB0ZW1wbGF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgcmV0cmlldmVzIHRoZSBjYWNoZWQgY29udGVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcmV0cmlldmUgYGNvbnRlbnRgIGZvclxuICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IENvbnRlbnQgZnJhZ21lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudFdpdGhJbmZvfSAqLyAodGVtcGxhdGUpLl90ZW1wbGF0ZUluZm87XG4gICAgICByZXR1cm4gKHRlbXBsYXRlSW5mbyAmJiB0ZW1wbGF0ZUluZm8uY29udGVudCkgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGNvbnRlbnQgYW5kIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGNsb25lZCBkb20uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgaXMgcGFyc2VkIChvbmNlIGFuZCBtZW1vaXplZCkgdXNpbmcgdGhpcyBsaWJyYXJ5J3NcbiAgICAgKiB0ZW1wbGF0ZSBwYXJzaW5nIGZlYXR1cmVzLCBhbmQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyB2YWx1ZS1hZGRlZFxuICAgICAqIGZlYXR1cmVzOlxuICAgICAqICogQWRkcyBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqICogR2VuZXJhdGVzIGFuIFwiaWQgbWFwXCIgZm9yIGFsbCBub2RlcyB3aXRoIGlkJ3MgdW5kZXIgYCRgIG9uIHJldHVybmVkXG4gICAgICogICBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqICogUGFzc2VzIHRlbXBsYXRlIGluZm8gaW5jbHVkaW5nIGBjb250ZW50YCBiYWNrIHRvIHRlbXBsYXRlcyBhc1xuICAgICAqICAgYF90ZW1wbGF0ZUluZm9gIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0byBhdm9pZCBkZWVwIHRlbXBsYXRlXG4gICAgICogICBjbG9uaW5nKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBtZW1vaXplZCB0ZW1wbGF0ZSBwYXJzaW5nIHByb2Nlc3MgaXMgZGVzdHJ1Y3RpdmUgdG8gdGhlXG4gICAgICogdGVtcGxhdGU6IGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmdzIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgYXJlXG4gICAgICogcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiBub3RlcywgYW5kIGFueSBuZXN0ZWQgYDx0ZW1wbGF0ZT4uY29udGVudGBcbiAgICAgKiBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gbm90ZXMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKi9cbiAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgLy8gUG9seWZpbGwgc3VwcG9ydDogYm9vdHN0cmFwIHRoZSB0ZW1wbGF0ZSBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlblxuICAgICAgaWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb250ZW50ICYmXG4gICAgICAgICAgd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSkge1xuICAgICAgICBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGxldCBub2RlSW5mbyA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3Q7XG4gICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50IHx8IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIERvY3VtZW50RnJhZ21lbnQgKi8gKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgLy8gTk9URTogU2hhZHlEb20gb3B0aW1pemF0aW9uIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICBkb20uX19ub0luc2VydGlvblBvaW50ID0gIXRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludDtcbiAgICAgIGxldCBub2RlcyA9IGRvbS5ub2RlTGlzdCA9IG5ldyBBcnJheShub2RlSW5mby5sZW5ndGgpO1xuICAgICAgZG9tLiQgPSB7fTtcbiAgICAgIGZvciAobGV0IGk9MCwgbD1ub2RlSW5mby5sZW5ndGgsIGluZm87IChpPGwpICYmIChpbmZvPW5vZGVJbmZvW2ldKTsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV0gPSBmaW5kVGVtcGxhdGVOb2RlKGRvbSwgaW5mbyk7XG4gICAgICAgIGFwcGx5SWRUb01hcCh0aGlzLCBkb20uJCwgbm9kZSwgaW5mbyk7XG4gICAgICAgIGFwcGx5VGVtcGxhdGVDb250ZW50KHRoaXMsIG5vZGUsIGluZm8pO1xuICAgICAgICBhcHBseUV2ZW50TGlzdGVuZXIodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHshU3RhbXBlZFRlbXBsYXRlfSAqLyhkb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgYnkgbWV0aG9kIG5hbWUgZm9yIHRoZSBldmVudCBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCBsb29rcyB1cCB0aGUgbWV0aG9kXG4gICAgICogbmFtZSBhdCBoYW5kbGluZyB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGxpc3RlbmVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2RcbiAgICAgKiBAcGFyYW0geyo9fSBjb250ZXh0IENvbnRleHQgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiAoZGVmYXVsdHNcbiAgICAgKiAgIHRvIGBub2RlYClcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gR2VuZXJhdGVkIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG5vZGU7XG4gICAgICBsZXQgaGFuZGxlciA9IGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBldmVudCBsaXN0ZW5lciB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gYWRkXG4gICAgICovXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFRlbXBsYXRlU3RhbXA7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvdGVtcGxhdGUtc3RhbXAuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9jb2xvci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCB7IFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGFmdGVyTmV4dFJlbmRlciB9IGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMnO1xuaW1wb3J0IHsgc2V0VG91Y2hBY3Rpb24gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5qcyc7XG5pbXBvcnQgeyBQYXBlclJpcHBsZUJlaGF2aW9yIH0gZnJvbSAnLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci10b2dnbGUtYnV0dG9uXCI+XG4gIDx0ZW1wbGF0ZSBzdHJpcC13aGl0ZXNwYWNlPVwiXCI+XG5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWhvcml6b250YWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXI7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KDpmb2N1cykge1xuICAgICAgICBvdXRsaW5lOm5vbmU7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtYmFyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgbGluZWFyIC4wOHM7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJhci1jb2xvciwgIzAwMDAwMCk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtYmFyO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWJ1dHRvbiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtM3B4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBoZWlnaHQ6IDIwcHg7XG4gICAgICAgIHdpZHRoOiAyMHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICAgICAgdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gbGluZWFyIC4wOHMsIGJhY2tncm91bmQtY29sb3IgbGluZWFyIC4wOHM7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSBsaW5lYXIgLjA4cywgYmFja2dyb3VuZC1jb2xvciBsaW5lYXIgLjA4cztcbiAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtYnV0dG9uLWNvbG9yLCB2YXIoLS1wYXBlci1ncmV5LTUwKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWJ1dHRvbi5kcmFnZ2luZyB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogbm9uZTtcbiAgICAgICAgdHJhbnNpdGlvbjogbm9uZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdOm5vdChbZGlzYWJsZWRdKSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1iYXItY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYmFyO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAudG9nZ2xlLWJhciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XG4gICAgICAgIG9wYWNpdHk6IDAuMTI7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKDE2cHgsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxNnB4LCAwKTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdOm5vdChbZGlzYWJsZWRdKSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYnV0dG9uLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmRiZGJkO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWluayB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtMTRweDtcbiAgICAgICAgbGVmdDogLTE0cHg7XG4gICAgICAgIHJpZ2h0OiBhdXRvO1xuICAgICAgICBib3R0b206IGF1dG87XG4gICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1pbmstY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWluaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdKSAudG9nZ2xlLWluayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtaW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWluaztcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDM2cHg7XG4gICAgICAgIGhlaWdodDogMTRweDtcbiAgICAgICAgLyogVGhlIHRvZ2dsZSBidXR0b24gaGFzIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mIC0zcHg7IFRoZSBleHRyYSAxcHhcbiAgICAgICAgLyogYWNjb3VudHMgZm9yIHRoZSB0b2dnbGUgYnV0dG9uIHNoYWRvdyBib3guICovXG4gICAgICAgIG1hcmdpbjogNHB4IDFweDtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1sYWJlbCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tbGFiZWwtc3BhY2luZywgOHB4KTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWxhYmVsLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgLyogaW52YWxpZCBzdGF0ZSAqL1xuICAgICAgOmhvc3QoW2ludmFsaWRdKSAudG9nZ2xlLWJhciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24taW52YWxpZC1iYXItY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtYnV0dG9uLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaW52YWxpZF0pIC50b2dnbGUtaW5rIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24taW52YWxpZC1pbmstY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgY2xhc3M9XCJ0b2dnbGUtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGlkPVwidG9nZ2xlQmFyXCIgY2xhc3M9XCJ0b2dnbGUtYmFyXCI+PC9kaXY+XG4gICAgICA8ZGl2IGlkPVwidG9nZ2xlQnV0dG9uXCIgY2xhc3M9XCJ0b2dnbGUtYnV0dG9uXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidG9nZ2xlLWxhYmVsXCI+PHNsb3Q+PC9zbG90PjwvZGl2PlxuXG4gIDwvdGVtcGxhdGU+XG5cbiAgXG48L2RvbS1tb2R1bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblBvbHltZXIoe1xuICBpczogJ3BhcGVyLXRvZ2dsZS1idXR0b24nLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvclxuICBdLFxuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgcm9sZTogJ2J1dHRvbicsXG4gICAgJ2FyaWEtcHJlc3NlZCc6ICdmYWxzZScsXG4gICAgdGFiaW5kZXg6IDBcbiAgfSxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWNoYW5nZVxuICAgICAqL1xuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgIHRyYWNrOiAnX29udHJhY2snXG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGFmdGVyTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRvdWNoQWN0aW9uKHRoaXMsICdwYW4teScpO1xuICAgIH0pO1xuICB9LFxuXG4gIF9vbnRyYWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0cmFjayA9IGV2ZW50LmRldGFpbDtcbiAgICBpZiAodHJhY2suc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMuX3RyYWNrU3RhcnQodHJhY2spO1xuICAgIH0gZWxzZSBpZiAodHJhY2suc3RhdGUgPT09ICd0cmFjaycpIHtcbiAgICAgIHRoaXMuX3RyYWNrTW92ZSh0cmFjayk7XG4gICAgfSBlbHNlIGlmICh0cmFjay5zdGF0ZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHRoaXMuX3RyYWNrRW5kKHRyYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgX3RyYWNrU3RhcnQ6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLiQudG9nZ2xlQmFyLm9mZnNldFdpZHRoIC8gMjtcbiAgICAvKlxuICAgICAqIGtlZXAgYW4gdHJhY2stb25seSBjaGVjayBzdGF0ZSB0byBrZWVwIHRoZSBkcmFnZ2luZyBiZWhhdmlvciBzbW9vdGhcbiAgICAgKiB3aGlsZSB0b2dnbGluZyBhY3RpdmF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuX3RyYWNrQ2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcbiAgICB0aGlzLiQudG9nZ2xlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2RyYWdnaW5nJyk7XG4gIH0sXG5cbiAgX3RyYWNrTW92ZTogZnVuY3Rpb24odHJhY2spIHtcbiAgICB2YXIgZHggPSB0cmFjay5keDtcbiAgICB0aGlzLl94ID0gTWF0aC5taW4odGhpcy5fd2lkdGgsXG4gICAgICAgIE1hdGgubWF4KDAsIHRoaXMuX3RyYWNrQ2hlY2tlZCA/IHRoaXMuX3dpZHRoICsgZHggOiBkeCkpO1xuICAgIHRoaXMudHJhbnNsYXRlM2QodGhpcy5feCArICdweCcsIDAsIDAsIHRoaXMuJC50b2dnbGVCdXR0b24pO1xuICAgIHRoaXMuX3VzZXJBY3RpdmF0ZSh0aGlzLl94ID4gKHRoaXMuX3dpZHRoIC8gMikpO1xuICB9LFxuXG4gIF90cmFja0VuZDogZnVuY3Rpb24odHJhY2spIHtcbiAgICB0aGlzLiQudG9nZ2xlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnaW5nJyk7XG4gICAgdGhpcy50cmFuc2Zvcm0oJycsIHRoaXMuJC50b2dnbGVCdXR0b24pO1xuICB9LFxuXG4gIC8vIGN1c3RvbWl6ZSB0aGUgZWxlbWVudCdzIHJpcHBsZVxuICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yaXBwbGVDb250YWluZXIgPSB0aGlzLiQudG9nZ2xlQnV0dG9uO1xuICAgIHZhciByaXBwbGUgPSBQYXBlclJpcHBsZUJlaGF2aW9yLl9jcmVhdGVSaXBwbGUoKTtcbiAgICByaXBwbGUuaWQgPSAnaW5rJztcbiAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdyZWNlbnRlcnMnLCAnJyk7XG4gICAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ2NpcmNsZScsICd0b2dnbGUtaW5rJyk7XG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfVxuXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXBwbHlTaGltIGZyb20gJy4uL3NyYy9hcHBseS1zaGltLmpzJztcbmltcG9ydCB0ZW1wbGF0ZU1hcCBmcm9tICcuLi9zcmMvdGVtcGxhdGUtbWFwLmpzJztcbmltcG9ydCB7Z2V0SXNFeHRlbmRzLCB0b0Nzc1RleHR9IGZyb20gJy4uL3NyYy9zdHlsZS11dGlsLmpzJztcbmltcG9ydCAqIGFzIEFwcGx5U2hpbVV0aWxzIGZyb20gJy4uL3NyYy9hcHBseS1zaGltLXV0aWxzLmpzJztcbmltcG9ydCBkb2N1bWVudFdhaXQgZnJvbSAnLi4vc3JjL2RvY3VtZW50LXdhaXQuanMnO1xuaW1wb3J0IHtnZXRDb21wdXRlZFN0eWxlVmFsdWUsIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXN9IGZyb20gJy4uL3NyYy9jb21tb24tdXRpbHMuanMnO1xuaW1wb3J0IHtDdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZX0gZnJvbSAnLi4vc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQge25hdGl2ZUNzc1ZhcmlhYmxlcywgbmF0aXZlU2hhZG93fSBmcm9tICcuLi9zcmMvc3R5bGUtc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtBcHBseVNoaW19ICovXG5jb25zdCBhcHBseVNoaW0gPSBuZXcgQXBwbHlTaGltKCk7XG5cbmNsYXNzIEFwcGx5U2hpbUludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7P0N1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlfSAqL1xuICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBudWxsO1xuICAgIGRvY3VtZW50V2FpdCgoKSA9PiB7XG4gICAgICB0aGlzLmVuc3VyZSgpO1xuICAgIH0pO1xuICAgIGFwcGx5U2hpbVsnaW52YWxpZENhbGxiYWNrJ10gPSBBcHBseVNoaW1VdGlscy5pbnZhbGlkYXRlO1xuICB9XG4gIGVuc3VyZSgpIHtcbiAgICBpZiAodGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuICAgIGlmICh0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWyd0cmFuc2Zvcm1DYWxsYmFjayddID0gKHN0eWxlKSA9PiB7XG4gICAgICAgIGFwcGx5U2hpbS50cmFuc2Zvcm1DdXN0b21TdHlsZShzdHlsZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsndmFsaWRhdGVDYWxsYmFjayddID0gKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKi9cbiAgcHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSkge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdID0gdGVtcGxhdGU7XG4gICAgbGV0IGFzdCA9IGFwcGx5U2hpbS50cmFuc2Zvcm1UZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpO1xuICAgIC8vIHNhdmUgb3JpZ2luYWwgc3R5bGUgYXN0IHRvIHVzZSBmb3IgcmV2YWxpZGF0aW5nIGluc3RhbmNlc1xuICAgIHRlbXBsYXRlWydfc3R5bGVBc3QnXSA9IGFzdDtcbiAgfVxuICBmbHVzaEN1c3RvbVN0eWxlcygpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIGlmICghdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3R5bGVzID0gdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsncHJvY2Vzc1N0eWxlcyddKCk7XG4gICAgaWYgKCF0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgbGV0IGNzID0gc3R5bGVzW2ldO1xuICAgICAgbGV0IHN0eWxlID0gdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSddKGNzKTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBhcHBseVNoaW0udHJhbnNmb3JtQ3VzdG9tU3R5bGUoc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgbGV0IHNoYWRvd0NoaWxkcmVuID0gZWxlbWVudC5zaGFkb3dSb290LmNoaWxkcmVuIHx8IGVsZW1lbnQuc2hhZG93Um9vdC5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFkb3dDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnN0eWxlU3VidHJlZSgvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhzaGFkb3dDaGlsZHJlbltpXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuIHx8IGVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zdHlsZVN1YnRyZWUoLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oY2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHN0eWxlRWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICBsZXQge2lzfSA9IGdldElzRXh0ZW5kcyhlbGVtZW50KTtcbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtpc107XG4gICAgaWYgKHRlbXBsYXRlICYmICFBcHBseVNoaW1VdGlscy50ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpKSB7XG4gICAgICAvLyBvbmx5IHJldmFsaWRhdGUgdGVtcGxhdGUgb25jZVxuICAgICAgaWYgKCFBcHBseVNoaW1VdGlscy50ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGlzKTtcbiAgICAgICAgQXBwbHlTaGltVXRpbHMuc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIHRoaXMgZWxlbWVudCBpbnN0YW5jZVxuICAgICAgbGV0IHJvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICBsZXQgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKHJvb3QucXVlcnlTZWxlY3Rvcignc3R5bGUnKSk7XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgIC8vIHJldXNlIHRoZSB0ZW1wbGF0ZSdzIHN0eWxlIGFzdCwgaXQgaGFzIGFsbCB0aGUgb3JpZ2luYWwgY3NzIHRleHRcbiAgICAgICAgICBzdHlsZVsnX19jc3NSdWxlcyddID0gdGVtcGxhdGVbJ19zdHlsZUFzdCddO1xuICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdG9Dc3NUZXh0KHRlbXBsYXRlWydfc3R5bGVBc3QnXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdHlsZURvY3VtZW50KHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIHRoaXMuc3R5bGVTdWJ0cmVlKGRvY3VtZW50LmJvZHksIHByb3BlcnRpZXMpO1xuICB9XG59XG5cbmlmICghd2luZG93LlNoYWR5Q1NTIHx8ICF3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pIHtcbiAgY29uc3QgYXBwbHlTaGltSW50ZXJmYWNlID0gbmV3IEFwcGx5U2hpbUludGVyZmFjZSgpO1xuICBsZXQgQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG4gIHdpbmRvdy5TaGFkeUNTUyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZWxlbWVudEV4dGVuZHNcbiAgICAgKi9cbiAgICBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lLCBlbGVtZW50RXh0ZW5kcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0eWxlU3VidHJlZShlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5zdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgc3R5bGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnN0eWxlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5zdHlsZURvY3VtZW50KHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgICB9LFxuICAgIG5hdGl2ZUNzczogbmF0aXZlQ3NzVmFyaWFibGVzLFxuICAgIG5hdGl2ZVNoYWRvdzogbmF0aXZlU2hhZG93XG4gIH07XG5cbiAgaWYgKEN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG4gIH1cbn1cblxud2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSA9IGFwcGx5U2hpbTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2FwcGx5LXNoaW0uanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuLypcbiAqIFRoZSBhcHBseSBzaGltIHNpbXVsYXRlcyB0aGUgYmVoYXZpb3Igb2YgYEBhcHBseWAgcHJvcG9zZWQgYXRcbiAqIGh0dHBzOi8vdGFiYXRraW5zLmdpdGh1Yi5pby9zcGVjcy9jc3MtYXBwbHktcnVsZS8uXG4gKiBUaGUgYXBwcm9hY2ggaXMgdG8gY29udmVydCBhIHByb3BlcnR5IGxpa2UgdGhpczpcbiAqXG4gKiAgICAtLWZvbzoge2NvbG9yOiByZWQ7IGJhY2tncm91bmQ6IGJsdWU7fVxuICpcbiAqIHRvIHRoaXM6XG4gKlxuICogICAgLS1mb29fLV9jb2xvcjogcmVkO1xuICogICAgLS1mb29fLV9iYWNrZ3JvdW5kOiBibHVlO1xuICpcbiAqIFRoZW4gd2hlcmUgYEBhcHBseSAtLWZvb2AgaXMgdXNlZCwgdGhhdCBpcyBjb252ZXJ0ZWQgdG86XG4gKlxuICogICAgY29sb3I6IHZhcigtLWZvb18tX2NvbG9yKTtcbiAqICAgIGJhY2tncm91bmQ6IHZhcigtLWZvb18tX2JhY2tncm91bmQpO1xuICpcbiAqIFRoaXMgYXBwcm9hY2ggZ2VuZXJhbGx5IHdvcmtzIGJ1dCB0aGVyZSBhcmUgc29tZSBpc3N1ZXMgYW5kIGxpbWl0YXRpb25zLlxuICogQ29uc2lkZXIsIGZvciBleGFtcGxlLCB0aGF0IHNvbWV3aGVyZSAqYmV0d2Vlbiogd2hlcmUgYC0tZm9vYCBpcyBzZXQgYW5kIHVzZWQsXG4gKiBhbm90aGVyIGVsZW1lbnQgc2V0cyBpdCB0bzpcbiAqXG4gKiAgICAtLWZvbzogeyBib3JkZXI6IDJweCBzb2xpZCByZWQ7IH1cbiAqXG4gKiBXZSBtdXN0IG5vdyBlbnN1cmUgdGhhdCB0aGUgY29sb3IgYW5kIGJhY2tncm91bmQgZnJvbSB0aGUgcHJldmlvdXMgc2V0dGluZ1xuICogZG8gbm90IGFwcGx5LiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBjaGFuZ2luZyB0aGUgcHJvcGVydHkgc2V0IHRvIHRoaXM6XG4gKlxuICogICAgLS1mb29fLV9ib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gKiAgICAtLWZvb18tX2NvbG9yOiBpbml0aWFsO1xuICogICAgLS1mb29fLV9iYWNrZ3JvdW5kOiBpbml0aWFsO1xuICpcbiAqIFRoaXMgd29ya3MgYnV0IGludHJvZHVjZXMgb25lIG5ldyBpc3N1ZS5cbiAqIENvbnNpZGVyIHRoaXMgc2V0dXAgYXQgdGhlIHBvaW50IHdoZXJlIHRoZSBgQGFwcGx5YCBpcyB1c2VkOlxuICpcbiAqICAgIGJhY2tncm91bmQ6IG9yYW5nZTtcbiAqICAgIGBAYXBwbHlgIC0tZm9vO1xuICpcbiAqIEluIHRoaXMgY2FzZSB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIHVuc2V0IChpbml0aWFsKSByYXRoZXIgdGhhbiB0aGUgZGVzaXJlZFxuICogYG9yYW5nZWAuIFdlIGFkZHJlc3MgdGhpcyBieSBhbHRlcmluZyB0aGUgcHJvcGVydHkgc2V0IHRvIHVzZSBhIGZhbGxiYWNrXG4gKiB2YWx1ZSBsaWtlIHRoaXM6XG4gKlxuICogICAgY29sb3I6IHZhcigtLWZvb18tX2NvbG9yKTtcbiAqICAgIGJhY2tncm91bmQ6IHZhcigtLWZvb18tX2JhY2tncm91bmQsIG9yYW5nZSk7XG4gKiAgICBib3JkZXI6IHZhcigtLWZvb18tX2JvcmRlcik7XG4gKlxuICogTm90ZSB0aGF0IHRoZSBkZWZhdWx0IGlzIHJldGFpbmVkIGluIHRoZSBwcm9wZXJ0eSBzZXQgYW5kIHRoZSBgYmFja2dyb3VuZGAgaXNcbiAqIHRoZSBkZXNpcmVkIGBvcmFuZ2VgLiBUaGlzIGxlYWRzIHVzIHRvIGEgbGltaXRhdGlvbi5cbiAqXG4gKiBMaW1pdGF0aW9uIDE6XG5cbiAqIE9ubHkgcHJvcGVydGllcyBpbiB0aGUgcnVsZSB3aGVyZSB0aGUgYEBhcHBseWBcbiAqIGlzIHVzZWQgYXJlIGNvbnNpZGVyZWQgYXMgZGVmYXVsdCB2YWx1ZXMuXG4gKiBJZiBhbm90aGVyIHJ1bGUgbWF0Y2hlcyB0aGUgZWxlbWVudCBhbmQgc2V0cyBgYmFja2dyb3VuZGAgd2l0aFxuICogbGVzcyBzcGVjaWZpY2l0eSB0aGFuIHRoZSBydWxlIGluIHdoaWNoIGBAYXBwbHlgIGFwcGVhcnMsXG4gKiB0aGUgYGJhY2tncm91bmRgIHdpbGwgbm90IGJlIHNldC5cbiAqXG4gKiBMaW1pdGF0aW9uIDI6XG4gKlxuICogV2hlbiB1c2luZyBQb2x5bWVyJ3MgYHVwZGF0ZVN0eWxlc2AgYXBpLCBuZXcgcHJvcGVydGllcyBtYXkgbm90IGJlIHNldCBmb3JcbiAqIGBAYXBwbHlgIHByb3BlcnRpZXMuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtmb3JFYWNoUnVsZSwgcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2ssIHJ1bGVzRm9yU3R5bGUsIHRvQ3NzVGV4dH0gZnJvbSAnLi9zdHlsZS11dGlsLmpzJztcbmltcG9ydCB7TUlYSU5fTUFUQ0gsIFZBUl9BU1NJR059IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcbmltcG9ydCB7ZGV0ZWN0TWl4aW59IGZyb20gJy4vY29tbW9uLXV0aWxzLmpzJztcbmltcG9ydCB7U3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuY29uc3QgQVBQTFlfTkFNRV9DTEVBTiA9IC87XFxzKi9tO1xuY29uc3QgSU5JVElBTF9JTkhFUklUID0gL15cXHMqKGluaXRpYWwpfChpbmhlcml0KVxccyokLztcblxuLy8gc2VwYXJhdG9yIHVzZWQgYmV0d2VlbiBtaXhpbi1uYW1lIGFuZCBtaXhpbi1wcm9wZXJ0eS1uYW1lIHdoZW4gcHJvZHVjaW5nIHByb3BlcnRpZXNcbi8vIE5PVEU6IHBsYWluICctJyBtYXkgY2F1c2UgY29sbGlzaW9ucyBpbiB1c2VyIHN0eWxlc1xuY29uc3QgTUlYSU5fVkFSX1NFUCA9ICdfLV8nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xubGV0IFByb3BlcnR5RW50cnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBAdHlwZWRlZiB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5sZXQgRGVwZW5kYW50c0VudHJ5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKiBAdHlwZWRlZiB7e1xuICogICAgcHJvcGVydGllczogUHJvcGVydHlFbnRyeSxcbiAqICAgIGRlcGVuZGFudHM6IERlcGVuZGFudHNFbnRyeVxuICogfX1cbiAqL1xubGV0IE1peGluTWFwRW50cnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLy8gbWFwIG9mIG1peGluIHRvIHByb3BlcnR5IG5hbWVzXG4vLyAtLWZvbzoge2JvcmRlcjogMnB4fSAtPiB7cHJvcGVydGllczogeygtLWZvbywgWydib3JkZXInXSl9LCBkZXBlbmRhbnRzOiB7J2VsZW1lbnQtbmFtZSc6IHByb3RvfX1cbmNsYXNzIE1peGluTWFwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU1peGluTWFwRW50cnk+fSAqL1xuICAgIHRoaXMuX21hcCA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVudHJ5fSBwcm9wc1xuICAgKi9cbiAgc2V0KG5hbWUsIHByb3BzKSB7XG4gICAgbmFtZSA9IG5hbWUudHJpbSgpO1xuICAgIHRoaXMuX21hcFtuYW1lXSA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHByb3BzLFxuICAgICAgZGVwZW5kYW50czoge31cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge01peGluTWFwRW50cnl9XG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIG5hbWUgPSBuYW1lLnRyaW0oKTtcbiAgICByZXR1cm4gdGhpcy5fbWFwW25hbWVdIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIG1hcmtlZCBpbnZhbGlkXG4gKiBAdHlwZSB7P2Z1bmN0aW9uKHN0cmluZyl9XG4gKi9cbmxldCBpbnZhbGlkQ2FsbGJhY2sgPSBudWxsO1xuXG4vKiogQHVucmVzdHJpY3RlZCAqL1xuY2xhc3MgQXBwbHlTaGltIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0hUTUxNZXRhRWxlbWVudH0gKi9cbiAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1peGluTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybiB0cnVlIGlmIGBjc3NUZXh0YCBjb250YWlucyBhIG1peGluIGRlZmluaXRpb24gb3IgY29uc3VtcHRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGRldGVjdE1peGluKGNzc1RleHQpIHtcbiAgICByZXR1cm4gZGV0ZWN0TWl4aW4oY3NzVGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gICAqL1xuICB0cmFuc2Zvcm1UZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpIHtcbiAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8odGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKTtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICBsZXQgYXN0ID0gbnVsbDtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIGFzdCA9IHRoaXMudHJhbnNmb3JtU3R5bGUoc3R5bGUsIGVsZW1lbnROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAgICovXG4gIHRyYW5zZm9ybVN0eWxlKHN0eWxlLCBlbGVtZW50TmFtZSA9ICcnKSB7XG4gICAgbGV0IGFzdCA9IHJ1bGVzRm9yU3R5bGUoc3R5bGUpO1xuICAgIHRoaXMudHJhbnNmb3JtUnVsZXMoYXN0LCBlbGVtZW50TmFtZSk7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSB0b0Nzc1RleHQoYXN0KTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICAgKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gICAqL1xuICB0cmFuc2Zvcm1DdXN0b21TdHlsZShzdHlsZSkge1xuICAgIGxldCBhc3QgPSBydWxlc0ZvclN0eWxlKHN0eWxlKTtcbiAgICBmb3JFYWNoUnVsZShhc3QsIChydWxlKSA9PiB7XG4gICAgICBpZiAocnVsZVsnc2VsZWN0b3InXSA9PT0gJzpyb290Jykge1xuICAgICAgICBydWxlWydzZWxlY3RvciddID0gJ2h0bWwnO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm1SdWxlKHJ1bGUpO1xuICAgIH0pXG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSB0b0Nzc1RleHQoYXN0KTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqL1xuICB0cmFuc2Zvcm1SdWxlcyhydWxlcywgZWxlbWVudE5hbWUpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnROYW1lO1xuICAgIGZvckVhY2hSdWxlKHJ1bGVzLCAocikgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm1SdWxlKHIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshU3R5bGVOb2RlfSBydWxlXG4gICAqL1xuICB0cmFuc2Zvcm1SdWxlKHJ1bGUpIHtcbiAgICBydWxlWydjc3NUZXh0J10gPSB0aGlzLnRyYW5zZm9ybUNzc1RleHQocnVsZVsncGFyc2VkQ3NzVGV4dCddKTtcbiAgICAvLyA6cm9vdCB3YXMgb25seSB1c2VkIGZvciB2YXJpYWJsZSBhc3NpZ25tZW50IGluIHByb3BlcnR5IHNoaW0sXG4gICAgLy8gYnV0IGdlbmVyYXRlcyBpbnZhbGlkIHNlbGVjdG9ycyB3aXRoIHJlYWwgcHJvcGVydGllcy5cbiAgICAvLyByZXBsYWNlIHdpdGggYDpob3N0ID4gKmAsIHdoaWNoIHNlcnZlcyB0aGUgc2FtZSBlZmZlY3RcbiAgICBpZiAocnVsZVsnc2VsZWN0b3InXSA9PT0gJzpyb290Jykge1xuICAgICAgcnVsZVsnc2VsZWN0b3InXSA9ICc6aG9zdCA+IConO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdHJhbnNmb3JtQ3NzVGV4dChjc3NUZXh0KSB7XG4gICAgLy8gcHJvZHVjZSB2YXJpYWJsZXNcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKFZBUl9BU1NJR04sIChtYXRjaFRleHQsIHByb3BlcnR5TmFtZSwgdmFsdWVQcm9wZXJ0eSwgdmFsdWVNaXhpbikgPT5cbiAgICAgIHRoaXMuX3Byb2R1Y2VDc3NQcm9wZXJ0aWVzKG1hdGNoVGV4dCwgcHJvcGVydHlOYW1lLCB2YWx1ZVByb3BlcnR5LCB2YWx1ZU1peGluKSk7XG4gICAgLy8gY29uc3VtZSBtaXhpbnNcbiAgICByZXR1cm4gdGhpcy5fY29uc3VtZUNzc1Byb3BlcnRpZXMoY3NzVGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfZ2V0SW5pdGlhbFZhbHVlRm9yUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICBpZiAoIXRoaXMuX21lYXN1cmVFbGVtZW50KSB7XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IC8qKiBAdHlwZSB7SFRNTE1ldGFFbGVtZW50fSAqLyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJykpO1xuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcHBseS1zaGltLW1lYXN1cmUnLCAnJyk7XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudC5zdHlsZS5hbGwgPSAnaW5pdGlhbCc7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuX21lYXN1cmVFbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lYXN1cmVFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgfVxuICAvKipcbiAgICogcmVwbGFjZSBtaXhpbiBjb25zdW1wdGlvbiB3aXRoIHZhcmlhYmxlIGNvbnN1bXB0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9jb25zdW1lQ3NzUHJvcGVydGllcyh0ZXh0KSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICBsZXQgbSA9IG51bGw7XG4gICAgLy8gbG9vcCBvdmVyIHRleHQgdW50aWwgYWxsIG1peGlucyB3aXRoIGRlZmludGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICB3aGlsZSgobSA9IE1JWElOX01BVENILmV4ZWModGV4dCkpKSB7XG4gICAgICBsZXQgbWF0Y2hUZXh0ID0gbVswXTtcbiAgICAgIGxldCBtaXhpbk5hbWUgPSBtWzFdO1xuICAgICAgbGV0IGlkeCA9IG0uaW5kZXg7XG4gICAgICAvLyBjb2xsZWN0IHByb3BlcnRpZXMgYmVmb3JlIGFwcGx5IHRvIGJlIFwiZGVmYXVsdHNcIiBpZiBtaXhpbiBtaWdodCBvdmVycmlkZSB0aGVtXG4gICAgICAvLyBtYXRjaCBpbmNsdWRlcyBhIFwicHJlZml4XCIsIHNvIGZpbmQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIEBhcHBseVxuICAgICAgbGV0IGFwcGx5UG9zID0gaWR4ICsgbWF0Y2hUZXh0LmluZGV4T2YoJ0BhcHBseScpO1xuICAgICAgbGV0IGFmdGVyQXBwbHlQb3MgPSBpZHggKyBtYXRjaFRleHQubGVuZ3RoO1xuICAgICAgLy8gZmluZCBwcm9wcyBkZWZpbmVkIGJlZm9yZSB0aGlzIEBhcHBseVxuICAgICAgbGV0IHRleHRCZWZvcmVBcHBseSA9IHRleHQuc2xpY2UoMCwgYXBwbHlQb3MpO1xuICAgICAgbGV0IHRleHRBZnRlckFwcGx5ID0gdGV4dC5zbGljZShhZnRlckFwcGx5UG9zKTtcbiAgICAgIGxldCBkZWZhdWx0cyA9IHRoaXMuX2Nzc1RleHRUb01hcCh0ZXh0QmVmb3JlQXBwbHkpO1xuICAgICAgbGV0IHJlcGxhY2VtZW50ID0gdGhpcy5fYXRBcHBseVRvQ3NzUHJvcGVydGllcyhtaXhpbk5hbWUsIGRlZmF1bHRzKTtcbiAgICAgIC8vIHVzZSByZWdleCBtYXRjaCBwb3NpdGlvbiB0byByZXBsYWNlIG1peGluLCBrZWVwIGxpbmVhciBwcm9jZXNzaW5nIHRpbWVcbiAgICAgIHRleHQgPSBgJHt0ZXh0QmVmb3JlQXBwbHl9JHtyZXBsYWNlbWVudH0ke3RleHRBZnRlckFwcGx5fWA7XG4gICAgICAvLyBtb3ZlIHJlZ2V4IHNlYXJjaCB0byBfYWZ0ZXJfIHJlcGxhY2VtZW50XG4gICAgICBNSVhJTl9NQVRDSC5sYXN0SW5kZXggPSBpZHggKyByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBwcm9kdWNlIHZhcmlhYmxlIGNvbnN1bXB0aW9uIGF0IHRoZSBzaXRlIG9mIG1peGluIGNvbnN1bXB0aW9uXG4gICAqIGBAYXBwbHlgIC0tZm9vOyAtPiBmb3IgYWxsIHByb3BzICgke3Byb3BuYW1lfTogdmFyKC0tZm9vXy1fJHtwcm9wbmFtZX0sICR7ZmFsbGJhY2tbcHJvcG5hbWVdfX0pKVxuICAgKiBFeGFtcGxlOlxuICAgKiAgYm9yZGVyOiB2YXIoLS1mb29fLV9ib3JkZXIpOyBwYWRkaW5nOiB2YXIoLS1mb29fLV9wYWRkaW5nLCAycHgpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtaXhpbk5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGZhbGxiYWNrc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfYXRBcHBseVRvQ3NzUHJvcGVydGllcyhtaXhpbk5hbWUsIGZhbGxiYWNrcykge1xuICAgIG1peGluTmFtZSA9IG1peGluTmFtZS5yZXBsYWNlKEFQUExZX05BTUVfQ0xFQU4sICcnKTtcbiAgICBsZXQgdmFycyA9IFtdO1xuICAgIGxldCBtaXhpbkVudHJ5ID0gdGhpcy5fbWFwLmdldChtaXhpbk5hbWUpO1xuICAgIC8vIGlmIHdlIGRlcGVuZCBvbiBhIG1peGluIGJlZm9yZSBpdCBpcyBjcmVhdGVkXG4gICAgLy8gbWFrZSBhIHNlbnRpbmVsIGVudHJ5IGluIHRoZSBtYXAgdG8gYWRkIHRoaXMgZWxlbWVudCBhcyBhIGRlcGVuZGVuY3kgZm9yIHdoZW4gaXQgaXMgZGVmaW5lZC5cbiAgICBpZiAoIW1peGluRW50cnkpIHtcbiAgICAgIHRoaXMuX21hcC5zZXQobWl4aW5OYW1lLCB7fSk7XG4gICAgICBtaXhpbkVudHJ5ID0gdGhpcy5fbWFwLmdldChtaXhpbk5hbWUpO1xuICAgIH1cbiAgICBpZiAobWl4aW5FbnRyeSkge1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIG1peGluRW50cnkuZGVwZW5kYW50c1t0aGlzLl9jdXJyZW50RWxlbWVudF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IHAsIHBhcnRzLCBmO1xuICAgICAgZm9yIChwIGluIG1peGluRW50cnkucHJvcGVydGllcykge1xuICAgICAgICBmID0gZmFsbGJhY2tzICYmIGZhbGxiYWNrc1twXTtcbiAgICAgICAgcGFydHMgPSBbcCwgJzogdmFyKCcsIG1peGluTmFtZSwgTUlYSU5fVkFSX1NFUCwgcF07XG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgcGFydHMucHVzaCgnLCcsIGYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goJyknKTtcbiAgICAgICAgdmFycy5wdXNoKHBhcnRzLmpvaW4oJycpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhcnMuam9pbignOyAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9yZXBsYWNlSW5pdGlhbE9ySW5oZXJpdChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBsZXQgbWF0Y2ggPSBJTklUSUFMX0lOSEVSSVQuZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgLy8gaW5pdGlhbFxuICAgICAgICAvLyByZXBsYWNlIGBpbml0aWFsYCB3aXRoIHRoZSBjb25jcmV0ZSBpbml0aWFsIHZhbHVlIGZvciB0aGlzIHByb3BlcnR5XG4gICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0SW5pdGlhbFZhbHVlRm9yUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5oZXJpdFxuICAgICAgICAvLyB3aXRoIHRoaXMgcHVycG9zZnVsbHkgaWxsZWdhbCB2YWx1ZSwgdGhlIHZhcmlhYmxlIHdpbGwgYmUgaW52YWxpZCBhdFxuICAgICAgICAvLyBjb21wdXRlIHRpbWUgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtdmFyaWFibGVzLyNpbnZhbGlkLWF0LWNvbXB1dGVkLXZhbHVlLXRpbWUpXG4gICAgICAgIC8vIGFuZCBmb3IgaW5oZXJpdGluZyB2YWx1ZXMsIHdpbGwgYmVoYXZlIHNpbWlsYXJseVxuICAgICAgICAvLyB3ZSBjYW5ub3Qgc3VwcG9ydCB0aGUgc2FtZSBiZWhhdmlvciBmb3Igbm9uIGluaGVyaXRpbmcgdmFsdWVzIGxpa2UgJ2JvcmRlcidcbiAgICAgICAgdmFsdWUgPSAnYXBwbHktc2hpbS1pbmhlcml0JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFwicGFyc2VcIiBhIG1peGluIGRlZmluaXRpb24gaW50byBhIG1hcCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICogY3NzVGV4dFRvTWFwKCdib3JkZXI6IDJweCBzb2xpZCBibGFjaycpIC0+ICgnYm9yZGVyJywgJzJweCBzb2xpZCBibGFjaycpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgX2Nzc1RleHRUb01hcCh0ZXh0KSB7XG4gICAgbGV0IHByb3BzID0gdGV4dC5zcGxpdCgnOycpO1xuICAgIGxldCBwcm9wZXJ0eSwgdmFsdWU7XG4gICAgbGV0IG91dCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwLCBwLCBzcDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwID0gcHJvcHNbaV07XG4gICAgICBpZiAocCkge1xuICAgICAgICBzcCA9IHAuc3BsaXQoJzonKTtcbiAgICAgICAgLy8gaWdub3JlIGxpbmVzIHRoYXQgYXJlbid0IGRlZmluaXRpb25zIGxpa2UgQG1lZGlhXG4gICAgICAgIGlmIChzcC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBzcFswXS50cmltKCk7XG4gICAgICAgICAgLy8gc29tZSBwcm9wZXJ0aWVzIG1heSBoYXZlICc6JyBpbiB0aGUgdmFsdWUsIGxpa2UgZGF0YSB1cmxzXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9yZXBsYWNlSW5pdGlhbE9ySW5oZXJpdChwcm9wZXJ0eSwgc3Auc2xpY2UoMSkuam9pbignOicpKTtcbiAgICAgICAgICBvdXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01peGluTWFwRW50cnl9IG1peGluRW50cnlcbiAgICovXG4gIF9pbnZhbGlkYXRlTWl4aW5FbnRyeShtaXhpbkVudHJ5KSB7XG4gICAgaWYgKCFpbnZhbGlkQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgZWxlbWVudE5hbWUgaW4gbWl4aW5FbnRyeS5kZXBlbmRhbnRzKSB7XG4gICAgICBpZiAoZWxlbWVudE5hbWUgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIGludmFsaWRDYWxsYmFjayhlbGVtZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlUHJvcGVydHlcbiAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZU1peGluXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9wcm9kdWNlQ3NzUHJvcGVydGllcyhtYXRjaFRleHQsIHByb3BlcnR5TmFtZSwgdmFsdWVQcm9wZXJ0eSwgdmFsdWVNaXhpbikge1xuICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIHByb3BlcnR5IHZhbHVlIGlzIGEgbWl4aW5cbiAgICBpZiAodmFsdWVQcm9wZXJ0eSkge1xuICAgICAgLy8gZm9ybTogLS1taXhpbjI6IHZhcigtLW1peGluMSksIHdoZXJlIC0tbWl4aW4xIGlzIGluIHRoZSBtYXBcbiAgICAgIHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrKHZhbHVlUHJvcGVydHksIChwcmVmaXgsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLl9tYXAuZ2V0KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlTWl4aW4gPSBgQGFwcGx5ICR7dmFsdWV9O2BcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdmFsdWVNaXhpbikge1xuICAgICAgcmV0dXJuIG1hdGNoVGV4dDtcbiAgICB9XG4gICAgbGV0IG1peGluQXNQcm9wZXJ0aWVzID0gdGhpcy5fY29uc3VtZUNzc1Byb3BlcnRpZXModmFsdWVNaXhpbik7XG4gICAgbGV0IHByZWZpeCA9IG1hdGNoVGV4dC5zbGljZSgwLCBtYXRjaFRleHQuaW5kZXhPZignLS0nKSk7XG4gICAgbGV0IG1peGluVmFsdWVzID0gdGhpcy5fY3NzVGV4dFRvTWFwKG1peGluQXNQcm9wZXJ0aWVzKTtcbiAgICBsZXQgY29tYmluZWRQcm9wcyA9IG1peGluVmFsdWVzO1xuICAgIGxldCBtaXhpbkVudHJ5ID0gdGhpcy5fbWFwLmdldChwcm9wZXJ0eU5hbWUpO1xuICAgIGxldCBvbGRQcm9wcyA9IG1peGluRW50cnkgJiYgbWl4aW5FbnRyeS5wcm9wZXJ0aWVzO1xuICAgIGlmIChvbGRQcm9wcykge1xuICAgICAgLy8gTk9URTogc2luY2Ugd2UgdXNlIG1peGluLCB0aGUgbWFwIG9mIHByb3BlcnRpZXMgaXMgdXBkYXRlZCBoZXJlXG4gICAgICAvLyBhbmQgdGhpcyBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICBjb21iaW5lZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG9sZFByb3BzKSwgbWl4aW5WYWx1ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tYXAuc2V0KHByb3BlcnR5TmFtZSwgY29tYmluZWRQcm9wcyk7XG4gICAgfVxuICAgIGxldCBvdXQgPSBbXTtcbiAgICBsZXQgcCwgdjtcbiAgICAvLyBzZXQgdmFyaWFibGVzIGRlZmluZWQgYnkgY3VycmVudCBtaXhpblxuICAgIGxldCBuZWVkVG9JbnZhbGlkYXRlID0gZmFsc2U7XG4gICAgZm9yIChwIGluIGNvbWJpbmVkUHJvcHMpIHtcbiAgICAgIHYgPSBtaXhpblZhbHVlc1twXTtcbiAgICAgIC8vIGlmIHByb3BlcnR5IG5vdCBkZWZpbmVkIGJ5IGN1cnJlbnQgbWl4aW4sIHNldCBpbml0aWFsXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHYgPSAnaW5pdGlhbCc7XG4gICAgICB9XG4gICAgICBpZiAob2xkUHJvcHMgJiYgIShwIGluIG9sZFByb3BzKSkge1xuICAgICAgICBuZWVkVG9JbnZhbGlkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKGAke3Byb3BlcnR5TmFtZX0ke01JWElOX1ZBUl9TRVB9JHtwfTogJHt2fWApO1xuICAgIH1cbiAgICBpZiAobmVlZFRvSW52YWxpZGF0ZSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZU1peGluRW50cnkobWl4aW5FbnRyeSk7XG4gICAgfVxuICAgIGlmIChtaXhpbkVudHJ5KSB7XG4gICAgICBtaXhpbkVudHJ5LnByb3BlcnRpZXMgPSBjb21iaW5lZFByb3BzO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIHRoZSBtaXhpbk1hcCBpcyBnbG9iYWwsIHRoZSBtaXhpbiBtaWdodCBjb25mbGljdCB3aXRoXG4gICAgLy8gYSBkaWZmZXJlbnQgc2NvcGUncyBzaW1wbGUgdmFyaWFibGUgZGVmaW5pdGlvbjpcbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vIHNvbWUgc3R5bGUgc29tZXdoZXJlOlxuICAgIC8vIC0tbWl4aW4xOnsgLi4uIH1cbiAgICAvLyAtLW1peGluMjogdmFyKC0tbWl4aW4xKTtcbiAgICAvLyBzb21lIG90aGVyIGVsZW1lbnQ6XG4gICAgLy8gLS1taXhpbjE6IDEwcHggc29saWQgcmVkO1xuICAgIC8vIC0tZm9vOiB2YXIoLS1taXhpbjEpO1xuICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIHZhcmlhYmxlIGRlZmluaXRpb24gaW4gcGxhY2UuXG4gICAgaWYgKHZhbHVlUHJvcGVydHkpIHtcbiAgICAgIHByZWZpeCA9IGAke21hdGNoVGV4dH07JHtwcmVmaXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke291dC5qb2luKCc7ICcpfTtgO1xuICB9XG59XG5cbi8qIGV4cG9ydHMgKi9cbkFwcGx5U2hpbS5wcm90b3R5cGVbJ2RldGVjdE1peGluJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLmRldGVjdE1peGluO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtU3R5bGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtU3R5bGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1DdXN0b21TdHlsZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1DdXN0b21TdHlsZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVJ1bGVzJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVJ1bGVzO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtUnVsZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtVGVtcGxhdGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtVGVtcGxhdGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWydfc2VwYXJhdG9yJ10gPSBNSVhJTl9WQVJfU0VQO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGx5U2hpbS5wcm90b3R5cGUsICdpbnZhbGlkQ2FsbGJhY2snLCB7XG4gIC8qKiBAcmV0dXJuIHs/ZnVuY3Rpb24oc3RyaW5nKX0gKi9cbiAgZ2V0KCkge1xuICAgIHJldHVybiBpbnZhbGlkQ2FsbGJhY2s7XG4gIH0sXG4gIC8qKiBAcGFyYW0gez9mdW5jdGlvbihzdHJpbmcpfSBjYiAqL1xuICBzZXQoY2IpIHtcbiAgICBpbnZhbGlkQ2FsbGJhY2sgPSBjYjtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcGx5U2hpbTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHRlbXBsYXRlTWFwIGZyb20gJy4vdGVtcGxhdGUtbWFwLmpzJztcbmltcG9ydCB7U3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLypcbiAqIFV0aWxpdGllcyBmb3IgaGFuZGxpbmcgaW52YWxpZGF0aW5nIGFwcGx5LXNoaW0gbWl4aW5zIGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICpcbiAqIFRoZSBpbnZhbGlkYXRpb24gc3RyYXRlZ3kgaW52b2x2ZXMga2VlcGluZyB0cmFjayBvZiB0aGUgXCJjdXJyZW50XCIgdmVyc2lvbiBvZiBhIHRlbXBsYXRlJ3MgbWl4aW5zLCBhbmQgdXBkYXRpbmcgdGhhdCBjb3VudCB3aGVuIGEgbWl4aW4gaXMgaW52YWxpZGF0ZWQuXG4gKiBUaGUgdGVtcGxhdGVcbiAqL1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBDVVJSRU5UX1ZFUlNJT04gPSAnX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uJztcblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgTkVYVF9WRVJTSU9OID0gJ19hcHBseVNoaW1OZXh0VmVyc2lvbic7XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IFZBTElEQVRJTkdfVkVSU0lPTiA9ICdfYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb24nO1xuXG4vKipcbiAqIEBjb25zdCB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZShlbGVtZW50TmFtZSl7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgaWYgKHRlbXBsYXRlKSB7XG4gICAgaW52YWxpZGF0ZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBtYXJrIGEgdGVtcGxhdGUgaW52YWxpZFxuICogYW5kIHNpZ25hbCB0aGF0IHRoZSBzdHlsZSBpbnNpZGUgbXVzdCBiZSByZWdlbmVyYXRlZC5cbiAqXG4gKiBVc2UgYHN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlYCB0byBiZWdpbiBhbiBhc3luY2hyb25vdXMgdmFsaWRhdGlvbiBjeWNsZS5cbiAqIER1cmluZyB0aGF0IGN5Y2xlLCBjYWxsIGB0ZW1wbGF0ZUlzVmFsaWRhdGluZ2AgdG8gc2VlIGlmIHRoZSB0ZW1wbGF0ZSBtdXN0XG4gKiBiZSByZXZhbGlkYXRlZFxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIC8vIGRlZmF1bHQgdGhlIGN1cnJlbnQgdmVyc2lvbiB0byAwXG4gIHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dIHx8IDA7XG4gIC8vIGVuc3VyZSB0aGUgXCJ2YWxpZGF0aW5nIGZvclwiIGZsYWcgZXhpc3RzXG4gIHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dIHx8IDA7XG4gIC8vIGluY3JlbWVudCB0aGUgbmV4dCB2ZXJzaW9uXG4gIHRlbXBsYXRlW05FWFRfVkVSU0lPTl0gPSAodGVtcGxhdGVbTkVYVF9WRVJTSU9OXSB8fCAwKSArIDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZChlbGVtZW50TmFtZSkge1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpIHtcbiAgcmV0dXJuIHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gPT09IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZGF0aW5nKGVsZW1lbnROYW1lKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgaWYgKHRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlSXNWYWxpZGF0aW5nKHRlbXBsYXRlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0ZW1wbGF0ZSBpcyBjdXJyZW50bHkgaW52YWxpZCBhbmQgYHN0YXJ0VmFsaWRhdGluZ2AgaGFzIGJlZW4gY2FsbGVkIHNpbmNlIHRoZSBsYXN0IGludmFsaWRhdGlvbi5cbiAqIElmIGZhbHNlLCB0aGUgdGVtcGxhdGUgbXVzdCBiZSB2YWxpZGF0ZWQuXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVJc1ZhbGlkYXRpbmcodGVtcGxhdGUpIHtcbiAgcmV0dXJuICF0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpICYmIHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gPT09IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG59XG5cbi8qKlxuICogdGhlIHRlbXBsYXRlIGlzIG1hcmtlZCBhcyBgdmFsaWRhdGluZ2AgZm9yIG9uZSBtaWNyb3Rhc2sgc28gdGhhdCBhbGwgaW5zdGFuY2VzXG4gKiBmb3VuZCBpbiB0aGUgdHJlZSBjcmF3bCBvZiBgYXBwbHlTdHlsZWAgd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyxcbiAqIGJ1dCB0aGUgdGVtcGxhdGUgd2lsbCBvbmx5IGJlIHVwZGF0ZWQgb25jZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFZhbGlkYXRpbmcoZWxlbWVudE5hbWUpIHtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG59XG5cbi8qKlxuICogQmVnaW4gYW4gYXN5bmNocm9ub3VzIGludmFsaWRhdGlvbiBjeWNsZS5cbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBldmVyeSB2YWxpZGF0aW9uIG9mIGEgdGVtcGxhdGVcbiAqXG4gKiBBZnRlciBvbmUgbWljcm90YXNrLCB0aGUgdGVtcGxhdGUgd2lsbCBiZSBtYXJrZWQgYXMgdmFsaWQgdW50aWwgdGhlIG5leHQgY2FsbCB0byBgaW52YWxpZGF0ZVRlbXBsYXRlYFxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgLy8gcmVtZW1iZXIgdGhhdCB0aGUgY3VycmVudCBcIm5leHQgdmVyc2lvblwiIGlzIHRoZSByZWFzb24gZm9yIHRoaXMgdmFsaWRhdGlvbiBjeWNsZVxuICB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbiAgLy8gaG93ZXZlciwgdGhlcmUgb25seSBuZWVkcyB0byBiZSBvbmUgYXN5bmMgdGFzayB0byBjbGVhciB0aGUgY291bnRlcnNcbiAgaWYgKCF0ZW1wbGF0ZS5fdmFsaWRhdGluZykge1xuICAgIHRlbXBsYXRlLl92YWxpZGF0aW5nID0gdHJ1ZTtcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAvLyBzeW5jIHRoZSBjdXJyZW50IHZlcnNpb24gdG8gbGV0IGZ1dHVyZSBpbnZhbGlkYXRpb25zIGNhdXNlIGEgcmVmcmVzaCBjeWNsZVxuICAgICAgdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSA9IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG4gICAgICB0ZW1wbGF0ZS5fdmFsaWRhdGluZyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRzQXJlSW52YWxpZCgpIHtcbiAgZm9yIChsZXQgZWxlbWVudE5hbWUgaW4gdGVtcGxhdGVNYXApIHtcbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gICAgaWYgKCF0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIHJ1biBhIGNhbGxiYWNrIHdoZW4gSFRNTEltcG9ydHMgYXJlIHJlYWR5IG9yIGltbWVkaWF0ZWx5IGlmXG4vLyB0aGlzIGFwaSBpcyBub3QgYXZhaWxhYmxlLlxuZnVuY3Rpb24gd2hlbkltcG9ydHNSZWFkeShjYikge1xuICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG4gICAgSFRNTEltcG9ydHMud2hlblJlYWR5KGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbXBvcnRIcmVmID0gZnVuY3Rpb24oaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykge1xuICBsZXQgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqL1xuICAgIChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZj1cIicgKyBocmVmICsgJ1wiXVtpbXBvcnQtaHJlZl0nKSk7XG4gIGlmICghbGluaykge1xuICAgIGxpbmsgPSAvKiogQHR5cGUge0hUTUxMaW5rRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKSk7XG4gICAgbGluay5yZWwgPSAnaW1wb3J0JztcbiAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdpbXBvcnQtaHJlZicsICcnKTtcbiAgfVxuICAvLyBhbHdheXMgZW5zdXJlIGxpbmsgaGFzIGBhc3luY2AgYXR0cmlidXRlIGlmIHVzZXIgc3BlY2lmaWVkIG9uZSxcbiAgLy8gZXZlbiBpZiBpdCB3YXMgcHJldmlvdXNseSBub3QgYXN5bmMuIFRoaXMgaXMgY29uc2lkZXJlZCBsZXNzIGNvbmZ1c2luZy5cbiAgaWYgKG9wdEFzeW5jKSB7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoJ2FzeW5jJywgJycpO1xuICB9XG4gIC8vIE5PVEU6IHRoZSBsaW5rIG1heSBub3cgYmUgaW4gMyBzdGF0ZXM6ICgxKSBwZW5kaW5nIGluc2VydGlvbixcbiAgLy8gKDIpIGluZmxpZ2h0LCAoMykgYWxyZWFkeSBsYW9kZWQuIEluIGVhY2ggY2FzZSwgd2UgbmVlZCB0byBhZGRcbiAgLy8gZXZlbnQgbGlzdGVuZXJzIHRvIHByb2Nlc3MgY2FsbGJhY2tzLlxuICBsZXQgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICB9O1xuICBsZXQgbG9hZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgLy8gSW4gY2FzZSBvZiBhIHN1Y2Nlc3NmdWwgbG9hZCwgY2FjaGUgdGhlIGxvYWQgZXZlbnQgb24gdGhlIGxpbmsgc29cbiAgICAvLyB0aGF0IGl0IGNhbiBiZSB1c2VkIHRvIHNob3J0LWNpcmN1aXQgdGhpcyBtZXRob2QgaW4gdGhlIGZ1dHVyZSB3aGVuXG4gICAgLy8gaXQgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgaHJlZiBwYXJhbS5cbiAgICBsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCA9IHRydWU7XG4gICAgaWYgKG9ubG9hZCkge1xuICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgIG9ubG9hZChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGxldCBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciwgcmVtb3ZlIHRoZSBsaW5rIGZyb20gdGhlIGRvY3VtZW50IHNvIHRoYXQgaXRcbiAgICAvLyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBhZ2FpbiB0aGUgbmV4dCB0aW1lIGBpbXBvcnRIcmVmYCBpc1xuICAgIC8vIGNhbGxlZC5cbiAgICBpZiAobGluay5wYXJlbnROb2RlKSB7XG4gICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxuICAgIGlmIChvbmVycm9yKSB7XG4gICAgICB3aGVuSW1wb3J0c1JlYWR5KCgpID0+IHtcbiAgICAgICAgb25lcnJvcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgaWYgKGxpbmsucGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgLy8gaWYgdGhlIGxpbmsgYWxyZWFkeSBsb2FkZWQsIGRpc3BhdGNoIGEgZmFrZSBsb2FkIGV2ZW50XG4gIC8vIHNvIHRoYXQgbGlzdGVuZXJzIGFyZSBjYWxsZWQgYW5kIGdldCBhIHByb3BlciBldmVudCBhcmd1bWVudC5cbiAgfSBlbHNlIGlmIChsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCkge1xuICAgIGxpbmsuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2xvYWQnKSk7XG4gIH1cbiAgcmV0dXJuIGxpbms7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9pbXBvcnQtaHJlZi5qcyIsImZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCd1bnJlc29sdmVkJyk7XG59XG5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgcmVzb2x2ZSgpO1xufSBlbHNlIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCByZXNvbHZlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvdW5yZXNvbHZlZC5qcyIsImltcG9ydCB7IExlZ2FjeUVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGVnYWN5LWVsZW1lbnQtbWl4aW4uanMnO1xuaW1wb3J0IHsgRG9tTW9kdWxlIH0gZnJvbSAnLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5qcyc7XG5cbmxldCBtZXRhUHJvcHMgPSB7XG4gIGF0dGFjaGVkOiB0cnVlLFxuICBkZXRhY2hlZDogdHJ1ZSxcbiAgcmVhZHk6IHRydWUsXG4gIGNyZWF0ZWQ6IHRydWUsXG4gIGJlZm9yZVJlZ2lzdGVyOiB0cnVlLFxuICByZWdpc3RlcmVkOiB0cnVlLFxuICBhdHRyaWJ1dGVDaGFuZ2VkOiB0cnVlLFxuICAvLyBtZXRhIG9iamVjdHNcbiAgYmVoYXZpb3JzOiB0cnVlXG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBcImxlZ2FjeVwiIGJlaGF2aW9yIG9yIGFycmF5IG9mIGJlaGF2aW9ycyB0byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogTm90ZTogdGhpcyBtZXRob2Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFsc28gYXBwbHkgdGhlIGBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbmBcbiAqIHRvIGVuc3VyZSB0aGF0IGFueSBsZWdhY3kgYmVoYXZpb3JzIGNhbiByZWx5IG9uIGxlZ2FjeSBQb2x5bWVyIEFQSSBvblxuICogdGhlIHVuZGVybHlpbmcgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyEoT2JqZWN0fEFycmF5KX0gYmVoYXZpb3JzIEJlaGF2aW9yIG9iamVjdCBvciBhcnJheSBvZiBiZWhhdmlvcnMuXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudHxmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBrbGFzcyBFbGVtZW50IGNsYXNzLlxuICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gUmV0dXJucyBhIG5ldyBFbGVtZW50IGNsYXNzIGV4dGVuZGVkIGJ5IHRoZVxuICogcGFzc2VkIGluIGBiZWhhdmlvcnNgIGFuZCBhbHNvIGJ5IGBQb2x5bWVyLkxlZ2FjeUVsZW1lbnRNaXhpbmAuXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHMsIGNoZWNrVHlwZXN9XG4gKi9cbmZ1bmN0aW9uIG1peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpIHtcbiAgaWYgKCFiZWhhdmlvcnMpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oa2xhc3MpO1xuICB9XG4gIC8vIE5PVEU6IGVuc3VyZSB0aGUgYmFoZXZpb3IgaXMgZXh0ZW5kaW5nIGEgY2xhc3Mgd2l0aFxuICAvLyBsZWdhY3kgZWxlbWVudCBhcGkuIFRoaXMgaXMgbmVjZXNzYXJ5IHNpbmNlIGJlaGF2aW9ycyBleHBlY3QgdG8gYmUgYWJsZVxuICAvLyB0byBhY2Nlc3MgMS54IGxlZ2FjeSBhcGkuXG4gIGtsYXNzID0gTGVnYWN5RWxlbWVudE1peGluKGtsYXNzKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGJlaGF2aW9ycykpIHtcbiAgICBiZWhhdmlvcnMgPSBbYmVoYXZpb3JzXTtcbiAgfVxuICBsZXQgc3VwZXJCZWhhdmlvcnMgPSBrbGFzcy5wcm90b3R5cGUuYmVoYXZpb3JzO1xuICAvLyBnZXQgZmxhdHRlbmVkLCBkZWR1cGVkIGxpc3Qgb2YgYmVoYXZpb3JzICpub3QqIGFscmVhZHkgb24gc3VwZXIgY2xhc3NcbiAgYmVoYXZpb3JzID0gZmxhdHRlbkJlaGF2aW9ycyhiZWhhdmlvcnMsIG51bGwsIHN1cGVyQmVoYXZpb3JzKTtcbiAgLy8gbWl4aW4gbmV3IGJlaGF2aW9yc1xuICBrbGFzcyA9IF9taXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKTtcbiAgaWYgKHN1cGVyQmVoYXZpb3JzKSB7XG4gICAgYmVoYXZpb3JzID0gc3VwZXJCZWhhdmlvcnMuY29uY2F0KGJlaGF2aW9ycyk7XG4gIH1cbiAgLy8gU2V0IGJlaGF2aW9ycyBvbiBwcm90b3R5cGUgZm9yIEJDLi4uXG4gIGtsYXNzLnByb3RvdHlwZS5iZWhhdmlvcnMgPSBiZWhhdmlvcnM7XG4gIHJldHVybiBrbGFzcztcbn1cblxuLy8gTk9URTpcbi8vIDEueFxuLy8gQmVoYXZpb3JzIHdlcmUgbWl4ZWQgaW4gKmluIHJldmVyc2Ugb3JkZXIqIGFuZCBkZS1kdXBlZCBvbiB0aGUgZmx5LlxuLy8gVGhlIHJ1bGUgd2FzIHRoYXQgYmVoYXZpb3IgcHJvcGVydGllcyB3ZXJlIGNvcGllZCBvbnRvIHRoZSBlbGVtZW50XG4vLyBwcm90b3R5cGUgaWYgYW5kIG9ubHkgaWYgdGhlIHByb3BlcnR5IGRpZCBub3QgYWxyZWFkeSBleGlzdC5cbi8vIEdpdmVuOiBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHByb3BlcnR5IGNvcHkgb3JkZXIgd2FzOlxuLy8gKDEpLCBCLCAoMiksIEEsICgzKSBDLiBUaGlzIG1lYW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHdpbiBvdmVyXG4vLyBCIHByb3BlcnRpZXMgd2luIG92ZXIgQSB3aW4gb3ZlciBDLiBUaGlzIG1pcnJvcnMgd2hhdCB3b3VsZCBoYXBwZW5cbi8vIHdpdGggaW5oZXJpdGFuY2UgaWYgZWxlbWVudCBleHRlbmRlZCBCIGV4dGVuZGVkIEEgZXh0ZW5kZWQgQy5cbi8vXG4vLyBBZ2FpbiBnaXZlbiwgUG9seW1lcnsgYmVoYXZpb3JzOiBbQSwgQiwgQywgQSwgQl19LCB0aGUgcmVzdWx0aW5nXG4vLyBgYmVoYXZpb3JzYCBhcnJheSB3YXMgW0MsIEEsIEJdLlxuLy8gQmVoYXZpb3IgbGlmZWN5Y2xlIG1ldGhvZHMgd2VyZSBjYWxsZWQgaW4gYmVoYXZpb3IgYXJyYXkgb3JkZXJcbi8vIGZvbGxvd2VkIGJ5IHRoZSBlbGVtZW50LCBlLmcuICgxKSBDLmNyZWF0ZWQsICgyKSBBLmNyZWF0ZWQsXG4vLyAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkLiBUaGVyZSB3YXMgbm8gc3VwcG9ydCBmb3Jcbi8vIHN1cGVyLCBhbmQgXCJzdXBlci1iZWhhdmlvclwiIG1ldGhvZHMgd2VyZSBjYWxsYWJsZSBvbmx5IGJ5IG5hbWUpLlxuLy9cbi8vIDIueFxuLy8gQmVoYXZpb3JzIGFyZSBtYWRlIGludG8gcHJvcGVyIG1peGlucyB3aGljaCBsaXZlIGluIHRoZVxuLy8gZWxlbWVudCdzIHByb3RvdHlwZSBjaGFpbi4gQmVoYXZpb3JzIGFyZSBwbGFjZWQgaW4gdGhlIGVsZW1lbnQgcHJvdG90eXBlXG4vLyBlbGRlc3QgdG8geW91bmdlc3QgYW5kIGRlLWR1cGVkIHlvdW5nZXN0IHRvIG9sZGVzdDpcbi8vIFNvLCBmaXJzdCBbQSwgQiwgQywgQSwgQl0gYmVjb21lcyBbQywgQSwgQl0gdGhlbixcbi8vIHRoZSBlbGVtZW50IHByb3RvdHlwZSBiZWNvbWVzIChvbGRlc3QpICgxKSBQb2x5bWVyLkVsZW1lbnQsICgyKSBjbGFzcyhDKSxcbi8vICgzKSBjbGFzcyhBKSwgKDQpIGNsYXNzKEIpLCAoNSkgY2xhc3MoUG9seW1lcih7Li4ufSkpLlxuLy8gUmVzdWx0OlxuLy8gVGhpcyBtZWFucyBlbGVtZW50IHByb3BlcnRpZXMgd2luIG92ZXIgQiBwcm9wZXJ0aWVzIHdpbiBvdmVyIEEgd2luXG4vLyBvdmVyIEMuIChzYW1lIGFzIDEueClcbi8vIElmIGxpZmVjeWNsZSBpcyBjYWxsZWQgKHN1cGVyIHRoZW4gbWUpLCBvcmRlciBpc1xuLy8gKDEpIEMuY3JlYXRlZCwgKDIpIEEuY3JlYXRlZCwgKDMpIEIuY3JlYXRlZCwgKDQpIGVsZW1lbnQuY3JlYXRlZFxuLy8gKGFnYWluIHNhbWUgYXMgMS54KVxuZnVuY3Rpb24gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpIHtcbiAgZm9yIChsZXQgaT0wOyBpPGJlaGF2aW9ycy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBiID0gYmVoYXZpb3JzW2ldO1xuICAgIGlmIChiKSB7XG4gICAgICBrbGFzcyA9IEFycmF5LmlzQXJyYXkoYikgPyBfbWl4aW5CZWhhdmlvcnMoYiwga2xhc3MpIDpcbiAgICAgICAgR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGIsIGtsYXNzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtsYXNzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGJlaGF2aW9ycyBMaXN0IG9mIGJlaGF2aW9ycyB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtBcnJheT19IGxpc3QgVGFyZ2V0IGxpc3QgdG8gZmxhdHRlbiBiZWhhdmlvcnMgaW50by5cbiAqIEBwYXJhbSB7QXJyYXk9fSBleGNsdWRlIExpc3Qgb2YgYmVoYXZpb3JzIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgbGlzdC5cbiAqIEByZXR1cm4geyFBcnJheX0gUmV0dXJucyB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgYmVoYXZpb3JzLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQmVoYXZpb3JzKGJlaGF2aW9ycywgbGlzdCwgZXhjbHVkZSkge1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgZm9yIChsZXQgaT1iZWhhdmlvcnMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGIgPSBiZWhhdmlvcnNbaV07XG4gICAgaWYgKGIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIGZsYXR0ZW5CZWhhdmlvcnMoYiwgbGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWR1cFxuICAgICAgICBpZiAobGlzdC5pbmRleE9mKGIpIDwgMCAmJiAoIWV4Y2x1ZGUgfHwgZXhjbHVkZS5pbmRleE9mKGIpIDwgMCkpIHtcbiAgICAgICAgICBsaXN0LnVuc2hpZnQoYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdiZWhhdmlvciBpcyBudWxsLCBjaGVjayBmb3IgbWlzc2luZyBvciA0MDQgaW1wb3J0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IVBvbHltZXJJbml0fSBpbmZvIFBvbHltZXIgaW5mbyBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gQmFzZSBiYXNlIGNsYXNzIHRvIGV4dGVuZCB3aXRoIGluZm8gb2JqZWN0XG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBHZW5lcmF0ZWQgY2xhc3NcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhpbmZvLCBCYXNlKSB7XG5cbiAgY2xhc3MgUG9seW1lckdlbmVyYXRlZCBleHRlbmRzIEJhc2Uge1xuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIGluZm8ucHJvcGVydGllcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBpbmZvLm9ic2VydmVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBmb3IgdGhpcyBjbGFzc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAvLyBnZXQgdGVtcGxhdGUgZmlyc3QgZnJvbSBhbnkgaW1wZXJhdGl2ZSBzZXQgaW4gYGluZm8uX3RlbXBsYXRlYFxuICAgICAgcmV0dXJuIGluZm8uX3RlbXBsYXRlIHx8XG4gICAgICAgIC8vIG5leHQgbG9vayBpbiBkb20tbW9kdWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVsZW1lbnQncyBpcy5cbiAgICAgICAgRG9tTW9kdWxlICYmIERvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgLy8gbmV4dCBsb29rIGZvciBzdXBlcmNsYXNzIHRlbXBsYXRlIChub3RlOiB1c2Ugc3VwZXJjbGFzcyBzeW1ib2xcbiAgICAgICAgLy8gdG8gZW5zdXJlIGNvcnJlY3QgYHRoaXMuaXNgKVxuICAgICAgICBCYXNlLnRlbXBsYXRlIHx8XG4gICAgICAgIC8vIGZpbmFsbHkgZmFsbCBiYWNrIHRvIGBfdGVtcGxhdGVgIGluIGVsZW1lbnQncyBwcm90b3lwZS5cbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX3RlbXBsYXRlIHx8XG4gICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgIHN1cGVyLmNyZWF0ZWQoKTtcbiAgICAgIGlmIChpbmZvLmNyZWF0ZWQpIHtcbiAgICAgICAgaW5mby5jcmVhdGVkLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyZWQoKSB7XG4gICAgICBzdXBlci5fcmVnaXN0ZXJlZCgpO1xuICAgICAgLyogTk9URTogYGJlZm9yZVJlZ2lzdGVyYCBpcyBjYWxsZWQgaGVyZSBmb3IgYmMsIGJ1dCB0aGUgYmVoYXZpb3JcbiAgICAgICBpcyBkaWZmZXJlbnQgdGhhbiBpbiAxLnguIEluIDEuMCwgdGhlIG1ldGhvZCB3YXMgY2FsbGVkICphZnRlcipcbiAgICAgICBtaXhpbmcgcHJvdG90eXBlcyB0b2dldGhlciBidXQgKmJlZm9yZSogcHJvY2Vzc2luZyBvZiBtZXRhLW9iamVjdHMuXG4gICAgICAgSG93ZXZlciwgZHluYW1pYyBlZmZlY3RzIGNhbiBzdGlsbCBiZSBzZXQgaGVyZSBhbmQgY2FuIGJlIGRvbmUgZWl0aGVyXG4gICAgICAgaW4gYGJlZm9yZVJlZ2lzdGVyYCBvciBgcmVnaXN0ZXJlZGAuIEl0IGlzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXRcbiAgICAgICBgaXNgIGluIGBiZWZvcmVSZWdpc3RlcmAgYXMgeW91IGNvdWxkIGluIDEueC5cbiAgICAgICovXG4gICAgICBpZiAoaW5mby5iZWZvcmVSZWdpc3Rlcikge1xuICAgICAgICBpbmZvLmJlZm9yZVJlZ2lzdGVyLmNhbGwoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgaW5mby5yZWdpc3RlcmVkLmNhbGwoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXBwbHlMaXN0ZW5lcnMoKSB7XG4gICAgICBzdXBlci5fYXBwbHlMaXN0ZW5lcnMoKTtcbiAgICAgIGlmIChpbmZvLmxpc3RlbmVycykge1xuICAgICAgICBmb3IgKGxldCBsIGluIGluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgICAgdGhpcy5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZSh0aGlzLCBsLCBpbmZvLmxpc3RlbmVyc1tsXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3RlOiBleGNlcHRpb24gdG8gXCJzdXBlciB0aGVuIG1lXCIgcnVsZTtcbiAgICAvLyBkbyB3b3JrIGJlZm9yZSBjYWxsaW5nIHN1cGVyIHNvIHRoYXQgc3VwZXIgYXR0cmlidXRlc1xuICAgIC8vIG9ubHkgYXBwbHkgaWYgbm90IGFscmVhZHkgc2V0LlxuICAgIF9lbnN1cmVBdHRyaWJ1dGVzKCkge1xuICAgICAgaWYgKGluZm8uaG9zdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yIChsZXQgYSBpbiBpbmZvLmhvc3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgdGhpcy5fZW5zdXJlQXR0cmlidXRlKGEsIGluZm8uaG9zdEF0dHJpYnV0ZXNbYV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdXBlci5fZW5zdXJlQXR0cmlidXRlcygpO1xuICAgIH1cblxuICAgIHJlYWR5KCkge1xuICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICAgIGlmIChpbmZvLnJlYWR5KSB7XG4gICAgICAgIGluZm8ucmVhZHkuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRhY2hlZCgpIHtcbiAgICAgIHN1cGVyLmF0dGFjaGVkKCk7XG4gICAgICBpZiAoaW5mby5hdHRhY2hlZCkge1xuICAgICAgICBpbmZvLmF0dGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGV0YWNoZWQoKSB7XG4gICAgICBzdXBlci5kZXRhY2hlZCgpO1xuICAgICAgaWYgKGluZm8uZGV0YWNoZWQpIHtcbiAgICAgICAgaW5mby5kZXRhY2hlZC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgIGlmIChpbmZvLmF0dHJpYnV0ZUNoYW5nZWQpIHtcbiAgICAgICAgaW5mby5hdHRyaWJ1dGVDaGFuZ2VkLmNhbGwodGhpcywgbmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICB9XG4gICB9XG4gIH1cblxuICBQb2x5bWVyR2VuZXJhdGVkLmdlbmVyYXRlZEZyb20gPSBpbmZvO1xuXG4gIGZvciAobGV0IHAgaW4gaW5mbykge1xuICAgIC8vIE5PVEU6IGNhbm5vdCBjb3B5IGBtZXRhUHJvcHNgIG1ldGhvZHMgb250byBwcm90b3R5cGUgYXQgbGVhc3QgYmVjYXVzZVxuICAgIC8vIGBzdXBlci5yZWFkeWAgbXVzdCBiZSBjYWxsZWQgYW5kIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgdXNlciBmbi5cbiAgICBpZiAoIShwIGluIG1ldGFQcm9wcykpIHtcbiAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5mbywgcCk7XG4gICAgICBpZiAocGQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbHltZXJHZW5lcmF0ZWQucHJvdG90eXBlLCBwLCBwZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFBvbHltZXJHZW5lcmF0ZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBDbGFzcyA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKCFpbmZvKSB7XG4gICAgY29uc29sZS53YXJuKCdQb2x5bWVyLkNsYXNzIHJlcXVpcmVzIGBpbmZvYCBhcmd1bWVudCcpO1xuICB9XG4gIGxldCBrbGFzcyA9IEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhpbmZvLCBpbmZvLmJlaGF2aW9ycyA/XG4gICAgLy8gbm90ZTogbWl4aW5CZWhhdmlvcnMgZW5zdXJlcyBgTGVnYWN5RWxlbWVudE1peGluYC5cbiAgICBtaXhpbkJlaGF2aW9ycyhpbmZvLmJlaGF2aW9ycywgSFRNTEVsZW1lbnQpIDpcbiAgICBMZWdhY3lFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpKTtcbiAgLy8gZGVjb3JhdGUga2xhc3Mgd2l0aCByZWdpc3RyYXRpb24gaW5mb1xuICBrbGFzcy5pcyA9IGluZm8uaXM7XG4gIHJldHVybiBrbGFzcztcbn07XG5cbmV4cG9ydCB7IG1peGluQmVoYXZpb3JzIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9jbGFzcy5qcyIsImltcG9ydCB7IFRlbXBsYXRlSW5zdGFuY2VCYXNlIGFzIFRlbXBsYXRlSW5zdGFuY2VCYXNlJDAsIFRlbXBsYXRpemUgfSBmcm9tICcuLi91dGlscy90ZW1wbGF0aXplLmpzJztcblxubGV0IFRlbXBsYXRlSW5zdGFuY2VCYXNlID0gVGVtcGxhdGVJbnN0YW5jZUJhc2UkMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIF90ZW1wbGF0aXplclRlbXBsYXRlOiBIVE1MVGVtcGxhdGVFbGVtZW50LFxuICogICBfcGFyZW50TW9kZWw6IGJvb2xlYW4sXG4gKiAgIF9pbnN0YW5jZVByb3BzOiBPYmplY3QsXG4gKiAgIF9mb3J3YXJkSG9zdFByb3BWMjogRnVuY3Rpb24sXG4gKiAgIF9ub3RpZnlJbnN0YW5jZVByb3BWMjogRnVuY3Rpb24sXG4gKiAgIGN0b3I6IFRlbXBsYXRlSW5zdGFuY2VCYXNlXG4gKiB9fVxuICovXG5sZXQgVGVtcGxhdGl6ZXJVc2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogVGhlIGBQb2x5bWVyLlRlbXBsYXRpemVyYCBiZWhhdmlvciBhZGRzIG1ldGhvZHMgdG8gZ2VuZXJhdGUgaW5zdGFuY2VzIG9mXG4gKiB0ZW1wbGF0ZXMgdGhhdCBhcmUgZWFjaCBtYW5hZ2VkIGJ5IGFuIGFub255bW91cyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgXG4gKiBpbnN0YW5jZSB3aGVyZSBkYXRhLWJpbmRpbmdzIGluIHRoZSBzdGFtcGVkIHRlbXBsYXRlIGNvbnRlbnQgYXJlIGJvdW5kIHRvXG4gKiBhY2Nlc3NvcnMgb24gaXRzZWxmLlxuICpcbiAqIFRoaXMgYmVoYXZpb3IgaXMgcHJvdmlkZWQgaW4gUG9seW1lciAyLnggYXMgYSBoeWJyaWQtZWxlbWVudCBjb252ZW5pZW5jZVxuICogb25seS4gIEZvciBub24taHlicmlkIHVzYWdlLCB0aGUgYFBvbHltZXIuVGVtcGxhdGl6ZWAgbGlicmFyeVxuICogc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBHZXQgYSB0ZW1wbGF0ZSBmcm9tIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAqICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gKiAgICAgLy8gUHJlcGFyZSB0aGUgdGVtcGxhdGVcbiAqICAgICB0aGlzLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICogICAgIC8vIEluc3RhbmNlIHRoZSB0ZW1wbGF0ZSB3aXRoIGFuIGluaXRpYWwgZGF0YSBtb2RlbFxuICogICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuc3RhbXAoe215UHJvcDogJ2luaXRpYWwnfSk7XG4gKiAgICAgLy8gSW5zZXJ0IHRoZSBpbnN0YW5jZSdzIERPTSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gKiAgICAgUG9seW1lci5kb20odGhpcykuYXBwZW5kQ2hpbGQoaW5zdGFuY2Uucm9vdCk7XG4gKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAqICAgICAvLyBpbiB0aGUgdGVtcGxhdGVcbiAqICAgICBpbnN0YW5jZS5teVByb3AgPSAnbmV3IHZhbHVlJztcbiAqXG4gKiBVc2VycyBvZiBgVGVtcGxhdGl6ZXJgIG1heSBuZWVkIHRvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIGFic3RyYWN0XG4gKiBBUEkncyB0byBkZXRlcm1pbmUgaG93IHByb3BlcnRpZXMgYW5kIHBhdGhzIGZyb20gdGhlIGhvc3Qgc2hvdWxkIGJlXG4gKiBmb3J3YXJkZWQgaW50byB0byBpbnN0YW5jZXM6XG4gKlxuICogICAgIF9mb3J3YXJkSG9zdFByb3BWMjogZnVuY3Rpb24ocHJvcCwgdmFsdWUpXG4gKlxuICogTGlrZXdpc2UsIHVzZXJzIG1heSBpbXBsZW1lbnQgdGhlc2UgYWRkaXRpb25hbCBhYnN0cmFjdCBBUEkncyB0byBkZXRlcm1pbmVcbiAqIGhvdyBpbnN0YW5jZS1zcGVjaWZpYyBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIG9uIHRoZSBpbnN0YW5jZSBzaG91bGQgYmVcbiAqIGZvcndhcmRlZCBvdXQgdG8gdGhlIGhvc3QsIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiAgICAgX25vdGlmeUluc3RhbmNlUHJvcFYyOiBmdW5jdGlvbihpbnN0LCBwcm9wLCB2YWx1ZSlcbiAqXG4gKiBJbiBvcmRlciB0byBkZXRlcm1pbmUgd2hpY2ggcHJvcGVydGllcyBhcmUgaW5zdGFuY2Utc3BlY2lmaWMgYW5kIHJlcXVpcmVcbiAqIGN1c3RvbSBub3RpZmljYXRpb24gdmlhIGBfbm90aWZ5SW5zdGFuY2VQcm9wYCwgZGVmaW5lIGFuIGBfaW5zdGFuY2VQcm9wc2BcbiAqIG9iamVjdCBjb250YWluaW5nIGtleXMgZm9yIGVhY2ggaW5zdGFuY2UgcHJvcCwgZm9yIGV4YW1wbGU6XG4gKlxuICogICAgIF9pbnN0YW5jZVByb3BzOiB7XG4gKiAgICAgICBpdGVtOiB0cnVlLFxuICogICAgICAgaW5kZXg6IHRydWVcbiAqICAgICB9XG4gKlxuICogQW55IHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgdGVtcGxhdGUgdGhhdCBhcmUgbm90IGRlZmluZWQgaW4gX2luc3RhbmNlUHJvcFxuICogd2lsbCBiZSBmb3J3YXJkZWQgb3V0IHRvIHRoZSBUZW1wbGF0aXplIGBvd25lcmAgYXV0b21hdGljYWxseS5cbiAqXG4gKiBVc2VycyBtYXkgYWxzbyBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBhYnN0cmFjdCBmdW5jdGlvbiB0byBzaG93IG9yXG4gKiBoaWRlIGFueSBET00gZ2VuZXJhdGVkIHVzaW5nIGBzdGFtcGA6XG4gKlxuICogICAgIF9zaG93SGlkZUNoaWxkcmVuOiBmdW5jdGlvbihzaG91bGRIaWRlKVxuICpcbiAqIE5vdGUgdGhhdCBzb21lIGNhbGxiYWNrcyBhcmUgc3VmZml4ZWQgd2l0aCBgVjJgIGluIHRoZSBQb2x5bWVyIDIueCBiZWhhdmlvclxuICogYXMgdGhlIGltcGxlbWVudGF0aW9ucyB3aWxsIG5lZWQgdG8gZGlmZmVyIGZyb20gdGhlIGNhbGxiYWNrcyByZXF1aXJlZFxuICogYnkgdGhlIDEueCBUZW1wbGF0aXplciBBUEkgZHVlIHRvIGNoYW5nZXMgaW4gdGhlIGBUZW1wbGF0ZUluc3RhbmNlYCBBUElcbiAqIGJldHdlZW4gdmVyc2lvbnMgMS54IGFuZCAyLnguXG4gKlxuICogQHBvbHltZXJCZWhhdmlvclxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xubGV0IFRlbXBsYXRpemVyID0ge1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gYW5vbnltb3VzIGBUZW1wbGF0ZUluc3RhbmNlYCBjbGFzcyAoc3RvcmVkIGFzIGB0aGlzLmN0b3JgKVxuICAgKiBmb3IgdGhlIHByb3ZpZGVkIHRlbXBsYXRlLiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIHBlclxuICAgKiB0ZW1wbGF0ZSB0byBwcmVwYXJlIGFuIGVsZW1lbnQgZm9yIHN0YW1waW5nIHRoZSB0ZW1wbGF0ZSwgZm9sbG93ZWRcbiAgICogYnkgYHN0YW1wYCB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJlcGFyZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtdXRhYmxlRGF0YSBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXBcbiAgICogICBzdHJpY3QgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG9cbiAgICogICBiZSBcImRpcnR5XCIpLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICovXG4gIHRlbXBsYXRpemUodGVtcGxhdGUsIG11dGFibGVEYXRhKSB7XG4gICAgdGhpcy5fdGVtcGxhdGl6ZXJUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIHRoaXMuY3RvciA9IFRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW4obXV0YWJsZURhdGEpLFxuICAgICAgcGFyZW50TW9kZWw6IHRoaXMuX3BhcmVudE1vZGVsLFxuICAgICAgaW5zdGFuY2VQcm9wczogdGhpcy5faW5zdGFuY2VQcm9wcyxcbiAgICAgIGZvcndhcmRIb3N0UHJvcDogdGhpcy5fZm9yd2FyZEhvc3RQcm9wVjIsXG4gICAgICBub3RpZnlJbnN0YW5jZVByb3A6IHRoaXMuX25vdGlmeUluc3RhbmNlUHJvcFYyXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIHByZXBhcmVkIGJ5IGB0ZW1wbGF0aXplYC4gIFRoZSBvYmplY3RcbiAgICogcmV0dXJuZWQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGFub255bW91cyBjbGFzcyBnZW5lcmF0ZWQgYnkgYHRlbXBsYXRpemVgXG4gICAqIHdob3NlIGByb290YCBwcm9wZXJ0eSBpcyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgbmV3bHkgY2xvbmVkXG4gICAqIHRlbXBsYXRlIGNvbnRlbnQsIGFuZCB3aGljaCBoYXMgcHJvcGVydHkgYWNjZXNzb3JzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICogcHJvcGVydGllcyByZWZlcmVuY2VkIGluIHRlbXBsYXRlIGJpbmRpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdD19IG1vZGVsIE9iamVjdCBjb250YWluaW5nIGluaXRpYWwgcHJvcGVydHkgdmFsdWVzIHRvXG4gICAqICAgcG9wdWxhdGUgaW50byB0aGUgdGVtcGxhdGUgYmluZGluZ3MuXG4gICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBSZXR1cm5zIHRoZSBjcmVhdGVkIGluc3RhbmNlIG9mXG4gICAqIHRoZSB0ZW1wbGF0ZSBwcmVwYXJlZCBieSBgdGVtcGxhdGl6ZWAuXG4gICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAqL1xuICBzdGFtcChtb2RlbCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jdG9yKG1vZGVsKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIChgVGVtcGxhdGVJbnN0YW5jZWApIGFzc29jaWF0ZWQgd2l0aFxuICAgKiBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlXG4gICAqIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbi4gIEEgdGVtcGxhdGUgbW9kZWwgc2hvdWxkIGJlIHVzZWRcbiAgICogdG8gbWFuaXB1bGF0ZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IE1vZGVsIHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICogICB0aGUgZWxlbWVudC5cbiAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICovXG4gIG1vZGVsRm9yRWxlbWVudChlbCkge1xuICAgIHJldHVybiBUZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLl90ZW1wbGF0aXplclRlbXBsYXRlLCBlbCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IFRlbXBsYXRpemVyIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuLi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBPcHRpb25hbE11dGFibGVEYXRhIH0gZnJvbSAnLi4vbWl4aW5zL211dGFibGUtZGF0YS5qcyc7XG5pbXBvcnQgeyBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuLi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0hUTUxFbGVtZW50fVxuICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAqL1xuY29uc3QgZG9tQmluZEJhc2UgPVxuICBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMoXG4gICAgT3B0aW9uYWxNdXRhYmxlRGF0YShcbiAgICAgIFByb3BlcnR5RWZmZWN0cyhIVE1MRWxlbWVudCkpKTtcblxuLyoqXG4gKiBDdXN0b20gZWxlbWVudCB0byBhbGxvdyB1c2luZyBQb2x5bWVyJ3MgdGVtcGxhdGUgZmVhdHVyZXMgKGRhdGEgYmluZGluZyxcbiAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycywgZXRjLikgaW4gdGhlIG1haW4gZG9jdW1lbnQgd2l0aG91dCBkZWZpbmluZ1xuICogYSBuZXcgY3VzdG9tIGVsZW1lbnQuXG4gKlxuICogYDx0ZW1wbGF0ZT5gIHRhZ3MgdXRpbGl6aW5nIGJpbmRpbmdzIG1heSBiZSB3cmFwcGVkIHdpdGggdGhlIGA8ZG9tLWJpbmQ+YFxuICogZWxlbWVudCwgd2hpY2ggd2lsbCBpbW1lZGlhdGVseSBzdGFtcCB0aGUgd3JhcHBlZCB0ZW1wbGF0ZSBpbnRvIHRoZSBtYWluXG4gKiBkb2N1bWVudCBhbmQgYmluZCBlbGVtZW50cyB0byB0aGUgYGRvbS1iaW5kYCBlbGVtZW50IGl0c2VsZiBhcyB0aGVcbiAqIGJpbmRpbmcgc2NvcGUuXG4gKlxuICogQHBvbHltZXJcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuT3B0aW9uYWxNdXRhYmxlRGF0YVxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkdlc3R1cmVFdmVudExpc3RlbmVyc1xuICogQGV4dGVuZHMge2RvbUJpbmRCYXNlfVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YVxuICogICBiaW5kaW5nLCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy4pIGluIHRoZSBtYWluIGRvY3VtZW50LlxuICovXG5jbGFzcyBEb21CaW5kIGV4dGVuZHMgZG9tQmluZEJhc2Uge1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydtdXRhYmxlLWRhdGEnXTsgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB0aGlzLiQgPSBudWxsO1xuICAgIHRoaXMuX19jaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICAvLyBhc3N1bWVzIG9ubHkgb25lIG9ic2VydmVkIGF0dHJpYnV0ZVxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5tdXRhYmxlRGF0YSA9IHRydWU7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fX3JlbW92ZUNoaWxkcmVuKCk7XG4gIH1cblxuICBfX2luc2VydENoaWxkcmVuKCkge1xuICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5yb290LCB0aGlzKTtcbiAgfVxuXG4gIF9fcmVtb3ZlQ2hpbGRyZW4oKSB7XG4gICAgaWYgKHRoaXMuX19jaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5fX2NoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gVGhpcyBpcyB0eXBpY2FsbHkgb25seVxuICAgKiBuZWNlc3NhcnkgdG8gY2FsbCBpZiBIVE1MSW1wb3J0cyB3aXRoIHRoZSBhc3luYyBhdHRyaWJ1dGUgYXJlIHVzZWQuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHRlbXBsYXRlO1xuICAgIGlmICghdGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGVtcGxhdGUgfHwgdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgIHRlbXBsYXRlID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpO1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20tYmluZCByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgIHRoaXMuX19jaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChsZXQgbj10aGlzLnJvb3QuZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHRoaXMuX19jaGlsZHJlblt0aGlzLl9fY2hpbGRyZW4ubGVuZ3RoXSA9IG47XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICAgIHRoaXMuX19pbnNlcnRDaGlsZHJlbigpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9KSk7XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2RvbS1iaW5kJywgRG9tQmluZCk7XG5cbmV4cG9ydCB7IERvbUJpbmQgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWJpbmQuanMiLCJpbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vLi4vcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IFRlbXBsYXRpemUgfSBmcm9tICcuLi91dGlscy90ZW1wbGF0aXplLmpzJztcbmltcG9ydCB7IERlYm91bmNlciB9IGZyb20gJy4uL3V0aWxzL2RlYm91bmNlLmpzJztcbmltcG9ydCB7IGVucXVldWVEZWJvdW5jZXIsIGZsdXNoIH0gZnJvbSAnLi4vdXRpbHMvZmx1c2guanMnO1xuaW1wb3J0IHsgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuaW1wb3J0IHsgcm9vdCBhcyByb290JDAgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcblxuLyoqXG4gKiBUaGUgYDxkb20taWY+YCBlbGVtZW50IHdpbGwgc3RhbXAgYSBsaWdodC1kb20gYDx0ZW1wbGF0ZT5gIGNoaWxkIHdoZW5cbiAqIHRoZSBgaWZgIHByb3BlcnR5IGJlY29tZXMgdHJ1dGh5LCBhbmQgdGhlIHRlbXBsYXRlIGNhbiB1c2UgUG9seW1lclxuICogZGF0YS1iaW5kaW5nIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBmZWF0dXJlcyB3aGVuIHVzZWQgaW4gdGhlIGNvbnRleHQgb2ZcbiAqIGEgUG9seW1lciBlbGVtZW50J3MgdGVtcGxhdGUuXG4gKlxuICogV2hlbiBgaWZgIGJlY29tZXMgZmFsc2V5LCB0aGUgc3RhbXBlZCBjb250ZW50IGlzIGhpZGRlbiBidXQgbm90XG4gKiByZW1vdmVkIGZyb20gZG9tLiBXaGVuIGBpZmAgc3Vic2VxdWVudGx5IGJlY29tZXMgdHJ1dGh5IGFnYWluLCB0aGUgY29udGVudFxuICogaXMgc2ltcGx5IHJlLXNob3duLiBUaGlzIGFwcHJvYWNoIGlzIHVzZWQgZHVlIHRvIGl0cyBmYXZvcmFibGUgcGVyZm9ybWFuY2VcbiAqIGNoYXJhY3RlcmlzdGljczogdGhlIGV4cGVuc2Ugb2YgY3JlYXRpbmcgdGVtcGxhdGUgY29udGVudCBpcyBwYWlkIG9ubHlcbiAqIG9uY2UgYW5kIGxhemlseS5cbiAqXG4gKiBTZXQgdGhlIGByZXN0YW1wYCBwcm9wZXJ0eSB0byB0cnVlIHRvIGZvcmNlIHRoZSBzdGFtcGVkIGNvbnRlbnQgdG8gYmVcbiAqIGNyZWF0ZWQgLyBkZXN0cm95ZWQgd2hlbiB0aGUgYGlmYCBjb25kaXRpb24gY2hhbmdlcy5cbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQHBvbHltZXJcbiAqIEBleHRlbmRzIFBvbHltZXIuRWxlbWVudFxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgY29uZGl0aW9uYWxseSBzdGFtcHMgYW5kIGhpZGVzIG9yIHJlbW92ZXNcbiAqICAgdGVtcGxhdGUgY29udGVudCBiYXNlZCBvbiBhIGJvb2xlYW4gZmxhZy5cbiAqL1xuY2xhc3MgRG9tSWYgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLWlmJzsgfVxuXG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuZXZlciBET00gaXMgYWRkZWQgb3IgcmVtb3ZlZC9oaWRkZW4gYnkgdGhpcyB0ZW1wbGF0ZSAoYnlcbiAgICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgICAqIGByZW5kZXJgLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgdGVtcGxhdGUgc2hvdWxkIHN0YW1wLlxuICAgICAgICovXG4gICAgICBpZjoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBvYnNlcnZlcjogJ19fZGVib3VuY2VSZW5kZXInXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdHJ1ZSwgZWxlbWVudHMgd2lsbCBiZSByZW1vdmVkIGZyb20gRE9NIGFuZCBkaXNjYXJkZWQgd2hlbiBgaWZgXG4gICAgICAgKiBiZWNvbWVzIGZhbHNlIGFuZCByZS1jcmVhdGVkIGFuZCBhZGRlZCBiYWNrIHRvIHRoZSBET00gd2hlbiBgaWZgXG4gICAgICAgKiBiZWNvbWVzIHRydWUuICBCeSBkZWZhdWx0LCBzdGFtcGVkIGVsZW1lbnRzIHdpbGwgYmUgaGlkZGVuIGJ1dCBsZWZ0XG4gICAgICAgKiBpbiB0aGUgRE9NIHdoZW4gYGlmYCBiZWNvbWVzIGZhbHNlLCB3aGljaCBpcyBnZW5lcmFsbHkgcmVzdWx0c1xuICAgICAgICogaW4gYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICovXG4gICAgICByZXN0YW1wOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgIH1cblxuICAgIH07XG5cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IG51bGw7XG4gICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5fX2luc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0SWYgPSBmYWxzZTtcbiAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gIH1cblxuICBfX2RlYm91bmNlUmVuZGVyKCkge1xuICAgIC8vIFJlbmRlciBpcyBhc3luYyBmb3IgMiByZWFzb25zOlxuICAgIC8vIDEuIFRvIGVsaW1pbmF0ZSBkb20gY3JlYXRpb24gdHJhc2hpbmcgaWYgdXNlciBjb2RlIHRocmFzaGVzIGBpZmAgaW4gdGhlXG4gICAgLy8gICAgc2FtZSB0dXJuLiBUaGlzIHdhcyBtb3JlIGNvbW1vbiBpbiAxLnggd2hlcmUgYSBjb21wb3VuZCBjb21wdXRlZFxuICAgIC8vICAgIHByb3BlcnR5IGNvdWxkIHJlc3VsdCBpbiB0aGUgcmVzdWx0IGNoYW5naW5nIG11bHRpcGxlIHRpbWVzLCBidXQgaXNcbiAgICAvLyAgICBtaXRpZ2F0ZWQgdG8gYSBsYXJnZSBleHRlbnQgYnkgYmF0Y2hlZCBwcm9wZXJ0eSBwcm9jZXNzaW5nIGluIDIueC5cbiAgICAvLyAyLiBUbyBhdm9pZCBkb3VibGUgb2JqZWN0IHByb3BhZ2F0aW9uIHdoZW4gYSBiYWcgaW5jbHVkaW5nIHZhbHVlcyBib3VuZFxuICAgIC8vICAgIHRvIHRoZSBgaWZgIHByb3BlcnR5IGFzIHdlbGwgYXMgb25lIG9yIG1vcmUgaG9zdFByb3BzIGNvdWxkIGVucXVldWVcbiAgICAvLyAgICB0aGUgPGRvbS1pZj4gdG8gZmx1c2ggYmVmb3JlIHRoZSA8dGVtcGxhdGU+J3MgaG9zdCBwcm9wZXJ0eVxuICAgIC8vICAgIGZvcndhcmRpbmcuIEluIHRoYXQgc2NlbmFyaW8gY3JlYXRpbmcgYW4gaW5zdGFuY2Ugd291bGQgcmVzdWx0IGluXG4gICAgLy8gICAgdGhlIGhvc3QgcHJvcHMgYmVpbmcgc2V0IG9uY2UsIGFuZCB0aGVuIHRoZSBlbnF1ZXVlZCBjaGFuZ2VzIG9uIHRoZVxuICAgIC8vICAgIHRlbXBsYXRlIHdvdWxkIHNldCBwcm9wZXJ0aWVzIGEgc2Vjb25kIHRpbWUsIHBvdGVudGlhbGx5IGNhdXNpbmcgYW5cbiAgICAvLyAgICBvYmplY3QgdG8gYmUgc2V0IHRvIGFuIGluc3RhbmNlIG1vcmUgdGhhbiBvbmNlLiAgQ3JlYXRpbmcgdGhlXG4gICAgLy8gICAgaW5zdGFuY2UgYXN5bmMgZnJvbSBmbHVzaGluZyBkYXRhIGVuc3VyZXMgdGhpcyBkb2Vzbid0IGhhcHBlbi4gSWZcbiAgICAvLyAgICB3ZSB3YW50ZWQgYSBzeW5jIG9wdGlvbiBpbiB0aGUgZnV0dXJlLCBzaW1wbHkgaGF2aW5nIDxkb20taWY+IGZsdXNoXG4gICAgLy8gICAgKG9yIGNsZWFyKSBpdHMgdGVtcGxhdGUncyBwZW5kaW5nIGhvc3QgcHJvcGVydGllcyBiZWZvcmUgY3JlYXRpbmdcbiAgICAvLyAgICB0aGUgaW5zdGFuY2Ugd291bGQgYWxzbyBhdm9pZCB0aGUgcHJvYmxlbS5cbiAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgLCBtaWNyb1Rhc2tcbiAgICAgICAgLCAoKSA9PiB0aGlzLl9fcmVuZGVyKCkpO1xuICAgIGVucXVldWVEZWJvdW5jZXIodGhpcy5fX3JlbmRlckRlYm91bmNlcik7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIGlmICghdGhpcy5wYXJlbnROb2RlIHx8XG4gICAgICAgICh0aGlzLnBhcmVudE5vZGUubm9kZVR5cGUgPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmXG4gICAgICAgICAhdGhpcy5wYXJlbnROb2RlLmhvc3QpKSB7XG4gICAgICB0aGlzLl9fdGVhcmRvd25JbnN0YW5jZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBOb3JtYWxseSByZW5kZXJpbmcgaXNcbiAgICogYXN5bmNocm9ub3VzIHRvIGEgcHJvdm9raW5nIGNoYW5nZS4gVGhpcyBpcyBkb25lIGZvciBlZmZpY2llbmN5IHNvXG4gICAqIHRoYXQgbXVsdGlwbGUgY2hhbmdlcyB0cmlnZ2VyIG9ubHkgYSBzaW5nbGUgcmVuZGVyLiBUaGUgcmVuZGVyIG1ldGhvZFxuICAgKiBzaG91bGQgYmUgY2FsbGVkIGlmLCBmb3IgZXhhbXBsZSwgdGVtcGxhdGUgcmVuZGVyaW5nIGlzIHJlcXVpcmVkIHRvXG4gICAqIHZhbGlkYXRlIGFwcGxpY2F0aW9uIHN0YXRlLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGZsdXNoKCk7XG4gIH1cblxuICBfX3JlbmRlcigpIHtcbiAgICBpZiAodGhpcy5pZikge1xuICAgICAgaWYgKCF0aGlzLl9fZW5zdXJlSW5zdGFuY2UoKSkge1xuICAgICAgICAvLyBObyB0ZW1wbGF0ZSBmb3VuZCB5ZXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZXN0YW1wKSB7XG4gICAgICB0aGlzLl9fdGVhcmRvd25JbnN0YW5jZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVzdGFtcCAmJiB0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWYgIT0gdGhpcy5fbGFzdElmKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgfSkpO1xuICAgICAgdGhpcy5fbGFzdElmID0gdGhpcy5pZjtcbiAgICB9XG4gIH1cblxuICBfX2Vuc3VyZUluc3RhbmNlKCkge1xuICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIC8vIEd1YXJkIGFnYWluc3QgZWxlbWVudCBiZWluZyBkZXRhY2hlZCB3aGlsZSByZW5kZXIgd2FzIHF1ZXVlZFxuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgICAgbGV0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgIHRoaXMuX19yZW5kZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLWlmIHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fY3RvciA9IFRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICAgICAgICAgIC8vIGRvbS1pZiB0ZW1wbGF0aXplciBpbnN0YW5jZXMgcmVxdWlyZSBgbXV0YWJsZTogdHJ1ZWAsIGFzXG4gICAgICAgICAgLy8gYF9fc3luY0hvc3RQcm9wZXJ0aWVzYCByZWxpZXMgb24gdGhhdCBiZWhhdmlvciB0byBzeW5jIG9iamVjdHNcbiAgICAgICAgICBtdXRhYmxlRGF0YTogdHJ1ZSxcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBmb3J3YXJkXG4gICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiBwcm9wZXJ0eVxuICAgICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW5zdGFuY2UuZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGluc3RhbmNlIGJ1dCBhcmUgc3F1ZWxjaGluZyBob3N0IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gZm9yd2FyZGluZyBkdWUgdG8gaWYgYmVpbmcgZmFsc2UsIG5vdGUgdGhlIGludmFsaWRhdGVkXG4gICAgICAgICAgICAgICAgLy8gcHJvcGVydGllcyBzbyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIGNhbiBzeW5jIHRoZW0gdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyB0aW1lIGBpZmAgYmVjb21lcyB0cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IHRoaXMuX19pbnZhbGlkUHJvcHMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzW3Jvb3QkMChwcm9wKV0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG5ldyB0aGlzLl9fY3RvcigpO1xuICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9faW5zdGFuY2Uucm9vdCwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fc3luY0hvc3RQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGxldCBjJCA9IHRoaXMuX19pbnN0YW5jZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGMkICYmIGMkLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERldGVjdCBjYXNlIHdoZXJlIGRvbS1pZiB3YXMgcmUtYXR0YWNoZWQgaW4gbmV3IHBvc2l0aW9uXG4gICAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHRoaXMucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIGlmIChsYXN0Q2hpbGQgIT09IGMkW2MkLmxlbmd0aC0xXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxjJC5sZW5ndGgpICYmIChuPWMkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9fc3luY0hvc3RQcm9wZXJ0aWVzKCkge1xuICAgIGxldCBwcm9wcyA9IHRoaXMuX19pbnZhbGlkUHJvcHM7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX19pbnN0YW5jZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHRoaXMuX19kYXRhSG9zdFtwcm9wXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICAgIHRoaXMuX19pbnN0YW5jZS5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICB9XG5cbiAgX190ZWFyZG93bkluc3RhbmNlKCkge1xuICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgIGxldCBjJCA9IHRoaXMuX19pbnN0YW5jZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjJCAmJiBjJC5sZW5ndGgpIHtcbiAgICAgICAgLy8gdXNlIGZpcnN0IGNoaWxkIHBhcmVudCwgZm9yIGNhc2Ugd2hlbiBkb20taWYgbWF5IGhhdmUgYmVlbiBkZXRhY2hlZFxuICAgICAgICBsZXQgcGFyZW50ID0gYyRbMF0ucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxjJC5sZW5ndGgpICYmIChuPWMkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX3Nob3dIaWRlQ2hpbGRyZW4oKSB7XG4gICAgbGV0IGhpZGRlbiA9IHRoaXMuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fIHx8ICF0aGlzLmlmO1xuICAgIGlmICh0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX19pbnN0YW5jZS5fc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pO1xuICAgIH1cbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21JZi5pcywgRG9tSWYpO1xuXG5leHBvcnQgeyBEb21JZiB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuanMiLCJpbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vLi4vcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVTcGxpY2VzIH0gZnJvbSAnLi4vdXRpbHMvYXJyYXktc3BsaWNlLmpzJztcbmltcG9ydCB7IEVsZW1lbnRNaXhpbiB9IGZyb20gJy4uL21peGlucy9lbGVtZW50LW1peGluLmpzJztcblxuLyoqXG4gKiBFbGVtZW50IG1peGluIGZvciByZWNvcmRpbmcgZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGFcbiAqIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhIGBzZWxlY3RlZGAgYXJyYXkgc3VjaCB0aGF0IHBhdGggY2hhbmdlcyB0byB0aGVcbiAqIG1hc3RlciBhcnJheSAoYXQgdGhlIGhvc3QpIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZVxuICogY29ycmVjdGx5IHByb3BhZ2F0ZWQgdG8gaXRlbXMgaW4gdGhlIHNlbGVjdGVkIGFycmF5IGFuZCB2aWNlLXZlcnNhLlxuICpcbiAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICogYHNlbGVjdChpdGVtKWAgYW5kIGBkZXNlbGVjdChpdGVtKWAgQVBJLCB1cGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHByb3BlcnR5XG4gKiB3aGljaCBtYXkgYmUgYm91bmQgdG8gb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLCBhbmQgYW55IGNoYW5nZXMgdG9cbiAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gKiBgaXRlbXNgIGFycmF5LiAgV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCBgc2VsZWN0ZWRgIGlzIGEgcHJvcGVydHlcbiAqIHJlcHJlc2VudGluZyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtLiAgV2hlbiBgbXVsdGlgIGlzIHRydWUsIGBzZWxlY3RlZGBcbiAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICpcbiAqIEBwb2x5bWVyXG4gKiBAbWl4aW5GdW5jdGlvblxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICogbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGEgYHNlbGVjdGVkYCBhcnJheVxuICovXG5sZXQgQXJyYXlTZWxlY3Rvck1peGluID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqL1xuICBsZXQgZWxlbWVudEJhc2UgPSBFbGVtZW50TWl4aW4oc3VwZXJDbGFzcyk7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgQXJyYXlTZWxlY3Rvck1peGluIGV4dGVuZHMgZWxlbWVudEJhc2Uge1xuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuXG4gICAgICByZXR1cm4ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGl0ZW1zIGZyb20gd2hpY2ggc2VsZWN0aW9uIHdpbGwgYmUgbWFkZS5cbiAgICAgICAgICovXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYHRydWVgLCBtdWx0aXBsZSBpdGVtcyBtYXkgYmUgc2VsZWN0ZWQgYXQgb25jZSAoaW4gdGhpcyBjYXNlLFxuICAgICAgICAgKiBgc2VsZWN0ZWRgIGlzIGFuIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtcykuICBXaGVuIGBmYWxzZWAsXG4gICAgICAgICAqIG9ubHkgb25lIGl0ZW0gbWF5IGJlIHNlbGVjdGVkIGF0IGEgdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyB0cnVlLCB0aGlzIGlzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgYW55IHNlbGVjdGVkLlxuICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCBvciBgbnVsbGBcbiAgICAgICAgICogaWYgbm8gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICogQHR5cGUgez8oT2JqZWN0fEFycmF5PCFPYmplY3Q+KX1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCBvciBgbnVsbGBcbiAgICAgICAgICogaWYgbm8gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICogQHR5cGUgez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZEl0ZW06IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYHRydWVgLCBjYWxsaW5nIGBzZWxlY3RgIG9uIGFuIGl0ZW0gdGhhdCBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgICAqIHdpbGwgZGVzZWxlY3QgdGhlIGl0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICB0b2dnbGU6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gWydfX3VwZGF0ZVNlbGVjdGlvbihtdWx0aSwgaXRlbXMuKiknXTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9fbGFzdEl0ZW1zID0gbnVsbDtcbiAgICAgIHRoaXMuX19sYXN0TXVsdGkgPSBudWxsO1xuICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbnVsbDtcbiAgICB9XG5cbiAgICBfX3VwZGF0ZVNlbGVjdGlvbihtdWx0aSwgaXRlbXNJbmZvKSB7XG4gICAgICBsZXQgcGF0aCA9IGl0ZW1zSW5mby5wYXRoO1xuICAgICAgaWYgKHBhdGggPT0gJ2l0ZW1zJykge1xuICAgICAgICAvLyBDYXNlIDEgLSBpdGVtcyBhcnJheSBjaGFuZ2VkLCBzbyBkaWZmIGFnYWluc3QgcHJldmlvdXMgYXJyYXkgYW5kXG4gICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICBsZXQgbmV3SXRlbXMgPSBpdGVtc0luZm8uYmFzZSB8fCBbXTtcbiAgICAgICAgbGV0IGxhc3RJdGVtcyA9IHRoaXMuX19sYXN0SXRlbXM7XG4gICAgICAgIGxldCBsYXN0TXVsdGkgPSB0aGlzLl9fbGFzdE11bHRpO1xuICAgICAgICBpZiAobXVsdGkgIT09IGxhc3RNdWx0aSkge1xuICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEl0ZW1zKSB7XG4gICAgICAgICAgbGV0IHNwbGljZXMgPSBjYWxjdWxhdGVTcGxpY2VzKG5ld0l0ZW1zLCBsYXN0SXRlbXMpO1xuICAgICAgICAgIHRoaXMuX19hcHBseVNwbGljZXMoc3BsaWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2xhc3RJdGVtcyA9IG5ld0l0ZW1zO1xuICAgICAgICB0aGlzLl9fbGFzdE11bHRpID0gbXVsdGk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zSW5mby5wYXRoID09ICdpdGVtcy5zcGxpY2VzJykge1xuICAgICAgICAvLyBDYXNlIDIgLSBnb3Qgc3BlY2lmaWMgc3BsaWNlIGluZm9ybWF0aW9uIGRlc2NyaWJpbmcgdGhlIGFycmF5IG11dGF0aW9uOlxuICAgICAgICAvLyBkZXNlbGVjdCBhbnkgcmVtb3ZlZCBpdGVtcyBhbmQgYWRqdXN0IHNlbGVjdGVkIGluZGljZXNcbiAgICAgICAgdGhpcy5fX2FwcGx5U3BsaWNlcyhpdGVtc0luZm8udmFsdWUuaW5kZXhTcGxpY2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhc2UgMyAtIGFuIGFycmF5IGVsZW1lbnQgd2FzIGNoYW5nZWQsIHNvIGRlc2VsZWN0IHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBpdGVtIGZvciB0aGF0IGluZGV4IGlmIGl0IHdhcyBwcmV2aW91c2x5IHNlbGVjdGVkXG4gICAgICAgIGxldCBwYXJ0ID0gcGF0aC5zbGljZSgnaXRlbXMuJy5sZW5ndGgpO1xuICAgICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocGFydCwgMTApO1xuICAgICAgICBpZiAoKHBhcnQuaW5kZXhPZignLicpIDwgMCkgJiYgcGFydCA9PSBpZHgpIHtcbiAgICAgICAgICB0aGlzLl9fZGVzZWxlY3RDaGFuZ2VkSWR4KGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX2FwcGx5U3BsaWNlcyhzcGxpY2VzKSB7XG4gICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLl9fc2VsZWN0ZWRNYXA7XG4gICAgICAvLyBBZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlcyBhbmQgbWFyayByZW1vdmFsc1xuICAgICAgZm9yIChsZXQgaT0wOyBpPHNwbGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHMgPSBzcGxpY2VzW2ldO1xuICAgICAgICBzZWxlY3RlZC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoaWR4IDwgcy5pbmRleCkge1xuICAgICAgICAgICAgLy8gbm8gY2hhbmdlXG4gICAgICAgICAgfSBlbHNlIGlmIChpZHggPj0gcy5pbmRleCArIHMucmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGFkanVzdCBpbmRleFxuICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KGl0ZW0sIGlkeCArIHMuYWRkZWRDb3VudCAtIHMucmVtb3ZlZC5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgaW5kZXhcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldChpdGVtLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPHMuYWRkZWRDb3VudDsgaisrKSB7XG4gICAgICAgICAgbGV0IGlkeCA9IHMuaW5kZXggKyBqO1xuICAgICAgICAgIGlmIChzZWxlY3RlZC5oYXModGhpcy5pdGVtc1tpZHhdKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KHRoaXMuaXRlbXNbaWR4XSwgaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSBsaW5rZWQgcGF0aHNcbiAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgLy8gUmVtb3ZlIHNlbGVjdGVkIGl0ZW1zIHRoYXQgd2VyZSByZW1vdmVkIGZyb20gdGhlIGl0ZW1zIGFycmF5XG4gICAgICBsZXQgc2lkeCA9IDA7XG4gICAgICBzZWxlY3RlZC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkJywgc2lkeCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdGVkLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9fdXBkYXRlTGlua3MoKSB7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0ge307XG4gICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICBsZXQgc2lkeCA9IDA7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtQYXRocygnaXRlbXMuJyArIGlkeCwgJ3NlbGVjdGVkLicgKyBzaWR4KyspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZCcsICdpdGVtcy4nICsgaWR4KTtcbiAgICAgICAgICB0aGlzLmxpbmtQYXRocygnc2VsZWN0ZWRJdGVtJywgJ2l0ZW1zLicgKyBpZHgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHNlbGVjdGlvbiBzdGF0ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgLy8gVW5iaW5kIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHt9O1xuICAgICAgLy8gVGhlIHNlbGVjdGVkIG1hcCBzdG9yZXMgMyBwaWVjZXMgb2YgaW5mb3JtYXRpb246XG4gICAgICAvLyBrZXk6IGl0ZW1zIGFycmF5IG9iamVjdFxuICAgICAgLy8gdmFsdWU6IGl0ZW1zIGFycmF5IGluZGV4XG4gICAgICAvLyBvcmRlcjogc2VsZWN0ZWQgYXJyYXkgaW5kZXhcbiAgICAgIHRoaXMuX19zZWxlY3RlZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uXG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5tdWx0aSA/IFtdIDogbnVsbDtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNTZWxlY3RlZChpdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NlbGVjdGVkTWFwLmhhcyhpdGVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBpc0luZGV4U2VsZWN0ZWQoaWR4KSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGVkKHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgfVxuXG4gICAgX19kZXNlbGVjdENoYW5nZWRJZHgoaWR4KSB7XG4gICAgICBsZXQgc2lkeCA9IHRoaXMuX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCk7XG4gICAgICBpZiAoc2lkeCA+PSAwKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChzaWR4ID09IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpIHtcbiAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX19kYXRhTGlua2VkUGF0aHNbJ2l0ZW1zLicgKyBpZHhdO1xuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChzZWxlY3RlZC5zbGljZSgnc2VsZWN0ZWQuJy5sZW5ndGgpLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIHRoZSBnaXZlbiBpdGVtIGlmIGl0IGlzIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gZGVzZWxlY3RcbiAgICAgKi9cbiAgICBkZXNlbGVjdChpdGVtKSB7XG4gICAgICBsZXQgaWR4ID0gdGhpcy5fX3NlbGVjdGVkTWFwLmdldChpdGVtKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZGVsZXRlKGl0ZW0pO1xuICAgICAgICBsZXQgc2lkeDtcbiAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICBzaWR4ID0gdGhpcy5fX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIHRoZSBnaXZlbiBpbmRleCBpZiBpdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gZGVzZWxlY3RcbiAgICAgKi9cbiAgICBkZXNlbGVjdEluZGV4KGlkeCkge1xuICAgICAgdGhpcy5kZXNlbGVjdCh0aGlzLml0ZW1zW2lkeF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0uICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICogZGVzZWxlY3QgdGhlIGl0ZW0gaWYgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBzZWxlY3RcbiAgICAgKi9cbiAgICBzZWxlY3QoaXRlbSkge1xuICAgICAgdGhpcy5zZWxlY3RJbmRleCh0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIGluZGV4LiAgV2hlbiBgdG9nZ2xlYCBpcyB0cnVlLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAqIGRlc2VsZWN0IHRoZSBpdGVtIGlmIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBzZWxlY3RcbiAgICAgKi9cbiAgICBzZWxlY3RJbmRleChpZHgpIHtcbiAgICAgIGxldCBpdGVtID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQoaXRlbSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm11bHRpKSB7XG4gICAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLnNldChpdGVtLCBpZHgpO1xuICAgICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICB0aGlzLnB1c2goJ3NlbGVjdGVkJywgaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnRvZ2dsZSkge1xuICAgICAgICB0aGlzLmRlc2VsZWN0SW5kZXgoaWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBBcnJheVNlbGVjdG9yTWl4aW47XG5cbn0pO1xuXG5leHBvcnQgeyBBcnJheVNlbGVjdG9yTWl4aW4gfTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9BcnJheVNlbGVjdG9yTWl4aW59XG4gKi9cbmxldCBiYXNlQXJyYXlTZWxlY3RvciA9IEFycmF5U2VsZWN0b3JNaXhpbihFbGVtZW50KTtcblxuLyoqXG4gKiBFbGVtZW50IGltcGxlbWVudGluZyB0aGUgYFBvbHltZXIuQXJyYXlTZWxlY3RvcmAgbWl4aW4sIHdoaWNoIHJlY29yZHNcbiAqIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhXG4gKiBgc2VsZWN0ZWRgIGFycmF5IHN1Y2ggdGhhdCBwYXRoIGNoYW5nZXMgdG8gdGhlIG1hc3RlciBhcnJheSAoYXQgdGhlIGhvc3QpXG4gKiBlbGVtZW50IG9yIGVsc2V3aGVyZSB2aWEgZGF0YS1iaW5kaW5nKSBhcmUgY29ycmVjdGx5IHByb3BhZ2F0ZWQgdG8gaXRlbXNcbiAqIGluIHRoZSBzZWxlY3RlZCBhcnJheSBhbmQgdmljZS12ZXJzYS5cbiAqXG4gKiBUaGUgYGl0ZW1zYCBwcm9wZXJ0eSBhY2NlcHRzIGFuIGFycmF5IG9mIHVzZXIgZGF0YSwgYW5kIHZpYSB0aGVcbiAqIGBzZWxlY3QoaXRlbSlgIGFuZCBgZGVzZWxlY3QoaXRlbSlgIEFQSSwgdXBkYXRlcyB0aGUgYHNlbGVjdGVkYCBwcm9wZXJ0eVxuICogd2hpY2ggbWF5IGJlIGJvdW5kIHRvIG90aGVyIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiwgYW5kIGFueSBjaGFuZ2VzIHRvXG4gKiBzdWItZmllbGRzIG9mIGBzZWxlY3RlZGAgaXRlbShzKSB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIGl0ZW1zIGluIHRoZVxuICogYGl0ZW1zYCBhcnJheS4gIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgYHNlbGVjdGVkYCBpcyBhIHByb3BlcnR5XG4gKiByZXByZXNlbnRpbmcgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbS4gIFdoZW4gYG11bHRpYCBpcyB0cnVlLCBgc2VsZWN0ZWRgXG4gKiBpcyBhbiBhcnJheSBvZiBtdWx0aXBseSBzZWxlY3RlZCBpdGVtcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICpcbiAqICAgPHRlbXBsYXRlPlxuICpcbiAqICAgICA8ZGl2PiBFbXBsb3llZSBsaXN0OiA8L2Rpdj5cbiAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaWQ9XCJlbXBsb3llZUxpc3RcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIj5cbiAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgICAgIDxidXR0b24gb24tY2xpY2s9XCJ0b2dnbGVTZWxlY3Rpb25cIj5TZWxlY3Q8L2J1dHRvbj5cbiAqICAgICA8L3RlbXBsYXRlPlxuICpcbiAqICAgICA8YXJyYXktc2VsZWN0b3IgaWQ9XCJzZWxlY3RvclwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiIHNlbGVjdGVkPVwie3tzZWxlY3RlZH19XCIgbXVsdGkgdG9nZ2xlPjwvYXJyYXktc2VsZWN0b3I+XG4gKlxuICogICAgIDxkaXY+IFNlbGVjdGVkIGVtcGxveWVlczogPC9kaXY+XG4gKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGl0ZW1zPVwie3tzZWxlY3RlZH19XCI+XG4gKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICogICAgIDwvdGVtcGxhdGU+XG4gKlxuICogICA8L3RlbXBsYXRlPlxuICpcbiAqIDwvZG9tLW1vZHVsZT5cbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiBQb2x5bWVyKHtcbiAqICAgaXM6ICdlbXBsb3llZS1saXN0JyxcbiAqICAgcmVhZHkoKSB7XG4gKiAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gKiAgICAgICAgIHtmaXJzdDogJ0JvYicsIGxhc3Q6ICdTbWl0aCd9LFxuICogICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gKiAgICAgICAgIC4uLlxuICogICAgIF07XG4gKiAgIH0sXG4gKiAgIHRvZ2dsZVNlbGVjdGlvbihlKSB7XG4gKiAgICAgbGV0IGl0ZW0gPSB0aGlzLiQuZW1wbG95ZWVMaXN0Lml0ZW1Gb3JFbGVtZW50KGUudGFyZ2V0KTtcbiAqICAgICB0aGlzLiQuc2VsZWN0b3Iuc2VsZWN0KGl0ZW0pO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwb2x5bWVyXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGV4dGVuZHMge2Jhc2VBcnJheVNlbGVjdG9yfVxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkFycmF5U2VsZWN0b3JNaXhpblxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgbGlua3MgcGF0aHMgYmV0d2VlbiBhbiBpbnB1dCBgaXRlbXNgIGFycmF5IGFuZFxuICogICBhbiBvdXRwdXQgYHNlbGVjdGVkYCBpdGVtIG9yIGFycmF5IGJhc2VkIG9uIGNhbGxzIHRvIGl0cyBzZWxlY3Rpb24gQVBJLlxuICovXG5jbGFzcyBBcnJheVNlbGVjdG9yIGV4dGVuZHMgYmFzZUFycmF5U2VsZWN0b3Ige1xuICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnYXJyYXktc2VsZWN0b3InOyB9XG59XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoQXJyYXlTZWxlY3Rvci5pcywgQXJyYXlTZWxlY3Rvcik7XG5leHBvcnQgeyBBcnJheVNlbGVjdG9yIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzIiwiaW1wb3J0ICcuLi8uLi8uLi8uLi9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzJztcbmltcG9ydCB7IGNzc0Zyb21Nb2R1bGVzIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmpzJztcblxuY29uc3QgYXR0ciA9ICdpbmNsdWRlJztcblxuY29uc3QgQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG5cbi8qKlxuICogQ3VzdG9tIGVsZW1lbnQgZm9yIGRlZmluaW5nIHN0eWxlcyBpbiB0aGUgbWFpbiBkb2N1bWVudCB0aGF0IGNhbiB0YWtlXG4gKiBhZHZhbnRhZ2Ugb2YgW3NoYWR5IERPTV0oaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvc2hhZHljc3MpIHNoaW1zXG4gKiBmb3Igc3R5bGUgZW5jYXBzdWxhdGlvbiwgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBjdXN0b20gbWl4aW5zLlxuICpcbiAqIC0gRG9jdW1lbnQgc3R5bGVzIGRlZmluZWQgaW4gYSBgPGN1c3RvbS1zdHlsZT5gIGFyZSBzaGltbWVkIHRvIGVuc3VyZSB0aGV5XG4gKiAgIGRvIG5vdCBsZWFrIGludG8gbG9jYWwgRE9NIHdoZW4gcnVubmluZyBvbiBicm93c2VycyB3aXRob3V0IG5hdGl2ZVxuICogICBTaGFkb3cgRE9NLlxuICogLSBDdXN0b20gcHJvcGVydGllcyBjYW4gYmUgZGVmaW5lZCBpbiBhIGA8Y3VzdG9tLXN0eWxlPmAuIFVzZSB0aGUgYGh0bWxgIHNlbGVjdG9yXG4gKiAgIHRvIGRlZmluZSBjdXN0b20gcHJvcGVydGllcyB0aGF0IGFwcGx5IHRvIGFsbCBjdXN0b20gZWxlbWVudHMuXG4gKiAtIEN1c3RvbSBtaXhpbnMgY2FuIGJlIGRlZmluZWQgaW4gYSBgPGN1c3RvbS1zdHlsZT5gLCBpZiB5b3UgaW1wb3J0IHRoZSBvcHRpb25hbFxuICogICBbYXBwbHkgc2hpbV0oaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvc2hhZHljc3MjYWJvdXQtYXBwbHlzaGltKVxuICogICAoYHNoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbGApLlxuICpcbiAqIFRvIHVzZTpcbiAqXG4gKiAtIEltcG9ydCBgY3VzdG9tLXN0eWxlLmh0bWxgLlxuICogLSBQbGFjZSBhIGA8Y3VzdG9tLXN0eWxlPmAgZWxlbWVudCBpbiB0aGUgbWFpbiBkb2N1bWVudCwgd3JhcHBpbmcgYW4gaW5saW5lIGA8c3R5bGU+YCB0YWcgdGhhdFxuICogICBjb250YWlucyB0aGUgQ1NTIHJ1bGVzIHlvdSB3YW50IHRvIHNoaW0uXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiA8IS0tIGltcG9ydCBhcHBseSBzaGltLS1vbmx5IHJlcXVpcmVkIGlmIHVzaW5nIG1peGlucyAtLT5cbiAqIDxsaW5rIHJlbD1cImltcG9ydCBocmVmPVwiYm93ZXJfY29tcG9uZW50cy9zaGFkeWNzcy9hcHBseS1zaGltLmh0bWxcIj5cbiAqIDwhLS0gaW1wb3J0IGN1c3RvbS1zdHlsZSBlbGVtZW50IC0tPlxuICogPGxpbmsgcmVsPVwiaW1wb3J0XCIgaHJlZj1cImJvd2VyX2NvbXBvbmVudHMvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmh0bWxcIj5cbiAqIC4uLlxuICogPGN1c3RvbS1zdHlsZT5cbiAqICAgPHN0eWxlPlxuICogICAgIGh0bWwge1xuICogICAgICAgLS1jdXN0b20tY29sb3I6IGJsdWU7XG4gKiAgICAgICAtLWN1c3RvbS1taXhpbjoge1xuICogICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAqICAgICAgICAgY29sb3I6IHJlZDtcbiAqICAgICAgIH07XG4gKiAgICAgfVxuICogICA8L3N0eWxlPlxuICogPC9jdXN0b20tc3R5bGU+XG4gKiBgYGBcbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuXG4gKiAgIHRha2UgYWR2YW50YWdlIG9mIFBvbHltZXIncyBzdHlsZSBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydGllcyBzaGltcy5cbiAqL1xuY2xhc3MgQ3VzdG9tU3R5bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc3R5bGUgPSBudWxsO1xuICAgIEN1c3RvbVN0eWxlSW50ZXJmYWNlLmFkZEN1c3RvbVN0eWxlKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaWdodC1ET00gYDxzdHlsZT5gIGNoaWxkIHRoaXMgZWxlbWVudCB3cmFwcy4gIFVwb24gZmlyc3RcbiAgICogY2FsbCBhbnkgc3R5bGUgbW9kdWxlcyByZWZlcmVuY2VkIHZpYSB0aGUgYGluY2x1ZGVgIGF0dHJpYnV0ZSB3aWxsIGJlXG4gICAqIGNvbmNhdGVuYXRlZCB0byB0aGlzIGVsZW1lbnQncyBgPHN0eWxlPmAuXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9IFRoaXMgZWxlbWVudCdzIGxpZ2h0LURPTSBgPHN0eWxlPmBcbiAgICovXG4gIGdldFN0eWxlKCkge1xuICAgIGlmICh0aGlzLl9zdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8odGhpcy5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKTtcbiAgICBpZiAoIXN0eWxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fc3R5bGUgPSBzdHlsZTtcbiAgICBjb25zdCBpbmNsdWRlID0gc3R5bGUuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGNzc0Zyb21Nb2R1bGVzKGluY2x1ZGUpICsgc3R5bGUudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgfVxufVxuXG53aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdjdXN0b20tc3R5bGUnLCBDdXN0b21TdHlsZSk7XG5leHBvcnQgeyBDdXN0b21TdHlsZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBDdXN0b21TdHlsZUludGVyZmFjZSBmcm9tICcuLi9zcmMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyc7XG5pbXBvcnQge2dldENvbXB1dGVkU3R5bGVWYWx1ZSwgdXBkYXRlTmF0aXZlUHJvcGVydGllc30gZnJvbSAnLi4vc3JjL2NvbW1vbi11dGlscy5qcyc7XG5pbXBvcnQge25hdGl2ZUNzc1ZhcmlhYmxlcywgbmF0aXZlU2hhZG93fSBmcm9tICcuLi9zcmMvc3R5bGUtc2V0dGluZ3MuanMnO1xuXG5jb25zdCBjdXN0b21TdHlsZUludGVyZmFjZSA9IG5ldyBDdXN0b21TdHlsZUludGVyZmFjZSgpO1xuXG5pZiAoIXdpbmRvdy5TaGFkeUNTUykge1xuICB3aW5kb3cuU2hhZHlDU1MgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZWxlbWVudEV4dGVuZHNcbiAgICAgKi9cbiAgICBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lLCBlbGVtZW50RXh0ZW5kcykge30sIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0eWxlU3VidHJlZShlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgICBjdXN0b21TdHlsZUludGVyZmFjZS5wcm9jZXNzU3R5bGVzKCk7XG4gICAgICB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBzdHlsZUVsZW1lbnQoZWxlbWVudCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBjdXN0b21TdHlsZUludGVyZmFjZS5wcm9jZXNzU3R5bGVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0eWxlRG9jdW1lbnQocHJvcGVydGllcykge1xuICAgICAgY3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvY2Vzc1N0eWxlcygpO1xuICAgICAgdXBkYXRlTmF0aXZlUHJvcGVydGllcyhkb2N1bWVudC5ib2R5LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gICAgfSxcbiAgICBuYXRpdmVDc3M6IG5hdGl2ZUNzc1ZhcmlhYmxlcyxcbiAgICBuYXRpdmVTaGFkb3c6IG5hdGl2ZVNoYWRvd1xuICB9XG59XG5cbndpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSA9IGN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyIsImltcG9ydCB7IE11dGFibGVEYXRhIH0gZnJvbSAnLi4vbWl4aW5zL211dGFibGUtZGF0YS5qcyc7XG5cbmxldCBtdXRhYmxlUHJvcGVydHlDaGFuZ2U7XG4oXG4gIC8qKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSAqL1xuICAoZnVuY3Rpb24oKSB7XG4gIG11dGFibGVQcm9wZXJ0eUNoYW5nZSA9IE11dGFibGVEYXRhLl9tdXRhYmxlUHJvcGVydHlDaGFuZ2U7XG59KSkoKTtcblxuZXhwb3J0IGNvbnN0IE11dGFibGVEYXRhQmVoYXZpb3IgPSB7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgXG4gICAqIGNhY2hlIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBPcHRpb25hbE11dGFibGVEYXRhQmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgKiBjaGVja2luZywgb3RoZXJ3aXNlIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gc2tpcCBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmdcbiAgICogZm9yIE9iamVjdHMgYW5kIEFycmF5cy5cbiAgICpcbiAgICogUHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlXG4gICAqIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICogQHRoaXMge3RoaXN9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRoaXMubXV0YWJsZURhdGEpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuXG4gICAgICAtLWxheW91dDoge1xuICAgICAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaW5saW5lOiB7XG4gICAgICAgIGRpc3BsYXk6IC1tcy1pbmxpbmUtZmxleGJveDtcbiAgICAgICAgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtZmxleDtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1ob3Jpem9udGFsOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaG9yaXpvbnRhbC1yZXZlcnNlOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtdmVydGljYWw6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC12ZXJ0aWNhbC1yZXZlcnNlOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtd3JhcDoge1xuICAgICAgICAtbXMtZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAtd2Via2l0LWZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtd3JhcC1yZXZlcnNlOiB7XG4gICAgICAgIC1tcy1mbGV4LXdyYXA6IHdyYXAtcmV2ZXJzZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LXdyYXA6IHdyYXAtcmV2ZXJzZTtcbiAgICAgICAgZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LWF1dG86IHtcbiAgICAgICAgLW1zLWZsZXg6IDEgMSBhdXRvO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDEgMSBhdXRvO1xuICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtbm9uZToge1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiBub25lO1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleDoge1xuICAgICAgICAtbXMtZmxleDogMSAxIDAuMDAwMDAwMDAxcHg7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWJhc2lzOiAwLjAwMDAwMDAwMXB4O1xuICAgICAgICBmbGV4LWJhc2lzOiAwLjAwMDAwMDAwMXB4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0yOiB7XG4gICAgICAgIC1tcy1mbGV4OiAyO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDI7XG4gICAgICAgIGZsZXg6IDI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTM6IHtcbiAgICAgICAgLW1zLWZsZXg6IDM7XG4gICAgICAgIC13ZWJraXQtZmxleDogMztcbiAgICAgICAgZmxleDogMztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNDoge1xuICAgICAgICAtbXMtZmxleDogNDtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA0O1xuICAgICAgICBmbGV4OiA0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC01OiB7XG4gICAgICAgIC1tcy1mbGV4OiA1O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDU7XG4gICAgICAgIGZsZXg6IDU7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTY6IHtcbiAgICAgICAgLW1zLWZsZXg6IDY7XG4gICAgICAgIC13ZWJraXQtZmxleDogNjtcbiAgICAgICAgZmxleDogNjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNzoge1xuICAgICAgICAtbXMtZmxleDogNztcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA3O1xuICAgICAgICBmbGV4OiA3O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC04OiB7XG4gICAgICAgIC1tcy1mbGV4OiA4O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDg7XG4gICAgICAgIGZsZXg6IDg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTk6IHtcbiAgICAgICAgLW1zLWZsZXg6IDk7XG4gICAgICAgIC13ZWJraXQtZmxleDogOTtcbiAgICAgICAgZmxleDogOTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMTA6IHtcbiAgICAgICAgLW1zLWZsZXg6IDEwO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDEwO1xuICAgICAgICBmbGV4OiAxMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMTE6IHtcbiAgICAgICAgLW1zLWZsZXg6IDExO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDExO1xuICAgICAgICBmbGV4OiAxMTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMTI6IHtcbiAgICAgICAgLW1zLWZsZXg6IDEyO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDEyO1xuICAgICAgICBmbGV4OiAxMjtcbiAgICAgIH07XG5cbiAgICAgIC8qIGFsaWdubWVudCBpbiBjcm9zcyBheGlzICovXG5cbiAgICAgIC0tbGF5b3V0LXN0YXJ0OiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBzdGFydDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXI6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZW5kOiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBlbmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1iYXNlbGluZToge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogYmFzZWxpbmU7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xuICAgICAgICBhbGlnbi1pdGVtczogYmFzZWxpbmU7XG4gICAgICB9O1xuXG4gICAgICAvKiBhbGlnbm1lbnQgaW4gbWFpbiBheGlzICovXG5cbiAgICAgIC0tbGF5b3V0LXN0YXJ0LWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBzdGFydDtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWVuZC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogZW5kO1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1hcm91bmQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGRpc3RyaWJ1dGU7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGp1c3RpZnk7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXItY2VudGVyOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXI7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXItanVzdGlmaWVkO1xuICAgICAgfTtcblxuICAgICAgLyogc2VsZiBhbGlnbm1lbnQgKi9cblxuICAgICAgLS1sYXlvdXQtc2VsZi1zdGFydDoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1jZW50ZXI6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtZW5kOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgICAgICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLXN0cmV0Y2g6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtYmFzZWxpbmU6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGJhc2VsaW5lO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGJhc2VsaW5lO1xuICAgICAgICBhbGlnbi1zZWxmOiBiYXNlbGluZTtcbiAgICAgIH07XG5cbiAgICAgIC8qIG11bHRpLWxpbmUgYWxpZ25tZW50IGluIG1haW4gYXhpcyAqL1xuXG4gICAgICAtLWxheW91dC1zdGFydC1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogc3RhcnQ7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1lbmQtYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGVuZDsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlci1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogY2VudGVyOyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYmV0d2Vlbi1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazoganVzdGlmeTsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWFyb3VuZC1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogZGlzdHJpYnV0ZTsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgIH07XG5cbiAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAgICAgT3RoZXIgTGF5b3V0XG4gICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAtLWxheW91dC1ibG9jazoge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWludmlzaWJsZToge1xuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXJlbGF0aXZlOiB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpdDoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNjcm9sbDoge1xuICAgICAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XG4gICAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZnVsbGJsZWVkOiB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgIH07XG5cbiAgICAgIC8qIGZpeGVkIHBvc2l0aW9uICovXG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLXRvcDoge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXhlZC1yaWdodDoge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLWJvdHRvbToge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXhlZC1sZWZ0OiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9O1xuXG4gICAgfVxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0LmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuL2NvbG9yLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcbiAgICAgIC8qXG4gICAgICAgKiBZb3UgY2FuIHVzZSB0aGVzZSBnZW5lcmljIHZhcmlhYmxlcyBpbiB5b3VyIGVsZW1lbnRzIGZvciBlYXN5IHRoZW1pbmcuXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYWxsIHlvdXIgZWxlbWVudHMgdXNlIFxcYC0tcHJpbWFyeS10ZXh0LWNvbG9yXFxgIGFzIGl0cyBtYWluXG4gICAgICAgKiBjb2xvciwgdGhlbiBzd2l0Y2hpbmcgZnJvbSBhIGxpZ2h0IHRvIGEgZGFyayB0aGVtZSBpcyBqdXN0IGEgbWF0dGVyIG9mXG4gICAgICAgKiBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgXFxgLS1wcmltYXJ5LXRleHQtY29sb3JcXGAgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAqL1xuICAgICAgLS1wcmltYXJ5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXRleHQtY29sb3IpO1xuICAgICAgLS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWJhY2tncm91bmQtY29sb3IpO1xuICAgICAgLS1zZWNvbmRhcnktdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtc2Vjb25kYXJ5LWNvbG9yKTtcbiAgICAgIC0tZGlzYWJsZWQtdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtZGlzYWJsZWQtY29sb3IpO1xuICAgICAgLS1kaXZpZGVyLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1kaXZpZGVyLWNvbG9yKTtcbiAgICAgIC0tZXJyb3ItY29sb3I6IHZhcigtLXBhcGVyLWRlZXAtb3JhbmdlLWE3MDApO1xuXG4gICAgICAvKlxuICAgICAgICogUHJpbWFyeSBhbmQgYWNjZW50IGNvbG9ycy4gQWxzbyBzZWUgY29sb3IuaHRtbCBmb3IgbW9yZSBjb2xvcnMuXG4gICAgICAgKi9cbiAgICAgIC0tcHJpbWFyeS1jb2xvcjogdmFyKC0tcGFwZXItaW5kaWdvLTUwMCk7XG4gICAgICAtLWxpZ2h0LXByaW1hcnktY29sb3I6IHZhcigtLXBhcGVyLWluZGlnby0xMDApO1xuICAgICAgLS1kYXJrLXByaW1hcnktY29sb3I6IHZhcigtLXBhcGVyLWluZGlnby03MDApO1xuXG4gICAgICAtLWFjY2VudC1jb2xvcjogdmFyKC0tcGFwZXItcGluay1hMjAwKTtcbiAgICAgIC0tbGlnaHQtYWNjZW50LWNvbG9yOiB2YXIoLS1wYXBlci1waW5rLWExMDApO1xuICAgICAgLS1kYXJrLWFjY2VudC1jb2xvcjogdmFyKC0tcGFwZXItcGluay1hNDAwKTtcblxuXG4gICAgICAvKlxuICAgICAgICogTWF0ZXJpYWwgRGVzaWduIExpZ2h0IGJhY2tncm91bmQgdGhlbWVcbiAgICAgICAqL1xuICAgICAgLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xuICAgICAgLS1saWdodC10aGVtZS1iYXNlLWNvbG9yOiAjMDAwMDAwO1xuICAgICAgLS1saWdodC10aGVtZS10ZXh0LWNvbG9yOiB2YXIoLS1wYXBlci1ncmV5LTkwMCk7XG4gICAgICAtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcjogIzczNzM3MzsgIC8qIGZvciBzZWNvbmRhcnkgdGV4dCBhbmQgaWNvbnMgKi9cbiAgICAgIC0tbGlnaHQtdGhlbWUtZGlzYWJsZWQtY29sb3I6ICM5YjliOWI7ICAvKiBkaXNhYmxlZC9oaW50IHRleHQgKi9cbiAgICAgIC0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcjogI2RiZGJkYjtcblxuICAgICAgLypcbiAgICAgICAqIE1hdGVyaWFsIERlc2lnbiBEYXJrIGJhY2tncm91bmQgdGhlbWVcbiAgICAgICAqL1xuICAgICAgLS1kYXJrLXRoZW1lLWJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLWdyZXktOTAwKTtcbiAgICAgIC0tZGFyay10aGVtZS1iYXNlLWNvbG9yOiAjZmZmZmZmO1xuICAgICAgLS1kYXJrLXRoZW1lLXRleHQtY29sb3I6ICNmZmZmZmY7XG4gICAgICAtLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWNvbG9yOiAjYmNiY2JjOyAgLyogZm9yIHNlY29uZGFyeSB0ZXh0IGFuZCBpY29ucyAqL1xuICAgICAgLS1kYXJrLXRoZW1lLWRpc2FibGVkLWNvbG9yOiAjNjQ2NDY0OyAgLyogZGlzYWJsZWQvaGludCB0ZXh0ICovXG4gICAgICAtLWRhcmstdGhlbWUtZGl2aWRlci1jb2xvcjogIzNjM2MzYztcblxuICAgICAgLypcbiAgICAgICAqIERlcHJlY2F0ZWQgdmFsdWVzIGJlY2F1c2Ugb2YgdGhlaXIgY29uZnVzaW5nIG5hbWVzLlxuICAgICAgICovXG4gICAgICAtLXRleHQtcHJpbWFyeS1jb2xvcjogdmFyKC0tZGFyay10aGVtZS10ZXh0LWNvbG9yKTtcbiAgICAgIC0tZGVmYXVsdC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcbiAgICB9XG4gIDwvc3R5bGU+XG48L2N1c3RvbS1zdHlsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCwgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQYXBlcklua3lGb2N1c0JlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBhcGVyUmlwcGxlQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsID0ge1xuICAvKipcbiAgICogU3luY2hyb25pemVzIHRoZSBlbGVtZW50J3MgY2hlY2tlZCBzdGF0ZSB3aXRoIGl0cyByaXBwbGUgZWZmZWN0LlxuICAgKi9cbiAgX2NoZWNrZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwuX2NoZWNrZWRDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlLnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgZWxlbWVudCdzIGBhY3RpdmVgIGFuZCBgY2hlY2tlZGAgc3RhdGUuXG4gICAqL1xuICBfYnV0dG9uU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBQYXBlclJpcHBsZUJlaGF2aW9yLl9idXR0b25TdGF0ZUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLmFjdGl2ZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IgPSBbXG4gIFBhcGVySW5reUZvY3VzQmVoYXZpb3IsXG4gIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yLFxuICBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWNoYW5nZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzdGF0ZSwgYHRydWVgIGlzIGNoZWNrZWQgYW5kIGBmYWxzZWAgaXMgdW5jaGVja2VkLlxuICAgICAqL1xuICAgIGNoZWNrZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICBvYnNlcnZlcjogJ19jaGVja2VkQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiB0b2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgd2l0aCBlYWNoIHRhcCBvciBwcmVzc1xuICAgICAqIG9mIHRoZSBzcGFjZWJhci5cbiAgICAgKi9cbiAgICB0b2dnbGVzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyogT3ZlcnJpZGVuIGZyb20gUG9seW1lci5Jcm9uRm9ybUVsZW1lbnRCZWhhdmlvciAqL1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ29uJyxcbiAgICAgIG9ic2VydmVyOiAnX3ZhbHVlQ2hhbmdlZCdcbiAgICB9XG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19yZXF1aXJlZENoYW5nZWQocmVxdWlyZWQpJ1xuICBdLFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVzZWQgYnkgYGlyb24tZm9ybWAgdG8gaGFuZGxlIHRoZSBjYXNlIHRoYXQgYW4gZWxlbWVudCB3aXRoIHRoaXMgYmVoYXZpb3JcbiAgICAvLyBkb2Vzbid0IGhhdmUgYSByb2xlIG9mICdjaGVja2JveCcgb3IgJ3JhZGlvJywgYnV0IHNob3VsZCBzdGlsbCBvbmx5IGJlXG4gICAgLy8gaW5jbHVkZWQgd2hlbiB0aGUgZm9ybSBpcyBzZXJpYWxpemVkIGlmIGB0aGlzLmNoZWNrZWQgPT09IHRydWVgLlxuICAgIHRoaXMuX2hhc0lyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgZWxlbWVudCBpcyByZXF1aXJlZCBhbmQgbm90IGNoZWNrZWQsIGFuZCB0cnVlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHsqPX0gX3ZhbHVlIElnbm9yZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYHJlcXVpcmVkYCBpcyBmYWxzZSBvciBpZiBgY2hlY2tlZGAgaXMgdHJ1ZS5cbiAgICovXG4gIF9nZXRWYWxpZGl0eTogZnVuY3Rpb24oX3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMucmVxdWlyZWQgfHwgdGhpcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGFyaWEtcmVxdWlyZWQgbGFiZWwgd2hlbiBgcmVxdWlyZWRgIGlzIGNoYW5nZWQuXG4gICAqL1xuICBfcmVxdWlyZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXF1aXJlZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVxdWlyZWQnLCAndHJ1ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1yZXF1aXJlZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmlyZSBgaXJvbi1jaGFuZ2VkYCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAqL1xuICBfY2hlY2tlZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWN0aXZlID0gdGhpcy5jaGVja2VkO1xuICAgIHRoaXMuZmlyZSgnaXJvbi1jaGFuZ2UnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXQgdmFsdWUgdG8gJ29uJyBpZiBpdCBpcyBzZXQgdG8gYHVuZGVmaW5lZGAuXG4gICAqL1xuICBfdmFsdWVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnb24nO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yID0gW1xuICBJcm9uRm9ybUVsZW1lbnRCZWhhdmlvcixcbiAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IsXG4gIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uTWV0YSB9IGZyb20gJy4uL2lyb24tbWV0YS9pcm9uLW1ldGEuanMnO1xuZXhwb3J0IGxldCBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEgPSBudWxsO1xuXG5leHBvcnQgY29uc3QgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIHZhbGlkYXRvciB0byB1c2UuXG4gICAgICovXG4gICAgdmFsaWRhdG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgbGFzdCBjYWxsIHRvIGB2YWxpZGF0ZWAgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBpbnZhbGlkOiB7XG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgb2JzZXJ2ZXI6ICdfaW52YWxpZENoYW5nZWQnXG4gICAgfSxcbiAgfSxcblxuICByZWdpc3RlcmVkOiBmdW5jdGlvbigpIHtcbiAgICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEgPSBuZXcgSXJvbk1ldGEoe3R5cGU6ICd2YWxpZGF0b3InfSk7XG4gIH0sXG5cbiAgX2ludmFsaWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKiBSZWNvbXB1dGUgdGhpcyBldmVyeSB0aW1lIGl0J3MgbmVlZGVkLCBiZWNhdXNlIHdlIGRvbid0IGtub3cgaWYgdGhlXG4gICAqIHVuZGVybHlpbmcgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhIGhhcyBjaGFuZ2VkLiAqL1xuICBnZXQgX3ZhbGlkYXRvcigpIHtcbiAgICByZXR1cm4gSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhICYmXG4gICAgICAgIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YS5ieUtleSh0aGlzLnZhbGlkYXRvcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbGlkYXRvciBgdmFsaWRhdG9yYCBleGlzdHMuXG4gICAqL1xuICBoYXNWYWxpZGF0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IgIT0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBgdmFsdWVgIGlzIHZhbGlkLCBhbmQgdXBkYXRlcyBgaW52YWxpZGAuIElmIHlvdSB3YW50XG4gICAqIHlvdXIgZWxlbWVudCB0byBoYXZlIGN1c3RvbSB2YWxpZGF0aW9uIGxvZ2ljLCBkbyBub3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2Q7XG4gICAqIG92ZXJyaWRlIGBfZ2V0VmFsaWRpdHkodmFsdWUpYCBpbnN0ZWFkLlxuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBEZXByZWNhdGVkOiBUaGUgdmFsdWUgdG8gYmUgdmFsaWRhdGVkLiBCeSBkZWZhdWx0LFxuICAgKiBpdCBpcyBwYXNzZWQgdG8gdGhlIHZhbGlkYXRvcidzIGB2YWxpZGF0ZSgpYCBmdW5jdGlvbiwgaWYgYSB2YWxpZGF0b3IgaXMgc2V0LlxuICAgKiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlIGVsZW1lbnQncyBgdmFsdWVgIHByb3BlcnR5XG4gICAqIGlzIHVzZWQsIGlmIGl0IGV4aXN0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBlbGVtZW50IHRoYXQgYWxzbyBoYXMgYSB2YWx1ZSBwcm9wZXJ0eSwgYW5kIHRoZXJlIHdhc1xuICAgIC8vIG5vIGV4cGxpY2l0IHZhbHVlIGFyZ3VtZW50IHBhc3NlZCwgdXNlIHRoZSBlbGVtZW50J3MgcHJvcGVydHkgaW5zdGVhZC5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICB0aGlzLmludmFsaWQgPSAhdGhpcy5fZ2V0VmFsaWRpdHkodGhpcy52YWx1ZSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5pbnZhbGlkID0gIXRoaXMuX2dldFZhbGlkaXR5KHZhbHVlKTtcbiAgICByZXR1cm4gIXRoaXMuaW52YWxpZDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuICBCeSBkZWZhdWx0LCBpdCBpcyBwYXNzZWRcbiAgICogdG8gdGhlIHZhbGlkYXRvcidzIGB2YWxpZGF0ZSgpYCBmdW5jdGlvbiwgaWYgYSB2YWxpZGF0b3IgaXMgc2V0LiBZb3VcbiAgICogc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRvIGltcGxlbWVudCBjdXN0b20gdmFsaWRpdHlcbiAgICogbG9naWMgZm9yIHlvdXIgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC5cbiAgICovXG5cbiAgX2dldFZhbGlkaXR5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmhhc1ZhbGlkYXRvcigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IFBvbHltZXIgYXMgUG9seW1lciQwIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHt7dHlwZTogKHN0cmluZ3xudWxsKSwga2V5OiAoc3RyaW5nfG51bGwpLCB2YWx1ZTogKn19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gSXJvbk1ldGEob3B0aW9ucykge1xuICB0aGlzLnR5cGUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUpIHx8ICdkZWZhdWx0JztcbiAgdGhpcy5rZXkgPSBvcHRpb25zICYmIG9wdGlvbnMua2V5O1xuICBpZiAoJ3ZhbHVlJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIH1cbn1cblxuSXJvbk1ldGEudHlwZXMgPSB7fTtcblxuSXJvbk1ldGEucHJvdG90eXBlID0ge1xuICBnZXQgdmFsdWUoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5O1xuXG4gICAgaWYgKHR5cGUgJiYga2V5KSB7XG4gICAgICByZXR1cm4gSXJvbk1ldGEudHlwZXNbdHlwZV0gJiYgSXJvbk1ldGEudHlwZXNbdHlwZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdmFyIGtleSA9IHRoaXMua2V5O1xuXG4gICAgaWYgKHR5cGUgJiYga2V5KSB7XG4gICAgICB0eXBlID0gSXJvbk1ldGEudHlwZXNbdHlwZV0gPSBJcm9uTWV0YS50eXBlc1t0eXBlXSB8fCB7fTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSB0eXBlW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0IGxpc3QoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKElyb25NZXRhLnR5cGVzW3RoaXMudHlwZV0pLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFEYXRhc1t0aGlzLnR5cGVdW2tleV07XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgYnlLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59O1xuXG5leHBvcnQgeyBJcm9uTWV0YSB9O1xuXG52YXIgbWV0YURhdGFzID0gSXJvbk1ldGEudHlwZXM7XG5cblBvbHltZXIkMCh7XG5cbiAgaXM6ICdpcm9uLW1ldGEnLFxuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIG1ldGEtZGF0YS4gIEFsbCBtZXRhLWRhdGEgb2YgdGhlIHNhbWUgdHlwZSBpcyBzdG9yZWRcbiAgICAgKiB0b2dldGhlci5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnZGVmYXVsdCcsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgdXNlZCB0byBzdG9yZSBgdmFsdWVgIHVuZGVyIHRoZSBgdHlwZWAgbmFtZXNwYWNlLlxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIGtleToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0YS1kYXRhIHRvIHN0b3JlIG9yIHJldHJpZXZlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGB2YWx1ZWAgaXMgc2V0IHRvIHRoZSBpcm9uLW1ldGEgaW5zdGFuY2UgaXRzZWxmLlxuICAgICAqL1xuICAgICBzZWxmOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgb2JzZXJ2ZXI6ICdfc2VsZkNoYW5nZWQnXG4gICAgfSxcblxuICAgIF9fbWV0YToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlTWV0YSh0eXBlLCBrZXksIHZhbHVlKSdcbiAgICB9XG4gIH0sXG5cbiAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICBoaWRkZW46IHRydWVcbiAgfSxcblxuICBfX2NvbXB1dGVNZXRhOiBmdW5jdGlvbih0eXBlLCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIG1ldGEgPSBuZXcgSXJvbk1ldGEoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5XG4gICAgfSk7XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbWV0YS52YWx1ZSkge1xuICAgICAgbWV0YS52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSAhPT0gbWV0YS52YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IG1ldGEudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH0sXG5cbiAgZ2V0IGxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19tZXRhICYmIHRoaXMuX19tZXRhLmxpc3Q7XG4gIH0sXG5cbiAgX3NlbGZDaGFuZ2VkOiBmdW5jdGlvbihzZWxmKSB7XG4gICAgaWYgKHNlbGYpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0cmlldmVzIG1ldGEgZGF0YSB2YWx1ZSBieSBrZXkuXG4gICAqXG4gICAqIEBtZXRob2QgYnlLZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRhLWRhdGEgdG8gYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBieUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBJcm9uTWV0YSh7XG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBrZXk6IGtleVxuICAgIH0pLnZhbHVlO1xuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1tZXRhL2lyb24tbWV0YS5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uRm9ybUVsZW1lbnRCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byBhbiBgaXJvbi1mb3JtYC5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWZvcm0tZWxlbWVudC1yZWdpc3RlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gYW4gYGlyb24tZm9ybWAuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1mb3JtLWVsZW1lbnQtdW5yZWdpc3RlclxuICAgICAqL1xuICAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIHZhbHVlOiB7XG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gbWFyayB0aGUgaW5wdXQgYXMgcmVxdWlyZWQuIElmIHVzZWQgaW4gYSBmb3JtLCBhXG4gICAgICogY3VzdG9tIGVsZW1lbnQgdGhhdCB1c2VzIHRoaXMgYmVoYXZpb3Igc2hvdWxkIGFsc28gdXNlXG4gICAgICogUG9seW1lci5Jcm9uVmFsaWRhdGFibGVCZWhhdmlvciBhbmQgZGVmaW5lIGEgY3VzdG9tIHZhbGlkYXRpb24gbWV0aG9kLlxuICAgICAqIE90aGVyd2lzZSwgYSBgcmVxdWlyZWRgIGVsZW1lbnQgd2lsbCBhbHdheXMgYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAgICAgKiBJdCdzIGFsc28gc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gcHJvdmlkZSBhIHZpc3VhbCBzdHlsZSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKiB3aGVuIGl0cyB2YWx1ZSBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHJlcXVpcmVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtIHRoYXQgdGhlIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZCB0by5cbiAgICAgKi9cbiAgICBfcGFyZW50Rm9ybToge1xuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfVxuICB9LFxuXG4gIGF0dGFjaGVkOiBFbGVtZW50ID8gbnVsbCA6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5vdGU6IHRoZSBpcm9uLWZvcm0gdGhhdCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byB3aWxsIHNldCB0aGlzXG4gICAgLy8gZWxlbWVudCdzIF9wYXJlbnRGb3JtIHByb3BlcnR5IHdoZW4gaGFuZGxpbmcgdGhpcyBldmVudC5cbiAgICB0aGlzLmZpcmUoJ2lyb24tZm9ybS1lbGVtZW50LXJlZ2lzdGVyJyk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IEVsZW1lbnQgPyBudWxsIDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudEZvcm0pIHtcbiAgICAgIHRoaXMuX3BhcmVudEZvcm0uZmlyZSgnaXJvbi1mb3JtLWVsZW1lbnQtdW5yZWdpc3RlcicsIHt0YXJnZXQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQnV0dG9uU3RhdGUgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyc7XG5pbXBvcnQgeyBQYXBlclJpcHBsZUJlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgSXJvbkNvbnRyb2xTdGF0ZSB9IGZyb20gJy4uL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbCA9IHtcbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19mb2N1c2VkQ2hhbmdlZChyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSdcbiAgXSxcblxuICBfZm9jdXNlZENoYW5nZWQ6IGZ1bmN0aW9uKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICBpZiAocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIHRoaXMuX3JpcHBsZS5ob2xkRG93biA9IHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQ7XG4gICAgfVxuICB9LFxuXG4gIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByaXBwbGUgPSBQYXBlclJpcHBsZUJlaGF2aW9yLl9jcmVhdGVSaXBwbGUoKTtcbiAgICByaXBwbGUuaWQgPSAnaW5rJztcbiAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdjZW50ZXInLCAnJyk7XG4gICAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ2NpcmNsZScpO1xuICAgIHJldHVybiByaXBwbGU7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBQYXBlcklua3lGb2N1c0JlaGF2aW9yID0gW1xuICBJcm9uQnV0dG9uU3RhdGUsXG4gIElyb25Db250cm9sU3RhdGUsXG4gIFBhcGVyUmlwcGxlQmVoYXZpb3IsXG4gIFBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25BMTF5S2V5c0JlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5cbnZhciBVdGlsaXR5ID0ge1xuICBkaXN0YW5jZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgeERlbHRhID0gKHgxIC0geDIpO1xuICAgIHZhciB5RGVsdGEgPSAoeTEgLSB5Mik7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHhEZWx0YSAqIHhEZWx0YSArIHlEZWx0YSAqIHlEZWx0YSk7XG4gIH0sXG5cbiAgbm93OiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA/XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93LmJpbmQod2luZG93LnBlcmZvcm1hbmNlKSA6IERhdGUubm93XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFbGVtZW50TWV0cmljcyhlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMud2lkdGggPSB0aGlzLmJvdW5kaW5nUmVjdC53aWR0aDtcbiAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdW5kaW5nUmVjdC5oZWlnaHQ7XG5cbiAgdGhpcy5zaXplID0gTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufVxuXG5FbGVtZW50TWV0cmljcy5wcm90b3R5cGUgPSB7XG4gIGdldCBib3VuZGluZ1JlY3QgKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0sXG5cbiAgZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb206IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdG9wTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgMCk7XG4gICAgdmFyIHRvcFJpZ2h0ID0gVXRpbGl0eS5kaXN0YW5jZSh4LCB5LCB0aGlzLndpZHRoLCAwKTtcbiAgICB2YXIgYm90dG9tTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgdGhpcy5oZWlnaHQpO1xuICAgIHZhciBib3R0b21SaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJpcHBsZShlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuY29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5jb2xvcjtcblxuICB0aGlzLndhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy53YXZlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMud2F2ZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbG9yO1xuICB0aGlzLndhdmUuY2xhc3NMaXN0LmFkZCgnd2F2ZScpO1xuICB0aGlzLndhdmVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnd2F2ZS1jb250YWluZXInKTtcbiAgZG9tKHRoaXMud2F2ZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy53YXZlKTtcblxuICB0aGlzLnJlc2V0SW50ZXJhY3Rpb25TdGF0ZSgpO1xufVxuXG5SaXBwbGUuTUFYX1JBRElVUyA9IDMwMDtcblxuUmlwcGxlLnByb3RvdHlwZSA9IHtcbiAgZ2V0IHJlY2VudGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnJlY2VudGVycztcbiAgfSxcblxuICBnZXQgY2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2VudGVyO1xuICB9LFxuXG4gIGdldCBtb3VzZURvd25FbGFwc2VkKCkge1xuICAgIHZhciBlbGFwc2VkO1xuXG4gICAgaWYgKCF0aGlzLm1vdXNlRG93blN0YXJ0KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBlbGFwc2VkID0gVXRpbGl0eS5ub3coKSAtIHRoaXMubW91c2VEb3duU3RhcnQ7XG5cbiAgICBpZiAodGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgIGVsYXBzZWQgLT0gdGhpcy5tb3VzZVVwRWxhcHNlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxhcHNlZDtcbiAgfSxcblxuICBnZXQgbW91c2VVcEVsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgIFV0aWxpdHkubm93ICgpIC0gdGhpcy5tb3VzZVVwU3RhcnQgOiAwO1xuICB9LFxuXG4gIGdldCBtb3VzZURvd25FbGFwc2VkU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZURvd25FbGFwc2VkIC8gMTAwMDtcbiAgfSxcblxuICBnZXQgbW91c2VVcEVsYXBzZWRTZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlVXBFbGFwc2VkIC8gMTAwMDtcbiAgfSxcblxuICBnZXQgbW91c2VJbnRlcmFjdGlvblNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZFNlY29uZHMgKyB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcztcbiAgfSxcblxuICBnZXQgaW5pdGlhbE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5pbml0aWFsT3BhY2l0eTtcbiAgfSxcblxuICBnZXQgb3BhY2l0eURlY2F5VmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vcGFjaXR5RGVjYXlWZWxvY2l0eTtcbiAgfSxcblxuICBnZXQgcmFkaXVzKCkge1xuICAgIHZhciB3aWR0aDIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggKiB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGg7XG4gICAgdmFyIGhlaWdodDIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0ICogdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodDtcbiAgICB2YXIgd2F2ZVJhZGl1cyA9IE1hdGgubWluKFxuICAgICAgTWF0aC5zcXJ0KHdpZHRoMiArIGhlaWdodDIpLFxuICAgICAgUmlwcGxlLk1BWF9SQURJVVNcbiAgICApICogMS4xICsgNTtcblxuICAgIHZhciBkdXJhdGlvbiA9IDEuMSAtIDAuMiAqICh3YXZlUmFkaXVzIC8gUmlwcGxlLk1BWF9SQURJVVMpO1xuICAgIHZhciB0aW1lTm93ID0gdGhpcy5tb3VzZUludGVyYWN0aW9uU2Vjb25kcyAvIGR1cmF0aW9uO1xuICAgIHZhciBzaXplID0gd2F2ZVJhZGl1cyAqICgxIC0gTWF0aC5wb3coODAsIC10aW1lTm93KSk7XG5cbiAgICByZXR1cm4gTWF0aC5hYnMoc2l6ZSk7XG4gIH0sXG5cbiAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgaWYgKCF0aGlzLm1vdXNlVXBTdGFydCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbE9wYWNpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIHRoaXMuaW5pdGlhbE9wYWNpdHkgLSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIHRoaXMub3BhY2l0eURlY2F5VmVsb2NpdHlcbiAgICApO1xuICB9LFxuXG4gIGdldCBvdXRlck9wYWNpdHkoKSB7XG4gICAgLy8gTGluZWFyIGluY3JlYXNlIGluIGJhY2tncm91bmQgb3BhY2l0eSwgY2FwcGVkIGF0IHRoZSBvcGFjaXR5XG4gICAgLy8gb2YgdGhlIHdhdmVmcm9udCAod2F2ZU9wYWNpdHkpLlxuICAgIHZhciBvdXRlck9wYWNpdHkgPSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIDAuMztcbiAgICB2YXIgd2F2ZU9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgTWF0aC5taW4ob3V0ZXJPcGFjaXR5LCB3YXZlT3BhY2l0eSlcbiAgICApO1xuICB9LFxuXG4gIGdldCBpc09wYWNpdHlGdWxseURlY2F5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eSA8IDAuMDEgJiZcbiAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gIH0sXG5cbiAgZ2V0IGlzUmVzdGluZ0F0TWF4UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPj0gdGhpcy5pbml0aWFsT3BhY2l0eSAmJlxuICAgICAgdGhpcy5yYWRpdXMgPj0gTWF0aC5taW4odGhpcy5tYXhSYWRpdXMsIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgfSxcblxuICBnZXQgaXNBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZVVwU3RhcnQgP1xuICAgICAgdGhpcy5pc09wYWNpdHlGdWxseURlY2F5ZWQgOiB0aGlzLmlzUmVzdGluZ0F0TWF4UmFkaXVzO1xuICB9LFxuXG4gIGdldCB0cmFuc2xhdGlvbkZyYWN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIDEsXG4gICAgICB0aGlzLnJhZGl1cyAvIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICogMiAvIE1hdGguc3FydCgyKVxuICAgICk7XG4gIH0sXG5cbiAgZ2V0IHhOb3coKSB7XG4gICAgaWYgKHRoaXMueEVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMueFN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueEVuZCAtIHRoaXMueFN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy54U3RhcnQ7XG4gIH0sXG5cbiAgZ2V0IHlOb3coKSB7XG4gICAgaWYgKHRoaXMueUVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMueVN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueUVuZCAtIHRoaXMueVN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy55U3RhcnQ7XG4gIH0sXG5cbiAgZ2V0IGlzTW91c2VEb3duKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlRG93blN0YXJ0ICYmICF0aGlzLm1vdXNlVXBTdGFydDtcbiAgfSxcblxuICByZXNldEludGVyYWN0aW9uU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWF4UmFkaXVzID0gMDtcbiAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gMDtcbiAgICB0aGlzLm1vdXNlVXBTdGFydCA9IDA7XG5cbiAgICB0aGlzLnhTdGFydCA9IDA7XG4gICAgdGhpcy55U3RhcnQgPSAwO1xuICAgIHRoaXMueEVuZCA9IDA7XG4gICAgdGhpcy55RW5kID0gMDtcbiAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSAwO1xuXG4gICAgdGhpcy5jb250YWluZXJNZXRyaWNzID0gbmV3IEVsZW1lbnRNZXRyaWNzKHRoaXMuZWxlbWVudCk7XG4gIH0sXG5cbiAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlO1xuICAgIHZhciB0cmFuc2xhdGVTdHJpbmc7XG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIHRoaXMud2F2ZS5zdHlsZS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgc2NhbGUgPSB0aGlzLnJhZGl1cyAvICh0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAvIDIpO1xuICAgIGR4ID0gdGhpcy54Tm93IC0gKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDIpO1xuICAgIGR5ID0gdGhpcy55Tm93IC0gKHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLyAyKTtcblxuXG4gICAgLy8gMmQgdHJhbnNmb3JtIGZvciBzYWZhcmkgYmVjYXVzZSBvZiBib3JkZXItcmFkaXVzIGFuZCBvdmVyZmxvdzpoaWRkZW4gY2xpcHBpbmcgYnVnLlxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD05ODUzOFxuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBkeCArICdweCwgJyArIGR5ICsgJ3B4KSc7XG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgZHggKyAncHgsICcgKyBkeSArICdweCwgMCknO1xuICAgIHRoaXMud2F2ZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnKSc7XG4gICAgdGhpcy53YXZlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZTNkKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJywxKSc7XG4gIH0sXG5cbiAgLyoqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCAqL1xuICBkb3duQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB4Q2VudGVyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC8gMjtcbiAgICB2YXIgeUNlbnRlciA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLyAyO1xuXG4gICAgdGhpcy5yZXNldEludGVyYWN0aW9uU3RhdGUoKTtcbiAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcblxuICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgdGhpcy54U3RhcnQgPSB4Q2VudGVyO1xuICAgICAgdGhpcy55U3RhcnQgPSB5Q2VudGVyO1xuICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgdGhpcy54U3RhcnQsIHRoaXMueVN0YXJ0LCB0aGlzLnhFbmQsIHRoaXMueUVuZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54U3RhcnQgPSBldmVudCA/XG4gICAgICAgICAgZXZlbnQuZGV0YWlsLnggLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LmxlZnQgOlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnlTdGFydCA9IGV2ZW50ID9cbiAgICAgICAgICBldmVudC5kZXRhaWwueSAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QudG9wIDpcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWNlbnRlcnMpIHtcbiAgICAgIHRoaXMueEVuZCA9IHhDZW50ZXI7XG4gICAgICB0aGlzLnlFbmQgPSB5Q2VudGVyO1xuICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgdGhpcy54U3RhcnQsIHRoaXMueVN0YXJ0LCB0aGlzLnhFbmQsIHRoaXMueUVuZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLm1heFJhZGl1cyA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5mdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbShcbiAgICAgIHRoaXMueFN0YXJ0LFxuICAgICAgdGhpcy55U3RhcnRcbiAgICApO1xuXG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLnRvcCA9XG4gICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS5sZWZ0ID1cbiAgICAgICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSkgLyAyICsgJ3B4JztcblxuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKyAncHgnO1xuICB9LFxuXG4gIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzTW91c2VEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZVVwU3RhcnQgPSBVdGlsaXR5Lm5vdygpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgZG9tKHRoaXMud2F2ZUNvbnRhaW5lci5wYXJlbnROb2RlKS5yZW1vdmVDaGlsZChcbiAgICAgIHRoaXMud2F2ZUNvbnRhaW5lclxuICAgICk7XG4gIH1cbn07XG5cblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcblxuICAgICAgICAvKiBTZWUgUG9seW1lckVsZW1lbnRzL3BhcGVyLWJlaGF2aW9ycy9pc3N1ZXMvMzQuIE9uIG5vbi1DaHJvbWUgYnJvd3NlcnMsXG4gICAgICAgICAqIGNyZWF0aW5nIGEgbm9kZSAod2l0aCBhIHBvc2l0aW9uOmFic29sdXRlKSBpbiB0aGUgbWlkZGxlIG9mIGFuIGV2ZW50XG4gICAgICAgICAqIGhhbmRsZXIgXCJpbnRlcnJ1cHRzXCIgdGhhdCBldmVudCBoYW5kbGVyICh3aGljaCBoYXBwZW5zIHdoZW4gdGhlXG4gICAgICAgICAqIHJpcHBsZSBpcyBjcmVhdGVkIG9uIGRlbWFuZCkgKi9cbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFthbmltYXRpbmddKSB7XG4gICAgICAgIC8qIFRoaXMgcmVzb2x2ZXMgYSByZW5kZXJpbmcgaXNzdWUgaW4gQ2hyb21lIChhcyBvZiA0MCkgd2hlcmUgdGhlXG4gICAgICAgICAgIHJpcHBsZSBpcyBub3QgcHJvcGVybHkgY2xpcHBlZCBieSBpdHMgcGFyZW50ICh3aGljaCBtYXkgaGF2ZVxuICAgICAgICAgICByb3VuZGVkIGNvcm5lcnMpLiBTZWU6IGh0dHA6Ly9qc2Jpbi5jb20vdGVtZXhhLzRcblxuICAgICAgICAgICBOb3RlOiBXZSBvbmx5IGFwcGx5IHRoaXMgc3R5bGUgY29uZGl0aW9uYWxseS4gT3RoZXJ3aXNlLCB0aGUgYnJvd3NlclxuICAgICAgICAgICB3aWxsIGNyZWF0ZSBhIG5ldyBjb21wb3NpdGluZyBsYXllciBmb3IgZXZlcnkgcmlwcGxlIGVsZW1lbnQgb24gdGhlXG4gICAgICAgICAgIHBhZ2UsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZC4gKi9cbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZS1jb250YWluZXIsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB9XG5cbiAgICAgICN3YXZlcyxcbiAgICAgIC53YXZlIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5jaXJjbGUpICNiYWNrZ3JvdW5kLFxuICAgICAgOmhvc3QoLmNpcmNsZSkgI3dhdmVzIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAud2F2ZS1jb250YWluZXIge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwiYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgaWQ9XCJ3YXZlc1wiPjwvZGl2PlxuYCxcblxuICBpczogJ3BhcGVyLXJpcHBsZScsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgSXJvbkExMXlLZXlzQmVoYXZpb3JcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgb3BhY2l0eSBzZXQgb24gdGhlIHdhdmUuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIGluaXRpYWxPcGFjaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4yNVxuICAgICAqL1xuICAgIGluaXRpYWxPcGFjaXR5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWx1ZTogMC4yNVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIb3cgZmFzdCAob3BhY2l0eSBwZXIgc2Vjb25kKSB0aGUgd2F2ZSBmYWRlcyBvdXQuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIG9wYWNpdHlEZWNheVZlbG9jaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC44XG4gICAgICovXG4gICAgb3BhY2l0eURlY2F5VmVsb2NpdHk6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHZhbHVlOiAwLjhcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGV4aGliaXQgYSBncmF2aXRhdGlvbmFsIHB1bGwgdG93YXJkc1xuICAgICAqIHRoZSBjZW50ZXIgb2YgdGhlaXIgY29udGFpbmVyIGFzIHRoZXkgZmFkZSBhd2F5LlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICByZWNlbnRlcnM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGNlbnRlciBpbnNpZGUgaXRzIGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBjZW50ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHRoZSB2aXN1YWwgcmlwcGxlcy5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmlwcGxlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cbiAgICByaXBwbGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gdGhlcmUgYXJlIHZpc2libGUgcmlwcGxlcyBhbmltYXRpbmcgd2l0aGluIHRoZVxuICAgICAqIGVsZW1lbnQuXG4gICAgICovXG4gICAgYW5pbWF0aW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHJpcHBsZSB3aWxsIHJlbWFpbiBpbiB0aGUgXCJkb3duXCIgc3RhdGUgdW50aWwgYGhvbGREb3duYFxuICAgICAqIGlzIHNldCB0byBmYWxzZSBhZ2Fpbi5cbiAgICAgKi9cbiAgICBob2xkRG93bjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX2hvbGREb3duQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHJpcHBsZSB3aWxsIG5vdCBnZW5lcmF0ZSBhIHJpcHBsZSBlZmZlY3RcbiAgICAgKiB2aWEgcG9pbnRlciBpbnRlcmFjdGlvbi5cbiAgICAgKiBDYWxsaW5nIHJpcHBsZSdzIGltcGVyYXRpdmUgYXBpIGxpa2UgYHNpbXVsYXRlZFJpcHBsZWAgd2lsbFxuICAgICAqIHN0aWxsIGdlbmVyYXRlIHRoZSByaXBwbGUgZWZmZWN0LlxuICAgICAqL1xuICAgIG5vaW5rOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIF9hbmltYXRpbmc6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgX2JvdW5kQW5pbWF0ZToge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0IHRhcmdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5RXZlbnRUYXJnZXQ7XG4gIH0sXG5cbiAga2V5QmluZGluZ3M6IHtcbiAgICAnZW50ZXI6a2V5ZG93bic6ICdfb25FbnRlcktleWRvd24nLFxuICAgICdzcGFjZTprZXlkb3duJzogJ19vblNwYWNlS2V5ZG93bicsXG4gICAgJ3NwYWNlOmtleXVwJzogJ19vblNwYWNlS2V5dXAnXG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNldCB1cCBhMTF5S2V5c0JlaGF2aW9yIHRvIGxpc3RlbiB0byBrZXkgZXZlbnRzIG9uIHRoZSB0YXJnZXQsXG4gICAgLy8gc28gdGhhdCBzcGFjZSBhbmQgZW50ZXIgYWN0aXZhdGUgdGhlIHJpcHBsZSBldmVuIGlmIHRoZSB0YXJnZXQgZG9lc24ndFxuICAgIC8vIGhhbmRsZSBrZXkgZXZlbnRzLiBUaGUga2V5IGhhbmRsZXJzIGRlYWwgd2l0aCBgbm9pbmtgIHRoZW1zZWx2ZXMuXG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG4gICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gZG9tKHRoaXMpLmdldE93bmVyUm9vdCgpLmhvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHZhciBrZXlFdmVudFRhcmdldCA9IC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAodGhpcy5rZXlFdmVudFRhcmdldCk7XG4gICAgdGhpcy5saXN0ZW4oa2V5RXZlbnRUYXJnZXQsICd1cCcsICd1aVVwQWN0aW9uJyk7XG4gICAgdGhpcy5saXN0ZW4oa2V5RXZlbnRUYXJnZXQsICdkb3duJywgJ3VpRG93bkFjdGlvbicpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVubGlzdGVuKHRoaXMua2V5RXZlbnRUYXJnZXQsICd1cCcsICd1aVVwQWN0aW9uJyk7XG4gICAgdGhpcy51bmxpc3Rlbih0aGlzLmtleUV2ZW50VGFyZ2V0LCAnZG93bicsICd1aURvd25BY3Rpb24nKTtcbiAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gbnVsbDtcbiAgfSxcblxuICBnZXQgc2hvdWxkS2VlcEFuaW1hdGluZyAoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucmlwcGxlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5yaXBwbGVzW2luZGV4XS5pc0FuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBzaW11bGF0ZWRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG93bkFjdGlvbihudWxsKTtcblxuICAgIC8vIFBsZWFzZSBzZWUgcG9seW1lci9wb2x5bWVyIzEzMDVcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy51cEFjdGlvbigpO1xuICAgIH0sIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSBkb3duIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAqL1xuICB1aURvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm5vaW5rKSB7XG4gICAgICB0aGlzLmRvd25BY3Rpb24oZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5ob2xkRG93biAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByaXBwbGUgPSB0aGlzLmFkZFJpcHBsZSgpO1xuXG4gICAgcmlwcGxlLmRvd25BY3Rpb24oZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAqL1xuICB1aVVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgdGhpcy51cEFjdGlvbihldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaG9sZERvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJpcHBsZXMuZm9yRWFjaChmdW5jdGlvbihyaXBwbGUpIHtcbiAgICAgIHJpcHBsZS51cEFjdGlvbihldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0ZSgpO1xuICB9LFxuXG4gIG9uQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2FuaW1hdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgdGhpcy5maXJlKCd0cmFuc2l0aW9uZW5kJyk7XG4gIH0sXG5cbiAgYWRkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmlwcGxlID0gbmV3IFJpcHBsZSh0aGlzKTtcblxuICAgIGRvbSh0aGlzLiQud2F2ZXMpLmFwcGVuZENoaWxkKHJpcHBsZS53YXZlQ29udGFpbmVyKTtcbiAgICB0aGlzLiQuYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByaXBwbGUuY29sb3I7XG4gICAgdGhpcy5yaXBwbGVzLnB1c2gocmlwcGxlKTtcblxuICAgIHRoaXMuX3NldEFuaW1hdGluZyh0cnVlKTtcblxuICAgIHJldHVybiByaXBwbGU7XG4gIH0sXG5cbiAgcmVtb3ZlUmlwcGxlOiBmdW5jdGlvbihyaXBwbGUpIHtcbiAgICB2YXIgcmlwcGxlSW5kZXggPSB0aGlzLnJpcHBsZXMuaW5kZXhPZihyaXBwbGUpO1xuXG4gICAgaWYgKHJpcHBsZUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmlwcGxlcy5zcGxpY2UocmlwcGxlSW5kZXgsIDEpO1xuXG4gICAgcmlwcGxlLnJlbW92ZSgpO1xuXG4gICAgaWYgKCF0aGlzLnJpcHBsZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZXRBbmltYXRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBjb25mbGljdHMgd2l0aCBFbGVtZW50I2FudGltYXRlKCkuXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2FuaW1hdGVcbiAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGluZGV4O1xuICAgIHZhciByaXBwbGU7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJpcHBsZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICByaXBwbGUgPSB0aGlzLnJpcHBsZXNbaW5kZXhdO1xuXG4gICAgICByaXBwbGUuZHJhdygpO1xuXG4gICAgICB0aGlzLiQuYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gcmlwcGxlLm91dGVyT3BhY2l0eTtcblxuICAgICAgaWYgKHJpcHBsZS5pc09wYWNpdHlGdWxseURlY2F5ZWQgJiYgIXJpcHBsZS5pc1Jlc3RpbmdBdE1heFJhZGl1cykge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZShyaXBwbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRLZWVwQW5pbWF0aW5nICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub25BbmltYXRpb25Db21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kQW5pbWF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkVudGVyS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51aURvd25BY3Rpb24oKTtcbiAgICB0aGlzLmFzeW5jKHRoaXMudWlVcEFjdGlvbiwgMSk7XG4gIH0sXG5cbiAgX29uU3BhY2VLZXlkb3duOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICB9LFxuXG4gIF9vblNwYWNlS2V5dXA6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudWlVcEFjdGlvbigpO1xuICB9LFxuXG4gIC8vIG5vdGU6IGhvbGREb3duIGRvZXMgbm90IHJlc3BlY3Qgbm9pbmsgc2luY2UgaXQgY2FuIGJlIGEgZm9jdXMgYmFzZWRcbiAgLy8gZWZmZWN0LlxuICBfaG9sZERvd25DaGFuZ2VkOiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkge1xuICAgIGlmIChvbGRWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV3VmFsKSB7XG4gICAgICB0aGlzLmRvd25BY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cEFjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXG4gIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHdhaXQgdW50aWxcbiAgdGhlIHJpcHBsZSBhbmltYXRpb24gZmluaXNoZXMgdG8gcGVyZm9ybSBzb21lIGFjdGlvbi5cblxuICBAZXZlbnQgdHJhbnNpdGlvbmVuZFxuICBAcGFyYW0ge3tub2RlOiBPYmplY3R9fSBkZXRhaWwgQ29udGFpbnMgdGhlIGFuaW1hdGVkIG5vZGUuXG4gICovXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtfcG9pbnRlcnNDb3VudH0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICovXHJcblxyXG52YXIgX3RvdWNoc3RhcnQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEJyb3dzZXIucG9pbnRlciA/ICdwb2ludGVyZG93bicgOiAndG91Y2hzdGFydCcsXHJcbiAgICBfdG91Y2hlbmQgPSBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiBCcm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCcsXHJcbiAgICBfcHJlID0gJ19sZWFmbGV0Xyc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBaZXB0byB0b3VjaCBjb2RlIGJ5IFRob21hcyBGdWNoc1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkRG91YmxlVGFwTGlzdGVuZXIob2JqLCBoYW5kbGVyLCBpZCkge1xyXG5cdHZhciBsYXN0LCB0b3VjaCxcclxuXHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0ICAgIGRlbGF5ID0gMjUwO1xyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xyXG5cdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0aWYgKCghQnJvd3Nlci5lZGdlKSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRjb3VudCA9IF9wb2ludGVyc0NvdW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb3VudCA+IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCksXHJcblx0XHQgICAgZGVsdGEgPSBub3cgLSAobGFzdCB8fCBub3cpO1xyXG5cclxuXHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdGRvdWJsZVRhcCA9IChkZWx0YSA+IDAgJiYgZGVsdGEgPD0gZGVsYXkpO1xyXG5cdFx0bGFzdCA9IG5vdztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xyXG5cdFx0aWYgKGRvdWJsZVRhcCAmJiAhdG91Y2guY2FuY2VsQnViYmxlKSB7XHJcblx0XHRcdGlmIChCcm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRpZiAoKCFCcm93c2VyLmVkZ2UpIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdHZhciBuZXdUb3VjaCA9IHt9LFxyXG5cdFx0XHRcdCAgICBwcm9wLCBpO1xyXG5cclxuXHRcdFx0XHRmb3IgKGkgaW4gdG91Y2gpIHtcclxuXHRcdFx0XHRcdHByb3AgPSB0b3VjaFtpXTtcclxuXHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQodG91Y2gpIDogcHJvcDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dG91Y2ggPSBuZXdUb3VjaDtcclxuXHRcdFx0fVxyXG5cdFx0XHR0b3VjaC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRcdFx0aGFuZGxlcih0b3VjaCk7XHJcblx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b2JqW19wcmUgKyBfdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRvYmpbX3ByZSArIF90b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblx0b2JqW19wcmUgKyAnZGJsY2xpY2snICsgaWRdID0gaGFuZGxlcjtcclxuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgb25Ub3VjaEVuZCwgZmFsc2UpO1xyXG5cclxuXHQvLyBPbiBzb21lIHBsYXRmb3JtcyAobm90YWJseSwgY2hyb21lPDU1IG9uIHdpbjEwICsgdG91Y2hzY3JlZW4gKyBtb3VzZSksXHJcblx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIHRvdWNoZW5kL3BvaW50ZXJ1cCBldmVudHMgYnV0IGRvZXMgZmlyZVxyXG5cdC8vIG5hdGl2ZSBkYmxjbGlja3MuIFNlZSAjNDEyNy5cclxuXHQvLyBFZGdlIDE0IGFsc28gZmlyZXMgbmF0aXZlIGRibGNsaWNrcywgYnV0IG9ubHkgZm9yIHBvaW50ZXJUeXBlIG1vdXNlLCBzZWUgIzUxODAuXHJcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpIHtcclxuXHR2YXIgdG91Y2hzdGFydCA9IG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0sXHJcblx0ICAgIHRvdWNoZW5kID0gb2JqW19wcmUgKyBfdG91Y2hlbmQgKyBpZF0sXHJcblx0ICAgIGRibGNsaWNrID0gb2JqW19wcmUgKyAnZGJsY2xpY2snICsgaWRdO1xyXG5cclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgZmFsc2UpO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKF90b3VjaGVuZCwgdG91Y2hlbmQsIGZhbHNlKTtcclxuXHRpZiAoIUJyb3dzZXIuZWRnZSkge1xyXG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZGJsY2xpY2ssIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZG9tL0RvbUV2ZW50LkRvdWJsZVRhcC5qcyIsImltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIEBzZWN0aW9uIERyYWdnaW5nIGV2ZW50c1xuXHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdC8vIEBldmVudCBtb3Zlc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0YXJ0cyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXG5cdFx0dGhpcy5fb2xkTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldExhdExuZygpO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuY2xvc2VQb3B1cCgpXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gdGhpcy5fbWFya2VyLFxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcblx0XHRpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0b3BzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cdFx0ZGVsZXRlIHRoaXMuX29sZExhdExuZztcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5EcmFnLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiMjI3M2UzZDhhZDkyNjRiN2RhYTViZGJmOGU2YjQ3ZjgucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24ucG5nXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiNDRhNTI2ZWVkMjU4MjIyNTE1YWEyMWVhZmZkMTRhOTYucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmdcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBFbGVtZW50IGFzIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB9IGZyb20gJy4uLy4uL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBNYXAgfSBmcm9tICcuLi8uLi9sZWFmbGV0L3NyYy9tYXAnO1xuaW1wb3J0IHsgQXR0cmlidXRpb24gfSBmcm9tICcuLi8uLi9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuQXR0cmlidXRpb24uanMnXG5cbi8vIE5lZWQgdGhlc2Ugc2lkZSBlZmZlY3RzXG5pbXBvcnQgJy4uLy4uL2xlYWZsZXQvc3JjL2NvbnRyb2wnO1xuaW1wb3J0ICcuLi8uLi9sZWFmbGV0L3NyYy9sYXllcic7XG5cbmV4cG9ydCBjbGFzcyBMZWFmbGV0TWFwIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmNzc1wiIC8+XG5cbiAgICAgIDwhLS0gRklYTUU6IEZpZ3VyZSBvdXQgU2hhZG93IERPTSBzbyB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbmNsdWRlZCBoZXJlIC0tPlxuICAgICAgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCJodHRwczovL3VucGtnLmNvbS9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXJAMS4zLjAvZGlzdC9NYXJrZXJDbHVzdGVyLmNzc1wiIG1lZGlhPVwic2NyZWVuXCI+XG4gICAgICA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXQubWFya2VyY2x1c3RlckAxLjMuMC9kaXN0L01hcmtlckNsdXN0ZXIuRGVmYXVsdC5jc3NcIiBtZWRpYT1cInNjcmVlblwiPlxuXG4gICAgICA8c3R5bGU+XG4gICAgICAgICNtYXAge1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICBAYXBwbHkgKC0tbGVhZmxldC1tYXAtY29tcG9uZW50KVxuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuXG4gICAgICA8ZGl2IGlkPVwibWFwXCI+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxhdGl0dWRlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIGxvbmdpdHVkZToge1xuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICB6b29tOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIG1pblpvb206IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgbWF4Wm9vbToge1xuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICB6b29tQ29udHJvbDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGlvblByZWZpeDoge1xuICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICBfY2hpbGRyZW5PYnNlcnZlcjogT2JqZWN0XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAodGhpcy4kLm1hcCwge1xuICAgICAgY2VudGVyOiBbdGhpcy5sYXRpdHVkZSwgdGhpcy5sb25naXR1ZGVdLFxuICAgICAgem9vbTogdGhpcy56b29tLFxuICAgICAgem9vbUNvbnRyb2w6IHRoaXMuem9vbUNvbnRyb2wsXG4gICAgICBpbmVydGlhRGVjZWxlcmF0aW9uOiAzMDAwLFxuICAgICAgaW5lcnRpYU1heFNwZWVkOiAzMDAwLFxuICAgICAgYXR0cmlidXRpb25Db250cm9sOiBmYWxzZSxcbiAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgIHRhcFRvbGVyYW5jZTogNDBcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF0dHJpYnV0aW9uUHJlZml4KSB7XG4gICAgICBsZXQgYXR0ckNvbnRyb2wgPSBuZXcgQXR0cmlidXRpb24oeyBwcmVmaXg6IHRoaXMuYXR0cmlidXRpb25QcmVmaXggfSk7XG4gICAgICB0aGlzLm1hcC5hZGRDb250cm9sKGF0dHJDb250cm9sKTtcbiAgICB9XG5cbiAgICAvLyBMLm1hcmtlcihbdGhpcy5sYXRpdHVkZSwgdGhpcy5sb25naXR1ZGVdKS5hZGRUbyh0aGlzLm1hcCk7XG5cbiAgICBsZXQgc2xvdCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdzbG90Jyk7XG4gICAgdGhpcy5fY2hpbGRyZW5PYnNlcnZlciA9IG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHNsb3QsIHRoaXMuX2JpbmREZXBlbmRlbmNpZXMuYmluZCh0aGlzKSk7XG4gIH1cbiAgXG4gIC8qIFNoaXR0eSB3YXkgb2YgcGFzc2luZyB2YWx1ZSB0byBjaGlsZHJlbiAqL1xuICBfYmluZERlcGVuZGVuY2llcyh7YWRkZWROb2Rlc30pIHtcbiAgICBhZGRlZE5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICBuLm1hcCA9IHRoaXMubWFwO1xuICAgIH0pO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC1tYXAnLCBMZWFmbGV0TWFwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC1tYXAvbGVhZmxldC1tYXAuanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLkJveFpvb20gaXMgdXNlZCB0byBhZGQgc2hpZnQtZHJhZyB6b29tIGludGVyYWN0aW9uIHRvIHRoZSBtYXBcbiAqICh6b29tIHRvIGEgc2VsZWN0ZWQgYm91bmRpbmcgYm94KSwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBCb3hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHRtYXAub24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3ksIHRoaXMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb3ZlZDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3BhbmUpO1xuXHRcdGRlbGV0ZSB0aGlzLl9wYW5lO1xuXHR9LFxuXG5cdF9yZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XG5cdH0sXG5cblx0X2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSAwO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnNoaWZ0S2V5IHx8ICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBDbGVhciB0aGUgZGVmZXJyZWQgcmVzZXRTdGF0ZSBpZiBpdCBoYXNuJ3QgZXhlY3V0ZWQgeWV0LCBvdGhlcndpc2UgaXRcblx0XHQvLyB3aWxsIGludGVycnVwdCB0aGUgaW50ZXJhY3Rpb24gYW5kIG9ycGhhbiBhIGJveCBlbGVtZW50IGluIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cblx0XHREb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG5cdFx0RG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JveCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY3Jvc3NoYWlyJyk7XG5cblx0XHRcdHRoaXMuX21hcC5maXJlKCdib3h6b29tc3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgQm91bmRzKHRoaXMuX3BvaW50LCB0aGlzLl9zdGFydFBvaW50KSxcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9ib3gpO1xuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdGNvbnRleHRtZW51OiBEb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3Jlc2V0U3RhdGUsIHRoaXMpLCAwKTtcblxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgICAgICB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpO1xuXG5cdFx0dGhpcy5fbWFwXG5cdFx0XHQuZml0Qm91bmRzKGJvdW5kcylcblx0XHRcdC5maXJlKCdib3h6b29tZW5kJywge2JveFpvb21Cb3VuZHM6IGJvdW5kc30pO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuX2ZpbmlzaCgpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgYm94Wm9vbTogSGFuZGxlclxuLy8gQm94IChzaGlmdC1kcmFnIHdpdGggbW91c2UpIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgQm94Wm9vbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5cbi8qXG4gKiBMLkhhbmRsZXIuRG91YmxlQ2xpY2tab29tIGlzIHVzZWQgdG8gaGFuZGxlIGRvdWJsZS1jbGljayB6b29tIG9uIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkb3VibGVDbGlja1pvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBpbiBieSBkb3VibGUgY2xpY2tpbmcgb24gaXQgYW5kXG5cdC8vIHpvb21lZCBvdXQgYnkgZG91YmxlIGNsaWNraW5nIHdoaWxlIGhvbGRpbmcgc2hpZnQuIElmIHBhc3NlZFxuXHQvLyBgJ2NlbnRlcidgLCBkb3VibGUtY2xpY2sgem9vbSB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGVcblx0Ly8gIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRkb3VibGVDbGlja1pvb206IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIERvdWJsZUNsaWNrWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25Eb3VibGVDbGljaywgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9sZFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5vcHRpb25zLnpvb21EZWx0YSxcblx0XHQgICAgem9vbSA9IGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSA/IG9sZFpvb20gLSBkZWx0YSA6IG9sZFpvb20gKyBkZWx0YTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5kb3VibGVDbGlja1pvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQoZS5jb250YWluZXJQb2ludCwgem9vbSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vXG4vLyBNYXAgcHJvcGVydGllcyBpbmNsdWRlIGludGVyYWN0aW9uIGhhbmRsZXJzIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2xcbi8vIGludGVyYWN0aW9uIGJlaGF2aW9yIGluIHJ1bnRpbWUsIGVuYWJsaW5nIG9yIGRpc2FibGluZyBjZXJ0YWluIGZlYXR1cmVzIHN1Y2hcbi8vIGFzIGRyYWdnaW5nIG9yIHRvdWNoIHpvb20gKHNlZSBgSGFuZGxlcmAgbWV0aG9kcykuIEZvciBleGFtcGxlOlxuLy9cbi8vIGBgYGpzXG4vLyBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbi8vIGBgYFxuLy9cbi8vIEBwcm9wZXJ0eSBkb3VibGVDbGlja1pvb206IEhhbmRsZXJcbi8vIERvdWJsZSBjbGljayB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgRG91YmxlQ2xpY2tab29tKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbS5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtEcmFnZ2FibGV9IGZyb20gJy4uLy4uL2RvbS9EcmFnZ2FibGUnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzIGFzIGxhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZHJhZ2dpbmc6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBiZSBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXG5cdGRyYWdnaW5nOiB0cnVlLFxuXG5cdC8vIEBzZWN0aW9uIFBhbm5pbmcgSW5lcnRpYSBPcHRpb25zXG5cdC8vIEBvcHRpb24gaW5lcnRpYTogQm9vbGVhbiA9ICpcblx0Ly8gSWYgZW5hYmxlZCwgcGFubmluZyBvZiB0aGUgbWFwIHdpbGwgaGF2ZSBhbiBpbmVydGlhIGVmZmVjdCB3aGVyZVxuXHQvLyB0aGUgbWFwIGJ1aWxkcyBtb21lbnR1bSB3aGlsZSBkcmFnZ2luZyBhbmQgY29udGludWVzIG1vdmluZyBpblxuXHQvLyB0aGUgc2FtZSBkaXJlY3Rpb24gZm9yIHNvbWUgdGltZS4gRmVlbHMgZXNwZWNpYWxseSBuaWNlIG9uIHRvdWNoXG5cdC8vIGRldmljZXMuIEVuYWJsZWQgYnkgZGVmYXVsdCB1bmxlc3MgcnVubmluZyBvbiBvbGQgQW5kcm9pZCBkZXZpY2VzLlxuXHRpbmVydGlhOiAhQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5leHBvcnQgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xuXHRcdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uWm9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuZGl2aWRlQnkoMiksXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XG5cblx0XHR0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQgPSBweFdvcmxkQ2VudGVyLnN1YnRyYWN0KHB4Q2VudGVyKS54O1xuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAuZ2V0UGl4ZWxXb3JsZEJvdW5kcygpLmdldFNpemUoKS54O1xuXHR9LFxuXG5cdF92aXNjb3VzTGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGhyZXNob2xkKSB7XG5cdFx0cmV0dXJuIHZhbHVlIC0gKHZhbHVlIC0gdGhyZXNob2xkKSAqIHRoaXMuX3Zpc2Nvc2l0eTtcblx0fSxcblxuXHRfb25QcmVEcmFnTGltaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX3Zpc2Nvc2l0eSB8fCAhdGhpcy5fb2Zmc2V0TGltaXQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyk7XG5cblx0XHR2YXIgbGltaXQgPSB0aGlzLl9vZmZzZXRMaW1pdDtcblx0XHRpZiAob2Zmc2V0LnggPCBsaW1pdC5taW4ueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWluLngpOyB9XG5cdFx0aWYgKG9mZnNldC55IDwgbGltaXQubWluLnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1pbi55KTsgfVxuXHRcdGlmIChvZmZzZXQueCA+IGxpbWl0Lm1heC54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5tYXgueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPiBsaW1pdC5tYXgueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWF4LnkpOyB9XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ1dyYXA6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cblx0XHR2YXIgd29ybGRXaWR0aCA9IHRoaXMuX3dvcmxkV2lkdGgsXG5cdFx0ICAgIGhhbGZXaWR0aCA9IE1hdGgucm91bmQod29ybGRXaWR0aCAvIDIpLFxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcblx0XHQgICAgeCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsXG5cdFx0ICAgIG5ld1gxID0gKHggLSBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoICsgaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXG5cdFx0ICAgIG5ld1ggPSBNYXRoLmFicyhuZXdYMSArIGR4KSA8IE1hdGguYWJzKG5ld1gyICsgZHgpID8gbmV3WDEgOiBuZXdYMjtcblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54ID0gbmV3WDtcblx0fSxcblxuXHRfb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcblxuXHRcdCAgICBub0luZXJ0aWEgPSAhb3B0aW9ucy5pbmVydGlhIHx8IHRoaXMuX3RpbWVzLmxlbmd0aCA8IDI7XG5cblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXG5cdFx0aWYgKG5vSW5lcnRpYSkge1xuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSB0aGlzLl9sYXN0UG9zLnN1YnRyYWN0KHRoaXMuX3Bvc2l0aW9uc1swXSksXG5cdFx0XHQgICAgZHVyYXRpb24gPSAodGhpcy5fbGFzdFRpbWUgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxuXHRcdFx0ICAgIGVhc2UgPSBvcHRpb25zLmVhc2VMaW5lYXJpdHksXG5cblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXG5cdFx0XHQgICAgc3BlZWQgPSBzcGVlZFZlY3Rvci5kaXN0YW5jZVRvKFswLCAwXSksXG5cblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZFZlY3RvciA9IHNwZWVkVmVjdG9yLm11bHRpcGx5QnkobGltaXRlZFNwZWVkIC8gc3BlZWQpLFxuXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXG5cdFx0XHQgICAgb2Zmc2V0ID0gbGltaXRlZFNwZWVkVmVjdG9yLm11bHRpcGx5QnkoLWRlY2VsZXJhdGlvbkR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuXHRcdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcblx0XHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldChvZmZzZXQsIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0LCB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXG5cdFx0XHRcdFx0XHRlYXNlTGluZWFyaXR5OiBlYXNlLFxuXHRcdFx0XHRcdFx0bm9Nb3ZlU3RhcnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRhbmltYXRlOiB0cnVlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgZHJhZ2dpbmc6IEhhbmRsZXJcbi8vIE1hcCBkcmFnZ2luZyBoYW5kbGVyIChieSBib3RoIG1vdXNlIGFuZCB0b3VjaCkuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBEcmFnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLkRyYWcuanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7b24sIG9mZiwgc3RvcH0gZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcblx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG5cdGtleWJvYXJkOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcblx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG5cdGtleWJvYXJkUGFuRGVsdGE6IDgwXG59KTtcblxuZXhwb3J0IHZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0b24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXG5cdFx0XHRpZiAobWFwLl9wYW5BbmltICYmIG1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykgeyByZXR1cm47IH1cblxuXHRcdFx0b2Zmc2V0ID0gdGhpcy5fcGFuS2V5c1trZXldO1xuXHRcdFx0aWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHR9XG5cblx0XHRcdG1hcC5wYW5CeShvZmZzZXQpO1xuXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdG1hcC5wYW5JbnNpZGVCb3VuZHMobWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwKSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLlNjcm9sbFdoZWVsWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGVuYWJsZSBtb3VzZSBzY3JvbGwgd2hlZWwgem9vbSBvbiB0aGUgbWFwLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2V3aGVlbCBvcHRpb25zXG5cdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcblx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcblx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcblx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG5cdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cblx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbn0pO1xuXG5leHBvcnQgdmFyIFNjcm9sbFdoZWVsWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblx0fSxcblxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZGVsdGEgPSBEb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHREb21FdmVudC5zdG9wKGUpO1xuXHR9LFxuXG5cdF9wZXJmb3JtWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzbmFwID0gdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXAgfHwgMDtcblxuXHRcdG1hcC5fc3RvcCgpOyAvLyBzdG9wIHBhbm5pbmcgYW5kIGZseSBhbmltYXRpb25zIGlmIGFueVxuXG5cdFx0Ly8gbWFwIHRoZSBkZWx0YSB3aXRoIGEgc2lnbW9pZCBmdW5jdGlvbiB0byAtNC4uNCByYW5nZSBsZWFuaW5nIG9uIC0xLi4xXG5cdFx0dmFyIGQyID0gdGhpcy5fZGVsdGEgLyAodGhpcy5fbWFwLm9wdGlvbnMud2hlZWxQeFBlclpvb21MZXZlbCAqIDQpLFxuXHRcdCAgICBkMyA9IDQgKiBNYXRoLmxvZygyIC8gKDEgKyBNYXRoLmV4cCgtTWF0aC5hYnMoZDIpKSkpIC8gTWF0aC5MTjIsXG5cdFx0ICAgIGQ0ID0gc25hcCA/IE1hdGguY2VpbChkMyAvIHNuYXApICogc25hcCA6IGQzLFxuXHRcdCAgICBkZWx0YSA9IG1hcC5fbGltaXRab29tKHpvb20gKyAodGhpcy5fZGVsdGEgPiAwID8gZDQgOiAtZDQpKSAtIHpvb207XG5cblx0XHR0aGlzLl9kZWx0YSA9IDA7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFwLnNldFpvb21Bcm91bmQodGhpcy5fbGFzdE1vdXNlUG9zLCB6b29tICsgZGVsdGEpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgc2Nyb2xsV2hlZWxab29tOiBIYW5kbGVyXG4vLyBTY3JvbGwgd2hlZWwgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3Njcm9sbFdoZWVsWm9vbScsIFNjcm9sbFdoZWVsWm9vbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuXG4vKlxuICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXA6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIEVuYWJsZXMgbW9iaWxlIGhhY2tzIGZvciBzdXBwb3J0aW5nIGluc3RhbnQgdGFwcyAoZml4aW5nIDIwMG1zIGNsaWNrXG5cdC8vIGRlbGF5IG9uIGlPUy9BbmRyb2lkKSBhbmQgdG91Y2ggaG9sZHMgKGZpcmVkIGFzIGBjb250ZXh0bWVudWAgZXZlbnRzKS5cblx0dGFwOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gdGFwVG9sZXJhbmNlOiBOdW1iZXIgPSAxNVxuXHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCBoaXMgZmluZ2VyIGR1cmluZyB0b3VjaFxuXHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIHRhcC5cblx0dGFwVG9sZXJhbmNlOiAxNVxufSk7XG5cbmV4cG9ydCB2YXIgVGFwID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzKSB7IHJldHVybjsgfVxuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cblx0XHR0aGlzLl9maXJlQ2xpY2sgPSB0cnVlO1xuXG5cdFx0Ly8gZG9uJ3Qgc2ltdWxhdGUgY2xpY2sgb3IgdHJhY2sgbG9uZ3ByZXNzIGlmIG1vcmUgdGhhbiAxIHRvdWNoXG5cdFx0aWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdLFxuXHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gdGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXG5cdFx0Ly8gaWYgdG91Y2hpbmcgYSBsaW5rLCBoaWdobGlnaHQgaXRcblx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2ltdWxhdGUgbG9uZyBob2xkIGJ1dCBzZXR0aW5nIGEgdGltZW91dFxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb25VcCgpO1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSwgMTAwMCk7XG5cblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZWRvd24nLCBmaXJzdCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9ob2xkVGltZW91dCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsIHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5fb25Nb3ZlLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuX29uVXBcblx0XHR9LCB0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9maXJlQ2xpY2sgJiYgZSAmJiBlLmNoYW5nZWRUb3VjaGVzKSB7XG5cblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZWwgPSBmaXJzdC50YXJnZXQ7XG5cblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZXVwJywgZmlyc3QpO1xuXG5cdFx0XHQvLyBzaW11bGF0ZSBjbGljayBpZiB0aGUgdG91Y2ggZGlkbid0IG1vdmUgdG9vIG11Y2hcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY2xpY2snLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG5cdH0sXG5cblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlbW92ZScsIGZpcnN0KTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XG5cblx0XHRzaW11bGF0ZWRFdmVudC5pbml0TW91c2VFdmVudChcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcblx0XHQgICAgICAgIGUuc2NyZWVuWCwgZS5zY3JlZW5ZLFxuXHRcdCAgICAgICAgZS5jbGllbnRYLCBlLmNsaWVudFksXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cblx0XHRlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdGFwOiBIYW5kbGVyXG4vLyBNb2JpbGUgdG91Y2ggaGFja3MgKHF1aWNrIHRhcCBhbmQgdG91Y2ggaG9sZCkgaGFuZGxlci5cbmlmIChCcm93c2VyLnRvdWNoICYmICFCcm93c2VyLnBvaW50ZXIpIHtcblx0TWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcCcsIFRhcCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzIGV4Y2VwdCBmb3Igb2xkIEFuZHJvaWRzLlxuXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2ggJiYgIUJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gYm91bmNlQXRab29tTGltaXRzOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBTZXQgaXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byB6b29tIGJleW9uZCBtaW4vbWF4IHpvb21cblx0Ly8gYW5kIHRoZW4gYm91bmNlIGJhY2sgd2hlbiBwaW5jaC16b29taW5nLlxuXHRib3VuY2VBdFpvb21MaW1pdHM6IHRydWVcbn0pO1xuXG5leHBvcnQgdmFyIFRvdWNoWm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG5cdFx0dGhpcy5fem9vbSA9IG1hcC5nZXRTY2FsZVpvb20oc2NhbGUsIHRoaXMuX3N0YXJ0Wm9vbSk7XG5cblx0XHRpZiAoIW1hcC5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyAmJiAoXG5cdFx0XHQodGhpcy5fem9vbSA8IG1hcC5nZXRNaW5ab29tKCkgJiYgc2NhbGUgPCAxKSB8fFxuXHRcdFx0KHRoaXMuX3pvb20gPiBtYXAuZ2V0TWF4Wm9vbSgpICYmIHNjYWxlID4gMSkpKSB7XG5cdFx0XHR0aGlzLl96b29tID0gbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnRvdWNoWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0TGF0TG5nO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxKSB7IHJldHVybjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgZGVsdGEgZnJvbSBwaW5jaCB0byBjZW50ZXIsIHNvIGNlbnRlckxhdExuZyBpcyBkZWx0YSBhcHBsaWVkIHRvIGluaXRpYWwgcGluY2hMYXRMbmdcblx0XHRcdHZhciBkZWx0YSA9IHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdFx0aWYgKHNjYWxlID09PSAxICYmIGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkgeyByZXR1cm47IH1cblx0XHRcdHRoaXMuX2NlbnRlciA9IG1hcC51bnByb2plY3QobWFwLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZywgdGhpcy5fem9vbSkuc3VidHJhY3QoZGVsdGEpLCB0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XG5cdFx0XHRtYXAuX21vdmVTdGFydCh0cnVlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanMiLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcblx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX2Zvcm0uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fZm9ybSwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2Zvcm0sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxyXG5cdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcblx0XHR2YXIgZm9ybSA9IHRoaXMuX2Zvcm0gPSBEb21VdGlsLmNyZWF0ZSgnZm9ybScsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIGZvcm0pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgZm9ybSk7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIGZvcm0pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgVXRpbC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoVXRpbC5iaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcblx0XHRpbnB1dC5sYXllcklkID0gVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbmV4cG9ydCB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5MYXllcnMuanMiLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnJiN4MjIxMjsnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG5leHBvcnQgdmFyIHpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuWm9vbS5qcyIsIlxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5TY2FsZS5qcyIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVmlkZW9PdmVybGF5XHJcbiAqIEBha2EgTC5WaWRlb092ZXJsYXlcclxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSB2aWRlbyBwbGF5ZXIgb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgSW1hZ2VPdmVybGF5YC5cclxuICpcclxuICogQSB2aWRlbyBvdmVybGF5IHVzZXMgdGhlIFtgPHZpZGVvPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC92aWRlbylcclxuICogSFRNTDUgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHZpZGVvVXJsID0gJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vYml0ZXMvMDAxODgvcGF0cmljaWFfbmFzYS53ZWJtJyxcclxuICogXHR2aWRlb0JvdW5kcyA9IFtbIDMyLCAtMTMwXSwgWyAxMywgLTEwMF1dO1xyXG4gKiBMLlZpZGVvT3ZlcmxheSh2aWRlb1VybCwgdmlkZW9Cb3VuZHMgKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFZpZGVvT3ZlcmxheSA9IEltYWdlT3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVmlkZW9PdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGF1dG9wbGF5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gc3RhcnRzIHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGxvYWRlZC5cclxuXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcblx0XHRsb29wOiB0cnVlXHJcblx0fSxcclxuXHJcblx0X2luaXRJbWFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHdhc0VsZW1lbnRTdXBwbGllZCA9IHRoaXMuX3VybC50YWdOYW1lID09PSAnVklERU8nO1xyXG5cdFx0dmFyIHZpZCA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ3ZpZGVvJyk7XHJcblxyXG5cdFx0dmlkLmNsYXNzID0gdmlkLmNsYXNzIHx8ICcnO1xyXG5cdFx0dmlkLmNsYXNzICs9ICdsZWFmbGV0LWltYWdlLWxheWVyICcgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcgOiAnJyk7XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cmwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHNvdXJjZSA9IERvbVV0aWwuY3JlYXRlKCdzb3VyY2UnKTtcclxuXHRcdFx0c291cmNlLnNyYyA9IHRoaXMuX3VybFtpXTtcclxuXHRcdFx0dmlkLmFwcGVuZENoaWxkKHNvdXJjZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEVsZW1lbnQoKTogSFRNTFZpZGVvRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTFZpZGVvRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MVmlkZW9FbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnZpZGVvT3ZlcmxheSh2aWRlbzogU3RyaW5nfEFycmF5fEhUTUxWaWRlb0VsZW1lbnQsIGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogVmlkZW9PdmVybGF5IG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiB0aGUgVVJMIG9mIHRoZSB2aWRlbyAob3IgYXJyYXkgb2YgVVJMcywgb3IgZXZlbiBhIHZpZGVvIGVsZW1lbnQpIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZpZGVvT3ZlcmxheSh2aWRlbywgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBWaWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9WaWRlb092ZXJsYXkuanMiLCJpbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcclxuaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtQYXRofSBmcm9tICcuL3ZlY3Rvci9QYXRoJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBQb3B1cFxyXG4gKiBAaW5oZXJpdHMgRGl2T3ZlcmxheVxyXG4gKiBAYWthIEwuUG9wdXBcclxuICogVXNlZCB0byBvcGVuIHBvcHVwcyBpbiBjZXJ0YWluIHBsYWNlcyBvZiB0aGUgbWFwLiBVc2UgW01hcC5vcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSB0b1xyXG4gKiBvcGVuIHBvcHVwcyB3aGlsZSBtYWtpbmcgc3VyZSB0aGF0IG9ubHkgb25lIHBvcHVwIGlzIG9wZW4gYXQgb25lIHRpbWVcclxuICogKHJlY29tbWVuZGVkIGZvciB1c2FiaWxpdHkpLCBvciB1c2UgW01hcC5hZGRMYXllcl0oI21hcC1hZGRsYXllcikgdG8gb3BlbiBhcyBtYW55IGFzIHlvdSB3YW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBJZiB5b3Ugd2FudCB0byBqdXN0IGJpbmQgYSBwb3B1cCB0byBtYXJrZXIgY2xpY2sgYW5kIHRoZW4gb3BlbiBpdCwgaXQncyByZWFsbHkgZWFzeTpcclxuICpcclxuICogYGBganNcclxuICogbWFya2VyLmJpbmRQb3B1cChwb3B1cENvbnRlbnQpLm9wZW5Qb3B1cCgpO1xyXG4gKiBgYGBcclxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFBvcHVwYCBtZXRob2QuXHJcbiAqIEhlcmUncyBhIG1vcmUgY29tcGxpY2F0ZWQgd2F5IHRvIG9wZW4gYSBwb3B1cCBvbiBhIG1hcDpcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cCgpXHJcbiAqIFx0LnNldExhdExuZyhsYXRsbmcpXHJcbiAqIFx0LnNldENvbnRlbnQoJzxwPkhlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHBvcHVwLjwvcD4nKVxyXG4gKiBcdC5vcGVuT24obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuZXhwb3J0IHZhciBQb3B1cCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFBvcHVwIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIHBvcHVwIHRvIHRoZSBtYXAgYW5kIGNsb3NlcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgc2FtZSBhcyBgbWFwLm9wZW5Qb3B1cChwb3B1cClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9wZW5Qb3B1cCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGlzIG9wZW5lZCBpbiB0aGUgbWFwXHJcblx0XHRtYXAuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBvcGVuJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdC8vIEZvciBub24tcGF0aCBsYXllcnMsIHdlIHRvZ2dsZSB0aGUgcG9wdXAgd2hlbiBjbGlja2luZ1xyXG5cdFx0XHQvLyBhZ2FpbiB0aGUgbGF5ZXIsIHNvIHByZXZlbnQgdGhlIG1hcCB0byByZW9wZW4gaXQuXHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaW4gdGhlIG1hcCBpcyBjbG9zZWRcclxuXHRcdG1hcC5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xyXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXHJcblx0XHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAhPT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA6IHRoaXMuX21hcC5vcHRpb25zLmNsb3NlUG9wdXBPbkNsaWNrKSB7XHJcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMua2VlcEluVmlldykge1xyXG5cdFx0XHRldmVudHMubW92ZWVuZCA9IHRoaXMuX2FkanVzdFBhbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24od3JhcHBlcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24odGhpcy5fY29udGVudE5vZGUpO1xyXG5cdFx0RG9tRXZlbnQub24od3JhcHBlciwgJ2NvbnRleHRtZW51JywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAtY29udGFpbmVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX3RpcCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xyXG5cdFx0XHR2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9IERvbVV0aWwuY3JlYXRlKCdhJywgcHJlZml4ICsgJy1jbG9zZS1idXR0b24nLCBjb250YWluZXIpO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5ocmVmID0gJyNjbG9zZSc7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmlubmVySFRNTCA9ICcmIzIxNTsnO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzY3JvbGxlZENsYXNzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4gfHwgKHRoaXMuX21hcC5fcGFuQW5pbSAmJiB0aGlzLl9tYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoRG9tVXRpbC5nZXRTdHlsZSh0aGlzLl9jb250YWluZXIsICdtYXJnaW5Cb3R0b20nKSwgMTApIHx8IDAsXHJcblx0XHQgICAgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCArIG1hcmdpbkJvdHRvbSxcclxuXHRcdCAgICBjb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lcldpZHRoLFxyXG5cdFx0ICAgIGxheWVyUG9zID0gbmV3IFBvaW50KHRoaXMuX2NvbnRhaW5lckxlZnQsIC1jb250YWluZXJIZWlnaHQgLSB0aGlzLl9jb250YWluZXJCb3R0b20pO1xyXG5cclxuXHRcdGxheWVyUG9zLl9hZGQoRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX2Nsb3NlKCk7XHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHBvcHVwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XHJcblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvciA/IHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IoKSA6IFswLCAwXSk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbi8vIEBmYWN0b3J5IEwucG9wdXAob3B0aW9ucz86IFBvcHVwIG9wdGlvbnMsIHNvdXJjZT86IExheWVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBgUG9wdXBgIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHBvcHVwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cclxuZXhwb3J0IHZhciBwb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IFBvcHVwKG9wdGlvbnMsIHNvdXJjZSk7XHJcbn07XHJcblxyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xyXG4gKiBAb3B0aW9uIGNsb3NlUG9wdXBPbkNsaWNrOiBCb29sZWFuID0gdHJ1ZVxyXG4gKiBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCBwb3B1cHMgdG8gY2xvc2Ugd2hlbiB1c2VyIGNsaWNrcyB0aGUgbWFwLlxyXG4gKi9cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAocG9wdXA6IFBvcHVwKTogdGhpc1xyXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgcG9wdXAgd2hpbGUgY2xvc2luZyB0aGUgcHJldmlvdXNseSBvcGVuZWQgKHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBpcyBvcGVuZWQgYXQgb25lIHRpbWUgZm9yIHVzYWJpbGl0eSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBvcGVuUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ3JlYXRlcyBhIHBvcHVwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVucyBpdCBpbiB0aGUgZ2l2ZW4gcG9pbnQgb24gYSBtYXAuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAocG9wdXAsIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0aWYgKCEocG9wdXAgaW5zdGFuY2VvZiBQb3B1cCkpIHtcclxuXHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMYXllclxyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcclxuICpcclxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgcG9wdXBzIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFBvcHVwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xyXG4gKiBsYXllci5vcGVuUG9wdXAoKTtcclxuICogbGF5ZXIuY2xvc2VQb3B1cCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogUG9wdXBzIHdpbGwgYWxzbyBiZSBhdXRvbWF0aWNhbGx5IG9wZW5lZCB3aGVuIHRoZSBsYXllciBpcyBjbGlja2VkIG9uIGFuZCBjbG9zZWQgd2hlbiB0aGUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgb3IgYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcbiAqL1xyXG5cclxuLy8gQHNlY3Rpb24gUG9wdXAgbWV0aG9kc1xyXG5MYXllci5pbmNsdWRlKHtcclxuXHJcblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBCaW5kcyBhIHBvcHVwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxyXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXHJcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgUG9wdXApIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XHJcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcclxuXHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBQb3B1cChvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmljZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIExheWVyKSkge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhdGxuZykge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0Ly8gc2V0IHBvcHVwIHNvdXJjZSB0byB0aGlzIGxheWVyXHJcblx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSBsYXllcjtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgcG9wdXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxyXG5cdFx0XHR0aGlzLl9wb3B1cC51cGRhdGUoKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHJcblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XHJcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoKSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL1BvcHVwLmpzIiwiXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbmV4cG9ydCB2YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWx5IHN3aXRjaCBiZXR3ZWVuIGByaWdodGAgYW5kIGBsZWZ0YCBhY2NvcmRpbmcgdG8gdGhlIHRvb2x0aXBcblx0XHQvLyBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxuXG5cdFx0Ly8gQG9wdGlvbiBwZXJtYW5lbnQ6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdG8gb3BlbiB0aGUgdG9vbHRpcCBwZXJtYW5lbnRseSBvciBvbmx5IG9uIG1vdXNlb3Zlci5cblx0XHRwZXJtYW5lbnQ6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBzdGlja3k6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgZm9sbG93IHRoZSBtb3VzZSBpbnN0ZWFkIG9mIGJlaW5nIGZpeGVkIGF0IHRoZSBmZWF0dXJlIGNlbnRlci5cblx0XHRzdGlja3k6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIGZlYXR1cmUgZXZlbnRzLlxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXG5cdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpbiB0aGUgbWFwIGlzIGNsb3NlZC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcGNsb3NlOiBUb29sdGlwRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkLlxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3Rvb2x0aXBjbG9zZScsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBEaXZPdmVybGF5LnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblxuXHRcdGlmIChCcm93c2VyLnRvdWNoICYmICF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKTtcblx0fSxcblxuXHRfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRfc2V0UG9zaXRpb246IGZ1bmN0aW9uIChwb3MpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIGNlbnRlclBvaW50ID0gbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobWFwLmdldENlbnRlcigpKSxcblx0XHQgICAgdG9vbHRpcFBvaW50ID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvcyksXG5cdFx0ICAgIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb24sXG5cdFx0ICAgIHRvb2x0aXBXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCxcblx0XHQgICAgdG9vbHRpcEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIG9mZnNldCA9IHRvUG9pbnQodGhpcy5vcHRpb25zLm9mZnNldCksXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xuXG5cdFx0aWYgKGRpcmVjdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludCgtdG9vbHRpcFdpZHRoIC8gMiArIG9mZnNldC54LCAtdG9vbHRpcEhlaWdodCArIG9mZnNldC55ICsgYW5jaG9yLnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgLSBvZmZzZXQueCwgLW9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PT0gJ2F1dG8nICYmIHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHBvcyA9IHBvcy5hZGQodG9Qb2ludChvZmZzZXQueCArIGFuY2hvci54LCBhbmNob3IueSAtIHRvb2x0aXBIZWlnaHQgLyAyICsgb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ2xlZnQnO1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoICsgYW5jaG9yLnggLSBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSAtIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fVxuXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1sZWZ0Jyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtdG9wJyk7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtJyArIGRpcmVjdGlvbik7XG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIHBvcyk7XG5cdH0sXG5cblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuZXhwb3J0IHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdGlmICghKHRvb2x0aXAgaW5zdGFuY2VvZiBUb29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMpLnNldENvbnRlbnQodG9vbHRpcCk7XG5cdFx0fVxuXG5cdFx0aWYgKGxhdGxuZykge1xuXHRcdFx0dG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5oYXNMYXllcih0b29sdGlwKSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIodG9vbHRpcCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAodG9vbHRpcD86IFRvb2x0aXApOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgdG9vbHRpcCBnaXZlbiBhcyBwYXJhbWV0ZXIuXG5cdGNsb3NlVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXApIHtcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcih0b29sdGlwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxufSk7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHMgZXhhbXBsZVxuICpcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHRvb2x0aXBzIHRvIGl0LlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLlBvbHlnb24obGF0bG5ncykuYmluZFRvb2x0aXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuVG9vbHRpcCgpO1xuICogbGF5ZXIuY2xvc2VUb29sdGlwKCk7XG4gKiBgYGBcbiAqL1xuXG4vLyBAc2VjdGlvbiBUb29sdGlwIG1ldGhvZHNcbkxheWVyLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2QgYmluZFRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFRvb2x0aXAsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIEJpbmRzIGEgdG9vbHRpcCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycy4gSWYgYSBgRnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIHJlY2VpdmVcblx0Ly8gdGhlIGxheWVyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBhbmQgc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAuXG5cdGJpbmRUb29sdGlwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG5cdFx0aWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBUb29sdGlwKSB7XG5cdFx0XHRVdGlsLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCBvcHRpb25zKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgVG9vbHRpcChvcHRpb25zLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCk7XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCAmJiB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpKSB7XG5cdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB1bmJpbmRUb29sdGlwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgdG9vbHRpcCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRUb29sdGlwYC5cblx0dW5iaW5kVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyh0cnVlKTtcblx0XHRcdHRoaXMuY2xvc2VUb29sdGlwKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0aWYgKCFyZW1vdmUgJiYgdGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nLFxuXHRcdCAgICBldmVudHMgPSB7XG5cdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VUb29sdGlwLFxuXHRcdFx0bW92ZTogdGhpcy5fbW92ZVRvb2x0aXBcblx0XHQgICAgfTtcblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5tb3VzZW92ZXIgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGV2ZW50cy5tb3VzZW91dCA9IHRoaXMuY2xvc2VUb29sdGlwO1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kpIHtcblx0XHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcblx0XHRcdFx0ZXZlbnRzLmNsaWNrID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHR9XG5cdFx0dGhpc1tvbk9mZl0oZXZlbnRzKTtcblx0XHR0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCA9ICFyZW1vdmU7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCB0b29sdGlwIGF0IHRoZSBzcGVjaWZpY2VkIGBsYXRsbmdgIG9yIGF0IHRoZSBkZWZhdWx0IHRvb2x0aXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyO1xuXHRcdFx0bGF5ZXIgPSB0aGlzO1xuXHRcdH1cblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXRsbmcpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyLmdldENlbnRlciA/IGxheWVyLmdldENlbnRlcigpIDogbGF5ZXIuZ2V0TGF0TG5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAgJiYgdGhpcy5fbWFwKSB7XG5cblx0XHRcdC8vIHNldCB0b29sdGlwIHNvdXJjZSB0byB0aGlzIGxheWVyXG5cdFx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBsYXllcjtcblxuXHRcdFx0Ly8gdXBkYXRlIHRoZSB0b29sdGlwIChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlKCk7XG5cblx0XHRcdC8vIG9wZW4gdGhlIHRvb2x0aXAgb24gdGhlIG1hcFxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Ub29sdGlwKHRoaXMuX3Rvb2x0aXAsIGxhdGxuZyk7XG5cblx0XHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG1heSBub3QgYmUgZGVmaW5lZCBpZiBub3QgcGVybWFuZW50IGFuZCBuZXZlclxuXHRcdFx0Ly8gb3BlbmVkLlxuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiB0aGlzLl90b29sdGlwLl9jb250YWluZXIpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sdGlwLl9jb250YWluZXIsICdsZWFmbGV0LWNsaWNrYWJsZScpO1xuXHRcdFx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5fY2xvc2UoKTtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX21hcCkge1xuXHRcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub3BlblRvb2x0aXAobGF5ZXIsIHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVG9vbHRpcC5qcyIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmV4cG9ydCB7aWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0Jztcbkljb24uRGVmYXVsdCA9IEljb25EZWZhdWx0O1xuZXhwb3J0IHtJY29ufTtcblxuZXhwb3J0IHtEaXZJY29uLCBkaXZJY29ufSBmcm9tICcuL0Rpdkljb24nO1xuZXhwb3J0IHtNYXJrZXIsIG1hcmtlcn0gZnJvbSAnLi9NYXJrZXInO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvaW5kZXguanMiLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LlxuXHRcdGh0bWw6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBiZ1BvczogUG9pbnQgPSBbMCwgMF1cblx0XHQvLyBPcHRpb25hbCByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dyb3VuZCwgaW4gcGl4ZWxzXG5cdFx0YmdQb3M6IG51bGwsXG5cblx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uJ1xuXHR9LFxuXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XG5cdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UgPyBvcHRpb25zLmh0bWwgOiAnJztcblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvRGl2SWNvbi5qcyIsImV4cG9ydCB7R3JpZExheWVyLCBncmlkTGF5ZXJ9IGZyb20gJy4vR3JpZExheWVyJztcbmltcG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcbmltcG9ydCB7VGlsZUxheWVyV01TLCB0aWxlTGF5ZXJXTVN9IGZyb20gJy4vVGlsZUxheWVyLldNUyc7XG5UaWxlTGF5ZXIuV01TID0gVGlsZUxheWVyV01TO1xudGlsZUxheWVyLndtcyA9IHRpbGVMYXllcldNUztcbmV4cG9ydCB7VGlsZUxheWVyLCB0aWxlTGF5ZXJ9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL2luZGV4LmpzIiwiZXhwb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5leHBvcnQge0NhbnZhcywgY2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge1NWRywgY3JlYXRlLCBwb2ludHNUb1BhdGgsIHN2Z30gZnJvbSAnLi9TVkcnO1xuU1ZHLmNyZWF0ZSA9IGNyZWF0ZTtcblNWRy5wb2ludHNUb1BhdGggPSBwb2ludHNUb1BhdGg7XG5leHBvcnQge1NWRywgc3ZnfTtcbmltcG9ydCAnLi9SZW5kZXJlci5nZXRSZW5kZXJlcic7XHQvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjaywgYnV0IG5lZWRlZCBiZWNhdXNlIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuXG5leHBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5leHBvcnQge0NpcmNsZU1hcmtlciwgY2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5leHBvcnQge0NpcmNsZSwgY2lyY2xlfSBmcm9tICcuL0NpcmNsZSc7XG5leHBvcnQge1BvbHlsaW5lLCBwb2x5bGluZX0gZnJvbSAnLi9Qb2x5bGluZSc7XG5leHBvcnQge1BvbHlnb24sIHBvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5leHBvcnQge1JlY3RhbmdsZSwgcmVjdGFuZ2xlfSBmcm9tICcuL1JlY3RhbmdsZSc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9pbmRleC5qcyIsImltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJldGFuZ2xlXG4gKiBAaW5oZXJpdHMgUG9seWdvblxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcmVjdGFuZ2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5Z29uYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWZpbmUgcmVjdGFuZ2xlIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAqIHZhciBib3VuZHMgPSBbWzU0LjU1OTMyMiwgLTUuNzY3ODIyXSwgWzU2LjEyMTA2MDQsIC0zLjAyMTI0MF1dO1xuICpcbiAqIC8vIGNyZWF0ZSBhbiBvcmFuZ2UgcmVjdGFuZ2xlXG4gKiBMLnJlY3RhbmdsZShib3VuZHMsIHtjb2xvcjogXCIjZmY3ODAwXCIsIHdlaWdodDogMX0pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSByZWN0YW5nbGUgYm91bmRzXG4gKiBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gKiBgYGBcbiAqXG4gKi9cblxuXG5leHBvcnQgdmFyIFJlY3RhbmdsZSA9IFBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdFBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRCb3VuZHMobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBwYXNzZWQgYm91bmRzLlxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRMYXRMbmdzKHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpKTtcblx0fSxcblxuXHRfYm91bmRzVG9MYXRMbmdzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0bGF0TG5nQm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0TG5nQm91bmRzKTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxuXHRcdFx0bGF0TG5nQm91bmRzLmdldFNvdXRoRWFzdCgpXG5cdFx0XTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5yZWN0YW5nbGUobGF0TG5nQm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcyIsImltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cblxuZXhwb3J0IHZhciB2bWxDcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGx2bWw6JyArIG5hbWUgKyAnIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8JyArIG5hbWUgKyAnIHhtbG5zPVwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LmNvbTp2bWxcIiBjbGFzcz1cImx2bWxcIj4nKTtcblx0XHR9O1xuXHR9XG59KSgpO1xuXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpbiB0aGlzIGNhc2UuXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gbWl4aW4gdG8gcmVkZWZpbmUgc29tZSBTVkcgbWV0aG9kcyB0byBoYW5kbGUgVk1MIHN5bnRheCB3aGljaCBpcyBzaW1pbGFyIGJ1dCB3aXRoIHNvbWUgZGlmZmVyZW5jZXNcbmV4cG9ydCB2YXIgdm1sTWl4aW4gPSB7XG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyID0gdm1sQ3JlYXRlKCdzaGFwZScpO1xuXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXZtbC1zaGFwZSAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpKTtcblxuXHRcdGNvbnRhaW5lci5jb29yZHNpemUgPSAnMSAxJztcblxuXHRcdGxheWVyLl9wYXRoID0gdm1sQ3JlYXRlKCdwYXRoJyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHREb21VdGlsLnJlbW92ZShjb250YWluZXIpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV07XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgc3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSxcblx0XHQgICAgZmlsbCA9IGxheWVyLl9maWxsLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyxcblx0XHQgICAgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gISFvcHRpb25zLnN0cm9rZTtcblx0XHRjb250YWluZXIuZmlsbGVkID0gISFvcHRpb25zLmZpbGw7XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UpIHtcblx0XHRcdGlmICghc3Ryb2tlKSB7XG5cdFx0XHRcdHN0cm9rZSA9IGxheWVyLl9zdHJva2UgPSB2bWxDcmVhdGUoJ3N0cm9rZScpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHN0cm9rZSk7XG5cdFx0XHRzdHJva2Uud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQgKyAncHgnO1xuXHRcdFx0c3Ryb2tlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IFV0aWwuaXNBcnJheShvcHRpb25zLmRhc2hBcnJheSkgP1xuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkuam9pbignICcpIDpcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN0cm9rZS5kYXNoU3R5bGUgPSAnJztcblx0XHRcdH1cblx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XG5cdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcblxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdGxheWVyLl9zdHJva2UgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGlmICghZmlsbCkge1xuXHRcdFx0XHRmaWxsID0gbGF5ZXIuX2ZpbGwgPSB2bWxDcmVhdGUoJ2ZpbGwnKTtcblx0XHRcdH1cblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxsKTtcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0ZmlsbC5vcGFjaXR5ID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKGZpbGwpO1xuXHRcdFx0bGF5ZXIuX2ZpbGwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludC5yb3VuZCgpLFxuXHRcdCAgICByID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSxcblx0XHQgICAgcjIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZIHx8IHIpO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLlZNTC5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi8uLi9tYXAvTWFwJztcbmltcG9ydCB7Q2FudmFzLCBjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7U1ZHLCBzdmd9IGZyb20gJy4vU1ZHJztcblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKCkpIHx8IHN2ZygpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IChTVkcgJiYgc3ZnKHtwYW5lOiBuYW1lfSkpIHx8IChDYW52YXMgJiYgY2FudmFzKHtwYW5lOiBuYW1lfSkpO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvUmVuZGVyZXIuZ2V0UmVuZGVyZXIuanMiLCJpbXBvcnQgeyBFbGVtZW50IGFzIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgRG9tUmVwZWF0IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5qcyc7XG5cbmltcG9ydCB7IHdtcyBhcyBXTVMgfSBmcm9tICcuL2xlYWZsZXQud21zLmpzJztcblxuaW1wb3J0ICcuL2xlYWZsZXQtd21zLWxheWVyLmpzJztcblxuXG5leHBvcnQgY2xhc3MgTGVhZmxldFdNU0dyb3VwIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIC8vIHJldHVybiBgXG4gICAgLy8gICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e3N1YkxheWVyc319XCI+XG4gICAgLy8gICAgIDxsZWFmbGV0LXdtcy1sYXllciB3bXMtc291cmNlPVwiW1t3bXNTb3VyY2VdXVwiIGxheWVyPVwiW1tpdGVtXV1cIj48L2xlYWZsZXQtd21zLWxheWVyPlxuICAgIC8vICAgPC90ZW1wbGF0ZT5cbiAgICAvLyBgO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBvYnNlcnZlcjogJ19tYXBTZXQnXG4gICAgICB9LFxuXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19zb3VyY2VDaGFuZ2UnLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsYXllcnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIG9ic2VydmVyOiAnX2xheWVyc0NoYW5nZScsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgdHJhbnNwYXJlbnQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgaWRlbnRpZnk6IEJvb2xlYW4sXG4gICAgICBpbmZvRm9ybWF0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICd0ZXh0L2h0bWwnXG4gICAgICB9LFxuICAgICAgbWluWm9vbTogTnVtYmVyLFxuICAgICAgbWF4Wm9vbTogTnVtYmVyLFxuICAgICAgYXR0cmlidXRpb246IFN0cmluZyxcbiAgICAgIFxuICAgICAgd21zU291cmNlOiBPYmplY3QsXG4gICAgICBzdWJMYXllcnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgdGhpcy5fd21zT3B0aW9ucyA9IHtcbiAgICAgIHRyYW5zcGFyZW50OiB0aGlzLnRyYW5zcGFyZW50LFxuICAgICAgZm9ybWF0OiB0aGlzLmZvcm1hdCxcbiAgICAgIGlkZW50aWZ5OiB0aGlzLmlkZW50aWZ5LFxuICAgICAgaW5mb19mb3JtYXQ6IHRoaXMuaW5mb0Zvcm1hdCxcbiAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgIGF0dHJpYnV0aW9uOiB0aGlzLmF0dHJpYnV0aW9uXG4gICAgfTtcbiAgfVxuXG4gIF9zb3VyY2VDaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMud21zU291cmNlKSB0aGlzLndtc1NvdXJjZS5yZW1vdmVGcm9tKHRoaXMubWFwKTtcblxuICAgIHRoaXMud21zU291cmNlID0gbmV3IFdNUy5Tb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMuX3dtc09wdGlvbnMpO1xuICAgIGlmICh0aGlzLm1hcCkgdGhpcy53bXNTb3VyY2UuYWRkVG8odGhpcy5tYXApO1xuICB9XG5cbiAgX2xheWVyc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICB0aGlzLndtc1NvdXJjZS5yZXBsYWNlQWxsU3ViTGF5ZXJzKHRoaXMubGF5ZXJzKTtcbiAgfVxuXG4gIF9tYXBTZXQoKSB7XG4gICAgdGhpcy53bXNTb3VyY2UuYWRkVG8odGhpcy5tYXApOyAvLyBGSVhNRTogdGhlcmUgY291bGQgYmUgYSByYWNlIGNvbmRpdGlvbiBoZXJlIGZvciB0aGlzLm1hcFxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC13bXMtZ3JvdXAnLCBMZWFmbGV0V01TR3JvdXApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0LXdtcy1ncm91cC5qcyIsIi8qIVxuICogbGVhZmxldC53bXMuanNcbiAqIEEgY29sbGVjdGlvbiBvZiBMZWFmbGV0IHV0aWxpdGllcyBmb3Igd29ya2luZyB3aXRoIFdlYiBNYXBwaW5nIHNlcnZpY2VzLlxuICogKGMpIDIwMTQtMjAxNiwgSG91c3RvbiBFbmdpbmVlcmluZywgSW5jLlxuICogTUlUIExpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCB7IEltYWdlT3ZlcmxheSB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyc7XG5pbXBvcnQgeyBUaWxlTGF5ZXJXTVMsIHRpbGVMYXllcldNUyB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyc7XG5pbXBvcnQgeyBFUFNHNDMyNiB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0c0MzI2LmpzJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvY29yZS9VdGlsLmpzJztcblxuZXhwb3J0IHZhciB3bXMgPSB7fTtcblxuLypcbiAqIHdtcy5Tb3VyY2VcbiAqIFRoZSBTb3VyY2Ugb2JqZWN0IG1hbmFnZXMgYSBzaW5nbGUgV01TIGNvbm5lY3Rpb24uICBNdWx0aXBsZSBcImxheWVyc1wiIGNhbiBiZVxuICogY3JlYXRlZCB3aXRoIHRoZSBnZXRMYXllciBmdW5jdGlvbiwgYnV0IGEgc2luZ2xlIHJlcXVlc3Qgd2lsbCBiZSBzZW50IGZvclxuICogZWFjaCBpbWFnZSB1cGRhdGUuICBDYW4gYmUgdXNlZCBpbiBub24tdGlsZWQgXCJvdmVybGF5XCIgbW9kZSAoZGVmYXVsdCksIG9yXG4gKiB0aWxlZCBtb2RlLCB2aWEgYW4gaW50ZXJuYWwgd21zLk92ZXJsYXkgb3Igd21zLlRpbGVMYXllciwgcmVzcGVjdGl2ZWx5LlxuICovXG53bXMuU291cmNlID0gTGF5ZXIuZXh0ZW5kKHtcbiAgICAnb3B0aW9ucyc6IHtcbiAgICAgICAgJ3VudGlsZWQnOiB0cnVlLFxuICAgICAgICAnaWRlbnRpZnknOiB0cnVlXG4gICAgfSxcblxuICAgICdpbml0aWFsaXplJzogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgIFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aWxlZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVudGlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuX3N1YkxheWVycyA9IHt9O1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gdGhpcy5jcmVhdGVPdmVybGF5KHRoaXMub3B0aW9ucy51bnRpbGVkKTtcbiAgICB9LFxuXG4gICAgJ2NyZWF0ZU92ZXJsYXknOiBmdW5jdGlvbih1bnRpbGVkKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvdmVybGF5IHdpdGggYWxsIG9wdGlvbnMgb3RoZXIgdGhhbiB1bnRpbGVkICYgaWRlbnRpZnlcbiAgICAgICAgdmFyIG92ZXJsYXlPcHRpb25zID0ge307XG4gICAgICAgIGZvciAodmFyIG9wdCBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHQgIT0gJ3VudGlsZWQnICYmIG9wdCAhPSAnaWRlbnRpZnknKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheU9wdGlvbnNbb3B0XSA9IHRoaXMub3B0aW9uc1tvcHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnRpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gd21zLm92ZXJsYXkodGhpcy5fdXJsLCBvdmVybGF5T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd21zLnRpbGVMYXllcih0aGlzLl91cmwsIG92ZXJsYXlPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnb25BZGQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoT3ZlcmxheSgpO1xuICAgIH0sXG5cbiAgICAnb25SZW1vdmUnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXApIHRoaXMuX292ZXJsYXkucmVtb3ZlRnJvbSh0aGlzLl9tYXApO1xuICAgIH0sXG5cbiAgICAnZ2V0RXZlbnRzJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWRlbnRpZnkpIHtcbiAgICAgICAgICAgIHJldHVybiB7J2NsaWNrJzogdGhpcy5pZGVudGlmeX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3NldE9wYWNpdHknOiBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICBpZiAodGhpcy5fb3ZlcmxheSkge1xuICAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgICdicmluZ1RvQmFjayc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgdGhpcy5vcHRpb25zLmlzQmFjayA9IHRydWU7XG4gICAgICAgICBpZiAodGhpcy5fb3ZlcmxheSkge1xuICAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuYnJpbmdUb0JhY2soKTtcbiAgICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2JyaW5nVG9Gcm9udCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgdGhpcy5vcHRpb25zLmlzQmFjayA9IGZhbHNlO1xuICAgICAgICAgaWYgKHRoaXMuX292ZXJsYXkpIHtcbiAgICAgICAgICAgICB0aGlzLl9vdmVybGF5LmJyaW5nVG9Gcm9udCgpO1xuICAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0TGF5ZXInOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB3bXMubGF5ZXIodGhpcywgbmFtZSk7XG4gICAgfSxcblxuICAgICdnZXRTdWJMYXllcnMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJMYXllcnM7XG4gICAgfSxcblxuICAgICdhZGRTdWJMYXllcic6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fc3ViTGF5ZXJzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWZyZXNoT3ZlcmxheSgpO1xuICAgIH0sXG5cbiAgICAncmVtb3ZlU3ViTGF5ZXInOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJMYXllcnNbbmFtZV07XG4gICAgICAgIHRoaXMucmVmcmVzaE92ZXJsYXkoKTtcbiAgICB9LFxuXG4gICAgLyogRWZmaWNpZW50IHdheSB0byBzd2FwIG91dCBhbGwgc3ViIGxheWVycyAqL1xuICAgICdyZXBsYWNlQWxsU3ViTGF5ZXJzJzogZnVuY3Rpb24gKG5ld1N1YkxheWVycykge1xuICAgICAgICB0aGlzLl9zdWJMYXllcnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTdWJMYXllcnMubGVuZ3RoOyBpKyspIHRoaXMuX3N1YkxheWVyc1tuZXdTdWJMYXllcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWZyZXNoT3ZlcmxheSgpO1xuICAgIH0sXG5cbiAgICAncmVmcmVzaE92ZXJsYXknOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN1YkxheWVycyA9IE9iamVjdC5rZXlzKHRoaXMuX3N1YkxheWVycykuam9pbihcIixcIik7XG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWJMYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXkucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5LnNldFBhcmFtcyh7J2xheWVycyc6IHN1YkxheWVyc30pO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5hZGRUbyh0aGlzLl9tYXApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdpZGVudGlmeSc6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAvLyBJZGVudGlmeSBtYXAgZmVhdHVyZXMgaW4gcmVzcG9uc2UgdG8gbWFwIGNsaWNrcy4gVG8gY3VzdG9taXplIHRoaXNcbiAgICAgICAgLy8gYmVoYXZpb3IsIGNyZWF0ZSBhIGNsYXNzIGV4dGVuZGluZyB3bXMuU291cmNlIGFuZCBvdmVycmlkZSBvbmUgb3JcbiAgICAgICAgLy8gbW9yZSBvZiB0aGUgZm9sbG93aW5nIGhvb2sgZnVuY3Rpb25zLlxuXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmdldElkZW50aWZ5TGF5ZXJzKCk7XG4gICAgICAgIGlmICghbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0RmVhdHVyZUluZm8oXG4gICAgICAgICAgICBldnQuY29udGFpbmVyUG9pbnQsIGV2dC5sYXRsbmcsIGxheWVycyxcbiAgICAgICAgICAgIHRoaXMuc2hvd0ZlYXR1cmVJbmZvXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgICdnZXRGZWF0dXJlSW5mbyc6IGZ1bmN0aW9uKHBvaW50LCBsYXRsbmcsIGxheWVycywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gUmVxdWVzdCBXTVMgR2V0RmVhdHVyZUluZm8gYW5kIGNhbGwgY2FsbGJhY2sgd2l0aCByZXN1bHRzXG4gICAgICAgIC8vIChzcGxpdCBmcm9tIGlkZW50aWZ5KCkgdG8gZmFjaWxpYXRlIHVzZSBvdXRzaWRlIG9mIG1hcCBldmVudHMpXG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLmdldEZlYXR1cmVJbmZvUGFyYW1zKHBvaW50LCBsYXllcnMpLFxuICAgICAgICAgICAgdXJsID0gdGhpcy5fdXJsICsgVXRpbC5nZXRQYXJhbVN0cmluZyhwYXJhbXMsIHRoaXMuX3VybCk7XG5cbiAgICAgICAgdGhpcy5zaG93V2FpdGluZygpO1xuICAgICAgICB0aGlzLmFqYXgodXJsLCBkb25lKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlV2FpdGluZygpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnBhcnNlRmVhdHVyZUluZm8ocmVzdWx0LCB1cmwpO1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBsYXRsbmcsIHRleHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdhamF4JzogZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgICAgICB3bXMuYWpheC5jYWxsKHRoaXMsIHVybCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAnZ2V0SWRlbnRpZnlMYXllcnMnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSG9vayB0byBkZXRlcm1pbmUgd2hpY2ggbGF5ZXJzIHRvIGlkZW50aWZ5XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWRlbnRpZnlMYXllcnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlkZW50aWZ5TGF5ZXJzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3ViTGF5ZXJzKTtcbiAgICAgfSxcblxuICAgICdnZXRGZWF0dXJlSW5mb1BhcmFtcyc6IGZ1bmN0aW9uKHBvaW50LCBsYXllcnMpIHtcbiAgICAgICAgLy8gSG9vayB0byBnZW5lcmF0ZSBwYXJhbWV0ZXJzIGZvciBXTVMgc2VydmljZSBHZXRGZWF0dXJlSW5mbyByZXF1ZXN0XG4gICAgICAgIHZhciB3bXNQYXJhbXMsIG92ZXJsYXk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudW50aWxlZCkge1xuICAgICAgICAgICAgLy8gVXNlIGV4aXN0aW5nIG92ZXJsYXlcbiAgICAgICAgICAgIHdtc1BhcmFtcyA9IHRoaXMuX292ZXJsYXkud21zUGFyYW1zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG92ZXJsYXkgaW5zdGFuY2UgdG8gbGV2ZXJhZ2UgdXBkYXRlV21zUGFyYW1zXG4gICAgICAgICAgICBvdmVybGF5ID0gdGhpcy5jcmVhdGVPdmVybGF5KHRydWUpO1xuICAgICAgICAgICAgb3ZlcmxheS51cGRhdGVXbXNQYXJhbXModGhpcy5fbWFwKTtcbiAgICAgICAgICAgIHdtc1BhcmFtcyA9IG92ZXJsYXkud21zUGFyYW1zO1xuICAgICAgICAgICAgd21zUGFyYW1zLmxheWVycyA9IGxheWVycy5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZm9QYXJhbXMgPSB7XG4gICAgICAgICAgICAncmVxdWVzdCc6ICdHZXRGZWF0dXJlSW5mbycsXG4gICAgICAgICAgICAncXVlcnlfbGF5ZXJzJzogbGF5ZXJzLmpvaW4oJywnKSxcbiAgICAgICAgICAgICdYJzogTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICAgICAgICAgICdZJzogTWF0aC5yb3VuZChwb2ludC55KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVXRpbC5leHRlbmQoe30sIHdtc1BhcmFtcywgaW5mb1BhcmFtcyk7XG4gICAgfSxcblxuICAgICdwYXJzZUZlYXR1cmVJbmZvJzogZnVuY3Rpb24ocmVzdWx0LCB1cmwpIHtcbiAgICAgICAgLy8gSG9vayB0byBoYW5kbGUgcGFyc2luZyBBSkFYIHJlc3BvbnNlXG4gICAgICAgIGlmIChyZXN1bHQgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAvLyBBSkFYIGZhaWxlZCwgcG9zc2libHkgZHVlIHRvIENPUlMgaXNzdWVzLlxuICAgICAgICAgICAgLy8gVHJ5IGxvYWRpbmcgY29udGVudCBpbiA8aWZyYW1lPi5cbiAgICAgICAgICAgIHJlc3VsdCA9IFwiPGlmcmFtZSBzcmM9J1wiICsgdXJsICsgXCInIHN0eWxlPSdib3JkZXI6bm9uZSc+XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgJ3Nob3dGZWF0dXJlSW5mbyc6IGZ1bmN0aW9uKGxhdGxuZywgaW5mbykge1xuICAgICAgICAvLyBIb29rIHRvIGhhbmRsZSBkaXNwbGF5aW5nIHBhcnNlZCBBSkFYIHJlc3BvbnNlIHRvIHRoZSB1c2VyXG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLm9wZW5Qb3B1cChpbmZvLCBsYXRsbmcpO1xuICAgIH0sXG5cbiAgICAnc2hvd1dhaXRpbmcnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSG9vayB0byBjdXN0b21pemUgQUpBWCB3YWl0IGFuaW1hdGlvblxuICAgICAgICBpZiAoIXRoaXMuX21hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gXCJwcm9ncmVzc1wiO1xuICAgIH0sXG5cbiAgICAnaGlkZVdhaXRpbmcnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSG9vayB0byByZW1vdmUgQUpBWCB3YWl0IGFuaW1hdGlvblxuICAgICAgICBpZiAoIXRoaXMuX21hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgfVxufSk7XG5cbndtcy5zb3VyY2UgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHdtcy5Tb3VyY2UodXJsLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gKiBMYXllclxuICogTGVhZmxldCBcImxheWVyXCIgd2l0aCBhbGwgYWN0dWFsIHJlbmRlcmluZyBoYW5kbGVkIHZpYSBhbiB1bmRlcmx5aW5nIFNvdXJjZVxuICogb2JqZWN0LiAgQ2FuIGJlIGNhbGxlZCBkaXJlY3RseSB3aXRoIGEgVVJMIHRvIGF1dG9tYXRpY2FsbHkgY3JlYXRlIG9yIHJldXNlXG4gKiBhbiBleGlzdGluZyBTb3VyY2UuICBOb3RlIHRoYXQgdGhlIGF1dG8tc291cmNlIGZlYXR1cmUgZG9lc24ndCB3b3JrIHdlbGwgaW5cbiAqIG11bHRpLW1hcCBlbnZpcm9ubWVudHM7IHNvIGZvciBiZXN0IHJlc3VsdHMsIGNyZWF0ZSBhIFNvdXJjZSBmaXJzdCBhbmQgdXNlXG4gKiBnZXRMYXllcigpIHRvIHJldHJpZXZlIHdtcy5MYXllciBpbnN0YW5jZXMuXG4gKi9cblxud21zLkxheWVyID0gTGF5ZXIuZXh0ZW5kKHtcbiAgICAnaW5pdGlhbGl6ZSc6IGZ1bmN0aW9uKHNvdXJjZSwgbGF5ZXJOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFzb3VyY2UuYWRkU3ViTGF5ZXIpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBzb3VyY2UgaXMgYSBVUkxcbiAgICAgICAgICAgIHNvdXJjZSA9IHdtcy5nZXRTb3VyY2VGb3JVcmwoc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuX25hbWUgPSBsYXllck5hbWU7XG4gICAgfSxcbiAgICAnb25BZGQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2UuX21hcClcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5hZGRUbyh0aGlzLl9tYXApO1xuICAgICAgICB0aGlzLl9zb3VyY2UuYWRkU3ViTGF5ZXIodGhpcy5fbmFtZSk7XG4gICAgfSxcbiAgICAnb25SZW1vdmUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc291cmNlLnJlbW92ZVN1YkxheWVyKHRoaXMuX25hbWUpO1xuICAgIH0sXG4gICAgJ3NldE9wYWNpdHknOiBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH0sXG4gICAgJ2JyaW5nVG9CYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5icmluZ1RvQmFjaygpO1xuICAgIH0sXG4gICAgJ2JyaW5nVG9Gcm9udCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zb3VyY2UuYnJpbmdUb0Zyb250KCk7XG4gICAgfVxufSk7XG5cbndtcy5sYXllciA9IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgd21zLkxheWVyKHNvdXJjZSwgb3B0aW9ucyk7XG59O1xuXG4vLyBDYWNoZSBvZiBzb3VyY2VzIGZvciB1c2Ugd2l0aCB3bXMuTGF5ZXIgYXV0by1zb3VyY2Ugb3B0aW9uXG53bXMuc291cmNlcyA9IHt9O1xud21zLmdldFNvdXJjZUZvclVybCA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgIGlmICghd21zLnNvdXJjZXNbdXJsXSkge1xuICAgICAgICB3bXMuc291cmNlc1t1cmxdID0gd21zLnNvdXJjZSh1cmwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gd21zLnNvdXJjZXNbdXJsXTtcbn07XG5cblxuLy8gQ29weSB0aWxlZCBXTVMgbGF5ZXIgZnJvbSBsZWFmbGV0IGNvcmUsIGluIGNhc2Ugd2UgbmVlZCB0byBzdWJjbGFzcyBpdCBsYXRlclxud21zLlRpbGVMYXllciA9IFRpbGVMYXllcldNUztcbndtcy50aWxlTGF5ZXIgPSB0aWxlTGF5ZXJXTVM7XG5cbi8qXG4gKiB3bXMuT3ZlcmxheTpcbiAqIFwiU2luZ2xlIFRpbGVcIiBXTVMgaW1hZ2Ugb3ZlcmxheSB0aGF0IHVwZGF0ZXMgd2l0aCBtYXAgY2hhbmdlcy5cbiAqIFBvcnRpb25zIG9mIHdtcy5PdmVybGF5IGFyZSBkaXJlY3RseSBleHRyYWN0ZWQgZnJvbSBMLlRpbGVMYXllci5XTVMuXG4gKiBTZWUgTGVhZmxldCBsaWNlbnNlLlxuICovXG53bXMuT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XG4gICAgJ2RlZmF1bHRXbXNQYXJhbXMnOiB7XG4gICAgICAgICdzZXJ2aWNlJzogJ1dNUycsXG4gICAgICAgICdyZXF1ZXN0JzogJ0dldE1hcCcsXG4gICAgICAgICd2ZXJzaW9uJzogJzEuMS4xJyxcbiAgICAgICAgJ2xheWVycyc6ICcnLFxuICAgICAgICAnc3R5bGVzJzogJycsXG4gICAgICAgICdmb3JtYXQnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICd0cmFuc3BhcmVudCc6IGZhbHNlXG4gICAgfSxcblxuICAgICdvcHRpb25zJzoge1xuICAgICAgICAnY3JzJzogbnVsbCxcbiAgICAgICAgJ3VwcGVyY2FzZSc6IGZhbHNlLFxuICAgICAgICAnYXR0cmlidXRpb24nOiAnJyxcbiAgICAgICAgJ29wYWNpdHknOiAxLFxuICAgICAgICAnaXNCYWNrJzogZmFsc2UsXG4gICAgICAgICdtaW5ab29tJzogMCxcbiAgICAgICAgJ21heFpvb20nOiAxOFxuICAgIH0sXG5cbiAgICAnaW5pdGlhbGl6ZSc6IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG5cbiAgICAgICAgLy8gTW92ZSBXTVMgcGFyYW1ldGVycyB0byBwYXJhbXMgb2JqZWN0XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fSwgb3B0cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgIGlmIChvcHQgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgIG9wdHNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICBwYXJhbXNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLndtc1BhcmFtcyA9IFV0aWwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgICdzZXRQYXJhbXMnOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgVXRpbC5leHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgICdnZXRBdHRyaWJ1dGlvbic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuICAgIH0sXG5cbiAgICAnb25BZGQnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgJ29uUmVtb3ZlJzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50T3ZlcmxheSkge1xuICAgICAgICAgICAgbWFwLnJlbW92ZUxheWVyKHRoaXMuX2N1cnJlbnRPdmVybGF5KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50T3ZlcmxheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFVybCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2N1cnJlbnRVcmw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2dldEV2ZW50cyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ21vdmVlbmQnOiB0aGlzLnVwZGF0ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAndXBkYXRlJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGltYWdlIFVSTCBhbmQgd2hldGhlciBpdCBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IHVwZGF0ZVxuICAgICAgICB0aGlzLnVwZGF0ZVdtc1BhcmFtcygpO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy5nZXRJbWFnZVVybCgpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFVybCA9PSB1cmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50VXJsID0gdXJsO1xuXG4gICAgICAgIC8vIEtlZXAgY3VycmVudCBpbWFnZSBvdmVybGF5IGluIHBsYWNlIHVudGlsIG5ldyBvbmUgbG9hZHNcbiAgICAgICAgLy8gKGluc3BpcmVkIGJ5IGVzcmkubGVhZmxldClcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCB7J29wYWNpdHknOiAwfSk7XG4gICAgICAgIG92ZXJsYXkuYWRkVG8odGhpcy5fbWFwKTtcbiAgICAgICAgb3ZlcmxheS5vbmNlKCdsb2FkJywgX3N3YXAsIHRoaXMpO1xuICAgICAgICBmdW5jdGlvbiBfc3dhcCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG92ZXJsYXkuX3VybCAhPSB0aGlzLl9jdXJyZW50VXJsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3VycmVudE92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY3VycmVudE92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICAgICAgb3ZlcmxheS5zZXRPcGFjaXR5KFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID8gdGhpcy5vcHRpb25zLm9wYWNpdHkgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0JhY2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5LmJyaW5nVG9CYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzQmFjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5LmJyaW5nVG9Gcm9udCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fbWFwLmdldFpvb20oKSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB8fFxuICAgICAgICAgICAgKHRoaXMuX21hcC5nZXRab29tKCkgPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkpe1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKG92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdzZXRPcGFjaXR5JzogZnVuY3Rpb24ob3BhY2l0eSkge1xuICAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRPdmVybGF5KSB7XG4gICAgICAgICAgICAgdGhpcy5fY3VycmVudE92ZXJsYXkuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2JyaW5nVG9CYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pc0JhY2sgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudE92ZXJsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPdmVybGF5LmJyaW5nVG9CYWNrKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2JyaW5nVG9Gcm9udCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaXNCYWNrID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50T3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudE92ZXJsYXkuYnJpbmdUb0Zyb250KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2VlIEwuVGlsZUxheWVyLldNUzogb25BZGQoKSAmIGdldFRpbGVVcmwoKVxuICAgICd1cGRhdGVXbXNQYXJhbXMnOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIFdNUyBvcHRpb25zXG4gICAgICAgIHZhciBib3VuZHMgPSBtYXAuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHZhciBzaXplID0gbWFwLmdldFNpemUoKTtcbiAgICAgICAgdmFyIHdtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xuICAgICAgICB2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycyB8fCBtYXAub3B0aW9ucy5jcnM7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uS2V5ID0gd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xuICAgICAgICB2YXIgbncgPSBjcnMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xuICAgICAgICB2YXIgc2UgPSBjcnMucHJvamVjdChib3VuZHMuZ2V0U291dGhFYXN0KCkpO1xuXG4gICAgICAgIC8vIEFzc2VtYmxlIFdNUyBwYXJhbWV0ZXIgc3RyaW5nXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAnd2lkdGgnOiBzaXplLngsXG4gICAgICAgICAgICAnaGVpZ2h0Jzogc2l6ZS55XG4gICAgICAgIH07XG4gICAgICAgIHBhcmFtc1twcm9qZWN0aW9uS2V5XSA9IGNycy5jb2RlO1xuICAgICAgICBwYXJhbXMuYmJveCA9IChcbiAgICAgICAgICAgIHdtc1ZlcnNpb24gPj0gMS4zICYmIGNycy5jb2RlID09PSBFUFNHNDMyNi5jb2RlID9cbiAgICAgICAgICAgIFtzZS55LCBudy54LCBudy55LCBzZS54XSA6XG4gICAgICAgICAgICBbbncueCwgc2UueSwgc2UueCwgbncueV1cbiAgICAgICAgKS5qb2luKCcsJyk7XG5cbiAgICAgICAgVXRpbC5leHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgICdnZXRJbWFnZVVybCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBwZXJjYXNlID0gdGhpcy5vcHRpb25zLnVwcGVyY2FzZSB8fCBmYWxzZTtcbiAgICAgICAgdmFyIHBzdHIgPSBVdGlsLmdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB0aGlzLl91cmwsIHVwcGVyY2FzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmwgKyBwc3RyO1xuICAgIH1cbn0pO1xuXG53bXMub3ZlcmxheSA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgd21zLk92ZXJsYXkodXJsLCBvcHRpb25zKTtcbn07XG5cbi8vIFNpbXBsZSBBSkFYIGhlbHBlciAoc2luY2Ugd2UgY2FuJ3QgYXNzdW1lIGpRdWVyeSBldGMuIGFyZSBwcmVzZW50KVxud21zLmFqYXggPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gY2hhbmdlO1xuICAgIHJlcXVlc3Qub3BlbignR0VUJywgdXJsKTtcbiAgICByZXF1ZXN0LnNlbmQoKTtcblxuICAgIGZ1bmN0aW9uIGNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvdmFyL3d3dy9sb2NhbGhvc3QvaHRkb2NzL0BnZ2NpdHkvbGVhZmxldC13bXMvbGVhZmxldC53bXMuanMiLCJpbXBvcnQgeyBFbGVtZW50IGFzIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuXG5leHBvcnQgY2xhc3MgTGVhZmxldFdNU0xheWVyIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdtc1NvdXJjZTogT2JqZWN0LFxuICAgICAgbGF5ZXI6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBcbiAgICBpZiAodGhpcy53bXNTb3VyY2UgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmxheWVyID09PSAnJykgcmV0dXJuO1xuICAgIHRoaXMud21zU291cmNlLmFkZFN1YkxheWVyKHRoaXMubGF5ZXIpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC13bXMtbGF5ZXInLCBMZWFmbGV0V01TTGF5ZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC92YXIvd3d3L2xvY2FsaG9zdC9odGRvY3MvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0LXdtcy1sYXllci5qcyIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5cbmltcG9ydCB7IFRpbGVMYXllciB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzJztcbmltcG9ydCB7IFRpbGVMYXllcldNUyB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBMZWFmbGV0VGlsZUxheWVyIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiAnX21hcFNldCdcbiAgICAgIH0sXG4gICAgICBiYXNlOiBCb29sZWFuLFxuICAgICAgdXJsOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IFwiLy97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmdcIixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfdXJsQ2hhbmdlZCcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAnX2Zvcm1hdENoYW5nZWQnLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsYXllcnM6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19sYXllcnNDaGFuZ2VkJ1xuICAgICAgfSxcbiAgICAgIG1pblpvb206IE51bWJlcixcbiAgICAgIG1heFpvb206IE51bWJlcixcbiAgICAgIGF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuXG4gIF91cmxDaGFuZ2VkICgpIHtcbiAgICBjb25zb2xlLmxvZygndXJsIGNoYW5nZWQnLCB0aGlzLnVybCk7XG4gICAgaWYgKHRoaXMubGVhZmxldExheWVyKSB0aGlzLmxlYWZsZXRMYXllci5zZXRVcmwodGhpcy51cmwpO1xuICB9XG5cbiAgX2xheWVyc0NoYW5nZWQgKCkge1xuICAgIGNvbnNvbGUubG9nKCdsYXllcnMgY2hhbmdlZCcsIHRoaXMubGF5ZXJzKTtcbiAgICBpZiAodGhpcy5sZWFmbGV0TGF5ZXIgJiYgdGhpcy5sZWFmbGV0TGF5ZXIgaW5zdGFuY2VvZiBUaWxlTGF5ZXJXTVMpIHRoaXMubGVhZmxldExheWVyLnNldFBhcmFtcyh7IGxheWVyczogdGhpcy5sYXllcnMgfSk7XG4gIH1cblxuICBfZm9ybWF0Q2hhbmdlZCAoKSB7XG4gICAgY29uc29sZS5sb2coJ2Zvcm1hdCBjaGFuZ2VkJywgdGhpcy5mb3JtYXQpO1xuXG4gICAgaWYgKHRoaXMubGVhZmxldExheWVyICYmIHRoaXMubWFwKSB7XG4gICAgICB0aGlzLmxlYWZsZXRMYXllci5yZW1vdmVGcm9tKHRoaXMubWFwKTtcbiAgICB9XG5cbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgIGF0dHJpYnV0aW9uOiB0aGlzLmF0dHJpYnV0aW9uXG4gICAgfTtcblxuICAgIHN3aXRjaCAodGhpcy5mb3JtYXQpIHtcbiAgICAgIGNhc2UgJ1hZWic6XG4gICAgICAgIHRoaXMubGVhZmxldExheWVyID0gbmV3IFRpbGVMYXllcih0aGlzLnVybCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnV01TJzpcbiAgICAgICAgdGhpcy5sZWFmbGV0TGF5ZXIgPSBuZXcgVGlsZUxheWVyV01TKHRoaXMudXJsLCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICBsYXllcnM6IHRoaXMubGF5ZXJzLFxuICAgICAgICAgIGZvcm1hdDogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgIGhpbnRzOiAncXVhbGl0eSdcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgbGVhZmxldC10aWxlLWxheWVyIGZvcm1hdDogJywgdGhpcy5mb3JtYXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFwKSB0aGlzLmxlYWZsZXRMYXllci5hZGRUbyh0aGlzLm1hcCk7XG4gICAgZWxzZSBjb25zb2xlLmxvZygnbWFwIG5vdCB5ZXQgc2V0Jyk7XG4gIH1cblxuICBfbWFwU2V0KCkge1xuICAgIGNvbnNvbGUubG9nKCdtYXAgc2V0Jyk7XG4gICAgaWYgKHRoaXMubGVhZmxldExheWVyICYmICF0aGlzLm1hcC5oYXNMYXllcih0aGlzLmxlYWZsZXRMYXllcikpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdubyBsYXllciB5ZXQsIGFkZGluZycpO1xuICAgICAgdGhpcy5sZWFmbGV0TGF5ZXIuYWRkVG8odGhpcy5tYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnbGF5ZXIgb2JqZWN0IG5vdCBzZXQgLyBsYXllciBleGlzdHMsIHNraXBwaW5nJyk7XG4gICAgfVxuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC10aWxlLWxheWVyJywgTGVhZmxldFRpbGVMYXllcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0BnZ2NpdHkvbGVhZmxldC10aWxlLWxheWVyL2xlYWZsZXQtdGlsZS1sYXllci5qcyIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBEb21SZXBlYXQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzJztcblxuaW1wb3J0IHsgQ2lyY2xlTWFya2VyIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyc7XG5pbXBvcnQgeyBHZW9KU09OIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvR2VvSlNPTi5qcyc7XG5pbXBvcnQgJy4uLy4uL2xlYWZsZXQvc3JjL0xlYWZsZXQuanMnO1xuaW1wb3J0IHsgTWFya2VyQ2x1c3Rlckdyb3VwIH0gZnJvbSAnLi4vLi4vbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy8nO1xuXG4vLyBEZXYgb25seVxuLy8gaW1wb3J0IHsgTGVhZmxldE1hcCB9IGZyb20gJy4uLy4uL0BnZ2NpdHkvbGVhZmxldC1tYXAvbGVhZmxldC1tYXAuanMnO1xuXG5leHBvcnQgY2xhc3MgTGVhZmxldEdlb0pTT04gZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiAnX21hcFNldCdcbiAgICAgIH0sXG5cbiAgICAgIHNvdXJjZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAnX3NvdXJjZUNoYW5nZScsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgZmlsbENvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICcjRkY4MEFCJ1xuICAgICAgfSxcblxuICAgICAgb3V0bGluZUNvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICcjRkYxNzQ0J1xuICAgICAgfSxcblxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDEwXG4gICAgICB9LFxuXG4gICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogM1xuICAgICAgfSxcblxuICAgICAgb3BhY2l0eToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAxLjBcbiAgICAgIH0sXG5cbiAgICAgIGZpbGxPcGFjaXR5OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgfSxcblxuICAgICAgY2x1c3RlcjogQm9vbGVhbixcbiAgICAgIG1heENsdXN0ZXJSYWRpdXM6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogODBcbiAgICAgIH0sXG4gICAgICBpZGVudGlmeTogQm9vbGVhbixcbiAgICAgIG1pblpvb206IE51bWJlcixcbiAgICAgIG1heFpvb206IE51bWJlcixcbiAgICAgIGF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHRoaXMuX2NsdXN0ZXJHcm91cCA9IG5ldyBNYXJrZXJDbHVzdGVyR3JvdXAoe1xuICAgICAgc2hvd0NvdmVyYWdlT25Ib3ZlcjogZmFsc2UsXG4gICAgICBtYXhDbHVzdGVyUmFkaXVzOiB0aGlzLm1heENsdXN0ZXJSYWRpdXNcbiAgICB9KTtcblxuICAgIHRoaXMuX2NpcmNsZU1ha2VyT3B0aW9ucyA9IHtcbiAgICAgIGNvbG9yOiB0aGlzLm91dGxpbmVDb2xvcixcbiAgICAgIGZpbGxDb2xvcjogdGhpcy5maWxsQ29sb3IsXG4gICAgICByYWRpdXM6IHRoaXMucmFkaXVzLFxuICAgICAgd2VpZ2h0OiB0aGlzLndlaWdodCxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLmZpbGxPcGFjaXR5XG4gICAgfTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdGhpcy5tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY2x1c3Rlckdyb3VwKTtcbiAgICB0aGlzLl9jbHVzdGVyR3JvdXAuY2xlYXJMYXllcnMoKTtcbiAgfVxuXG4gIF9hZGRHZW9KU09OTGF5ZXIoZ2VvanNvbikge1xuICAgIHRoaXMuX2NsdXN0ZXJHcm91cC5jbGVhckxheWVycygpO1xuXG4gICAgdGhpcy5fZ2VvSlNPTk9wdGlvbnMgPSB7XG4gICAgICBwb2ludFRvTGF5ZXI6ICh0aGlzLmNsdXN0ZXIpID8gdGhpcy5fY2x1c3RlclBvaW50cy5iaW5kKHRoaXMpIDogdGhpcy5fc2ltcGxlUG9pbnRzLmJpbmQodGhpcyksXG4gICAgICBhdHRyaWJ1dGlvbjogdGhpcy5hdHRyaWJ1dGlvblxuICAgIH07XG4gICAgdGhpcy5fZ2VvSlNPTkxheWVyID0gbmV3IEdlb0pTT04oZ2VvanNvbiwgdGhpcy5fZ2VvSlNPTk9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMuY2x1c3Rlcikge1xuICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIodGhpcy5fY2x1c3Rlckdyb3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIodGhpcy5fZ2VvSlNPTkxheWVyKTtcbiAgICB9XG4gIH1cblxuICBfY2x1c3RlclBvaW50cyhmZWF0dXJlLCBsYXRsbmcpIHtcbiAgICBsZXQgbWFya2VyID0gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIHRoaXMuX2NpcmNsZU1ha2VyT3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuaWRlbnRpZnkpIG1hcmtlci5iaW5kUG9wdXAodGhpcy5fZ2VuZXJhdGVQb3B1cENvbnRlbnQoZmVhdHVyZSkpO1xuXG4gICAgdGhpcy5fY2x1c3Rlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG4gIH1cblxuICBfc2ltcGxlUG9pbnRzKGZlYXR1cmUsIGxhdGxuZykge1xuICAgIGxldCBtYXJrZXIgPSBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgdGhpcy5fY2lyY2xlTWFrZXJPcHRpb25zKTtcbiAgICBpZiAodGhpcy5pZGVudGlmeSkgbWFya2VyLmJpbmRQb3B1cCh0aGlzLl9nZW5lcmF0ZVBvcHVwQ29udGVudChmZWF0dXJlKSk7XG5cbiAgICByZXR1cm4gbWFya2VyO1xuICB9XG5cbiAgX29uRWFjaEZlYXR1cmUoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICBjb25zb2xlLmxvZygnYmluZGluZycpO1xuICAgIGlmICh0aGlzLmlkZW50aWZ5KSB7XG4gICAgICBsYXllci5iaW5kUG9wdXAodGhpcy5fZ2VuZXJhdGVQb3B1cENvbnRlbnQoZmVhdHVyZSkpO1xuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVBvcHVwQ29udGVudCAoZmVhdHVyZSkge1xuICAgIGxldCByb3dzID0gJyc7XG4gICAgZm9yIChsZXQgcCBpbiBmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgIGxldCBmaWVsZE5hbWUgPSBwLnJlcGxhY2UoL1xcd1xcUyovZywgZnVuY3Rpb24odHh0KXsgcmV0dXJuIHR4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJyAnKTsgfSlcbiAgICAgIHJvd3MgKz0gYDx0cj48dGQ+JHtmaWVsZE5hbWV9OjwvdGQ+PHRkPjxzdHJvbmc+JHtmZWF0dXJlLnByb3BlcnRpZXNbcF19PC9zdHJvbmc+PC90ZD48L3RyPmA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGA8dGFibGU+JHtyb3dzfTwvdGFibGU+YDtcbiAgfVxuXG4gIF9zb3VyY2VDaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMubWFwICYmIHRoaXMuX2dlb0pTT05MYXllcikgdGhpcy5fZ2VvSlNPTkxheWVyLnJlbW92ZUZyb20odGhpcy5tYXApO1xuXG4gICAgZmV0Y2godGhpcy5zb3VyY2UpXG4gICAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgIC50aGVuKHRoaXMuX2FkZEdlb0pTT05MYXllci5iaW5kKHRoaXMpKTtcbiAgICAvLyAuY2F0Y2goKCkgPT4gYWxlcnQoJ1VuYWJsZSB0byBsb2FkIGxheWVyJykpO1xuICB9XG5cbiAgX21hcFNldCgpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnYWRkaW5nIGxheWVyJyk7XG4gICAgLy8gdGhpcy5tYXAuYWRkTGF5ZXIodGhpcy5fZ2VvSlNPTkxheWVyKTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xlYWZsZXQtZ2VvanNvbi1wb2ludHMnLCBMZWFmbGV0R2VvSlNPTik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL3Zhci93d3cvbG9jYWxob3N0L2h0ZG9jcy9AZ2djaXR5L2xlYWZsZXQtZ2VvanNvbi9sZWFmbGV0LWdlb2pzb24tcG9pbnRzLmpzIiwiXHJcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcclxuZXhwb3J0IHt2ZXJzaW9ufTtcclxuXHJcbi8vIGNvbnRyb2xcclxuZXhwb3J0ICogZnJvbSAnLi9jb250cm9sL2luZGV4JztcclxuXHJcbi8vIGNvcmVcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2luZGV4JztcclxuXHJcbi8vIGRvbVxyXG5leHBvcnQgKiBmcm9tICcuL2RvbS9pbmRleCc7XHJcblxyXG4vLyBnZW9tZXRyeVxyXG5leHBvcnQgKiBmcm9tICcuL2dlb21ldHJ5L2luZGV4JztcclxuXHJcbi8vIGdlb1xyXG5leHBvcnQgKiBmcm9tICcuL2dlby9pbmRleCc7XHJcblxyXG4vLyBsYXllclxyXG5leHBvcnQgKiBmcm9tICcuL2xheWVyL2luZGV4JztcclxuXHJcbi8vIG1hcFxyXG5leHBvcnQgKiBmcm9tICcuL21hcC9pbmRleCc7XHJcblxyXG4vLyBtaXNjXHJcblxyXG52YXIgb2xkTCA9IHdpbmRvdy5MO1xyXG5leHBvcnQgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcclxuXHR3aW5kb3cuTCA9IG9sZEw7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEFsd2F5cyBleHBvcnQgdXMgdG8gd2luZG93IGdsb2JhbCAoc2VlICMyMzY0KVxyXG53aW5kb3cuTCA9IGV4cG9ydHM7XHJcblxyXG5pbXBvcnQge2ZyZWV6ZX0gZnJvbSAnLi9jb3JlL1V0aWwnO1xyXG5PYmplY3QuZnJlZXplID0gZnJlZXplO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL0xlYWZsZXQuanMiLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4vQnJvd3Nlcic7XG5leHBvcnQge0Jyb3dzZXJ9O1xuXG5leHBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuL0V2ZW50cyc7XG5pbXBvcnQge0V2ZW50c30gZnJvbSAnLi9FdmVudHMnO1xuZXhwb3J0IHtFdmVudGVkfTtcbmV4cG9ydCB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG5leHBvcnQge0hhbmRsZXJ9IGZyb20gJy4vSGFuZGxlcic7XG5cbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcbmV4cG9ydCB7VXRpbH07XG5leHBvcnQge2V4dGVuZCwgYmluZCwgc3RhbXAsIHNldE9wdGlvbnN9IGZyb20gJy4vVXRpbCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvaW5kZXguanMiLCJleHBvcnQge1Bvc0FuaW1hdGlvbn0gZnJvbSAnLi9Qb3NBbmltYXRpb24nO1xuXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcbmV4cG9ydCB7RG9tRXZlbnR9O1xuXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4vRG9tVXRpbCc7XG5leHBvcnQge0RvbVV0aWx9O1xuXG5leHBvcnQge0RyYWdnYWJsZX0gZnJvbSAnLi9EcmFnZ2FibGUnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vaW5kZXguanMiLCJleHBvcnQge1BvaW50LCB0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuL1BvaW50JztcbmV4cG9ydCB7Qm91bmRzLCB0b0JvdW5kcyBhcyBib3VuZHN9IGZyb20gJy4vQm91bmRzJztcbmV4cG9ydCB7VHJhbnNmb3JtYXRpb24sIHRvVHJhbnNmb3JtYXRpb24gYXMgdHJhbnNmb3JtYXRpb259IGZyb20gJy4vVHJhbnNmb3JtYXRpb24nO1xuXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuL0xpbmVVdGlsJztcbmV4cG9ydCB7TGluZVV0aWx9O1xuaW1wb3J0ICogYXMgUG9seVV0aWwgZnJvbSAnLi9Qb2x5VXRpbCc7XG5leHBvcnQge1BvbHlVdGlsfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvaW5kZXguanMiLCJleHBvcnQge0xhdExuZywgdG9MYXRMbmcgYXMgbGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XG5leHBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuL0xhdExuZ0JvdW5kcyc7XG5cbmltcG9ydCAqIGFzIFByb2plY3Rpb24gZnJvbSAnLi9wcm9qZWN0aW9uL2luZGV4JztcbmV4cG9ydCB7UHJvamVjdGlvbn07XG5cbmV4cG9ydCAqIGZyb20gJy4vY3JzL2luZGV4JztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2luZGV4LmpzIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcbmltcG9ydCB7RVBTRzMzOTV9IGZyb20gJy4vQ1JTLkVQU0czMzk1JztcbmltcG9ydCB7RVBTRzM4NTcsIEVQU0c5MDA5MTN9IGZyb20gJy4vQ1JTLkVQU0czODU3JztcbmltcG9ydCB7RVBTRzQzMjZ9IGZyb20gJy4vQ1JTLkVQU0c0MzI2JztcbmltcG9ydCB7U2ltcGxlfSBmcm9tICcuL0NSUy5TaW1wbGUnO1xuXG5DUlMuRWFydGggPSBFYXJ0aDtcbkNSUy5FUFNHMzM5NSA9IEVQU0czMzk1O1xuQ1JTLkVQU0czODU3ID0gRVBTRzM4NTc7XG5DUlMuRVBTRzkwMDkxMyA9IEVQU0c5MDA5MTM7XG5DUlMuRVBTRzQzMjYgPSBFUFNHNDMyNjtcbkNSUy5TaW1wbGUgPSBTaW1wbGU7XG5cbmV4cG9ydCB7Q1JTfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9pbmRleC5qcyIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzMzOTUuanMiLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAbmFtZXNwYWNlIENSU1xuICogQGNycyBMLkNSUy5TaW1wbGVcbiAqXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBtYXBzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW50byBgeGAgYW5kIGB5YCBkaXJlY3RseS5cbiAqIE1heSBiZSB1c2VkIGZvciBtYXBzIG9mIGZsYXQgc3VyZmFjZXMgKGUuZy4gZ2FtZSBtYXBzKS4gTm90ZSB0aGF0IHRoZSBgeWBcbiAqIGF4aXMgc2hvdWxkIHN0aWxsIGJlIGludmVydGVkIChnb2luZyBmcm9tIGJvdHRvbSB0byB0b3ApLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogc2ltcGxlIGV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAqL1xuXG5leHBvcnQgdmFyIFNpbXBsZSA9IFV0aWwuZXh0ZW5kKHt9LCBDUlMsIHtcblx0cHJvamVjdGlvbjogTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxLCAwLCAtMSwgMCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0cmV0dXJuIE1hdGgucG93KDIsIHpvb20pO1xuXHR9LFxuXG5cdHpvb206IGZ1bmN0aW9uIChzY2FsZSkge1xuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSkgLyBNYXRoLkxOMjtcblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgZHggPSBsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nLFxuXHRcdCAgICBkeSA9IGxhdGxuZzIubGF0IC0gbGF0bG5nMS5sYXQ7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0fSxcblxuXHRpbmZpbml0ZTogdHJ1ZVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcyIsIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBfcHJvamVjdGlvbikuXG5cbiAqIEBwcm9wZXJ0eSBib3VuZHM6IEJvdW5kc1xuICogVGhlIGJvdW5kcyAoc3BlY2lmaWVkIGluIENSUyB1bml0cykgd2hlcmUgdGhlIHByb2plY3Rpb24gaXMgdmFsaWRcblxuICogQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcbiAqIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGEgMkQgcG9pbnQuXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKiBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcbiAqIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC4gUHJvamVjdHMgYSAyRCBwb2ludCBpbnRvIGEgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5Qb2ludGAgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxuXG4gKi9cblxuZXhwb3J0IHtMb25MYXR9IGZyb20gJy4vUHJvamVjdGlvbi5Mb25MYXQnO1xuZXhwb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcbmV4cG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJuYW1lXCI6XCJsZWFmbGV0XCIsXCJ2ZXJzaW9uXCI6XCIxLjIuMFwiLFwiZGVzY3JpcHRpb25cIjpcIkphdmFTY3JpcHQgbGlicmFyeSBmb3IgbW9iaWxlLWZyaWVuZGx5IGludGVyYWN0aXZlIG1hcHNcIixcImRldkRlcGVuZGVuY2llc1wiOntcImVzbGludFwiOlwiXjMuNS4wIDwzLjYuMFwiLFwiZXNsaW50LWNvbmZpZy1tb3VybmVyXCI6XCJeMi4wLjFcIixcImdpdC1yZXYtc3luY1wiOlwiXjEuOC4wXCIsXCJoYXBwZW5cIjpcIn4wLjMuMVwiLFwiamFrZVwiOlwifjguMC4xMlwiLFwia2FybWFcIjpcIl4xLjMuMFwiLFwia2FybWEtY2hyb21lLWxhdW5jaGVyXCI6XCJeMi4wLjBcIixcImthcm1hLWNvdmVyYWdlXCI6XCJ+MS4xLjFcIixcImthcm1hLWZpcmVmb3gtbGF1bmNoZXJcIjpcIn4xLjAuMFwiLFwia2FybWEtbW9jaGFcIjpcIl4xLjIuMFwiLFwia2FybWEtcGhhbnRvbWpzLWxhdW5jaGVyXCI6XCJeMS4wLjJcIixcImthcm1hLXJvbGx1cC1wcmVwcm9jZXNzb3JcIjpcIl40LjAuMlwiLFwia2FybWEtc2FmYXJpLWxhdW5jaGVyXCI6XCJ+MS4wLjBcIixcImxlYWZkb2NcIjpcIl4xLjQuMVwiLFwibW9jaGFcIjpcIl4zLjUuMFwiLFwicGhhbnRvbWpzLXByZWJ1aWx0XCI6XCJeMi4xLjEyXCIsXCJwcm9zdGhldGljLWhhbmRcIjpcIl4xLjMuMVwiLFwicm9sbHVwXCI6XCJeMC40NS4yXCIsXCJyb2xsdXAtcGx1Z2luLWdpdC12ZXJzaW9uXCI6XCIwLjIuMVwiLFwicm9sbHVwLXBsdWdpbi1qc29uXCI6XCJeMi4xLjBcIixcInJvbGx1cC13YXRjaFwiOlwiXjQuMy4xXCIsXCJzb3VyY2UtbWFwXCI6XCJeMC41LjZcIixcInNzcmlcIjpcIl40LjEuMlwiLFwidWdsaWZ5LWpzXCI6XCJ+My4wLjI2XCJ9LFwibWFpblwiOlwiZGlzdC9sZWFmbGV0LXNyYy5qc1wiLFwic3R5bGVcIjpcImRpc3QvbGVhZmxldC5jc3NcIixcImZpbGVzXCI6W1wiZGlzdFwiLFwic3JjXCIsXCIhZGlzdC9sZWFmbGV0LnppcFwiXSxcInNjcmlwdHNcIjp7XCJ0ZXN0LWpha2VcIjpcImpha2UgdGVzdFwiLFwidGVzdFwiOlwiamFrZSB0ZXN0XCIsXCJidWlsZC1qYWtlXCI6XCJqYWtlIGJ1aWxkXCIsXCJidWlsZFwiOlwibnBtIHJ1biByb2xsdXAgJiYgbnBtIHJ1biB1Z2xpZnlcIixcInJlbGVhc2VcIjpcIi4vYnVpbGQvcHVibGlzaC5zaFwiLFwibGludFwiOlwiZXNsaW50IHNyYzsgZXNsaW50IHNwZWMvc3VpdGVzXCIsXCJsaW50Zml4XCI6XCJlc2xpbnQgc3JjIC0tZml4OyBlc2xpbnQgc3BlYy9zdWl0ZXMgLS1maXg7IFwiLFwicm9sbHVwXCI6XCJyb2xsdXAgLWMgYnVpbGQvcm9sbHVwLWNvbmZpZy5qc1wiLFwid2F0Y2hcIjpcInJvbGx1cCAtdyAtYyBidWlsZC9yb2xsdXAtd2F0Y2gtY29uZmlnLmpzXCIsXCJ1Z2xpZnlcIjpcInVnbGlmeWpzIGRpc3QvbGVhZmxldC1zcmMuanMgLWMgLW0gLW8gZGlzdC9sZWFmbGV0LmpzIC0tc291cmNlLW1hcCBmaWxlbmFtZT1kaXN0L2xlYWZsZXQuanMubWFwIC0taW4tc291cmNlLW1hcCBkaXN0L2xlYWZsZXQtc3JjLmpzLm1hcCAtLXNvdXJjZS1tYXAtdXJsIGxlYWZsZXQuanMubWFwIC0tY29tbWVudHNcIixcImludGVncml0eVwiOlwibm9kZWpzIC4vYnVpbGQvaW50ZWdyaXR5LmpzXCJ9LFwiZXNsaW50Q29uZmlnXCI6e1wicm9vdFwiOnRydWUsXCJnbG9iYWxzXCI6e1wiTFwiOnRydWV9LFwiZW52XCI6e1wiY29tbW9uanNcIjp0cnVlLFwiYW1kXCI6dHJ1ZSxcIm5vZGVcIjpmYWxzZX0sXCJleHRlbmRzXCI6XCJtb3VybmVyXCIsXCJwYXJzZXJPcHRpb25zXCI6e1wiZWNtYVZlcnNpb25cIjo2LFwic291cmNlVHlwZVwiOlwibW9kdWxlXCJ9LFwicnVsZXNcIjp7XCJsaW5lYnJlYWstc3R5bGVcIjpbMCxcInVuaXhcIl0sXCJuby1taXhlZC1zcGFjZXMtYW5kLXRhYnNcIjpbMixcInNtYXJ0LXRhYnNcIl0sXCJpbmRlbnRcIjpbMixcInRhYlwiLHtcIlZhcmlhYmxlRGVjbGFyYXRvclwiOjB9XSxcImN1cmx5XCI6MixcInNwYWNlZC1jb21tZW50XCI6MixcInN0cmljdFwiOjAsXCJ3cmFwLWlpZmVcIjowLFwia2V5LXNwYWNpbmdcIjowLFwiY29uc2lzdGVudC1yZXR1cm5cIjowfX0sXCJyZXBvc2l0b3J5XCI6e1widHlwZVwiOlwiZ2l0XCIsXCJ1cmxcIjpcImdpdDovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0LmdpdFwifSxcImtleXdvcmRzXCI6W1wiZ2lzXCIsXCJtYXBcIl0sXCJsaWNlbnNlXCI6XCJCU0QtMi1DbGF1c2VcIn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuZXhwb3J0IHsgTWFya2VyQ2x1c3Rlckdyb3VwIH0gZnJvbSAnLi9NYXJrZXJDbHVzdGVyR3JvdXAuanMnO1xyXG5leHBvcnQgeyBNYXJrZXJDbHVzdGVyIH0gZnJvbSAnLi9NYXJrZXJDbHVzdGVyLmpzJztcclxuaW1wb3J0IHt9IGZyb20gJy4vTWFya2VyT3BhY2l0eS5qcyc7XHJcbmltcG9ydCB7fSBmcm9tICcuL0Rpc3RhbmNlR3JpZC5qcyc7XHJcbmltcG9ydCB7fSBmcm9tICcuL01hcmtlckNsdXN0ZXIuUXVpY2tIdWxsLmpzJztcclxuaW1wb3J0IHt9IGZyb20gJy4vTWFya2VyQ2x1c3Rlci5TcGlkZXJmaWVyLmpzJztcclxuaW1wb3J0IHt9IGZyb20gJy4vTWFya2VyQ2x1c3Rlckdyb3VwLlJlZnJlc2guanMnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvaW5kZXguanMiLCIvKlxyXG4gKiBMLk1hcmtlckNsdXN0ZXJHcm91cCBleHRlbmRzIEwuRmVhdHVyZUdyb3VwIGJ5IGNsdXN0ZXJpbmcgdGhlIG1hcmtlcnMgY29udGFpbmVkIHdpdGhpblxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyQ2x1c3Rlckdyb3VwID0gTC5NYXJrZXJDbHVzdGVyR3JvdXAgPSBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRtYXhDbHVzdGVyUmFkaXVzOiA4MCwgLy9BIGNsdXN0ZXIgd2lsbCBjb3ZlciBhdCBtb3N0IHRoaXMgbWFueSBwaXhlbHMgZnJvbSBpdHMgY2VudGVyXHJcblx0XHRpY29uQ3JlYXRlRnVuY3Rpb246IG51bGwsXHJcblx0XHRjbHVzdGVyUGFuZTogTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMucGFuZSxcclxuXHJcblx0XHRzcGlkZXJmeU9uTWF4Wm9vbTogdHJ1ZSxcclxuXHRcdHNob3dDb3ZlcmFnZU9uSG92ZXI6IHRydWUsXHJcblx0XHR6b29tVG9Cb3VuZHNPbkNsaWNrOiB0cnVlLFxyXG5cdFx0c2luZ2xlTWFya2VyTW9kZTogZmFsc2UsXHJcblxyXG5cdFx0ZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb206IG51bGwsXHJcblxyXG5cdFx0Ly8gU2V0dGluZyB0aGlzIHRvIGZhbHNlIHByZXZlbnRzIHRoZSByZW1vdmFsIG9mIGFueSBjbHVzdGVycyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9pbnQsIHdoaWNoXHJcblx0XHQvLyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXHJcblx0XHRyZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kczogdHJ1ZSxcclxuXHJcblx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhbGwgYW5pbWF0aW9ucyAoem9vbSBhbmQgc3BpZGVyZnkpLlxyXG5cdFx0Ly8gSWYgZmFsc2UsIG9wdGlvbiBhbmltYXRlQWRkaW5nTWFya2VycyBiZWxvdyBoYXMgbm8gZWZmZWN0LlxyXG5cdFx0Ly8gSWYgTC5Eb21VdGlsLlRSQU5TSVRJT04gaXMgZmFsc3ksIHRoaXMgb3B0aW9uIGhhcyBubyBlZmZlY3QuXHJcblx0XHRhbmltYXRlOiB0cnVlLFxyXG5cclxuXHRcdC8vV2hldGhlciB0byBhbmltYXRlIGFkZGluZyBtYXJrZXJzIGFmdGVyIGFkZGluZyB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwIHRvIHRoZSBtYXBcclxuXHRcdC8vIElmIHlvdSBhcmUgYWRkaW5nIGluZGl2aWR1YWwgbWFya2VycyBzZXQgdG8gdHJ1ZSwgaWYgYWRkaW5nIGJ1bGsgbWFya2VycyBsZWF2ZSBmYWxzZSBmb3IgbWFzc2l2ZSBwZXJmb3JtYW5jZSBnYWlucy5cclxuXHRcdGFuaW1hdGVBZGRpbmdNYXJrZXJzOiBmYWxzZSxcclxuXHJcblx0XHQvL0luY3JlYXNlIHRvIGluY3JlYXNlIHRoZSBkaXN0YW5jZSBhd2F5IHRoYXQgc3BpZGVyZmllZCBtYXJrZXJzIGFwcGVhciBmcm9tIHRoZSBjZW50ZXJcclxuXHRcdHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyOiAxLFxyXG5cclxuXHRcdC8vIE1ha2UgaXQgcG9zc2libGUgdG8gc3BlY2lmeSBhIHBvbHlsaW5lIG9wdGlvbnMgb24gYSBzcGlkZXIgbGVnXHJcblx0XHRzcGlkZXJMZWdQb2x5bGluZU9wdGlvbnM6IHsgd2VpZ2h0OiAxLjUsIGNvbG9yOiAnIzIyMicsIG9wYWNpdHk6IDAuNSB9LFxyXG5cclxuXHRcdC8vIFdoZW4gYnVsayBhZGRpbmcgbGF5ZXJzLCBhZGRzIG1hcmtlcnMgaW4gY2h1bmtzLiBNZWFucyBhZGRMYXllcnMgbWF5IG5vdCBhZGQgYWxsIHRoZSBsYXllcnMgaW4gdGhlIGNhbGwsIG90aGVycyB3aWxsIGJlIGxvYWRlZCBkdXJpbmcgc2V0VGltZW91dHNcclxuXHRcdGNodW5rZWRMb2FkaW5nOiBmYWxzZSxcclxuXHRcdGNodW5rSW50ZXJ2YWw6IDIwMCwgLy8gcHJvY2VzcyBtYXJrZXJzIGZvciBhIG1heGltdW0gb2YgfiBuIG1pbGxpc2Vjb25kcyAodGhlbiB0cmlnZ2VyIHRoZSBjaHVua1Byb2dyZXNzIGNhbGxiYWNrKVxyXG5cdFx0Y2h1bmtEZWxheTogNTAsIC8vIGF0IHRoZSBlbmQgb2YgZWFjaCBpbnRlcnZhbCwgZ2l2ZSBuIG1pbGxpc2Vjb25kcyBiYWNrIHRvIHN5c3RlbS9icm93c2VyXHJcblx0XHRjaHVua1Byb2dyZXNzOiBudWxsLCAvLyBwcm9ncmVzcyBjYWxsYmFjazogZnVuY3Rpb24ocHJvY2Vzc2VkLCB0b3RhbCwgZWxhcHNlZCkgKGUuZy4gZm9yIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yKVxyXG5cclxuXHRcdC8vT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBMLlBvbHlnb24gY29uc3RydWN0b3JcclxuXHRcdHBvbHlnb25PcHRpb25zOiB7fVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmljb25DcmVhdGVGdW5jdGlvbikge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uID0gdGhpcy5fZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAgPSBMLmZlYXR1cmVHcm91cCgpO1xyXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAgPSBMLmZlYXR1cmVHcm91cCgpO1xyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pblpvb21BbmltYXRpb24gPSAwO1xyXG5cdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XHJcblx0XHR0aGlzLl9uZWVkc1JlbW92aW5nID0gW107IC8vTWFya2VycyByZW1vdmVkIHdoaWxlIHdlIGFyZW4ndCBvbiB0aGUgbWFwIG5lZWQgdG8gYmUga2VwdCB0cmFjayBvZlxyXG5cdFx0Ly9UaGUgYm91bmRzIG9mIHRoZSBjdXJyZW50bHkgc2hvd24gYXJlYSAoZnJvbSBfZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKSBVcGRhdGVkIG9uIHpvb20vbW92ZVxyXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLl9xdWV1ZSA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycyA9IHtcclxuXHRcdFx0J2RyYWdzdGFydCc6IHRoaXMuX2NoaWxkTWFya2VyRHJhZ1N0YXJ0LFxyXG5cdFx0XHQnbW92ZSc6IHRoaXMuX2NoaWxkTWFya2VyTW92ZWQsXHJcblx0XHRcdCdkcmFnZW5kJzogdGhpcy5fY2hpbGRNYXJrZXJEcmFnRW5kLFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBIb29rIHRoZSBhcHByb3ByaWF0ZSBhbmltYXRpb24gbWV0aG9kcy5cclxuXHRcdHZhciBhbmltYXRlID0gTC5Eb21VdGlsLlRSQU5TSVRJT04gJiYgdGhpcy5vcHRpb25zLmFuaW1hdGU7XHJcblx0XHRMLmV4dGVuZCh0aGlzLCBhbmltYXRlID8gdGhpcy5fd2l0aEFuaW1hdGlvbiA6IHRoaXMuX25vQW5pbWF0aW9uKTtcclxuXHRcdC8vIFJlbWVtYmVyIHdoaWNoIE1hcmtlckNsdXN0ZXIgY2xhc3MgdG8gaW5zdGFudGlhdGUgKGFuaW1hdGVkIG9yIG5vdCkuXHJcblx0XHR0aGlzLl9tYXJrZXJDbHVzdGVyID0gYW5pbWF0ZSA/IEwuTWFya2VyQ2x1c3RlciA6IEwuTWFya2VyQ2x1c3Rlck5vbkFuaW1hdGVkO1xyXG5cdH0sXHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXJzKFtsYXllcl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vRG9uJ3QgY2x1c3RlciBub24gcG9pbnQgZGF0YVxyXG5cdFx0aWYgKCFsYXllci5nZXRMYXRMbmcpIHtcclxuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRMYXllcihsYXllcik7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbGF5ZXIgfSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly9JZiB3ZSBoYXZlIGFscmVhZHkgY2x1c3RlcmVkIHdlJ2xsIG5lZWQgdG8gYWRkIHRoaXMgb25lIHRvIGEgY2x1c3RlclxyXG5cclxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgdGhpcy5fbWF4Wm9vbSk7XHJcblx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbGF5ZXIgfSk7XHJcblxyXG5cdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdC8vV29yayBvdXQgd2hhdCBpcyB2aXNpYmxlXHJcblx0XHR2YXIgdmlzaWJsZUxheWVyID0gbGF5ZXIsXHJcblx0XHQgICAgY3VycmVudFpvb20gPSB0aGlzLl96b29tO1xyXG5cdFx0aWYgKGxheWVyLl9fcGFyZW50KSB7XHJcblx0XHRcdHdoaWxlICh2aXNpYmxlTGF5ZXIuX19wYXJlbnQuX3pvb20gPj0gY3VycmVudFpvb20pIHtcclxuXHRcdFx0XHR2aXNpYmxlTGF5ZXIgPSB2aXNpYmxlTGF5ZXIuX19wYXJlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fY3VycmVudFNob3duQm91bmRzLmNvbnRhaW5zKHZpc2libGVMYXllci5nZXRMYXRMbmcoKSkpIHtcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5hbmltYXRlQWRkaW5nTWFya2Vycykge1xyXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyKGxheWVyLCB2aXNpYmxlTGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQobGF5ZXIsIHZpc2libGVMYXllcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlTGF5ZXJzKFtsYXllcl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vTm9uIHBvaW50IGxheWVyc1xyXG5cdFx0aWYgKCFsYXllci5nZXRMYXRMbmcpIHtcclxuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5yZW1vdmVMYXllcihsYXllcik7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9hcnJheVNwbGljZSh0aGlzLl9uZWVkc0NsdXN0ZXJpbmcsIGxheWVyKSAmJiB0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcucHVzaCh7IGxheWVyOiBsYXllciwgbGF0bG5nOiBsYXllci5fbGF0bG5nIH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFsYXllci5fX3BhcmVudCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xyXG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XHJcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnlMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIGNsdXN0ZXJzXHJcblx0XHR0aGlzLl9yZW1vdmVMYXllcihsYXllciwgdHJ1ZSk7XHJcblx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbGF5ZXIgfSk7XHJcblxyXG5cdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdGxheWVyLm9mZih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9mZWF0dXJlR3JvdXAuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihsYXllcik7XHJcblx0XHRcdGlmIChsYXllci5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdGxheWVyLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIGFkZHMgdGhlbSBpbiBidWxrXHJcblx0YWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzQXJyYXksIHNraXBMYXllckFkZEV2ZW50KSB7XHJcblx0XHRpZiAoIUwuVXRpbC5pc0FycmF5KGxheWVyc0FycmF5KSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcnNBcnJheSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0ICAgIG5wZyA9IHRoaXMuX25vblBvaW50R3JvdXAsXHJcblx0XHQgICAgY2h1bmtlZCA9IHRoaXMub3B0aW9ucy5jaHVua2VkTG9hZGluZyxcclxuXHRcdCAgICBjaHVua0ludGVydmFsID0gdGhpcy5vcHRpb25zLmNodW5rSW50ZXJ2YWwsXHJcblx0XHQgICAgY2h1bmtQcm9ncmVzcyA9IHRoaXMub3B0aW9ucy5jaHVua1Byb2dyZXNzLFxyXG5cdFx0ICAgIGwgPSBsYXllcnNBcnJheS5sZW5ndGgsXHJcblx0XHQgICAgb2Zmc2V0ID0gMCxcclxuXHRcdCAgICBvcmlnaW5hbEFycmF5ID0gdHJ1ZSxcclxuXHRcdCAgICBtO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHN0YXJ0ZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHR2YXIgcHJvY2VzcyA9IEwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuXHRcdFx0XHRmb3IgKDsgb2Zmc2V0IDwgbDsgb2Zmc2V0KyspIHtcclxuXHRcdFx0XHRcdGlmIChjaHVua2VkICYmIG9mZnNldCAlIDIwMCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHQvLyBldmVyeSBjb3VwbGUgaHVuZHJlZCBtYXJrZXJzLCBpbnN0cnVtZW50IHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgcHJvY2Vzc2luZyBzdGFydGVkOlxyXG5cdFx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydDtcclxuXHRcdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBjaHVua0ludGVydmFsKSB7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7IC8vIGJlZW4gd29ya2luZyB0b28gaGFyZCwgdGltZSB0byB0YWtlIGEgYnJlYWsgOi0pXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbb2Zmc2V0XTtcclxuXHJcblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0XHRcdC8vIFNpZGUgZWZmZWN0czpcclxuXHRcdFx0XHRcdC8vIC0gVG90YWwgaW5jcmVhc2VzLCBzbyBjaHVua1Byb2dyZXNzIHJhdGlvIGp1bXBzIGJhY2t3YXJkLlxyXG5cdFx0XHRcdFx0Ly8gLSBHcm91cHMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGdyb3VwLCBvbmx5IHRoZWlyIG5vbi1ncm91cCBjaGlsZCBsYXllcnMgKGhhc0xheWVyKS5cclxuXHRcdFx0XHRcdC8vIENoYW5naW5nIGFycmF5IGxlbmd0aCB3aGlsZSBsb29waW5nIGRvZXMgbm90IGFmZmVjdCBwZXJmb3JtYW5jZSBpbiBjdXJyZW50IGJyb3dzZXJzOlxyXG5cdFx0XHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vZm9yLWxvb3AtY2hhbmdpbmctbGVuZ3RoLzZcclxuXHRcdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHRcdGlmIChvcmlnaW5hbEFycmF5KSB7XHJcblx0XHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcclxuXHRcdFx0XHRcdGlmICghbS5nZXRMYXRMbmcpIHtcclxuXHRcdFx0XHRcdFx0bnBnLmFkZExheWVyKG0pO1xyXG5cdFx0XHRcdFx0XHRpZiAoIXNraXBMYXllckFkZEV2ZW50KSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fYWRkTGF5ZXIobSwgdGhpcy5fbWF4Wm9vbSk7XHJcblx0XHRcdFx0XHRpZiAoIXNraXBMYXllckFkZEV2ZW50KSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBtIH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vSWYgd2UganVzdCBtYWRlIGEgY2x1c3RlciBvZiBzaXplIDIgdGhlbiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgb3RoZXIgbWFya2VyIGZyb20gdGhlIG1hcCAoaWYgaXQgaXMpIG9yIHdlIG5ldmVyIHdpbGxcclxuXHRcdFx0XHRcdGlmIChtLl9fcGFyZW50KSB7XHJcblx0XHRcdFx0XHRcdGlmIChtLl9fcGFyZW50LmdldENoaWxkQ291bnQoKSA9PT0gMikge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJzID0gbS5fX3BhcmVudC5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0XHRcdFx0XHQgICAgb3RoZXJNYXJrZXIgPSBtYXJrZXJzWzBdID09PSBtID8gbWFya2Vyc1sxXSA6IG1hcmtlcnNbMF07XHJcblx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIob3RoZXJNYXJrZXIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY2h1bmtQcm9ncmVzcykge1xyXG5cdFx0XHRcdFx0Ly8gcmVwb3J0IHByb2dyZXNzIGFuZCB0aW1lIGVsYXBzZWQ6XHJcblx0XHRcdFx0XHRjaHVua1Byb2dyZXNzKG9mZnNldCwgbCwgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0ZWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gQ29tcGxldGVkIHByb2Nlc3NpbmcgYWxsIG1hcmtlcnMuXHJcblx0XHRcdFx0aWYgKG9mZnNldCA9PT0gbCkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXHJcblx0XHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCB0aGlzLl96b29tLCB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KHByb2Nlc3MsIHRoaXMub3B0aW9ucy5jaHVua0RlbGF5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdFx0cHJvY2VzcygpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIG5lZWRzQ2x1c3RlcmluZyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcclxuXHJcblx0XHRcdGZvciAoOyBvZmZzZXQgPCBsOyBvZmZzZXQrKykge1xyXG5cdFx0XHRcdG0gPSBsYXllcnNBcnJheVtvZmZzZXRdO1xyXG5cclxuXHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9Ob3QgcG9pbnQgZGF0YSwgY2FuJ3QgYmUgY2x1c3RlcmVkXHJcblx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xyXG5cdFx0XHRcdFx0bnBnLmFkZExheWVyKG0pO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5oYXNMYXllcihtKSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRuZWVkc0NsdXN0ZXJpbmcucHVzaChtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCByZW1vdmVzIHRoZW0gaW4gYnVsa1xyXG5cdHJlbW92ZUxheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5KSB7XHJcblx0XHR2YXIgaSwgbSxcclxuXHRcdCAgICBsID0gbGF5ZXJzQXJyYXkubGVuZ3RoLFxyXG5cdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0ICAgIG5wZyA9IHRoaXMuX25vblBvaW50R3JvdXAsXHJcblx0XHQgICAgb3JpZ2luYWxBcnJheSA9IHRydWU7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRcdG0gPSBsYXllcnNBcnJheVtpXTtcclxuXHJcblx0XHRcdFx0Ly8gR3JvdXAgb2YgbGF5ZXJzLCBhcHBlbmQgY2hpbGRyZW4gdG8gbGF5ZXJzQXJyYXkgYW5kIHNraXAuXHJcblx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRcdGlmIChvcmlnaW5hbEFycmF5KSB7XHJcblx0XHRcdFx0XHRcdGxheWVyc0FycmF5ID0gbGF5ZXJzQXJyYXkuc2xpY2UoKTtcclxuXHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5KTtcclxuXHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbSk7XHJcblx0XHRcdFx0bnBnLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nLnB1c2goeyBsYXllcjogbSwgbGF0bG5nOiBtLl9sYXRsbmcgfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcclxuXHJcblx0XHRcdC8vIFdvcmsgb24gYSBjb3B5IG9mIHRoZSBhcnJheSwgc28gdGhhdCBuZXh0IGxvb3AgaXMgbm90IGFmZmVjdGVkLlxyXG5cdFx0XHR2YXIgbGF5ZXJzQXJyYXkyID0gbGF5ZXJzQXJyYXkuc2xpY2UoKSxcclxuXHRcdFx0ICAgIGwyID0gbDtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGwyOyBpKyspIHtcclxuXHRcdFx0XHRtID0gbGF5ZXJzQXJyYXkyW2ldO1xyXG5cclxuXHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5Mik7XHJcblx0XHRcdFx0XHRsMiA9IGxheWVyc0FycmF5Mi5sZW5ndGg7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnlMYXllcihtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0bSA9IGxheWVyc0FycmF5W2ldO1xyXG5cclxuXHRcdFx0Ly8gR3JvdXAgb2YgbGF5ZXJzLCBhcHBlbmQgY2hpbGRyZW4gdG8gbGF5ZXJzQXJyYXkgYW5kIHNraXAuXHJcblx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdGxheWVyc0FycmF5ID0gbGF5ZXJzQXJyYXkuc2xpY2UoKTtcclxuXHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5KTtcclxuXHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW0uX19wYXJlbnQpIHtcclxuXHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKG0sIHRydWUsIHRydWUpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbSB9KTtcclxuXHJcblx0XHRcdGlmIChmZy5oYXNMYXllcihtKSkge1xyXG5cdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdC8vRml4IHVwIHRoZSBjbHVzdGVycyBhbmQgbWFya2VycyBvbiB0aGUgbWFwXHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCB0aGlzLl96b29tLCB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vUmVtb3ZlcyBhbGwgbGF5ZXJzIGZyb20gdGhlIE1hcmtlckNsdXN0ZXJHcm91cFxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvL05lZWQgb3VyIG93biBzcGVjaWFsIGltcGxlbWVudGF0aW9uIGFzIHRoZSBMYXllckdyb3VwIG9uZSBkb2Vzbid0IHdvcmsgZm9yIHVzXHJcblxyXG5cdFx0Ly9JZiB3ZSBhcmVuJ3Qgb24gdGhlIG1hcCAoeWV0KSwgYmxvdyBhd2F5IHRoZSBtYXJrZXJzIHdlIGtub3cgb2ZcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZ3JpZENsdXN0ZXJzO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZ3JpZFVuY2x1c3RlcmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9SZW1vdmUgYWxsIHRoZSB2aXNpYmxlIGxheWVyc1xyXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmNsZWFyTGF5ZXJzKCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmNsZWFyTGF5ZXJzKCk7XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKG1hcmtlcikge1xyXG5cdFx0XHRtYXJrZXIub2ZmKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XHJcblx0XHRcdGRlbGV0ZSBtYXJrZXIuX19wYXJlbnQ7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdC8vUmVzZXQgX3RvcENsdXN0ZXJMZXZlbCBhbmQgdGhlIERpc3RhbmNlR3JpZHNcclxuXHRcdFx0dGhpcy5fZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlIEZlYXR1cmVHcm91cC5nZXRCb3VuZHMgYXMgaXQgZG9lc24ndCB3b3JrXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCkge1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fbmVlZHNDbHVzdGVyaW5nW2ldLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHJcblx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX25vblBvaW50R3JvdXAuZ2V0Qm91bmRzKCkpO1xyXG5cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5lYWNoTGF5ZXJcclxuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuXHRcdHZhciBtYXJrZXJzID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nLnNsaWNlKCksXHJcblx0XHRcdG5lZWRzUmVtb3ZpbmcgPSB0aGlzLl9uZWVkc1JlbW92aW5nLFxyXG5cdFx0XHR0aGlzTmVlZHNSZW1vdmluZywgaSwgajtcclxuXHJcblx0XHRpZiAodGhpcy5fdG9wQ2x1c3RlckxldmVsKSB7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5nZXRBbGxDaGlsZE1hcmtlcnMobWFya2Vycyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0XHRmb3IgKGogPSBuZWVkc1JlbW92aW5nLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcblx0XHRcdFx0aWYgKG5lZWRzUmVtb3Zpbmdbal0ubGF5ZXIgPT09IG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0XHRcdHRoaXNOZWVkc1JlbW92aW5nID0gZmFsc2U7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzTmVlZHNSZW1vdmluZykge1xyXG5cdFx0XHRcdG1ldGhvZC5jYWxsKGNvbnRleHQsIG1hcmtlcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5lYWNoTGF5ZXIobWV0aG9kLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyc1xyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcclxuXHRcdFx0bGF5ZXJzLnB1c2gobCk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5nZXRMYXllciwgV0FSTklORzogUmVhbGx5IGJhZCBwZXJmb3JtYW5jZVxyXG5cdGdldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciByZXN1bHQgPSBudWxsO1xyXG5cclxuXHRcdGlkID0gcGFyc2VJbnQoaWQsIDEwKTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobCkge1xyXG5cdFx0XHRpZiAoTC5zdGFtcChsKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXN1bHQgPSBsO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0sXHJcblxyXG5cdC8vUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBsYXllciBpcyBpbiB0aGlzIE1hcmtlckNsdXN0ZXJHcm91cFxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpLCBhbkFycmF5ID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xyXG5cclxuXHRcdGZvciAoaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKGFuQXJyYXlbaV0gPT09IGxheWVyKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRhbkFycmF5ID0gdGhpcy5fbmVlZHNSZW1vdmluZztcclxuXHRcdGZvciAoaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKGFuQXJyYXlbaV0ubGF5ZXIgPT09IGxheWVyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICEhKGxheWVyLl9fcGFyZW50ICYmIGxheWVyLl9fcGFyZW50Ll9ncm91cCA9PT0gdGhpcykgfHwgdGhpcy5fbm9uUG9pbnRHcm91cC5oYXNMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly9ab29tIGRvd24gdG8gc2hvdyB0aGUgZ2l2ZW4gbGF5ZXIgKHNwaWRlcmZ5aW5nIGlmIG5lY2Vzc2FyeSkgdGhlbiBjYWxscyB0aGUgY2FsbGJhY2tcclxuXHR6b29tVG9TaG93TGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgY2FsbGJhY2spIHtcclxuXHJcblx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNob3dNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICgobGF5ZXIuX2ljb24gfHwgbGF5ZXIuX19wYXJlbnQuX2ljb24pICYmICF0aGlzLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAub2ZmKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblx0XHRcdFx0dGhpcy5vZmYoJ2FuaW1hdGlvbmVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xyXG5cclxuXHRcdFx0XHRpZiAobGF5ZXIuX2ljb24pIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChsYXllci5fX3BhcmVudC5faWNvbikge1xyXG5cdFx0XHRcdFx0dGhpcy5vbmNlKCdzcGlkZXJmaWVkJywgY2FsbGJhY2ssIHRoaXMpO1xyXG5cdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQuc3BpZGVyZnkoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGxheWVyLl9pY29uICYmIHRoaXMuX21hcC5nZXRCb3VuZHMoKS5jb250YWlucyhsYXllci5nZXRMYXRMbmcoKSkpIHtcclxuXHRcdFx0Ly9MYXllciBpcyB2aXNpYmxlIG9uZCBvbiBzY3JlZW4sIGltbWVkaWF0ZSByZXR1cm5cclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXIuX19wYXJlbnQuX3pvb20gPCBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSkpIHtcclxuXHRcdFx0Ly9MYXllciBzaG91bGQgYmUgdmlzaWJsZSBhdCB0aGlzIHpvb20gbGV2ZWwuIEl0IG11c3Qgbm90IGJlIG9uIHNjcmVlbiBzbyBqdXN0IHBhbiBvdmVyIHRvIGl0XHJcblx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLl9tYXAucGFuVG8obGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblx0XHRcdHRoaXMub24oJ2FuaW1hdGlvbmVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xyXG5cdFx0XHRsYXllci5fX3BhcmVudC56b29tVG9Cb3VuZHMoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBGZWF0dXJlR3JvdXAub25BZGRcclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0dmFyIGksIGwsIGxheWVyO1xyXG5cclxuXHRcdGlmICghaXNGaW5pdGUodGhpcy5fbWFwLmdldE1heFpvb20oKSkpIHtcclxuXHRcdFx0dGhyb3cgXCJNYXAgaGFzIG5vIG1heFpvb20gc3BlY2lmaWVkXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmFkZFRvKG1hcCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZFRvKG1hcCk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ncmlkQ2x1c3RlcnMpIHtcclxuXHRcdFx0dGhpcy5fZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnMoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXhMYXQgPSBtYXAub3B0aW9ucy5jcnMucHJvamVjdGlvbi5NQVhfTEFUSVRVREU7XHJcblxyXG5cdFx0Ly9SZXN0b3JlIGFsbCB0aGUgcG9zaXRpb25zIGFzIHRoZXkgYXJlIGluIHRoZSBNQ0cgYmVmb3JlIHJlbW92aW5nIHRoZW1cclxuXHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc1JlbW92aW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XHJcblx0XHRcdGxheWVyLm5ld2xhdGxuZyA9IGxheWVyLmxheWVyLl9sYXRsbmc7XHJcblx0XHRcdGxheWVyLmxheWVyLl9sYXRsbmcgPSBsYXllci5sYXRsbmc7XHJcblx0XHR9XHJcblx0XHQvL1JlbW92ZSB0aGVtLCB0aGVuIHJlc3RvcmUgdGhlaXIgbmV3IHBvc2l0aW9uc1xyXG5cdFx0Zm9yIChpID0gMCwgbCA9IHRoaXMuX25lZWRzUmVtb3ZpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbmVlZHNSZW1vdmluZ1tpXTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobGF5ZXIubGF5ZXIsIHRydWUpO1xyXG5cdFx0XHRsYXllci5sYXllci5fbGF0bG5nID0gbGF5ZXIubmV3bGF0bG5nO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fbmVlZHNSZW1vdmluZyA9IFtdO1xyXG5cclxuXHRcdC8vUmVtZW1iZXIgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhbmQgYm91bmRzXHJcblx0XHR0aGlzLl96b29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xyXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCB0aGlzLl9tb3ZlRW5kLCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc3BpZGVyZmllck9uQWRkKSB7IC8vVE9ETyBGSVhNRTogTm90IHN1cmUgaG93IHRvIGhhdmUgc3BpZGVyZmllciBhZGQgc29tZXRoaW5nIG9uIGhlcmUgbmljZWx5XHJcblx0XHRcdHRoaXMuX3NwaWRlcmZpZXJPbkFkZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2JpbmRFdmVudHMoKTtcclxuXHJcblx0XHQvL0FjdHVhbGx5IGFkZCBvdXIgbWFya2VycyB0byB0aGUgbWFwOlxyXG5cdFx0bCA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcclxuXHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xyXG5cdFx0dGhpcy5hZGRMYXllcnMobCwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0Ly9PdmVycmlkZXMgRmVhdHVyZUdyb3VwLm9uUmVtb3ZlXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl96b29tRW5kLCB0aGlzKTtcclxuXHRcdG1hcC5vZmYoJ21vdmVlbmQnLCB0aGlzLl9tb3ZlRW5kLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl91bmJpbmRFdmVudHMoKTtcclxuXHJcblx0XHQvL0luIGNhc2Ugd2UgYXJlIGluIGEgY2x1c3RlciBhbmltYXRpb25cclxuXHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgPSB0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNsdXN0ZXItYW5pbScsICcnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc3BpZGVyZmllck9uUmVtb3ZlKSB7IC8vVE9ETyBGSVhNRTogTm90IHN1cmUgaG93IHRvIGhhdmUgc3BpZGVyZmllciBhZGQgc29tZXRoaW5nIG9uIGhlcmUgbmljZWx5XHJcblx0XHRcdHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXhMYXQ7XHJcblxyXG5cdFx0Ly9DbGVhbiB1cCBhbGwgdGhlIGxheWVycyB3ZSBhZGRlZCB0byB0aGUgbWFwXHJcblx0XHR0aGlzLl9oaWRlQ292ZXJhZ2UoKTtcclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAucmVtb3ZlKCk7XHJcblxyXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmNsZWFyTGF5ZXJzKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRWaXNpYmxlUGFyZW50OiBmdW5jdGlvbiAobWFya2VyKSB7XHJcblx0XHR2YXIgdk1hcmtlciA9IG1hcmtlcjtcclxuXHRcdHdoaWxlICh2TWFya2VyICYmICF2TWFya2VyLl9pY29uKSB7XHJcblx0XHRcdHZNYXJrZXIgPSB2TWFya2VyLl9fcGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZNYXJrZXIgfHwgbnVsbDtcclxuXHR9LFxyXG5cclxuXHQvL1JlbW92ZSB0aGUgZ2l2ZW4gb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5XHJcblx0X2FycmF5U3BsaWNlOiBmdW5jdGlvbiAoYW5BcnJheSwgb2JqKSB7XHJcblx0XHRmb3IgKHZhciBpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gb2JqKSB7XHJcblx0XHRcdFx0YW5BcnJheS5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGEgbWFya2VyIGZyb20gYWxsIF9ncmlkVW5jbHVzdGVyZWQgem9vbSBsZXZlbHMsIHN0YXJ0aW5nIGF0IHRoZSBzdXBwbGllZCB6b29tLlxyXG5cdCAqIEBwYXJhbSBtYXJrZXIgdG8gYmUgcmVtb3ZlZCBmcm9tIF9ncmlkVW5jbHVzdGVyZWQuXHJcblx0ICogQHBhcmFtIHogaW50ZWdlciBib3R0b20gc3RhcnQgem9vbSBsZXZlbCAoaW5jbHVkZWQpXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVtb3ZlRnJvbUdyaWRVbmNsdXN0ZXJlZDogZnVuY3Rpb24gKG1hcmtlciwgeikge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXHJcblx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xyXG5cclxuXHRcdGZvciAoOyB6ID49IG1pblpvb207IHotLSkge1xyXG5cdFx0XHRpZiAoIWdyaWRVbmNsdXN0ZXJlZFt6XS5yZW1vdmVPYmplY3QobWFya2VyLCBtYXAucHJvamVjdChtYXJrZXIuZ2V0TGF0TG5nKCksIHopKSkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoaWxkTWFya2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50YXJnZXQuX19kcmFnU3RhcnQgPSBlLnRhcmdldC5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdF9jaGlsZE1hcmtlck1vdmVkOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9pZ25vcmVNb3ZlICYmICFlLnRhcmdldC5fX2RyYWdTdGFydCkge1xyXG5cdFx0XHR2YXIgaXNQb3B1cE9wZW4gPSBlLnRhcmdldC5fcG9wdXAgJiYgZS50YXJnZXQuX3BvcHVwLmlzT3BlbigpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZUNoaWxkKGUudGFyZ2V0LCBlLm9sZExhdExuZywgZS5sYXRsbmcpO1xyXG5cclxuXHRcdFx0aWYgKGlzUG9wdXBPcGVuKSB7XHJcblx0XHRcdFx0ZS50YXJnZXQub3BlblBvcHVwKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZUNoaWxkOiBmdW5jdGlvbiAobGF5ZXIsIGZyb20sIHRvKSB7XHJcblx0XHRsYXllci5fbGF0bG5nID0gZnJvbTtcclxuXHRcdHRoaXMucmVtb3ZlTGF5ZXIobGF5ZXIpO1xyXG5cclxuXHRcdGxheWVyLl9sYXRsbmcgPSB0bztcclxuXHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9jaGlsZE1hcmtlckRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS50YXJnZXQuX19kcmFnU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5fbW92ZUNoaWxkKGUudGFyZ2V0LCBlLnRhcmdldC5fX2RyYWdTdGFydCwgZS50YXJnZXQuX2xhdGxuZyk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgZS50YXJnZXQuX19kcmFnU3RhcnQ7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vSW50ZXJuYWwgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGEgbWFya2VyIGZyb20gZXZlcnl0aGluZy5cclxuXHQvL2RvbnRVcGRhdGVNYXA6IHNldCB0byB0cnVlIGlmIHlvdSB3aWxsIGhhbmRsZSB1cGRhdGluZyB0aGUgbWFwIG1hbnVhbGx5IChmb3IgYnVsayBmdW5jdGlvbnMpXHJcblx0X3JlbW92ZUxheWVyOiBmdW5jdGlvbiAobWFya2VyLCByZW1vdmVGcm9tRGlzdGFuY2VHcmlkLCBkb250VXBkYXRlTWFwKSB7XHJcblx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxyXG5cdFx0XHRncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXHJcblx0XHRcdGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHRtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xyXG5cclxuXHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSBkaXN0YW5jZSBjbHVzdGVycyBpdCBtaWdodCBiZSBpblxyXG5cdFx0aWYgKHJlbW92ZUZyb21EaXN0YW5jZUdyaWQpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlRnJvbUdyaWRVbmNsdXN0ZXJlZChtYXJrZXIsIHRoaXMuX21heFpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vV29yayBvdXIgd2F5IHVwIHRoZSBjbHVzdGVycyByZW1vdmluZyB0aGVtIGFzIHdlIGdvIGlmIHJlcXVpcmVkXHJcblx0XHR2YXIgY2x1c3RlciA9IG1hcmtlci5fX3BhcmVudCxcclxuXHRcdFx0bWFya2VycyA9IGNsdXN0ZXIuX21hcmtlcnMsXHJcblx0XHRcdG90aGVyTWFya2VyO1xyXG5cclxuXHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgaW1tZWRpYXRlIHBhcmVudHMgbWFya2VyIGxpc3RcclxuXHRcdHRoaXMuX2FycmF5U3BsaWNlKG1hcmtlcnMsIG1hcmtlcik7XHJcblxyXG5cdFx0d2hpbGUgKGNsdXN0ZXIpIHtcclxuXHRcdFx0Y2x1c3Rlci5fY2hpbGRDb3VudC0tO1xyXG5cdFx0XHRjbHVzdGVyLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChjbHVzdGVyLl96b29tIDwgbWluWm9vbSkge1xyXG5cdFx0XHRcdC8vVG9wIGxldmVsLCBkbyBub3RoaW5nXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH0gZWxzZSBpZiAocmVtb3ZlRnJvbURpc3RhbmNlR3JpZCAmJiBjbHVzdGVyLl9jaGlsZENvdW50IDw9IDEpIHsgLy9DbHVzdGVyIG5vIGxvbmdlciByZXF1aXJlZFxyXG5cdFx0XHRcdC8vV2UgbmVlZCB0byBwdXNoIHRoZSBvdGhlciBtYXJrZXIgdXAgdG8gdGhlIHBhcmVudFxyXG5cdFx0XHRcdG90aGVyTWFya2VyID0gY2x1c3Rlci5fbWFya2Vyc1swXSA9PT0gbWFya2VyID8gY2x1c3Rlci5fbWFya2Vyc1sxXSA6IGNsdXN0ZXIuX21hcmtlcnNbMF07XHJcblxyXG5cdFx0XHRcdC8vVXBkYXRlIGRpc3RhbmNlIGdyaWRcclxuXHRcdFx0XHRncmlkQ2x1c3RlcnNbY2x1c3Rlci5fem9vbV0ucmVtb3ZlT2JqZWN0KGNsdXN0ZXIsIG1hcC5wcm9qZWN0KGNsdXN0ZXIuX2NMYXRMbmcsIGNsdXN0ZXIuX3pvb20pKTtcclxuXHRcdFx0XHRncmlkVW5jbHVzdGVyZWRbY2x1c3Rlci5fem9vbV0uYWRkT2JqZWN0KG90aGVyTWFya2VyLCBtYXAucHJvamVjdChvdGhlck1hcmtlci5nZXRMYXRMbmcoKSwgY2x1c3Rlci5fem9vbSkpO1xyXG5cclxuXHRcdFx0XHQvL01vdmUgb3RoZXJNYXJrZXIgdXAgdG8gcGFyZW50XHJcblx0XHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UoY2x1c3Rlci5fX3BhcmVudC5fY2hpbGRDbHVzdGVycywgY2x1c3Rlcik7XHJcblx0XHRcdFx0Y2x1c3Rlci5fX3BhcmVudC5fbWFya2Vycy5wdXNoKG90aGVyTWFya2VyKTtcclxuXHRcdFx0XHRvdGhlck1hcmtlci5fX3BhcmVudCA9IGNsdXN0ZXIuX19wYXJlbnQ7XHJcblxyXG5cdFx0XHRcdGlmIChjbHVzdGVyLl9pY29uKSB7XHJcblx0XHRcdFx0XHQvL0NsdXN0ZXIgaXMgY3VycmVudGx5IG9uIHRoZSBtYXAsIG5lZWQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdGhlIG1hcCBpbnN0ZWFkXHJcblx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjbHVzdGVyKTtcclxuXHRcdFx0XHRcdGlmICghZG9udFVwZGF0ZU1hcCkge1xyXG5cdFx0XHRcdFx0XHRmZy5hZGRMYXllcihvdGhlck1hcmtlcik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNsdXN0ZXIuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNsdXN0ZXIgPSBjbHVzdGVyLl9fcGFyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSBtYXJrZXIuX19wYXJlbnQ7XHJcblx0fSxcclxuXHJcblx0X2lzT3JJc1BhcmVudDogZnVuY3Rpb24gKGVsLCBvZWwpIHtcclxuXHRcdHdoaWxlIChvZWwpIHtcclxuXHRcdFx0aWYgKGVsID09PSBvZWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvZWwgPSBvZWwucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlIEwuRXZlbnRlZC5maXJlXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKGRhdGEgJiYgZGF0YS5sYXllciBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xyXG5cdFx0XHQvL1ByZXZlbnQgbXVsdGlwbGUgY2x1c3Rlcm1vdXNlb3Zlci9vZmYgZXZlbnRzIGlmIHRoZSBpY29uIGlzIG1hZGUgdXAgb2Ygc3RhY2tlZCBkaXZzIChEb2Vzbid0IHdvcmsgaW4gaWUgPD0gOCwgbm8gcmVsYXRlZFRhcmdldClcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudCAmJiB0aGlzLl9pc09ySXNQYXJlbnQoZGF0YS5sYXllci5faWNvbiwgZGF0YS5vcmlnaW5hbEV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHR5cGUgPSAnY2x1c3RlcicgKyB0eXBlO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5maXJlLmNhbGwodGhpcywgdHlwZSwgZGF0YSwgcHJvcGFnYXRlKTtcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlIEwuRXZlbnRlZC5saXN0ZW5zXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIHByb3BhZ2F0ZSkge1xyXG5cdFx0cmV0dXJuIEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5saXN0ZW5zLmNhbGwodGhpcywgdHlwZSwgcHJvcGFnYXRlKSB8fCBMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUubGlzdGVucy5jYWxsKHRoaXMsICdjbHVzdGVyJyArIHR5cGUsIHByb3BhZ2F0ZSk7XHJcblx0fSxcclxuXHJcblx0Ly9EZWZhdWx0IGZ1bmN0aW9uYWxpdHlcclxuXHRfZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gKGNsdXN0ZXIpIHtcclxuXHRcdHZhciBjaGlsZENvdW50ID0gY2x1c3Rlci5nZXRDaGlsZENvdW50KCk7XHJcblxyXG5cdFx0dmFyIGMgPSAnIG1hcmtlci1jbHVzdGVyLSc7XHJcblx0XHRpZiAoY2hpbGRDb3VudCA8IDEwKSB7XHJcblx0XHRcdGMgKz0gJ3NtYWxsJztcclxuXHRcdH0gZWxzZSBpZiAoY2hpbGRDb3VudCA8IDEwMCkge1xyXG5cdFx0XHRjICs9ICdtZWRpdW0nO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YyArPSAnbGFyZ2UnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5EaXZJY29uKHsgaHRtbDogJzxkaXY+PHNwYW4+JyArIGNoaWxkQ291bnQgKyAnPC9zcGFuPjwvZGl2PicsIGNsYXNzTmFtZTogJ21hcmtlci1jbHVzdGVyJyArIGMsIGljb25TaXplOiBuZXcgTC5Qb2ludCg0MCwgNDApIH0pO1xyXG5cdH0sXHJcblxyXG5cdF9iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxyXG5cdFx0ICAgIHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3ZlcixcclxuXHRcdCAgICB6b29tVG9Cb3VuZHNPbkNsaWNrID0gdGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2s7XHJcblxyXG5cdFx0Ly9ab29tIG9uIGNsdXN0ZXIgY2xpY2sgb3Igc3BpZGVyZnkgaWYgd2UgYXJlIGF0IHRoZSBsb3dlc3QgbGV2ZWxcclxuXHRcdGlmIChzcGlkZXJmeU9uTWF4Wm9vbSB8fCB6b29tVG9Cb3VuZHNPbkNsaWNrKSB7XHJcblx0XHRcdHRoaXMub24oJ2NsdXN0ZXJjbGljaycsIHRoaXMuX3pvb21PclNwaWRlcmZ5LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1Nob3cgY29udmV4IGh1bGwgKGJvdW5kYXJ5KSBwb2x5Z29uIG9uIG1vdXNlIG92ZXJcclxuXHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW92ZXInLCB0aGlzLl9zaG93Q292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLm9uKCdjbHVzdGVybW91c2VvdXQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tT3JTcGlkZXJmeTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBjbHVzdGVyID0gZS5sYXllcixcclxuXHRcdCAgICBib3R0b21DbHVzdGVyID0gY2x1c3RlcjtcclxuXHJcblx0XHR3aGlsZSAoYm90dG9tQ2x1c3Rlci5fY2hpbGRDbHVzdGVycy5sZW5ndGggPT09IDEpIHtcclxuXHRcdFx0Ym90dG9tQ2x1c3RlciA9IGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ2x1c3RlcnNbMF07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGJvdHRvbUNsdXN0ZXIuX3pvb20gPT09IHRoaXMuX21heFpvb20gJiZcclxuXHRcdFx0Ym90dG9tQ2x1c3Rlci5fY2hpbGRDb3VudCA9PT0gY2x1c3Rlci5fY2hpbGRDb3VudCAmJlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20pIHtcclxuXHJcblx0XHRcdC8vIEFsbCBjaGlsZCBtYXJrZXJzIGFyZSBjb250YWluZWQgaW4gYSBzaW5nbGUgY2x1c3RlciBmcm9tIHRoaXMuX21heFpvb20gdG8gdGhpcyBjbHVzdGVyLlxyXG5cdFx0XHRjbHVzdGVyLnNwaWRlcmZ5KCk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrKSB7XHJcblx0XHRcdGNsdXN0ZXIuem9vbVRvQm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRm9jdXMgdGhlIG1hcCBhZ2FpbiBmb3Iga2V5Ym9hcmQgdXNlcnMuXHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9zaG93Q292ZXJhZ2U6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cdFx0aWYgKHRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fc2hvd25Qb2x5Z29uKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGUubGF5ZXIuZ2V0Q2hpbGRDb3VudCgpID4gMiAmJiBlLmxheWVyICE9PSB0aGlzLl9zcGlkZXJmaWVkKSB7XHJcblx0XHRcdHRoaXMuX3Nob3duUG9seWdvbiA9IG5ldyBMLlBvbHlnb24oZS5sYXllci5nZXRDb252ZXhIdWxsKCksIHRoaXMub3B0aW9ucy5wb2x5Z29uT3B0aW9ucyk7XHJcblx0XHRcdG1hcC5hZGRMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9oaWRlQ292ZXJhZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaG93blBvbHlnb24pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XHJcblx0XHRcdHRoaXMuX3Nob3duUG9seWdvbiA9IG51bGw7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VuYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxyXG5cdFx0XHRzaG93Q292ZXJhZ2VPbkhvdmVyID0gdGhpcy5vcHRpb25zLnNob3dDb3ZlcmFnZU9uSG92ZXIsXHJcblx0XHRcdHpvb21Ub0JvdW5kc09uQ2xpY2sgPSB0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljayxcclxuXHRcdFx0bWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChzcGlkZXJmeU9uTWF4Wm9vbSB8fCB6b29tVG9Cb3VuZHNPbkNsaWNrKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdjbHVzdGVyY2xpY2snLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHRpZiAoc2hvd0NvdmVyYWdlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHRcdHRoaXMub2ZmKCdjbHVzdGVybW91c2VvdXQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRoaXMuX21lcmdlU3BsaXRDbHVzdGVycygpO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld0JvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCB0aGlzLl96b29tLCBuZXdCb3VuZHMpO1xyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pLCBuZXdCb3VuZHMpO1xyXG5cclxuXHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IG5ld0JvdW5kcztcclxuXHRcdHJldHVybjtcclxuXHR9LFxyXG5cclxuXHRfZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXhab29tID0gTWF0aC5jZWlsKHRoaXMuX21hcC5nZXRNYXhab29tKCkpLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcclxuXHRcdFx0cmFkaXVzID0gdGhpcy5vcHRpb25zLm1heENsdXN0ZXJSYWRpdXMsXHJcblx0XHRcdHJhZGl1c0ZuID0gcmFkaXVzO1xyXG5cclxuXHRcdC8vSWYgd2UganVzdCBzZXQgbWF4Q2x1c3RlclJhZGl1cyB0byBhIHNpbmdsZSBudW1iZXIsIHdlIG5lZWQgdG8gY3JlYXRlXHJcblx0XHQvL2Egc2ltcGxlIGZ1bmN0aW9uIHRvIHJldHVybiB0aGF0IG51bWJlci4gT3RoZXJ3aXNlLCB3ZSBqdXN0IGhhdmUgdG9cclxuXHRcdC8vdXNlIHRoZSBmdW5jdGlvbiB3ZSd2ZSBwYXNzZWQgaW4uXHJcblx0XHRpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdHJhZGl1c0ZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFkaXVzOyB9O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb20gIT09IG51bGwpIHtcclxuXHRcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5kaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSAtIDE7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9tYXhab29tID0gbWF4Wm9vbTtcclxuXHRcdHRoaXMuX2dyaWRDbHVzdGVycyA9IHt9O1xyXG5cdFx0dGhpcy5fZ3JpZFVuY2x1c3RlcmVkID0ge307XHJcblxyXG5cdFx0Ly9TZXQgdXAgRGlzdGFuY2VHcmlkcyBmb3IgZWFjaCB6b29tXHJcblx0XHRmb3IgKHZhciB6b29tID0gbWF4Wm9vbTsgem9vbSA+PSBtaW5ab29tOyB6b29tLS0pIHtcclxuXHRcdFx0dGhpcy5fZ3JpZENsdXN0ZXJzW3pvb21dID0gbmV3IEwuRGlzdGFuY2VHcmlkKHJhZGl1c0ZuKHpvb20pKTtcclxuXHRcdFx0dGhpcy5fZ3JpZFVuY2x1c3RlcmVkW3pvb21dID0gbmV3IEwuRGlzdGFuY2VHcmlkKHJhZGl1c0ZuKHpvb20pKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbnN0YW50aWF0ZSB0aGUgYXBwcm9wcmlhdGUgTC5NYXJrZXJDbHVzdGVyIGNsYXNzIChhbmltYXRlZCBvciBub3QpLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsID0gbmV3IHRoaXMuX21hcmtlckNsdXN0ZXIodGhpcywgbWluWm9vbSAtIDEpO1xyXG5cdH0sXHJcblxyXG5cdC8vWm9vbTogWm9vbSB0byBzdGFydCBhZGRpbmcgYXQgKFBhc3MgdGhpcy5fbWF4Wm9vbSB0byBzdGFydCBhdCB0aGUgYm90dG9tKVxyXG5cdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCB6b29tKSB7XHJcblx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxyXG5cdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXHJcblx0XHQgICAgbWFya2VyUG9pbnQsIHo7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XHJcblx0XHRcdHRoaXMuX292ZXJyaWRlTWFya2VySWNvbihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIub24odGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcclxuXHJcblx0XHQvL0ZpbmQgdGhlIGxvd2VzdCB6b29tIGxldmVsIHRvIHNsb3QgdGhpcyBvbmUgaW5cclxuXHRcdGZvciAoOyB6b29tID49IG1pblpvb207IHpvb20tLSkge1xyXG5cdFx0XHRtYXJrZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGxheWVyLmdldExhdExuZygpLCB6b29tKTsgLy8gY2FsY3VsYXRlIHBpeGVsIHBvc2l0aW9uXHJcblxyXG5cdFx0XHQvL1RyeSBmaW5kIGEgY2x1c3RlciBjbG9zZSBieVxyXG5cdFx0XHR2YXIgY2xvc2VzdCA9IGdyaWRDbHVzdGVyc1t6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcclxuXHRcdFx0aWYgKGNsb3Nlc3QpIHtcclxuXHRcdFx0XHRjbG9zZXN0Ll9hZGRDaGlsZChsYXllcik7XHJcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBjbG9zZXN0O1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9UcnkgZmluZCBhIG1hcmtlciBjbG9zZSBieSB0byBmb3JtIGEgbmV3IGNsdXN0ZXIgd2l0aFxyXG5cdFx0XHRjbG9zZXN0ID0gZ3JpZFVuY2x1c3RlcmVkW3pvb21dLmdldE5lYXJPYmplY3QobWFya2VyUG9pbnQpO1xyXG5cdFx0XHRpZiAoY2xvc2VzdCkge1xyXG5cdFx0XHRcdHZhciBwYXJlbnQgPSBjbG9zZXN0Ll9fcGFyZW50O1xyXG5cdFx0XHRcdGlmIChwYXJlbnQpIHtcclxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKGNsb3Nlc3QsIGZhbHNlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vQ3JlYXRlIG5ldyBjbHVzdGVyIHdpdGggdGhlc2UgMiBpbiBpdFxyXG5cclxuXHRcdFx0XHR2YXIgbmV3Q2x1c3RlciA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIHpvb20sIGNsb3Nlc3QsIGxheWVyKTtcclxuXHRcdFx0XHRncmlkQ2x1c3RlcnNbem9vbV0uYWRkT2JqZWN0KG5ld0NsdXN0ZXIsIHRoaXMuX21hcC5wcm9qZWN0KG5ld0NsdXN0ZXIuX2NMYXRMbmcsIHpvb20pKTtcclxuXHRcdFx0XHRjbG9zZXN0Ll9fcGFyZW50ID0gbmV3Q2x1c3RlcjtcclxuXHRcdFx0XHRsYXllci5fX3BhcmVudCA9IG5ld0NsdXN0ZXI7XHJcblxyXG5cdFx0XHRcdC8vRmlyc3QgY3JlYXRlIGFueSBuZXcgaW50ZXJtZWRpYXRlIHBhcmVudCBjbHVzdGVycyB0aGF0IGRvbid0IGV4aXN0XHJcblx0XHRcdFx0dmFyIGxhc3RQYXJlbnQgPSBuZXdDbHVzdGVyO1xyXG5cdFx0XHRcdGZvciAoeiA9IHpvb20gLSAxOyB6ID4gcGFyZW50Ll96b29tOyB6LS0pIHtcclxuXHRcdFx0XHRcdGxhc3RQYXJlbnQgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCB6LCBsYXN0UGFyZW50KTtcclxuXHRcdFx0XHRcdGdyaWRDbHVzdGVyc1t6XS5hZGRPYmplY3QobGFzdFBhcmVudCwgdGhpcy5fbWFwLnByb2plY3QoY2xvc2VzdC5nZXRMYXRMbmcoKSwgeikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwYXJlbnQuX2FkZENoaWxkKGxhc3RQYXJlbnQpO1xyXG5cclxuXHRcdFx0XHQvL1JlbW92ZSBjbG9zZXN0IGZyb20gdGhpcyB6b29tIGxldmVsIGFuZCBhbnkgYWJvdmUgdGhhdCBpdCBpcyBpbiwgcmVwbGFjZSB3aXRoIG5ld0NsdXN0ZXJcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkKGNsb3Nlc3QsIHpvb20pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vRGlkbid0IG1hbmFnZSB0byBjbHVzdGVyIGluIGF0IHRoaXMgem9vbSwgcmVjb3JkIHVzIGFzIGEgbWFya2VyIGhlcmUgYW5kIGNvbnRpbnVlIHVwd2FyZHNcclxuXHRcdFx0Z3JpZFVuY2x1c3RlcmVkW3pvb21dLmFkZE9iamVjdChsYXllciwgbWFya2VyUG9pbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vRGlkbid0IGdldCBpbiBhbnl0aGluZywgYWRkIHVzIHRvIHRoZSB0b3BcclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYWRkQ2hpbGQobGF5ZXIpO1xyXG5cdFx0bGF5ZXIuX19wYXJlbnQgPSB0aGlzLl90b3BDbHVzdGVyTGV2ZWw7XHJcblx0XHRyZXR1cm47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVmcmVzaGVzIHRoZSBpY29uIG9mIGFsbCBcImRpcnR5XCIgdmlzaWJsZSBjbHVzdGVycy5cclxuXHQgKiBOb24tdmlzaWJsZSBcImRpcnR5XCIgY2x1c3RlcnMgd2lsbCBiZSB1cGRhdGVkIHdoZW4gdGhleSBhcmUgYWRkZWQgdG8gdGhlIG1hcC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZWZyZXNoQ2x1c3RlcnNJY29uczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRpZiAoYyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3RlciAmJiBjLl9pY29uTmVlZHNVcGRhdGUpIHtcclxuXHRcdFx0XHRjLl91cGRhdGVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vRW5xdWV1ZSBjb2RlIHRvIGZpcmUgYWZ0ZXIgdGhlIG1hcmtlciBleHBhbmQvY29udHJhY3QgaGFzIGhhcHBlbmVkXHJcblx0X2VucXVldWU6IGZ1bmN0aW9uIChmbikge1xyXG5cdFx0dGhpcy5fcXVldWUucHVzaChmbik7XHJcblx0XHRpZiAoIXRoaXMuX3F1ZXVlVGltZW91dCkge1xyXG5cdFx0XHR0aGlzLl9xdWV1ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9wcm9jZXNzUXVldWUsIHRoaXMpLCAzMDApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0X3Byb2Nlc3NRdWV1ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9xdWV1ZVtpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fcXVldWUubGVuZ3RoID0gMDtcclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9xdWV1ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5fcXVldWVUaW1lb3V0ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHQvL01lcmdlIGFuZCBzcGxpdCBhbnkgZXhpc3RpbmcgY2x1c3RlcnMgdGhhdCBhcmUgdG9vIGJpZyBvciBzbWFsbFxyXG5cdF9tZXJnZVNwbGl0Q2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXBab29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xyXG5cclxuXHRcdC8vSW4gY2FzZSB3ZSBhcmUgc3RhcnRpbmcgdG8gc3BsaXQgYmVmb3JlIHRoZSBhbmltYXRpb24gZmluaXNoZWRcclxuXHRcdHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tIDwgbWFwWm9vbSAmJiB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSkpIHsgLy9ab29tIGluLCBzcGxpdFxyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xyXG5cdFx0XHQvL1JlbW92ZSBjbHVzdGVycyBub3cgb2ZmIHNjcmVlblxyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgdGhpcy5fem9vbSwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbUluKHRoaXMuX3pvb20sIG1hcFpvb20pO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodGhpcy5fem9vbSA+IG1hcFpvb20pIHsgLy9ab29tIG91dCwgbWVyZ2VcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21PdXQodGhpcy5fem9vbSwgbWFwWm9vbSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9tb3ZlRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9HZXRzIHRoZSBtYXBzIHZpc2libGUgYm91bmRzIGV4cGFuZGVkIGluIGVhY2ggZGlyZWN0aW9uIGJ5IHRoZSBzaXplIG9mIHRoZSBzY3JlZW4gKHNvIHRoZSB1c2VyIGNhbm5vdCBzZWUgYW4gYXJlYSB3ZSBkbyBub3QgY292ZXIgaW4gb25lIHBhbilcclxuXHRfZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5yZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kcykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbWFwQm91bmRzSW5maW5pdGU7XHJcblx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci5tb2JpbGUpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX2NoZWNrQm91bmRzTWF4TGF0KHRoaXMuX21hcC5nZXRCb3VuZHMoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrQm91bmRzTWF4TGF0KHRoaXMuX21hcC5nZXRCb3VuZHMoKS5wYWQoMSkpOyAvLyBQYWRkaW5nIGV4cGFuZHMgdGhlIGJvdW5kcyBieSBpdHMgb3duIGRpbWVuc2lvbnMgYnV0IHNjYWxlZCB3aXRoIHRoZSBnaXZlbiBmYWN0b3IuXHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRXhwYW5kcyB0aGUgbGF0aXR1ZGUgdG8gSW5maW5pdHkgKG9yIC1JbmZpbml0eSkgaWYgdGhlIGlucHV0IGJvdW5kcyByZWFjaCB0aGUgbWFwIHByb2plY3Rpb24gbWF4aW11bSBkZWZpbmVkIGxhdGl0dWRlXHJcblx0ICogKGluIHRoZSBjYXNlIG9mIFdlYi9TcGhlcmljYWwgTWVyY2F0b3IsIGl0IGlzIDg1LjA1MTEyODc3OTggLyBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01lcmNhdG9yI0Zvcm11bGFzKS5cclxuXHQgKiBPdGhlcndpc2UsIHRoZSByZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kcyBvcHRpb24gd2lsbCByZW1vdmUgbWFya2VycyBiZXlvbmQgdGhhdCBsaW1pdCwgd2hlcmVhcyB0aGUgc2FtZSBtYXJrZXJzIHdpdGhvdXRcclxuXHQgKiB0aGlzIG9wdGlvbiAob3Igb3V0c2lkZSBNQ0cpIHdpbGwgaGF2ZSB0aGVpciBwb3NpdGlvbiBmbG9vcmVkIChjZWlsZWQpIGJ5IHRoZSBwcm9qZWN0aW9uIGFuZCByZW5kZXJlZCBhdCB0aGF0IGxpbWl0LFxyXG5cdCAqIG1ha2luZyB0aGUgdXNlciB0aGluayB0aGF0IE1DRyBcImVhdHNcIiB0aGVtIGFuZCBuZXZlciBkaXNwbGF5cyB0aGVtIGFnYWluLlxyXG5cdCAqIEBwYXJhbSBib3VuZHMgTC5MYXRMbmdCb3VuZHNcclxuXHQgKiBAcmV0dXJucyB7TC5MYXRMbmdCb3VuZHN9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfY2hlY2tCb3VuZHNNYXhMYXQ6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBtYXhMYXQgPSB0aGlzLl9tYXhMYXQ7XHJcblxyXG5cdFx0aWYgKG1heExhdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmIChib3VuZHMuZ2V0Tm9ydGgoKSA+PSBtYXhMYXQpIHtcclxuXHRcdFx0XHRib3VuZHMuX25vcnRoRWFzdC5sYXQgPSBJbmZpbml0eTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoYm91bmRzLmdldFNvdXRoKCkgPD0gLW1heExhdCkge1xyXG5cdFx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxhdCA9IC1JbmZpbml0eTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly9TaGFyZWQgYW5pbWF0aW9uIGNvZGVcclxuXHRfYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZDogZnVuY3Rpb24gKGxheWVyLCBuZXdDbHVzdGVyKSB7XHJcblx0XHRpZiAobmV3Q2x1c3RlciA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdH0gZWxzZSBpZiAobmV3Q2x1c3Rlci5fY2hpbGRDb3VudCA9PT0gMikge1xyXG5cdFx0XHRuZXdDbHVzdGVyLl9hZGRUb01hcCgpO1xyXG5cclxuXHRcdFx0dmFyIG1hcmtlcnMgPSBuZXdDbHVzdGVyLmdldEFsbENoaWxkTWFya2VycygpO1xyXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobWFya2Vyc1swXSk7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtYXJrZXJzWzFdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBFeHRyYWN0cyBpbmRpdmlkdWFsIChpLmUuIG5vbi1ncm91cCkgbGF5ZXJzIGZyb20gYSBMYXllciBHcm91cC5cclxuXHQgKiBAcGFyYW0gZ3JvdXAgdG8gZXh0cmFjdCBsYXllcnMgZnJvbS5cclxuXHQgKiBAcGFyYW0gb3V0cHV0IHtBcnJheX0gaW4gd2hpY2ggdG8gc3RvcmUgdGhlIGV4dHJhY3RlZCBsYXllcnMuXHJcblx0ICogQHJldHVybnMgeyp8QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZXh0cmFjdE5vbkdyb3VwTGF5ZXJzOiBmdW5jdGlvbiAoZ3JvdXAsIG91dHB1dCkge1xyXG5cdFx0dmFyIGxheWVycyA9IGdyb3VwLmdldExheWVycygpLFxyXG5cdFx0ICAgIGkgPSAwLFxyXG5cdFx0ICAgIGxheWVyO1xyXG5cclxuXHRcdG91dHB1dCA9IG91dHB1dCB8fCBbXTtcclxuXHJcblx0XHRmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsYXllciA9IGxheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhsYXllciwgb3V0cHV0KTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3V0cHV0LnB1c2gobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSW1wbGVtZW50cyB0aGUgc2luZ2xlTWFya2VyTW9kZSBvcHRpb24uXHJcblx0ICogQHBhcmFtIGxheWVyIE1hcmtlciB0byByZS1zdHlsZSB1c2luZyB0aGUgQ2x1c3RlcnMgaWNvbkNyZWF0ZUZ1bmN0aW9uLlxyXG5cdCAqIEByZXR1cm5zIHtMLkljb259IFRoZSBuZXdseSBjcmVhdGVkIGljb24uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfb3ZlcnJpZGVNYXJrZXJJY29uOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpY29uID0gbGF5ZXIub3B0aW9ucy5pY29uID0gdGhpcy5vcHRpb25zLmljb25DcmVhdGVGdW5jdGlvbih7XHJcblx0XHRcdGdldENoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRyZXR1cm4gMTtcclxuXHRcdFx0fSxcclxuXHRcdFx0Z2V0QWxsQ2hpbGRNYXJrZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0cmV0dXJuIFtsYXllcl07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBpY29uO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBDb25zdGFudCBib3VuZHMgdXNlZCBpbiBjYXNlIG9wdGlvbiBcInJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzXCIgaXMgc2V0IHRvIGZhbHNlLlxyXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcclxuXHRfbWFwQm91bmRzSW5maW5pdGU6IG5ldyBMLkxhdExuZ0JvdW5kcyhuZXcgTC5MYXRMbmcoLUluZmluaXR5LCAtSW5maW5pdHkpLCBuZXcgTC5MYXRMbmcoSW5maW5pdHksIEluZmluaXR5KSlcclxufSk7XHJcblxyXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcclxuXHRfbm9BbmltYXRpb246IHtcclxuXHRcdC8vTm9uIEFuaW1hdGVkIHZlcnNpb25zIG9mIGV2ZXJ5dGhpbmdcclxuXHRcdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHQvL0RvIG5vdGhpbmcuLi5cclxuXHRcdH0sXHJcblx0XHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgcHJldmlvdXNab29tTGV2ZWwpO1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHJcblx0XHRcdC8vV2UgZGlkbid0IGFjdHVhbGx5IGFuaW1hdGUsIGJ1dCB3ZSB1c2UgdGhpcyBldmVudCB0byBtZWFuIFwiY2x1c3RlcmluZyBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcIlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xyXG5cdFx0fSxcclxuXHRcdF9hbmltYXRpb25ab29tT3V0OiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgcHJldmlvdXNab29tTGV2ZWwpO1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHJcblx0XHRcdC8vV2UgZGlkbid0IGFjdHVhbGx5IGFuaW1hdGUsIGJ1dCB3ZSB1c2UgdGhpcyBldmVudCB0byBtZWFuIFwiY2x1c3RlcmluZyBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcIlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xyXG5cdFx0fSxcclxuXHRcdF9hbmltYXRpb25BZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuZXdDbHVzdGVyKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQobGF5ZXIsIG5ld0NsdXN0ZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF93aXRoQW5pbWF0aW9uOiB7XHJcblx0XHQvL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcclxuXHRcdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lICs9ICcgbGVhZmxldC1jbHVzdGVyLWFuaW0nO1xyXG5cdFx0XHR0aGlzLl9pblpvb21BbmltYXRpb24rKztcclxuXHRcdH0sXHJcblxyXG5cdFx0X2FuaW1hdGlvblpvb21JbjogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpLFxyXG5cdFx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXHJcblx0XHRcdCAgICBpO1xyXG5cclxuXHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IHRydWU7XHJcblxyXG5cdFx0XHQvL0FkZCBhbGwgY2hpbGRyZW4gb2YgY3VycmVudCBjbHVzdGVycyB0byBtYXAgYW5kIHJlbW92ZSB0aG9zZSBjbHVzdGVycyBmcm9tIG1hcFxyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0dmFyIHN0YXJ0UG9zID0gYy5fbGF0bG5nLFxyXG5cdFx0XHRcdCAgICBtYXJrZXJzICA9IGMuX21hcmtlcnMsXHJcblx0XHRcdFx0ICAgIG07XHJcblxyXG5cdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKHN0YXJ0UG9zKSkge1xyXG5cdFx0XHRcdFx0c3RhcnRQb3MgPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgKyAxID09PSBuZXdab29tTGV2ZWwpIHsgLy9JbW1lZGlhdGVseSBhZGQgdGhlIG5ldyBjaGlsZCBhbmQgcmVtb3ZlIHVzXHJcblx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjKTtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIGJvdW5kcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vRmFkZSBvdXQgb2xkIGNsdXN0ZXJcclxuXHRcdFx0XHRcdGMuY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChzdGFydFBvcywgbmV3Wm9vbUxldmVsLCBib3VuZHMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9SZW1vdmUgYWxsIG1hcmtlcnMgdGhhdCBhcmVuJ3QgdmlzaWJsZSBhbnkgbW9yZVxyXG5cdFx0XHRcdC8vVE9ETzogRG8gd2UgYWN0dWFsbHkgbmVlZCB0byBkbyB0aGlzIG9uIHRoZSBoaWdoZXIgbGV2ZWxzIHRvbz9cclxuXHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcclxuXHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xyXG5cclxuXHRcdFx0Ly9VcGRhdGUgb3BhY2l0aWVzXHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcclxuXHRcdFx0Ly9UT0RPIE1heWJlPyBVcGRhdGUgbWFya2VycyBpbiBfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlXHJcblx0XHRcdGZnLmVhY2hMYXllcihmdW5jdGlvbiAobikge1xyXG5cdFx0XHRcdGlmICghKG4gaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpICYmIG4uX2ljb24pIHtcclxuXHRcdFx0XHRcdG4uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly91cGRhdGUgdGhlIHBvc2l0aW9ucyBvZiB0aGUganVzdCBhZGRlZCBjbHVzdGVycy9tYXJrZXJzXHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHkoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVzdG9yZUNoaWxkUG9zaXRpb25zKG5ld1pvb21MZXZlbCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Ly9SZW1vdmUgdGhlIG9sZCBjbHVzdGVycyBhbmQgY2xvc2UgdGhlIHpvb20gYW5pbWF0aW9uXHJcblx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdC8vdXBkYXRlIHRoZSBwb3NpdGlvbnMgb2YgdGhlIGp1c3QgYWRkZWQgY2x1c3RlcnMvbWFya2Vyc1xyXG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHkoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xyXG5cdFx0XHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9hbmltYXRpb25ab29tT3V0OiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0U2luZ2xlKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCwgcHJldmlvdXNab29tTGV2ZWwgLSAxLCBuZXdab29tTGV2ZWwpO1xyXG5cclxuXHRcdFx0Ly9OZWVkIHRvIGFkZCBtYXJrZXJzIGZvciB0aG9zZSB0aGF0IHdlcmVuJ3Qgb24gdGhlIG1hcCBiZWZvcmUgYnV0IGFyZSBub3dcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblx0XHRcdC8vUmVtb3ZlIG1hcmtlcnMgdGhhdCB3ZXJlIG9uIHRoZSBtYXAgYmVmb3JlIGJ1dCB3b24ndCBiZSBub3dcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9hbmltYXRpb25BZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuZXdDbHVzdGVyKSB7XHJcblx0XHRcdHZhciBtZSA9IHRoaXMsXHJcblx0XHRcdCAgICBmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cDtcclxuXHJcblx0XHRcdGZnLmFkZExheWVyKGxheWVyKTtcclxuXHRcdFx0aWYgKG5ld0NsdXN0ZXIgIT09IGxheWVyKSB7XHJcblx0XHRcdFx0aWYgKG5ld0NsdXN0ZXIuX2NoaWxkQ291bnQgPiAyKSB7IC8vV2FzIGFscmVhZHkgYSBjbHVzdGVyXHJcblxyXG5cdFx0XHRcdFx0bmV3Q2x1c3Rlci5fdXBkYXRlSWNvbigpO1xyXG5cdFx0XHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcclxuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0XHRcdFx0bGF5ZXIuX3NldFBvcyh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KG5ld0NsdXN0ZXIuZ2V0TGF0TG5nKCkpKTtcclxuXHRcdFx0XHRcdGxheWVyLmNsdXN0ZXJIaWRlKCk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcclxuXHJcblx0XHRcdFx0XHRcdG1lLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgeyAvL0p1c3QgYmVjYW1lIGEgY2x1c3RlclxyXG5cdFx0XHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcclxuXHJcblx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHRcdFx0XHRcdG1lLl9hbmltYXRpb25ab29tT3V0U2luZ2xlKG5ld0NsdXN0ZXIsIHRoaXMuX21hcC5nZXRNYXhab29tKCksIHRoaXMuX3pvb20pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIFByaXZhdGUgbWV0aG9kcyBmb3IgYW5pbWF0ZWQgdmVyc2lvbnMuXHJcblx0X2FuaW1hdGlvblpvb21PdXRTaW5nbGU6IGZ1bmN0aW9uIChjbHVzdGVyLCBwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCksXHJcblx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xyXG5cclxuXHRcdC8vQW5pbWF0ZSBhbGwgb2YgdGhlIG1hcmtlcnMgaW4gdGhlIGNsdXN0ZXJzIHRvIG1vdmUgdG8gdGhlaXIgY2x1c3RlciBjZW50ZXIgcG9pbnRcclxuXHRcdGNsdXN0ZXIuX3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW5BbmRBZGRTZWxmVG9NYXAoYm91bmRzLCBtaW5ab29tLCBwcmV2aW91c1pvb21MZXZlbCArIDEsIG5ld1pvb21MZXZlbCk7XHJcblxyXG5cdFx0dmFyIG1lID0gdGhpcztcclxuXHJcblx0XHQvL1VwZGF0ZSB0aGUgb3BhY2l0eSAoSWYgd2UgaW1tZWRpYXRlbHkgc2V0IGl0IHRoZXkgd29uJ3QgYW5pbWF0ZSlcclxuXHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XHJcblx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUJlY29tZVZpc2libGUoYm91bmRzLCBuZXdab29tTGV2ZWwpO1xyXG5cclxuXHRcdC8vVE9ETzogTWF5YmUgdXNlIHRoZSB0cmFuc2l0aW9uIHRpbWluZyBzdHVmZiB0byBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZVxyXG5cdFx0Ly9XaGVuIHRoZSBhbmltYXRpb25zIGFyZSBkb25lLCB0aWR5IHVwXHJcblx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vVGhpcyBjbHVzdGVyIHN0b3BwZWQgYmVpbmcgYSBjbHVzdGVyIGJlZm9yZSB0aGUgdGltZW91dCBmaXJlZFxyXG5cdFx0XHRpZiAoY2x1c3Rlci5fY2hpbGRDb3VudCA9PT0gMSkge1xyXG5cdFx0XHRcdHZhciBtID0gY2x1c3Rlci5fbWFya2Vyc1swXTtcclxuXHRcdFx0XHQvL0lmIHdlIHdlcmUgaW4gYSBjbHVzdGVyIGFuaW1hdGlvbiBhdCB0aGUgdGltZSB0aGVuIHRoZSBvcGFjaXR5IGFuZCBwb3NpdGlvbiBvZiBvdXIgY2hpbGQgY291bGQgYmUgd3Jvbmcgbm93LCBzbyBmaXggaXRcclxuXHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHRcdFx0XHRtLnNldExhdExuZyhtLmdldExhdExuZygpKTtcclxuXHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gZmFsc2U7XHJcblx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHkoYm91bmRzLCBuZXdab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcChib3VuZHMsIG1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsICsgMSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0bWUuX2FuaW1hdGlvbkVuZCgpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lID0gdGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jbHVzdGVyLWFuaW0nLCAnJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pblpvb21BbmltYXRpb24tLTtcclxuXHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XHJcblx0fSxcclxuXHJcblx0Ly9Gb3JjZSBhIGJyb3dzZXIgbGF5b3V0IG9mIHN0dWZmIGluIHRoZSBtYXBcclxuXHQvLyBTaG91bGQgYXBwbHkgdGhlIGN1cnJlbnQgb3BhY2l0eSBhbmQgbG9jYXRpb24gdG8gYWxsIGVsZW1lbnRzIHNvIHdlIGNhbiB1cGRhdGUgdGhlbSBhZ2FpbiBmb3IgYW4gYW5pbWF0aW9uXHJcblx0X2ZvcmNlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvL0luIG15IHRlc3RpbmcgdGhpcyB3b3JrcywgaW5mYWN0IG9mZnNldFdpZHRoIG9mIGFueSBlbGVtZW50IHNlZW1zIHRvIHdvcmsuXHJcblx0XHQvL0NvdWxkIGxvb3AgYWxsIHRoaXMuX2xheWVycyBhbmQgZG8gdGhpcyBmb3IgZWFjaCBfaWNvbiBpZiBpdCBzdG9wcyB3b3JraW5nXHJcblxyXG5cdFx0TC5VdGlsLmZhbHNlRm4oZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwubWFya2VyQ2x1c3Rlckdyb3VwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFya2VyQ2x1c3Rlckdyb3VwKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlckdyb3VwLmpzIiwiZXhwb3J0IHZhciBNYXJrZXJDbHVzdGVyID0gTC5NYXJrZXJDbHVzdGVyID0gTC5NYXJrZXIuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiBMLkljb24ucHJvdG90eXBlLm9wdGlvbnMsXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChncm91cCwgem9vbSwgYSwgYikge1xyXG5cclxuXHRcdEwuTWFya2VyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYSA/IChhLl9jTGF0TG5nIHx8IGEuZ2V0TGF0TG5nKCkpIDogbmV3IEwuTGF0TG5nKDAsIDApLFxyXG4gICAgICAgICAgICB7IGljb246IHRoaXMsIHBhbmU6IGdyb3VwLm9wdGlvbnMuY2x1c3RlclBhbmUgfSk7XHJcblxyXG5cdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX21hcmtlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2NoaWxkQ291bnQgPSAwO1xyXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGlmIChhKSB7XHJcblx0XHRcdHRoaXMuX2FkZENoaWxkKGEpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGIpIHtcclxuXHRcdFx0dGhpcy5fYWRkQ2hpbGQoYik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9SZWN1cnNpdmVseSByZXRyaWV2ZSBhbGwgY2hpbGQgbWFya2VycyBvZiB0aGlzIGNsdXN0ZXJcclxuXHRnZXRBbGxDaGlsZE1hcmtlcnM6IGZ1bmN0aW9uIChzdG9yYWdlQXJyYXkpIHtcclxuXHRcdHN0b3JhZ2VBcnJheSA9IHN0b3JhZ2VBcnJheSB8fCBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2ldLmdldEFsbENoaWxkTWFya2VycyhzdG9yYWdlQXJyYXkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGogPSB0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcblx0XHRcdHN0b3JhZ2VBcnJheS5wdXNoKHRoaXMuX21hcmtlcnNbal0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdG9yYWdlQXJyYXk7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRoZSBjb3VudCBvZiBob3cgbWFueSBjaGlsZCBtYXJrZXJzIHdlIGhhdmVcclxuXHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDb3VudDtcclxuXHR9LFxyXG5cclxuXHQvL1pvb20gdG8gdGhlIG1pbmltdW0gb2Ygc2hvd2luZyBhbGwgb2YgdGhlIGNoaWxkIG1hcmtlcnMsIG9yIHRoZSBleHRlbnRzIG9mIHRoaXMgY2x1c3RlclxyXG5cdHpvb21Ub0JvdW5kczogZnVuY3Rpb24gKGZpdEJvdW5kc09wdGlvbnMpIHtcclxuXHRcdHZhciBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycy5zbGljZSgpLFxyXG5cdFx0XHRtYXAgPSB0aGlzLl9ncm91cC5fbWFwLFxyXG5cdFx0XHRib3VuZHNab29tID0gbWFwLmdldEJvdW5kc1pvb20odGhpcy5fYm91bmRzKSxcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb20gKyAxLFxyXG5cdFx0XHRtYXBab29tID0gbWFwLmdldFpvb20oKSxcclxuXHRcdFx0aTtcclxuXHJcblx0XHQvL2NhbGN1bGF0ZSBob3cgZmFyIHdlIG5lZWQgdG8gem9vbSBkb3duIHRvIHNlZSBhbGwgb2YgdGhlIG1hcmtlcnNcclxuXHRcdHdoaWxlIChjaGlsZENsdXN0ZXJzLmxlbmd0aCA+IDAgJiYgYm91bmRzWm9vbSA+IHpvb20pIHtcclxuXHRcdFx0em9vbSsrO1xyXG5cdFx0XHR2YXIgbmV3Q2x1c3RlcnMgPSBbXTtcclxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkQ2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRuZXdDbHVzdGVycyA9IG5ld0NsdXN0ZXJzLmNvbmNhdChjaGlsZENsdXN0ZXJzW2ldLl9jaGlsZENsdXN0ZXJzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjaGlsZENsdXN0ZXJzID0gbmV3Q2x1c3RlcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGJvdW5kc1pvb20gPiB6b29tKSB7XHJcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIHpvb20pO1xyXG5cdFx0fSBlbHNlIGlmIChib3VuZHNab29tIDw9IG1hcFpvb20pIHsgLy9JZiBmaXRCb3VuZHMgd291bGRuJ3Qgem9vbSB1cyBkb3duLCB6b29tIHVzIGRvd24gaW5zdGVhZFxyXG5cdFx0XHR0aGlzLl9ncm91cC5fbWFwLnNldFZpZXcodGhpcy5fbGF0bG5nLCBtYXBab29tICsgMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9ncm91cC5fbWFwLmZpdEJvdW5kcyh0aGlzLl9ib3VuZHMsIGZpdEJvdW5kc09wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xyXG5cdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9ib3VuZHMpO1xyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdHRoaXMuc2V0SWNvbih0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL0NsdWRnZSBmb3IgSWNvbiwgd2UgcHJldGVuZCB0byBiZSBhbiBpY29uIGZvciBwZXJmb3JtYW5jZVxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9pY29uTmVlZHNVcGRhdGUpIHtcclxuXHRcdFx0dGhpcy5faWNvbk9iaiA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHRoaXMpO1xyXG5cdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZUljb24oKTtcclxuXHR9LFxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblxyXG5cdF9hZGRDaGlsZDogZnVuY3Rpb24gKG5ldzEsIGlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblxyXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3NldENsdXN0ZXJDZW50ZXIobmV3MSk7XHJcblxyXG5cdFx0aWYgKG5ldzEgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcclxuXHRcdFx0aWYgKCFpc05vdGlmaWNhdGlvbkZyb21DaGlsZCkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnMucHVzaChuZXcxKTtcclxuXHRcdFx0XHRuZXcxLl9fcGFyZW50ID0gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9jaGlsZENvdW50ICs9IG5ldzEuX2NoaWxkQ291bnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFya2Vycy5wdXNoKG5ldzEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2NoaWxkQ291bnQrKztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fX3BhcmVudCkge1xyXG5cdFx0XHR0aGlzLl9fcGFyZW50Ll9hZGRDaGlsZChuZXcxLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBNYWtlcyBzdXJlIHRoZSBjbHVzdGVyIGNlbnRlciBpcyBzZXQuIElmIG5vdCwgdXNlcyB0aGUgY2hpbGQgY2VudGVyIGlmIGl0IGlzIGEgY2x1c3Rlciwgb3IgdGhlIG1hcmtlciBwb3NpdGlvbi5cclxuXHQgKiBAcGFyYW0gY2hpbGQgTC5NYXJrZXJDbHVzdGVyfEwuTWFya2VyIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGNsdXN0ZXIgY2VudGVyIGlmIG5vdCBkZWZpbmVkIHlldC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9zZXRDbHVzdGVyQ2VudGVyOiBmdW5jdGlvbiAoY2hpbGQpIHtcclxuXHRcdGlmICghdGhpcy5fY0xhdExuZykge1xyXG5cdFx0XHQvLyB3aGVuIGNsdXN0ZXJpbmcsIHRha2UgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGFzIHRoZSBjbHVzdGVyIGNlbnRlclxyXG5cdFx0XHR0aGlzLl9jTGF0TG5nID0gY2hpbGQuX2NMYXRMbmcgfHwgY2hpbGQuX2xhdGxuZztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBc3NpZ25zIGltcG9zc2libGUgYm91bmRpbmcgdmFsdWVzIHNvIHRoYXQgdGhlIG5leHQgZXh0ZW5kIGVudGlyZWx5IGRldGVybWluZXMgdGhlIG5ldyBib3VuZHMuXHJcblx0ICogVGhpcyBtZXRob2QgYXZvaWRzIGhhdmluZyB0byB0cmFzaCB0aGUgcHJldmlvdXMgTC5MYXRMbmdCb3VuZHMgb2JqZWN0IGFuZCB0byBjcmVhdGUgYSBuZXcgb25lLCB3aGljaCBpcyBtdWNoIHNsb3dlciBmb3IgdGhpcyBjbGFzcy5cclxuXHQgKiBBcyBsb25nIGFzIHRoZSBib3VuZHMgYXJlIG5vdCBleHRlbmRlZCwgbW9zdCBvdGhlciBtZXRob2RzIHdvdWxkIHByb2JhYmx5IGZhaWwsIGFzIHRoZXkgd291bGQgd2l0aCBib3VuZHMgaW5pdGlhbGl6ZWQgYnV0IG5vdCBleHRlbmRlZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZXNldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuXHJcblx0XHRpZiAoYm91bmRzLl9zb3V0aFdlc3QpIHtcclxuXHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gSW5maW5pdHk7XHJcblx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxuZyA9IEluZmluaXR5O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGJvdW5kcy5fbm9ydGhFYXN0KSB7XHJcblx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IC1JbmZpbml0eTtcclxuXHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubG5nID0gLUluZmluaXR5O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZWNhbGN1bGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLFxyXG5cdFx0ICAgIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0ICAgIGxhdFN1bSA9IDAsXHJcblx0XHQgICAgbG5nU3VtID0gMCxcclxuXHRcdCAgICB0b3RhbENvdW50ID0gdGhpcy5fY2hpbGRDb3VudCxcclxuXHRcdCAgICBpLCBjaGlsZCwgY2hpbGRMYXRMbmcsIGNoaWxkQ291bnQ7XHJcblxyXG5cdFx0Ly8gQ2FzZSB3aGVyZSBhbGwgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYW5kIHdlIGFyZSBsZWZ0IHdpdGgganVzdCBhbiBlbXB0eSBfdG9wQ2x1c3RlckxldmVsLlxyXG5cdFx0aWYgKHRvdGFsQ291bnQgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlc2V0IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG9iamVjdCwgZm9yIHBlcmZvcm1hbmNlLlxyXG5cdFx0dGhpcy5fcmVzZXRCb3VuZHMoKTtcclxuXHJcblx0XHQvLyBDaGlsZCBtYXJrZXJzLlxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Y2hpbGRMYXRMbmcgPSBtYXJrZXJzW2ldLl9sYXRsbmc7XHJcblxyXG5cdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGNoaWxkTGF0TG5nKTtcclxuXHJcblx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQ7XHJcblx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hpbGQgY2x1c3RlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjaGlsZCA9IGNoaWxkQ2x1c3RlcnNbaV07XHJcblxyXG5cdFx0XHQvLyBSZS1jb21wdXRlIGNoaWxkIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb24gZmlyc3QgaWYgbmVjZXNzYXJ5LlxyXG5cdFx0XHRpZiAoY2hpbGQuX2JvdW5kc05lZWRVcGRhdGUpIHtcclxuXHRcdFx0XHRjaGlsZC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChjaGlsZC5fYm91bmRzKTtcclxuXHJcblx0XHRcdGNoaWxkTGF0TG5nID0gY2hpbGQuX3dMYXRMbmc7XHJcblx0XHRcdGNoaWxkQ291bnQgPSBjaGlsZC5fY2hpbGRDb3VudDtcclxuXHJcblx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQgKiBjaGlsZENvdW50O1xyXG5cdFx0XHRsbmdTdW0gKz0gY2hpbGRMYXRMbmcubG5nICogY2hpbGRDb3VudDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXRsbmcgPSB0aGlzLl93TGF0TG5nID0gbmV3IEwuTGF0TG5nKGxhdFN1bSAvIHRvdGFsQ291bnQsIGxuZ1N1bSAvIHRvdGFsQ291bnQpO1xyXG5cclxuXHRcdC8vIFJlc2V0IGRpcnR5IGZsYWcuXHJcblx0XHR0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly9TZXQgb3VyIG1hcmtlcnMgcG9zaXRpb24gYXMgZ2l2ZW4gYW5kIGFkZCBpdCB0byB0aGUgbWFwXHJcblx0X2FkZFRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MpIHtcclxuXHRcdGlmIChzdGFydFBvcykge1xyXG5cdFx0XHR0aGlzLl9iYWNrdXBMYXRsbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHRcdHRoaXMuc2V0TGF0TG5nKHN0YXJ0UG9zKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2dyb3VwLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW46IGZ1bmN0aW9uIChib3VuZHMsIGNlbnRlciwgbWF4Wm9vbSkge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgbWF4Wm9vbSAtIDEsXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBjLl9tYXJrZXJzLFxyXG5cdFx0XHRcdFx0aSwgbTtcclxuXHRcdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdFx0XHQvL09ubHkgZG8gaXQgaWYgdGhlIGljb24gaXMgc3RpbGwgb24gdGhlIG1hcFxyXG5cdFx0XHRcdFx0aWYgKG0uX2ljb24pIHtcclxuXHRcdFx0XHRcdFx0bS5fc2V0UG9zKGNlbnRlcik7XHJcblx0XHRcdFx0XHRcdG0uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSBjLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0XHRcdFx0aiwgY207XHJcblx0XHRcdFx0Zm9yIChqID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdFx0Y20gPSBjaGlsZENsdXN0ZXJzW2pdO1xyXG5cdFx0XHRcdFx0aWYgKGNtLl9pY29uKSB7XHJcblx0XHRcdFx0XHRcdGNtLl9zZXRQb3MoY2VudGVyKTtcclxuXHRcdFx0XHRcdFx0Y20uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW5BbmRBZGRTZWxmVG9NYXA6IGZ1bmN0aW9uIChib3VuZHMsIG1hcE1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCBtYXBNaW5ab29tLFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW4oYm91bmRzLCBjLl9ncm91cC5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChjLmdldExhdExuZygpKS5yb3VuZCgpLCBwcmV2aW91c1pvb21MZXZlbCk7XHJcblxyXG5cdFx0XHRcdC8vVE9ETzogZGVwdGhUb0FuaW1hdGVJbiBhZmZlY3RzIF9pc1NpbmdsZVBhcmVudCwgaWYgdGhlcmUgaXMgYSBtdWx0aXpvb20gd2UgbWF5L21heSBub3QgYmUuXHJcblx0XHRcdFx0Ly9BcyBhIGhhY2sgd2Ugb25seSBkbyBhIGFuaW1hdGlvbiBmcmVlIHpvb20gb24gYSBzaW5nbGUgbGV2ZWwgem9vbSwgaWYgc29tZW9uZSBkb2VzIG11bHRpcGxlIGxldmVscyB0aGVuIHdlIGFsd2F5cyBhbmltYXRlXHJcblx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgLSAxID09PSBuZXdab29tTGV2ZWwpIHtcclxuXHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwpOyAvL0ltbWVkaWF0ZWx5IHJlbW92ZSBvdXIgY2hpbGRyZW4gYXMgd2UgYXJlIHJlcGxhY2luZyB0aGVtLiBUT0RPIHByZXZpb3VzQm91bmRzIG5vdCBib3VuZHNcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Yy5fYWRkVG9NYXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlOiBmdW5jdGlvbiAoYm91bmRzLCB6b29tTGV2ZWwpIHtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCksIHpvb21MZXZlbCwgbnVsbCwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcDogZnVuY3Rpb24gKHN0YXJ0UG9zLCB6b29tTGV2ZWwsIGJvdW5kcykge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSAtIDEsIHpvb21MZXZlbCxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRpZiAoem9vbUxldmVsID09PSBjLl96b29tKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL0FkZCBvdXIgY2hpbGQgbWFya2VycyBhdCBzdGFydFBvcyAoc28gdGhleSBjYW4gYmUgYW5pbWF0ZWQgb3V0KVxyXG5cdFx0XHRcdGZvciAodmFyIGkgPSBjLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHR2YXIgbm0gPSBjLl9tYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG5tLl9sYXRsbmcpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChzdGFydFBvcykge1xyXG5cdFx0XHRcdFx0XHRubS5fYmFja3VwTGF0bG5nID0gbm0uZ2V0TGF0TG5nKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRubS5zZXRMYXRMbmcoc3RhcnRQb3MpO1xyXG5cdFx0XHRcdFx0XHRpZiAobm0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRubS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihubSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGMuX2FkZFRvTWFwKHN0YXJ0UG9zKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnM6IGZ1bmN0aW9uICh6b29tTGV2ZWwpIHtcclxuXHRcdC8vRml4IHBvc2l0aW9ucyBvZiBjaGlsZCBtYXJrZXJzXHJcblx0XHRmb3IgKHZhciBpID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHR2YXIgbm0gPSB0aGlzLl9tYXJrZXJzW2ldO1xyXG5cdFx0XHRpZiAobm0uX2JhY2t1cExhdGxuZykge1xyXG5cdFx0XHRcdG5tLnNldExhdExuZyhubS5fYmFja3VwTGF0bG5nKTtcclxuXHRcdFx0XHRkZWxldGUgbm0uX2JhY2t1cExhdGxuZztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh6b29tTGV2ZWwgLSAxID09PSB0aGlzLl96b29tKSB7XHJcblx0XHRcdC8vUmVwb3NpdGlvbiBjaGlsZCBjbHVzdGVyc1xyXG5cdFx0XHRmb3IgKHZhciBqID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbal0uX3Jlc3RvcmVQb3NpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKHZhciBrID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBrID49IDA7IGstLSkge1xyXG5cdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNba10uX3JlY3Vyc2l2ZWx5UmVzdG9yZUNoaWxkUG9zaXRpb25zKHpvb21MZXZlbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVzdG9yZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fYmFja3VwTGF0bG5nKSB7XHJcblx0XHRcdHRoaXMuc2V0TGF0TG5nKHRoaXMuX2JhY2t1cExhdGxuZyk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9iYWNrdXBMYXRsbmc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9leGNlcHRCb3VuZHM6IElmIHNldCwgZG9uJ3QgcmVtb3ZlIGFueSBtYXJrZXJzL2NsdXN0ZXJzIGluIGl0XHJcblx0X3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwOiBmdW5jdGlvbiAocHJldmlvdXNCb3VuZHMsIG1hcE1pblpvb20sIHpvb21MZXZlbCwgZXhjZXB0Qm91bmRzKSB7XHJcblx0XHR2YXIgbSwgaTtcclxuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KHByZXZpb3VzQm91bmRzLCBtYXBNaW5ab29tIC0gMSwgem9vbUxldmVsIC0gMSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHQvL1JlbW92ZSBtYXJrZXJzIGF0IGV2ZXJ5IGxldmVsXHJcblx0XHRcdFx0Zm9yIChpID0gYy5fbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IGMuX21hcmtlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Ly9SZW1vdmUgY2hpbGQgY2x1c3RlcnMgYXQganVzdCB0aGUgYm90dG9tIGxldmVsXHJcblx0XHRcdFx0Zm9yIChpID0gYy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0bSA9IGMuX2NoaWxkQ2x1c3RlcnNbaV07XHJcblx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0Ly9SdW4gdGhlIGdpdmVuIGZ1bmN0aW9ucyByZWN1cnNpdmVseSB0byB0aGlzIGFuZCBjaGlsZCBjbHVzdGVyc1xyXG5cdC8vIGJvdW5kc1RvQXBwbHlUbzogYSBMLkxhdExuZ0JvdW5kcyByZXByZXNlbnRpbmcgdGhlIGJvdW5kcyBvZiB3aGF0IGNsdXN0ZXJzIHRvIHJlY3Vyc2UgaW4gdG9cclxuXHQvLyB6b29tTGV2ZWxUb1N0YXJ0OiB6b29tIGxldmVsIHRvIHN0YXJ0IHJ1bm5pbmcgZnVuY3Rpb25zIChpbmNsdXNpdmUpXHJcblx0Ly8gem9vbUxldmVsVG9TdG9wOiB6b29tIGxldmVsIHRvIHN0b3AgcnVubmluZyBmdW5jdGlvbnMgKGluY2x1c2l2ZSlcclxuXHQvLyBydW5BdEV2ZXJ5TGV2ZWw6IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gTC5NYXJrZXJDbHVzdGVyIGFzIGFuIGFyZ3VtZW50IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgb24gZXZlcnkgbGV2ZWxcclxuXHQvLyBydW5BdEJvdHRvbUxldmVsOiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIEwuTWFya2VyQ2x1c3RlciBhcyBhbiBhcmd1bWVudCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIGF0IG9ubHkgdGhlIGJvdHRvbSBsZXZlbFxyXG5cdF9yZWN1cnNpdmVseTogZnVuY3Rpb24gKGJvdW5kc1RvQXBwbHlUbywgem9vbUxldmVsVG9TdGFydCwgem9vbUxldmVsVG9TdG9wLCBydW5BdEV2ZXJ5TGV2ZWwsIHJ1bkF0Qm90dG9tTGV2ZWwpIHtcclxuXHRcdHZhciBjaGlsZENsdXN0ZXJzID0gdGhpcy5fY2hpbGRDbHVzdGVycyxcclxuXHRcdCAgICB6b29tID0gdGhpcy5fem9vbSxcclxuXHRcdCAgICBpLCBjO1xyXG5cclxuXHRcdGlmICh6b29tTGV2ZWxUb1N0YXJ0IDw9IHpvb20pIHtcclxuXHRcdFx0aWYgKHJ1bkF0RXZlcnlMZXZlbCkge1xyXG5cdFx0XHRcdHJ1bkF0RXZlcnlMZXZlbCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocnVuQXRCb3R0b21MZXZlbCAmJiB6b29tID09PSB6b29tTGV2ZWxUb1N0b3ApIHtcclxuXHRcdFx0XHRydW5BdEJvdHRvbUxldmVsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHpvb20gPCB6b29tTGV2ZWxUb1N0YXJ0IHx8IHpvb20gPCB6b29tTGV2ZWxUb1N0b3ApIHtcclxuXHRcdFx0Zm9yIChpID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdGMgPSBjaGlsZENsdXN0ZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChib3VuZHNUb0FwcGx5VG8uaW50ZXJzZWN0cyhjLl9ib3VuZHMpKSB7XHJcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseShib3VuZHNUb0FwcGx5VG8sIHpvb21MZXZlbFRvU3RhcnQsIHpvb21MZXZlbFRvU3RvcCwgcnVuQXRFdmVyeUxldmVsLCBydW5BdEJvdHRvbUxldmVsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL1JldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgdGhlIHBhcmVudCBvZiBvbmx5IG9uZSBjbHVzdGVyIGFuZCB0aGF0IGNsdXN0ZXIgaXMgdGhlIHNhbWUgYXMgdXNcclxuXHRfaXNTaW5nbGVQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vRG9uJ3QgbmVlZCB0byBjaGVjayB0aGlzLl9tYXJrZXJzIGFzIHRoZSByZXN0IHdvbid0IHdvcmsgaWYgdGhlcmUgYXJlIGFueVxyXG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiB0aGlzLl9jaGlsZENsdXN0ZXJzWzBdLl9jaGlsZENvdW50ID09PSB0aGlzLl9jaGlsZENvdW50O1xyXG5cdH1cclxufSk7XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlci5qcyIsIlxyXG4vKlxyXG4qIEV4dGVuZHMgTC5NYXJrZXIgdG8gaW5jbHVkZSB0d28gZXh0cmEgbWV0aG9kczogY2x1c3RlckhpZGUgYW5kIGNsdXN0ZXJTaG93LlxyXG4qIFxyXG4qIFRoZXkgd29yayBhcyBzZXRPcGFjaXR5KDApIGFuZCBzZXRPcGFjaXR5KDEpIHJlc3BlY3RpdmVseSwgYnV0XHJcbiogdGhleSB3aWxsIHJlbWVtYmVyIHRoZSBtYXJrZXIncyBvcGFjaXR5IHdoZW4gaGlkaW5nIGFuZCBzaG93aW5nIGl0IGFnYWluLlxyXG4qIFxyXG4qL1xyXG5cclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoe1xyXG5cdFxyXG5cdGNsdXN0ZXJIaWRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eVdoZW5VbmNsdXN0ZXJlZCA9IHRoaXMub3B0aW9ucy5vcGFjaXR5IHx8IDE7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRPcGFjaXR5KDApO1xyXG5cdH0sXHJcblx0XHJcblx0Y2x1c3RlclNob3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciByZXQgPSB0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkgfHwgdGhpcy5vcHRpb25zLm9wYWNpdHlXaGVuVW5jbHVzdGVyZWQpO1xyXG5cdFx0ZGVsZXRlIHRoaXMub3B0aW9ucy5vcGFjaXR5V2hlblVuY2x1c3RlcmVkO1xyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0XHJcbn0pO1xyXG5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJPcGFjaXR5LmpzIiwiXHJcbkwuRGlzdGFuY2VHcmlkID0gZnVuY3Rpb24gKGNlbGxTaXplKSB7XHJcblx0dGhpcy5fY2VsbFNpemUgPSBjZWxsU2l6ZTtcclxuXHR0aGlzLl9zcUNlbGxTaXplID0gY2VsbFNpemUgKiBjZWxsU2l6ZTtcclxuXHR0aGlzLl9ncmlkID0ge307XHJcblx0dGhpcy5fb2JqZWN0UG9pbnQgPSB7IH07XHJcbn07XHJcblxyXG5MLkRpc3RhbmNlR3JpZC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGFkZE9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcclxuXHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXHJcblx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxyXG5cdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxyXG5cdFx0ICAgIGNlbGwgPSByb3dbeF0gPSByb3dbeF0gfHwgW10sXHJcblx0XHQgICAgc3RhbXAgPSBMLlV0aWwuc3RhbXAob2JqKTtcclxuXHJcblx0XHR0aGlzLl9vYmplY3RQb2ludFtzdGFtcF0gPSBwb2ludDtcclxuXHJcblx0XHRjZWxsLnB1c2gob2JqKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XHJcblx0XHR0aGlzLnJlbW92ZU9iamVjdChvYmopO1xyXG5cdFx0dGhpcy5hZGRPYmplY3Qob2JqLCBwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCB3YXMgZm91bmRcclxuXHRyZW1vdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XHJcblx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxyXG5cdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcclxuXHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZCxcclxuXHRcdCAgICByb3cgPSBncmlkW3ldID0gZ3JpZFt5XSB8fCB7fSxcclxuXHRcdCAgICBjZWxsID0gcm93W3hdID0gcm93W3hdIHx8IFtdLFxyXG5cdFx0ICAgIGksIGxlbjtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5fb2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGNlbGxbaV0gPT09IG9iaikge1xyXG5cclxuXHRcdFx0XHRjZWxsLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdFx0aWYgKGxlbiA9PT0gMSkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHJvd1t4XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGVhY2hPYmplY3Q6IGZ1bmN0aW9uIChmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGksIGosIGssIGxlbiwgcm93LCBjZWxsLCByZW1vdmVkLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkO1xyXG5cclxuXHRcdGZvciAoaSBpbiBncmlkKSB7XHJcblx0XHRcdHJvdyA9IGdyaWRbaV07XHJcblxyXG5cdFx0XHRmb3IgKGogaW4gcm93KSB7XHJcblx0XHRcdFx0Y2VsbCA9IHJvd1tqXTtcclxuXHJcblx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xyXG5cdFx0XHRcdFx0cmVtb3ZlZCA9IGZuLmNhbGwoY29udGV4dCwgY2VsbFtrXSk7XHJcblx0XHRcdFx0XHRpZiAocmVtb3ZlZCkge1xyXG5cdFx0XHRcdFx0XHRrLS07XHJcblx0XHRcdFx0XHRcdGxlbi0tO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldE5lYXJPYmplY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcclxuXHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXHJcblx0XHQgICAgaSwgaiwgaywgcm93LCBjZWxsLCBsZW4sIG9iaiwgZGlzdCxcclxuXHRcdCAgICBvYmplY3RQb2ludCA9IHRoaXMuX29iamVjdFBvaW50LFxyXG5cdFx0ICAgIGNsb3Nlc3REaXN0U3EgPSB0aGlzLl9zcUNlbGxTaXplLFxyXG5cdFx0ICAgIGNsb3Nlc3QgPSBudWxsO1xyXG5cclxuXHRcdGZvciAoaSA9IHkgLSAxOyBpIDw9IHkgKyAxOyBpKyspIHtcclxuXHRcdFx0cm93ID0gdGhpcy5fZ3JpZFtpXTtcclxuXHRcdFx0aWYgKHJvdykge1xyXG5cclxuXHRcdFx0XHRmb3IgKGogPSB4IC0gMTsgaiA8PSB4ICsgMTsgaisrKSB7XHJcblx0XHRcdFx0XHRjZWxsID0gcm93W2pdO1xyXG5cdFx0XHRcdFx0aWYgKGNlbGwpIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRvYmogPSBjZWxsW2tdO1xyXG5cdFx0XHRcdFx0XHRcdGRpc3QgPSB0aGlzLl9zcURpc3Qob2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildLCBwb2ludCk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdFNxIHx8XHJcblx0XHRcdFx0XHRcdFx0XHRkaXN0IDw9IGNsb3Nlc3REaXN0U3EgJiYgY2xvc2VzdCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RTcSA9IGRpc3Q7XHJcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gb2JqO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XHJcblx0fSxcclxuXHJcblx0X2dldENvb3JkOiBmdW5jdGlvbiAoeCkge1xyXG5cdFx0dmFyIGNvb3JkID0gTWF0aC5mbG9vcih4IC8gdGhpcy5fY2VsbFNpemUpO1xyXG5cdFx0cmV0dXJuIGlzRmluaXRlKGNvb3JkKSA/IGNvb3JkIDogeDtcclxuXHR9LFxyXG5cclxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocCwgcDIpIHtcclxuXHRcdHZhciBkeCA9IHAyLnggLSBwLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcC55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL0Rpc3RhbmNlR3JpZC5qcyIsIi8qIENvcHlyaWdodCAoYykgMjAxMiB0aGUgYXV0aG9ycyBsaXN0ZWQgYXQgdGhlIGZvbGxvd2luZyBVUkwsIGFuZC9vclxyXG50aGUgYXV0aG9ycyBvZiByZWZlcmVuY2VkIGFydGljbGVzIG9yIGluY29ycG9yYXRlZCBleHRlcm5hbCBjb2RlOlxyXG5odHRwOi8vZW4ubGl0ZXJhdGVwcm9ncmFtcy5vcmcvUXVpY2todWxsXyhKYXZhc2NyaXB0KT9hY3Rpb249aGlzdG9yeSZvZmZzZXQ9MjAxMjA0MTAxNzUyNTZcclxuXHJcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXHJcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXHJcblRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXHJcblNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG5cclxuUmV0cmlldmVkIGZyb206IGh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP29sZGlkPTE4NDM0XHJcbiovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cdEwuUXVpY2tIdWxsID0ge1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gY3B0IGEgcG9pbnQgdG8gYmUgbWVhc3VyZWQgZnJvbSB0aGUgYmFzZWxpbmVcclxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJsIHRoZSBiYXNlbGluZSwgYXMgcmVwcmVzZW50ZWQgYnkgYSB0d28tZWxlbWVudFxyXG5cdFx0ICogICBhcnJheSBvZiBsYXRsbmcgb2JqZWN0cy5cclxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IGFuIGFwcHJveGltYXRlIGRpc3RhbmNlIG1lYXN1cmVcclxuXHRcdCAqL1xyXG5cdFx0Z2V0RGlzdGFudDogZnVuY3Rpb24gKGNwdCwgYmwpIHtcclxuXHRcdFx0dmFyIHZZID0gYmxbMV0ubGF0IC0gYmxbMF0ubGF0LFxyXG5cdFx0XHRcdHZYID0gYmxbMF0ubG5nIC0gYmxbMV0ubG5nO1xyXG5cdFx0XHRyZXR1cm4gKHZYICogKGNwdC5sYXQgLSBibFswXS5sYXQpICsgdlkgKiAoY3B0LmxuZyAtIGJsWzBdLmxuZykpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYmFzZUxpbmUgYSB0d28tZWxlbWVudCBhcnJheSBvZiBsYXRsbmcgb2JqZWN0c1xyXG5cdFx0ICogICByZXByZXNlbnRpbmcgdGhlIGJhc2VsaW5lIHRvIHByb2plY3QgZnJvbVxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5ncyBhbiBhcnJheSBvZiBsYXRsbmcgb2JqZWN0c1xyXG5cdFx0ICogQHJldHVybnMge09iamVjdH0gdGhlIG1heGltdW0gcG9pbnQgYW5kIGFsbCBuZXcgcG9pbnRzIHRvIHN0YXlcclxuXHRcdCAqICAgaW4gY29uc2lkZXJhdGlvbiBmb3IgdGhlIGh1bGwuXHJcblx0XHQgKi9cclxuXHRcdGZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcclxuXHRcdFx0dmFyIG1heEQgPSAwLFxyXG5cdFx0XHRcdG1heFB0ID0gbnVsbCxcclxuXHRcdFx0XHRuZXdQb2ludHMgPSBbXSxcclxuXHRcdFx0XHRpLCBwdCwgZDtcclxuXHJcblx0XHRcdGZvciAoaSA9IGxhdExuZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRwdCA9IGxhdExuZ3NbaV07XHJcblx0XHRcdFx0ZCA9IHRoaXMuZ2V0RGlzdGFudChwdCwgYmFzZUxpbmUpO1xyXG5cclxuXHRcdFx0XHRpZiAoZCA+IDApIHtcclxuXHRcdFx0XHRcdG5ld1BvaW50cy5wdXNoKHB0KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZCA+IG1heEQpIHtcclxuXHRcdFx0XHRcdG1heEQgPSBkO1xyXG5cdFx0XHRcdFx0bWF4UHQgPSBwdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7IG1heFBvaW50OiBtYXhQdCwgbmV3UG9pbnRzOiBuZXdQb2ludHMgfTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBHaXZlbiBhIGJhc2VsaW5lLCBjb21wdXRlIHRoZSBjb252ZXggaHVsbCBvZiBsYXRMbmdzIGFzIGFuIGFycmF5XHJcblx0XHQgKiBvZiBsYXRMbmdzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGxhdExuZ3NcclxuXHRcdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHRcdCAqL1xyXG5cdFx0YnVpbGRDb252ZXhIdWxsOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcclxuXHRcdFx0dmFyIGNvbnZleEh1bGxCYXNlTGluZXMgPSBbXSxcclxuXHRcdFx0XHR0ID0gdGhpcy5maW5kTW9zdERpc3RhbnRQb2ludEZyb21CYXNlTGluZShiYXNlTGluZSwgbGF0TG5ncyk7XHJcblxyXG5cdFx0XHRpZiAodC5tYXhQb2ludCkgeyAvLyBpZiB0aGVyZSBpcyBzdGlsbCBhIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmVcclxuXHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzID1cclxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbYmFzZUxpbmVbMF0sIHQubWF4UG9pbnRdLCB0Lm5ld1BvaW50cylcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcyA9XHJcblx0XHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzLmNvbmNhdChcclxuXHRcdFx0XHRcdFx0dGhpcy5idWlsZENvbnZleEh1bGwoW3QubWF4UG9pbnQsIGJhc2VMaW5lWzFdXSwgdC5uZXdQb2ludHMpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdHJldHVybiBjb252ZXhIdWxsQmFzZUxpbmVzO1xyXG5cdFx0XHR9IGVsc2UgeyAgLy8gaWYgdGhlcmUgaXMgbm8gbW9yZSBwb2ludCBcIm91dHNpZGVcIiB0aGUgYmFzZSBsaW5lLCB0aGUgY3VycmVudCBiYXNlIGxpbmUgaXMgcGFydCBvZiB0aGUgY29udmV4IGh1bGxcclxuXHRcdFx0XHRyZXR1cm4gW2Jhc2VMaW5lWzBdXTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogR2l2ZW4gYW4gYXJyYXkgb2YgbGF0bG5ncywgY29tcHV0ZSBhIGNvbnZleCBodWxsIGFzIGFuIGFycmF5XHJcblx0XHQgKiBvZiBsYXRsbmdzXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5nc1xyXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdFx0ICovXHJcblx0XHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAobGF0TG5ncykge1xyXG5cdFx0XHQvLyBmaW5kIGZpcnN0IGJhc2VsaW5lXHJcblx0XHRcdHZhciBtYXhMYXQgPSBmYWxzZSwgbWluTGF0ID0gZmFsc2UsXHJcblx0XHRcdFx0bWF4TG5nID0gZmFsc2UsIG1pbkxuZyA9IGZhbHNlLFxyXG5cdFx0XHRcdG1heExhdFB0ID0gbnVsbCwgbWluTGF0UHQgPSBudWxsLFxyXG5cdFx0XHRcdG1heExuZ1B0ID0gbnVsbCwgbWluTG5nUHQgPSBudWxsLFxyXG5cdFx0XHRcdG1heFB0ID0gbnVsbCwgbWluUHQgPSBudWxsLFxyXG5cdFx0XHRcdGk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSBsYXRMbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0dmFyIHB0ID0gbGF0TG5nc1tpXTtcclxuXHRcdFx0XHRpZiAobWF4TGF0ID09PSBmYWxzZSB8fCBwdC5sYXQgPiBtYXhMYXQpIHtcclxuXHRcdFx0XHRcdG1heExhdFB0ID0gcHQ7XHJcblx0XHRcdFx0XHRtYXhMYXQgPSBwdC5sYXQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtaW5MYXQgPT09IGZhbHNlIHx8IHB0LmxhdCA8IG1pbkxhdCkge1xyXG5cdFx0XHRcdFx0bWluTGF0UHQgPSBwdDtcclxuXHRcdFx0XHRcdG1pbkxhdCA9IHB0LmxhdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1heExuZyA9PT0gZmFsc2UgfHwgcHQubG5nID4gbWF4TG5nKSB7XHJcblx0XHRcdFx0XHRtYXhMbmdQdCA9IHB0O1xyXG5cdFx0XHRcdFx0bWF4TG5nID0gcHQubG5nO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobWluTG5nID09PSBmYWxzZSB8fCBwdC5sbmcgPCBtaW5MbmcpIHtcclxuXHRcdFx0XHRcdG1pbkxuZ1B0ID0gcHQ7XHJcblx0XHRcdFx0XHRtaW5MbmcgPSBwdC5sbmc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAobWluTGF0ICE9PSBtYXhMYXQpIHtcclxuXHRcdFx0XHRtaW5QdCA9IG1pbkxhdFB0O1xyXG5cdFx0XHRcdG1heFB0ID0gbWF4TGF0UHQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bWluUHQgPSBtaW5MbmdQdDtcclxuXHRcdFx0XHRtYXhQdCA9IG1heExuZ1B0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY2ggPSBbXS5jb25jYXQodGhpcy5idWlsZENvbnZleEh1bGwoW21pblB0LCBtYXhQdF0sIGxhdExuZ3MpLFxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5idWlsZENvbnZleEh1bGwoW21heFB0LCBtaW5QdF0sIGxhdExuZ3MpKTtcclxuXHRcdFx0cmV0dXJuIGNoO1xyXG5cdFx0fVxyXG5cdH07XHJcbn0oKSk7XHJcblxyXG5MLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XHJcblx0Z2V0Q29udmV4SHVsbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCksXHJcblx0XHRcdHBvaW50cyA9IFtdLFxyXG5cdFx0XHRwLCBpO1xyXG5cclxuXHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRwID0gY2hpbGRNYXJrZXJzW2ldLmdldExhdExuZygpO1xyXG5cdFx0XHRwb2ludHMucHVzaChwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTC5RdWlja0h1bGwuZ2V0Q29udmV4SHVsbChwb2ludHMpO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyLlF1aWNrSHVsbC5qcyIsIi8vVGhpcyBjb2RlIGlzIDEwMCUgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2phd2ovT3ZlcmxhcHBpbmdNYXJrZXJTcGlkZXJmaWVyLUxlYWZsZXRcclxuLy9IdWdlIHRoYW5rcyB0byBqYXdqIGZvciBpbXBsZW1lbnRpbmcgaXQgZmlyc3QgdG8gbWFrZSBteSBqb2IgZWFzeSA6LSlcclxuXHJcbkwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcclxuXHJcblx0XzJQSTogTWF0aC5QSSAqIDIsXHJcblx0X2NpcmNsZUZvb3RTZXBhcmF0aW9uOiAyNSwgLy9yZWxhdGVkIHRvIGNpcmN1bWZlcmVuY2Ugb2YgY2lyY2xlXHJcblx0X2NpcmNsZVN0YXJ0QW5nbGU6IDAsXHJcblxyXG5cdF9zcGlyYWxGb290U2VwYXJhdGlvbjogIDI4LCAvL3JlbGF0ZWQgdG8gc2l6ZSBvZiBzcGlyYWwgKGV4cGVyaW1lbnQhKVxyXG5cdF9zcGlyYWxMZW5ndGhTdGFydDogMTEsXHJcblx0X3NwaXJhbExlbmd0aEZhY3RvcjogNSxcclxuXHJcblx0X2NpcmNsZVNwaXJhbFN3aXRjaG92ZXI6IDksIC8vc2hvdyBzcGlyYWwgaW5zdGVhZCBvZiBjaXJjbGUgZnJvbSB0aGlzIG1hcmtlciBjb3VudCB1cHdhcmRzLlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gMCAtPiBhbHdheXMgc3BpcmFsOyBJbmZpbml0eSAtPiBhbHdheXMgY2lyY2xlXHJcblxyXG5cdHNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPT09IHRoaXMgfHwgdGhpcy5fZ3JvdXAuX2luWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCksXHJcblx0XHRcdGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGNlbnRlciA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdFx0cG9zaXRpb25zO1xyXG5cclxuXHRcdHRoaXMuX2dyb3VwLl91bnNwaWRlcmZ5KCk7XHJcblx0XHR0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9IHRoaXM7XHJcblxyXG5cdFx0Ly9UT0RPIE1heWJlOiBjaGlsZE1hcmtlcnMgb3JkZXIgYnkgZGlzdGFuY2UgdG8gY2VudGVyXHJcblxyXG5cdFx0aWYgKGNoaWxkTWFya2Vycy5sZW5ndGggPj0gdGhpcy5fY2lyY2xlU3BpcmFsU3dpdGNob3Zlcikge1xyXG5cdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c1NwaXJhbChjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y2VudGVyLnkgKz0gMTA7IC8vIE90aGVyd2lzZSBjaXJjbGVzIGxvb2sgd3JvbmcgPT4gaGFjayBmb3Igc3RhbmRhcmQgYmx1ZSBpY29uLCByZW5kZXJzIGRpZmZlcmVudGx5IGZvciBvdGhlciBpY29ucy5cclxuXHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNDaXJjbGUoY2hpbGRNYXJrZXJzLmxlbmd0aCwgY2VudGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpb25TcGlkZXJmeShjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0dW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XHJcblx0XHQvLy8gPHBhcmFtIE5hbWU9XCJ6b29tRGV0YWlsc1wiPkFyZ3VtZW50IGZyb20gem9vbWFuaW0gaWYgYmVpbmcgY2FsbGVkIGluIGEgem9vbSBhbmltYXRpb24gb3IgbnVsbCBvdGhlcndpc2U8L3BhcmFtPlxyXG5cdFx0aWYgKHRoaXMuX2dyb3VwLl9pblpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fYW5pbWF0aW9uVW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XHJcblxyXG5cdFx0dGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9nZW5lcmF0ZVBvaW50c0NpcmNsZTogZnVuY3Rpb24gKGNvdW50LCBjZW50ZXJQdCkge1xyXG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fY2lyY2xlRm9vdFNlcGFyYXRpb24gKiAoMiArIGNvdW50KSxcclxuXHRcdFx0bGVnTGVuZ3RoID0gY2lyY3VtZmVyZW5jZSAvIHRoaXMuXzJQSSwgIC8vcmFkaXVzIGZyb20gY2lyY3VtZmVyZW5jZVxyXG5cdFx0XHRhbmdsZVN0ZXAgPSB0aGlzLl8yUEkgLyBjb3VudCxcclxuXHRcdFx0cmVzID0gW10sXHJcblx0XHRcdGksIGFuZ2xlO1xyXG5cclxuXHRcdGxlZ0xlbmd0aCA9IE1hdGgubWF4KGxlZ0xlbmd0aCwgMzUpOyAvLyBNaW5pbXVtIGRpc3RhbmNlIHRvIGdldCBvdXRzaWRlIHRoZSBjbHVzdGVyIGljb24uXHJcblxyXG5cdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7IC8vIENsb2Nrd2lzZSwgbGlrZSBzcGlyYWwuXHJcblx0XHRcdGFuZ2xlID0gdGhpcy5fY2lyY2xlU3RhcnRBbmdsZSArIGkgKiBhbmdsZVN0ZXA7XHJcblx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXM7XHJcblx0fSxcclxuXHJcblx0X2dlbmVyYXRlUG9pbnRzU3BpcmFsOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XHJcblx0XHR2YXIgc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgPSB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyLFxyXG5cdFx0XHRsZWdMZW5ndGggPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aFN0YXJ0LFxyXG5cdFx0XHRzZXBhcmF0aW9uID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxGb290U2VwYXJhdGlvbixcclxuXHRcdFx0bGVuZ3RoRmFjdG9yID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhGYWN0b3IgKiB0aGlzLl8yUEksXHJcblx0XHRcdGFuZ2xlID0gMCxcclxuXHRcdFx0cmVzID0gW10sXHJcblx0XHRcdGk7XHJcblxyXG5cdFx0cmVzLmxlbmd0aCA9IGNvdW50O1xyXG5cclxuXHRcdC8vIEhpZ2hlciBpbmRleCwgY2xvc2VyIHBvc2l0aW9uIHRvIGNsdXN0ZXIgY2VudGVyLlxyXG5cdFx0Zm9yIChpID0gY291bnQ7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdC8vIFNraXAgdGhlIGZpcnN0IHBvc2l0aW9uLCBzbyB0aGF0IHdlIGFyZSBhbHJlYWR5IGZhcnRoZXIgZnJvbSBjZW50ZXIgYW5kIHdlIGF2b2lkXHJcblx0XHRcdC8vIGJlaW5nIHVuZGVyIHRoZSBkZWZhdWx0IGNsdXN0ZXIgaWNvbiAoZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIENpcmNsZSBNYXJrZXJzKS5cclxuXHRcdFx0aWYgKGkgPCBjb3VudCkge1xyXG5cdFx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFuZ2xlICs9IHNlcGFyYXRpb24gLyBsZWdMZW5ndGggKyBpICogMC4wMDA1O1xyXG5cdFx0XHRsZWdMZW5ndGggKz0gbGVuZ3RoRmFjdG9yIC8gYW5nbGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH0sXHJcblxyXG5cdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBncm91cCA9IHRoaXMuX2dyb3VwLFxyXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxyXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCksXHJcblx0XHRcdG0sIGk7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcclxuXHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblxyXG5cdFx0XHRpZiAobS5fcHJlU3BpZGVyZnlMYXRsbmcpIHtcclxuXHRcdFx0XHRtLnNldExhdExuZyhtLl9wcmVTcGlkZXJmeUxhdGxuZyk7XHJcblx0XHRcdFx0ZGVsZXRlIG0uX3ByZVNwaWRlcmZ5TGF0bG5nO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xyXG5cdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobS5fc3BpZGVyTGVnKSB7XHJcblx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKG0uX3NwaWRlckxlZyk7XHJcblx0XHRcdFx0ZGVsZXRlIG0uX3NwaWRlckxlZztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLmZpcmUoJ3Vuc3BpZGVyZmllZCcsIHtcclxuXHRcdFx0Y2x1c3RlcjogdGhpcyxcclxuXHRcdFx0bWFya2VyczogY2hpbGRNYXJrZXJzXHJcblx0XHR9KTtcclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XHJcblx0XHRncm91cC5fc3BpZGVyZmllZCA9IG51bGw7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vTm9uIEFuaW1hdGVkIHZlcnNpb25zIG9mIGV2ZXJ5dGhpbmdcclxuTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQgPSBMLk1hcmtlckNsdXN0ZXIuZXh0ZW5kKHtcclxuXHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xyXG5cdFx0dmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0bGVnT3B0aW9ucyA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zLFxyXG5cdFx0XHRpLCBtLCBsZWcsIG5ld1BvcztcclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XHJcblxyXG5cdFx0Ly8gVHJhdmVyc2UgaW4gYXNjZW5kaW5nIG9yZGVyIHRvIG1ha2Ugc3VyZSB0aGF0IGlubmVyIGNpcmNsZU1hcmtlcnMgYXJlIG9uIHRvcCBvZiBmdXJ0aGVyIGxlZ3MuIE5vcm1hbCBtYXJrZXJzIGFyZSByZS1vcmRlcmVkIGJ5IG5ld1Bvc2l0aW9uLlxyXG5cdFx0Ly8gVGhlIHJldmVyc2Ugb3JkZXIgdHJpY2sgbm8gbG9uZ2VyIGltcHJvdmVzIHBlcmZvcm1hbmNlIG9uIG1vZGVybiBicm93c2Vycy5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZE1hcmtlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bmV3UG9zID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb3NpdGlvbnNbaV0pO1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0Ly8gQWRkIHRoZSBsZWcgYmVmb3JlIHRoZSBtYXJrZXIsIHNvIHRoYXQgaW4gY2FzZSB0aGUgbGF0dGVyIGlzIGEgY2lyY2xlTWFya2VyLCB0aGUgbGVnIGlzIGJlaGluZCBpdC5cclxuXHRcdFx0bGVnID0gbmV3IEwuUG9seWxpbmUoW3RoaXMuX2xhdGxuZywgbmV3UG9zXSwgbGVnT3B0aW9ucyk7XHJcblx0XHRcdG1hcC5hZGRMYXllcihsZWcpO1xyXG5cdFx0XHRtLl9zcGlkZXJMZWcgPSBsZWc7XHJcblxyXG5cdFx0XHQvLyBOb3cgYWRkIHRoZSBtYXJrZXIuXHJcblx0XHRcdG0uX3ByZVNwaWRlcmZ5TGF0bG5nID0gbS5fbGF0bG5nO1xyXG5cdFx0XHRtLnNldExhdExuZyhuZXdQb3MpO1xyXG5cdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy9NYWtlIHRoZXNlIGFwcGVhciBvbiB0b3Agb2YgRVZFUllUSElOR1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmZy5hZGRMYXllcihtKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuc2V0T3BhY2l0eSgwLjMpO1xyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XHJcblx0XHRncm91cC5maXJlKCdzcGlkZXJmaWVkJywge1xyXG5cdFx0XHRjbHVzdGVyOiB0aGlzLFxyXG5cdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRpb25VbnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy9BbmltYXRlZCB2ZXJzaW9ucyBoZXJlXHJcbkwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcclxuXHJcblx0X2FuaW1hdGlvblNwaWRlcmZ5OiBmdW5jdGlvbiAoY2hpbGRNYXJrZXJzLCBwb3NpdGlvbnMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXMsXHJcblx0XHRcdGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0dGhpc0xheWVyTGF0TG5nID0gdGhpcy5fbGF0bG5nLFxyXG5cdFx0XHR0aGlzTGF5ZXJQb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXNMYXllckxhdExuZyksXHJcblx0XHRcdHN2ZyA9IEwuUGF0aC5TVkcsXHJcblx0XHRcdGxlZ09wdGlvbnMgPSBMLmV4dGVuZCh7fSwgdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMpLCAvLyBDb3B5IHRoZSBvcHRpb25zIHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB0aGVtIGZvciBhbmltYXRpb24uXHJcblx0XHRcdGZpbmFsTGVnT3BhY2l0eSA9IGxlZ09wdGlvbnMub3BhY2l0eSxcclxuXHRcdFx0aSwgbSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5ld1BvcztcclxuXHJcblx0XHRpZiAoZmluYWxMZWdPcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZmluYWxMZWdPcGFjaXR5ID0gTC5NYXJrZXJDbHVzdGVyR3JvdXAucHJvdG90eXBlLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zLm9wYWNpdHk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN2Zykge1xyXG5cdFx0XHQvLyBJZiB0aGUgaW5pdGlhbCBvcGFjaXR5IG9mIHRoZSBzcGlkZXIgbGVnIGlzIG5vdCAwIHRoZW4gaXQgYXBwZWFycyBiZWZvcmUgdGhlIGFuaW1hdGlvbiBzdGFydHMuXHJcblx0XHRcdGxlZ09wdGlvbnMub3BhY2l0eSA9IDA7XHJcblxyXG5cdFx0XHQvLyBBZGQgdGhlIGNsYXNzIGZvciBDU1MgdHJhbnNpdGlvbnMuXHJcblx0XHRcdGxlZ09wdGlvbnMuY2xhc3NOYW1lID0gKGxlZ09wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC1jbHVzdGVyLXNwaWRlci1sZWcnO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGhhdmUgYSBkZWZpbmVkIG9wYWNpdHkuXHJcblx0XHRcdGxlZ09wdGlvbnMub3BhY2l0eSA9IGZpbmFsTGVnT3BhY2l0eTtcclxuXHRcdH1cclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XHJcblxyXG5cdFx0Ly8gQWRkIG1hcmtlcnMgYW5kIHNwaWRlciBsZWdzIHRvIG1hcCwgaGlkZGVuIGF0IG91ciBjZW50ZXIgcG9pbnQuXHJcblx0XHQvLyBUcmF2ZXJzZSBpbiBhc2NlbmRpbmcgb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgaW5uZXIgY2lyY2xlTWFya2VycyBhcmUgb24gdG9wIG9mIGZ1cnRoZXIgbGVncy4gTm9ybWFsIG1hcmtlcnMgYXJlIHJlLW9yZGVyZWQgYnkgbmV3UG9zaXRpb24uXHJcblx0XHQvLyBUaGUgcmV2ZXJzZSBvcmRlciB0cmljayBubyBsb25nZXIgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb24gbW9kZXJuIGJyb3dzZXJzLlxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkTWFya2Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0bmV3UG9zID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb3NpdGlvbnNbaV0pO1xyXG5cclxuXHRcdFx0Ly8gQWRkIHRoZSBsZWcgYmVmb3JlIHRoZSBtYXJrZXIsIHNvIHRoYXQgaW4gY2FzZSB0aGUgbGF0dGVyIGlzIGEgY2lyY2xlTWFya2VyLCB0aGUgbGVnIGlzIGJlaGluZCBpdC5cclxuXHRcdFx0bGVnID0gbmV3IEwuUG9seWxpbmUoW3RoaXNMYXllckxhdExuZywgbmV3UG9zXSwgbGVnT3B0aW9ucyk7XHJcblx0XHRcdG1hcC5hZGRMYXllcihsZWcpO1xyXG5cdFx0XHRtLl9zcGlkZXJMZWcgPSBsZWc7XHJcblxyXG5cdFx0XHQvLyBFeHBsYW5hdGlvbnM6IGh0dHBzOi8vamFrZWFyY2hpYmFsZC5jb20vMjAxMy9hbmltYXRlZC1saW5lLWRyYXdpbmctc3ZnL1xyXG5cdFx0XHQvLyBJbiBvdXIgY2FzZSB0aGUgdHJhbnNpdGlvbiBwcm9wZXJ0eSBpcyBkZWNsYXJlZCBpbiB0aGUgQ1NTIGZpbGUuXHJcblx0XHRcdGlmIChzdmcpIHtcclxuXHRcdFx0XHRsZWdQYXRoID0gbGVnLl9wYXRoO1xyXG5cdFx0XHRcdGxlZ0xlbmd0aCA9IGxlZ1BhdGguZ2V0VG90YWxMZW5ndGgoKSArIDAuMTsgLy8gTmVlZCBhIHNtYWxsIGV4dHJhIGxlbmd0aCB0byBhdm9pZCByZW1haW5pbmcgZG90IGluIEZpcmVmb3guXHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNoYXJyYXkgPSBsZWdMZW5ndGg7IC8vIEp1c3QgMSBsZW5ndGggaXMgZW5vdWdoLCBpdCB3aWxsIGJlIGR1cGxpY2F0ZWQuXHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gbGVnTGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiBpdCBpcyBhIG1hcmtlciwgYWRkIGl0IG5vdyBhbmQgd2UnbGwgYW5pbWF0ZSBpdCBvdXRcclxuXHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XHJcblx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMTAwMDAwMCk7IC8vIE1ha2Ugbm9ybWFsIG1hcmtlcnMgYXBwZWFyIG9uIHRvcCBvZiBFVkVSWVRISU5HXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIFZlY3RvcnMganVzdCBnZXQgaW1tZWRpYXRlbHkgYWRkZWRcclxuXHRcdFx0ZmcuYWRkTGF5ZXIobSk7XHJcblxyXG5cdFx0XHRpZiAobS5fc2V0UG9zKSB7XHJcblx0XHRcdFx0bS5fc2V0UG9zKHRoaXNMYXllclBvcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRncm91cC5fZm9yY2VMYXlvdXQoKTtcclxuXHRcdGdyb3VwLl9hbmltYXRpb25TdGFydCgpO1xyXG5cclxuXHRcdC8vIFJldmVhbCBtYXJrZXJzIGFuZCBzcGlkZXIgbGVncy5cclxuXHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XHJcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHQvL01vdmUgbWFya2VyIHRvIG5ldyBwb3NpdGlvblxyXG5cdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcclxuXHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBbmltYXRlIGxlZyAoYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGRlbGVnYXRlZCB0byBDU1MgdHJhbnNpdGlvbikuXHJcblx0XHRcdGlmIChzdmcpIHtcclxuXHRcdFx0XHRsZWcgPSBtLl9zcGlkZXJMZWc7XHJcblx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcclxuXHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSAwO1xyXG5cdFx0XHRcdC8vbGVnUGF0aC5zdHlsZS5zdHJva2VPcGFjaXR5ID0gZmluYWxMZWdPcGFjaXR5O1xyXG5cdFx0XHRcdGxlZy5zZXRTdHlsZSh7b3BhY2l0eTogZmluYWxMZWdPcGFjaXR5fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMuc2V0T3BhY2l0eSgwLjMpO1xyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XHJcblxyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdFx0Z3JvdXAuZmlyZSgnc3BpZGVyZmllZCcsIHtcclxuXHRcdFx0XHRjbHVzdGVyOiBtZSxcclxuXHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcclxuXHRcdFx0fSk7XHJcblx0XHR9LCAyMDApO1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRpb25VbnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdHZhciBtZSA9IHRoaXMsXHJcblx0XHRcdGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0dGhpc0xheWVyUG9zID0gem9vbURldGFpbHMgPyBtYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIHpvb21EZXRhaWxzLnpvb20sIHpvb21EZXRhaWxzLmNlbnRlcikgOiBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHRcdGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCksXHJcblx0XHRcdHN2ZyA9IEwuUGF0aC5TVkcsXHJcblx0XHRcdG0sIGksIGxlZywgbGVnUGF0aCwgbGVnTGVuZ3RoLCBub25BbmltYXRhYmxlO1xyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHRcdGdyb3VwLl9hbmltYXRpb25TdGFydCgpO1xyXG5cclxuXHRcdC8vTWFrZSB1cyB2aXNpYmxlIGFuZCBicmluZyB0aGUgY2hpbGQgbWFya2VycyBiYWNrIGluXHJcblx0XHR0aGlzLnNldE9wYWNpdHkoMSk7XHJcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdC8vTWFya2VyIHdhcyBhZGRlZCB0byB1cyBhZnRlciB3ZSB3ZXJlIHNwaWRlcmZpZWRcclxuXHRcdFx0aWYgKCFtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL0Nsb3NlIGFueSBwb3B1cCBvbiB0aGUgbWFya2VyIGZpcnN0LCBvdGhlcndpc2Ugc2V0dGluZyB0aGUgbG9jYXRpb24gb2YgdGhlIG1hcmtlciB3aWxsIG1ha2UgdGhlIG1hcCBzY3JvbGxcclxuXHRcdFx0bS5jbG9zZVBvcHVwKCk7XHJcblxyXG5cdFx0XHQvL0ZpeCB1cCB0aGUgbG9jYXRpb24gdG8gdGhlIHJlYWwgb25lXHJcblx0XHRcdG0uc2V0TGF0TG5nKG0uX3ByZVNwaWRlcmZ5TGF0bG5nKTtcclxuXHRcdFx0ZGVsZXRlIG0uX3ByZVNwaWRlcmZ5TGF0bG5nO1xyXG5cclxuXHRcdFx0Ly9IYWNrIG92ZXJyaWRlIHRoZSBsb2NhdGlvbiB0byBiZSBvdXIgY2VudGVyXHJcblx0XHRcdG5vbkFuaW1hdGFibGUgPSB0cnVlO1xyXG5cdFx0XHRpZiAobS5fc2V0UG9zKSB7XHJcblx0XHRcdFx0bS5fc2V0UG9zKHRoaXNMYXllclBvcyk7XHJcblx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtLmNsdXN0ZXJIaWRlKSB7XHJcblx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdG5vbkFuaW1hdGFibGUgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobm9uQW5pbWF0YWJsZSkge1xyXG5cdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBbmltYXRlIHRoZSBzcGlkZXIgbGVnIGJhY2sgaW4gKGFuaW1hdGlvbiBpcyBhY3R1YWxseSBkZWxlZ2F0ZWQgdG8gQ1NTIHRyYW5zaXRpb24pLlxyXG5cdFx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdFx0bGVnID0gbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XHJcblx0XHRcdFx0bGVnTGVuZ3RoID0gbGVnUGF0aC5nZXRUb3RhbExlbmd0aCgpICsgMC4xO1xyXG5cdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IGxlZ0xlbmd0aDtcclxuXHRcdFx0XHRsZWcuc2V0U3R5bGUoe29wYWNpdHk6IDB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XHJcblxyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vSWYgd2UgaGF2ZSBvbmx5IDw9IG9uZSBjaGlsZCBsZWZ0IHRoZW4gdGhhdCBtYXJrZXIgd2lsbCBiZSBzaG93biBvbiB0aGUgbWFwIHNvIGRvbid0IHJlbW92ZSBpdCFcclxuXHRcdFx0dmFyIHN0aWxsVGhlcmVDaGlsZENvdW50ID0gMDtcclxuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHRcdFx0XHRpZiAobS5fc3BpZGVyTGVnKSB7XHJcblx0XHRcdFx0XHRzdGlsbFRoZXJlQ2hpbGRDb3VudCsrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHRcdGlmICghbS5fc3BpZGVyTGVnKSB7IC8vSGFzIGFscmVhZHkgYmVlbiB1bnNwaWRlcmZpZWRcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XHJcblx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgwKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChzdGlsbFRoZXJlQ2hpbGRDb3VudCA+IDEpIHtcclxuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKG0uX3NwaWRlckxlZyk7XHJcblx0XHRcdFx0ZGVsZXRlIG0uX3NwaWRlckxlZztcclxuXHRcdFx0fVxyXG5cdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHRcdGdyb3VwLmZpcmUoJ3Vuc3BpZGVyZmllZCcsIHtcclxuXHRcdFx0XHRjbHVzdGVyOiBtZSxcclxuXHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcclxuXHRcdFx0fSk7XHJcblx0XHR9LCAyMDApO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuTC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XHJcblx0Ly9UaGUgTWFya2VyQ2x1c3RlciBjdXJyZW50bHkgc3BpZGVyZmllZCAoaWYgYW55KVxyXG5cdF9zcGlkZXJmaWVkOiBudWxsLFxyXG5cclxuXHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91bnNwaWRlcmZ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0fSxcclxuXHJcblx0X3NwaWRlcmZpZXJPbkFkZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX3Vuc3BpZGVyZnlXcmFwcGVyLCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ3pvb21zdGFydCcsIHRoaXMuX3Vuc3BpZGVyZnlab29tU3RhcnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0Ly9Ccm93c2VycyB3aXRob3V0IHpvb21BbmltYXRpb24gb3IgYSBiaWcgem9vbSBkb24ndCBmaXJlIHpvb21zdGFydFxyXG5cdFx0dGhpcy5fbWFwLm9uKCd6b29tZW5kJywgdGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5LCB0aGlzKTtcclxuXHJcblx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuZ2V0UmVuZGVyZXIodGhpcyk7XHJcblx0XHRcdC8vTmVlZHMgdG8gaGFwcGVuIGluIHRoZSBwYWdlbG9hZCwgbm90IGFmdGVyLCBvciBhbmltYXRpb25zIGRvbid0IHdvcmsgaW4gd2Via2l0XHJcblx0XHRcdC8vICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTUyMDAvc3ZnLWFuaW1hdGUtd2l0aC1keW5hbWljYWxseS1hZGRlZC1lbGVtZW50c1xyXG5cdFx0XHQvL0Rpc2FibGUgb24gdG91Y2ggYnJvd3NlcnMgYXMgdGhlIGFuaW1hdGlvbiBtZXNzZXMgdXAgb24gYSB0b3VjaCB6b29tIGFuZCBpc24ndCB2ZXJ5IG5vdGljYWJsZVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9zcGlkZXJmaWVyT25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5LCB0aGlzKTtcclxuXHJcblx0XHQvL0Vuc3VyZSB0aGF0IG1hcmtlcnMgYXJlIGJhY2sgd2hlcmUgdGhleSBzaG91bGQgYmVcclxuXHRcdC8vIFVzZSBubyBhbmltYXRpb24gdG8gYXZvaWQgYSBzdGlja3kgbGVhZmxldC1jbHVzdGVyLWFuaW0gY2xhc3Mgb24gbWFwUGFuZVxyXG5cdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0fSxcclxuXHJcblx0Ly9PbiB6b29tIHN0YXJ0IHdlIGFkZCBhIHpvb21hbmltIGhhbmRsZXIgc28gdGhhdCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBiZSBsYXN0IChhZnRlciBtYXJrZXJzIGFyZSBhbmltYXRlZClcclxuXHQvL1RoaXMgbWVhbnMgd2UgY2FuIGRlZmluZSB0aGUgYW5pbWF0aW9uIHRoZXkgZG8gcmF0aGVyIHRoYW4gTWFya2VycyBkb2luZyBhbiBhbmltYXRpb24gdG8gdGhlaXIgYWN0dWFsIGxvY2F0aW9uXHJcblx0X3Vuc3BpZGVyZnlab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X3Vuc3BpZGVyZnlab29tQW5pbTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XHJcblx0XHQvL1dhaXQgdW50aWwgdGhlIGZpcnN0IHpvb21hbmltIGFmdGVyIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCB0b3VjaC16b29taW5nIGJlZm9yZSBydW5uaW5nIHRoZSBhbmltYXRpb25cclxuXHRcdGlmIChMLkRvbVV0aWwuaGFzQ2xhc3ModGhpcy5fbWFwLl9tYXBQYW5lLCAnbGVhZmxldC10b3VjaGluZycpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XHJcblx0XHR0aGlzLl91bnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcclxuXHR9LFxyXG5cclxuXHRfdW5zcGlkZXJmeVdyYXBwZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vLyA8c3VtbWFyeT5fdW5zcGlkZXJmeSBidXQgcGFzc2VzIG5vIGFyZ3VtZW50czwvc3VtbWFyeT5cclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcclxuXHR9LFxyXG5cclxuXHRfdW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XHJcblx0XHRpZiAodGhpcy5fc3BpZGVyZmllZCkge1xyXG5cdFx0XHR0aGlzLl9zcGlkZXJmaWVkLnVuc3BpZGVyZnkoem9vbURldGFpbHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XHJcblx0XHRcdHRoaXMuX3NwaWRlcmZpZWQuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vSWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBiZWluZyBzcGlkZXJmaWVkIHRoZW4gd2UgdW5zcGlkZXJmeSBpdCBzbyBpdCBpc24ndCBvbiB0aGUgbWFwIGFueW1vcmUgZXRjXHJcblx0X3Vuc3BpZGVyZnlMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIuX3NwaWRlckxlZykge1xyXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcdC8vUG9zaXRpb24gd2lsbCBiZSBmaXhlZCB1cCBpbW1lZGlhdGVseSBpbiBfYW5pbWF0aW9uVW5zcGlkZXJmeVxyXG5cdFx0XHRpZiAobGF5ZXIuc2V0WkluZGV4T2Zmc2V0KSB7XHJcblx0XHRcdFx0bGF5ZXIuc2V0WkluZGV4T2Zmc2V0KDApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIobGF5ZXIuX3NwaWRlckxlZyk7XHJcblx0XHRcdGRlbGV0ZSBsYXllci5fc3BpZGVyTGVnO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyLlNwaWRlcmZpZXIuanMiLCIvKipcclxuICogQWRkcyAxIHB1YmxpYyBtZXRob2QgdG8gTUNHIGFuZCAxIHRvIEwuTWFya2VyIHRvIGZhY2lsaXRhdGUgY2hhbmdpbmdcclxuICogbWFya2VycycgaWNvbiBvcHRpb25zIGFuZCByZWZyZXNoaW5nIHRoZWlyIGljb24gYW5kIHRoZWlyIHBhcmVudCBjbHVzdGVyc1xyXG4gKiBhY2NvcmRpbmdseSAoY2FzZSB3aGVyZSB0aGVpciBpY29uQ3JlYXRlRnVuY3Rpb24gdXNlcyBkYXRhIG9mIGNoaWxkTWFya2Vyc1xyXG4gKiB0byBtYWtlIHVwIHRoZSBjbHVzdGVyIGljb24pLlxyXG4gKi9cclxuXHJcblxyXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBpY29uIG9mIGFsbCBjbHVzdGVycyB3aGljaCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gbWFya2VyKHMpLlxyXG5cdCAqIEluIHNpbmdsZU1hcmtlck1vZGUsIGFsc28gdXBkYXRlcyB0aGUgZ2l2ZW4gbWFya2VyKHMpIGljb24uXHJcblx0ICogQHBhcmFtIGxheWVycyBMLk1hcmtlckNsdXN0ZXJHcm91cHxMLkxheWVyR3JvdXB8QXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcil8XHJcblx0ICogTC5NYXJrZXJDbHVzdGVyfEwuTWFya2VyIChvcHRpb25hbCkgbGlzdCBvZiBtYXJrZXJzIChvciBzaW5nbGUgbWFya2VyKSB3aG9zZSBwYXJlbnRcclxuXHQgKiBjbHVzdGVycyBuZWVkIHRvIGJlIHVwZGF0ZWQuIElmIG5vdCBwcm92aWRlZCwgcmV0cmlldmVzIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMuXHJcblx0ICogQHJldHVybnMge0wuTWFya2VyQ2x1c3Rlckdyb3VwfVxyXG5cdCAqL1xyXG5cdHJlZnJlc2hDbHVzdGVyczogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0aWYgKCFsYXllcnMpIHtcclxuXHRcdFx0bGF5ZXJzID0gdGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycygpO1xyXG5cdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXJHcm91cCkge1xyXG5cdFx0XHRsYXllcnMgPSBsYXllcnMuX3RvcENsdXN0ZXJMZXZlbC5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcclxuXHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdGxheWVycyA9IGxheWVycy5fbGF5ZXJzO1xyXG5cdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcclxuXHRcdFx0bGF5ZXJzID0gbGF5ZXJzLmdldEFsbENoaWxkTWFya2VycygpO1xyXG5cdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xyXG5cdFx0XHRsYXllcnMgPSBbbGF5ZXJzXTtcclxuXHRcdH0gLy8gZWxzZTogbXVzdCBiZSBhbiBBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKVxyXG5cdFx0dGhpcy5fZmxhZ1BhcmVudHNJY29uc05lZWRVcGRhdGUobGF5ZXJzKTtcclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly8gSW4gY2FzZSBvZiBzaW5nbGVNYXJrZXJNb2RlLCBhbHNvIHJlLWRyYXcgdGhlIG1hcmtlcnMuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNpbmdsZU1hcmtlck1vZGUpIHtcclxuXHRcdFx0dGhpcy5fcmVmcmVzaFNpbmdsZU1hcmtlck1vZGVNYXJrZXJzKGxheWVycyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2ltcGx5IGZsYWdzIGFsbCBwYXJlbnQgY2x1c3RlcnMgb2YgdGhlIGdpdmVuIG1hcmtlcnMgYXMgaGF2aW5nIGEgXCJkaXJ0eVwiIGljb24uXHJcblx0ICogQHBhcmFtIGxheWVycyBBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKSBsaXN0IG9mIG1hcmtlcnMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfZmxhZ1BhcmVudHNJY29uc05lZWRVcGRhdGU6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdHZhciBpZCwgcGFyZW50O1xyXG5cclxuXHRcdC8vIEFzc3VtZXMgbGF5ZXJzIGlzIGFuIEFycmF5IG9yIGFuIE9iamVjdCB3aG9zZSBwcm90b3R5cGUgaXMgbm9uLWVudW1lcmFibGUuXHJcblx0XHRmb3IgKGlkIGluIGxheWVycykge1xyXG5cdFx0XHQvLyBGbGFnIHBhcmVudCBjbHVzdGVycycgaWNvbiBhcyBcImRpcnR5XCIsIGFsbCB0aGUgd2F5IHVwLlxyXG5cdFx0XHQvLyBEdW1iIHByb2Nlc3MgdGhhdCBmbGFncyBtdWx0aXBsZSB0aW1lcyB1cHBlciBwYXJlbnRzLCBidXQgc3RpbGxcclxuXHRcdFx0Ly8gbXVjaCBtb3JlIGVmZmljaWVudCB0aGFuIHRyeWluZyB0byBiZSBzbWFydCBhbmQgbWFrZSBzaG9ydCBsaXN0cyxcclxuXHRcdFx0Ly8gYXQgbGVhc3QgaW4gdGhlIGNhc2Ugb2YgYSBoaWVyYXJjaHkgZm9sbG93aW5nIGEgcG93ZXIgbGF3OlxyXG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mbGFnLW5vZGVzLWluLXBvd2VyLWhpZXJhcmNoeS8yXHJcblx0XHRcdHBhcmVudCA9IGxheWVyc1tpZF0uX19wYXJlbnQ7XHJcblx0XHRcdHdoaWxlIChwYXJlbnQpIHtcclxuXHRcdFx0XHRwYXJlbnQuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9fcGFyZW50O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmUtZHJhd3MgdGhlIGljb24gb2YgdGhlIHN1cHBsaWVkIG1hcmtlcnMuXHJcblx0ICogVG8gYmUgdXNlZCBpbiBzaW5nbGVNYXJrZXJNb2RlIG9ubHkuXHJcblx0ICogQHBhcmFtIGxheWVycyBBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKSBsaXN0IG9mIG1hcmtlcnMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcmVmcmVzaFNpbmdsZU1hcmtlck1vZGVNYXJrZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR2YXIgaWQsIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaWQgaW4gbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gbGF5ZXJzW2lkXTtcclxuXHJcblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkbyBub3Qgb3ZlcnJpZGUgbWFya2VycyB0aGF0IGRvIG5vdCBiZWxvbmcgdG8gVEhJUyBncm91cC5cclxuXHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdFx0Ly8gTmVlZCB0byByZS1jcmVhdGUgdGhlIGljb24gZmlyc3QsIHRoZW4gcmUtZHJhdyB0aGUgbWFya2VyLlxyXG5cdFx0XHRcdGxheWVyLnNldEljb24odGhpcy5fb3ZlcnJpZGVNYXJrZXJJY29uKGxheWVyKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgZ2l2ZW4gb3B0aW9ucyBpbiB0aGUgbWFya2VyJ3MgaWNvbiBhbmQgcmVmcmVzaGVzIHRoZSBtYXJrZXIuXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgbWFwIG9iamVjdCBvZiBpY29uIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIGRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzIGJvb2xlYW4gKG9wdGlvbmFsKSB0cnVlIHRvIHRyaWdnZXJcclxuXHQgKiBNQ0cucmVmcmVzaENsdXN0ZXJzT2YoKSByaWdodCBhd2F5IHdpdGggdGhpcyBzaW5nbGUgbWFya2VyLlxyXG5cdCAqIEByZXR1cm5zIHtMLk1hcmtlcn1cclxuXHQgKi9cclxuXHRyZWZyZXNoSWNvbk9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zLCBkaXJlY3RseVJlZnJlc2hDbHVzdGVycykge1xyXG5cdFx0dmFyIGljb24gPSB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHJcblx0XHRMLnNldE9wdGlvbnMoaWNvbiwgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5zZXRJY29uKGljb24pO1xyXG5cclxuXHRcdC8vIFNob3J0Y3V0IHRvIHJlZnJlc2ggdGhlIGFzc29jaWF0ZWQgTUNHIGNsdXN0ZXJzIHJpZ2h0IGF3YXkuXHJcblx0XHQvLyBUbyBiZSB1c2VkIHdoZW4gcmVmcmVzaGluZyBhIHNpbmdsZSBtYXJrZXIuXHJcblx0XHQvLyBPdGhlcndpc2UsIGJldHRlciB1c2UgTUNHLnJlZnJlc2hDbHVzdGVycygpIG9uY2UgYXQgdGhlIGVuZCB3aXRoXHJcblx0XHQvLyB0aGUgbGlzdCBvZiBtb2RpZmllZCBtYXJrZXJzLlxyXG5cdFx0aWYgKGRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzICYmIHRoaXMuX19wYXJlbnQpIHtcclxuXHRcdFx0dGhpcy5fX3BhcmVudC5fZ3JvdXAucmVmcmVzaENsdXN0ZXJzKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyR3JvdXAuUmVmcmVzaC5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCI8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIGhyZWY9XFxcImh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vYm9vdHN0cmFwLzQuMC4wLWJldGEvY3NzL2Jvb3RzdHJhcC5taW4uY3NzXFxcIiBpbnRlZ3JpdHk9XFxcInNoYTM4NC0vWTZwRDZGVi9WdjJISm5BNnQrdnNsVTZmd1lYakNGdGNFcEhiTkowbHlBRnNYVHNqQmJmYURqekFMZVFzTjZNXFxcIlxcbiAgY3Jvc3NvcmlnaW49XFxcImFub255bW91c1xcXCI+XFxuPGxpbmsgaHJlZj1cXFwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PUxhdG86MzAwLDQwMCw0MDBpLDkwMFxcXCIgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIj5cXG48bGluayBocmVmPVxcXCJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2ZvbnQtYXdlc29tZS80LjcuMC9jc3MvZm9udC1hd2Vzb21lLm1pbi5jc3NcXFwiIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaW50ZWdyaXR5PVxcXCJzaGEzODQtd3ZmWHBxcFpaVlFHSzZUQWg1UFZsR09mUU5IU29EMnhiRStRa1B4Q0FGbE5FZXZvRUgzU2wwc2liVmNPUVZuTlxcXCJcXG4gIGNyb3Nzb3JpZ2luPVxcXCJhbm9ueW1vdXNcXFwiPlxcblxcblxcbiAgPGxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCJodHRwczovL3VucGtnLmNvbS9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXJAMS4zLjAvZGlzdC9NYXJrZXJDbHVzdGVyLmNzc1xcXCIgbWVkaWE9XFxcInNjcmVlblxcXCI+XFxuICA8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIGhyZWY9XFxcImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXQubWFya2VyY2x1c3RlckAxLjMuMC9kaXN0L01hcmtlckNsdXN0ZXIuRGVmYXVsdC5jc3NcXFwiIG1lZGlhPVxcXCJzY3JlZW5cXFwiPlxcblxcblxcbjxzdHlsZT5cXG4gICA6aG9zdCB7XFxuICAgIGZvbnQtZmFtaWx5OiAnTGF0bycsIHNhbnMtc2VyaWY7XFxuICAgIC0tcHJpbWFyeS1jb2xvcjogIzAwM2Q3ZDtcXG4gICAgLS1zZWNvbmRhcnktY29sb3I6ICNmZjRiNWY7XFxuICB9XFxuXFxuICBtYWluLmNhcmQge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDE1cHg7XFxuICAgIHRvcDogMTVweDtcXG4gICAgYm90dG9tOiAxNXB4O1xcbiAgICB3aWR0aDogMzAwcHg7XFxuICAgIHotaW5kZXg6IDEwMDU7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIGJveC1zaGFkb3c6IDAgOHB4IDEwcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgM3B4IDE0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgNXB4IDVweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC4zKTtcXG5cXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDE3NW1zO1xcbiAgfVxcblxcbiAgYSB7XFxuICAgIGNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yLCBpbmhlcml0KTtcXG4gIH1cXG5cXG4gIC5idG4tcHJpbWFyeSB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yLCBpbmhlcml0KTtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yLCBpbmhlcml0KTtcXG4gIH1cXG5cXG4gIGhlYWRlciNwYWdlLXRpdGxlIHtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuICAgIGhlaWdodDogMTUwcHg7XFxuICB9XFxuXFxuICBoZWFkZXIjcGFnZS10aXRsZSBoMSB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgfVxcblxcbiAgc2VjdGlvbiNvdmVybGF5cyB7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNXB4O1xcbiAgfVxcblxcbiAgc2VjdGlvbiNvdmVybGF5cz51bD5saS5saXN0LWdyb3VwLWl0ZW0ge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgfVxcblxcbiAgc2VjdGlvbiNvdmVybGF5cyAub3ZlcmxheS1pdGVtIHtcXG4gICAgZm9udC1zaXplOiAxLjFyZW07XFxuICAgIHBhZGRpbmc6IDAuNzVyZW0gMS4yNXJlbTtcXG4gICAgY29sb3I6ICM0NDQ7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzIC5vdmVybGF5LWl0ZW06aG92ZXIge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzIC5vdmVybGF5LWl0ZW0uc2VsZWN0ZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xcbiAgICBjb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuXFxuICAgIC8qIGxlZnQgYm9yZGVyIGFuZCBvZmZzZXQgdGV4dCBiYWNrICovXFxuICAgIGJvcmRlci1sZWZ0OiAwLjI1cmVtIHNvbGlkIHZhcigtLXByaW1hcnktY29sb3IpO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDFyZW07XFxuICB9XFxuXFxuICB1bC5vdmVybGF5LWxheWVycz5saS5saXN0LWdyb3VwLWl0ZW0ge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIGJvcmRlci1sZWZ0OiAwLjI1cmVtIHNvbGlkIHZhcigtLXByaW1hcnktY29sb3IpO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEuNzVyZW07XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG5cXG4gIHVsLm92ZXJsYXktbGF5ZXJzIC5vdmVybGF5LWxheWVycy10b2dnbGUge1xcbiAgICAtLXByaW1hcnktY29sb3I6IHZhcigtLXNlY29uZGFyeS1jb2xvcik7XFxuICB9XFxuXFxuICBidXR0b24jYmFzZW1hcC1zd2l0Y2hlcixcXG4gIGJ1dHRvbiNsYXllcnMtbWVudS10b2dnbGUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHJpZ2h0OiAzMHB4O1xcbiAgICB3aWR0aDogMTYwcHg7XFxuICAgIGhlaWdodDogOTBweDtcXG4gICAgei1pbmRleDogMTAwMTtcXG4gICAgYm9yZGVyOiA1cHggc29saWQgI2ZmZmZmZjtcXG4gICAgYm94LXNoYWRvdzogMCA4cHggMTBweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKSwgMCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuXFxuICBidXR0b24jYmFzZW1hcC1zd2l0Y2hlciB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnLi9hZXJpYWwucG5nJyk7XFxuICAgIGJvdHRvbTogMzBweDtcXG4gIH1cXG5cXG4gIGJ1dHRvbiNsYXllcnMtbWVudS10b2dnbGUge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICBib3R0b206IDEzMHB4O1xcbiAgfVxcblxcbiAgc2VjdGlvbiNkb3dubG9hZC1kaXNjbGFpbWVyIHtcXG4gICAgbWF4LWhlaWdodDogNDAwcHg7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICB0ZXh0LWFsaWduOiBqdXN0aWZ5O1xcbiAgfVxcblxcbiAgLnNob3ctbW9iaWxlIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA2MDBweCkge1xcbiAgICBtYWluLmNhcmQge1xcbiAgICAgIHJpZ2h0OiAzMHB4O1xcbiAgICAgIGxlZnQ6IDMwcHg7XFxuICAgICAgdG9wOiAzMHB4O1xcbiAgICAgIGJvdHRvbTogMzBweDtcXG4gICAgICB3aWR0aDogdW5zZXQ7XFxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwKTtcXG4gICAgfVxcblxcbiAgICBtYWluLnNob3cge1xcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIH1cXG5cXG4gICAgLnNob3ctbW9iaWxlIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgfVxcblxcbiAgICBidXR0b24jYmFzZW1hcC1zd2l0Y2hlcixcXG4gICAgYnV0dG9uI2xheWVycy1tZW51LXRvZ2dsZSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgd2lkdGg6IDkwcHg7XFxuICAgICAgaGVpZ2h0OiA5MHB4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDkwcHg7XFxuICAgIH1cXG4gIH1cXG48L3N0eWxlPlxcblxcbjwhLS1saW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvNC4wLjAtYmV0YS9jc3MvYm9vdHN0cmFwLm1pbi5jc3NcXFwiIGludGVncml0eT1cXFwic2hhMzg0LS9ZNnBENkZWL1Z2MkhKbkE2dCt2c2xVNmZ3WVhqQ0Z0Y0VwSGJOSjBseUFGc1hUc2pCYmZhRGp6QUxlUXNONk1cXFwiIGNyb3Nzb3JpZ2luPVxcXCJhbm9ueW1vdXNcXFwiLS0+XFxuXFxuPG1haW4gaWQ9XFxcImxheWVycy1tZW51XFxcIiBjbGFzcz1cXFwiY2FyZFxcXCI+XFxuICA8aGVhZGVyIGlkPVxcXCJwYWdlLXRpdGxlXFxcIiBjbGFzcz1cXFwiY2FyZC1pbWctdG9wIGQtZmxleCBhbGlnbi1pdGVtcy1lbmRcXFwiPlxcbiAgICA8aDEgY2xhc3M9XFxcImgyXFxcIj5bW21hcFRpdGxlXV08L2gxPlxcbiAgPC9oZWFkZXI+XFxuXFxuICA8IS0tIFNlYXJjaCBzZWN0aW9uIC0tPlxcbiAgPHNlY3Rpb24gaWQ9XFxcInNlYXJjaC1zZWN0aW9uXFxcIiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwic2VhcmNoXFxcIiBpZD1cXFwic2VhcmNoXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHJvdW5kZWQtMFxcXCIgcGxhY2Vob2xkZXI9XFxcIlNlYXJjaCBhZGRyZXNzXFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0biByb3VuZGVkLTBcXFwiPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tc2Vjb25kYXJ5IHJvdW5kZWQtMFxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZncgZmEtc2VhcmNoXFxcIj48L2k+XFxuICAgICAgPC9idXR0b24+XFxuICAgIDwvc3Bhbj5cXG4gIDwvc2VjdGlvbj5cXG5cXG4gIDwhLS0gTGlzdCBvZiBhdmFpbGFibGUgb3ZlcmxheXMgLS0+XFxuICA8c2VjdGlvbiBpZD1cXFwib3ZlcmxheXNcXFwiPlxcbiAgICA8dWwgY2xhc3M9XFxcImxpc3QtZ3JvdXBcXFwiPlxcblxcbiAgICAgIDx0ZW1wbGF0ZSBpcz1cXFwiZG9tLXJlcGVhdFxcXCIgaXRlbXM9XFxcInt7b3ZlcmxheU1hcHN9fVxcXCI+XFxuICAgICAgICA8bGkgY2xhc3M9XFxcImxpc3QtZ3JvdXAtaXRlbVxcXCI+XFxuXFxuICAgICAgICAgIDwhLS0gTWFpbiBvdmVybGF5IHRvZ2dsZSAtLT5cXG4gICAgICAgICAgPHRlbXBsYXRlIGlzPVxcXCJkb20taWZcXFwiIGlmPVxcXCJ7eyFmbGF0fX1cXFwiPlxcbiAgICAgICAgICAgIDxkaXYgdGl0bGU9XFxcIltbaXRlbS5kZXNjcmlwdGlvbl1dXFxcIiBjbGFzcyQ9XFxcIltbX292ZXJsYXlJdGVtQ2xhc3Moc2VsZWN0ZWRPdmVybGF5LCBpdGVtKV1dXFxcIiBvbi1jbGljaz1cXFwib3ZlcmxheVNlbGVjdFxcXCI+XFxuICAgICAgICAgICAgICA8cGFwZXItdG9nZ2xlLWJ1dHRvbiBjaGVja2VkPVxcXCJbW19pc0N1cnJlbnRPdmVybGF5KHNlbGVjdGVkT3ZlcmxheSwgaXRlbSldXVxcXCI+PC9wYXBlci10b2dnbGUtYnV0dG9uPlxcbiAgICAgICAgICAgICAgPHNwYW4+W1tpdGVtLm5hbWVdXTwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC90ZW1wbGF0ZT5cXG5cXG4gICAgICAgICAgPGRpdiBjbGFzcyQ9XFxcIltbX292ZXJsYXlMYXllcnNTaG93KHNlbGVjdGVkT3ZlcmxheSwgaXRlbSldXVxcXCI+XFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXCJvdmVybGF5LWxheWVycyBsaXN0LWdyb3VwIGxpc3QtZ3JvdXAtZmx1c2hcXFwiPlxcblxcbiAgICAgICAgICAgICAgPCEtLSBFeGNsdXNpdmUgbGF5ZXJzIC0tPlxcbiAgICAgICAgICAgICAgPHRlbXBsYXRlIGlzPVxcXCJkb20tcmVwZWF0XFxcIiBpdGVtcz1cXFwie3tpdGVtLmxheWVycy5leGNsdXNpdmVzfX1cXFwiIGFzPVxcXCJsYXllclxcXCI+XFxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFwibGlzdC1ncm91cC1pdGVtIGQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtc3RhcnRcXFwiIG9uLWNsaWNrPVxcXCJ0b2dnbGVMYXllclxcXCI+XFxuICAgICAgICAgICAgICAgICAgPHBhcGVyLXRvZ2dsZS1idXR0b24gY2xhc3M9XFxcIm92ZXJsYXktbGF5ZXJzLXRvZ2dsZVxcXCIgY2hlY2tlZD1cXFwiW1tfaXNDdXJyZW50RXhjbHVzaXZlKGxheWVyLCB3bXNHcm91cHMpXV1cXFwiPjwvcGFwZXItdG9nZ2xlLWJ1dHRvbj5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibXItYXV0b1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICBbW2xheWVyLm5hbWVdXVxcbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIiBvbi1jbGljaz1cXFwiZG93bmxvYWRMYXllclxcXCIgY2xhc3M9XFxcImp1c3RpZnktc2VsZi1lbmRcXFwiPjxpIHRpdGxlPVxcXCJEb3dubG9hZCBbW2xheWVyLm5hbWVdXVxcXCIgY2xhc3M9XFxcImZhIGZhLWZ3IGZhLWRvd25sb2FkXFxcIj48L2k+PC9hPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgPC90ZW1wbGF0ZT5cXG5cXG4gICAgICAgICAgICAgIDwhLS0gT3B0aW9uYWwgbGF5ZXJzIC0tPlxcbiAgICAgICAgICAgICAgPHRlbXBsYXRlIGlzPVxcXCJkb20tcmVwZWF0XFxcIiBpdGVtcz1cXFwie3tpdGVtLmxheWVycy5vcHRpb25hbHN9fVxcXCIgYXM9XFxcImxheWVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJsaXN0LWdyb3VwLWl0ZW0gZC1mbGV4IGp1c3RpZnktY29udGVudC1zdGFydFxcXCIgb24tY2xpY2s9XFxcInRvZ2dsZUxheWVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8cGFwZXItdG9nZ2xlLWJ1dHRvbiBjbGFzcz1cXFwib3ZlcmxheS1sYXllcnMtdG9nZ2xlXFxcIiBjaGVja2VkPVxcXCJbW2xheWVyLnZpc2libGVdXVxcXCI+PC9wYXBlci10b2dnbGUtYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtci1hdXRvXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIFtbbGF5ZXIubmFtZV1dXFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIG9uLWNsaWNrPVxcXCJkb3dubG9hZExheWVyXFxcIiBjbGFzcz1cXFwianVzdGlmeS1zZWxmLWVuZFxcXCI+PGkgdGl0bGU9XFxcIkRvd25sb2FkIFtbbGF5ZXIubmFtZV1dXFxcIiBjbGFzcz1cXFwiZmEgZmEtZncgZmEtZG93bmxvYWRcXFwiPjwvaT48L2E+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8L3RlbXBsYXRlPlxcblxcbiAgICAgICAgICAgIDwvdWw+XFxuICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPC9saT5cXG4gICAgICA8L3RlbXBsYXRlPlxcblxcbiAgICA8L3VsPlxcbiAgPC9zZWN0aW9uPlxcblxcbiAgPGZvb3RlciBjbGFzcz1cXFwiY2FyZC1ib2R5XFxcIj5cXG4gICAgPCEtLSA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj5IZWxwPC9hPlxcbiAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj5Ub3VyPC9hPiAtLT5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodCBzaG93LW1vYmlsZVxcXCI+XFxuICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgb24tY2xpY2s9XFxcInRvZ2dsZUxheWVyc01lbnVcXFwiPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLW1hcFxcXCI+PC9pPlxcbiAgICAgICAgVmlldyBNYXBcXG4gICAgICA8L2E+XFxuICAgIDwvZGl2PlxcbiAgPC9mb290ZXI+XFxuPC9tYWluPlxcblxcbjwhLS0gQmFzZW1hcCB0b2dnbGUgYnV0dG9uIC0tPlxcbjxidXR0b24gaWQ9XFxcImJhc2VtYXAtc3dpdGNoZXJcXFwiIG9uLWNsaWNrPVxcXCJzd2l0Y2hCYXNlbWFwXFxcIj48L2J1dHRvbj5cXG5cXG48IS0tIExheWVycyBjb250cm9sIG1lbnUgKG1vYmlsZSBvbmx5KSAtLT5cXG48YnV0dG9uIGlkPVxcXCJsYXllcnMtbWVudS10b2dnbGVcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIG9uLWNsaWNrPVxcXCJ0b2dnbGVMYXllcnNNZW51XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtYmFycyBmYS0zeFxcXCI+PC9pPjwvYnV0dG9uPlxcblxcbjxsZWFmbGV0LW1hcCBtYXA9XFxcInt7bWFwfX1cXFwiIGxhdGl0dWRlPVxcXCIzMy43Nzg3MjRcXFwiIGxvbmdpdHVkZT1cXFwiLTExNy45NjAwNThcXFwiIHpvb209XFxcIjEzXFxcIiBtaW4tem9vbT1cXFwiMTFcXFwiIG1heC16b29tPVxcXCIxOVxcXCIgYXR0cmlidXRpb24tcHJlZml4PVxcXCJDaXR5IG9mIEdhcmRlbiBHcm92ZVxcXCI+XFxuXFxuICA8dGVtcGxhdGUgaXM9XFxcImRvbS1pZlxcXCIgaWY9XFxcInt7YmFzZVNvdXJjZX19XFxcIiByZXN0YW1wPlxcbiAgICA8bGVhZmxldC10aWxlLWxheWVyIG1hcD1cXFwie3ttYXB9fVxcXCIgdXJsPVxcXCJbW2Jhc2VTb3VyY2VdXVxcXCIgZm9ybWF0PVxcXCJbW2Jhc2VGb3JtYXRdXVxcXCIgbGF5ZXJzPVxcXCJbW2Jhc2VMYXllcnNdXVxcXCIgYXR0cmlidXRpb249XFxcIiZjb3B5OyBPcGVuU3RyZWV0TWFwXFxcIj5cXG4gICAgPC9sZWFmbGV0LXRpbGUtbGF5ZXI+XFxuICA8L3RlbXBsYXRlPlxcblxcbiAgPHRlbXBsYXRlIGlzPVxcXCJkb20tcmVwZWF0XFxcIiBpdGVtcz1cXFwie3t3bXNHcm91cHN9fVxcXCIgYXM9XFxcImdyb3VwXFxcIj5cXG4gICAgPGxlYWZsZXQtd21zLWdyb3VwIG1hcD1cXFwie3ttYXB9fVxcXCIgc291cmNlPVxcXCJbW2dyb3VwLnNvdXJjZV1dXFxcIiBsYXllcnM9XFxcIltbZ3JvdXAubGF5ZXJzXV1cXFwiIHRyYW5zcGFyZW50IGZvcm1hdD1cXFwiaW1hZ2UvcG5nXFxcIiBpZGVudGlmeT1cXFwiW1tncm91cC5pZGVudGlmeV1dXFxcIiBpbmZvLWZvcm1hdD1cXFwiW1tncm91cC5pbmZvRm9ybWF0XV1cXFwiPlxcbiAgICA8L2xlYWZsZXQtd21zLWdyb3VwPlxcbiAgPC90ZW1wbGF0ZT5cXG5cXG4gIDx0ZW1wbGF0ZSBpcz1cXFwiZG9tLXJlcGVhdFxcXCIgaXRlbXM9XFxcInt7Z2VvanNvbkxheWVyc319XFxcIiBhcz1cXFwibGF5ZXJcXFwiPlxcbiAgICA8bGVhZmxldC1nZW9qc29uLXBvaW50cyBtYXA9XFxcInt7bWFwfX1cXFwiIHNvdXJjZSQ9XFxcIltbbGF5ZXIuc291cmNlXV1cXFwiIHJhZGl1cyQ9XFxcIltbbGF5ZXIucmFkaXVzXV1cXFwiIHdlaWdodCQ9XFxcIltbbGF5ZXIud2VpZ2h0XV1cXFwiIG1heC1jbHVzdGVyLXJhZGl1cyQ9XFxcIltbbGF5ZXIubWF4Q2x1c3RlclJhZGl1c11dXFxcIlxcbiAgICAgIGZpbGwtY29sb3IkPVxcXCJbW2xheWVyLmZpbGxDb2xvcl1dXFxcIiBvdXRsaW5lLWNvbG9yJD1cXFwiW1tsYXllci5vdXRsaW5lQ29sb3JdXVxcXCIgb3BhY2l0eSQ9XFxcIltbbGF5ZXIub3BhY2l0eV1dXFxcIiBmaWxsLW9wYWNpdHkkPVxcXCJbW2xheWVyLmZpbGxPcGFjaXR5XV1cXFwiIGlkZW50aWZ5JD1cXFwiW1tsYXllci5pZGVudGlmeV1dXFxcIlxcbiAgICAgIGF0dHJpYnV0aW9uJD1cXFwiW1tsYXllci5hdHRyaWJ1dGlvbl1dXFxcIiBjbHVzdGVyJD1cXFwiW1tsYXllci5jbHVzdGVyXV1cXFwiPlxcbiAgICA8L2xlYWZsZXQtZ2VvanNvbi1wb2ludHM+XFxuICA8L3RlbXBsYXRlPlxcbjwvbGVhZmxldC1tYXA+XFxuXFxuPCEtLSBEb3dubG9hZCBNb2RhbCAtLT5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlXFxcIiBpZD1cXFwiZG93bmxvYWQtbW9kYWxcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImRvd25sb2FkLW1vZGFsLWxhYmVsXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2cgbW9kYWwtbGdcXFwiIHJvbGU9XFxcImRvY3VtZW50XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtaGVhZGVyXFxcIj5cXG4gICAgICAgIDxoMyBjbGFzcz1cXFwibW9kYWwtdGl0bGVcXFwiIGlkPVxcXCJkb3dubG9hZC1tb2RhbC1sYWJlbFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGlkPVxcXCJsYXllci1uYW1lXFxcIj48L3NwYW4+XFxuICAgICAgICA8L2gzPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgYXJpYS1sYWJlbD1cXFwiQ2xvc2VcXFwiPlxcbiAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcbiAgICAgICAgPHNlY3Rpb24gc3R5bGU9XFxcImhlaWdodDogNDAwcHg7IG92ZXJmbG93OiBhdXRvOyBwYWRkaW5nOiAxMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyBmb250LXNpemU6IDAuODVyZW07XFxcIj5cXG4gICAgICAgICAgPGg1PkRvd25sb2FkIERpc2NsYWltZXI8L2g1PlxcblxcbiAgICAgICAgICA8cD5UaGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgcHJvdmlkZXMgdGhlIGRhdGEgYXMgYSBwdWJsaWMgcmVzb3VyY2Ugb2YgZ2VuZXJhbCBpbmZvcm1hdGlvbiBmb3IgdXNlIFxcXCJhcyBpcy5cXFwiIFRoZSBDaXR5XFxuICAgICAgICAgICAgb2YgR2FyZGVuIEdyb3ZlIHByb3ZpZGVzIHRoaXMgaW5mb3JtYXRpb24gd2l0aCB0aGUgdW5kZXJzdGFuZGluZyB0aGF0IGl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGFjY3VyYXRlLCBjb3JyZWN0XFxuICAgICAgICAgICAgb3IgY29tcGxldGUgYW5kIGFueSBjb25jbHVzaW9ucyBkcmF3biBmcm9tIHN1Y2ggaW5mb3JtYXRpb24gYXJlIHRoZSBzb2xlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyLiBGdXJ0aGVyLFxcbiAgICAgICAgICAgIHRoZSBDaXR5IG9mIEdhcmRlbiBHcm92ZSBtYWtlcyBubyB3YXJyYW50eSwgcmVwcmVzZW50YXRpb24gb3IgZ3VhcmFudHkgYXMgdG8gdGhlIGNvbnRlbnQsIHNlcXVlbmNlLCBhY2N1cmFjeSxcXG4gICAgICAgICAgICB0aW1lbGluZXNzIG9yIGNvbXBsZXRlbmVzcyBvZiBhbnkgb2YgdGhlIHNwYXRpYWwgb3IgZGF0YWJhc2UgaW5mb3JtYXRpb24gcHJvdmlkZWQgaGVyZWluLiBXaGlsZSBldmVyeSBlZmZvcnRcXG4gICAgICAgICAgICBoYXMgYmVlbiBtYWRlIHRvIGVuc3VyZSB0aGUgY29udGVudCwgc2VxdWVuY2UsIGFjY3VyYWN5LCB0aW1lbGluZXNzIG9yIGNvbXBsZXRlbmVzcyBvZiBtYXRlcmlhbHMgcHJlc2VudGVkIHdpdGhpblxcbiAgICAgICAgICAgIHRoZXNlIHBhZ2VzLCB0aGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgYXNzdW1lcyBubyByZXNwb25zaWJpbGl0eSBmb3IgZXJyb3JzIG9yIG9taXNzaW9ucywgYW5kIGV4cGxpY2l0bHkgZGlzY2xhaW1zXFxuICAgICAgICAgICAgYW55IHJlcHJlc2VudGF0aW9ucyBhbmQgd2FycmFudGllcywgaW5jbHVkaW5nLCB3aXRob3V0IGxpbWl0YXRpb24sIHRoZSBpbXBsaWVkIHdhcnJhbnRpZXMgb2YgbWVyY2hhbnRhYmlsaXR5XFxuICAgICAgICAgICAgYW5kIGZpdG5lc3MgZm9yIGEgcGFydGljdWxhciBwdXJwb3NlLiBUaGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgc2hhbGwgYXNzdW1lIG5vIGxpYWJpbGl0eSBmb3I6PC9wPlxcbiAgICAgICAgICA8cD4xLkFueSBlcnJvcnMsIG9taXNzaW9ucywgb3IgaW5hY2N1cmFjaWVzIGluIHRoZSBpbmZvcm1hdGlvbiBwcm92aWRlZCwgcmVnYXJkbGVzcyBvZiBob3cgY2F1c2VkOyBvciAyLkFueSBkZWNpc2lvblxcbiAgICAgICAgICAgIG1hZGUgb3IgYWN0aW9uIHRha2VuIG9yIG5vdCB0YWtlbiBieSB2aWV3ZXIgaW4gcmVsaWFuY2UgdXBvbiBhbnkgaW5mb3JtYXRpb24gb3IgZGF0YSBmdXJuaXNoZWQgaGVyZXVuZGVyLjwvcD5cXG4gICAgICAgICAgPHA+QXZhaWxhYmlsaXR5IG9mIHRoZSBDaXR5IG9mIEdhcmRlbiBHcm92ZSBHSVMgaXMgbm90IGd1YXJhbnRlZWQuIEFwcGxpY2F0aW9ucywgc2VydmVycywgYW5kIG5ldHdvcmsgY29ubmVjdGlvbnNcXG4gICAgICAgICAgICBtYXkgYmUgdW5hdmFpbGFibGUgYXQgYW55IHRpbWUgZm9yIG1haW50ZW5hbmNlIG9yIHVuc2NoZWR1bGVkIG91dGFnZXMuIE91dGFnZXMgbWF5IGJlIG9mIGxvbmcgZHVyYXRpb24uIFVzZXJzXFxuICAgICAgICAgICAgYXJlIGNhdXRpb25lZCB0byBjcmVhdGUgZGVwZW5kZW5jaWVzIG9uIHRoZXNlIHNlcnZpY2VzIGZvciBjcml0aWNhbCBuZWVkcy48L3A+XFxuICAgICAgICAgIDxwPlRIRSBGT1JFR09JTkcgV0FSUkFOVFkgSVMgRVhDTFVTSVZFIEFORCBJTiBMSUVVIE9GIEFMTCBPVEhFUiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgUEFSVElDVUxBUlxcbiAgICAgICAgICAgIFBVUlBPU0UgQU5EL09SIEFOWSBPVEhFUiBUWVBFIFdIRVRIRVIgRVhQUkVTU0VEIE9SIElNUExJRUQuIEluIG5vIGV2ZW50IHNoYWxsIFRoZSBDaXR5IG9mIEdhcmRlbiBHcm92ZSBiZWNvbWVcXG4gICAgICAgICAgICBsaWFibGUgdG8gdXNlcnMgb2YgdGhlc2UgZGF0YSwgb3IgYW55IG90aGVyIHBhcnR5LCBmb3IgYW55IGxvc3Mgb3IgZGlyZWN0LCBpbmRpcmVjdCwgc3BlY2lhbCwgaW5jaWRlbnRhbCBvciBjb25zZXF1ZW50aWFsXFxuICAgICAgICAgICAgZGFtYWdlcywgaW5jbHVkaW5nLCBidXQgbm90IGxpbWl0ZWQgdG8sIHRpbWUsIG1vbmV5IG9yIGdvb2R3aWxsLCBhcmlzaW5nIGZyb20gdGhlIHVzZSBvciBtb2RpZmljYXRpb24gb2YgdGhlXFxuICAgICAgICAgICAgZGF0YS5cXG4gICAgICAgICAgPC9wPlxcbiAgICAgICAgICA8cD5UbyBhc3Npc3QgVGhlIENpdHkgb2YgR2FyZGVuIEdyb3ZlIGluIHRoZSBtYWludGVuYW5jZSBhbmQvb3IgY29ycmVjdGlvbiBvZiB0aGUgZGF0YSwgdXNlcnMgc2hvdWxkIHByb3ZpZGUgdGhlIENpdHlcXG4gICAgICAgICAgICBvZiBHYXJkZW4gR3JvdmUgd2l0aCBpbmZvcm1hdGlvbiBjb25jZXJuaW5nIGVycm9ycyBvciBkaXNjcmVwYW5jaWVzIGZvdW5kIGluIHVzaW5nIHRoZSBkYXRhLiBQbGVhc2UgYWNrbm93bGVkZ2VcXG4gICAgICAgICAgICB0aGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgYXMgdGhlIHNvdXJjZSB3aGVuIGRhdGEgaXMgdXNlZCBpbiB0aGUgcHJlcGFyYXRpb24gb2YgcmVwb3J0cywgcGFwZXJzLCBwdWJsaWNhdGlvbnMsXFxuICAgICAgICAgICAgbWFwcywgb3Igb3RoZXIgcHJvZHVjdHMuPC9wPlxcbiAgICAgICAgPC9zZWN0aW9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgICAgICA8IS0tYnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc2Vjb25kYXJ5XFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj5DbG9zZTwvYnV0dG9uLS0+XFxuICAgICAgICA8c3BhbiBpZD1cXFwiZG93bmxvYWQtYnV0dG9ucy1sYWJlbFxcXCI+RG93bmxvYWQgYXM6PC9zcGFuPlxcbiAgICAgICAgPGEgaWQ9XFxcImdlb2pzb24tZG93bmxvYWRcXFwiIGhyZWY9XFxcIiNcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImRvd25sb2FkLWJ1dHRvbnMtbGFiZWxcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZG93bmxvYWRcXFwiPjwvaT5HZW9KU09OXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwiY3N2LWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+Q1NWXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwia21sLWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+S01MXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwic2hhcGVmaWxlLWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+U2hhcGVmaWxlXFxuICAgICAgICA8L2E+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hcHAudGVtcGxhdGUuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcykuanN5YW1sPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGUodCxuLGkpe2Z1bmN0aW9uIHIoYSxzKXtpZighblthXSl7aWYoIXRbYV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXMmJmMpcmV0dXJuIGMoYSwhMCk7aWYobylyZXR1cm4gbyhhLCEwKTt2YXIgdT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2ErXCInXCIpO3Rocm93IHUuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix1fXZhciBsPW5bYV09e2V4cG9ydHM6e319O3RbYV1bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFthXVsxXVtlXTtyZXR1cm4gcihufHxlKX0sbCxsLmV4cG9ydHMsZSx0LG4saSl9cmV0dXJuIG5bYV0uZXhwb3J0c31mb3IodmFyIG89XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxhPTA7YTxpLmxlbmd0aDthKyspcihpW2FdKTtyZXR1cm4gcn0oezE6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiBmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIFwiK2UrXCIgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuXCIpfX12YXIgcj1lKFwiLi9qcy15YW1sL2xvYWRlclwiKSxvPWUoXCIuL2pzLXlhbWwvZHVtcGVyXCIpO3QuZXhwb3J0cy5UeXBlPWUoXCIuL2pzLXlhbWwvdHlwZVwiKSx0LmV4cG9ydHMuU2NoZW1hPWUoXCIuL2pzLXlhbWwvc2NoZW1hXCIpLHQuZXhwb3J0cy5GQUlMU0FGRV9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIiksdC5leHBvcnRzLkpTT05fU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2pzb25cIiksdC5leHBvcnRzLkNPUkVfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2NvcmVcIiksdC5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlXCIpLHQuZXhwb3J0cy5ERUZBVUxUX0ZVTExfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSx0LmV4cG9ydHMubG9hZD1yLmxvYWQsdC5leHBvcnRzLmxvYWRBbGw9ci5sb2FkQWxsLHQuZXhwb3J0cy5zYWZlTG9hZD1yLnNhZmVMb2FkLHQuZXhwb3J0cy5zYWZlTG9hZEFsbD1yLnNhZmVMb2FkQWxsLHQuZXhwb3J0cy5kdW1wPW8uZHVtcCx0LmV4cG9ydHMuc2FmZUR1bXA9by5zYWZlRHVtcCx0LmV4cG9ydHMuWUFNTEV4Y2VwdGlvbj1lKFwiLi9qcy15YW1sL2V4Y2VwdGlvblwiKSx0LmV4cG9ydHMuTUlOSU1BTF9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIiksdC5leHBvcnRzLlNBRkVfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZVwiKSx0LmV4cG9ydHMuREVGQVVMVF9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsXCIpLHQuZXhwb3J0cy5zY2FuPWkoXCJzY2FuXCIpLHQuZXhwb3J0cy5wYXJzZT1pKFwicGFyc2VcIiksdC5leHBvcnRzLmNvbXBvc2U9aShcImNvbXBvc2VcIiksdC5leHBvcnRzLmFkZENvbnN0cnVjdG9yPWkoXCJhZGRDb25zdHJ1Y3RvclwiKX0se1wiLi9qcy15YW1sL2R1bXBlclwiOjMsXCIuL2pzLXlhbWwvZXhjZXB0aW9uXCI6NCxcIi4vanMteWFtbC9sb2FkZXJcIjo1LFwiLi9qcy15YW1sL3NjaGVtYVwiOjcsXCIuL2pzLXlhbWwvc2NoZW1hL2NvcmVcIjo4LFwiLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGxcIjo5LFwiLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmVcIjoxMCxcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIjoxMSxcIi4vanMteWFtbC9zY2hlbWEvanNvblwiOjEyLFwiLi9qcy15YW1sL3R5cGVcIjoxM31dLDI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiB2b2lkIDA9PT1lfHxudWxsPT09ZX10LmV4cG9ydHMuaXNOb3RoaW5nPWksdC5leHBvcnRzLmlzT2JqZWN0PWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZX0sdC5leHBvcnRzLnRvQXJyYXk9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTppKGUpP1tdOltlXX0sdC5leHBvcnRzLnJlcGVhdD1mdW5jdGlvbihlLHQpe3ZhciBuLGk9XCJcIjtmb3Iobj0wO248dDtuKz0xKWkrPWU7cmV0dXJuIGl9LHQuZXhwb3J0cy5pc05lZ2F0aXZlWmVybz1mdW5jdGlvbihlKXtyZXR1cm4gMD09PWUmJk51bWJlci5ORUdBVElWRV9JTkZJTklUWT09PTEvZX0sdC5leHBvcnRzLmV4dGVuZD1mdW5jdGlvbihlLHQpe3ZhciBuLGkscixvO2lmKHQpZm9yKG49MCxpPShvPU9iamVjdC5rZXlzKHQpKS5sZW5ndGg7bjxpO24rPTEpZVtyPW9bbl1dPXRbcl07cmV0dXJuIGV9fSx7fV0sMzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0KXt2YXIgbixpLHIsbyxhLHMsYztpZihudWxsPT09dClyZXR1cm57fTtmb3Iobj17fSxyPTAsbz0oaT1PYmplY3Qua2V5cyh0KSkubGVuZ3RoO3I8bztyKz0xKWE9aVtyXSxzPVN0cmluZyh0W2FdKSxcIiEhXCI9PT1hLnNsaWNlKDAsMikmJihhPVwidGFnOnlhbWwub3JnLDIwMDI6XCIrYS5zbGljZSgyKSksKGM9ZS5jb21waWxlZFR5cGVNYXAuZmFsbGJhY2tbYV0pJiZULmNhbGwoYy5zdHlsZUFsaWFzZXMscykmJihzPWMuc3R5bGVBbGlhc2VzW3NdKSxuW2FdPXM7cmV0dXJuIG59ZnVuY3Rpb24gcihlKXt2YXIgdCxuLGk7aWYodD1lLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLGU8PTI1NSluPVwieFwiLGk9MjtlbHNlIGlmKGU8PTY1NTM1KW49XCJ1XCIsaT00O2Vsc2V7aWYoIShlPD00Mjk0OTY3Mjk1KSl0aHJvdyBuZXcgRihcImNvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkZcIik7bj1cIlVcIixpPTh9cmV0dXJuXCJcXFxcXCIrbitFLnJlcGVhdChcIjBcIixpLXQubGVuZ3RoKSt0fWZ1bmN0aW9uIG8oZSl7dGhpcy5zY2hlbWE9ZS5zY2hlbWF8fF8sdGhpcy5pbmRlbnQ9TWF0aC5tYXgoMSxlLmluZGVudHx8MiksdGhpcy5za2lwSW52YWxpZD1lLnNraXBJbnZhbGlkfHwhMSx0aGlzLmZsb3dMZXZlbD1FLmlzTm90aGluZyhlLmZsb3dMZXZlbCk/LTE6ZS5mbG93TGV2ZWwsdGhpcy5zdHlsZU1hcD1pKHRoaXMuc2NoZW1hLGUuc3R5bGVzfHxudWxsKSx0aGlzLnNvcnRLZXlzPWUuc29ydEtleXN8fCExLHRoaXMubGluZVdpZHRoPWUubGluZVdpZHRofHw4MCx0aGlzLm5vUmVmcz1lLm5vUmVmc3x8ITEsdGhpcy5ub0NvbXBhdE1vZGU9ZS5ub0NvbXBhdE1vZGV8fCExLHRoaXMuY29uZGVuc2VGbG93PWUuY29uZGVuc2VGbG93fHwhMSx0aGlzLmltcGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdCx0aGlzLmV4cGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdCx0aGlzLnRhZz1udWxsLHRoaXMucmVzdWx0PVwiXCIsdGhpcy5kdXBsaWNhdGVzPVtdLHRoaXMudXNlZER1cGxpY2F0ZXM9bnVsbH1mdW5jdGlvbiBhKGUsdCl7Zm9yKHZhciBuLGk9RS5yZXBlYXQoXCIgXCIsdCkscj0wLG89LTEsYT1cIlwiLHM9ZS5sZW5ndGg7cjxzOyktMT09PShvPWUuaW5kZXhPZihcIlxcblwiLHIpKT8obj1lLnNsaWNlKHIpLHI9cyk6KG49ZS5zbGljZShyLG8rMSkscj1vKzEpLG4ubGVuZ3RoJiZcIlxcblwiIT09biYmKGErPWkpLGErPW47cmV0dXJuIGF9ZnVuY3Rpb24gcyhlLHQpe3JldHVyblwiXFxuXCIrRS5yZXBlYXQoXCIgXCIsZS5pbmRlbnQqdCl9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuLGk7Zm9yKG49MCxpPWUuaW1wbGljaXRUeXBlcy5sZW5ndGg7bjxpO24rPTEpaWYoZS5pbXBsaWNpdFR5cGVzW25dLnJlc29sdmUodCkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gdShlKXtyZXR1cm4gZT09PVV8fGU9PT1MfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIDMyPD1lJiZlPD0xMjZ8fDE2MTw9ZSYmZTw9NTUyOTUmJjgyMzIhPT1lJiY4MjMzIT09ZXx8NTczNDQ8PWUmJmU8PTY1NTMzJiY2NTI3OSE9PWV8fDY1NTM2PD1lJiZlPD0xMTE0MTExfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGwoZSkmJjY1Mjc5IT09ZSYmZSE9PSQmJmUhPT1KJiZlIT09USYmZSE9PWVlJiZlIT09bmUmJmUhPT1HJiZlIT09Un1mdW5jdGlvbiBmKGUpe3JldHVybiBsKGUpJiY2NTI3OSE9PWUmJiF1KGUpJiZlIT09SCYmZSE9PVomJmUhPT1HJiZlIT09JCYmZSE9PUomJmUhPT1RJiZlIT09ZWUmJmUhPT1uZSYmZSE9PVImJmUhPT1XJiZlIT09SyYmZSE9PXEmJmUhPT10ZSYmZSE9PVYmJmUhPT1CJiZlIT09WSYmZSE9PVAmJmUhPT16JiZlIT09WH1mdW5jdGlvbiBkKGUsdCxuLGkscil7dmFyIG8sYSxzPSExLGM9ITEsZD0tMSE9PWksaD0tMSxtPWYoZS5jaGFyQ29kZUF0KDApKSYmIXUoZS5jaGFyQ29kZUF0KGUubGVuZ3RoLTEpKTtpZih0KWZvcihvPTA7bzxlLmxlbmd0aDtvKyspe2lmKGE9ZS5jaGFyQ29kZUF0KG8pLCFsKGEpKXJldHVybiB1ZTttPW0mJnAoYSl9ZWxzZXtmb3Iobz0wO288ZS5sZW5ndGg7bysrKXtpZigoYT1lLmNoYXJDb2RlQXQobykpPT09RClzPSEwLGQmJihjPWN8fG8taC0xPmkmJlwiIFwiIT09ZVtoKzFdLGg9byk7ZWxzZSBpZighbChhKSlyZXR1cm4gdWU7bT1tJiZwKGEpfWM9Y3x8ZCYmby1oLTE+aSYmXCIgXCIhPT1lW2grMV19cmV0dXJuIHN8fGM/XCIgXCI9PT1lWzBdJiZuPjk/dWU6Yz9jZTpzZTptJiYhcihlKT9vZTphZX1mdW5jdGlvbiBoKGUsdCxuLGkpe2UuZHVtcD1mdW5jdGlvbigpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm5cIicnXCI7aWYoIWUubm9Db21wYXRNb2RlJiYtMSE9PXJlLmluZGV4T2YodCkpcmV0dXJuXCInXCIrdCtcIidcIjt2YXIgcj1lLmluZGVudCpNYXRoLm1heCgxLG4pLG89LTE9PT1lLmxpbmVXaWR0aD8tMTpNYXRoLm1heChNYXRoLm1pbihlLmxpbmVXaWR0aCw0MCksZS5saW5lV2lkdGgtcikscz1pfHxlLmZsb3dMZXZlbD4tMSYmbj49ZS5mbG93TGV2ZWw7c3dpdGNoKGQodCxzLGUuaW5kZW50LG8sZnVuY3Rpb24odCl7cmV0dXJuIGMoZSx0KX0pKXtjYXNlIG9lOnJldHVybiB0O2Nhc2UgYWU6cmV0dXJuXCInXCIrdC5yZXBsYWNlKC8nL2csXCInJ1wiKStcIidcIjtjYXNlIHNlOnJldHVyblwifFwiK20odCxlLmluZGVudCkrZyhhKHQscikpO2Nhc2UgY2U6cmV0dXJuXCI+XCIrbSh0LGUuaW5kZW50KStnKGEoeSh0LG8pLHIpKTtjYXNlIHVlOnJldHVybidcIicrdih0KSsnXCInO2RlZmF1bHQ6dGhyb3cgbmV3IEYoXCJpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZVwiKX19KCl9ZnVuY3Rpb24gbShlLHQpe3ZhciBuPVwiIFwiPT09ZVswXT9TdHJpbmcodCk6XCJcIixpPVwiXFxuXCI9PT1lW2UubGVuZ3RoLTFdO3JldHVybiBuKyhpJiYoXCJcXG5cIj09PWVbZS5sZW5ndGgtMl18fFwiXFxuXCI9PT1lKT9cIitcIjppP1wiXCI6XCItXCIpK1wiXFxuXCJ9ZnVuY3Rpb24gZyhlKXtyZXR1cm5cIlxcblwiPT09ZVtlLmxlbmd0aC0xXT9lLnNsaWNlKDAsLTEpOmV9ZnVuY3Rpb24geShlLHQpe2Zvcih2YXIgbixpLHI9LyhcXG4rKShbXlxcbl0qKS9nLG89ZnVuY3Rpb24oKXt2YXIgbj1lLmluZGV4T2YoXCJcXG5cIik7cmV0dXJuIG49LTEhPT1uP246ZS5sZW5ndGgsci5sYXN0SW5kZXg9bix4KGUuc2xpY2UoMCxuKSx0KX0oKSxhPVwiXFxuXCI9PT1lWzBdfHxcIiBcIj09PWVbMF07aT1yLmV4ZWMoZSk7KXt2YXIgcz1pWzFdLGM9aVsyXTtuPVwiIFwiPT09Y1swXSxvKz1zKyhhfHxufHxcIlwiPT09Yz9cIlwiOlwiXFxuXCIpK3goYyx0KSxhPW59cmV0dXJuIG99ZnVuY3Rpb24geChlLHQpe2lmKFwiXCI9PT1lfHxcIiBcIj09PWVbMF0pcmV0dXJuIGU7Zm9yKHZhciBuLGkscj0vIFteIF0vZyxvPTAsYT0wLHM9MCxjPVwiXCI7bj1yLmV4ZWMoZSk7KShzPW4uaW5kZXgpLW8+dCYmKGk9YT5vP2E6cyxjKz1cIlxcblwiK2Uuc2xpY2UobyxpKSxvPWkrMSksYT1zO3JldHVybiBjKz1cIlxcblwiLGUubGVuZ3RoLW8+dCYmYT5vP2MrPWUuc2xpY2UobyxhKStcIlxcblwiK2Uuc2xpY2UoYSsxKTpjKz1lLnNsaWNlKG8pLGMuc2xpY2UoMSl9ZnVuY3Rpb24gdihlKXtmb3IodmFyIHQsbixpLG89XCJcIixhPTA7YTxlLmxlbmd0aDthKyspKHQ9ZS5jaGFyQ29kZUF0KGEpKT49NTUyOTYmJnQ8PTU2MzE5JiYobj1lLmNoYXJDb2RlQXQoYSsxKSk+PTU2MzIwJiZuPD01NzM0Mz8obys9cigxMDI0Kih0LTU1Mjk2KStuLTU2MzIwKzY1NTM2KSxhKyspOm8rPSEoaT1pZVt0XSkmJmwodCk/ZVthXTppfHxyKHQpO3JldHVybiBvfWZ1bmN0aW9uIEEoZSx0LG4pe3ZhciBpLHIsbz1cIlwiLGE9ZS50YWc7Zm9yKGk9MCxyPW4ubGVuZ3RoO2k8cjtpKz0xKWooZSx0LG5baV0sITEsITEpJiYoMCE9PWkmJihvKz1cIixcIisoZS5jb25kZW5zZUZsb3c/XCJcIjpcIiBcIikpLG8rPWUuZHVtcCk7ZS50YWc9YSxlLmR1bXA9XCJbXCIrbytcIl1cIn1mdW5jdGlvbiBiKGUsdCxuLGkpe3ZhciByLG8sYT1cIlwiLGM9ZS50YWc7Zm9yKHI9MCxvPW4ubGVuZ3RoO3I8bztyKz0xKWooZSx0KzEsbltyXSwhMCwhMCkmJihpJiYwPT09cnx8KGErPXMoZSx0KSksZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/YSs9XCItXCI6YSs9XCItIFwiLGErPWUuZHVtcCk7ZS50YWc9YyxlLmR1bXA9YXx8XCJbXVwifWZ1bmN0aW9uIHcoZSx0LG4pe3ZhciBpLHIsbyxhLHMsYz1cIlwiLHU9ZS50YWcsbD1PYmplY3Qua2V5cyhuKTtmb3IoaT0wLHI9bC5sZW5ndGg7aTxyO2krPTEpcz1lLmNvbmRlbnNlRmxvdz8nXCInOlwiXCIsMCE9PWkmJihzKz1cIiwgXCIpLGE9bltvPWxbaV1dLGooZSx0LG8sITEsITEpJiYoZS5kdW1wLmxlbmd0aD4xMDI0JiYocys9XCI/IFwiKSxzKz1lLmR1bXArKGUuY29uZGVuc2VGbG93PydcIic6XCJcIikrXCI6XCIrKGUuY29uZGVuc2VGbG93P1wiXCI6XCIgXCIpLGooZSx0LGEsITEsITEpJiYoYys9cys9ZS5kdW1wKSk7ZS50YWc9dSxlLmR1bXA9XCJ7XCIrYytcIn1cIn1mdW5jdGlvbiBDKGUsdCxuLGkpe3ZhciByLG8sYSxjLHUsbCxwPVwiXCIsZj1lLnRhZyxkPU9iamVjdC5rZXlzKG4pO2lmKCEwPT09ZS5zb3J0S2V5cylkLnNvcnQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc29ydEtleXMpZC5zb3J0KGUuc29ydEtleXMpO2Vsc2UgaWYoZS5zb3J0S2V5cyl0aHJvdyBuZXcgRihcInNvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb25cIik7Zm9yKHI9MCxvPWQubGVuZ3RoO3I8bztyKz0xKWw9XCJcIixpJiYwPT09cnx8KGwrPXMoZSx0KSksYz1uW2E9ZFtyXV0saihlLHQrMSxhLCEwLCEwLCEwKSYmKCh1PW51bGwhPT1lLnRhZyYmXCI/XCIhPT1lLnRhZ3x8ZS5kdW1wJiZlLmR1bXAubGVuZ3RoPjEwMjQpJiYoZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/bCs9XCI/XCI6bCs9XCI/IFwiKSxsKz1lLmR1bXAsdSYmKGwrPXMoZSx0KSksaihlLHQrMSxjLCEwLHUpJiYoZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/bCs9XCI6XCI6bCs9XCI6IFwiLHArPWwrPWUuZHVtcCkpO2UudGFnPWYsZS5kdW1wPXB8fFwie31cIn1mdW5jdGlvbiBrKGUsdCxuKXt2YXIgaSxyLG8sYSxzLGM7Zm9yKG89MCxhPShyPW4/ZS5leHBsaWNpdFR5cGVzOmUuaW1wbGljaXRUeXBlcykubGVuZ3RoO288YTtvKz0xKWlmKCgocz1yW29dKS5pbnN0YW5jZU9mfHxzLnByZWRpY2F0ZSkmJighcy5pbnN0YW5jZU9mfHxcIm9iamVjdFwiPT10eXBlb2YgdCYmdCBpbnN0YW5jZW9mIHMuaW5zdGFuY2VPZikmJighcy5wcmVkaWNhdGV8fHMucHJlZGljYXRlKHQpKSl7aWYoZS50YWc9bj9zLnRhZzpcIj9cIixzLnJlcHJlc2VudCl7aWYoYz1lLnN0eWxlTWFwW3MudGFnXXx8cy5kZWZhdWx0U3R5bGUsXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT09TS5jYWxsKHMucmVwcmVzZW50KSlpPXMucmVwcmVzZW50KHQsYyk7ZWxzZXtpZighVC5jYWxsKHMucmVwcmVzZW50LGMpKXRocm93IG5ldyBGKFwiITxcIitzLnRhZysnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInK2MrJ1wiIHN0eWxlJyk7aT1zLnJlcHJlc2VudFtjXSh0LGMpfWUuZHVtcD1pfXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGooZSx0LG4saSxyLG8pe2UudGFnPW51bGwsZS5kdW1wPW4sayhlLG4sITEpfHxrKGUsbiwhMCk7dmFyIGE9TS5jYWxsKGUuZHVtcCk7aSYmKGk9ZS5mbG93TGV2ZWw8MHx8ZS5mbG93TGV2ZWw+dCk7dmFyIHMsYyx1PVwiW29iamVjdCBPYmplY3RdXCI9PT1hfHxcIltvYmplY3QgQXJyYXldXCI9PT1hO2lmKHUmJihjPS0xIT09KHM9ZS5kdXBsaWNhdGVzLmluZGV4T2YobikpKSwobnVsbCE9PWUudGFnJiZcIj9cIiE9PWUudGFnfHxjfHwyIT09ZS5pbmRlbnQmJnQ+MCkmJihyPSExKSxjJiZlLnVzZWREdXBsaWNhdGVzW3NdKWUuZHVtcD1cIipyZWZfXCIrcztlbHNle2lmKHUmJmMmJiFlLnVzZWREdXBsaWNhdGVzW3NdJiYoZS51c2VkRHVwbGljYXRlc1tzXT0hMCksXCJbb2JqZWN0IE9iamVjdF1cIj09PWEpaSYmMCE9PU9iamVjdC5rZXlzKGUuZHVtcCkubGVuZ3RoPyhDKGUsdCxlLmR1bXAsciksYyYmKGUuZHVtcD1cIiZyZWZfXCIrcytlLmR1bXApKToodyhlLHQsZS5kdW1wKSxjJiYoZS5kdW1wPVwiJnJlZl9cIitzK1wiIFwiK2UuZHVtcCkpO2Vsc2UgaWYoXCJbb2JqZWN0IEFycmF5XVwiPT09YSlpJiYwIT09ZS5kdW1wLmxlbmd0aD8oYihlLHQsZS5kdW1wLHIpLGMmJihlLmR1bXA9XCImcmVmX1wiK3MrZS5kdW1wKSk6KEEoZSx0LGUuZHVtcCksYyYmKGUuZHVtcD1cIiZyZWZfXCIrcytcIiBcIitlLmR1bXApKTtlbHNle2lmKFwiW29iamVjdCBTdHJpbmddXCIhPT1hKXtpZihlLnNraXBJbnZhbGlkKXJldHVybiExO3Rocm93IG5ldyBGKFwidW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgXCIrYSl9XCI/XCIhPT1lLnRhZyYmaChlLGUuZHVtcCx0LG8pfW51bGwhPT1lLnRhZyYmXCI/XCIhPT1lLnRhZyYmKGUuZHVtcD1cIiE8XCIrZS50YWcrXCI+IFwiK2UuZHVtcCl9cmV0dXJuITB9ZnVuY3Rpb24gSShlLHQpe3ZhciBuLGkscj1bXSxvPVtdO2ZvcihTKGUscixvKSxuPTAsaT1vLmxlbmd0aDtuPGk7bis9MSl0LmR1cGxpY2F0ZXMucHVzaChyW29bbl1dKTt0LnVzZWREdXBsaWNhdGVzPW5ldyBBcnJheShpKX1mdW5jdGlvbiBTKGUsdCxuKXt2YXIgaSxyLG87aWYobnVsbCE9PWUmJlwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKC0xIT09KHI9dC5pbmRleE9mKGUpKSktMT09PW4uaW5kZXhPZihyKSYmbi5wdXNoKHIpO2Vsc2UgaWYodC5wdXNoKGUpLEFycmF5LmlzQXJyYXkoZSkpZm9yKHI9MCxvPWUubGVuZ3RoO3I8bztyKz0xKVMoZVtyXSx0LG4pO2Vsc2UgZm9yKHI9MCxvPShpPU9iamVjdC5rZXlzKGUpKS5sZW5ndGg7cjxvO3IrPTEpUyhlW2lbcl1dLHQsbil9ZnVuY3Rpb24gTyhlLHQpe3ZhciBuPW5ldyBvKHQ9dHx8e30pO3JldHVybiBuLm5vUmVmc3x8SShlLG4pLGoobiwwLGUsITAsITApP24uZHVtcCtcIlxcblwiOlwiXCJ9dmFyIEU9ZShcIi4vY29tbW9uXCIpLEY9ZShcIi4vZXhjZXB0aW9uXCIpLF89ZShcIi4vc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSxOPWUoXCIuL3NjaGVtYS9kZWZhdWx0X3NhZmVcIiksTT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxMPTksRD0xMCxVPTMyLHE9MzMsWT0zNCxSPTM1LFA9MzcsVz0zOCxCPTM5LEs9NDIsJD00NCxIPTQ1LEc9NTgsVj02MixaPTYzLHo9NjQsSj05MSxRPTkzLFg9OTYsZWU9MTIzLHRlPTEyNCxuZT0xMjUsaWU9e307aWVbMF09XCJcXFxcMFwiLGllWzddPVwiXFxcXGFcIixpZVs4XT1cIlxcXFxiXCIsaWVbOV09XCJcXFxcdFwiLGllWzEwXT1cIlxcXFxuXCIsaWVbMTFdPVwiXFxcXHZcIixpZVsxMl09XCJcXFxcZlwiLGllWzEzXT1cIlxcXFxyXCIsaWVbMjddPVwiXFxcXGVcIixpZVszNF09J1xcXFxcIicsaWVbOTJdPVwiXFxcXFxcXFxcIixpZVsxMzNdPVwiXFxcXE5cIixpZVsxNjBdPVwiXFxcXF9cIixpZVs4MjMyXT1cIlxcXFxMXCIsaWVbODIzM109XCJcXFxcUFwiO3ZhciByZT1bXCJ5XCIsXCJZXCIsXCJ5ZXNcIixcIlllc1wiLFwiWUVTXCIsXCJvblwiLFwiT25cIixcIk9OXCIsXCJuXCIsXCJOXCIsXCJub1wiLFwiTm9cIixcIk5PXCIsXCJvZmZcIixcIk9mZlwiLFwiT0ZGXCJdLG9lPTEsYWU9MixzZT0zLGNlPTQsdWU9NTt0LmV4cG9ydHMuZHVtcD1PLHQuZXhwb3J0cy5zYWZlRHVtcD1mdW5jdGlvbihlLHQpe3JldHVybiBPKGUsRS5leHRlbmQoe3NjaGVtYTpOfSx0KSl9fSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL3NjaGVtYS9kZWZhdWx0X2Z1bGxcIjo5LFwiLi9zY2hlbWEvZGVmYXVsdF9zYWZlXCI6MTB9XSw0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQpe0Vycm9yLmNhbGwodGhpcyksdGhpcy5uYW1lPVwiWUFNTEV4Y2VwdGlvblwiLHRoaXMucmVhc29uPWUsdGhpcy5tYXJrPXQsdGhpcy5tZXNzYWdlPSh0aGlzLnJlYXNvbnx8XCIodW5rbm93biByZWFzb24pXCIpKyh0aGlzLm1hcms/XCIgXCIrdGhpcy5tYXJrLnRvU3RyaW5nKCk6XCJcIiksRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0aGlzLmNvbnN0cnVjdG9yKTp0aGlzLnN0YWNrPShuZXcgRXJyb3IpLnN0YWNrfHxcIlwifShpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5uYW1lK1wiOiBcIjtyZXR1cm4gdCs9dGhpcy5yZWFzb258fFwiKHVua25vd24gcmVhc29uKVwiLCFlJiZ0aGlzLm1hcmsmJih0Kz1cIiBcIit0aGlzLm1hcmsudG9TdHJpbmcoKSksdH0sdC5leHBvcnRzPWl9LHt9XSw1OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXtyZXR1cm4gMTA9PT1lfHwxMz09PWV9ZnVuY3Rpb24gcihlKXtyZXR1cm4gOT09PWV8fDMyPT09ZX1mdW5jdGlvbiBvKGUpe3JldHVybiA5PT09ZXx8MzI9PT1lfHwxMD09PWV8fDEzPT09ZX1mdW5jdGlvbiBhKGUpe3JldHVybiA0ND09PWV8fDkxPT09ZXx8OTM9PT1lfHwxMjM9PT1lfHwxMjU9PT1lfWZ1bmN0aW9uIHMoZSl7dmFyIHQ7cmV0dXJuIDQ4PD1lJiZlPD01Nz9lLTQ4Ojk3PD0odD0zMnxlKSYmdDw9MTAyP3QtOTcrMTA6LTF9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gMTIwPT09ZT8yOjExNz09PWU/NDo4NT09PWU/ODowfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIDQ4PD1lJiZlPD01Nz9lLTQ4Oi0xfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIDQ4PT09ZT9cIlxcMFwiOjk3PT09ZT9cIlx1MDAwN1wiOjk4PT09ZT9cIlxcYlwiOjExNj09PWU/XCJcXHRcIjo5PT09ZT9cIlxcdFwiOjExMD09PWU/XCJcXG5cIjoxMTg9PT1lP1wiXFx2XCI6MTAyPT09ZT9cIlxcZlwiOjExND09PWU/XCJcXHJcIjoxMDE9PT1lP1wiXHUwMDFiXCI6MzI9PT1lP1wiIFwiOjM0PT09ZT8nXCInOjQ3PT09ZT9cIi9cIjo5Mj09PWU/XCJcXFxcXCI6Nzg9PT1lP1wiwoVcIjo5NT09PWU/XCLCoFwiOjc2PT09ZT9cIlxcdTIwMjhcIjo4MD09PWU/XCJcXHUyMDI5XCI6XCJcIn1mdW5jdGlvbiBwKGUpe3JldHVybiBlPD02NTUzNT9TdHJpbmcuZnJvbUNoYXJDb2RlKGUpOlN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGUtNjU1MzY+PjEwKSw1NjMyMCsoZS02NTUzNiYxMDIzKSl9ZnVuY3Rpb24gZihlLHQpe3RoaXMuaW5wdXQ9ZSx0aGlzLmZpbGVuYW1lPXQuZmlsZW5hbWV8fG51bGwsdGhpcy5zY2hlbWE9dC5zY2hlbWF8fFcsdGhpcy5vbldhcm5pbmc9dC5vbldhcm5pbmd8fG51bGwsdGhpcy5sZWdhY3k9dC5sZWdhY3l8fCExLHRoaXMuanNvbj10Lmpzb258fCExLHRoaXMubGlzdGVuZXI9dC5saXN0ZW5lcnx8bnVsbCx0aGlzLmltcGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdCx0aGlzLnR5cGVNYXA9dGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwLHRoaXMubGVuZ3RoPWUubGVuZ3RoLHRoaXMucG9zaXRpb249MCx0aGlzLmxpbmU9MCx0aGlzLmxpbmVTdGFydD0wLHRoaXMubGluZUluZGVudD0wLHRoaXMuZG9jdW1lbnRzPVtdfWZ1bmN0aW9uIGQoZSx0KXtyZXR1cm4gbmV3IFkodCxuZXcgUihlLmZpbGVuYW1lLGUuaW5wdXQsZS5wb3NpdGlvbixlLmxpbmUsZS5wb3NpdGlvbi1lLmxpbmVTdGFydCkpfWZ1bmN0aW9uIGgoZSx0KXt0aHJvdyBkKGUsdCl9ZnVuY3Rpb24gbShlLHQpe2Uub25XYXJuaW5nJiZlLm9uV2FybmluZy5jYWxsKG51bGwsZChlLHQpKX1mdW5jdGlvbiBnKGUsdCxuLGkpe3ZhciByLG8sYSxzO2lmKHQ8bil7aWYocz1lLmlucHV0LnNsaWNlKHQsbiksaSlmb3Iocj0wLG89cy5sZW5ndGg7cjxvO3IrPTEpOT09PShhPXMuY2hhckNvZGVBdChyKSl8fDMyPD1hJiZhPD0xMTE0MTExfHxoKGUsXCJleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlclwiKTtlbHNlIEoudGVzdChzKSYmaChlLFwidGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnNcIik7ZS5yZXN1bHQrPXN9fWZ1bmN0aW9uIHkoZSx0LG4saSl7dmFyIHIsbyxhLHM7Zm9yKHEuaXNPYmplY3Qobil8fGgoZSxcImNhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlXCIpLGE9MCxzPShyPU9iamVjdC5rZXlzKG4pKS5sZW5ndGg7YTxzO2ErPTEpbz1yW2FdLEIuY2FsbCh0LG8pfHwodFtvXT1uW29dLGlbb109ITApfWZ1bmN0aW9uIHgoZSx0LG4saSxyLG8sYSxzKXt2YXIgYyx1O2lmKHI9U3RyaW5nKHIpLG51bGw9PT10JiYodD17fSksXCJ0YWc6eWFtbC5vcmcsMjAwMjptZXJnZVwiPT09aSlpZihBcnJheS5pc0FycmF5KG8pKWZvcihjPTAsdT1vLmxlbmd0aDtjPHU7Yys9MSl5KGUsdCxvW2NdLG4pO2Vsc2UgeShlLHQsbyxuKTtlbHNlIGUuanNvbnx8Qi5jYWxsKG4scil8fCFCLmNhbGwodCxyKXx8KGUubGluZT1hfHxlLmxpbmUsZS5wb3NpdGlvbj1zfHxlLnBvc2l0aW9uLGgoZSxcImR1cGxpY2F0ZWQgbWFwcGluZyBrZXlcIikpLHRbcl09byxkZWxldGUgbltyXTtyZXR1cm4gdH1mdW5jdGlvbiB2KGUpe3ZhciB0OzEwPT09KHQ9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKT9lLnBvc2l0aW9uKys6MTM9PT10PyhlLnBvc2l0aW9uKyssMTA9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJmUucG9zaXRpb24rKyk6aChlLFwiYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkXCIpLGUubGluZSs9MSxlLmxpbmVTdGFydD1lLnBvc2l0aW9ufWZ1bmN0aW9uIEEoZSx0LG4pe2Zvcih2YXIgbz0wLGE9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pOzAhPT1hOyl7Zm9yKDtyKGEpOylhPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKHQmJjM1PT09YSlkb3thPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKDEwIT09YSYmMTMhPT1hJiYwIT09YSk7aWYoIWkoYSkpYnJlYWs7Zm9yKHYoZSksYT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksbysrLGUubGluZUluZGVudD0wOzMyPT09YTspZS5saW5lSW5kZW50KyssYT1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX1yZXR1cm4tMSE9PW4mJjAhPT1vJiZlLmxpbmVJbmRlbnQ8biYmbShlLFwiZGVmaWNpZW50IGluZGVudGF0aW9uXCIpLG99ZnVuY3Rpb24gYihlKXt2YXIgdCxuPWUucG9zaXRpb247cmV0dXJuISg0NSE9PSh0PWUuaW5wdXQuY2hhckNvZGVBdChuKSkmJjQ2IT09dHx8dCE9PWUuaW5wdXQuY2hhckNvZGVBdChuKzEpfHx0IT09ZS5pbnB1dC5jaGFyQ29kZUF0KG4rMil8fChuKz0zLDAhPT0odD1lLmlucHV0LmNoYXJDb2RlQXQobikpJiYhbyh0KSkpfWZ1bmN0aW9uIHcoZSx0KXsxPT09dD9lLnJlc3VsdCs9XCIgXCI6dD4xJiYoZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsdC0xKSl9ZnVuY3Rpb24gQyhlLHQsbil7dmFyIHMsYyx1LGwscCxmLGQsaCxtLHk9ZS5raW5kLHg9ZS5yZXN1bHQ7aWYobT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksbyhtKXx8YShtKXx8MzU9PT1tfHwzOD09PW18fDQyPT09bXx8MzM9PT1tfHwxMjQ9PT1tfHw2Mj09PW18fDM5PT09bXx8MzQ9PT1tfHwzNz09PW18fDY0PT09bXx8OTY9PT1tKXJldHVybiExO2lmKCg2Mz09PW18fDQ1PT09bSkmJihjPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKzEpLG8oYyl8fG4mJmEoYykpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLHU9bD1lLnBvc2l0aW9uLHA9ITE7MCE9PW07KXtpZig1OD09PW0pe2lmKGM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSksbyhjKXx8biYmYShjKSlicmVha31lbHNlIGlmKDM1PT09bSl7aWYocz1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbi0xKSxvKHMpKWJyZWFrfWVsc2V7aWYoZS5wb3NpdGlvbj09PWUubGluZVN0YXJ0JiZiKGUpfHxuJiZhKG0pKWJyZWFrO2lmKGkobSkpe2lmKGY9ZS5saW5lLGQ9ZS5saW5lU3RhcnQsaD1lLmxpbmVJbmRlbnQsQShlLCExLC0xKSxlLmxpbmVJbmRlbnQ+PXQpe3A9ITAsbT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbik7Y29udGludWV9ZS5wb3NpdGlvbj1sLGUubGluZT1mLGUubGluZVN0YXJ0PWQsZS5saW5lSW5kZW50PWg7YnJlYWt9fXAmJihnKGUsdSxsLCExKSx3KGUsZS5saW5lLWYpLHU9bD1lLnBvc2l0aW9uLHA9ITEpLHIobSl8fChsPWUucG9zaXRpb24rMSksbT1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX1yZXR1cm4gZyhlLHUsbCwhMSksISFlLnJlc3VsdHx8KGUua2luZD15LGUucmVzdWx0PXgsITEpfWZ1bmN0aW9uIGsoZSx0KXt2YXIgbixyLG87aWYoMzkhPT0obj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLGUucG9zaXRpb24rKyxyPW89ZS5wb3NpdGlvbjswIT09KG49ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKTspaWYoMzk9PT1uKXtpZihnKGUscixlLnBvc2l0aW9uLCEwKSwzOSE9PShuPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pKSlyZXR1cm4hMDtyPWUucG9zaXRpb24sZS5wb3NpdGlvbisrLG89ZS5wb3NpdGlvbn1lbHNlIGkobik/KGcoZSxyLG8sITApLHcoZSxBKGUsITEsdCkpLHI9bz1lLnBvc2l0aW9uKTplLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyXCIpOihlLnBvc2l0aW9uKyssbz1lLnBvc2l0aW9uKTtoKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyXCIpfWZ1bmN0aW9uIGooZSx0KXt2YXIgbixyLG8sYSx1LGw7aWYoMzQhPT0obD1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLGUucG9zaXRpb24rKyxuPXI9ZS5wb3NpdGlvbjswIT09KGw9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKTspe2lmKDM0PT09bClyZXR1cm4gZyhlLG4sZS5wb3NpdGlvbiwhMCksZS5wb3NpdGlvbisrLCEwO2lmKDkyPT09bCl7aWYoZyhlLG4sZS5wb3NpdGlvbiwhMCksbD1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSxpKGwpKUEoZSwhMSx0KTtlbHNlIGlmKGw8MjU2JiZuZVtsXSllLnJlc3VsdCs9aWVbbF0sZS5wb3NpdGlvbisrO2Vsc2UgaWYoKHU9YyhsKSk+MCl7Zm9yKG89dSxhPTA7bz4wO28tLSkodT1zKGw9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpKT49MD9hPShhPDw0KSt1OmgoZSxcImV4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlclwiKTtlLnJlc3VsdCs9cChhKSxlLnBvc2l0aW9uKyt9ZWxzZSBoKGUsXCJ1bmtub3duIGVzY2FwZSBzZXF1ZW5jZVwiKTtuPXI9ZS5wb3NpdGlvbn1lbHNlIGkobCk/KGcoZSxuLHIsITApLHcoZSxBKGUsITEsdCkpLG49cj1lLnBvc2l0aW9uKTplLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyXCIpOihlLnBvc2l0aW9uKysscj1lLnBvc2l0aW9uKX1oKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyXCIpfWZ1bmN0aW9uIEkoZSx0KXt2YXIgbixpLHIsYSxzLGMsdSxsLHAsZixkPSEwLG09ZS50YWcsZz1lLmFuY2hvcix5PXt9O2lmKDkxPT09KGY9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSlyPTkzLGM9ITEsaT1bXTtlbHNle2lmKDEyMyE9PWYpcmV0dXJuITE7cj0xMjUsYz0hMCxpPXt9fWZvcihudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09aSksZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKTswIT09Zjspe2lmKEEoZSwhMCx0KSwoZj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpPT09cilyZXR1cm4gZS5wb3NpdGlvbisrLGUudGFnPW0sZS5hbmNob3I9ZyxlLmtpbmQ9Yz9cIm1hcHBpbmdcIjpcInNlcXVlbmNlXCIsZS5yZXN1bHQ9aSwhMDtkfHxoKGUsXCJtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllc1wiKSxsPXU9cD1udWxsLGE9cz0hMSw2Mz09PWYmJm8oZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkpJiYoYT1zPSEwLGUucG9zaXRpb24rKyxBKGUsITAsdCkpLG49ZS5saW5lLE0oZSx0LEssITEsITApLGw9ZS50YWcsdT1lLnJlc3VsdCxBKGUsITAsdCksZj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksIXMmJmUubGluZSE9PW58fDU4IT09Znx8KGE9ITAsZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSxBKGUsITAsdCksTShlLHQsSywhMSwhMCkscD1lLnJlc3VsdCksYz94KGUsaSx5LGwsdSxwKTphP2kucHVzaCh4KGUsbnVsbCx5LGwsdSxwKSk6aS5wdXNoKHUpLEEoZSwhMCx0KSw0ND09PShmPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKSk/KGQ9ITAsZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6ZD0hMX1oKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvblwiKX1mdW5jdGlvbiBTKGUsdCl7dmFyIG4sbyxhLHMsYz1WLGw9ITEscD0hMSxmPXQsZD0wLG09ITE7aWYoMTI0PT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSlvPSExO2Vsc2V7aWYoNjIhPT1zKXJldHVybiExO289ITB9Zm9yKGUua2luZD1cInNjYWxhclwiLGUucmVzdWx0PVwiXCI7MCE9PXM7KWlmKDQzPT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpfHw0NT09PXMpVj09PWM/Yz00Mz09PXM/ejpaOmgoZSxcInJlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllclwiKTtlbHNle2lmKCEoKGE9dShzKSk+PTApKWJyZWFrOzA9PT1hP2goZSxcImJhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmVcIik6cD9oKGUsXCJyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllclwiKTooZj10K2EtMSxwPSEwKX1pZihyKHMpKXtkb3tzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKHIocykpO2lmKDM1PT09cylkb3tzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKCFpKHMpJiYwIT09cyl9Zm9yKDswIT09czspe2Zvcih2KGUpLGUubGluZUluZGVudD0wLHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pOyghcHx8ZS5saW5lSW5kZW50PGYpJiYzMj09PXM7KWUubGluZUluZGVudCsrLHM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7aWYoIXAmJmUubGluZUluZGVudD5mJiYoZj1lLmxpbmVJbmRlbnQpLGkocykpZCsrO2Vsc2V7aWYoZS5saW5lSW5kZW50PGYpe2M9PT16P2UucmVzdWx0Kz1xLnJlcGVhdChcIlxcblwiLGw/MStkOmQpOmM9PT1WJiZsJiYoZS5yZXN1bHQrPVwiXFxuXCIpO2JyZWFrfWZvcihvP3Iocyk/KG09ITAsZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsbD8xK2Q6ZCkpOm0/KG09ITEsZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsZCsxKSk6MD09PWQ/bCYmKGUucmVzdWx0Kz1cIiBcIik6ZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsZCk6ZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsbD8xK2Q6ZCksbD0hMCxwPSEwLGQ9MCxuPWUucG9zaXRpb247IWkocykmJjAhPT1zOylzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2coZSxuLGUucG9zaXRpb24sITEpfX1yZXR1cm4hMH1mdW5jdGlvbiBPKGUsdCl7dmFyIG4saSxyLGE9ZS50YWcscz1lLmFuY2hvcixjPVtdLHU9ITE7Zm9yKG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1jKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTswIT09ciYmNDU9PT1yJiYoaT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbisxKSxvKGkpKTspaWYodT0hMCxlLnBvc2l0aW9uKyssQShlLCEwLC0xKSYmZS5saW5lSW5kZW50PD10KWMucHVzaChudWxsKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTtlbHNlIGlmKG49ZS5saW5lLE0oZSx0LEgsITEsITApLGMucHVzaChlLnJlc3VsdCksQShlLCEwLC0xKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKSwoZS5saW5lPT09bnx8ZS5saW5lSW5kZW50PnQpJiYwIT09ciloKGUsXCJiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeVwiKTtlbHNlIGlmKGUubGluZUluZGVudDx0KWJyZWFrO3JldHVybiEhdSYmKGUudGFnPWEsZS5hbmNob3I9cyxlLmtpbmQ9XCJzZXF1ZW5jZVwiLGUucmVzdWx0PWMsITApfWZ1bmN0aW9uIEUoZSx0LG4pe3ZhciBpLGEscyxjLHUsbD1lLnRhZyxwPWUuYW5jaG9yLGY9e30sZD17fSxtPW51bGwsZz1udWxsLHk9bnVsbCx2PSExLGI9ITE7Zm9yKG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1mKSx1PWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTswIT09dTspe2lmKGk9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkscz1lLmxpbmUsYz1lLnBvc2l0aW9uLDYzIT09dSYmNTghPT11fHwhbyhpKSl7aWYoIU0oZSxuLCQsITEsITApKWJyZWFrO2lmKGUubGluZT09PXMpe2Zvcih1PWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTtyKHUpOyl1PWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKDU4PT09dSlvKHU9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpfHxoKGUsXCJhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmdcIiksdiYmKHgoZSxmLGQsbSxnLG51bGwpLG09Zz15PW51bGwpLGI9ITAsdj0hMSxhPSExLG09ZS50YWcsZz1lLnJlc3VsdDtlbHNle2lmKCFiKXJldHVybiBlLnRhZz1sLGUuYW5jaG9yPXAsITA7aChlLFwiY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWRcIil9fWVsc2V7aWYoIWIpcmV0dXJuIGUudGFnPWwsZS5hbmNob3I9cCwhMDtoKGUsXCJjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXlcIil9fWVsc2UgNjM9PT11Pyh2JiYoeChlLGYsZCxtLGcsbnVsbCksbT1nPXk9bnVsbCksYj0hMCx2PSEwLGE9ITApOnY/KHY9ITEsYT0hMCk6aChlLFwiaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkOyBvciBmb2xsb3dlZCBieSBhIG5vbi10YWJ1bGF0ZWQgZW1wdHkgbGluZVwiKSxlLnBvc2l0aW9uKz0xLHU9aTtpZigoZS5saW5lPT09c3x8ZS5saW5lSW5kZW50PnQpJiYoTShlLHQsRywhMCxhKSYmKHY/Zz1lLnJlc3VsdDp5PWUucmVzdWx0KSx2fHwoeChlLGYsZCxtLGcseSxzLGMpLG09Zz15PW51bGwpLEEoZSwhMCwtMSksdT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpLGUubGluZUluZGVudD50JiYwIT09dSloKGUsXCJiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5XCIpO2Vsc2UgaWYoZS5saW5lSW5kZW50PHQpYnJlYWt9cmV0dXJuIHYmJngoZSxmLGQsbSxnLG51bGwpLGImJihlLnRhZz1sLGUuYW5jaG9yPXAsZS5raW5kPVwibWFwcGluZ1wiLGUucmVzdWx0PWYpLGJ9ZnVuY3Rpb24gRihlKXt2YXIgdCxuLGkscixhPSExLHM9ITE7aWYoMzMhPT0ocj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2lmKG51bGwhPT1lLnRhZyYmaChlLFwiZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHlcIiksNjA9PT0ocj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk/KGE9ITAscj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6MzM9PT1yPyhzPSEwLG49XCIhIVwiLHI9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpOm49XCIhXCIsdD1lLnBvc2l0aW9uLGEpe2Rve3I9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbil9d2hpbGUoMCE9PXImJjYyIT09cik7ZS5wb3NpdGlvbjxlLmxlbmd0aD8oaT1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbikscj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWdcIil9ZWxzZXtmb3IoOzAhPT1yJiYhbyhyKTspMzM9PT1yJiYocz9oKGUsXCJ0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzXCIpOihuPWUuaW5wdXQuc2xpY2UodC0xLGUucG9zaXRpb24rMSksZWUudGVzdChuKXx8aChlLFwibmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnNcIikscz0hMCx0PWUucG9zaXRpb24rMSkpLHI9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7aT1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbiksWC50ZXN0KGkpJiZoKGUsXCJ0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnNcIil9cmV0dXJuIGkmJiF0ZS50ZXN0KGkpJiZoKGUsXCJ0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6IFwiK2kpLGE/ZS50YWc9aTpCLmNhbGwoZS50YWdNYXAsbik/ZS50YWc9ZS50YWdNYXBbbl0raTpcIiFcIj09PW4/ZS50YWc9XCIhXCIraTpcIiEhXCI9PT1uP2UudGFnPVwidGFnOnlhbWwub3JnLDIwMDI6XCIraTpoKGUsJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicrbisnXCInKSwhMH1mdW5jdGlvbiBfKGUpe3ZhciB0LG47aWYoMzghPT0obj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihudWxsIT09ZS5hbmNob3ImJmgoZSxcImR1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eVwiKSxuPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09biYmIW8obikmJiFhKG4pOyluPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO3JldHVybiBlLnBvc2l0aW9uPT09dCYmaChlLFwibmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlclwiKSxlLmFuY2hvcj1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbiksITB9ZnVuY3Rpb24gTihlKXt2YXIgdCxuLGk7aWYoNDIhPT0oaT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihpPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09aSYmIW8oaSkmJiFhKGkpOylpPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO3JldHVybiBlLnBvc2l0aW9uPT09dCYmaChlLFwibmFtZSBvZiBhbiBhbGlhcyBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyXCIpLG49ZS5pbnB1dC5zbGljZSh0LGUucG9zaXRpb24pLGUuYW5jaG9yTWFwLmhhc093blByb3BlcnR5KG4pfHxoKGUsJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicrbisnXCInKSxlLnJlc3VsdD1lLmFuY2hvck1hcFtuXSxBKGUsITAsLTEpLCEwfWZ1bmN0aW9uIE0oZSx0LG4saSxyKXt2YXIgbyxhLHMsYyx1LGwscCxmLGQ9MSxtPSExLGc9ITE7aWYobnVsbCE9PWUubGlzdGVuZXImJmUubGlzdGVuZXIoXCJvcGVuXCIsZSksZS50YWc9bnVsbCxlLmFuY2hvcj1udWxsLGUua2luZD1udWxsLGUucmVzdWx0PW51bGwsbz1hPXM9Rz09PW58fEg9PT1uLGkmJkEoZSwhMCwtMSkmJihtPSEwLGUubGluZUluZGVudD50P2Q9MTplLmxpbmVJbmRlbnQ9PT10P2Q9MDplLmxpbmVJbmRlbnQ8dCYmKGQ9LTEpKSwxPT09ZClmb3IoO0YoZSl8fF8oZSk7KUEoZSwhMCwtMSk/KG09ITAscz1vLGUubGluZUluZGVudD50P2Q9MTplLmxpbmVJbmRlbnQ9PT10P2Q9MDplLmxpbmVJbmRlbnQ8dCYmKGQ9LTEpKTpzPSExO2lmKHMmJihzPW18fHIpLDEhPT1kJiZHIT09bnx8KHA9Sz09PW58fCQ9PT1uP3Q6dCsxLGY9ZS5wb3NpdGlvbi1lLmxpbmVTdGFydCwxPT09ZD9zJiYoTyhlLGYpfHxFKGUsZixwKSl8fEkoZSxwKT9nPSEwOihhJiZTKGUscCl8fGsoZSxwKXx8aihlLHApP2c9ITA6TihlKT8oZz0hMCxudWxsPT09ZS50YWcmJm51bGw9PT1lLmFuY2hvcnx8aChlLFwiYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXNcIikpOkMoZSxwLEs9PT1uKSYmKGc9ITAsbnVsbD09PWUudGFnJiYoZS50YWc9XCI/XCIpKSxudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09ZS5yZXN1bHQpKTowPT09ZCYmKGc9cyYmTyhlLGYpKSksbnVsbCE9PWUudGFnJiZcIiFcIiE9PWUudGFnKWlmKFwiP1wiPT09ZS50YWcpe2ZvcihjPTAsdT1lLmltcGxpY2l0VHlwZXMubGVuZ3RoO2M8dTtjKz0xKWlmKChsPWUuaW1wbGljaXRUeXBlc1tjXSkucmVzb2x2ZShlLnJlc3VsdCkpe2UucmVzdWx0PWwuY29uc3RydWN0KGUucmVzdWx0KSxlLnRhZz1sLnRhZyxudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09ZS5yZXN1bHQpO2JyZWFrfX1lbHNlIEIuY2FsbChlLnR5cGVNYXBbZS5raW5kfHxcImZhbGxiYWNrXCJdLGUudGFnKT8obD1lLnR5cGVNYXBbZS5raW5kfHxcImZhbGxiYWNrXCJdW2UudGFnXSxudWxsIT09ZS5yZXN1bHQmJmwua2luZCE9PWUua2luZCYmaChlLFwidW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITxcIitlLnRhZysnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicrbC5raW5kKydcIiwgbm90IFwiJytlLmtpbmQrJ1wiJyksbC5yZXNvbHZlKGUucmVzdWx0KT8oZS5yZXN1bHQ9bC5jb25zdHJ1Y3QoZS5yZXN1bHQpLG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1lLnJlc3VsdCkpOmgoZSxcImNhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8XCIrZS50YWcrXCI+IGV4cGxpY2l0IHRhZ1wiKSk6aChlLFwidW5rbm93biB0YWcgITxcIitlLnRhZytcIj5cIik7cmV0dXJuIG51bGwhPT1lLmxpc3RlbmVyJiZlLmxpc3RlbmVyKFwiY2xvc2VcIixlKSxudWxsIT09ZS50YWd8fG51bGwhPT1lLmFuY2hvcnx8Z31mdW5jdGlvbiBUKGUpe3ZhciB0LG4sYSxzLGM9ZS5wb3NpdGlvbix1PSExO2ZvcihlLnZlcnNpb249bnVsbCxlLmNoZWNrTGluZUJyZWFrcz1lLmxlZ2FjeSxlLnRhZ01hcD17fSxlLmFuY2hvck1hcD17fTswIT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSYmKEEoZSwhMCwtMSkscz1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksIShlLmxpbmVJbmRlbnQ+MHx8MzchPT1zKSk7KXtmb3IodT0hMCxzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09cyYmIW8ocyk7KXM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7Zm9yKGE9W10sKG49ZS5pbnB1dC5zbGljZSh0LGUucG9zaXRpb24pKS5sZW5ndGg8MSYmaChlLFwiZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoXCIpOzAhPT1zOyl7Zm9yKDtyKHMpOylzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKDM1PT09cyl7ZG97cz1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX13aGlsZSgwIT09cyYmIWkocykpO2JyZWFrfWlmKGkocykpYnJlYWs7Zm9yKHQ9ZS5wb3NpdGlvbjswIT09cyYmIW8ocyk7KXM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7YS5wdXNoKGUuaW5wdXQuc2xpY2UodCxlLnBvc2l0aW9uKSl9MCE9PXMmJnYoZSksQi5jYWxsKG9lLG4pP29lW25dKGUsbixhKTptKGUsJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJytuKydcIicpfUEoZSwhMCwtMSksMD09PWUubGluZUluZGVudCYmNDU9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJjQ1PT09ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkmJjQ1PT09ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMik/KGUucG9zaXRpb24rPTMsQShlLCEwLC0xKSk6dSYmaChlLFwiZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZFwiKSxNKGUsZS5saW5lSW5kZW50LTEsRywhMSwhMCksQShlLCEwLC0xKSxlLmNoZWNrTGluZUJyZWFrcyYmUS50ZXN0KGUuaW5wdXQuc2xpY2UoYyxlLnBvc2l0aW9uKSkmJm0oZSxcIm5vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudFwiKSxlLmRvY3VtZW50cy5wdXNoKGUucmVzdWx0KSxlLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/NDY9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJihlLnBvc2l0aW9uKz0zLEEoZSwhMCwtMSkpOmUucG9zaXRpb248ZS5sZW5ndGgtMSYmaChlLFwiZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWRcIil9ZnVuY3Rpb24gTChlLHQpe2U9U3RyaW5nKGUpLHQ9dHx8e30sMCE9PWUubGVuZ3RoJiYoMTAhPT1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSkmJjEzIT09ZS5jaGFyQ29kZUF0KGUubGVuZ3RoLTEpJiYoZSs9XCJcXG5cIiksNjUyNzk9PT1lLmNoYXJDb2RlQXQoMCkmJihlPWUuc2xpY2UoMSkpKTt2YXIgbj1uZXcgZihlLHQpO2ZvcihuLmlucHV0Kz1cIlxcMFwiOzMyPT09bi5pbnB1dC5jaGFyQ29kZUF0KG4ucG9zaXRpb24pOyluLmxpbmVJbmRlbnQrPTEsbi5wb3NpdGlvbis9MTtmb3IoO24ucG9zaXRpb248bi5sZW5ndGgtMTspVChuKTtyZXR1cm4gbi5kb2N1bWVudHN9ZnVuY3Rpb24gRChlLHQsbil7dmFyIGkscixvPUwoZSxuKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBvO2ZvcihpPTAscj1vLmxlbmd0aDtpPHI7aSs9MSl0KG9baV0pfWZ1bmN0aW9uIFUoZSx0KXt2YXIgbj1MKGUsdCk7aWYoMCE9PW4ubGVuZ3RoKXtpZigxPT09bi5sZW5ndGgpcmV0dXJuIG5bMF07dGhyb3cgbmV3IFkoXCJleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZVwiKX19Zm9yKHZhciBxPWUoXCIuL2NvbW1vblwiKSxZPWUoXCIuL2V4Y2VwdGlvblwiKSxSPWUoXCIuL21hcmtcIiksUD1lKFwiLi9zY2hlbWEvZGVmYXVsdF9zYWZlXCIpLFc9ZShcIi4vc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSxCPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksSz0xLCQ9MixIPTMsRz00LFY9MSxaPTIsej0zLEo9L1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vLFE9L1tcXHg4NVxcdTIwMjhcXHUyMDI5XS8sWD0vWyxcXFtcXF1cXHtcXH1dLyxlZT0vXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pLHRlPS9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2ksbmU9bmV3IEFycmF5KDI1NiksaWU9bmV3IEFycmF5KDI1NikscmU9MDtyZTwyNTY7cmUrKyluZVtyZV09bChyZSk/MTowLGllW3JlXT1sKHJlKTt2YXIgb2U9e1lBTUw6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpLHIsbztudWxsIT09ZS52ZXJzaW9uJiZoKGUsXCJkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmVcIiksMSE9PW4ubGVuZ3RoJiZoKGUsXCJZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIpLG51bGw9PT0oaT0vXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKG5bMF0pKSYmaChlLFwiaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmVcIikscj1wYXJzZUludChpWzFdLDEwKSxvPXBhcnNlSW50KGlbMl0sMTApLDEhPT1yJiZoKGUsXCJ1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudFwiKSxlLnZlcnNpb249blswXSxlLmNoZWNrTGluZUJyZWFrcz1vPDIsMSE9PW8mJjIhPT1vJiZtKGUsXCJ1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50XCIpfSxUQUc6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpLHI7MiE9PW4ubGVuZ3RoJiZoKGUsXCJUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzXCIpLGk9blswXSxyPW5bMV0sZWUudGVzdChpKXx8aChlLFwiaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmVcIiksQi5jYWxsKGUudGFnTWFwLGkpJiZoKGUsJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJytpKydcIiB0YWcgaGFuZGxlJyksdGUudGVzdChyKXx8aChlLFwiaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlXCIpLGUudGFnTWFwW2ldPXJ9fTt0LmV4cG9ydHMubG9hZEFsbD1ELHQuZXhwb3J0cy5sb2FkPVUsdC5leHBvcnRzLnNhZmVMb2FkQWxsPWZ1bmN0aW9uKGUsdCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBEKGUscS5leHRlbmQoe3NjaGVtYTpQfSxuKSk7RChlLHQscS5leHRlbmQoe3NjaGVtYTpQfSxuKSl9LHQuZXhwb3J0cy5zYWZlTG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBVKGUscS5leHRlbmQoe3NjaGVtYTpQfSx0KSl9fSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL21hcmtcIjo2LFwiLi9zY2hlbWEvZGVmYXVsdF9mdWxsXCI6OSxcIi4vc2NoZW1hL2RlZmF1bHRfc2FmZVwiOjEwfV0sNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0LG4saSxyKXt0aGlzLm5hbWU9ZSx0aGlzLmJ1ZmZlcj10LHRoaXMucG9zaXRpb249bix0aGlzLmxpbmU9aSx0aGlzLmNvbHVtbj1yfXZhciByPWUoXCIuL2NvbW1vblwiKTtpLnByb3RvdHlwZS5nZXRTbmlwcGV0PWZ1bmN0aW9uKGUsdCl7dmFyIG4saSxvLGEscztpZighdGhpcy5idWZmZXIpcmV0dXJuIG51bGw7Zm9yKGU9ZXx8NCx0PXR8fDc1LG49XCJcIixpPXRoaXMucG9zaXRpb247aT4wJiYtMT09PVwiXFwwXFxyXFxuwoVcXHUyMDI4XFx1MjAyOVwiLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGktMSkpOylpZihpLT0xLHRoaXMucG9zaXRpb24taT50LzItMSl7bj1cIiAuLi4gXCIsaSs9NTticmVha31mb3Iobz1cIlwiLGE9dGhpcy5wb3NpdGlvbjthPHRoaXMuYnVmZmVyLmxlbmd0aCYmLTE9PT1cIlxcMFxcclxcbsKFXFx1MjAyOFxcdTIwMjlcIi5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChhKSk7KWlmKChhKz0xKS10aGlzLnBvc2l0aW9uPnQvMi0xKXtvPVwiIC4uLiBcIixhLT01O2JyZWFrfXJldHVybiBzPXRoaXMuYnVmZmVyLnNsaWNlKGksYSksci5yZXBlYXQoXCIgXCIsZSkrbitzK28rXCJcXG5cIityLnJlcGVhdChcIiBcIixlK3RoaXMucG9zaXRpb24taStuLmxlbmd0aCkrXCJeXCJ9LGkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0LG49XCJcIjtyZXR1cm4gdGhpcy5uYW1lJiYobis9J2luIFwiJyt0aGlzLm5hbWUrJ1wiICcpLG4rPVwiYXQgbGluZSBcIisodGhpcy5saW5lKzEpK1wiLCBjb2x1bW4gXCIrKHRoaXMuY29sdW1uKzEpLGV8fCh0PXRoaXMuZ2V0U25pcHBldCgpKSYmKG4rPVwiOlxcblwiK3QpLG59LHQuZXhwb3J0cz1pfSx7XCIuL2NvbW1vblwiOjJ9XSw3OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQsbil7dmFyIHI9W107cmV0dXJuIGUuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe249aShlLHQsbil9KSxlW3RdLmZvckVhY2goZnVuY3Rpb24oZSl7bi5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7dC50YWc9PT1lLnRhZyYmdC5raW5kPT09ZS5raW5kJiZyLnB1c2gobil9KSxuLnB1c2goZSl9KSxuLmZpbHRlcihmdW5jdGlvbihlLHQpe3JldHVybi0xPT09ci5pbmRleE9mKHQpfSl9ZnVuY3Rpb24gcigpe3ZhciBlLHQsbj17c2NhbGFyOnt9LHNlcXVlbmNlOnt9LG1hcHBpbmc6e30sZmFsbGJhY2s6e319O2ZvcihlPTAsdD1hcmd1bWVudHMubGVuZ3RoO2U8dDtlKz0xKWFyZ3VtZW50c1tlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe25bZS5raW5kXVtlLnRhZ109bi5mYWxsYmFja1tlLnRhZ109ZX0pO3JldHVybiBufWZ1bmN0aW9uIG8oZSl7dGhpcy5pbmNsdWRlPWUuaW5jbHVkZXx8W10sdGhpcy5pbXBsaWNpdD1lLmltcGxpY2l0fHxbXSx0aGlzLmV4cGxpY2l0PWUuZXhwbGljaXR8fFtdLHRoaXMuaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbihlKXtpZihlLmxvYWRLaW5kJiZcInNjYWxhclwiIT09ZS5sb2FkS2luZCl0aHJvdyBuZXcgcyhcIlRoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKX0pLHRoaXMuY29tcGlsZWRJbXBsaWNpdD1pKHRoaXMsXCJpbXBsaWNpdFwiLFtdKSx0aGlzLmNvbXBpbGVkRXhwbGljaXQ9aSh0aGlzLFwiZXhwbGljaXRcIixbXSksdGhpcy5jb21waWxlZFR5cGVNYXA9cih0aGlzLmNvbXBpbGVkSW1wbGljaXQsdGhpcy5jb21waWxlZEV4cGxpY2l0KX12YXIgYT1lKFwiLi9jb21tb25cIikscz1lKFwiLi9leGNlcHRpb25cIiksYz1lKFwiLi90eXBlXCIpO28uREVGQVVMVD1udWxsLG8uY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGUsdDtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAxOmU9by5ERUZBVUxULHQ9YXJndW1lbnRzWzBdO2JyZWFrO2Nhc2UgMjplPWFyZ3VtZW50c1swXSx0PWFyZ3VtZW50c1sxXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvblwiKX1pZihlPWEudG9BcnJheShlKSx0PWEudG9BcnJheSh0KSwhZS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIG99KSl0aHJvdyBuZXcgcyhcIlNwZWNpZmllZCBsaXN0IG9mIHN1cGVyIHNjaGVtYXMgKG9yIGEgc2luZ2xlIFNjaGVtYSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVNjaGVtYSBvYmplY3QuXCIpO2lmKCF0LmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgY30pKXRocm93IG5ldyBzKFwiU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LlwiKTtyZXR1cm4gbmV3IG8oe2luY2x1ZGU6ZSxleHBsaWNpdDp0fSl9LHQuZXhwb3J0cz1vfSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL3R5cGVcIjoxM31dLDg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vc2NoZW1hXCIpO3QuZXhwb3J0cz1uZXcgaSh7aW5jbHVkZTpbZShcIi4vanNvblwiKV19KX0se1wiLi4vc2NoZW1hXCI6NyxcIi4vanNvblwiOjEyfV0sOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPWkuREVGQVVMVD1uZXcgaSh7aW5jbHVkZTpbZShcIi4vZGVmYXVsdF9zYWZlXCIpXSxleHBsaWNpdDpbZShcIi4uL3R5cGUvanMvdW5kZWZpbmVkXCIpLGUoXCIuLi90eXBlL2pzL3JlZ2V4cFwiKSxlKFwiLi4vdHlwZS9qcy9mdW5jdGlvblwiKV19KX0se1wiLi4vc2NoZW1hXCI6NyxcIi4uL3R5cGUvanMvZnVuY3Rpb25cIjoxOCxcIi4uL3R5cGUvanMvcmVnZXhwXCI6MTksXCIuLi90eXBlL2pzL3VuZGVmaW5lZFwiOjIwLFwiLi9kZWZhdWx0X3NhZmVcIjoxMH1dLDEwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3NjaGVtYVwiKTt0LmV4cG9ydHM9bmV3IGkoe2luY2x1ZGU6W2UoXCIuL2NvcmVcIildLGltcGxpY2l0OltlKFwiLi4vdHlwZS90aW1lc3RhbXBcIiksZShcIi4uL3R5cGUvbWVyZ2VcIildLGV4cGxpY2l0OltlKFwiLi4vdHlwZS9iaW5hcnlcIiksZShcIi4uL3R5cGUvb21hcFwiKSxlKFwiLi4vdHlwZS9wYWlyc1wiKSxlKFwiLi4vdHlwZS9zZXRcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL2JpbmFyeVwiOjE0LFwiLi4vdHlwZS9tZXJnZVwiOjIyLFwiLi4vdHlwZS9vbWFwXCI6MjQsXCIuLi90eXBlL3BhaXJzXCI6MjUsXCIuLi90eXBlL3NldFwiOjI3LFwiLi4vdHlwZS90aW1lc3RhbXBcIjoyOSxcIi4vY29yZVwiOjh9XSwxMTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPW5ldyBpKHtleHBsaWNpdDpbZShcIi4uL3R5cGUvc3RyXCIpLGUoXCIuLi90eXBlL3NlcVwiKSxlKFwiLi4vdHlwZS9tYXBcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL21hcFwiOjIxLFwiLi4vdHlwZS9zZXFcIjoyNixcIi4uL3R5cGUvc3RyXCI6Mjh9XSwxMjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPW5ldyBpKHtpbmNsdWRlOltlKFwiLi9mYWlsc2FmZVwiKV0saW1wbGljaXQ6W2UoXCIuLi90eXBlL251bGxcIiksZShcIi4uL3R5cGUvYm9vbFwiKSxlKFwiLi4vdHlwZS9pbnRcIiksZShcIi4uL3R5cGUvZmxvYXRcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL2Jvb2xcIjoxNSxcIi4uL3R5cGUvZmxvYXRcIjoxNixcIi4uL3R5cGUvaW50XCI6MTcsXCIuLi90eXBlL251bGxcIjoyMyxcIi4vZmFpbHNhZmVcIjoxMX1dLDEzOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXt2YXIgdD17fTtyZXR1cm4gbnVsbCE9PWUmJk9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24obil7ZVtuXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbU3RyaW5nKGUpXT1ufSl9KSx0fXZhciByPWUoXCIuL2V4Y2VwdGlvblwiKSxvPVtcImtpbmRcIixcInJlc29sdmVcIixcImNvbnN0cnVjdFwiLFwiaW5zdGFuY2VPZlwiLFwicHJlZGljYXRlXCIsXCJyZXByZXNlbnRcIixcImRlZmF1bHRTdHlsZVwiLFwic3R5bGVBbGlhc2VzXCJdLGE9W1wic2NhbGFyXCIsXCJzZXF1ZW5jZVwiLFwibWFwcGluZ1wiXTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZih0PXR8fHt9LE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24odCl7aWYoLTE9PT1vLmluZGV4T2YodCkpdGhyb3cgbmV3IHIoJ1Vua25vd24gb3B0aW9uIFwiJyt0KydcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicrZSsnXCIgWUFNTCB0eXBlLicpfSksdGhpcy50YWc9ZSx0aGlzLmtpbmQ9dC5raW5kfHxudWxsLHRoaXMucmVzb2x2ZT10LnJlc29sdmV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LHRoaXMuY29uc3RydWN0PXQuY29uc3RydWN0fHxmdW5jdGlvbihlKXtyZXR1cm4gZX0sdGhpcy5pbnN0YW5jZU9mPXQuaW5zdGFuY2VPZnx8bnVsbCx0aGlzLnByZWRpY2F0ZT10LnByZWRpY2F0ZXx8bnVsbCx0aGlzLnJlcHJlc2VudD10LnJlcHJlc2VudHx8bnVsbCx0aGlzLmRlZmF1bHRTdHlsZT10LmRlZmF1bHRTdHlsZXx8bnVsbCx0aGlzLnN0eWxlQWxpYXNlcz1pKHQuc3R5bGVBbGlhc2VzfHxudWxsKSwtMT09PWEuaW5kZXhPZih0aGlzLmtpbmQpKXRocm93IG5ldyByKCdVbmtub3duIGtpbmQgXCInK3RoaXMua2luZCsnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicrZSsnXCIgWUFNTCB0eXBlLicpfX0se1wiLi9leGNlcHRpb25cIjo0fV0sMTQ6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaTt0cnl7aT1lKFwiYnVmZmVyXCIpLkJ1ZmZlcn1jYXRjaChlKXt9dmFyIHI9ZShcIi4uL3R5cGVcIiksbz1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyXCI7dC5leHBvcnRzPW5ldyByKFwidGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5XCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiExO3ZhciB0LG4saT0wLHI9ZS5sZW5ndGgsYT1vO2ZvcihuPTA7bjxyO24rKylpZighKCh0PWEuaW5kZXhPZihlLmNoYXJBdChuKSkpPjY0KSl7aWYodDwwKXJldHVybiExO2krPTZ9cmV0dXJuIGklOD09MH0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lLnJlcGxhY2UoL1tcXHJcXG49XS9nLFwiXCIpLGE9ci5sZW5ndGgscz1vLGM9MCx1PVtdO2Zvcih0PTA7dDxhO3QrKyl0JTQ9PTAmJnQmJih1LnB1c2goYz4+MTYmMjU1KSx1LnB1c2goYz4+OCYyNTUpLHUucHVzaCgyNTUmYykpLGM9Yzw8NnxzLmluZGV4T2Yoci5jaGFyQXQodCkpO3JldHVybiAwPT0obj1hJTQqNik/KHUucHVzaChjPj4xNiYyNTUpLHUucHVzaChjPj44JjI1NSksdS5wdXNoKDI1NSZjKSk6MTg9PT1uPyh1LnB1c2goYz4+MTAmMjU1KSx1LnB1c2goYz4+MiYyNTUpKToxMj09PW4mJnUucHVzaChjPj40JjI1NSksaT9pLmZyb20/aS5mcm9tKHUpOm5ldyBpKHUpOnV9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm4gaSYmaS5pc0J1ZmZlcihlKX0scmVwcmVzZW50OmZ1bmN0aW9uKGUpe3ZhciB0LG4saT1cIlwiLHI9MCxhPWUubGVuZ3RoLHM9bztmb3IodD0wO3Q8YTt0KyspdCUzPT0wJiZ0JiYoaSs9c1tyPj4xOCY2M10saSs9c1tyPj4xMiY2M10saSs9c1tyPj42JjYzXSxpKz1zWzYzJnJdKSxyPShyPDw4KStlW3RdO3JldHVybiAwPT0obj1hJTMpPyhpKz1zW3I+PjE4JjYzXSxpKz1zW3I+PjEyJjYzXSxpKz1zW3I+PjYmNjNdLGkrPXNbNjMmcl0pOjI9PT1uPyhpKz1zW3I+PjEwJjYzXSxpKz1zW3I+PjQmNjNdLGkrPXNbcjw8MiY2M10saSs9c1s2NF0pOjE9PT1uJiYoaSs9c1tyPj4yJjYzXSxpKz1zW3I8PDQmNjNdLGkrPXNbNjRdLGkrPXNbNjRdKSxpfX0pfSx7XCIuLi90eXBlXCI6MTN9XSwxNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOmJvb2xcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITE7dmFyIHQ9ZS5sZW5ndGg7cmV0dXJuIDQ9PT10JiYoXCJ0cnVlXCI9PT1lfHxcIlRydWVcIj09PWV8fFwiVFJVRVwiPT09ZSl8fDU9PT10JiYoXCJmYWxzZVwiPT09ZXx8XCJGYWxzZVwiPT09ZXx8XCJGQUxTRVwiPT09ZSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm5cInRydWVcIj09PWV8fFwiVHJ1ZVwiPT09ZXx8XCJUUlVFXCI9PT1lfSxwcmVkaWNhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEJvb2xlYW5dXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDp7bG93ZXJjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1widHJ1ZVwiOlwiZmFsc2VcIn0sdXBwZXJjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1wiVFJVRVwiOlwiRkFMU0VcIn0sY2FtZWxjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1wiVHJ1ZVwiOlwiRmFsc2VcIn19LGRlZmF1bHRTdHlsZTpcImxvd2VyY2FzZVwifSl9LHtcIi4uL3R5cGVcIjoxM31dLDE2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL2NvbW1vblwiKSxyPWUoXCIuLi90eXBlXCIpLG89bmV3IFJlZ0V4cChcIl4oPzpbLStdPyg/OjB8WzEtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT98XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT98Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKnxbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpfFxcXFwuKD86bmFufE5hTnxOQU4pKSRcIiksYT0vXlstK10/WzAtOV0rZS87dC5leHBvcnRzPW5ldyByKFwidGFnOnlhbWwub3JnLDIwMDI6ZmxvYXRcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1lJiYhKCFvLnRlc3QoZSl8fFwiX1wiPT09ZVtlLmxlbmd0aC0xXSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdCxuLGkscjtyZXR1cm4gdD1lLnJlcGxhY2UoL18vZyxcIlwiKS50b0xvd2VyQ2FzZSgpLG49XCItXCI9PT10WzBdPy0xOjEscj1bXSxcIistXCIuaW5kZXhPZih0WzBdKT49MCYmKHQ9dC5zbGljZSgxKSksXCIuaW5mXCI9PT10PzE9PT1uP051bWJlci5QT1NJVElWRV9JTkZJTklUWTpOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6XCIubmFuXCI9PT10P05hTjp0LmluZGV4T2YoXCI6XCIpPj0wPyh0LnNwbGl0KFwiOlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IudW5zaGlmdChwYXJzZUZsb2F0KGUsMTApKX0pLHQ9MCxpPTEsci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QrPWUqaSxpKj02MH0pLG4qdCk6bipwYXJzZUZsb2F0KHQsMTApfSxwcmVkaWNhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IE51bWJlcl1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSYmKGUlMSE9MHx8aS5pc05lZ2F0aXZlWmVybyhlKSl9LHJlcHJlc2VudDpmdW5jdGlvbihlLHQpe3ZhciBuO2lmKGlzTmFOKGUpKXN3aXRjaCh0KXtjYXNlXCJsb3dlcmNhc2VcIjpyZXR1cm5cIi5uYW5cIjtjYXNlXCJ1cHBlcmNhc2VcIjpyZXR1cm5cIi5OQU5cIjtjYXNlXCJjYW1lbGNhc2VcIjpyZXR1cm5cIi5OYU5cIn1lbHNlIGlmKE51bWJlci5QT1NJVElWRV9JTkZJTklUWT09PWUpc3dpdGNoKHQpe2Nhc2VcImxvd2VyY2FzZVwiOnJldHVyblwiLmluZlwiO2Nhc2VcInVwcGVyY2FzZVwiOnJldHVyblwiLklORlwiO2Nhc2VcImNhbWVsY2FzZVwiOnJldHVyblwiLkluZlwifWVsc2UgaWYoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPT09ZSlzd2l0Y2godCl7Y2FzZVwibG93ZXJjYXNlXCI6cmV0dXJuXCItLmluZlwiO2Nhc2VcInVwcGVyY2FzZVwiOnJldHVyblwiLS5JTkZcIjtjYXNlXCJjYW1lbGNhc2VcIjpyZXR1cm5cIi0uSW5mXCJ9ZWxzZSBpZihpLmlzTmVnYXRpdmVaZXJvKGUpKXJldHVyblwiLTAuMFwiO3JldHVybiBuPWUudG9TdHJpbmcoMTApLGEudGVzdChuKT9uLnJlcGxhY2UoXCJlXCIsXCIuZVwiKTpufSxkZWZhdWx0U3R5bGU6XCJsb3dlcmNhc2VcIn0pfSx7XCIuLi9jb21tb25cIjoyLFwiLi4vdHlwZVwiOjEzfV0sMTc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiA0ODw9ZSYmZTw9NTd8fDY1PD1lJiZlPD03MHx8OTc8PWUmJmU8PTEwMn1mdW5jdGlvbiByKGUpe3JldHVybiA0ODw9ZSYmZTw9NTV9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gNDg8PWUmJmU8PTU3fXZhciBhPWUoXCIuLi9jb21tb25cIikscz1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IHMoXCJ0YWc6eWFtbC5vcmcsMjAwMjppbnRcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITE7dmFyIHQsbj1lLmxlbmd0aCxhPTAscz0hMTtpZighbilyZXR1cm4hMTtpZihcIi1cIiE9PSh0PWVbYV0pJiZcIitcIiE9PXR8fCh0PWVbKythXSksXCIwXCI9PT10KXtpZihhKzE9PT1uKXJldHVybiEwO2lmKFwiYlwiPT09KHQ9ZVsrK2FdKSl7Zm9yKGErKzthPG47YSsrKWlmKFwiX1wiIT09KHQ9ZVthXSkpe2lmKFwiMFwiIT09dCYmXCIxXCIhPT10KXJldHVybiExO3M9ITB9cmV0dXJuIHMmJlwiX1wiIT09dH1pZihcInhcIj09PXQpe2ZvcihhKys7YTxuO2ErKylpZihcIl9cIiE9PSh0PWVbYV0pKXtpZighaShlLmNoYXJDb2RlQXQoYSkpKXJldHVybiExO3M9ITB9cmV0dXJuIHMmJlwiX1wiIT09dH1mb3IoO2E8bjthKyspaWYoXCJfXCIhPT0odD1lW2FdKSl7aWYoIXIoZS5jaGFyQ29kZUF0KGEpKSlyZXR1cm4hMTtzPSEwfXJldHVybiBzJiZcIl9cIiE9PXR9aWYoXCJfXCI9PT10KXJldHVybiExO2Zvcig7YTxuO2ErKylpZihcIl9cIiE9PSh0PWVbYV0pKXtpZihcIjpcIj09PXQpYnJlYWs7aWYoIW8oZS5jaGFyQ29kZUF0KGEpKSlyZXR1cm4hMTtzPSEwfXJldHVybiEoIXN8fFwiX1wiPT09dCkmJihcIjpcIiE9PXR8fC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChlLnNsaWNlKGEpKSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdCxuLGk9ZSxyPTEsbz1bXTtyZXR1cm4tMSE9PWkuaW5kZXhPZihcIl9cIikmJihpPWkucmVwbGFjZSgvXy9nLFwiXCIpKSxcIi1cIiE9PSh0PWlbMF0pJiZcIitcIiE9PXR8fChcIi1cIj09PXQmJihyPS0xKSx0PShpPWkuc2xpY2UoMSkpWzBdKSxcIjBcIj09PWk/MDpcIjBcIj09PXQ/XCJiXCI9PT1pWzFdP3IqcGFyc2VJbnQoaS5zbGljZSgyKSwyKTpcInhcIj09PWlbMV0/cipwYXJzZUludChpLDE2KTpyKnBhcnNlSW50KGksOCk6LTEhPT1pLmluZGV4T2YoXCI6XCIpPyhpLnNwbGl0KFwiOlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe28udW5zaGlmdChwYXJzZUludChlLDEwKSl9KSxpPTAsbj0xLG8uZm9yRWFjaChmdW5jdGlvbihlKXtpKz1lKm4sbio9NjB9KSxyKmkpOnIqcGFyc2VJbnQoaSwxMCl9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgTnVtYmVyXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpJiZlJTE9PTAmJiFhLmlzTmVnYXRpdmVaZXJvKGUpfSxyZXByZXNlbnQ6e2JpbmFyeTpmdW5jdGlvbihlKXtyZXR1cm5cIjBiXCIrZS50b1N0cmluZygyKX0sb2N0YWw6ZnVuY3Rpb24oZSl7cmV0dXJuXCIwXCIrZS50b1N0cmluZyg4KX0sZGVjaW1hbDpmdW5jdGlvbihlKXtyZXR1cm4gZS50b1N0cmluZygxMCl9LGhleGFkZWNpbWFsOmZ1bmN0aW9uKGUpe3JldHVyblwiMHhcIitlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfX0sZGVmYXVsdFN0eWxlOlwiZGVjaW1hbFwiLHN0eWxlQWxpYXNlczp7YmluYXJ5OlsyLFwiYmluXCJdLG9jdGFsOls4LFwib2N0XCJdLGRlY2ltYWw6WzEwLFwiZGVjXCJdLGhleGFkZWNpbWFsOlsxNixcImhleFwiXX19KX0se1wiLi4vY29tbW9uXCI6MixcIi4uL3R5cGVcIjoxM31dLDE4OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk7dHJ5e2k9ZShcImVzcHJpbWFcIil9Y2F0Y2goZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKGk9d2luZG93LmVzcHJpbWEpfXZhciByPWUoXCIuLi8uLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgcihcInRhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiExO3RyeXt2YXIgdD1cIihcIitlK1wiKVwiLG49aS5wYXJzZSh0LHtyYW5nZTohMH0pO3JldHVyblwiUHJvZ3JhbVwiPT09bi50eXBlJiYxPT09bi5ib2R5Lmxlbmd0aCYmXCJFeHByZXNzaW9uU3RhdGVtZW50XCI9PT1uLmJvZHlbMF0udHlwZSYmXCJGdW5jdGlvbkV4cHJlc3Npb25cIj09PW4uYm9keVswXS5leHByZXNzaW9uLnR5cGV9Y2F0Y2goZSl7cmV0dXJuITF9fSxjb25zdHJ1Y3Q6ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIihcIitlK1wiKVwiLHI9aS5wYXJzZShuLHtyYW5nZTohMH0pLG89W107aWYoXCJQcm9ncmFtXCIhPT1yLnR5cGV8fDEhPT1yLmJvZHkubGVuZ3RofHxcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiE9PXIuYm9keVswXS50eXBlfHxcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIT09ci5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvblwiKTtyZXR1cm4gci5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24oZSl7by5wdXNoKGUubmFtZSl9KSx0PXIuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2UsbmV3IEZ1bmN0aW9uKG8sbi5zbGljZSh0WzBdKzEsdFsxXS0xKSl9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgRnVuY3Rpb25dXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDpmdW5jdGlvbihlKXtyZXR1cm4gZS50b1N0cmluZygpfX0pfSx7XCIuLi8uLi90eXBlXCI6MTN9XSwxOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi8uLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cFwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm4hMTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuITE7dmFyIHQ9ZSxuPS9cXC8oW2dpbV0qKSQvLmV4ZWMoZSksaT1cIlwiO2lmKFwiL1wiPT09dFswXSl7aWYobiYmKGk9blsxXSksaS5sZW5ndGg+MylyZXR1cm4hMTtpZihcIi9cIiE9PXRbdC5sZW5ndGgtaS5sZW5ndGgtMV0pcmV0dXJuITF9cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdD1lLG49L1xcLyhbZ2ltXSopJC8uZXhlYyhlKSxpPVwiXCI7cmV0dXJuXCIvXCI9PT10WzBdJiYobiYmKGk9blsxXSksdD10LnNsaWNlKDEsdC5sZW5ndGgtaS5sZW5ndGgtMSkpLG5ldyBSZWdFeHAodCxpKX0scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBSZWdFeHBdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDpmdW5jdGlvbihlKXt2YXIgdD1cIi9cIitlLnNvdXJjZStcIi9cIjtyZXR1cm4gZS5nbG9iYWwmJih0Kz1cImdcIiksZS5tdWx0aWxpbmUmJih0Kz1cIm1cIiksZS5pZ25vcmVDYXNlJiYodCs9XCJpXCIpLHR9fSl9LHtcIi4uLy4uL3R5cGVcIjoxM31dLDIwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uLy4uL3R5cGVcIik7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6anMvdW5kZWZpbmVkXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbigpe30scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lfSxyZXByZXNlbnQ6ZnVuY3Rpb24oKXtyZXR1cm5cIlwifX0pfSx7XCIuLi8uLi90eXBlXCI6MTN9XSwyMTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOm1hcFwiLHtraW5kOlwibWFwcGluZ1wiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTp7fX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjptZXJnZVwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtyZXR1cm5cIjw8XCI9PT1lfHxudWxsPT09ZX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpudWxsXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiEwO3ZhciB0PWUubGVuZ3RoO3JldHVybiAxPT09dCYmXCJ+XCI9PT1lfHw0PT09dCYmKFwibnVsbFwiPT09ZXx8XCJOdWxsXCI9PT1lfHxcIk5VTExcIj09PWUpfSxjb25zdHJ1Y3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT09ZX0scmVwcmVzZW50OntjYW5vbmljYWw6ZnVuY3Rpb24oKXtyZXR1cm5cIn5cIn0sbG93ZXJjYXNlOmZ1bmN0aW9uKCl7cmV0dXJuXCJudWxsXCJ9LHVwcGVyY2FzZTpmdW5jdGlvbigpe3JldHVyblwiTlVMTFwifSxjYW1lbGNhc2U6ZnVuY3Rpb24oKXtyZXR1cm5cIk51bGxcIn19LGRlZmF1bHRTdHlsZTpcImxvd2VyY2FzZVwifSl9LHtcIi4uL3R5cGVcIjoxM31dLDI0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3R5cGVcIikscj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpvbWFwXCIse2tpbmQ6XCJzZXF1ZW5jZVwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITA7dmFyIHQsbixpLGEscyxjPVtdLHU9ZTtmb3IodD0wLG49dS5sZW5ndGg7dDxuO3QrPTEpe2lmKGk9dVt0XSxzPSExLFwiW29iamVjdCBPYmplY3RdXCIhPT1vLmNhbGwoaSkpcmV0dXJuITE7Zm9yKGEgaW4gaSlpZihyLmNhbGwoaSxhKSl7aWYocylyZXR1cm4hMTtzPSEwfWlmKCFzKXJldHVybiExO2lmKC0xIT09Yy5pbmRleE9mKGEpKXJldHVybiExO2MucHVzaChhKX1yZXR1cm4hMH0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09ZT9lOltdfX0pfSx7XCIuLi90eXBlXCI6MTN9XSwyNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpLHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpwYWlyc1wiLHtraW5kOlwic2VxdWVuY2VcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiEwO3ZhciB0LG4saSxvLGEscz1lO2ZvcihhPW5ldyBBcnJheShzLmxlbmd0aCksdD0wLG49cy5sZW5ndGg7dDxuO3QrPTEpe2lmKGk9c1t0XSxcIltvYmplY3QgT2JqZWN0XVwiIT09ci5jYWxsKGkpKXJldHVybiExO2lmKDEhPT0obz1PYmplY3Qua2V5cyhpKSkubGVuZ3RoKXJldHVybiExO2FbdF09W29bMF0saVtvWzBdXV19cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm5bXTt2YXIgdCxuLGkscixvLGE9ZTtmb3Iobz1uZXcgQXJyYXkoYS5sZW5ndGgpLHQ9MCxuPWEubGVuZ3RoO3Q8bjt0Kz0xKWk9YVt0XSxyPU9iamVjdC5rZXlzKGkpLG9bdF09W3JbMF0saVtyWzBdXV07cmV0dXJuIG99fSl9LHtcIi4uL3R5cGVcIjoxM31dLDI2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3R5cGVcIik7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6c2VxXCIse2tpbmQ6XCJzZXF1ZW5jZVwiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTpbXX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKSxyPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6c2V0XCIse2tpbmQ6XCJtYXBwaW5nXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm4hMDt2YXIgdCxuPWU7Zm9yKHQgaW4gbilpZihyLmNhbGwobix0KSYmbnVsbCE9PW5bdF0pcmV0dXJuITE7cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTp7fX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpzdHJcIix7a2luZDpcInNjYWxhclwiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTpcIlwifX0pfSx7XCIuLi90eXBlXCI6MTN9XSwyOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpLHI9bmV3IFJlZ0V4cChcIl4oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldKS0oWzAtOV1bMC05XSkkXCIpLG89bmV3IFJlZ0V4cChcIl4oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldPyktKFswLTldWzAtOV0/KSg/OltUdF18WyBcXFxcdF0rKShbMC05XVswLTldPyk6KFswLTldWzAtOV0pOihbMC05XVswLTldKSg/OlxcXFwuKFswLTldKikpPyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPykoPzo6KFswLTldWzAtOV0pKT8pKT8kXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcFwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWUmJihudWxsIT09ci5leGVjKGUpfHxudWxsIT09by5leGVjKGUpKX0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3ZhciB0LG4saSxhLHMsYyx1LGwscD0wLGY9bnVsbDtpZihudWxsPT09KHQ9ci5leGVjKGUpKSYmKHQ9by5leGVjKGUpKSxudWxsPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJEYXRlIHJlc29sdmUgZXJyb3JcIik7aWYobj0rdFsxXSxpPSt0WzJdLTEsYT0rdFszXSwhdFs0XSlyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMobixpLGEpKTtpZihzPSt0WzRdLGM9K3RbNV0sdT0rdFs2XSx0WzddKXtmb3IocD10WzddLnNsaWNlKDAsMyk7cC5sZW5ndGg8MzspcCs9XCIwXCI7cD0rcH1yZXR1cm4gdFs5XSYmKGY9NmU0Kig2MCordFsxMF0rICsodFsxMV18fDApKSxcIi1cIj09PXRbOV0mJihmPS1mKSksbD1uZXcgRGF0ZShEYXRlLlVUQyhuLGksYSxzLGMsdSxwKSksZiYmbC5zZXRUaW1lKGwuZ2V0VGltZSgpLWYpLGx9LGluc3RhbmNlT2Y6RGF0ZSxyZXByZXNlbnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9JU09TdHJpbmcoKX19KX0se1wiLi4vdHlwZVwiOjEzfV0sXCIvXCI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi9saWIvanMteWFtbC5qc1wiKTt0LmV4cG9ydHM9aX0se1wiLi9saWIvanMteWFtbC5qc1wiOjF9XX0se30sW10pKFwiL1wiKX0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2Rpc3QvanMteWFtbC5taW4uanMiXSwic291cmNlUm9vdCI6IiJ9