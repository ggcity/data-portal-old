/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 90);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.throttle = throttle;
exports.wrapNum = wrapNum;
exports.falseFn = falseFn;
exports.formatNum = formatNum;
exports.trim = trim;
exports.splitWords = splitWords;
exports.setOptions = setOptions;
exports.getParamString = getParamString;
exports.template = template;
exports.indexOf = indexOf;
exports.requestAnimFrame = requestAnimFrame;
exports.cancelAnimFrame = cancelAnimFrame;
/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = exports.freeze = Object.freeze;
Object.freeze = function (obj) {
	return obj;
};

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = exports.create = Object.create || function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
}();

// @function bind(fn: Function, …): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = exports.lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || (exports.lastId = lastId += 1);
	return obj._leaflet_id;
	/* eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function later() {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function wrapperFn() {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;
		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
	    min = range[0],
	    d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() {
	return false;
}

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, digits === undefined ? 6 : digits);
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values — they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);
		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = exports.isArray = Array.isArray || function (obj) {
	return Object.prototype.toString.call(obj) === '[object Array]';
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) {
			return i;
		}
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = exports.emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
	    timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = exports.requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = exports.cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
	window.clearTimeout(id);
};

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.enableTextSelection = exports.disableTextSelection = exports.TRANSITION_END = exports.TRANSITION = exports.TRANSFORM = undefined;
exports.get = get;
exports.getStyle = getStyle;
exports.create = create;
exports.remove = remove;
exports.empty = empty;
exports.toFront = toFront;
exports.toBack = toBack;
exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.setClass = setClass;
exports.getClass = getClass;
exports.setOpacity = setOpacity;
exports.testProp = testProp;
exports.setTransform = setTransform;
exports.setPosition = setPosition;
exports.getPosition = getPosition;
exports.disableImageDrag = disableImageDrag;
exports.enableImageDrag = enableImageDrag;
exports.preventOutline = preventOutline;
exports.restoreOutline = restoreOutline;

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Point = __webpack_require__(3);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = exports.TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = exports.TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END = exports.TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';

// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || el.currentStyle && el.currentStyle[style];

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = Util.splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, Util.trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
	    filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) {
			return;
		}
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = value !== 100;
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new _Point.Point(0, 0);

	el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/* eslint-enable */

	if (Browser.any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new _Point.Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection = exports.disableTextSelection = undefined;
var enableTextSelection = exports.enableTextSelection = undefined;
var _userSelect;
if ('onselectstart' in document) {
	exports.disableTextSelection = disableTextSelection = function disableTextSelection() {
		DomEvent.on(window, 'selectstart', DomEvent.preventDefault);
	};
	exports.enableTextSelection = enableTextSelection = function enableTextSelection() {
		DomEvent.off(window, 'selectstart', DomEvent.preventDefault);
	};
} else {
	var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	exports.disableTextSelection = disableTextSelection = function disableTextSelection() {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	exports.enableTextSelection = enableTextSelection = function enableTextSelection() {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	DomEvent.on(window, 'dragstart', DomEvent.preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	DomEvent.off(window, 'dragstart', DomEvent.preventDefault);
}

var _outlineElement, _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) {
		return;
	}
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	DomEvent.on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) {
		return;
	}
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	DomEvent.off(window, 'keydown', restoreOutline);
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.JSCompiler_renameProperty = function (prop, obj) {
  return prop;
};

/** @namespace */
var Polymer = void 0;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.Point = Point;
exports.toPoint = toPoint;

var _Util = __webpack_require__(0);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 *
 * Note that `Point` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = round ? Math.round(x) : x;
	// @property y: Number; The `y` coordinate of the point
	this.y = round ? Math.round(y) : y;
}

var trunc = Math.trunc || function (v) {
	return v > 0 ? Math.floor(v) : Math.ceil(v);
};

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function clone() {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function add(point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function _add(point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function subtract(point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function _subtract(point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function divideBy(num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function _divideBy(num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function multiplyBy(num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function _multiplyBy(num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function scaleBy(point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function unscaleBy(point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function round() {
		return this.clone()._round();
	},

	_round: function _round() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function floor() {
		return this.clone()._floor();
	},

	_floor: function _floor() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function ceil() {
		return this.clone()._ceil();
	},

	_ceil: function _ceil() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method trunc(): Point
	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
	trunc: function trunc() {
		return this.clone()._trunc();
	},

	_trunc: function _trunc() {
		this.x = trunc(this.x);
		this.y = trunc(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function distanceTo(point) {
		point = toPoint(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function equals(point) {
		point = toPoint(point);

		return point.x === this.x && point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function contains(point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function toString() {
		return 'Point(' + (0, _Util.formatNum)(this.x) + ', ' + (0, _Util.formatNum)(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if ((0, _Util.isArray)(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vml = exports.svg = exports.canvas = exports.retina = exports.mobileGecko = exports.mobileOpera = exports.touch = exports.pointer = exports.msPointer = exports.mobileWebkit3d = exports.mobileWebkit = exports.mobile = exports.any3d = exports.gecko3d = exports.webkit3d = exports.ie3d = exports.win = exports.opera12 = exports.phantom = exports.safari = exports.gecko = exports.chrome = exports.opera = exports.androidStock = exports.android23 = exports.android = exports.webkit = exports.edge = exports.ielt9 = exports.ie = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _SVG = __webpack_require__(75);

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = exports.ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = exports.ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = exports.edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = exports.webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = exports.android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = exports.android23 = userAgentContains('android 2') || userAgentContains('android 3');

/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
var androidStock = exports.androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

// @property opera: Boolean; `true` for the Opera browser
var opera = exports.opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = exports.chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = exports.gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = exports.safari = !chrome && userAgentContains('safari');

var phantom = exports.phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = exports.opera12 = 'OTransition' in style;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = exports.win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = exports.ie3d = ie && 'transition' in style;

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = exports.webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = exports.gecko3d = 'MozPerspective' in style;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = exports.any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = exports.mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = exports.mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = exports.mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = exports.msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = exports.pointer = !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = exports.touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = exports.mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = exports.mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen.
var retina = exports.retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;

// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = exports.canvas = function () {
  return !!document.createElement('canvas').getContext;
}();

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = exports.svg = !!(document.createElementNS && (0, _SVG.svgCreate)('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = exports.vml = !svg && function () {
  try {
    var div = document.createElement('div');
    div.innerHTML = '<v:shape adj="1"/>';

    var shape = div.firstChild;
    shape.style.behavior = 'url(#default#VML)';

    return shape && _typeof(shape.adj) === 'object';
  } catch (e) {
    return false;
  }
}();

function userAgentContains(str) {
  return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Bounds = Bounds;
exports.toBounds = toBounds;

var _Point = __webpack_require__(3);

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 *
 * Note that `Bounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Bounds(a, b) {
	if (!a) {
		return;
	}

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function extend(point) {
		// (Point)
		point = (0, _Point.toPoint)(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function getCenter(round) {
		return new _Point.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function getBottomLeft() {
		return new _Point.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function getTopRight() {
		// -> Point
		return new _Point.Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function getTopLeft() {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function getBottomRight() {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function getSize() {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function contains(obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof _Point.Point) {
			obj = (0, _Point.toPoint)(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function intersects(bounds) {
		// (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = max2.x >= min.x && min2.x <= max.x,
		    yIntersects = max2.y >= min.y && min2.y <= max.y;

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function overlaps(bounds) {
		// (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = max2.x > min.x && min2.x < max.x,
		    yOverlaps = max2.y > min.y && min2.y < max.y;

		return xOverlaps && yOverlaps;
	},

	isValid: function isValid() {
		return !!(this.min && this.max);
	}
};

// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.removeListener = exports.addListener = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.on = on;
exports.off = off;
exports.stopPropagation = stopPropagation;
exports.disableScrollPropagation = disableScrollPropagation;
exports.disableClickPropagation = disableClickPropagation;
exports.preventDefault = preventDefault;
exports.stop = stop;
exports.getMousePosition = getMousePosition;
exports.getWheelDelta = getWheelDelta;
exports.fakeStop = fakeStop;
exports.skipped = skipped;
exports.isExternalTarget = isExternalTarget;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(76);

var _DomEvent2 = __webpack_require__(116);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = Util.splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function off(obj, types, fn, context) {

	if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = Util.splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) {
		return this;
	}

	var handler = function handler(e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (Browser.pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		(0, _DomEvent.addPointerListener)(obj, type, handler, id);
	} else if (Browser.touch && type === 'dblclick' && _DomEvent2.addDoubleTapListener && !(Browser.pointer && Browser.chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		(0, _DomEvent2.addDoubleTapListener)(obj, handler, id);
	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
		} else if (type === 'mouseenter' || type === 'mouseleave') {
			handler = function handler(e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);
		} else {
			if (type === 'click' && Browser.android) {
				handler = function handler(e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}
	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + Util.stamp(fn) + (context ? '_' + Util.stamp(context) : ''),
	    handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) {
		return this;
	}

	if (Browser.pointer && type.indexOf('touch') === 0) {
		(0, _DomEvent.removePointerListener)(obj, type, id);
	} else if (Browser.touch && type === 'dblclick' && _DomEvent2.removeDoubleTapListener && !(Browser.pointer && Browser.chrome)) {
		(0, _DomEvent2.removeDoubleTapListener)(obj, id);
	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
		} else {
			obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}
	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {
		// In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev: DOMEvent): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new _Point.Point(e.clientX, e.clientY);
	}

	var rect = container.getBoundingClientRect();

	var scaleX = rect.width / container.offsetWidth || 1;
	var scaleY = rect.height / container.offsetHeight || 1;
	return new _Point.Point(e.clientX / scaleX - rect.left - container.clientLeft, e.clientY / scaleY - rect.top - container.clientTop);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor = Browser.win && Browser.chrome ? 2 * window.devicePixelRatio : Browser.gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return Browser.edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
	e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
	e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
	e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
	e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
	e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
	e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
	e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
	0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) {
		return true;
	}

	try {
		while (related && related !== el) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return related !== el;
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,
	    elapsed = lastClick && timeStamp - lastClick;

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}

// @function addListener(…): this
// Alias to [`L.DomEvent.on`](#domevent-on)
exports.addListener = on;

// @function removeListener(…): this
// Alias to [`L.DomEvent.off`](#domevent-off)

exports.removeListener = off;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Base = undefined;

var _legacyElementMixin = __webpack_require__(60);

__webpack_require__(28);

__webpack_require__(100);

__webpack_require__(101);

__webpack_require__(44);

__webpack_require__(102);

__webpack_require__(103);

__webpack_require__(104);

__webpack_require__(106);

var Base = exports.Base = (0, _legacyElementMixin.LegacyElementMixin)(HTMLElement).prototype;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Map = undefined;
exports.createMap = createMap;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Events = __webpack_require__(19);

var _CRS = __webpack_require__(73);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(5);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _PosAnimation = __webpack_require__(77);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = exports.Map = _Events.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: _CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,

		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function initialize(id, options) {
		// (HTMLElement or String, Object)
		options = Util.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = Util.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView((0, _LatLng.toLatLng)(options.center), options.zoom, { reset: true });
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = DomUtil.TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			DomEvent.on(this._proxy, DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},

	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function setView(center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter((0, _LatLng.toLatLng)(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = Util.extend({ animate: options.animate }, options.zoom);
				options.pan = Util.extend({ animate: options.animate, duration: options.duration }, options.pan);
			}

			// try animating pan or zoom
			var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function setZoom(zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, { zoom: options });
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function zoomIn(delta, options) {
		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function zoomOut(delta, options) {
		delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function setZoomAround(latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof _Point.Point ? latlng : this.latLngToContainerPoint(latlng),
		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, { zoom: options });
	},

	_getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : (0, _LatLngBounds.toLatLngBounds)(bounds);

		var paddingTL = (0, _Point.toPoint)(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = (0, _Point.toPoint)(options.paddingBottomRight || options.padding || [0, 0]),
		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function fitBounds(bounds, options) {

		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function fitWorld(options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function panTo(center, options) {
		// (LatLng)
		return this.setView(center, this._zoom, { pan: options });
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function panBy(offset, options) {
		offset = (0, _Point.toPoint)(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new _PosAnimation.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function flyTo(targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = (0, _LatLng.toLatLng)(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = to.distanceTo(from) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			// workaround for floating point precision bug when sq = 0, log = -Infinite,
			// thus triggering an infinite loop in flyTo
			var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) {
			return (Math.exp(n) - Math.exp(-n)) / 2;
		}
		function cosh(n) {
			return (Math.exp(n) + Math.exp(-n)) / 2;
		}
		function tanh(n) {
			return sinh(n) / cosh(n);
		}

		var r0 = r(0);

		function w(s) {
			return w0 * (cosh(r0) / cosh(r0 + rho * s));
		}
		function u(s) {
			return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
		}

		function easeOut(t) {
			return 1 - Math.pow(1 - t, 1.5);
		}

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = Util.requestAnimFrame(frame, this);

				this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), { flyTo: true });
			} else {
				this._move(targetCenter, targetZoom)._moveEnd(true);
			}
		}

		this._moveStart(true, options.noMoveStart);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function flyToBounds(bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function setMaxBounds(bounds) {
		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function setMinZoom(zoom) {
		var oldZoom = this.options.minZoom;
		this.options.minZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() < this.options.minZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function setMaxZoom(zoom) {
		var oldZoom = this.options.maxZoom;
		this.options.maxZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() > this.options.maxZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function panInsideBounds(bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, (0, _LatLngBounds.toLatLngBounds)(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function invalidateSize(options) {
		if (!this._loaded) {
			return this;
		}

		options = Util.extend({
			animate: false,
			pan: true
		}, options === true ? { animate: true } : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) {
			return this;
		}

		if (options.animate && options.pan) {
			this.panBy(offset);
		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(Util.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function stop() {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function locate(options) {

		options = this._locateOptions = Util.extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = Util.bind(this._handleGeolocationResponse, this),
		    onError = Util.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function stopLocate() {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function _handleGeolocationError(error) {
		var c = error.code,
		    message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function _handleGeolocationResponse(pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new _LatLng.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO Appropriate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function addHandler(name, HandlerClass) {
		if (!HandlerClass) {
			return this;
		}

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function remove() {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/* eslint-enable */
			this._containerId = undefined;
		}

		if (this._locationWatchId !== undefined) {
			this.stopLocate();
		}

		this._stop();

		DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			DomUtil.remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function createPane(name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function getCenter() {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function getZoom() {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function getBounds() {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new _LatLngBounds.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function getMinZoom() {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function getMaxZoom() {
		return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {
		// (LatLngBounds[, Boolean, Point]) -> Number
		bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);
		padding = (0, _Point.toPoint)(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = (0, _Bounds.toBounds)(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = Browser.any3d ? this.options.zoomSnap : 1,
		    scalex = size.x / boundsSize.x,
		    scaley = size.y / boundsSize.y,
		    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function getSize() {
		if (!this._size || this._sizeChanged) {
			this._size = new _Point.Point(this._container.clientWidth || 0, this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function getPixelBounds(center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new _Bounds.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function getPixelOrigin() {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function getPixelWorldBounds(zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function getPane(pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function getPanes() {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function getContainer() {
		return this._container;
	},

	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function getZoomScale(toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function getScaleZoom(scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function project(latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint((0, _LatLng.toLatLng)(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function unproject(point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng((0, _Point.toPoint)(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function layerPointToLatLng(point) {
		var projectedPoint = (0, _Point.toPoint)(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function latLngToLayerPoint(latlng) {
		var projectedPoint = this.project((0, _LatLng.toLatLng)(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function wrapLatLng(latlng) {
		return this.options.crs.wrapLatLng((0, _LatLng.toLatLng)(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function wrapLatLngBounds(latlng) {
		return this.options.crs.wrapLatLngBounds((0, _LatLngBounds.toLatLngBounds)(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function distance(latlng1, latlng2) {
		return this.options.crs.distance((0, _LatLng.toLatLng)(latlng1), (0, _LatLng.toLatLng)(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function containerPointToLayerPoint(point) {
		// (Point)
		return (0, _Point.toPoint)(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function layerPointToContainerPoint(point) {
		// (Point)
		return (0, _Point.toPoint)(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function containerPointToLatLng(point) {
		var layerPoint = this.containerPointToLayerPoint((0, _Point.toPoint)(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function latLngToContainerPoint(latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint((0, _LatLng.toLatLng)(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {
		return DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function mouseEventToLatLng(e) {
		// (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},

	// map initialization methods

	_initContainer: function _initContainer(id) {
		var container = this._container = DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		DomEvent.on(container, 'scroll', this._onScroll, this);
		this._containerId = Util.stamp(container);
	},

	_initLayout: function _initLayout() {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;

		DomUtil.addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function _initPanes() {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		DomUtil.setPosition(this._mapPane, new _Point.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for `Tooltip`s.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},

	// private methods that modify map state

	// @section Map state change events
	_resetView: function _resetView(center, zoom) {
		DomUtil.setPosition(this._mapPane, new _Point.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function _moveStart(zoomChanged, noMoveStart) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		if (!noMoveStart) {
			this.fire('movestart');
		}
		return this;
	},

	_move: function _move(center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || data && data.pinch) {
			// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function _moveEnd(zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function _stop() {
		Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function _rawPanBy(offset) {
		DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function _getZoomSpan() {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function _panInsideMaxBounds() {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function _checkIfLoaded() {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function _initEvents(remove) {
		this._targets = {};
		this._targets[Util.stamp(this._container)] = this;

		var onOff = remove ? DomEvent.off : DomEvent.on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (Browser.any3d && this.options.transform3DLimit) {
			(remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function _onResize() {
		Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = Util.requestAnimFrame(function () {
			this.invalidateSize({ debounceMoveend: true });
		}, this);
	},

	_onScroll: function _onScroll() {
		this._container.scrollTop = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function _onMoveEnd() {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function _findEventTargets(e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[Util.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !DomEvent.isExternalTarget(src, e)) {
					break;
				}
				targets.push(target);
				if (isHover) {
					break;
				}
			}
			if (src === this._container) {
				break;
			}
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && DomEvent.isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function _handleDOMEvent(e) {
		if (!this._loaded || DomEvent.skipped(e)) {
			return;
		}

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress') {
			// prevents outline when clicking on keyboard-focusable element
			DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function _fireDOMEvent(e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) {
			return;
		}

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) {
			return;
		}

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
			data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && Util.indexOf(this._mouseEvents, type) !== -1) {
				return;
			}
		}
	},

	_draggableMoved: function _draggableMoved(obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
	},

	_clearHandlers: function _clearHandlers() {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function whenReady(callback, context) {
		if (this._loaded) {
			callback.call(context || this, { target: this });
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	// private methods for getting map state

	_getMapPanePos: function _getMapPanePos() {
		return DomUtil.getPosition(this._mapPane) || new _Point.Point(0, 0);
	},

	_moved: function _moved() {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function _getTopLeftPoint(center, zoom) {
		var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return (0, _Bounds.toBounds)([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function _getCenterLayerPoint() {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function _getCenterOffset(latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function _limitCenter(center, zoom, bounds) {

		if (!bounds) {
			return center;
		}

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new _Bounds.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function _limitOffset(offset, bounds) {
		if (!bounds) {
			return offset;
		}

		var viewBounds = this.getPixelBounds(),
		    newBounds = new _Bounds.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = (0, _Bounds.toBounds)(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new _Point.Point(dx, dy);
	},

	_rebound: function _rebound(left, right) {
		return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function _limitZoom(zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function _onPanTransitionStep() {
		this.fire('move');
	},

	_onPanTransitionEnd: function _onPanTransitionEnd() {
		DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function _tryAnimatedPan(center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._trunc();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
			return false;
		}

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function _createAnimProxy() {

		var proxy = this._proxy = DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = DomUtil.TRANSFORM,
			    transform = this._proxy.style[prop];

			DomUtil.setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			DomUtil.setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function _destroyAnimProxy() {
		DomUtil.remove(this._proxy);
		delete this._proxy;
	},

	_catchTransitionEnd: function _catchTransitionEnd(e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function _nothingToAnimate() {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {

		if (this._animatingZoom) {
			return true;
		}

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
			return false;
		}

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) {
			return false;
		}

		Util.requestAnimFrame(function () {
			this._moveStart(true, false)._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {
		if (!this._mapPane) {
			return;
		}

		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(Util.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function _onZoomTransitionEnd() {
		if (!this._animatingZoom) {
			return;
		}

		if (this._mapPane) {
			DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');
		}

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.LatLng = LatLng;
exports.toLatLng = toLatLng;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _CRS = __webpack_require__(16);

var _LatLngBounds = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 *
 * Note that `LatLng` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function equals(obj, maxMargin) {
		if (!obj) {
			return false;
		}

		obj = toLatLng(obj);

		var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function toString(precision) {
		return 'LatLng(' + Util.formatNum(this.lat, precision) + ', ' + Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
	distanceTo: function distanceTo(other) {
		return _CRS.Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function wrap() {
		return _CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function toBounds(sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);

		return (0, _LatLngBounds.toLatLngBounds)([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function clone() {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};

// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (Util.isArray(a) && _typeof(a[0]) !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.LatLngBounds = LatLngBounds;
exports.toLatLngBounds = toLatLngBounds;

var _LatLng = __webpack_require__(9);

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 *
 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLngBounds(corner1, corner2) {
	// (LatLng, LatLng) or (LatLng[])
	if (!corner1) {
		return;
	}

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function extend(obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2,
		    ne2;

		if (obj instanceof _LatLng.LatLng) {
			sw2 = obj;
			ne2 = obj;
		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) {
				return this;
			}
		} else {
			return obj ? this.extend((0, _LatLng.toLatLng)(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new _LatLng.LatLng(sw2.lat, sw2.lng);
			this._northEast = new _LatLng.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
	// Negative values will retract the bounds.
	pad: function pad(bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(new _LatLng.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new _LatLng.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function getCenter() {
		return new _LatLng.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function getSouthWest() {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function getNorthEast() {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function getNorthWest() {
		return new _LatLng.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function getSouthEast() {
		return new _LatLng.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function getWest() {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function getSouth() {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function getEast() {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function getNorth() {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function contains(obj) {
		// (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof _LatLng.LatLng || 'lat' in obj) {
			obj = (0, _LatLng.toLatLng)(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2,
		    ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function intersects(bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),
		    latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
		    lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function overlaps(bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),
		    latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
		    lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function toBBoxString() {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function equals(bounds, maxMargin) {
		if (!bounds) {
			return false;
		}

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function isValid() {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Element = undefined;

var _elementMixin = __webpack_require__(33);

/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin Polymer.ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */
var Element = (0, _elementMixin.ElementMixin)(HTMLElement);
exports.Element = Element;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Layer = undefined;

var _Events = __webpack_require__(19);

var _Map = __webpack_require__(8);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */

var Layer = exports.Layer = _Events.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
  * Classes extending `L.Layer` will inherit the following methods:
  *
  * @method addTo(map: Map|LayerGroup): this
  * Adds the layer to the given map or layer group.
  */
	addTo: function addTo(map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function remove() {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function removeFrom(obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function getPane(name) {
		return this._map.getPane(name ? this.options[name] || name : this.options.pane);
	},

	addInteractiveTarget: function addInteractiveTarget(targetEl) {
		this._map._targets[Util.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function removeInteractiveTarget(targetEl) {
		delete this._map._targets[Util.stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function getAttribution() {
		return this.options.attribution;
	},

	_layerAdd: function _layerAdd(e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) {
			return;
		}

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', { layer: this });
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */

/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
_Map.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function addLayer(layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = Util.stamp(layer);
		if (this._layers[id]) {
			return this;
		}
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function removeLayer(layer) {
		var id = Util.stamp(layer);

		if (!this._layers[id]) {
			return this;
		}

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', { layer: layer });
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function hasLayer(layer) {
		return !!layer && Util.stamp(layer) in this._layers;
	},

	/* @method eachLayer(fn: Function, context?: Object): this
  * Iterates over the layers of the map, optionally specifying context of the iterator function.
  * ```
  * map.eachLayer(function(layer){
  *     layer.bindPopup('Hello');
  * });
  * ```
  */
	eachLayer: function eachLayer(method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function _addLayers(layers) {
		layers = layers ? Util.isArray(layers) ? layers : [layers] : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function _addZoomLimit(layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[Util.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function _removeZoomLimit(layer) {
		var id = Util.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function _updateZoomLevels() {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dedupingMixin = undefined;

__webpack_require__(2);

// unique global id for deduping mixins.
var dedupeId = 0;

/**
 * @constructor
 * @extends {Function}
 */
function MixinFunction() {}
/** @type {(WeakMap | undefined)} */
MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */
MixinFunction.prototype.__mixinSet;

var dedupingMixin = exports.dedupingMixin = function dedupingMixin(mixin) {
  var mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
  }
  // maintain a unique id for each mixin
  var mixinDedupeId = dedupeId++;
  function dedupingMixin(base) {
    var baseSet = /** @type {!MixinFunction} */base.__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    var map = mixinApplications;
    var extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */mixin(base);
      map.set(base, extended);
    }
    // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.
    var mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Handler = undefined;

var _Class = __webpack_require__(20);

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = exports.Handler = _Class.Class.extend({
	initialize: function initialize(map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function enable() {
		if (this._enabled) {
			return this;
		}

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function disable() {
		if (!this._enabled) {
			return this;
		}

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function enabled() {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

// @section There is static function which can be called without instantiating L.Handler:
// @function addTo(map: Map, name: String): this
// Adds a new Handler to the given map with the given name.
Handler.addTo = function (map, name) {
	map.addHandler(name, this);
	return this;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.microTask = exports.idlePeriod = exports.animationFrame = exports.timeOut = undefined;

__webpack_require__(2);

/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
var AsyncInterface = void 0; // eslint-disable-line no-unused-vars

// Microtask implemented using Mutation Observer
var microtaskCurrHandle = 0;
var microtaskLastHandle = 0;
var microtaskCallbacks = [];
var microtaskNodeContent = 0;
var microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

function microtaskFlush() {
  var len = microtaskCallbacks.length;
  for (var i = 0; i < len; i++) {
    var cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

var timeOut = exports.timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} delay Time to wait before calling callbacks in ms
   * @return {AsyncInterface} An async timeout interface
   */
  after: function after(delay) {
    return {
      run: function run(fn) {
        return setTimeout(fn, delay);
      },

      cancel: window.clearTimeout.bind(window)
    };
  },

  /**
   * Enqueues a function called in the next task.
   *
   * @memberof Polymer.Async.timeOut
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.setTimeout.bind(window),
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.clearTimeout.bind(window)
};

var animationFrame = exports.animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof Polymer.Async.animationFrame
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.requestAnimationFrame.bind(window),
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.cancelAnimationFrame.bind(window)
};

var idlePeriod = exports.idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {function(IdleDeadline)} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: function run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },

  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: function cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }
};

var microTask = exports.microTask = {

  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof Polymer.Async.microTask
   * @param {Function} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run: function run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },


  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof Polymer.Async.microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: function cancel(handle) {
    var idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Earth = undefined;

var _CRS = __webpack_require__(47);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = exports.Earth = Util.extend({}, _CRS.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function distance(latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
		    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
		    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
		    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return this.R * c;
	}
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDebouncer = exports.flush = exports.matchesSelector = exports.dom = exports.DomApi = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

__webpack_require__(34);

var _flattenedNodesObserver = __webpack_require__(67);

var _flush = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var p = Element.prototype;
/**
 * @const {function(this:Element, string): boolean}
 */
var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @memberof Polymer.dom
 * @param {!Element} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
var matchesSelector = function matchesSelector(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};

/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 */

var DomApi = function () {

  /**
   * @param {Node} node Node for which to create a Polymer.dom helper object.
   */
  function DomApi(node) {
    _classCallCheck(this, DomApi);

    this.node = node;
  }

  /**
   * Returns an instance of `Polymer.FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {Function} callback Called when direct or distributed children
   *   of this element changes
   * @return {Polymer.FlattenedNodesObserver} Observer instance
   */


  _createClass(DomApi, [{
    key: 'observeNodes',
    value: function observeNodes(callback) {
      return new _flattenedNodesObserver.FlattenedNodesObserver(this.node, callback);
    }

    /**
     * Disconnects an observer previously created via `observeNodes`
     *
     * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
     *   to disconnect.
     */

  }, {
    key: 'unobserveNodes',
    value: function unobserveNodes(observerHandle) {
      observerHandle.disconnect();
    }

    /**
     * Provided as a backwards-compatible API only.  This method does nothing.
     */

  }, {
    key: 'notifyObserver',
    value: function notifyObserver() {}

    /**
     * Returns true if the provided node is contained with this element's
     * light-DOM children or shadow root, including any nested shadow roots
     * of children therein.
     *
     * @param {Node} node Node to test
     * @return {boolean} Returns true if the given `node` is contained within
     *   this element's light or shadow DOM.
     */

  }, {
    key: 'deepContains',
    value: function deepContains(node) {
      if (this.node.contains(node)) {
        return true;
      }
      var n = node;
      var doc = node.ownerDocument;
      // walk from node to `this` or `document`
      while (n && n !== doc && n !== this.node) {
        // use logical parentnode, or native ShadowRoot host
        n = n.parentNode || n.host;
      }
      return n === this.node;
    }

    /**
     * Returns the root node of this node.  Equivalent to `getRoodNode()`.
     *
     * @return {Node} Top most element in the dom tree in which the node
     * exists. If the node is connected to a document this is either a
     * shadowRoot or the document; otherwise, it may be the node
     * itself or a node or document fragment containing it.
     */

  }, {
    key: 'getOwnerRoot',
    value: function getOwnerRoot() {
      return this.node.getRootNode();
    }

    /**
     * For slot elements, returns the nodes assigned to the slot; otherwise
     * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
     *
     * @return {Array<Node>} Array of assigned nodes
     */

  }, {
    key: 'getDistributedNodes',
    value: function getDistributedNodes() {
      return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
    }

    /**
     * Returns an array of all slots this element was distributed to.
     *
     * @return {Array<HTMLSlotElement>} Description
     */

  }, {
    key: 'getDestinationInsertionPoints',
    value: function getDestinationInsertionPoints() {
      var ip$ = [];
      var n = this.node.assignedSlot;
      while (n) {
        ip$.push(n);
        n = n.assignedSlot;
      }
      return ip$;
    }

    /**
     * Calls `importNode` on the `ownerDocument` for this node.
     *
     * @param {Node} node Node to import
     * @param {boolean} deep True if the node should be cloned deeply during
     *   import
     * @return {Node} Clone of given node imported to this owner document
     */

  }, {
    key: 'importNode',
    value: function importNode(node, deep) {
      var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
      return doc.importNode(node, deep);
    }

    /**
     * @return {Array} Returns a flattened list of all child nodes and nodes assigned
     * to child slots.
     */

  }, {
    key: 'getEffectiveChildNodes',
    value: function getEffectiveChildNodes() {
      return _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(this.node);
    }

    /**
     * Returns a filtered list of flattened child elements for this element based
     * on the given selector.
     *
     * @param {string} selector Selector to filter nodes against
     * @return {Array<HTMLElement>} List of flattened child elements
     */

  }, {
    key: 'queryDistributedElements',
    value: function queryDistributedElements(selector) {
      var c$ = this.getEffectiveChildNodes();
      var list = [];
      for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
          list.push(c);
        }
      }
      return list;
    }

    /**
     * For shadow roots, returns the currently focused element within this
     * shadow root.
     *
     * @return {Node|undefined} Currently focused element
     */

  }, {
    key: 'activeElement',
    get: function get() {
      var node = this.node;
      return node._activeElement !== undefined ? node._activeElement : node.activeElement;
    }
  }]);

  return DomApi;
}();

function forwardMethods(proto, methods) {
  var _loop = function _loop(i) {
    var method = methods[i];
    proto[method] = /** @this {DomApi} */function () {
      return this.node[method].apply(this.node, arguments);
    };
  };

  for (var i = 0; i < methods.length; i++) {
    _loop(i);
  }
}

function forwardReadOnlyProperties(proto, properties) {
  var _loop2 = function _loop2(i) {
    var name = properties[i];
    Object.defineProperty(proto, name, {
      get: function get() {
        return (/** @type {DomApi} */this.node[name]
        );
      },
      configurable: true
    });
  };

  for (var i = 0; i < properties.length; i++) {
    _loop2(i);
  }
}

function forwardProperties(proto, properties) {
  var _loop3 = function _loop3(i) {
    var name = properties[i];
    Object.defineProperty(proto, name, {
      get: function get() {
        return (/** @type {DomApi} */this.node[name]
        );
      },
      set: function set(value) {
        /** @type {DomApi} */this.node[name] = value;
      },
      configurable: true
    });
  };

  for (var i = 0; i < properties.length; i++) {
    _loop3(i);
  }
}

forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

/**
 * Event API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is an `Event`.
 */

var EventApi = function () {
  function EventApi(event) {
    _classCallCheck(this, EventApi);

    this.event = event;
  }

  /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {Node} The node this event was dispatched to
   */


  _createClass(EventApi, [{
    key: 'rootTarget',
    get: function get() {
      return this.event.composedPath()[0];
    }

    /**
     * Returns the local (re-targeted) target for this event.
     *
     * @return {Node} The local (re-targeted) target for this event.
     */

  }, {
    key: 'localTarget',
    get: function get() {
      return this.event.target;
    }

    /**
     * Returns the `composedPath` for this event.
     */

  }, {
    key: 'path',
    get: function get() {
      return this.event.composedPath();
    }
  }]);

  return EventApi;
}();

exports.DomApi = DomApi;
var dom = exports.dom = function dom(obj) {
  obj = obj || document;
  if (!obj.__domApi) {
    var helper = void 0;
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApi(obj);
    }
    obj.__domApi = helper;
  }
  return obj.__domApi;
};

exports.matchesSelector = matchesSelector;
exports.flush = _flush.flush;
exports.addDebouncer = _flush.enqueueDebouncer;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.featureGroup = exports.FeatureGroup = undefined;

var _LayerGroup = __webpack_require__(46);

var _LatLngBounds = __webpack_require__(10);

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = exports.FeatureGroup = _LayerGroup.LayerGroup.extend({

	addLayer: function addLayer(layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		_LayerGroup.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', { layer: layer });
	},

	removeLayer: function removeLayer(layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		_LayerGroup.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', { layer: layer });
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function setStyle(style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function bringToFront() {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the back of all other layers
	bringToBack: function bringToBack() {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function getBounds() {
		var bounds = new _LatLngBounds.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = exports.featureGroup = function featureGroup(layers) {
	return new FeatureGroup(layers);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Evented = exports.Events = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _Class = __webpack_require__(20);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = exports.Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
  * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
  *
  * @alternative
  * @method on(eventMap: Object): this
  * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  */
	on: function on(types, fn, context) {

		// types can be a map of types/handlers
		if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}
		} else {
			// types can be a string of space-separated words
			types = Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
  * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
  *
  * @alternative
  * @method off(eventMap: Object): this
  * Removes a set of type/listener pairs.
  *
  * @alternative
  * @method off: this
  * Removes all listeners to all events on the object.
  */
	off: function off(types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;
		} else if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}
		} else {
			types = Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function _on(type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = { fn: fn, ctx: context },
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function _off(type, fn, context) {
		var listeners, i, len;

		if (!this._events) {
			return;
		}

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) {
					continue;
				}
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function fire(type, data, propagate) {
		if (!this.listens(type, propagate)) {
			return this;
		}

		var event = Util.extend({}, data, {
			type: type,
			target: this,
			sourceTarget: data && data.sourceTarget || this
		});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = this._firingCount + 1 || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function listens(type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) {
			return true;
		}

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) {
					return true;
				}
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function once(types, fn, context) {

		if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = Util.bind(function () {
			this.off(types, fn, context).off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this.on(types, fn, context).on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function addEventParent(obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[Util.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function removeEventParent(obj) {
		if (this._eventParents) {
			delete this._eventParents[Util.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function _propagateEvent(e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, Util.extend({
				layer: e.target,
				propagatedFrom: e.target
			}, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = exports.Evented = _Class.Class.extend(Events);

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Class = Class;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function NewClass() {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		Util.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = Util.extend(Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	Util.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) {
			return;
		}

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};

// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	Util.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	Util.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) {
	// (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (typeof L === 'undefined' || !L || !L.Mixin) {
		return;
	}

	includes = Util.isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Transformation = Transformation;
exports.toTransformation = toTransformation;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */

// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (Util.isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function transform(point, scale) {
		// (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function _transform(point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function untransform(point, scale) {
		scale = scale || 1;
		return new _Point.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coefficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.control = exports.Control = undefined;

var _Class = __webpack_require__(20);

var _Map = __webpack_require__(8);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = exports.Control = _Class.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
	},

	/* @section
  * Classes extending L.Control will inherit the following methods:
  *
  * @method getPosition: string
  * Returns the position of the control.
  */
	getPosition: function getPosition() {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function setPosition(position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function getContainer() {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function addTo(map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function remove() {
		if (!this._map) {
			return this;
		}

		DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function _refocusOnMap(e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = exports.control = function control(options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
_Map.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function addControl(control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function removeControl(control) {
		control.remove();
		return this;
	},

	_initControlPos: function _initControlPos() {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer = DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function _clearControlPos() {
		for (var i in this._controlCorners) {
			DomUtil.remove(this._controlCorners[i]);
		}
		DomUtil.remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Path = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = exports.Path = _Layer.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function beforeAdd(map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function onAdd() {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function onRemove() {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function redraw() {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function setStyle(style) {
		Util.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function bringToFront() {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function bringToBack() {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function getElement() {
		return this._path;
	},

	_reset: function _reset() {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function _clickTolerance() {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
	}
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.simplify = simplify;
exports.pointToSegmentDistance = pointToSegmentDistance;
exports.closestPointOnSegment = closestPointOnSegment;
exports.clipSegment = clipSegment;
exports._getEdgeIntersection = _getEdgeIntersection;
exports._getBitCode = _getBitCode;
exports._sqClosestPointOnSegment = _sqClosestPointOnSegment;
exports.isFlat = isFlat;
exports._flat = _flat;

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

	// stage 1: vertex reduction
	points = _reducePoints(points, sqTolerance);

	// stage 2: Douglas-Peucker simplification
	points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
	    ArrayConstructor = (typeof Uint8Array === 'undefined' ? 'undefined' : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,
	    markers = new ArrayConstructor(len);

	markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
	    newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	    index,
	    i,
	    sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
	    codeB = _getBitCode(b, bounds),
	    codeOut,
	    p,
	    newCode;

	// save 2nd code to avoid calculating it on the next segment
	_lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
	    dy = b.y - a.y,
	    min = bounds.min,
	    max = bounds.max,
	    x,
	    y;

	if (code & 8) {
		// top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;
	} else if (code & 4) {
		// bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;
	} else if (code & 2) {
		// right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;
	} else if (code & 1) {
		// left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new _Point.Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) {
		// left
		code |= 1;
	} else if (p.x > bounds.max.x) {
		// right
		code |= 2;
	}

	if (p.y < bounds.min.y) {
		// bottom
		code |= 4;
	} else if (p.y > bounds.max.y) {
		// top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
	    dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
	    y = p1.y,
	    dx = p2.x - x,
	    dy = p2.y - y,
	    dot = dx * dx + dy * dy,
	    t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new _Point.Point(x, y);
}

// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !Util.isArray(latlngs[0]) || _typeof(latlngs[0][0]) !== 'object' && typeof latlngs[0][0] !== 'undefined';
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathFromUrl = exports.resolveUrl = exports.resolveCss = undefined;

__webpack_require__(2);

var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
var workingURL = void 0;
var resolveDoc = void 0;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  // Lazy feature detection.
  if (workingURL === undefined) {
    workingURL = false;
    try {
      var u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = u.href === 'http://a/c%20d';
    } catch (e) {
      // silently fail
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    return new URL(url, baseURI).href;
  }
  // Fallback to creating an anchor into a disconnected document.
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}

/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
    return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
  });
}

/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}

exports.resolveCss = resolveCss;
exports.resolveUrl = resolveUrl;
exports.pathFromUrl = pathFromUrl;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDeep = undefined;
exports.isPath = isPath;
exports.root = root;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
exports.translate = translate;
exports.matches = matches;
exports.normalize = normalize;
exports.split = split;
exports.get = get;
exports.set = set;

__webpack_require__(2);

function isPath(path) {
  return path.indexOf('.') >= 0;
}

function root(path) {
  var dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}

function matches(base, path) {
  return base === path || isAncestor(base, path) || isDescendant(base, path);
}

function normalize(path) {
  if (Array.isArray(path)) {
    var parts = [];
    for (var i = 0; i < path.length; i++) {
      var args = path[i].toString().split('.');
      for (var j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }
  return path.toString().split('.');
}

function get(root, path, info) {
  var prop = root;
  var parts = split(path);
  // Loop over path parts[0..n-1] and dereference
  for (var i = 0; i < parts.length; i++) {
    if (!prop) {
      return;
    }
    var part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}

function set(root, path, value) {
  var prop = root;
  var parts = split(path);
  var last = parts[parts.length - 1];
  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (var i = 0; i < parts.length - 1; i++) {
      var part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    // Set value to object at end of path
    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }
  return parts.join('.');
}

var isDeep = exports.isDeep = isPath;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Debouncer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

__webpack_require__(13);

__webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
var AsyncModule = void 0; // eslint-disable-line no-unused-vars

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 * @memberof Polymer
 */

var Debouncer = function () {
  function Debouncer() {
    _classCallCheck(this, Debouncer);

    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncModule} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   */


  _createClass(Debouncer, [{
    key: 'setConfig',
    value: function setConfig(asyncModule, callback) {
      var _this = this;

      this._asyncModule = asyncModule;
      this._callback = callback;
      this._timer = this._asyncModule.run(function () {
        _this._timer = null;
        _this._callback();
      });
    }
    /**
     * Cancels an active debouncer and returns a reference to itself.
     */

  }, {
    key: 'cancel',
    value: function cancel() {
      if (this.isActive()) {
        this._asyncModule.cancel(this._timer);
        this._timer = null;
      }
    }
    /**
     * Flushes an active debouncer and returns a reference to itself.
     */

  }, {
    key: 'flush',
    value: function flush() {
      if (this.isActive()) {
        this.cancel();
        this._callback();
      }
    }
    /**
     * Returns true if the debouncer is active.
     *
     * @return {boolean} True if active.
     */

  }, {
    key: 'isActive',
    value: function isActive() {
      return this._timer != null;
    }
    /**
     * Creates a debouncer if no debouncer is passed as a parameter
     * or it cancels an active debouncer otherwise. The following
     * example shows how a debouncer can be called multiple times within a
     * microtask and "debounced" such that the provided callback function is
     * called once. Add this method to a custom element:
     *
     * _debounceWork() {
     *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
     *       Polymer.Async.microTask, () => {
     *     this._doWork();
     *   });
     * }
     *
     * If the `_debounceWork` method is called multiple times within the same
     * microtask, the `_doWork` function will be called only once at the next
     * microtask checkpoint.
     *
     * Note: In testing it is often convenient to avoid asynchrony. To accomplish
     * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
     * `Polymer.flush`. For example, extend the above example by adding
     * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
     * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
     * the debouncer has completed.
     *
     * @param {Debouncer?} debouncer Debouncer object.
     * @param {!AsyncModule} asyncModule Object with Async interface
     * @param {function()} callback Callback to run.
     * @return {!Debouncer} Returns a debouncer object.
     */

  }], [{
    key: 'debounce',
    value: function debounce(debouncer, asyncModule, callback) {
      if (debouncer instanceof Debouncer) {
        debouncer.cancel();
      } else {
        debouncer = new Debouncer();
      }
      debouncer.setConfig(asyncModule, callback);
      return debouncer;
    }
  }]);

  return Debouncer;
}();

exports.Debouncer = Debouncer;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Polymer = undefined;

var _class = __webpack_require__(99);

var Polymer = exports.Polymer = function Polymer(info) {
  // if input is a `class` (aka a function with a prototype), use the prototype
  // remember that the `constructor` will never be called
  var klass = void 0;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = (0, _class.Class)(info);
  }
  customElements.define(klass.is, /** @type {!HTMLElement} */klass);
  return klass;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionalMutableData = exports.MutableData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _mixin = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
  var isObject = void 0;
  if (mutableData) {
    isObject = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;
    // Pull `old` for Objects from temp cache, but treat `null` as a primitive
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  // Strict equality check, but return false for NaN===NaN
  var shouldChange = old !== value && (old === old || value === value);
  // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}

var MutableData = exports.MutableData = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  var MutableData = function (_superClass) {
    _inherits(MutableData, _superClass);

    function MutableData() {
      _classCallCheck(this, MutableData);

      return _possibleConstructorReturn(this, (MutableData.__proto__ || Object.getPrototypeOf(MutableData)).apply(this, arguments));
    }

    _createClass(MutableData, [{
      key: '_shouldPropertyChange',

      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * This method pulls the value to dirty check against from the `__dataTemp`
       * cache (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      value: function _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, true);
      }
    }]);

    return MutableData;
  }(superClass);
  /** @type {boolean} */


  MutableData.prototype.mutableData = false;

  return MutableData;
});

var OptionalMutableData = exports.OptionalMutableData = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  var OptionalMutableData = function (_superClass2) {
    _inherits(OptionalMutableData, _superClass2);

    function OptionalMutableData() {
      _classCallCheck(this, OptionalMutableData);

      return _possibleConstructorReturn(this, (OptionalMutableData.__proto__ || Object.getPrototypeOf(OptionalMutableData)).apply(this, arguments));
    }

    _createClass(OptionalMutableData, [{
      key: '_shouldPropertyChange',


      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * When `this.mutableData` is true on this instance, this method
       * pulls the value to dirty check against from the `__dataTemp` cache
       * (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      value: function _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, this.mutableData);
      }
    }], [{
      key: 'properties',
      get: function get() {
        return {
          /**
           * Instance-level flag for configuring the dirty-checking strategy
           * for this element.  When true, Objects and Arrays will skip dirty
           * checking, otherwise strict equality checking will be used.
           */
          mutableData: Boolean
        };
      }
    }]);

    return OptionalMutableData;
  }(superClass);

  return OptionalMutableData;
});

// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Icon = undefined;
exports.icon = icon;

var _Class = __webpack_require__(20);

var _Util = __webpack_require__(0);

var _Point = __webpack_require__(3);

var _Browser = __webpack_require__(4);

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = exports.Icon = _Class.Class.extend({

	/* @section
  * @aka Icon options
  *
  * @option iconUrl: String = null
  * **(required)** The URL to the icon image (absolute or relative to your script path).
  *
  * @option iconRetinaUrl: String = null
  * The URL to a retina sized version of the icon image (absolute or relative to your
  * script path). Used for Retina screen devices.
  *
  * @option iconSize: Point = null
  * Size of the icon image in pixels.
  *
  * @option iconAnchor: Point = null
  * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
  * will be aligned so that this point is at the marker's geographical location. Centered
  * by default if size is specified, also can be set in CSS with negative margins.
  *
  * @option popupAnchor: Point = [0, 0]
  * The coordinates of the point from which popups will "open", relative to the icon anchor.
  *
  * @option tooltipAnchor: Point = [0, 0]
  * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
  *
  * @option shadowUrl: String = null
  * The URL to the icon shadow image. If not specified, no shadow image will be created.
  *
  * @option shadowRetinaUrl: String = null
  *
  * @option shadowSize: Point = null
  * Size of the shadow image in pixels.
  *
  * @option shadowAnchor: Point = null
  * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
  * as iconAnchor if not specified).
  *
  * @option className: String = ''
  * A custom class name to assign to both icon and shadow images. Empty by default.
  */

	options: {
		popupAnchor: [0, 0],
		tooltipAnchor: [0, 0]
	},

	initialize: function initialize(options) {
		(0, _Util.setOptions)(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function createIcon(oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function createShadow(oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function _createIcon(name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function _setIconStyles(img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = (0, _Point.toPoint)(sizeOption),
		    anchor = (0, _Point.toPoint)(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = -anchor.x + 'px';
			img.style.marginTop = -anchor.y + 'px';
		}

		if (size) {
			img.style.width = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function _createImg(src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function _getIconUrl(name) {
		return _Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});

// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Renderer = undefined;

var _Layer = __webpack_require__(12);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Bounds = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = exports.Renderer = _Layer.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1,

		// @option tolerance: Number = 0
		// How much to extend click tolerance round a path/object on the map
		tolerance: 0
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
		Util.stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function onAdd() {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function onRemove() {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function getEvents() {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function _onAnimZoom(ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function _onZoom() {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function _updateTransform(center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),
		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (Browser.any3d) {
			DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function _reset() {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function _onZoomEnd() {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function _updatePaths() {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function _update() {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new _Bounds.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CircleMarker = undefined;
exports.circleMarker = circleMarker;

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = exports.CircleMarker = _Path.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function initialize(latlng, options) {
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function setLatLng(latlng) {
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this.redraw();
		return this.fire('move', { latlng: this._latlng });
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function setRadius(radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function getRadius() {
		return this._radius;
	},

	setStyle: function setStyle(options) {
		var radius = options && options.radius || this._radius;
		_Path.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function _project() {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function _updateBounds() {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new _Bounds.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function _update() {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function _updatePath() {
		this._renderer._updateCircle(this);
	},

	_empty: function _empty() {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});

// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStyles = exports.registrations = exports.instanceCount = exports.ElementMixin = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports._regLog = _regLog;
exports.register = register;
exports.dumpRegistrations = dumpRegistrations;

__webpack_require__(2);

var _settings = __webpack_require__(34);

var _mixin = __webpack_require__(13);

var _caseMap = __webpack_require__(35);

var caseMap$0 = _interopRequireWildcard(_caseMap);

var _styleGather = __webpack_require__(58);

var _resolveUrl = __webpack_require__(25);

var _domModule = __webpack_require__(59);

var _propertyEffects = __webpack_require__(36);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ElementMixin = exports.ElementMixin = (0, _mixin.dedupingMixin)(function (base) {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_PropertyEffects}
   */
  var polymerElementBase = (0, _propertyEffects.PropertyEffects)(base);

  var caseMap = caseMap$0;

  /**
   * Returns the `properties` object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   *
   * @param {HTMLElement} klass Element class
   * @return {Object} Object containing own properties for this class
   * @private
   */
  function ownPropertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
      klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
      /** @type PolymerElementConstructor */klass.properties : {};
    }
    return klass.__ownProperties;
  }

  /**
   * Returns the `observers` array specifically on `klass`. Use for
   * setting up observers.
   *
   * @param {HTMLElement} klass Element class
   * @return {Array} Array containing own observers for this class
   * @private
   */
  function ownObserversForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
      klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
      /** @type PolymerElementConstructor */klass.observers : [];
    }
    return klass.__ownObservers;
  }

  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   *
   * @param {Object} flattenedProps Bag to collect flattened properties into
   * @param {Object} props Bag of properties to add to `flattenedProps`
   * @return {Object} The input `flattenedProps` bag
   * @private
   */
  function flattenProperties(flattenedProps, props) {
    for (var p in props) {
      var o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   * @suppress {missingProperties} class.prototype is not a property for some reason?
   * @private
   */
  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
      klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
      var superCtor = Object.getPrototypeOf(klass.prototype).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Object.assign(Object.create(propertiesForClass( /** @type PolymerElementConstructor */superCtor)), klass.__classProperties);
      }
    }
    return klass.__classProperties;
  }

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */
  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
      klass.__classPropertyDefaults = null;
      var props = propertiesForClass(klass);
      for (var p in props) {
        var info = props[p];
        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }
    return klass.__classPropertyDefaults;
  }

  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {PolymerElementConstructor} klass Element class
   * @return {boolean} True if all metaprogramming for this class has been
   *   completed
   * @private
   */
  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
  }

  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClassAndSuper(klass) {
    var proto = /** @type PolymerElementConstructor */klass.prototype;
    var superCtor = Object.getPrototypeOf(proto).constructor;
    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }
    finalizeClass(klass);
  }

  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClass(klass) {
    klass.__finalized = true;
    var proto = /** @type PolymerElementConstructor */klass.prototype;
    if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
      register(proto);
    }
    var props = ownPropertiesForClass(klass);
    if (props) {
      finalizeProperties(proto, props);
    }
    var observers = ownObserversForClass(klass);
    if (observers) {
      finalizeObservers(proto, observers, props);
    }
    // note: create "working" template that is finalized at instance time
    var template = /** @type PolymerElementConstructor */klass.template;
    if (template) {
      if (typeof template === 'string') {
        var t = document.createElement('template');
        t.innerHTML = template;
        template = t;
      } else {
        template = template.cloneNode(true);
      }
      proto._template = template;
    }
  }

  /**
   * Configures a `proto` based on a `properties` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *    and effects to
   * @param {Object} properties Flattened bag of property descriptors for
   *    this class
   * @private
   */
  function finalizeProperties(proto, properties) {
    for (var p in properties) {
      createPropertyFromConfig(proto, p, properties[p], properties);
    }
  }

  /**
   * Configures a `proto` based on a `observers` array.
   * Leverages `PropertyEffects` to create observers.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {Object} observers Flattened array of observer descriptors for
   *   this class
   * @param {Object} dynamicFns Object containing keys for any properties
   *   that are functions and should trigger the effect when the function
   *   reference is changed
   * @private
   */
  function finalizeObservers(proto, observers, dynamicFns) {
    for (var i = 0; i < observers.length; i++) {
      proto._createMethodObserver(observers[i], dynamicFns);
    }
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should may contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttriute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   * Also consider adding warnings when an effect cannot be changed.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @private
   */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }

  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {!HTMLTemplateElement} template Template to process and bind
   * @param {string} baseURI URL against which to resolve urls in
   *   style element cssText
   * @param {string} is Tag name (or type extension name) for this element
   * @param {string=} ext For type extensions, the tag name that was extended
   * @private
   */
  function finalizeTemplate(proto, template, baseURI, is, ext) {
    // support `include="module-name"`
    var cssText = (0, _styleGather.cssFromModuleImports)(is) + (0, _styleGather.cssFromTemplate)(template, baseURI);
    if (cssText) {
      var style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }
    proto._bindTemplate(template);
  }

  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   */

  var PolymerElement = function (_polymerElementBase) {
    _inherits(PolymerElement, _polymerElementBase);

    _createClass(PolymerElement, null, [{
      key: 'finalize',


      /**
       * Called automatically when the first element instance is created to
       * ensure that class finalization work has been completed.
       * May be called by users to eagerly perform class finalization work
       * prior to the creation of the first element instance.
       *
       * Class finalization work generally includes meta-programming such as
       * creating property accessors and any property effect metadata needed for
       * the features used.
       *
       * @public
       */
      value: function finalize() {
        if (!hasClassFinalized(this)) {
          finalizeClassAndSuper(this);
        }
      }

      /**
       * Returns the template that will be stamped into this element's shadow root.
       *
       * If a `static get is()` getter is defined, the default implementation
       * will return the first `<template>` in a `dom-module` whose `id`
       * matches this element's `is`.
       *
       * Users may override this getter to return an arbitrary template
       * (in which case the `is` getter is unnecessary). The template returned
       * may be either an `HTMLTemplateElement` or a string that will be
       * automatically parsed into a template.
       *
       * Note that when subclassing, if the super class overrode the default
       * implementation and the subclass would like to provide an alternate
       * template via a `dom-module`, it should override this getter and
       * return `Polymer.DomModule.import(this.is, 'template')`.
       *
       * If a subclass would like to modify the super class template, it should
       * clone it rather than modify it in place.  If the getter does expensive
       * work such as cloning/modifying a template, it should memoize the
       * template for maximum performance:
       *
       *   let memoizedTemplate;
       *   class MySubClass extends MySuperClass {
       *     static get template() {
       *       if (!memoizedTemplate) {
       *         memoizedTemplate = super.template.cloneNode(true);
       *         let subContent = document.createElement('div');
       *         subContent.textContent = 'This came from MySubClass';
       *         memoizedTemplate.content.appendChild(subContent);
       *       }
       *       return memoizedTemplate;
       *     }
       *   }
       *
       * @return {HTMLTemplateElement|string} Template to be stamped
       */

    }, {
      key: 'observedAttributes',


      /**
       * Standard Custom Elements V1 API.  The default implementation returns
       * a list of dash-cased attributes based on a flattening of all properties
       * declared in `static get properties()` for this element and any
       * superclasses.
       *
       * @return {Array} Observed attribute list
       */
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
          var list = [];
          var properties = propertiesForClass(this);
          for (var prop in properties) {
            list.push((0, _caseMap.camelToDashCase)(prop));
          }
          this.__observedAttributes = list;
        }
        return this.__observedAttributes;
      }
    }, {
      key: 'template',
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
          this._template = _domModule.DomModule && _domModule.DomModule.import(
          /** @type PolymerElementConstructor*/this.is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.template;
        }
        return this._template;
      }

      /**
       * Path matching the url from which the element was imported.
       * This path is used to resolve url's in template style cssText.
       * The `importPath` property is also set on element instances and can be
       * used to create bindings relative to the import path.
       * Defaults to the path matching the url containing a `dom-module` element
       * matching this element's static `is` property.
       * Note, this path should contain a trailing `/`.
       *
       * @return {string} The import path for this element class
       */

    }, {
      key: 'importPath',
      get: function get() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
          var module = _domModule.DomModule && _domModule.DomModule.import( /** @type PolymerElementConstructor */this.is);
          this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type PolymerElementConstructor*/this.prototype).constructor.importPath;
        }
        return this._importPath;
      }
    }]);

    function PolymerElement() {
      _classCallCheck(this, PolymerElement);

      /** @type {HTMLTemplateElement} */
      var _this = _possibleConstructorReturn(this, (PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement)).call(this));

      _this._template;
      /** @type {string} */
      _this._importPath;
      /** @type {string} */
      _this.rootPath;
      /** @type {string} */
      _this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
      _this.root;
      /** @type {!Object<string, !Node>} */
      _this.$;
      return _this;
    }

    /**
     * Overrides the default `Polymer.PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @override
     * @suppress {invalidCasts}
     */


    _createClass(PolymerElement, [{
      key: '_initializeProperties',
      value: function _initializeProperties() {
        exports.instanceCount = instanceCount += 1;
        this.constructor.finalize();
        var importPath = this.constructor.importPath;
        // note: finalize template when we have access to `localName` to
        // avoid dependence on `is` for polyfilling styling.
        if (this._template && !this._template.__polymerFinalized) {
          this._template.__polymerFinalized = true;
          var baseURI = importPath ? (0, _resolveUrl.resolveUrl)(importPath) : '';
          finalizeTemplate( /** @type {!PolymerElement} */this.__proto__, this._template, baseURI,
          /**@type {!HTMLElement}*/this.localName);
        }
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_initializeProperties', this).call(this);
        // set path defaults
        this.rootPath = _settings.rootPath;
        this.importPath = importPath;
        // apply property defaults...
        var p$ = propertyDefaultsForClass(this.constructor);
        if (!p$) {
          return;
        }
        for (var p in p$) {
          var info = p$[p];
          // Don't set default value if there is already an own property, which
          // happens when a `properties` property with default but no effects had
          // a property set (e.g. bound) by its host before upgrade
          if (!this.hasOwnProperty(p)) {
            var value = typeof info.value == 'function' ? info.value.call(this) : info.value;
            // Set via `_setProperty` if there is an accessor, to enable
            // initializing readOnly property defaults
            if (this._hasAccessor(p)) {
              this._setPendingProperty(p, value, true);
            } else {
              this[p] = value;
            }
          }
        }
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `connectedCallback`.
       *
       * The default implementation enables the property effects system and
       * flushes any pending properties, and updates shimmed CSS properties
       * when using the ShadyCSS scoping/custom properties polyfill.
       *
       * @suppress {invalidCasts}
       */

    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        if (window.ShadyCSS && this._template) {
          window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
        }
        this._enableProperties();
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `disconnectedCallback`.
       */

    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {}

      /**
       * Stamps the element template.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        if (this._template) {
          this.root = this._stampTemplate(this._template);
          this.$ = this.root.$;
        }
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), 'ready', this).call(this);
      }

      /**
       * Implements `PropertyEffects`'s `_readyClients` call. Attaches
       * element dom by calling `_attachDom` with the dom stamped from the
       * element's template via `_stampTemplate`. Note that this allows
       * client dom to be attached to the element prior to any observers
       * running.
       *
       * @override
       */

    }, {
      key: '_readyClients',
      value: function _readyClients() {
        if (this._template) {
          this.root = this._attachDom( /** @type {StampedTemplate} */this.root);
        }
        // The super._readyClients here sets the clients initialized flag.
        // We must wait to do this until after client dom is created/attached
        // so that this flag can be checked to prevent notifications fired
        // during this process from being handled before clients are ready.
        _get(PolymerElement.prototype.__proto__ || Object.getPrototypeOf(PolymerElement.prototype), '_readyClients', this).call(this);
      }

      /**
       * Attaches an element's stamped dom to itself. By default,
       * this method creates a `shadowRoot` and adds the dom to it.
       * However, this method may be overridden to allow an element
       * to put its dom in another location.
       *
       * @throws {Error}
       * @suppress {missingReturn}
       * @param {StampedTemplate} dom to attach to the element.
       * @return {ShadowRoot} node to which the dom has been attached.
       */

    }, {
      key: '_attachDom',
      value: function _attachDom(dom) {
        if (this.attachShadow) {
          if (dom) {
            if (!this.shadowRoot) {
              this.attachShadow({ mode: 'open' });
            }
            this.shadowRoot.appendChild(dom);
            return this.shadowRoot;
          }
          return null;
        } else {
          throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
          'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
        }
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `attributeChangedCallback`.
       *
       * By default, attributes declared in `properties` metadata are
       * deserialized using their `type` information to properties of the
       * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
       * properties.
       *
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @override
       */

    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          var property = caseMap.dashToCamelCase(name);
          var type = propertiesForClass(this.constructor)[property].type;
          if (!this._hasReadOnlyEffect(property)) {
            this._attributeToProperty(name, value, type);
          }
        }
      }

      /**
       * When using the ShadyCSS scoping and custom property shim, causes all
       * shimmed styles in this element (and its subtree) to be updated
       * based on current custom property values.
       *
       * The optional parameter overrides inline custom property styles with an
       * object of properties where the keys are CSS properties, and the values
       * are strings.
       *
       * Example: `this.updateStyles({'--color': 'blue'})`
       *
       * These properties are retained unless a value of `null` is set.
       *
       * @param {Object=} properties Bag of custom property key/values to
       *   apply to this element.
       * @suppress {invalidCasts}
       */

    }, {
      key: 'updateStyles',
      value: function updateStyles(properties) {
        if (window.ShadyCSS) {
          window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
        }
      }

      /**
       * Rewrites a given URL relative to a base URL. The base URL defaults to
       * the original location of the document containing the `dom-module` for
       * this element. This method will return the same URL before and after
       * bundling.
       *
       * @param {string} url URL to resolve.
       * @param {string=} base Optional base URL to resolve against, defaults
       * to the element's `importPath`
       * @return {string} Rewritten URL relative to base
       */

    }, {
      key: 'resolveUrl',
      value: function resolveUrl(url, base) {
        if (!base && this.importPath) {
          base = (0, _resolveUrl.resolveUrl)(this.importPath);
        }
        return (0, _resolveUrl.resolveUrl)(url, base);
      }

      /**
       * Overrides `PropertyAccessors` to add map of dynamic functions on
       * template info, for consumption by `PropertyEffects` template binding
       * code. This map determines which method templates should have accessors
       * created for them.
       *
       * @override
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }], [{
      key: '_parseTemplateContent',
      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
        templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
        return _get(PolymerElement.__proto__ || Object.getPrototypeOf(PolymerElement), '_parseTemplateContent', this).call(this, template, templateInfo, nodeInfo);
      }
    }]);

    return PolymerElement;
  }(polymerElementBase);

  return PolymerElement;
});

var instanceCount = exports.instanceCount = 0;
var registrations = exports.registrations = [];

function _regLog(prototype) {
  console.log('[' + prototype.is + ']: registered');
}

function register(prototype) {
  registrations.push(prototype);
  undefined && _regLog(prototype);
}

function dumpRegistrations() {
  registrations.forEach(_regLog);
}

var updateStyles = exports.updateStyles = function updateStyles(props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setSanitizeDOMValue = exports.sanitizeDOMValue = exports.setRootPath = exports.rootPath = exports.Settings = exports.useNativeCustomElements = exports.useNativeCSSProperties = exports.useShadow = undefined;

__webpack_require__(2);

var _resolveUrl = __webpack_require__(25);

/**
 * Legacy settings.
 * @namespace
 * @memberof Polymer
 */
var settings = undefined || {};
var useShadow = exports.useShadow = !window.ShadyDOM;
var useNativeCSSProperties = exports.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
var useNativeCustomElements = exports.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
exports.Settings = settings;

/**
 * Globally settable property that is automatically assigned to
 * `Polymer.ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `Polymer.rootPath` to provide a stable application mount path when
 * using client side routing.
 *
 * @memberof Polymer
 */

var rootPath = undefined || (0, _resolveUrl.pathFromUrl)(document.baseURI || window.location.href);

exports.rootPath = rootPath;
var setRootPath = exports.setRootPath = function setRootPath(path) {
  exports.rootPath = rootPath = path;
};

/**
 * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
 *
 *     Polymer = {
 *       sanitizeDOMValue: function(value, name, type, node) { ... }
 *     }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 * @memberof Polymer
 */
var sanitizeDOMValue = undefined;

exports.sanitizeDOMValue = sanitizeDOMValue;
var setSanitizeDOMValue = exports.setSanitizeDOMValue = function setSanitizeDOMValue(newSanitizeDOMValue) {
  exports.sanitizeDOMValue = sanitizeDOMValue = newSanitizeDOMValue;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dashToCamelCase = dashToCamelCase;
exports.camelToDashCase = camelToDashCase;

__webpack_require__(2);

var caseMap = {};
var DASH_TO_CAMEL = /-[a-z]/g;
var CAMEL_TO_DASH = /([A-Z])/g;

function dashToCamelCase(dash) {
  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, function (m) {
    return m[1].toUpperCase();
  }));
}

function camelToDashCase(camel) {
  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertyEffects = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _path = __webpack_require__(26);

var _caseMap = __webpack_require__(35);

var caseMap = _interopRequireWildcard(_caseMap);

var _propertyAccessors = __webpack_require__(91);

var _templateStamp = __webpack_require__(92);

var _settings = __webpack_require__(34);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** @const {Object} */
var CaseMap = caseMap;

// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
var dedupeId = 0;

/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */
var TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};

/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */
var DataTrigger = void 0; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */
var DataEffect = void 0; //eslint-disable-line no-unused-vars

var PropertyEffectsType = void 0; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */
function ensureOwnEffectMap(model, type) {
  var effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    for (var p in effects) {
      var protoFx = effects[p];
      var instFx = effects[p] = Array(protoFx.length);
      for (var i = 0; i < protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }
  return effects;
}

// -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {Object} props Bag of current property changes
 * @param {Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    var ran = false;
    var id = dedupeId++;
    for (var prop in props) {
      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }
    return ran;
  }
  return false;
}

/**
 * Runs a list of effects for a given property.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  var ran = false;
  var rootProperty = hasPaths ? (0, _path.root)(prop) : prop;
  var fxs = effects[rootProperty];
  if (fxs) {
    for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}

/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    var triggerPath = trigger.name;
    return triggerPath == path || trigger.structured && (0, _path.isAncestor)(triggerPath, path) || trigger.wildcard && (0, _path.isDescendant)(triggerPath, path);
  } else {
    return true;
  }
}

/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runObserverEffect(inst, property, props, oldProps, info) {
  var fn = inst[info.methodName];
  var changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.methodName + '` not defined');
  }
}

/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  var fxs = inst[TYPES.NOTIFY];
  var notified = void 0;
  var id = dedupeId++;
  // Try normal notify effects; if none, fall back to try path notification
  for (var prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.
  var host = void 0;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}

/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */
function notifyPath(inst, path, props) {
  var rootProperty = (0, _path.root)(path);
  if (rootProperty !== path) {
    var eventName = (0, _caseMap.camelToDashCase)(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}

/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} eventName The name of the event to send ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property changed, the path
 *   that changed (optional).
 * @private
 * @suppress {invalidCasts}
 */
function dispatchNotifyEvent(inst, eventName, value, path) {
  var detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail: detail }));
}

/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  var rootProperty = hasPaths ? (0, _path.root)(property) : property;
  var path = rootProperty != property ? property : null;
  var value = path ? (0, _path.get)(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property]; // specifically for .splices
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}

/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!PropertyEffectsType} inst Host element instance handling the notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @private
 */
function handleNotification(event, inst, fromProp, toPath, negate) {
  var value = void 0;
  var detail = /** @type {Object} */event.detail;
  var fromPath = detail && detail.path;
  if (fromPath) {
    toPath = (0, _path.translate)(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.target[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}

/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runReflectEffect(inst, property, props, oldProps, info) {
  var value = inst.__data[property];
  if (_settings.sanitizeDOMValue) {
    value = (0, _settings.sanitizeDOMValue)(value, info.attrName, 'attribute', /** @type {Node} */inst);
  }
  inst._propertyToAttribute(property, info.attrName, value);
}

/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {!Object} changedProps Bag of changed properties
 * @param {!Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  var computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    var inputProps = changedProps;
    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(oldProps, inst.__dataOld);
      Object.assign(changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}

/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runComputedEffect(inst, property, props, oldProps, info) {
  var result = runMethodEffect(inst, property, props, oldProps, info);
  var computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}

/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!PropertyEffectsType} inst The instance whose props are changing
 * @param {string | !Array<(string|number)>} path Path that has changed
 * @param {*} value Value of changed path
 * @private
 */
function computeLinkedPaths(inst, path, value) {
  var links = inst.__dataLinkedPaths;
  if (links) {
    var link = void 0;
    for (var a in links) {
      var b = links[a];
      if ((0, _path.isDescendant)(a, path)) {
        link = (0, _path.translate)(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if ((0, _path.isDescendant)(b, path)) {
        link = (0, _path.translate)(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}

// -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @private
 */
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  var /** Binding */binding = { kind: kind, target: target, parts: parts, literal: literal, isCompound: parts.length !== 1 };
  nodeInfo.bindings.push(binding);
  // Add listener info to binding metadata
  if (shouldAddListener(binding)) {
    var _binding$parts$ = binding.parts[0],
        event = _binding$parts$.event,
        negate = _binding$parts$.negate;

    binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
    binding.listenerNegate = negate;
  }
  // Add "propagate" property effects to templateInfo
  var index = templateInfo.nodeInfoList.length;
  for (var i = 0; i < binding.parts.length; i++) {
    var part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}

/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 */
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      var dependencies = part.dependencies;
      var info = { index: index, binding: binding, part: part, evaluator: constructor };
      for (var j = 0; j < dependencies.length; j++) {
        var trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info: info, trigger: trigger
        });
      }
    }
  }
}

/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @private
 */
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  var node = nodeList[info.index];
  var binding = info.binding;
  var part = info.part;
  // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    var value = props[path];
    path = (0, _path.translate)(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    // Propagate value to child
    applyBindingValue(inst, node, binding, part, _value);
  }
}

/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!PropertyEffectsType} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @private
 */
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (_settings.sanitizeDOMValue) {
    value = (0, _settings.sanitizeDOMValue)(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
  } else {
    // Property binding
    var prop = binding.target;
    if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}

/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    var storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}

/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */
function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
}

/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!PropertyEffectsType} inst Instance that bas been previously bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @private
 */
function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  var nodeList = templateInfo.nodeList,
      nodeInfoList = templateInfo.nodeInfoList;

  if (nodeInfoList.length) {
    for (var i = 0; i < nodeInfoList.length; i++) {
      var info = nodeInfoList[i];
      var node = nodeList[i];
      var bindings = info.bindings;
      if (bindings) {
        for (var _i = 0; _i < bindings.length; _i++) {
          var binding = bindings[_i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}

/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @private
 */
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    var parts = binding.parts;
    // Copy literals from parts into storage for this binding
    var literals = new Array(parts.length);
    for (var j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    var target = binding.target;
    storage[target] = literals;
    // Configure properties with their literal parts
    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}

/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!PropertyEffectsType} inst Host element instance to handle notification event
 * @param {Binding} binding Binding metadata
 * @private
 */
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    var part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function (e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}

// -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @private
 */
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && ((typeof dynamicFn === 'undefined' ? 'undefined' : _typeof(dynamicFn)) !== 'object' || dynamicFn[sig.methodName]);
  var info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo: methodInfo,
    dynamicFn: dynamicFn
  };
  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
}

/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */
function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  var context = inst._methodHost || inst;
  var fn = context[info.methodName];
  if (fn) {
    var args = marshalArgs(inst.__data, info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

var emptyArray = [];

// Regular expressions used for binding
var IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
var NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
var SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
var DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
var STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
var ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
var ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
var ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
var BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
var OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
var CLOSE_BRACKET = '(?:]]|}})';
var NEGATE = '(?:(!)\\s*)?'; // Group 2
var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
var bindingRegex = new RegExp(EXPRESSION, "g");

/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */
function literalFromParts(parts) {
  var s = '';
  for (var i = 0; i < parts.length; i++) {
    var literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}

/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */
function parseMethod(expression) {
  // tries to match valid javascript property names
  var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    var methodName = m[1];
    var sig = { methodName: methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      var args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}

/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */
function parseArgs(argList, sig) {
  sig.args = argList.map(function (rawArg) {
    var arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}

/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */
function parseArg(rawArg) {
  // clean up whitespace
  var arg = rawArg.trim()
  // replace comma entity with comma
  .replace(/&comma;/g, ',')
  // repair extra escape sequences; note only commas strictly need
  // escaping, but we allow any other char to be escaped since its
  // likely users will do this
  .replace(/\\(.)/g, '\$1');
  // basic argument descriptor
  var a = {
    name: arg,
    value: '',
    literal: false
  };
  // detect literal value (must be String or Number)
  var fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch (fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  // if not literal, look for structured path
  if (!a.literal) {
    a.rootProperty = (0, _path.root)(arg);
    // detect structured path (has dots)
    a.structured = (0, _path.isPath)(arg);
    if (a.structured) {
      a.wildcard = arg.slice(-2) == '.*';
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}

/**
 * Gather the argument values for a method specified in the provided array
 * of argument metadata.
 *
 * The `path` and `value` arguments are used to fill in wildcard descriptor
 * when the method is being called as a result of a path notification.
 *
 * @param {Object} data Instance data storage object to read properties from
 * @param {!Array<!MethodArg>} args Array of argument metadata
 * @param {string} path Property/path name that triggered the method effect
 * @param {Object} props Bag of current property changes
 * @return {Array<*>} Array of argument values
 * @private
 */
function marshalArgs(data, args, path, props) {
  var values = [];
  for (var i = 0, l = args.length; i < l; i++) {
    var arg = args[i];
    var name = arg.name;
    var v = void 0;
    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = (0, _path.get)(data, name);
        // when data is not stored e.g. `splices`
        if (v === undefined) {
          v = props[name];
        }
      } else {
        v = data[name];
      }
    }
    if (arg.wildcard) {
      // Only send the actual path changed info if the change that
      // caused the observer to run matched the wildcard
      var baseChanged = name.indexOf(path + '.') === 0;
      var matches = path.indexOf(name) === 0 && !baseChanged;
      values[i] = {
        path: matches ? path : name,
        value: matches ? props[path] : v,
        base: v
      };
    } else {
      values[i] = v;
    }
  }
  return values;
}

// data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @private
 */
function _notifySplices(inst, array, path, splices) {
  var splicesPath = path + '.splices';
  inst.notifyPath(splicesPath, { indexSplices: splices });
  inst.notifyPath(path + '.length', array.length);
  // Null here to allow potentially large splice records to be GC'ed.
  inst.__data[splicesPath] = { indexSplices: null };
}

/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @private
 */
function notifySplice(inst, array, path, index, addedCount, removed) {
  _notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}

/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

var PropertyEffects = exports.PropertyEffects = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   */
  var propertyEffectsBase = (0, _templateStamp.TemplateStamp)((0, _propertyAccessors.PropertyAccessors)(superClass));

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */

  var PropertyEffects = function (_propertyEffectsBase) {
    _inherits(PropertyEffects, _propertyEffectsBase);

    function PropertyEffects() {
      _classCallCheck(this, PropertyEffects);

      /** @type {boolean} */
      var _this = _possibleConstructorReturn(this, (PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects)).call(this));

      _this.__dataClientsReady;
      /** @type {Array} */
      _this.__dataPendingClients;
      /** @type {Object} */
      _this.__dataToNotify;
      /** @type {Object} */
      _this.__dataLinkedPaths;
      /** @type {boolean} */
      _this.__dataHasPaths;
      /** @type {Object} */
      _this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */
      _this.__dataHost;
      /** @type {!Object} */
      _this.__dataTemp;
      /** @type {boolean} */
      _this.__dataClientsInitialized;
      /** @type {!Object} */
      _this.__data;
      /** @type {!Object} */
      _this.__dataPending;
      /** @type {!Object} */
      _this.__dataOld;
      /** @type {Object} */
      _this.__computeEffects;
      /** @type {Object} */
      _this.__reflectEffects;
      /** @type {Object} */
      _this.__notifyEffects;
      /** @type {Object} */
      _this.__propagateEffects;
      /** @type {Object} */
      _this.__observeEffects;
      /** @type {Object} */
      _this.__readOnly;
      /** @type {number} */
      _this.__dataCounter;
      /** @type {!TemplateInfo} */
      _this.__templateInfo;
      return _this;
    }

    _createClass(PropertyEffects, [{
      key: '_initializeProperties',
      value: function _initializeProperties() {
        _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_initializeProperties', this).call(this);
        hostStack.registerHost(this);
        this.__dataClientsReady = false;
        this.__dataPendingClients = null;
        this.__dataToNotify = null;
        this.__dataLinkedPaths = null;
        this.__dataHasPaths = false;
        // May be set on instance prior to upgrade
        this.__dataCompoundStorage = this.__dataCompoundStorage || null;
        this.__dataHost = this.__dataHost || null;
        this.__dataTemp = {};
        this.__dataClientsInitialized = false;
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to provide a
       * more efficient implementation of initializing properties from
       * the prototype on the instance.
       *
       * @override
       * @param {Object} props Properties to initialize on the prototype
       */

    }, {
      key: '_initializeProtoProperties',
      value: function _initializeProtoProperties(props) {
        this.__data = Object.create(props);
        this.__dataPending = Object.create(props);
        this.__dataOld = {};
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
       * `_setProperty`'s `shouldNotify: true`.
       *
       * @override
       * @param {Object} props Properties to initialize on the instance
       */

    }, {
      key: '_initializeInstanceProperties',
      value: function _initializeInstanceProperties(props) {
        var readOnly = this[TYPES.READ_ONLY];
        for (var prop in props) {
          if (!readOnly || !readOnly[prop]) {
            this.__dataPending = this.__dataPending || {};
            this.__dataOld = this.__dataOld || {};
            this.__data[prop] = this.__dataPending[prop] = props[prop];
          }
        }
      }

      // Prototype setup ----------------------------------------

      /**
       * Equivalent to static `addPropertyEffect` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_addPropertyEffect',
      value: function _addPropertyEffect(property, type, effect) {
        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
        // effects are accumulated into arrays per property based on type
        var effects = ensureOwnEffectMap(this, type)[property];
        if (!effects) {
          effects = this[type][property] = [];
        }
        effects.push(effect);
      }

      /**
       * Removes the given property effect.
       *
       * @param {string} property Property the effect was associated with
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object to remove
       */

    }, {
      key: '_removePropertyEffect',
      value: function _removePropertyEffect(property, type, effect) {
        var effects = ensureOwnEffectMap(this, type)[property];
        var idx = effects.indexOf(effect);
        if (idx >= 0) {
          effects.splice(idx, 1);
        }
      }

      /**
       * Returns whether the current prototype/instance has a property effect
       * of a certain type.
       *
       * @param {string} property Property name
       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasPropertyEffect',
      value: function _hasPropertyEffect(property, type) {
        var effects = this[type];
        return Boolean(effects && effects[property]);
      }

      /**
       * Returns whether the current prototype/instance has a "read only"
       * accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasReadOnlyEffect',
      value: function _hasReadOnlyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.READ_ONLY);
      }

      /**
       * Returns whether the current prototype/instance has a "notify"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasNotifyEffect',
      value: function _hasNotifyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.NOTIFY);
      }

      /**
       * Returns whether the current prototype/instance has a "reflect to attribute"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasReflectEffect',
      value: function _hasReflectEffect(property) {
        return this._hasPropertyEffect(property, TYPES.REFLECT);
      }

      /**
       * Returns whether the current prototype/instance has a "computed"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */

    }, {
      key: '_hasComputedEffect',
      value: function _hasComputedEffect(property) {
        return this._hasPropertyEffect(property, TYPES.COMPUTE);
      }

      // Runtime ----------------------------------------

      /**
       * Sets a pending property or path.  If the root property of the path in
       * question had no accessor, the path is set, otherwise it is enqueued
       * via `_setPendingProperty`.
       *
       * This function isolates relatively expensive functionality necessary
       * for the public API (`set`, `setProperties`, `notifyPath`, and property
       * change listeners via {{...}} bindings), such that it is only done
       * when paths enter the system, and not at every propagation step.  It
       * also sets a `__dataHasPaths` flag on the instance which is used to
       * fast-path slower path-matching code in the property effects host paths.
       *
       * `path` can be a path string or array of path parts as accepted by the
       * public API.
       *
       * @param {string | !Array<number|string>} path Path to set
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify Set to true if this change should
       *  cause a property notification event dispatch
       * @param {boolean=} isPathNotification If the path being set is a path
       *   notification of an already changed value, as opposed to a request
       *   to set and notify the change.  In the latter `false` case, a dirty
       *   check is performed and then the value is set to the path before
       *   enqueuing the pending property change.
       * @return {boolean} Returns true if the property/path was enqueued in
       *   the pending changes bag.
       * @protected
       */

    }, {
      key: '_setPendingPropertyOrPath',
      value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
        if (isPathNotification || (0, _path.root)(Array.isArray(path) ? path[0] : path) !== path) {
          // Dirty check changes being set to a path against the actual object,
          // since this is the entry point for paths into the system; from here
          // the only dirty checks are against the `__dataTemp` cache to prevent
          // duplicate work in the same turn only. Note, if this was a notification
          // of a change already set to a path (isPathNotification: true),
          // we always let the change through and skip the `set` since it was
          // already dirty checked at the point of entry and the underlying
          // object has already been updated
          if (!isPathNotification) {
            var old = (0, _path.get)(this, path);
            path = /** @type {string} */(0, _path.set)(this, path, value);
            // Use property-accessor's simpler dirty check
            if (!path || !_get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_shouldPropertyChange', this).call(this, path, value, old)) {
              return false;
            }
          }
          this.__dataHasPaths = true;
          if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
            computeLinkedPaths(this, path, value);
            return true;
          }
        } else {
          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
            return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
          } else {
            this[path] = value;
          }
        }
        return false;
      }

      /**
       * Applies a value to a non-Polymer element/node's property.
       *
       * The implementation makes a best-effort at binding interop:
       * Some native element properties have side-effects when
       * re-setting the same value (e.g. setting `<input>.value` resets the
       * cursor position), so we do a dirty-check before setting the value.
       * However, for better interop with non-Polymer custom elements that
       * accept objects, we explicitly re-set object changes coming from the
       * Polymer world (which may include deep object changes without the
       * top reference changing), erring on the side of providing more
       * information.
       *
       * Users may override this method to provide alternate approaches.
       *
       * @param {Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       * @protected
       */

    }, {
      key: '_setUnmanagedPropertyToNode',
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        // It is a judgment call that resetting primitives is
        // "bad" and resettings objects is also "good"; alternatively we could
        // implement a whitelist of tag & property values that should never
        // be reset (e.g. <input>.value && <select>.value)
        if (value !== node[prop] || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
          node[prop] = value;
        }
      }

      /**
       * Overrides the `PropertyAccessors` implementation to introduce special
       * dirty check logic depending on the property & value being set:
       *
       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
       * 2. Object set to simple property (e.g. 'prop': {...})
       *    Stored in `__dataTemp` and `__data`, dirty checked against
       *    `__dataTemp` by default implementation of `_shouldPropertyChange`
       * 3. Primitive value set to simple property (e.g. 'prop': 42)
       *    Stored in `__data`, dirty checked against `__data`
       *
       * The dirty-check is important to prevent cycles due to two-way
       * notification, but paths and objects are only dirty checked against any
       * previous value set during this turn via a "temporary cache" that is
       * cleared when the last `_propertiesChaged` exits. This is so:
       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
       *    due to array mutations like shift/unshift/splice; this is fine
       *    since path changes are dirty-checked at user entry points like `set`
       * b. dirty-checking for objects only lasts one turn to allow the user
       *    to mutate the object in-place and re-set it with the same identity
       *    and have all sub-properties re-propagated in a subsequent turn.
       *
       * The temp cache is not necessarily sufficient to prevent invalid array
       * paths, since a splice can happen during the same turn (with pathological
       * user code); we could introduce a "fixup" for temporarily cached array
       * paths if needed: https://github.com/Polymer/polymer/issues/4227
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify True if property should fire notification
       *   event (applies only for `notify: true` properties)
       * @return {boolean} Returns true if the property changed
       * @override
       */

    }, {
      key: '_setPendingProperty',
      value: function _setPendingProperty(property, value, shouldNotify) {
        var isPath = this.__dataHasPaths && (0, _path.isPath)(property);
        var prevProps = isPath ? this.__dataTemp : this.__data;
        if (this._shouldPropertyChange(property, value, prevProps[property])) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = this.__data[property];
          }
          // Paths are stored in temporary cache (cleared at end of turn),
          // which is used for dirty-checking, all others stored in __data
          if (isPath) {
            this.__dataTemp[property] = value;
          } else {
            this.__data[property] = value;
          }
          // All changes go into pending property bag, passed to _propertiesChanged
          this.__dataPending[property] = value;
          // Track properties that should notify separately
          if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
            this.__dataToNotify = this.__dataToNotify || {};
            this.__dataToNotify[property] = shouldNotify;
          }
          return true;
        }
        return false;
      }

      /**
       * Overrides base implementation to ensure all accessors set `shouldNotify`
       * to true, for per-property notification tracking.
       *
       * @override
       */

    }, {
      key: '_setProperty',
      value: function _setProperty(property, value) {
        if (this._setPendingProperty(property, value, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Overrides `PropertyAccessor`'s default async queuing of
       * `_propertiesChanged`: if `__dataReady` is false (has not yet been
       * manually flushed), the function no-ops; otherwise flushes
       * `_propertiesChanged` synchronously.
       *
       * @override
       */

    }, {
      key: '_invalidateProperties',
      value: function _invalidateProperties() {
        if (this.__dataReady) {
          this._flushProperties();
        }
      }

      /**
       * Enqueues the given client on a list of pending clients, whose
       * pending property changes can later be flushed via a call to
       * `_flushClients`.
       *
       * @param {Object} client PropertyEffects client to enqueue
       * @protected
       */

    }, {
      key: '_enqueueClient',
      value: function _enqueueClient(client) {
        this.__dataPendingClients = this.__dataPendingClients || [];
        if (client !== this) {
          this.__dataPendingClients.push(client);
        }
      }

      /**
       * Flushes any clients previously enqueued via `_enqueueClient`, causing
       * their `_flushProperties` method to run.
       *
       * @protected
       */

    }, {
      key: '_flushClients',
      value: function _flushClients() {
        if (!this.__dataClientsReady) {
          this.__dataClientsReady = true;
          this._readyClients();
          // Override point where accessors are turned on; importantly,
          // this is after clients have fully readied, providing a guarantee
          // that any property effects occur only after all clients are ready.
          this.__dataReady = true;
        } else {
          this.__enableOrFlushClients();
        }
      }

      // NOTE: We ensure clients either enable or flush as appropriate. This
      // handles two corner cases:
      // (1) clients flush properly when connected/enabled before the host
      // enables; e.g.
      //   (a) Templatize stamps with no properties and does not flush and
      //   (b) the instance is inserted into dom and
      //   (c) then the instance flushes.
      // (2) clients enable properly when not connected/enabled when the host
      // flushes; e.g.
      //   (a) a template is runtime stamped and not yet connected/enabled
      //   (b) a host sets a property, causing stamped dom to flush
      //   (c) the stamped dom enables.

    }, {
      key: '__enableOrFlushClients',
      value: function __enableOrFlushClients() {
        var clients = this.__dataPendingClients;
        if (clients) {
          this.__dataPendingClients = null;
          for (var i = 0; i < clients.length; i++) {
            var client = clients[i];
            if (!client.__dataEnabled) {
              client._enableProperties();
            } else if (client.__dataPending) {
              client._flushProperties();
            }
          }
        }
      }

      /**
       * Perform any initial setup on client dom. Called before the first
       * `_flushProperties` call on client dom and before any element
       * observers are called.
       *
       * @protected
       */

    }, {
      key: '_readyClients',
      value: function _readyClients() {
        this.__enableOrFlushClients();
      }

      /**
       * Sets a bag of property changes to this instance, and
       * synchronously processes all effects of the properties as a batch.
       *
       * Property names must be simple properties, not paths.  Batched
       * path propagation is not supported.
       *
       * @param {Object} props Bag of one or more key-value pairs whose key is
       *   a property and value is the new value to set for that property.
       * @param {boolean=} setReadOnly When true, any private values set in
       *   `props` will be set. By default, `setProperties` will not set
       *   `readOnly: true` root properties.
       * @public
       */

    }, {
      key: 'setProperties',
      value: function setProperties(props, setReadOnly) {
        for (var path in props) {
          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
            //TODO(kschaaf): explicitly disallow paths in setProperty?
            // wildcard observers currently only pass the first changed path
            // in the `info` object, and you could do some odd things batching
            // paths, e.g. {'foo.bar': {...}, 'foo': null}
            this._setPendingPropertyOrPath(path, props[path], true);
          }
        }
        this._invalidateProperties();
      }

      /**
       * Overrides `PropertyAccessors` so that property accessor
       * side effects are not enabled until after client dom is fully ready.
       * Also calls `_flushClients` callback to ensure client dom is enabled
       * that was not enabled as a result of flushing properties.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        // It is important that `super.ready()` is not called here as it
        // immediately turns on accessors. Instead, we wait until `readyClients`
        // to enable accessors to provide a guarantee that clients are ready
        // before processing any accessors side effects.
        this._flushProperties();
        // If no data was pending, `_flushProperties` will not `flushClients`
        // so ensure this is done.
        if (!this.__dataClientsReady) {
          this._flushClients();
        }
        // Before ready, client notifications do not trigger _flushProperties.
        // Therefore a flush is necessary here if data has been set.
        if (this.__dataPending) {
          this._flushProperties();
        }
      }

      /**
       * Implements `PropertyAccessors`'s properties changed callback.
       *
       * Runs each class of effects for the batch of changed properties in
       * a specific order (compute, propagate, reflect, observe, notify).
       *
       * @override
       */

    }, {
      key: '_propertiesChanged',
      value: function _propertiesChanged(currentProps, changedProps, oldProps) {
        // ----------------------------
        // let c = Object.getOwnPropertyNames(changedProps || {});
        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
        // if (window.debug) { debugger; }
        // ----------------------------
        var hasPaths = this.__dataHasPaths;
        this.__dataHasPaths = false;
        // Compute properties
        runComputedEffects(this, changedProps, oldProps, hasPaths);
        // Clear notify properties prior to possible reentry (propagate, observe),
        // but after computing effects have a chance to add to them
        var notifyProps = this.__dataToNotify;
        this.__dataToNotify = null;
        // Propagate properties to clients
        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
        // Flush clients
        this._flushClients();
        // Reflect properties
        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
        // Observe properties
        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
        // Notify properties to host
        if (notifyProps) {
          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
        }
        // Clear temporary cache at end of turn
        if (this.__dataCounter == 1) {
          this.__dataTemp = {};
        }
        // ----------------------------
        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
        // ----------------------------
      }

      /**
       * Called to propagate any property changes to stamped template nodes
       * managed by this element.
       *
       * @param {Object} changedProps Bag of changed properties
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @protected
       */

    }, {
      key: '_propagatePropertyChanges',
      value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
        if (this[TYPES.PROPAGATE]) {
          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
        }
        var templateInfo = this.__templateInfo;
        while (templateInfo) {
          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
          templateInfo = templateInfo.nextTemplateInfo;
        }
      }

      /**
       * Aliases one data path as another, such that path notifications from one
       * are routed to the other.
       *
       * @param {string | !Array<string|number>} to Target path to link.
       * @param {string | !Array<string|number>} from Source path to link.
       * @public
       */

    }, {
      key: 'linkPaths',
      value: function linkPaths(to, from) {
        to = (0, _path.normalize)(to);
        from = (0, _path.normalize)(from);
        this.__dataLinkedPaths = this.__dataLinkedPaths || {};
        this.__dataLinkedPaths[to] = from;
      }

      /**
       * Removes a data path alias previously established with `_linkPaths`.
       *
       * Note, the path to unlink should be the target (`to`) used when
       * linking the paths.
       *
       * @param {string | !Array<string|number>} path Target path to unlink.
       * @public
       */

    }, {
      key: 'unlinkPaths',
      value: function unlinkPaths(path) {
        path = (0, _path.normalize)(path);
        if (this.__dataLinkedPaths) {
          delete this.__dataLinkedPaths[path];
        }
      }

      /**
       * Notify that an array has changed.
       *
       * Example:
       *
       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
       *     ...
       *     this.items.splice(1, 1, {name: 'Sam'});
       *     this.items.push({name: 'Bob'});
       *     this.notifySplices('items', [
       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
       *     ]);
       *
       * @param {string} path Path that should be notified.
       * @param {Array} splices Array of splice records indicating ordered
       *   changes that occurred to the array. Each record should have the
       *   following fields:
       *    * index: index at which the change occurred
       *    * removed: array of items that were removed from this index
       *    * addedCount: number of new items added at this index
       *    * object: a reference to the array in question
       *    * type: the string literal 'splice'
       *
       *   Note that splice records _must_ be normalized such that they are
       *   reported in index order (raw results from `Object.observe` are not
       *   ordered and must be normalized/merged before notifying).
       * @public
      */

    }, {
      key: 'notifySplices',
      value: function notifySplices(path, splices) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        _notifySplices(this, array, info.path, splices);
      }

      /**
       * Convenience method for reading a value from a path.
       *
       * Note, if any part in the path is undefined, this method returns
       * `undefined` (this method does not throw when dereferencing undefined
       * paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `users.12.name` or `['users', 12, 'name']`).
       * @param {Object=} root Root object from which the path is evaluated.
       * @return {*} Value at the path, or `undefined` if any part of the path
       *   is undefined.
       * @public
       */

    }, {
      key: 'get',
      value: function get(path, root) {
        return (0, _path.get)(root || this, path);
      }

      /**
       * Convenience method for setting a value to a path and notifying any
       * elements bound to the same path.
       *
       * Note, if any part in the path except for the last is undefined,
       * this method does nothing (this method does not throw when
       * dereferencing undefined paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
       * @param {*} value Value to set at the specified path.
       * @param {Object=} root Root object from which the path is evaluated.
       *   When specified, no notification will occur.
       * @public
      */

    }, {
      key: 'set',
      value: function set(path, value, root) {
        if (root) {
          (0, _path.set)(root, path, value);
        } else {
          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
            if (this._setPendingPropertyOrPath(path, value, true)) {
              this._invalidateProperties();
            }
          }
        }
      }

      /**
       * Adds items onto the end of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to push onto array
       * @return {number} New length of the array.
       * @public
       */

    }, {
      key: 'push',
      value: function push(path) {
        var info = { path: '' };
        var array = /** @type {Array}*/(0, _path.get)(this, path, info);
        var len = array.length;

        for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          items[_key - 1] = arguments[_key];
        }

        var ret = array.push.apply(array, items);
        if (items.length) {
          notifySplice(this, array, info.path, len, items.length, []);
        }
        return ret;
      }

      /**
       * Removes an item from the end of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */

    }, {
      key: 'pop',
      value: function pop(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        var hadLength = Boolean(array.length);
        var ret = array.pop();
        if (hadLength) {
          notifySplice(this, array, info.path, array.length, 0, [ret]);
        }
        return ret;
      }

      /**
       * Starting from the start index specified, removes 0 or more items
       * from the array and inserts 0 or more new items in their place.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.splice`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {number} start Index from which to start removing/inserting.
       * @param {number} deleteCount Number of items to remove.
       * @param {...*} items Items to insert into array.
       * @return {Array} Array of removed items.
       * @public
       */

    }, {
      key: 'splice',
      value: function splice(path, start, deleteCount) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        // Normalize fancy native splice handling of crazy start values
        if (start < 0) {
          start = array.length - Math.floor(-start);
        } else {
          start = Math.floor(start);
        }
        if (!start) {
          start = 0;
        }

        for (var _len2 = arguments.length, items = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          items[_key2 - 3] = arguments[_key2];
        }

        var ret = array.splice.apply(array, [start, deleteCount].concat(items));
        if (items.length || ret.length) {
          notifySplice(this, array, info.path, start, items.length, ret);
        }
        return ret;
      }

      /**
       * Removes an item from the beginning of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */

    }, {
      key: 'shift',
      value: function shift(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);
        var hadLength = Boolean(array.length);
        var ret = array.shift();
        if (hadLength) {
          notifySplice(this, array, info.path, 0, 0, [ret]);
        }
        return ret;
      }

      /**
       * Adds items onto the beginning of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to insert info array
       * @return {number} New length of the array.
       * @public
       */

    }, {
      key: 'unshift',
      value: function unshift(path) {
        var info = { path: '' };
        var array = /** @type {Array} */(0, _path.get)(this, path, info);

        for (var _len3 = arguments.length, items = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          items[_key3 - 1] = arguments[_key3];
        }

        var ret = array.unshift.apply(array, items);
        if (items.length) {
          notifySplice(this, array, info.path, 0, items.length, []);
        }
        return ret;
      }

      /**
       * Notify that a path has changed.
       *
       * Example:
       *
       *     this.item.user.name = 'Bob';
       *     this.notifyPath('item.user.name');
       *
       * @param {string} path Path that should be notified.
       * @param {*=} value Value at the path (optional).
       * @public
      */

    }, {
      key: 'notifyPath',
      value: function notifyPath(path, value) {
        /** @type {string} */
        var propPath = void 0;
        if (arguments.length == 1) {
          // Get value if not supplied
          var info = { path: '' };
          value = (0, _path.get)(this, path, info);
          propPath = info.path;
        } else if (Array.isArray(path)) {
          // Normalize path if needed
          propPath = (0, _path.normalize)(path);
        } else {
          propPath = /** @type{string} */path;
        }
        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Equivalent to static `createReadOnlyProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */

    }, {
      key: '_createReadOnlyProperty',
      value: function _createReadOnlyProperty(property, protectedSetter) {
        this._addPropertyEffect(property, TYPES.READ_ONLY);
        if (protectedSetter) {
          this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
            this._setProperty(property, value);
          };
        }
      }

      /**
       * Equivalent to static `createPropertyObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createPropertyObserver',
      value: function _createPropertyObserver(property, methodName, dynamicFn) {
        var info = { property: property, methodName: methodName, dynamicFn: Boolean(dynamicFn) };
        this._addPropertyEffect(property, TYPES.OBSERVE, {
          fn: runObserverEffect, info: info, trigger: { name: property }
        });
        if (dynamicFn) {
          this._addPropertyEffect(methodName, TYPES.OBSERVE, {
            fn: runObserverEffect, info: info, trigger: { name: methodName }
          });
        }
      }

      /**
       * Equivalent to static `createMethodObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createMethodObserver',
      value: function _createMethodObserver(expression, dynamicFn) {
        var sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed observer expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
      }

      /**
       * Equivalent to static `createNotifyingProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: '_createNotifyingProperty',
      value: function _createNotifyingProperty(property) {
        this._addPropertyEffect(property, TYPES.NOTIFY, {
          fn: runNotifyEffect,
          info: {
            eventName: CaseMap.camelToDashCase(property) + '-changed',
            property: property
          }
        });
      }

      /**
       * Equivalent to static `createReflectedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: '_createReflectedProperty',
      value: function _createReflectedProperty(property) {
        var attr = CaseMap.camelToDashCase(property);
        if (attr[0] === '-') {
          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
        } else {
          this._addPropertyEffect(property, TYPES.REFLECT, {
            fn: runReflectEffect,
            info: {
              attrName: attr
            }
          });
        }
      }

      /**
       * Equivalent to static `createComputedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: '_createComputedProperty',
      value: function _createComputedProperty(property, expression, dynamicFn) {
        var sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed computed expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
      }

      // -- static class methods ------------

      /**
       * Ensures an accessor exists for the specified property, and adds
       * to a list of "property effects" that will run when the accessor for
       * the specified property is set.  Effects are grouped by "type", which
       * roughly corresponds to a phase in effect processing.  The effect
       * metadata should be in the following form:
       *
       *     {
       *       fn: effectFunction, // Reference to function to call to perform effect
       *       info: { ... }       // Effect metadata passed to function
       *       trigger: {          // Optional triggering metadata; if not provided
       *         name: string      // the property is treated as a wildcard
       *         structured: boolean
       *         wildcard: boolean
       *       }
       *     }
       *
       * Effects are called from `_propertiesChanged` in the following order by
       * type:
       *
       * 1. COMPUTE
       * 2. PROPAGATE
       * 3. REFLECT
       * 4. OBSERVE
       * 5. NOTIFY
       *
       * Effect functions are called with the following signature:
       *
       *     effectFunction(inst, path, props, oldProps, info, hasPaths)
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_bindTemplate',


      // -- binding ----------------------------------------------

      /**
       * Equivalent to static `bindTemplate` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * This method may be called on the prototype (for prototypical template
       * binding, to avoid creating accessors every instance) once per prototype,
       * and will be called with `runtimeBinding: true` by `_stampTemplate` to
       * create and link an instance of the template metadata associated with a
       * particular stamping.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @param {boolean=} instanceBinding When false (default), performs
       *   "prototypical" binding of the template and overwrites any previously
       *   bound template for the class. When true (as passed from
       *   `_stampTemplate`), the template info is instanced and linked into
       *   the list of bound templates.
       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
       *   this is an instance of the prototypical template info
       * @protected
       */
      value: function _bindTemplate(template, instanceBinding) {
        var templateInfo = this.constructor._parseTemplate(template);
        var wasPreBound = this.__templateInfo == templateInfo;
        // Optimization: since this is called twice for proto-bound templates,
        // don't attempt to recreate accessors if this template was pre-bound
        if (!wasPreBound) {
          for (var prop in templateInfo.propertyEffects) {
            this._createPropertyAccessor(prop);
          }
        }
        if (instanceBinding) {
          // For instance-time binding, create instance of template metadata
          // and link into list of templates if necessary
          templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
          templateInfo.wasPreBound = wasPreBound;
          if (!wasPreBound && this.__templateInfo) {
            var last = this.__templateInfoLast || this.__templateInfo;
            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
            templateInfo.previousTemplateInfo = last;
            return templateInfo;
          }
        }
        return this.__templateInfo = templateInfo;
      }

      /**
       * Adds a property effect to the given template metadata, which is run
       * at the "propagate" stage of `_propertiesChanged` when the template
       * has been bound to the element via `_bindTemplate`.
       *
       * The `effect` object should match the format in `_addPropertyEffect`.
       *
       * @param {Object} templateInfo Template metadata to add effect to
       * @param {string} prop Property that should trigger the effect
       * @param {Object=} effect Effect metadata object
       * @protected
       */

    }, {
      key: '_stampTemplate',


      /**
       * Stamps the provided template and performs instance-time setup for
       * Polymer template features, including data bindings, declarative event
       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
       * is returned containing the stamped DOM, ready for insertion into the
       * DOM.
       *
       * This method may be called more than once; however note that due to
       * `shadycss` polyfill limitations, only styles from templates prepared
       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
       * to the shadow root and support CSS custom properties), and note that
       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
       * any styles required by in runtime-stamped templates must be included
       * in the main element template.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       * @override
       * @protected
       */
      value: function _stampTemplate(template) {
        // Ensures that created dom is `_enqueueClient`'d to this element so
        // that it can be flushed on next call to `_flushProperties`
        hostStack.beginHosting(this);
        var dom = _get(PropertyEffects.prototype.__proto__ || Object.getPrototypeOf(PropertyEffects.prototype), '_stampTemplate', this).call(this, template);
        hostStack.endHosting(this);
        var templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
        // Add template-instance-specific data to instanced templateInfo
        templateInfo.nodeList = dom.nodeList;
        // Capture child nodes to allow unstamping of non-prototypical templates
        if (!templateInfo.wasPreBound) {
          var nodes = templateInfo.childNodes = [];
          for (var n = dom.firstChild; n; n = n.nextSibling) {
            nodes.push(n);
          }
        }
        dom.templateInfo = templateInfo;
        // Setup compound storage, 2-way listeners, and dataHost for bindings
        setupBindings(this, templateInfo);
        // Flush properties into template nodes if already booted
        if (this.__dataReady) {
          runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
        }
        return dom;
      }

      /**
       * Removes and unbinds the nodes previously contained in the provided
       * DocumentFragment returned from `_stampTemplate`.
       *
       * @param {!StampedTemplate} dom DocumentFragment previously returned
       *   from `_stampTemplate` associated with the nodes to be removed
       * @protected
       */

    }, {
      key: '_removeBoundDom',
      value: function _removeBoundDom(dom) {
        // Unlink template info
        var templateInfo = dom.templateInfo;
        if (templateInfo.previousTemplateInfo) {
          templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
        }
        if (templateInfo.nextTemplateInfo) {
          templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
        }
        if (this.__templateInfoLast == templateInfo) {
          this.__templateInfoLast = templateInfo.previousTemplateInfo;
        }
        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
        // Remove stamped nodes
        var nodes = templateInfo.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          node.parentNode.removeChild(node);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: 'PROPERTY_EFFECT_TYPES',
      get: function get() {
        return TYPES;
      }
    }], [{
      key: 'addPropertyEffect',
      value: function addPropertyEffect(property, type, effect) {
        this.prototype._addPropertyEffect(property, type, effect);
      }

      /**
       * Creates a single-property observer for the given property.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createPropertyObserver',
      value: function createPropertyObserver(property, methodName, dynamicFn) {
        this.prototype._createPropertyObserver(property, methodName, dynamicFn);
      }

      /**
       * Creates a multi-property "method observer" based on the provided
       * expression, which should be a string in the form of a normal Javascript
       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
       * should correspond to a property or path in the context of this
       * prototype (or instance), or may be a literal string or number.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createMethodObserver',
      value: function createMethodObserver(expression, dynamicFn) {
        this.prototype._createMethodObserver(expression, dynamicFn);
      }

      /**
       * Causes the setter for the given property to dispatch `<property>-changed`
       * events to notify of changes to the property.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: 'createNotifyingProperty',
      value: function createNotifyingProperty(property) {
        this.prototype._createNotifyingProperty(property);
      }

      /**
       * Creates a read-only accessor for the given property.
       *
       * To set the property, use the protected `_setProperty` API.
       * To create a custom protected setter (e.g. `_setMyProp()` for
       * property `myProp`), pass `true` for `protectedSetter`.
       *
       * Note, if the property will have other property effects, this method
       * should be called first, before adding other effects.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */

    }, {
      key: 'createReadOnlyProperty',
      value: function createReadOnlyProperty(property, protectedSetter) {
        this.prototype._createReadOnlyProperty(property, protectedSetter);
      }

      /**
       * Causes the setter for the given property to reflect the property value
       * to a (dash-cased) attribute of the same name.
       *
       * @param {string} property Property name
       * @protected
       */

    }, {
      key: 'createReflectedProperty',
      value: function createReflectedProperty(property) {
        this.prototype._createReflectedProperty(property);
      }

      /**
       * Creates a computed property whose value is set to the result of the
       * method described by the given `expression` each time one or more
       * arguments to the method changes.  The expression should be a string
       * in the form of a normal Javascript function signature:
       * `'methodName(arg1, [..., argn])'`
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
       *   method names should be included as a dependency to the effect.
       * @protected
       */

    }, {
      key: 'createComputedProperty',
      value: function createComputedProperty(property, expression, dynamicFn) {
        this.prototype._createComputedProperty(property, expression, dynamicFn);
      }

      /**
       * Parses the provided template to ensure binding effects are created
       * for them, and then ensures property accessors are created for any
       * dependent properties in the template.  Binding effects for bound
       * templates are stored in a linked list on the instance so that
       * templates can be efficiently stamped and unstamped.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @return {Object} Template metadata object
       * @protected
       */

    }, {
      key: 'bindTemplate',
      value: function bindTemplate(template) {
        return this.prototype._bindTemplate(template);
      }
    }, {
      key: '_addTemplatePropertyEffect',
      value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
        var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
        hostProps[prop] = true;
        var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
        var propEffects = effects[prop] = effects[prop] || [];
        propEffects.push(effect);
      }
    }, {
      key: '_parseTemplateNode',
      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNode', this).call(this, node, templateInfo, nodeInfo);
        if (node.nodeType === Node.TEXT_NODE) {
          var parts = this._parseBindings(node.textContent, templateInfo);
          if (parts) {
            // Initialize the textContent with any literal parts
            // NOTE: default to a space here so the textNode remains; some browsers
            // (IE) evacipate an empty textNode following cloneNode/importNode.
            node.textContent = literalFromParts(parts) || ' ';
            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
            noted = true;
          }
        }
        return noted;
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from attributes.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: '_parseTemplateNodeAttribute',
      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        var parts = this._parseBindings(value, templateInfo);
        if (parts) {
          // Attribute or property
          var origName = name;
          var kind = 'property';
          if (name[name.length - 1] == '$') {
            name = name.slice(0, -1);
            kind = 'attribute';
          }
          // Initialize attribute bindings with any literal parts
          var literal = literalFromParts(parts);
          if (literal && kind == 'attribute') {
            node.setAttribute(name, literal);
          }
          // Clear attribute before removing, since IE won't allow removing
          // `value` attribute if it previously had a value (can't
          // unconditionally set '' before removing since attributes with `$`
          // can't be set using setAttribute)
          if (node.localName === 'input' && origName === 'value') {
            node.setAttribute(origName, '');
          }
          // Remove annotation
          node.removeAttribute(origName);
          // Case hackery: attributes are lower-case, but bind targets
          // (properties) are case sensitive. Gambit is to map dash-case to
          // camel-case: `foo-bar` becomes `fooBar`.
          // Attribute bindings are excepted.
          if (kind === 'property') {
            name = (0, _caseMap.dashToCamelCase)(name);
          }
          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
          return true;
        } else {
          return _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNodeAttribute', this).call(this, node, templateInfo, nodeInfo, name, value);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * binding the properties that a nested template depends on to the template
       * as `_host_<property>`.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */

    }, {
      key: '_parseTemplateNestedTemplate',
      value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
        var noted = _get(PropertyEffects.__proto__ || Object.getPrototypeOf(PropertyEffects), '_parseTemplateNestedTemplate', this).call(this, node, templateInfo, nodeInfo);
        // Merge host props into outer template and add bindings
        var hostProps = nodeInfo.templateInfo.hostProps;
        var mode = '{';
        for (var source in hostProps) {
          var parts = [{ mode: mode, source: source, dependencies: [source] }];
          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
        }
        return noted;
      }

      /**
       * Called to parse text in a template (either attribute values or
       * textContent) into binding metadata.
       *
       * Any overrides of this method should return an array of binding part
       * metadata  representing one or more bindings found in the provided text
       * and any "literal" text in between.  Any non-literal parts will be passed
       * to `_evaluateBinding` when any dependencies change.  The only required
       * fields of each "part" in the returned array are as follows:
       *
       * - `dependencies` - Array containing trigger metadata for each property
       *   that should trigger the binding to update
       * - `literal` - String containing text if the part represents a literal;
       *   in this case no `dependencies` are needed
       *
       * Additional metadata for use by `_evaluateBinding` may be provided in
       * each part object as needed.
       *
       * The default implementation handles the following types of bindings
       * (one or more may be intermixed with literal strings):
       * - Property binding: `[[prop]]`
       * - Path binding: `[[object.prop]]`
       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
       * - Two-way property or path bindings (supports negation):
       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
       * - Inline computed method (supports negation):
       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
       *
       * @param {string} text Text to parse from attribute or textContent
       * @param {Object} templateInfo Current template metadata
       * @return {Array<!BindingPart>} Array of binding part metadata
       * @protected
       */

    }, {
      key: '_parseBindings',
      value: function _parseBindings(text, templateInfo) {
        var parts = [];
        var lastIndex = 0;
        var m = void 0;
        // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
        // Regex matches:
        //        Iteration 1:  Iteration 2:
        // m[1]: '{{'          '[['
        // m[2]: ''            '!'
        // m[3]: 'prop'        'compute(foo,bar)'
        while ((m = bindingRegex.exec(text)) !== null) {
          // Add literal part
          if (m.index > lastIndex) {
            parts.push({ literal: text.slice(lastIndex, m.index) });
          }
          // Add binding part
          var mode = m[1][0];
          var negate = Boolean(m[2]);
          var source = m[3].trim();
          var customEvent = false,
              notifyEvent = '',
              colon = -1;
          if (mode == '{' && (colon = source.indexOf('::')) > 0) {
            notifyEvent = source.substring(colon + 2);
            source = source.substring(0, colon);
            customEvent = true;
          }
          var signature = parseMethod(source);
          var dependencies = [];
          if (signature) {
            // Inline computed function
            var args = signature.args,
                methodName = signature.methodName;

            for (var i = 0; i < args.length; i++) {
              var arg = args[i];
              if (!arg.literal) {
                dependencies.push(arg);
              }
            }
            var dynamicFns = templateInfo.dynamicFns;
            if (dynamicFns && dynamicFns[methodName] || signature.static) {
              dependencies.push(methodName);
              signature.dynamicFn = true;
            }
          } else {
            // Property or path
            dependencies.push(source);
          }
          parts.push({
            source: source, mode: mode, negate: negate, customEvent: customEvent, signature: signature, dependencies: dependencies,
            event: notifyEvent
          });
          lastIndex = bindingRegex.lastIndex;
        }
        // Add a final literal part
        if (lastIndex && lastIndex < text.length) {
          var literal = text.substring(lastIndex);
          if (literal) {
            parts.push({
              literal: literal
            });
          }
        }
        if (parts.length) {
          return parts;
        } else {
          return null;
        }
      }

      /**
       * Called to evaluate a previously parsed binding part based on a set of
       * one or more changed dependencies.
       *
       * @param {this} inst Element that should be used as scope for
       *   binding dependencies
       * @param {BindingPart} part Binding part metadata
       * @param {string} path Property/path that triggered this effect
       * @param {Object} props Bag of current property changes
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @return {*} Value the binding part evaluated to
       * @protected
       */

    }, {
      key: '_evaluateBinding',
      value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
        var value = void 0;
        if (part.signature) {
          value = runMethodEffect(inst, path, props, oldProps, part.signature);
        } else if (path != part.source) {
          value = (0, _path.get)(inst, part.source);
        } else {
          if (hasPaths && (0, _path.isPath)(path)) {
            value = (0, _path.get)(inst, path);
          } else {
            value = inst.__data[path];
          }
        }
        if (part.negate) {
          value = !value;
        }
        return value;
      }
    }]);

    return PropertyEffects;
  }(propertyEffectsBase);

  // make a typing for closure :P


  PropertyEffectsType = PropertyEffects;

  return PropertyEffects;
});

/**
 * Helper api for enqueing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */
var hostStack = {

  stack: [],

  /**
   * @param {*} inst Instance to add to hostStack
   * @this {hostStack}
   */
  registerHost: function registerHost(inst) {
    if (this.stack.length) {
      var host = this.stack[this.stack.length - 1];
      host._enqueueClient(inst);
    }
  },


  /**
   * @param {*} inst Instance to begin hosting
   * @this {hostStack}
   */
  beginHosting: function beginHosting(inst) {
    this.stack.push(inst);
  },


  /**
   * @param {*} inst Instance to end hosting
   * @this {hostStack}
   */
  endHosting: function endHosting(inst) {
    var stackLen = this.stack.length;
    if (stackLen && this.stack[stackLen - 1] == inst) {
      this.stack.pop();
    }
  }
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
var nativeShadow = exports.nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
var nativeCssVariables = exports.nativeCssVariables = void 0;

/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */
function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    exports.nativeCssVariables = nativeCssVariables = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    exports.nativeCssVariables = nativeCssVariables = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  exports.nativeCssVariables = nativeCssVariables = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  // reset window variable to let ShadyCSS API take its place
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/



/** @unrestricted */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.stringify = stringify;
exports.removeCustomPropAssignment = removeCustomPropAssignment;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleNode = function StyleNode() {
  _classCallCheck(this, StyleNode);

  /** @type {number} */
  this['start'] = 0;
  /** @type {number} */
  this['end'] = 0;
  /** @type {StyleNode} */
  this['previous'] = null;
  /** @type {StyleNode} */
  this['parent'] = null;
  /** @type {Array<StyleNode>} */
  this['rules'] = null;
  /** @type {string} */
  this['parsedCssText'] = '';
  /** @type {string} */
  this['cssText'] = '';
  /** @type {boolean} */
  this['atRule'] = false;
  /** @type {number} */
  this['type'] = 0;
  /** @type {string} */
  this['keyframesName'] = '';
  /** @type {string} */
  this['selector'] = '';
  /** @type {string} */
  this['parsedSelector'] = '';
};

exports.StyleNode = StyleNode;

// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */

function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}

// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}

// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function lex(text) {
  var root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length;
  var n = root;
  for (var i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      var p = n;
      var previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}

// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */
function parseCss(node, text) {
  var t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    var ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax
    t = t.substring(t.lastIndexOf(';') + 1);
    var s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = s.indexOf(AT_START) === 0;
    // note, support a subset of rule types...
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  var r$ = node['rules'];
  if (r$) {
    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}

/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
    var code = arguments[1],
        repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}

/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */
function stringify(node, preserveProperties) {
  var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  // calc rule cssText
  var cssText = '';
  if (node['cssText'] || node['rules']) {
    var r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  // emit rule if there is cssText
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}

/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */
function _hasMixinRules(rules) {
  var r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
}

/** @enum {number} */
var types = exports.types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
};

var OPEN_BRACE = '{';
var CLOSE_BRACE = '}';

// helper regexp's
var RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};

var VAR_START = '--';
var MEDIA_START = '@media';
var AT_START = '@';

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

var VAR_ASSIGN = exports.VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
var MIXIN_MATCH = exports.MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
var VAR_CONSUMED = exports.VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
var ANIMATION_MATCH = exports.ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
var MEDIA_MATCH = exports.MEDIA_MATCH = /@media\s(.*)/;
var IS_VAR = exports.IS_VAR = /^--/;
var BRACKETED = exports.BRACKETED = /\{[^}]*\}/g;
var HOST_PREFIX = exports.HOST_PREFIX = '(?:^|[^.#[:])';
var HOST_SUFFIX = exports.HOST_SUFFIX = '($|[.:[\\s>+~])';

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateNativeProperties = updateNativeProperties;
exports.getComputedStyleValue = getComputedStyleValue;
exports.detectMixin = detectMixin;

var _commonRegex = __webpack_require__(39);

/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (var p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  var value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}

/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */
function detectMixin(cssText) {
  var has = _commonRegex.MIXIN_MATCH.test(cssText) || _commonRegex.VAR_ASSIGN.test(cssText);
  // reset state of the regexes
  _commonRegex.MIXIN_MATCH.lastIndex = 0;
  _commonRegex.VAR_ASSIGN.lastIndex = 0;
  return has;
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = exports.add = exports.findOriginalTarget = exports.prevent = exports._fire = exports.recognizers = exports.gestures = undefined;
exports.deepTargetFind = deepTargetFind;
exports._findOriginalTarget = _findOriginalTarget;
exports._handleNative = _handleNative;
exports._handleTouchAction = _handleTouchAction;
exports.addListener = addListener;
exports.removeListener = removeListener;
exports._add = _add;
exports._remove = _remove;
exports.register = register;
exports._findRecognizerByEvent = _findRecognizerByEvent;
exports.setTouchAction = setTouchAction;
exports.resetMouseCanceller = resetMouseCanceller;

__webpack_require__(2);

var _async = __webpack_require__(15);

var _debounce = __webpack_require__(27);

// detect native touch action support
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
// number of last N track positions to keep
var TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
var MOUSE_TIMEOUT = 2500;
var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
var MOUSE_HAS_BUTTONS = function () {
  try {
    return new MouseEvent('test', { buttons: 1 }).buttons === 1;
  } catch (e) {
    return false;
  }
}();

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
var SUPPORTS_PASSIVE = false;
(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', { get: function get() {
        SUPPORTS_PASSIVE = true;
      } });
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch (e) {}
})();

// Check for touch-only devices
var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

var GestureRecognizer = function GestureRecognizer() {}; // eslint-disable-line no-unused-vars
GestureRecognizer.prototype.reset = function () {};
/** @type {function(MouseEvent) | undefined} */
GestureRecognizer.prototype.mousedown;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mousemove;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mouseup;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchstart;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchmove;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchend;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.click;

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
var mouseCanceller = function mouseCanceller(mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  var sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  // skip synthetic mouse events
  mouseEvent[HANDLED_OBJ] = { skip: true };
  // disable "ghost clicks"
  if (mouseEvent.type === 'click') {
    var path = mouseEvent.composedPath && mouseEvent.composedPath();
    if (path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};

/**
 * @param {boolean=} setup True to add, false to remove.
 */
function setupTeardownMouseCanceller(setup) {
  var events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (var i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  var unset = function unset() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = e.composedPath()[0];
  POINTERSTATE.mouse.mouseIgnoreJob = _debounce.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, _async.timeOut.after(MOUSE_TIMEOUT), unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
  var type = ev.type;
  // exit early if the event is not a mouse event
  if (MOUSE_EVENTS.indexOf(type) === -1) {
    return false;
  }
  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
  if (type === 'mousemove') {
    // allow undefined for testing events
    var buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    // buttons is a bitmask, check that the left button bit is set (1)
    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    var button = ev.button === undefined ? 0 : ev.button;
    // ev.button is 0 in mousedown/mouseup/click for left button activation
    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    }
    // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(
    var t = _findOriginalTarget(ev);
    // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click
    if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    var bcr = /** @type {Element} */t.getBoundingClientRect();
    // use page x/y to account for scrolling
    var x = ev.pageX,
        y = ev.pageY;
    // ev is a synthetic click if the position is outside the bounding box of the target
    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
  }
  return false;
}

var POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  var ta = 'auto';
  var path = ev.composedPath && ev.composedPath();
  if (path) {
    for (var i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
  }
  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

// use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

var gestures = exports.gestures = {};
var recognizers = exports.recognizers = [];

function deepTargetFind(x, y) {
  var node = document.elementFromPoint(x, y);
  var next = node;
  // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop
  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    var oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    // on Safari, elementFromPoint may return the shadowRoot host
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}

function _findOriginalTarget(ev) {
  // shadowdom
  if (ev.composedPath) {
    return (/** @type {EventTarget} */ev.composedPath()[0]
    );
  }
  // shadydom
  return ev.target;
}

function _handleNative(ev) {
  var handled = void 0;
  var type = ev.type;
  var node = ev.currentTarget;
  var gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  var gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
      var t = ev.changedTouches[0];
      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  // used to ignore synthetic mouse events
  if (handled.skip) {
    return;
  }
  // reset recognizer state
  for (var i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  // enforce gesture recognizer order
  for (var _i = 0, _r; _i < recognizers.length; _i++) {
    _r = recognizers[_i];
    if (gs[_r.name] && !handled[_r.name]) {
      handled[_r.name] = true;
      _r[type](ev);
    }
  }
}

function _handleTouchAction(ev) {
  var t = ev.changedTouches[0];
  var type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    var ta = firstTouchAction(ev);
    var _prevent = false;
    var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) {
      // scrolling is happening
    } else if (ta === 'none') {
      _prevent = true;
    } else if (ta === 'pan-x') {
      _prevent = dy > dx;
    } else if (ta === 'pan-y') {
      _prevent = dx > dy;
    }
    if (_prevent) {
      ev.preventDefault();
    } else {
      _prevent('track');
    }
  }
}

function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}

function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}

function _add(node, evType, handler) {
  var recognizer = gestures[evType];
  var deps = recognizer.deps;
  var name = recognizer.name;
  var gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (var i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    // don't add mouse handlers on iOS because they cause gray selection overlays
    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = { _count: 0 };
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative);
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}

function _remove(node, evType, handler) {
  var recognizer = gestures[evType];
  var deps = recognizer.deps;
  var name = recognizer.name;
  var gobj = node[GESTURE_KEY];
  if (gobj) {
    for (var i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative);
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}

function register(recog) {
  recognizers.push(recog);
  for (var i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}

function _findRecognizerByEvent(evName) {
  for (var i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (var j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}

function setTouchAction(node, value) {
  if (HAS_NATIVE_TA) {
    node.style.touchAction = value;
  }
  node[TOUCH_ACTION] = value;
}

function _fire2(target, type, detail) {
  var ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  target.dispatchEvent(ev);
  // forward `preventDefault` in a clean way
  if (ev.defaultPrevented) {
    var preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}

exports._fire = _fire2;
function _prevent2(evName) {
  var recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}

exports.prevent = _prevent2;
function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}

/* eslint-disable valid-jsdoc */

register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],

  info: {
    movefn: null,
    upfn: null
  },

  /** @this {GestureRecognizer} */
  reset: function reset() {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = _findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        self._fire('up', t, e);
        untrackDocument(self.info);
      }
    };
    var upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        self._fire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this._fire('down', t, e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @param {string} type
   * @param {EventTarget} target
   * @param {Event} event
   * @param {Function} preventer
   */
  _fire: function _fire(type, target, event, preventer) {
    _fire2(target, type, {
      x: event.clientX,
      y: event.clientY,
      sourceEvent: event,
      preventer: preventer,
      prevent: function prevent(e) {
        return _prevent2(e);
      }
    });
  }
});

register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],

  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    /** @this {GestureRecognizer} */
    addMove: function addMove(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /** @this {GestureRecognizer} */
  reset: function reset() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  hasMovedEnough: function hasMovedEnough(x, y) {
    if (this.info.prevent) {
      return false;
    }
    if (this.info.started) {
      return true;
    }
    var dx = Math.abs(this.info.x - x);
    var dy = Math.abs(this.info.y - y);
    return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    var t = _findOriginalTarget(e);
    var self = this;
    var movefn = function movefn(e) {
      var x = e.clientX,
          y = e.clientY;
      if (self.hasMovedEnough(x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          _prevent2('tap');
        }
        self.info.addMove({ x: x, y: y });
        if (!hasLeftMouseButton(e)) {
          // always _fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        self._fire(t, e);
        self.info.started = true;
      }
    };
    var upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }

      // remove the temporary listeners
      untrackDocument(self.info);
    };
    // add temporary document listeners as mouse retargets
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    var ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchmove: function touchmove(e) {
    var t = _findOriginalTarget(e);
    var ct = e.changedTouches[0];
    var x = ct.clientX,
        y = ct.clientY;
    if (this.hasMovedEnough(x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        _prevent2('tap');
      }
      this.info.addMove({ x: x, y: y });
      this._fire(t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    var t = _findOriginalTarget(e);
    var ct = e.changedTouches[0];
    // only trackend if track was started and not aborted
    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({ x: ct.clientX, y: ct.clientY });
      this._fire(t, ct, e);
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {EventTarget} target
   * @param {Touch} touch
   */
  _fire: function _fire(target, touch) {
    var secondlast = this.info.moves[this.info.moves.length - 2];
    var lastmove = this.info.moves[this.info.moves.length - 1];
    var dx = lastmove.x - this.info.x;
    var dy = lastmove.y - this.info.y;
    var ddx = void 0,
        ddy = 0;
    if (secondlast) {
      ddx = lastmove.x - secondlast.x;
      ddy = lastmove.y - secondlast.y;
    }
    _fire2(target, 'track', {
      state: this.info.state,
      x: touch.clientX,
      y: touch.clientY,
      dx: dx,
      dy: dy,
      ddx: ddx,
      ddy: ddy,
      sourceEvent: touch,
      hover: function hover() {
        return deepTargetFind(touch.clientX, touch.clientY);
      }
    });
  }

});

register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /** @this {GestureRecognizer} */
  reset: function reset() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /** @this {GestureRecognizer} */
  save: function save(e) {
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function mousedown(e) {
    if (hasLeftMouseButton(e)) {
      this.save(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  click: function click(e) {
    if (hasLeftMouseButton(e)) {
      this.forward(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function touchstart(e) {
    this.save(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function touchend(e) {
    this.forward(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {Event | Touch} e
   * @param {Event=} preventer
   */
  forward: function forward(e, preventer) {
    var dx = Math.abs(e.clientX - this.info.x);
    var dy = Math.abs(e.clientY - this.info.y);
    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
    var t = _findOriginalTarget(preventer || e);
    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
    if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
      // prevent taps from being generated if an event has canceled them
      if (!this.info.prevent) {
        _fire2(t, 'tap', {
          x: e.clientX,
          y: e.clientY,
          sourceEvent: e,
          preventer: preventer
        });
      }
    }
  }
});

var findOriginalTarget = exports.findOriginalTarget = _findOriginalTarget;
var add = exports.add = addListener;
var remove = exports.remove = removeListener;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flush = exports.enqueueDebouncer = undefined;

__webpack_require__(2);

var debouncerQueue = [];

var enqueueDebouncer = exports.enqueueDebouncer = function enqueueDebouncer(debouncer) {
  debouncerQueue.push(debouncer);
};

function flushDebouncers() {
  var didFlush = Boolean(debouncerQueue.length);
  while (debouncerQueue.length) {
    try {
      debouncerQueue.shift().flush();
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }
  return didFlush;
}

var flush = exports.flush = function flush() {
  var shadyDOM = void 0,
      debouncers = void 0;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplateInstanceBase = exports.Templatize = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(2);

var _propertyEffects = __webpack_require__(36);

var _mutableData = __webpack_require__(29);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
var newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 */
function HTMLTemplateElementExtension() {
  return newInstance;
}
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 */
var DataTemplate = (0, _propertyEffects.PropertyEffects)(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 */
var MutableDataTemplate = (0, _mutableData.MutableData)(DataTemplate);

// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}

// Base class for TemplateInstance's
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 */
var base = (0, _propertyEffects.PropertyEffects)(function () {
  function _class() {
    _classCallCheck(this, _class);
  }

  return _class;
}());

/**
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @unrestricted
 */

var TemplateInstanceBase = function (_base) {
  _inherits(TemplateInstanceBase, _base);

  function TemplateInstanceBase(props) {
    _classCallCheck(this, TemplateInstanceBase);

    var _this = _possibleConstructorReturn(this, (TemplateInstanceBase.__proto__ || Object.getPrototypeOf(TemplateInstanceBase)).call(this));

    _this._configureProperties(props);
    _this.root = _this._stampTemplate(_this.__dataHost);
    // Save list of stamped children
    var children = _this.children = [];
    for (var n = _this.root.firstChild; n; n = n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = _this;
    }
    if (_this.__templatizeOwner.__hideTemplateChildren__) {
      _this._showHideChildren(true);
    }
    // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.
    var options = _this.__templatizeOptions;
    if (props && options.instanceProps || !options.instanceProps) {
      _this._enableProperties();
    }
    return _this;
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   */


  _createClass(TemplateInstanceBase, [{
    key: '_configureProperties',
    value: function _configureProperties(props) {
      var options = this.__templatizeOptions;
      if (props) {
        for (var iprop in options.instanceProps) {
          if (iprop in props) {
            this._setPendingProperty(iprop, props[iprop]);
          }
        }
      }
      for (var hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
      }
    }
    /**
     * Forwards a host property to this instance.  This method should be
     * called on instances from the `options.forwardHostProp` callback
     * to propagate changes of host properties to each instance.
     *
     * Note this method enqueues the change, which are flushed as a batch.
     *
     * @param {string} prop Property or path name
     * @param {*} value Value of the property to forward
     */

  }, {
    key: 'forwardHostProp',
    value: function forwardHostProp(prop, value) {
      if (this._setPendingPropertyOrPath(prop, value, false, true)) {
        this.__dataHost._enqueueClient(this);
      }
    }
    /**
     * @override
     */

  }, {
    key: '_addEventListenerToNode',
    value: function _addEventListenerToNode(node, eventName, handler) {
      var _this2 = this;

      if (this._methodHost && this.__templatizeOptions.parentModel) {
        // If this instance should be considered a parent model, decorate
        // events this template instance as `model`
        this._methodHost._addEventListenerToNode(node, eventName, function (e) {
          e.model = _this2;
          handler(e);
        });
      } else {
        // Otherwise delegate to the template's host (which could be)
        // another template instance
        var templateHost = this.__dataHost.__dataHost;
        if (templateHost) {
          templateHost._addEventListenerToNode(node, eventName, handler);
        }
      }
    }
    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @param {boolean} hide Set to true to hide the children;
     * set to false to show them.
     * @protected
     */

  }, {
    key: '_showHideChildren',
    value: function _showHideChildren(hide) {
      var c = this.children;
      for (var i = 0; i < c.length; i++) {
        var n = c[i];
        // Ignore non-changes
        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
          if (n.nodeType === Node.TEXT_NODE) {
            if (hide) {
              n.__polymerTextContent__ = n.textContent;
              n.textContent = '';
            } else {
              n.textContent = n.__polymerTextContent__;
            }
          } else if (n.style) {
            if (hide) {
              n.__polymerDisplay__ = n.style.display;
              n.style.display = 'none';
            } else {
              n.style.display = n.__polymerDisplay__;
            }
          }
        }
        n.__hideTemplateChildren__ = hide;
        if (n._showHideChildren) {
          n._showHideChildren(hide);
        }
      }
    }
    /**
     * Overrides default property-effects implementation to intercept
     * textContent bindings while children are "hidden" and cache in
     * private storage for later retrieval.
     *
     * @override
     */

  }, {
    key: '_setUnmanagedPropertyToNode',
    value: function _setUnmanagedPropertyToNode(node, prop, value) {
      if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
        node.__polymerTextContent__ = value;
      } else {
        _get(TemplateInstanceBase.prototype.__proto__ || Object.getPrototypeOf(TemplateInstanceBase.prototype), '_setUnmanagedPropertyToNode', this).call(this, node, prop, value);
      }
    }
    /**
     * Find the parent model of this template instance.  The parent model
     * is either another templatize instance that had option `parentModel: true`,
     * or else the host element.
     *
     * @return {Polymer_PropertyEffects} The parent model of this instance
     */

  }, {
    key: 'parentModel',
    get: function get() {
      var model = this.__parentModel;
      if (!model) {
        var options = void 0;
        model = this;
        do {
          // A template instance's `__dataHost` is a <template>
          // `model.__dataHost.__dataHost` is the template's host
          model = model.__dataHost.__dataHost;
        } while ((options = model.__templatizeOptions) && !options.parentModel);
        this.__parentModel = model;
      }
      return model;
    }
  }]);

  return TemplateInstanceBase;
}(base);

/** @type {!DataTemplate} */


TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */
TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */
TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */
TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */
TemplateInstanceBase.prototype.__hostProps;

/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 */
var MutableTemplateInstanceBase = (0, _mutableData.MutableData)(TemplateInstanceBase);

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  var templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}

/* eslint-disable valid-jsdoc */
/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function createTemplatizerClass(template, templateInfo, options) {
  // Anonymous class created by the templatize
  var base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
  /**
   * @constructor
   * @extends {base}
   */
  var klass = function (_base2) {
    _inherits(klass, _base2);

    function klass() {
      _classCallCheck(this, klass);

      return _possibleConstructorReturn(this, (klass.__proto__ || Object.getPrototypeOf(klass)).apply(this, arguments));
    }

    return klass;
  }(base);
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}

/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function addPropagateEffects(template, templateInfo, options) {
  var userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp) {
    // Provide data API and property effects on memoized template class
    var klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      var _base3 = options.mutableData ? MutableDataTemplate : DataTemplate;
      klass = templateInfo.templatizeTemplateClass = function (_base4) {
        _inherits(TemplatizedTemplate, _base4);

        function TemplatizedTemplate() {
          _classCallCheck(this, TemplatizedTemplate);

          return _possibleConstructorReturn(this, (TemplatizedTemplate.__proto__ || Object.getPrototypeOf(TemplatizedTemplate)).apply(this, arguments));
        }

        return TemplatizedTemplate;
      }(_base3);
      // Add template - >instances effects
      // and host <- template effects
      var hostProps = templateInfo.hostProps;
      for (var prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
    }
    upgradeTemplate(template, klass);
    // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time
    if (template.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(template.__data, template.__dataProto);
    }
    // Clear any pending data for performance
    template.__dataTemp = {};
    template.__dataPending = null;
    template.__dataOld = null;
    template._enableProperties();
  }
}
/* eslint-enable valid-jsdoc */

function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  var hostProps = templateInfo.hostProps || {};
  for (var iprop in options.instanceProps) {
    delete hostProps[iprop];
    var userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (var hprop in hostProps) {
      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}

/**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Polymer.Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customze property forwarding and event model decoration
 *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
 *       parentModel: true,
 *       instanceProps: {...},
 *       forwardHostProp(property, value) {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 *
 * @namespace
 * @memberof Polymer
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */

var Templatize = {

  /**
   * Returns an anonymous `Polymer.PropertyEffects` class bound to the
   * `<template>` provided.  Instancing the class will result in the
   * template being stamped into document fragment stored as the instance's
   * `root` property, after which it can be appended to the DOM.
   *
   * Templates may utilize all Polymer data-binding features as well as
   * declarative event listeners.  Event listeners and inline computing
   * functions in the template will be called on the host of the template.
   *
   * The constructor returned takes a single argument dictionary of initial
   * property values to propagate into template bindings.  Additionally
   * host properties can be forwarded in, and instance properties can be
   * notified out by providing optional callbacks in the `options` dictionary.
   *
   * Valid configuration in `options` are as follows:
   *
   * - `forwardHostProp(property, value)`: Called when a property referenced
   *   in the template changed on the template's host. As this library does
   *   not retain references to templates instanced by the user, it is the
   *   templatize owner's responsibility to forward host property changes into
   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
   *    method on the generated class should be called to forward host
   *   properties into the template to prevent unnecessary property-changed
   *   notifications. Any properties referenced in the template that are not
   *   defined in `instanceProps` will be notified up to the template's host
   *   automatically.
   * - `instanceProps`: Dictionary of property names that will be added
   *   to the instance by the templatize owner.  These properties shadow any
   *   host properties, and changes within the template to these properties
   *   will result in `notifyInstanceProp` being called.
   * - `mutableData`: When `true`, the generated class will skip strict
   *   dirty-checking for objects and arrays (always consider them to be
   *   "dirty").
   * - `notifyInstanceProp(instance, property, value)`: Called when
   *   an instance property changes.  Users may choose to call `notifyPath`
   *   on e.g. the owner to notify the change.
   * - `parentModel`: When `true`, events handled by declarative event listeners
   *   (`on-event="handler"`) will be decorated with a `model` property pointing
   *   to the template instance that stamped it.  It will also be returned
   *   from `instance.parentModel` in cases where template instance nesting
   *   causes an inner model to shadow an outer model.
   *
   * Note that the class returned from `templatize` is generated only once
   * for a given `<template>` using `options` from the first call for that
   * template, and the cached class is returned for all subsequent calls to
   * `templatize` for that template.  As such, `options` callbacks should not
   * close over owner-specific properties since only the first `options` is
   * used; rather, callbacks are called bound to the `owner`, and so context
   * needed from the callbacks (such as references to `instances` stamped)
   * should be stored on the `owner` such that they can be retrieved via `this`.
   *
   * @memberof Polymer.Templatize
   * @param {!HTMLTemplateElement} template Template to templatize
   * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
   *   any optional callbacks will be bound to this owner.
   * @param {Object=} options Options dictionary (see summary for details)
   * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
   *   provided
   * @suppress {invalidCasts}
   */
  templatize: function templatize(template, owner, options) {
    options = /** @type {!TemplatizeOptions} */options || {};
    if (template.__templatizeOwner) {
      throw new Error('A <template> can only be templatized once');
    }
    template.__templatizeOwner = owner;
    var templateInfo = owner.constructor._parseTemplate(template);
    // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding
    var baseClass = templateInfo.templatizeInstanceClass;
    if (!baseClass) {
      baseClass = createTemplatizerClass(template, templateInfo, options);
      templateInfo.templatizeInstanceClass = baseClass;
    }
    // Host property forwarding must be installed onto template instance
    addPropagateEffects(template, templateInfo, options);
    // Subclass base class and add reference for this specific template
    var klass = function (_baseClass) {
      _inherits(TemplateInstance, _baseClass);

      function TemplateInstance() {
        _classCallCheck(this, TemplateInstance);

        return _possibleConstructorReturn(this, (TemplateInstance.__proto__ || Object.getPrototypeOf(TemplateInstance)).apply(this, arguments));
      }

      return TemplateInstance;
    }(baseClass);
    klass.prototype._methodHost = findMethodHost(template);
    klass.prototype.__dataHost = template;
    klass.prototype.__templatizeOwner = owner;
    klass.prototype.__hostProps = templateInfo.hostProps;
    return (/** @type {function(new:TemplateInstanceBase)} */klass
    );
  },


  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of
   * `TemplateInstanceBase`, and should be used to manipulate data
   * associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @memberof Polymer.Templatize
   * @param {HTMLTemplateElement} template The model will be returned for
   *   elements stamped from this template
   * @param {Node} node Node for which to return a template model.
   * @return {TemplateInstanceBase} Template instance representing the
   *   binding scope for the element
   */
  modelForElement: function modelForElement(template, node) {
    var model = void 0;
    while (node) {
      // An element with a __templatizeInstance marks the top boundary
      // of a scope; walk up until we find one, and then ensure that
      // its __dataHost matches `this`, meaning this dom-repeat stamped it
      if (model = node.__templatizeInstance) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) {
          node = model.__dataHost;
        } else {
          return model;
        }
      } else {
        // Still in a template scope, keep going up until
        // a __templatizeInstance is found
        node = node.parentNode;
      }
    }
    return null;
  }
};

exports.Templatize = Templatize;
exports.TemplateInstanceBase = TemplateInstanceBase;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomRepeat = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _templatize = __webpack_require__(43);

var _debounce = __webpack_require__(27);

var _flush = __webpack_require__(42);

var _mutableData = __webpack_require__(29);

var _path = __webpack_require__(26);

var _async = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TemplateInstanceBase = _templatize.TemplateInstanceBase; // eslint-disable-line

/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {Polymer.Element}
 */
var domRepeatBase = (0, _mutableData.OptionalMutableData)(_polymerElement.Element);

/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 *   <script>
 *     Polymer({
 *       is: 'employee-list',
 *       ready: function() {
 *         this.employees = [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *         ];
 *       }
 *     });
 *   < /script>
 *
 * </dom-module>
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
 * `unshift`), and template instances will be kept in sync with the data in the
 * array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model is an instance of Polymer.Base, and should
 * be used to manipulate data on the instance, for example
 * `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer: function(item) {
 *     return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <template is="dom-repeat" items="{{employees}}"
 *           filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @extends {domRepeatBase}
 * @appliesMixin Polymer.OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */

var DomRepeat = function (_domRepeatBase) {
  _inherits(DomRepeat, _domRepeatBase);

  _createClass(DomRepeat, null, [{
    key: 'is',


    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'dom-repeat';
    }
  }, {
    key: 'template',
    get: function get() {
      return null;
    }
  }, {
    key: 'properties',
    get: function get() {

      /**
       * Fired whenever DOM is added or removed by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */
      return {

        /**
         * An array containing items determining how many instances of the template
         * to stamp and that that each template instance should bind to.
         */
        items: {
          type: Array
        },

        /**
         * The name of the variable to add to the binding scope for the array
         * element associated with a given template instance.
         */
        as: {
          type: String,
          value: 'item'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the sorted and filtered list of rendered items.
         * Note, for the index in the `this.items` array, use the value of the
         * `itemsIndexAs` property.
         */
        indexAs: {
          type: String,
          value: 'index'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the `this.items` array. Note, for the index of
         * this instance in the sorted and filtered list of rendered items,
         * use the value of the `indexAs` property.
         */
        itemsIndexAs: {
          type: String,
          value: 'itemsIndex'
        },

        /**
         * A function that should determine the sort order of the items.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.sort`.
         * Using a sort function has no effect on the underlying `items` array.
         */
        sort: {
          type: Function,
          observer: '__sortChanged'
        },

        /**
         * A function that can be used to filter items out of the view.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.filter`.
         * Using a filter function has no effect on the underlying `items` array.
         */
        filter: {
          type: Function,
          observer: '__filterChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `observe` property
         * should be set to a space-separated list of the names of item
         * sub-fields that should trigger a re-sort or re-filter when changed.
         * These should generally be fields of `item` that the sort or filter
         * function depends on.
         */
        observe: {
          type: String,
          observer: '__observeChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `delay` property
         * determines a debounce time after a change to observed item
         * properties that must pass before the filter or sort is re-run.
         * This is useful in rate-limiting shuffing of the view when
         * item changes may be frequent.
         */
        delay: Number,

        /**
         * Count of currently rendered items after `filter` (if any) has been applied.
         * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
         * set of template instances is rendered.
         *
         */
        renderedItemCount: {
          type: Number,
          notify: true,
          readOnly: true
        },

        /**
         * Defines an initial count of template instances to render after setting
         * the `items` array, before the next paint, and puts the `dom-repeat`
         * into "chunking mode".  The remaining items will be created and rendered
         * incrementally at each animation frame therof until all instances have
         * been rendered.
         */
        initialCount: {
          type: Number,
          observer: '__initializeChunking'
        },

        /**
         * When `initialCount` is used, this property defines a frame rate to
         * target by throttling the number of instances rendered each frame to
         * not exceed the budget for the target frame rate.  Setting this to a
         * higher number will allow lower latency and higher throughput for
         * things like event handlers, but will result in a longer time for the
         * remaining items to complete rendering.
         */
        targetFramerate: {
          type: Number,
          value: 20
        },

        _targetFrameTime: {
          type: Number,
          computed: '__computeFrameTime(targetFramerate)'
        }

      };
    }
  }, {
    key: 'observers',
    get: function get() {
      return ['__itemsChanged(items.*)'];
    }
  }]);

  function DomRepeat() {
    _classCallCheck(this, DomRepeat);

    var _this = _possibleConstructorReturn(this, (DomRepeat.__proto__ || Object.getPrototypeOf(DomRepeat)).call(this));

    _this.__instances = [];
    _this.__limit = Infinity;
    _this.__pool = [];
    _this.__renderDebouncer = null;
    _this.__itemsIdxToInstIdx = {};
    _this.__chunkCount = null;
    _this.__lastChunkTime = null;
    _this.__sortFn = null;
    _this.__filterFn = null;
    _this.__observePaths = null;
    _this.__ctor = null;
    _this.__isDetached = true;
    _this.template = null;
    return _this;
  }

  _createClass(DomRepeat, [{
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'disconnectedCallback', this).call(this);
      this.__isDetached = true;
      for (var i = 0; i < this.__instances.length; i++) {
        this.__detachInstance(i);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(DomRepeat.prototype.__proto__ || Object.getPrototypeOf(DomRepeat.prototype), 'connectedCallback', this).call(this);
      // only perform attachment if the element was previously detached.
      if (this.__isDetached) {
        this.__isDetached = false;
        var parent = this.parentNode;
        for (var i = 0; i < this.__instances.length; i++) {
          this.__attachInstance(i, parent);
        }
      }
    }
  }, {
    key: '__ensureTemplatized',
    value: function __ensureTemplatized() {
      var _this2 = this;

      // Templatizing (generating the instance constructor) needs to wait
      // until ready, since won't have its template content handed back to
      // it until then
      if (!this.__ctor) {
        var template = this.template = this.querySelector('template');
        if (!template) {
          // // Wait until childList changes and template should be there by then
          var observer = new MutationObserver(function () {
            if (_this2.querySelector('template')) {
              observer.disconnect();
              _this2.__render();
            } else {
              throw new Error('dom-repeat requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return false;
        }
        // Template instance props that should be excluded from forwarding
        var instanceProps = {};
        instanceProps[this.as] = true;
        instanceProps[this.indexAs] = true;
        instanceProps[this.itemsIndexAs] = true;
        this.__ctor = _templatize.Templatize.templatize(template, this, {
          mutableData: this.mutableData,
          parentModel: true,
          instanceProps: instanceProps,
          /**
           * @this {this}
           * @param {string} prop Property to set
           * @param {*} value Value to set property to
           */
          forwardHostProp: function forwardHostProp(prop, value) {
            var i$ = this.__instances;
            for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
              inst.forwardHostProp(prop, value);
            }
          },
          /**
           * @this {this}
           * @param {Object} inst Instance to notify
           * @param {string} prop Property to notify
           * @param {*} value Value to notify
           */
          notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {
            if ((0, _path.matches)(this.as, prop)) {
              var idx = inst[this.itemsIndexAs];
              if (prop == this.as) {
                this.items[idx] = value;
              }
              var path = (0, _path.translate)(this.as, 'items.' + idx, prop);
              this.notifyPath(path, value);
            }
          }
        });
      }
      return true;
    }
  }, {
    key: '__getMethodHost',
    value: function __getMethodHost() {
      // Technically this should be the owner of the outermost template.
      // In shadow dom, this is always getRootNode().host, but we can
      // approximate this via cooperation with our dataHost always setting
      // `_methodHost` as long as there were bindings (or id's) on this
      // instance causing it to get a dataHost.
      return this.__dataHost._methodHost || this.__dataHost;
    }
  }, {
    key: '__sortChanged',
    value: function __sortChanged(sort) {
      var methodHost = this.__getMethodHost();
      this.__sortFn = sort && (typeof sort == 'function' ? sort : function () {
        return methodHost[sort].apply(methodHost, arguments);
      });
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__filterChanged',
    value: function __filterChanged(filter) {
      var methodHost = this.__getMethodHost();
      this.__filterFn = filter && (typeof filter == 'function' ? filter : function () {
        return methodHost[filter].apply(methodHost, arguments);
      });
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__computeFrameTime',
    value: function __computeFrameTime(rate) {
      return Math.ceil(1000 / rate);
    }
  }, {
    key: '__initializeChunking',
    value: function __initializeChunking() {
      if (this.initialCount) {
        this.__limit = this.initialCount;
        this.__chunkCount = this.initialCount;
        this.__lastChunkTime = performance.now();
      }
    }
  }, {
    key: '__tryRenderChunk',
    value: function __tryRenderChunk() {
      // Debounced so that multiple calls through `_render` between animation
      // frames only queue one new rAF (e.g. array mutation & chunked render)
      if (this.items && this.__limit < this.items.length) {
        this.__debounceRender(this.__requestRenderChunk);
      }
    }
  }, {
    key: '__requestRenderChunk',
    value: function __requestRenderChunk() {
      var _this3 = this;

      requestAnimationFrame(function () {
        return _this3.__renderChunk();
      });
    }
  }, {
    key: '__renderChunk',
    value: function __renderChunk() {
      // Simple auto chunkSize throttling algorithm based on feedback loop:
      // measure actual time between frames and scale chunk count by ratio
      // of target/actual frame time
      var currChunkTime = performance.now();
      var ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
      this.__limit += this.__chunkCount;
      this.__lastChunkTime = currChunkTime;
      this.__debounceRender(this.__render);
    }
  }, {
    key: '__observeChanged',
    value: function __observeChanged() {
      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
    }
  }, {
    key: '__itemsChanged',
    value: function __itemsChanged(change) {
      if (this.items && !Array.isArray(this.items)) {
        console.warn('dom-repeat expected array for `items`, found', this.items);
      }
      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
      // path to that instance synchronously (retuns false for non-item paths)
      if (!this.__handleItemPath(change.path, change.value)) {
        // Otherwise, the array was reset ('items') or spliced ('items.splices'),
        // so queue a full refresh
        this.__initializeChunking();
        this.__debounceRender(this.__render);
      }
    }
  }, {
    key: '__handleObservedPaths',
    value: function __handleObservedPaths(path) {
      if (this.__observePaths) {
        path = path.substring(path.indexOf('.') + 1);
        var paths = this.__observePaths;
        for (var i = 0; i < paths.length; i++) {
          if (path.indexOf(paths[i]) === 0) {
            this.__debounceRender(this.__render, this.delay);
            return true;
          }
        }
      }
    }

    /**
     * @param {function(this:DomRepeat)} fn Function to debounce.
     * @param {number=} delay Delay in ms to debounce by.
     */

  }, {
    key: '__debounceRender',
    value: function __debounceRender(fn) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? _async.timeOut.after(delay) : _async.microTask, fn.bind(this));
      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */

  }, {
    key: 'render',
    value: function render() {
      // Queue this repeater, then flush all in order
      this.__debounceRender(this.__render);
      (0, _flush.flush)();
    }
  }, {
    key: '__render',
    value: function __render() {
      if (!this.__ensureTemplatized()) {
        // No template found yet
        return;
      }
      this.__applyFullRefresh();
      // Reset the pool
      // TODO(kschaaf): Reuse pool across turns and nested templates
      // Now that objects/arrays are re-evaluated when set, we can safely
      // reuse pooled instances across turns, however we still need to decide
      // semantics regarding how long to hold, how many to hold, etc.
      this.__pool.length = 0;
      // Set rendered item count
      this._setRenderedItemCount(this.__instances.length);
      // Notify users
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      // Check to see if we need to render more items
      this.__tryRenderChunk();
    }
  }, {
    key: '__applyFullRefresh',
    value: function __applyFullRefresh() {
      var _this4 = this;

      var items = this.items || [];
      var isntIdxToItemsIdx = new Array(items.length);
      for (var i = 0; i < items.length; i++) {
        isntIdxToItemsIdx[i] = i;
      }
      // Apply user filter
      if (this.__filterFn) {
        isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {
          return _this4.__filterFn(items[i], idx, array);
        });
      }
      // Apply user sort
      if (this.__sortFn) {
        isntIdxToItemsIdx.sort(function (a, b) {
          return _this4.__sortFn(items[a], items[b]);
        });
      }
      // items->inst map kept for item path forwarding
      var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
      var instIdx = 0;
      // Generate instances and assign items
      var limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
      for (; instIdx < limit; instIdx++) {
        var inst = this.__instances[instIdx];
        var itemIdx = isntIdxToItemsIdx[instIdx];
        var item = items[itemIdx];
        itemsIdxToInstIdx[itemIdx] = instIdx;
        if (inst && instIdx < this.__limit) {
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          this.__insertInstance(item, instIdx, itemIdx);
        }
      }
      // Remove any extra instances from previous state
      for (var _i = this.__instances.length - 1; _i >= instIdx; _i--) {
        this.__detachAndRemoveInstance(_i);
      }
    }
  }, {
    key: '__detachInstance',
    value: function __detachInstance(idx) {
      var inst = this.__instances[idx];
      for (var i = 0; i < inst.children.length; i++) {
        var el = inst.children[i];
        inst.root.appendChild(el);
      }
      return inst;
    }
  }, {
    key: '__attachInstance',
    value: function __attachInstance(idx, parent) {
      var inst = this.__instances[idx];
      parent.insertBefore(inst.root, this);
    }
  }, {
    key: '__detachAndRemoveInstance',
    value: function __detachAndRemoveInstance(idx) {
      var inst = this.__detachInstance(idx);
      if (inst) {
        this.__pool.push(inst);
      }
      this.__instances.splice(idx, 1);
    }
  }, {
    key: '__stampInstance',
    value: function __stampInstance(item, instIdx, itemIdx) {
      var model = {};
      model[this.as] = item;
      model[this.indexAs] = instIdx;
      model[this.itemsIndexAs] = itemIdx;
      return new this.__ctor(model);
    }
  }, {
    key: '__insertInstance',
    value: function __insertInstance(item, instIdx, itemIdx) {
      var inst = this.__pool.pop();
      if (inst) {
        // TODO(kschaaf): If the pool is shared across turns, hostProps
        // need to be re-set to reused instances in addition to item
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        inst = this.__stampInstance(item, instIdx, itemIdx);
      }
      var beforeRow = this.__instances[instIdx + 1];
      var beforeNode = beforeRow ? beforeRow.children[0] : this;
      this.parentNode.insertBefore(inst.root, beforeNode);
      this.__instances[instIdx] = inst;
      return inst;
    }

    // Implements extension point from Templatize mixin

  }, {
    key: '_showHideChildren',
    value: function _showHideChildren(hidden) {
      for (var i = 0; i < this.__instances.length; i++) {
        this.__instances[i]._showHideChildren(hidden);
      }
    }

    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to inst for key

  }, {
    key: '__handleItemPath',
    value: function __handleItemPath(path, value) {
      var itemsPath = path.slice(6); // 'items.'.length == 6
      var dot = itemsPath.indexOf('.');
      var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
      // If path was index into array...
      if (itemsIdx == parseInt(itemsIdx, 10)) {
        var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
        // If the path is observed, it will trigger a full refresh
        this.__handleObservedPaths(itemSubPath);
        // Note, even if a rull refresh is triggered, always do the path
        // notification because unless mutableData is used for dom-repeat
        // and all elements in the instance subtree, a full refresh may
        // not trigger the proper update.
        var instIdx = this.__itemsIdxToInstIdx[itemsIdx];
        var inst = this.__instances[instIdx];
        if (inst) {
          var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
          // This is effectively `notifyPath`, but avoids some of the overhead
          // of the public API
          inst._setPendingPropertyOrPath(itemPath, value, false, true);
          inst._flushProperties();
        }
        return true;
      }
    }

    /**
     * Returns the item associated with a given element stamped by
     * this `dom-repeat`.
     *
     * Note, to modify sub-properties of the item,
     * `modelForElement(el).set('item.<sub-prop>', value)`
     * should be used.
     *
     * @param {HTMLElement} el Element for which to return the item.
     * @return {*} Item associated with the element.
     */

  }, {
    key: 'itemForElement',
    value: function itemForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.as];
    }

    /**
     * Returns the inst index for a given element stamped by this `dom-repeat`.
     * If `sort` is provided, the index will reflect the sorted order (rather
     * than the original array order).
     *
     * @param {HTMLElement} el Element for which to return the index.
     * @return {*} Row index associated with the element (note this may
     *   not correspond to the array index if a user `sort` is applied).
     */

  }, {
    key: 'indexForElement',
    value: function indexForElement(el) {
      var instance = this.modelForElement(el);
      return instance && instance[this.indexAs];
    }

    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of `Polymer.Base`, and
     * should be used to manipulate data associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     */

  }, {
    key: 'modelForElement',
    value: function modelForElement(el) {
      return _templatize.Templatize.modelForElement(this.template, el);
    }
  }]);

  return DomRepeat;
}(domRepeatBase);

customElements.define(DomRepeat.is, DomRepeat);

exports.DomRepeat = DomRepeat;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperRippleBehavior = undefined;

__webpack_require__(7);

__webpack_require__(115);

var _ironButtonState = __webpack_require__(70);

var _polymerDom = __webpack_require__(17);

var PaperRippleBehavior = exports.PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function _downHandler(event) {
    _ironButtonState.IronButtonStateImpl._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function ensureRipple(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        (0, _polymerDom.dom)(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = (0, _polymerDom.dom)(this._rippleContainer || this);
        var target = (0, _polymerDom.dom)(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */target)) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function getRipple() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function hasRipple() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function _createRipple() {
    return (/** @type {!PaperRippleElement} */document.createElement('paper-ripple')
    );
  },

  _noinkChanged: function _noinkChanged(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.layerGroup = exports.LayerGroup = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = exports.LayerGroup = _Layer.Layer.extend({

	initialize: function initialize(layers, options) {
		Util.setOptions(this, options);

		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function addLayer(layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function removeLayer(layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function hasLayer(layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function clearLayers() {
		return this.eachLayer(this.removeLayer, this);
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function invoke(methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i,
		    layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function onAdd(map) {
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function onRemove(map) {
		this.eachLayer(map.removeLayer, map);
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function eachLayer(method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function getLayer(id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function getLayers() {
		var layers = [];
		this.eachLayer(layers.push, layers);
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function setZIndex(zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function getLayerId(layer) {
		return Util.stamp(layer);
	}
});

// @factory L.layerGroup(layers?: Layer[], options?: Object)
// Create a layer group, optionally given an initial set of layers and an `options` object.
var layerGroup = exports.layerGroup = function layerGroup(layers, options) {
	return new LayerGroup(layers, options);
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CRS = undefined;

var _Bounds = __webpack_require__(5);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 *
 * Note that the CRS instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.
 */

var CRS = exports.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function latLngToPoint(latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function pointToLatLng(point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function project(latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function unproject(point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function scale(zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function zoom(scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function getProjectedBounds(zoom) {
		if (this.infinite) {
			return null;
		}

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return new _Bounds.Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function wrapLatLng(latlng) {
		var lng = this.wrapLng ? Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return new _LatLng.LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function wrapLatLngBounds(bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = new _LatLng.LatLng(sw.lat - latShift, sw.lng - lngShift),
		    newNe = new _LatLng.LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new _LatLngBounds.LatLngBounds(newSw, newNe);
	}
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Marker = undefined;
exports.marker = marker;

var _Layer = __webpack_require__(12);

var _Icon = __webpack_require__(78);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Marker = __webpack_require__(117);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = exports.Marker = _Layer.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new _Icon.IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option autoPan: Boolean = false
		// Set it to `true` if you want the map to do panning animation when marker hits the edges.
		autoPan: false,

		// @option autoPanPadding: Point = Point(50, 50)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [50, 50],

		// @option autoPanSpeed: Number = 10
		// Number of pixels the map should move by.
		autoPanSpeed: 10,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false
	},

	/* @section
  *
  * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
  */

	initialize: function initialize(latlng, options) {
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);
	},

	onAdd: function onAdd(map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function onRemove(map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function getEvents() {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function setLatLng(latlng) {
		var oldLatLng = this._latlng;
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', { oldLatLng: oldLatLng, latlng: this._latlng });
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function setZIndexOffset(offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function setIcon(icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function getElement() {
		return this._icon;
	},

	update: function update() {

		if (this._icon && this._map) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function _initIcon() {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (icon.tagName === 'IMG') {
				icon.alt = options.alt || '';
			}
		}

		DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			DomUtil.addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;

		if (options.opacity < 1) {
			this._updateOpacity();
		}

		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function _removeIcon() {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function _removeShadow() {
		if (this._shadow) {
			DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function _setPos(pos) {
		DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function _updateZIndex(offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function _animateZoom(opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function _initInteraction() {

		if (!this.options.interactive) {
			return;
		}

		DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (_Marker.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new _Marker.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function _updateOpacity() {
		var opacity = this.options.opacity;

		DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function _bringToFront() {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function _resetZIndex() {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function _getPopupAnchor() {
		return this.options.icon.options.popupAnchor;
	},

	_getTooltipAnchor: function _getTooltipAnchor() {
		return this.options.icon.options.tooltipAnchor;
	}
});

// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Draggable = undefined;

var _Events = __webpack_require__(19);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Point = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};

var Draggable = exports.Draggable = _Events.Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function initialize(element, dragStartTarget, preventOutline, options) {
		Util.setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function enable() {
		if (this._enabled) {
			return;
		}

		DomEvent.on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function disable() {
		if (!this._enabled) {
			return;
		}

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		DomEvent.off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function _onDown(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}

		this._moved = false;

		if (DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) {
			return;
		}

		if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
			return;
		}
		Draggable._dragging = this; // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			DomUtil.preventOutline(this._element);
		}

		DomUtil.disableImageDrag();
		DomUtil.disableTextSelection();

		if (this._moving) {
			return;
		}

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new _Point.Point(first.clientX, first.clientY);

		DomEvent.on(document, MOVE[e.type], this._onMove, this);
		DomEvent.on(document, END[e.type], this._onUp, this);
	},

	_onMove: function _onMove(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
		    newPoint = new _Point.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) {
			return;
		}
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
			return;
		}

		DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = DomUtil.getPosition(this._element).subtract(offset);

			DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function _updatePosition() {
		var e = { originalEvent: this._lastEvent };

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function _onUp(e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) {
			return;
		}
		this.finishDrag();
	},

	finishDrag: function finishDrag() {
		DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			DomEvent.off(document, MOVE[i], this._onMove, this);
			DomEvent.off(document, END[i], this._onUp, this);
		}

		DomUtil.enableImageDrag();
		DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.imageOverlay = exports.ImageOverlay = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(5);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = exports.ImageOverlay = _Layer.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the tile layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: ''
	},

	initialize: function initialize(url, bounds, options) {
		// (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		Util.setOptions(this, options);
	},

	onAdd: function onAdd() {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function onRemove() {
		DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function setStyle(styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function setUrl(url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function setBounds(bounds) {
		this._bounds = (0, _LatLngBounds.toLatLngBounds)(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function getEvents() {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method: setZIndex(value: Number) : this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function setZIndex(value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function getBounds() {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function getElement() {
		return this._image;
	},

	_initImage: function _initImage() {
		var wasElementSupplied = this._url.tagName === 'IMG';
		var img = this._image = wasElementSupplied ? this._url : DomUtil.create('img');

		DomUtil.addClass(img, 'leaflet-image-layer');
		if (this._zoomAnimated) {
			DomUtil.addClass(img, 'leaflet-zoom-animated');
		}
		if (this.options.className) {
			DomUtil.addClass(img, this.options.className);
		}

		img.onselectstart = Util.falseFn;
		img.onmousemove = Util.falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = Util.bind(this.fire, this, 'load');
		img.onerror = Util.bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		if (wasElementSupplied) {
			this._url = img.src;
			return;
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function _animateZoom(e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function _reset() {
		var image = this._image,
		    bounds = new _Bounds.Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		DomUtil.setPosition(image, bounds.min);

		image.style.width = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function _updateOpacity() {
		DomUtil.setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function _updateZIndex() {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function _overlayOnError() {
		// @event error: Event
		// Fired when the ImageOverlay layer has loaded its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = exports.imageOverlay = function imageOverlay(url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DivOverlay = undefined;

var _Layer = __webpack_require__(12);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _Point = __webpack_require__(3);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = exports.DivOverlay = _Layer.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function initialize(options, source) {
		Util.setOptions(this, options);

		this._source = source;
	},

	onAdd: function onAdd(map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function onRemove(map) {
		if (map._fadeAnimated) {
			DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(Util.bind(DomUtil.remove, undefined, this._container), 200);
		} else {
			DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function getLatLng() {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function setLatLng(latlng) {
		this._latlng = (0, _LatLng.toLatLng)(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function getContent() {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function setContent(content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function getElement() {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function update() {
		if (!this._map) {
			return;
		}

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function getEvents() {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function isOpen() {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function _updateContent() {
		if (!this._content) {
			return;
		}

		var node = this._contentNode;
		var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function _updatePosition() {
		if (!this._map) {
			return;
		}

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = (0, _Point.toPoint)(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function _getAnchor() {
		return [0, 0];
	}

});

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TileLayer = undefined;
exports.tileLayer = tileLayer;

var _GridLayer = __webpack_require__(83);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */

var TileLayer = exports.TileLayer = _GridLayer.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function initialize(url, options) {

		this._url = url;

		options = Util.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function setUrl(url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function createTile(coords, done) {
		var tile = document.createElement('img');

		DomEvent.on(tile, 'load', Util.bind(this._tileOnLoad, this, done, tile));
		DomEvent.on(tile, 'error', Util.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
   Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
   http://www.w3.org/TR/WCAG20-TECHS/H67
  */
		tile.alt = '';

		/*
   Set role="presentation" to force screen readers to ignore this
   https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
  */
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function getTileUrl(coords) {
		var data = {
			r: Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return Util.template(this._url, Util.extend(data, this.options));
	},

	_tileOnLoad: function _tileOnLoad(done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (Browser.ielt9) {
			setTimeout(Util.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function _tileOnError(done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function _onTileRemove(e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function _getZoomForUrl() {
		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom,
		    zoomReverse = this.options.zoomReverse,
		    zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function _getSubdomain(tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function _abortLoading() {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = Util.falseFn;
				tile.onerror = Util.falseFn;

				if (!tile.complete) {
					tile.src = Util.emptyImageUrl;
					DomUtil.remove(tile);
					delete this._tiles[i];
				}
			}
		}
	}
});

// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TileLayerWMS = undefined;
exports.tileLayerWMS = tileLayerWMS;

var _TileLayer = __webpack_require__(52);

var _Util = __webpack_require__(0);

var _Browser = __webpack_require__(4);

var _CRS = __webpack_require__(54);

var _Bounds = __webpack_require__(5);

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = exports.TileLayerWMS = _TileLayer.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function initialize(url, options) {

		this._url = url;

		var wmsParams = (0, _Util.extend)({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = (0, _Util.setOptions)(this, options);

		var realRetina = options.detectRetina && _Browser.retina ? 2 : 1;
		var tileSize = this.getTileSize();
		wmsParams.width = tileSize.x * realRetina;
		wmsParams.height = tileSize.y * realRetina;

		this.wmsParams = wmsParams;
	},

	onAdd: function onAdd(map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		_TileLayer.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function getTileUrl(coords) {

		var tileBounds = this._tileCoordsToNwSe(coords),
		    crs = this._crs,
		    bounds = (0, _Bounds.toBounds)(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
		    min = bounds.min,
		    max = bounds.max,
		    bbox = (this._wmsVersion >= 1.3 && this._crs === _CRS.EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),
		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);
		return url + (0, _Util.getParamString)(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function setParams(params, noRedraw) {

		(0, _Util.extend)(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
	return new TileLayerWMS(url, options);
}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EPSG4326 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(55);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = exports.EPSG4326 = Util.extend({}, _CRS.Earth, {
  code: 'EPSG:4326',
  projection: _Projection.LonLat,
  transformation: (0, _Transformation.toTransformation)(1 / 180, 1, -1 / 180, 0.5)
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LonLat = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(5);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = exports.LonLat = {
  project: function project(latlng) {
    return new _Point.Point(latlng.lng, latlng.lat);
  },

  unproject: function unproject(point) {
    return new _LatLng.LatLng(point.y, point.x);
  },

  bounds: new _Bounds.Bounds([-180, -90], [180, 90])
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Polyline = undefined;
exports.polyline = polyline;

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(5);

var _Point = __webpack_require__(3);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */

var Polyline = exports.Polyline = _Path.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function initialize(latlngs, options) {
		Util.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function getLatLngs() {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function setLatLngs(latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function isEmpty() {
		return !this._latlngs.length;
	},

	// @method closestLayerPoint: Point
	// Returns the point closest to `p` on the Polyline.
	closestLayerPoint: function closestLayerPoint(p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = LineUtil._sqClosestPointOnSegment,
		    p1,
		    p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function getCenter() {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i,
		    halfDist,
		    segDist,
		    dist,
		    p1,
		    p2,
		    ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) {
			return null;
		}

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function getBounds() {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function addLatLng(latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = (0, _LatLng.toLatLng)(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function _setLatLngs(latlngs) {
		this._bounds = new _LatLngBounds.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function _defaultShape() {
		return LineUtil.isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function _convertLatLngs(latlngs) {
		var result = [],
		    flat = LineUtil.isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = (0, _LatLng.toLatLng)(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function _project() {
		var pxBounds = new _Bounds.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new _Point.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof _LatLng.LatLng,
		    len = latlngs.length,
		    i,
		    ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function _clipPoints() {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i,
		    j,
		    k,
		    len,
		    len2,
		    segment,
		    points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) {
					continue;
				}

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if (segment[1] !== points[j + 1] || j === len2 - 2) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function _simplifyPoints() {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function _update() {
		if (!this._map) {
			return;
		}

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function _updatePath() {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p, closed) {
		var i,
		    j,
		    k,
		    len,
		    len2,
		    part,
		    w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) {
			return false;
		}

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && j === 0) {
					continue;
				}

				if (LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = LineUtil._flat;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Polygon = undefined;
exports.polygon = polygon;

var _Polyline = __webpack_require__(56);

var _LatLng = __webpack_require__(9);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(5);

var _PolyUtil = __webpack_require__(86);

var PolyUtil = _interopRequireWildcard(_PolyUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = exports.Polygon = _Polyline.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function isEmpty() {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function getCenter() {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i,
		    j,
		    p1,
		    p2,
		    f,
		    area,
		    x,
		    y,
		    center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) {
			return null;
		}

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function _convertLatLngs(latlngs) {
		var result = _Polyline.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof _LatLng.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function _setLatLngs(latlngs) {
		_Polyline.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (LineUtil.isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function _defaultShape() {
		return LineUtil.isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function _clipPoints() {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new _Point.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new _Bounds.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function _updatePath() {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function _containsPoint(p) {
		var inside = false,
		    part,
		    p1,
		    p2,
		    i,
		    j,
		    k,
		    len,
		    len2;

		if (!this._pxBounds.contains(p)) {
			return false;
		}

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || _Polyline.Polyline.prototype._containsPoint.call(this, p, true);
	}

});

// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssFromModules = cssFromModules;
exports.cssFromModule = cssFromModule;
exports.cssFromTemplate = cssFromTemplate;
exports.cssFromModuleImports = cssFromModuleImports;
exports._cssFromModuleImports = _cssFromModuleImports;

var _resolveUrl = __webpack_require__(25);

var MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
var INCLUDE_ATTR = 'include';

function importModule(moduleId) {
  var /** Polymer.DomModule */PolymerDomModule = customElements.get('dom-module');
  if (!PolymerDomModule) {
    return null;
  }
  return PolymerDomModule.import(moduleId);
}

/** @typedef {{assetpath: string}} */
var templateWithAssetPath = void 0; // eslint-disable-line no-unused-vars

function cssFromModules(moduleIds) {
  var modules = moduleIds.trim().split(/\s+/);
  var cssText = '';
  for (var i = 0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }
  return cssText;
}

function cssFromModule(moduleId) {
  var m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    var cssText = _cssFromModuleImports(m);
    // include css from the first template in the module
    var t = m.querySelector('template');
    if (t) {
      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */m.assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}

function cssFromTemplate(template, baseURI) {
  var cssText = '';
  // if element is a template, get content from its .content
  var e$ = template.content.querySelectorAll('style');
  for (var i = 0; i < e$.length; i++) {
    var e = e$[i];
    // support style sharing by allowing styles to "include"
    // other dom-modules that contain styling
    var include = e.getAttribute(INCLUDE_ATTR);
    if (include) {
      cssText += cssFromModules(include);
    }
    e.parentNode.removeChild(e);
    cssText += baseURI ? (0, _resolveUrl.resolveCss)(e.textContent, baseURI) : e.textContent;
  }
  return cssText;
}

function cssFromModuleImports(moduleId) {
  var m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}

function _cssFromModuleImports(module) {
  var cssText = '';
  var p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (var i = 0; i < p$.length; i++) {
    var p = p$[i];
    if (p.import) {
      var importDoc = p.import;
      // NOTE: polyfill affordance.
      // under the HTMLImports polyfill, there will be no 'body',
      // but the import pseudo-doc can be used directly.
      var container = importDoc.body ? importDoc.body : importDoc;
      cssText += (0, _resolveUrl.resolveCss)(container.textContent, importDoc.baseURI);
    }
  }
  return cssText;
}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomModule = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _resolveUrl = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var modules = {};
var lcModules = {};
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}

/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */

var DomModule = function (_HTMLElement) {
  _inherits(DomModule, _HTMLElement);

  function DomModule() {
    _classCallCheck(this, DomModule);

    return _possibleConstructorReturn(this, (DomModule.__proto__ || Object.getPrototypeOf(DomModule)).apply(this, arguments));
  }

  _createClass(DomModule, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this.register();
      }
    }

    /**
     * The absolute URL of the original location of this `dom-module`.
     *
     * This value will differ from this element's `ownerDocument` in the
     * following ways:
     * - Takes into account any `assetpath` attribute added during bundling
     *   to indicate the original location relative to the bundled location
     * - Uses the HTMLImports polyfill's `importForElement` API to ensure
     *   the path is relative to the import document's location since
     *   `ownerDocument` is not currently polyfilled
     */

  }, {
    key: 'register',


    /**
     * Registers the dom-module at a given id. This method should only be called
     * when a dom-module is imperatively created. For
     * example, `document.createElement('dom-module').register('foo')`.
     * @param {string=} id The id at which to register the dom-module.
     */
    value: function register(id) {
      id = id || this.id;
      if (id) {
        this.id = id;
        // store id separate from lowercased id so that
        // in all cases mixedCase id will stored distinctly
        // and lowercase version is a fallback
        modules[id] = this;
        lcModules[id.toLowerCase()] = this;
        styleOutsideTemplateCheck(this);
      }
    }
  }, {
    key: 'assetpath',
    get: function get() {
      // Don't override existing assetpath.
      if (!this.__assetpath) {
        // note: assetpath set via an attribute must be relative to this
        // element's location; accomodate polyfilled HTMLImports
        var owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
        var url = (0, _resolveUrl.resolveUrl)(this.getAttribute('assetpath') || '', owner.baseURI);
        this.__assetpath = (0, _resolveUrl.pathFromUrl)(url);
      }
      return this.__assetpath;
    }
  }], [{
    key: 'import',


    /**
     * Retrieves the element specified by the css `selector` in the module
     * registered by `id`. For example, this.import('foo', 'img');
     * @param {string} id The id of the dom-module in which to search.
     * @param {string=} selector The css selector by which to find the element.
     * @return {Element} Returns the element which matches `selector` in the
     * module registered at the specified `id`.
     */
    value: function _import(id, selector) {
      if (id) {
        var m = findModule(id);
        if (m && selector) {
          return m.querySelector(selector);
        }
        return m;
      }
      return null;
    }
  }, {
    key: 'observedAttributes',
    get: function get() {
      return ['id'];
    }
  }]);

  return DomModule;
}(HTMLElement);

DomModule.prototype['modules'] = modules;

customElements.define('dom-module', DomModule);

exports.DomModule = DomModule;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LegacyElementMixin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(94);

var _elementMixin = __webpack_require__(33);

var _gestureEventListeners = __webpack_require__(65);

var _mixin = __webpack_require__(13);

var _importHref = __webpack_require__(97);

__webpack_require__(66);

__webpack_require__(98);

var _polymerDom = __webpack_require__(17);

var _gestures = __webpack_require__(41);

var _debounce = __webpack_require__(27);

var _async = __webpack_require__(15);

var _path = __webpack_require__(26);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var styleInterface = window.ShadyCSS;

var LegacyElementMixin = exports.LegacyElementMixin = (0, _mixin.dedupingMixin)(function (base) {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   */
  var legacyElementBase = (0, _gestureEventListeners.GestureEventListeners)((0, _elementMixin.ElementMixin)(base));

  /**
   * Map of simple names to touch action names
   * @dict
   */
  var DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };

  /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */

  var LegacyElement = function (_legacyElementBase) {
    _inherits(LegacyElement, _legacyElementBase);

    function LegacyElement() {
      _classCallCheck(this, LegacyElement);

      var _this = _possibleConstructorReturn(this, (LegacyElement.__proto__ || Object.getPrototypeOf(LegacyElement)).call(this));

      _this.root = _this;
      /** @type {boolean} */
      _this.isAttached;
      /** @type {WeakMap<!Element, !Object<string, !Function>>} */
      _this.__boundListeners;
      /** @type {Object<string, Function>} */
      _this._debouncers;
      _this.created();
      return _this;
    }

    /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     */


    _createClass(LegacyElement, [{
      key: 'created',
      value: function created() {}

      /**
       * Provides an implementation of `connectedCallback`
       * which adds Polymer legacy API's `attached` method.
       * @override
       */

    }, {
      key: 'connectedCallback',
      value: function connectedCallback() {
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'connectedCallback', this).call(this);
        this.isAttached = true;
        this.attached();
      }

      /**
       * Legacy callback called during `connectedCallback`, for overriding
       * by the user.
       */

    }, {
      key: 'attached',
      value: function attached() {}

      /**
       * Provides an implementation of `disconnectedCallback`
       * which adds Polymer legacy API's `detached` method.
       * @override
       */

    }, {
      key: 'disconnectedCallback',
      value: function disconnectedCallback() {
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'disconnectedCallback', this).call(this);
        this.isAttached = false;
        this.detached();
      }

      /**
       * Legacy callback called during `disconnectedCallback`, for overriding
       * by the user.
       */

    }, {
      key: 'detached',
      value: function detached() {}

      /**
       * Provides an override implementation of `attributeChangedCallback`
       * which adds the Polymer legacy API's `attributeChanged` method.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @override
       */

    }, {
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'attributeChangedCallback', this).call(this, name, old, value);
          this.attributeChanged(name, old, value);
        }
      }

      /**
       * Legacy callback called during `attributeChangedChallback`, for overriding
       * by the user.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       */

    }, {
      key: 'attributeChanged',
      value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for class initialization via the `_registered` callback.
       * This is called only when the first instance of the element is created.
       *
       * @override
       */

    }, {
      key: '_initializeProperties',
      value: function _initializeProperties() {
        var proto = Object.getPrototypeOf(this);
        if (!proto.hasOwnProperty('__hasRegisterFinished')) {
          proto.__hasRegisterFinished = true;
          this._registered();
        }
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), '_initializeProperties', this).call(this);
      }

      /**
       * Called automatically when an element is initializing.
       * Users may override this method to perform class registration time
       * work. The implementation should ensure the work is performed
       * only once for the class.
       * @protected
       */

    }, {
      key: '_registered',
      value: function _registered() {}

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for installing `hostAttributes` and `listeners`.
       *
       * @override
       */

    }, {
      key: 'ready',
      value: function ready() {
        this._ensureAttributes();
        this._applyListeners();
        _get(LegacyElement.prototype.__proto__ || Object.getPrototypeOf(LegacyElement.prototype), 'ready', this).call(this);
      }

      /**
       * Ensures an element has required attributes. Called when the element
       * is being readied via `ready`. Users should override to set the
       * element's required attributes. The implementation should be sure
       * to check and not override existing attributes added by
       * the user of the element. Typically, setting attributes should be left
       * to the element user and not done here; reasonable exceptions include
       * setting aria roles and focusability.
       * @protected
       */

    }, {
      key: '_ensureAttributes',
      value: function _ensureAttributes() {}

      /**
       * Adds element event listeners. Called when the element
       * is being readied via `ready`. Users should override to
       * add any required element event listeners.
       * In performance critical elements, the work done here should be kept
       * to a minimum since it is done before the element is rendered. In
       * these elements, consider adding listeners asychronously so as not to
       * block render.
       * @protected
       */

    }, {
      key: '_applyListeners',
      value: function _applyListeners() {}

      /**
       * Converts a typed JavaScript value to a string.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features. To customize
       * how properties are serialized to attributes for attribute bindings and
       * `reflectToAttribute: true` properties as well as this method, override
       * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
       *
       * @param {*} value Value to deserialize
       * @return {string | undefined} Serialized value
       */

    }, {
      key: 'serialize',
      value: function serialize(value) {
        return this._serializeValue(value);
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.  To customize
       * how attributes are deserialized to properties for in
       * `attributeChangedCallback`, override `_deserializeValue` method
       * provided by `Polymer.PropertyAccessors`.
       *
       * @param {string} value String to deserialize
       * @param {*} type Type to deserialize the string to
       * @return {*} Returns the deserialized value in the `type` given.
       */

    }, {
      key: 'deserialize',
      value: function deserialize(value, type) {
        return this._deserializeValue(value, type);
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */

    }, {
      key: 'reflectPropertyToAttribute',
      value: function reflectPropertyToAttribute(property, attribute, value) {
        this._propertyToAttribute(property, attribute, value);
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @param {Element} node Element to set attribute to.
       */

    }, {
      key: 'serializeValueToAttribute',
      value: function serializeValueToAttribute(value, attribute, node) {
        this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
      }

      /**
       * Copies own properties (including accessor descriptors) from a source
       * object to a target object.
       *
       * @param {Object} prototype Target object to copy properties to.
       * @param {Object} api Source object to copy properties from.
       * @return {Object} prototype object that was passed as first argument.
       */

    }, {
      key: 'extend',
      value: function extend(prototype, api) {
        if (!(prototype && api)) {
          return prototype || api;
        }
        var n$ = Object.getOwnPropertyNames(api);
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
          var pd = Object.getOwnPropertyDescriptor(api, n);
          if (pd) {
            Object.defineProperty(prototype, n, pd);
          }
        }
        return prototype;
      }

      /**
       * Copies props from a source object to a target object.
       *
       * Note, this method uses a simple `for...in` strategy for enumerating
       * properties.  To ensure only `ownProperties` are copied from source
       * to target and that accessor implementations are copied, use `extend`.
       *
       * @param {Object} target Target object to copy properties to.
       * @param {Object} source Source object to copy properties from.
       * @return {Object} Target object that was passed as first argument.
       */

    }, {
      key: 'mixin',
      value: function mixin(target, source) {
        for (var i in source) {
          target[i] = source[i];
        }
        return target;
      }

      /**
       * Sets the prototype of an object.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       * @param {Object} object The object on which to set the prototype.
       * @param {Object} prototype The prototype that will be set on the given
       * `object`.
       * @return {Object} Returns the given `object` with its prototype set
       * to the given `prototype` object.
       */

    }, {
      key: 'chainObject',
      value: function chainObject(object, prototype) {
        if (object && prototype && object !== prototype) {
          object.__proto__ = prototype;
        }
        return object;
      }

      /* **** Begin Template **** */

      /**
       * Calls `importNode` on the `content` of the `template` specified and
       * returns a document fragment containing the imported content.
       *
       * @param {HTMLTemplateElement} template HTML template element to instance.
       * @return {DocumentFragment} Document fragment containing the imported
       *   template content.
      */

    }, {
      key: 'instanceTemplate',
      value: function instanceTemplate(template) {
        var content = this.constructor._contentForTemplate(template);
        var dom = /** @type {DocumentFragment} */
        document.importNode(content, true);
        return dom;
      }

      /* **** Begin Events **** */

      /**
       * Dispatches a custom event with an optional detail value.
       *
       * @param {string} type Name of event type.
       * @param {*=} detail Detail value containing event-specific
       *   payload.
       * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
       *  options Object specifying options.  These may include:
       *  `bubbles` (boolean, defaults to `true`),
       *  `cancelable` (boolean, defaults to false), and
       *  `node` on which to fire the event (HTMLElement, defaults to `this`).
       * @return {Event} The new event that was fired.
       */

    }, {
      key: 'fire',
      value: function fire(type, detail, options) {
        options = options || {};
        detail = detail === null || detail === undefined ? {} : detail;
        var event = new Event(type, {
          bubbles: options.bubbles === undefined ? true : options.bubbles,
          cancelable: Boolean(options.cancelable),
          composed: options.composed === undefined ? true : options.composed
        });
        event.detail = detail;
        var node = options.node || this;
        node.dispatchEvent(event);
        return event;
      }

      /**
       * Convenience method to add an event listener on a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to add event listener to.
       * @param {string} eventName Name of event to listen for.
       * @param {string} methodName Name of handler method on `this` to call.
       */

    }, {
      key: 'listen',
      value: function listen(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
        var bl = hbl.get(node);
        if (!bl) {
          bl = {};
          hbl.set(node, bl);
        }
        var key = eventName + methodName;
        if (!bl[key]) {
          bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
        }
      }

      /**
       * Convenience method to remove an event listener from a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to remove event listener from.
       * @param {string} eventName Name of event to stop listening to.
       * @param {string} methodName Name of handler method on `this` to not call
       anymore.
       */

    }, {
      key: 'unlisten',
      value: function unlisten(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        var bl = this.__boundListeners && this.__boundListeners.get(node);
        var key = eventName + methodName;
        var handler = bl && bl[key];
        if (handler) {
          this._removeEventListenerFromNode(node, eventName, handler);
          bl[key] = null;
        }
      }

      /**
       * Override scrolling behavior to all direction, one direction, or none.
       *
       * Valid scroll directions:
       *   - 'all': scroll in any direction
       *   - 'x': scroll only in the 'x' direction
       *   - 'y': scroll only in the 'y' direction
       *   - 'none': disable scrolling for this node
       *
       * @param {string=} direction Direction to allow scrolling
       * Defaults to `all`.
       * @param {Element=} node Element to apply scroll direction setting.
       * Defaults to `this`.
       */

    }, {
      key: 'setScrollDirection',
      value: function setScrollDirection(direction, node) {
        (0, _gestures.setTouchAction)(node || this, DIRECTION_MAP[direction] || 'auto');
      }
      /* **** End Events **** */

      /**
       * Convenience method to run `querySelector` on this local DOM scope.
       *
       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
       *
       * @param {string} slctr Selector to run on this local DOM scope
       * @return {Element} Element found by the selector, or null if not found.
       */

    }, {
      key: '$$',
      value: function $$(slctr) {
        return this.root.querySelector(slctr);
      }

      /**
       * Return the element whose local dom within which this element
       * is contained. This is a shorthand for
       * `this.getRootNode().host`.
       * @this {Element}
       */

    }, {
      key: 'distributeContent',


      /**
       * Force this element to distribute its children to its local dom.
       * This should not be necessary as of Polymer 2.0.2 and is provided only
       * for backwards compatibility.
       */
      value: function distributeContent() {
        if (window.ShadyDOM && this.shadowRoot) {
          ShadyDOM.flush();
        }
      }

      /**
       * Returns a list of nodes that are the effective childNodes. The effective
       * childNodes list is the same as the element's childNodes except that
       * any `<content>` elements are replaced with the list of nodes distributed
       * to the `<content>`, the result of its `getDistributedNodes` method.
       * @this {Element}
       * @return {Array<Node>} List of effctive child nodes.
       */

    }, {
      key: 'getEffectiveChildNodes',
      value: function getEffectiveChildNodes() {
        return (
          /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(this).getEffectiveChildNodes()
        );
      }

      /**
       * Returns a list of nodes distributed within this element that match
       * `selector`. These can be dom children or elements distributed to
       * children that are insertion points.
       * @param {string} selector Selector to run.
       * @this {Element}
       * @return {Array<Node>} List of distributed elements that match selector.
       */

    }, {
      key: 'queryDistributedElements',
      value: function queryDistributedElements(selector) {
        return (
          /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(this).queryDistributedElements(selector)
        );
      }

      /**
       * Returns a list of elements that are the effective children. The effective
       * children list is the same as the element's children except that
       * any `<content>` elements are replaced with the list of elements
       * distributed to the `<content>`.
       *
       * @return {Array<Node>} List of effctive children.
       */

    }, {
      key: 'getEffectiveChildren',
      value: function getEffectiveChildren() {
        var list = this.getEffectiveChildNodes();
        return list.filter(function ( /** @type {Node} */n) {
          return n.nodeType === Node.ELEMENT_NODE;
        });
      }

      /**
       * Returns a string of text content that is the concatenation of the
       * text content's of the element's effective childNodes (the elements
       * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
       *
       * @return {string} List of effctive children.
       */

    }, {
      key: 'getEffectiveTextContent',
      value: function getEffectiveTextContent() {
        var cn = this.getEffectiveChildNodes();
        var tc = [];
        for (var i = 0, c; c = cn[i]; i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      }

      /**
       * Returns the first effective childNode within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {Object<Node>} First effective child node that matches selector.
       */

    }, {
      key: 'queryEffectiveChildren',
      value: function queryEffectiveChildren(selector) {
        var e$ = this.queryDistributedElements(selector);
        return e$ && e$[0];
      }

      /**
       * Returns a list of effective childNodes within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {Array<Node>} List of effective child nodes that match selector.
       */

    }, {
      key: 'queryAllEffectiveChildren',
      value: function queryAllEffectiveChildren(selector) {
        return this.queryDistributedElements(selector);
      }

      /**
       * Returns a list of nodes distributed to this element's `<slot>`.
       *
       * If this element contains more than one `<slot>` in its local DOM,
       * an optional selector may be passed to choose the desired content.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<slot>`.  Defaults to `content`.
       * @return {Array<Node>} List of distributed nodes for the `<slot>`.
       */

    }, {
      key: 'getContentChildNodes',
      value: function getContentChildNodes(slctr) {
        var content = this.root.querySelector(slctr || 'slot');
        return content ? /** @type {Polymer.DomApi} */(0, _polymerDom.dom)(content).getDistributedNodes() : [];
      }

      /**
       * Returns a list of element children distributed to this element's
       * `<slot>`.
       *
       * If this element contains more than one `<slot>` in its
       * local DOM, an optional selector may be passed to choose the desired
       * content.  This method differs from `getContentChildNodes` in that only
       * elements are returned.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {Array<HTMLElement>} List of distributed nodes for the
       *   `<slot>`.
       * @suppress {invalidCasts}
       */

    }, {
      key: 'getContentChildren',
      value: function getContentChildren(slctr) {
        return (/** @type {Array<HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
            return n.nodeType === Node.ELEMENT_NODE;
          })
        );
      }

      /**
       * Checks whether an element is in this element's light DOM tree.
       *
       * @param {?Node} node The element to be checked.
       * @this {Element}
       * @return {boolean} true if node is in this element's light DOM tree.
       */

    }, {
      key: 'isLightDescendant',
      value: function isLightDescendant(node) {
        return this !== node && this.contains(node) && this.getRootNode() === node.getRootNode();
      }

      /**
       * Checks whether an element is in this element's local DOM tree.
       *
       * @param {Element=} node The element to be checked.
       * @return {boolean} true if node is in this element's local DOM tree.
       */

    }, {
      key: 'isLocalDescendant',
      value: function isLocalDescendant(node) {
        return this.root === node.getRootNode();
      }

      // NOTE: should now be handled by ShadyCss library.

    }, {
      key: 'scopeSubtree',
      value: function scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


      /**
       * Returns the computed style value for the given property.
       * @param {string} property The css property name.
       * @return {string} Returns the computed css property value for the given
       * `property`.
       */

    }, {
      key: 'getComputedStyleValue',
      value: function getComputedStyleValue(property) {
        return styleInterface.getComputedStyleValue(this, property);
      }

      // debounce

      /**
       * Call `debounce` to collapse multiple requests for a named task into
       * one invocation which is made after the wait time has elapsed with
       * no new request.  If no wait time is given, the callback will be called
       * at microtask timing (guaranteed before paint).
       *
       *     debouncedClickAction(e) {
       *       // will not call `processClick` more than once per 100ms
       *       this.debounce('click', function() {
       *        this.processClick();
       *       } 100);
       *     }
       *
       * @param {string} jobName String to indentify the debounce job.
       * @param {function()} callback Function that is called (with `this`
       *   context) when the wait time elapses.
       * @param {number} wait Optional wait time in milliseconds (ms) after the
       *   last signal that must elapse before invoking `callback`
       * @return {Object} Returns a debouncer object on which exists the
       * following methods: `isActive()` returns true if the debouncer is
       * active; `cancel()` cancels the debouncer if it is active;
       * `flush()` immediately invokes the debounced callback if the debouncer
       * is active.
       */

    }, {
      key: 'debounce',
      value: function debounce(jobName, callback, wait) {
        this._debouncers = this._debouncers || {};
        return this._debouncers[jobName] = _debounce.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? _async.timeOut.after(wait) : _async.microTask, callback.bind(this));
      }

      /**
       * Returns whether a named debouncer is active.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       * @return {boolean} Whether the debouncer is active (has not yet fired).
       */

    }, {
      key: 'isDebouncerActive',
      value: function isDebouncerActive(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.isActive());
      }

      /**
       * Immediately calls the debouncer `callback` and inactivates it.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       */

    }, {
      key: 'flushDebouncer',
      value: function flushDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.flush();
        }
      }

      /**
       * Cancels an active debouncer.  The `callback` will not be called.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       */

    }, {
      key: 'cancelDebouncer',
      value: function cancelDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        var debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.cancel();
        }
      }

      /**
       * Runs a callback function asyncronously.
       *
       * By default (if no waitTime is specified), async callbacks are run at
       * microtask timing, which will occur before paint.
       *
       * @param {Function} callback The callback function to run, bound to `this`.
       * @param {number=} waitTime Time to wait before calling the
       *   `callback`.  If unspecified or 0, the callback will be run at microtask
       *   timing (before paint).
       * @return {number} Handle that may be used to cancel the async job.
       */

    }, {
      key: 'async',
      value: function async(callback, waitTime) {
        return waitTime > 0 ? _async.timeOut.run(callback.bind(this), waitTime) : ~_async.microTask.run(callback.bind(this));
      }

      /**
       * Cancels an async operation started with `async`.
       *
       * @param {number} handle Handle returned from original `async` call to
       *   cancel.
       */

    }, {
      key: 'cancelAsync',
      value: function cancelAsync(handle) {
        handle < 0 ? _async.microTask.cancel(~handle) : _async.timeOut.cancel(handle);
      }

      // other

      /**
       * Convenience method for creating an element and configuring it.
       *
       * @param {string} tag HTML element tag to create.
       * @param {Object} props Object of properties to configure on the
       *    instance.
       * @return {Element} Newly created and configured element.
       */

    }, {
      key: 'create',
      value: function create(tag, props) {
        var elt = document.createElement(tag);
        if (props) {
          if (elt.setProperties) {
            elt.setProperties(props);
          } else {
            for (var n in props) {
              elt[n] = props[n];
            }
          }
        }
        return elt;
      }

      /**
       * Convenience method for importing an HTML document imperatively.
       *
       * This method creates a new `<link rel="import">` element with
       * the provided URL and appends it to the document to start loading.
       * In the `onload` callback, the `import` property of the `link`
       * element will contain the imported document contents.
       *
       * @param {string} href URL to document to load.
       * @param {Function} onload Callback to notify when an import successfully
       *   loaded.
       * @param {Function} onerror Callback to notify when an import
       *   unsuccessfully loaded.
       * @param {boolean} optAsync True if the import should be loaded `async`.
       *   Defaults to `false`.
       * @return {HTMLLinkElement} The link element for the URL to be loaded.
       */

    }, {
      key: 'importHref',
      value: function importHref(href, onload, onerror, optAsync) {
        // eslint-disable-line no-unused-vars
        var loadFn = onload ? onload.bind(this) : null;
        var errorFn = onerror ? onerror.bind(this) : null;
        return (0, _importHref.importHref)(href, loadFn, errorFn, optAsync);
      }

      /**
       * Polyfill for Element.prototype.matches, which is sometimes still
       * prefixed.
       *
       * @param {string} selector Selector to test.
       * @param {Element=} node Element to test the selector against.
       * @return {boolean} Whether the element matches the selector.
       */

    }, {
      key: 'elementMatches',
      value: function elementMatches(selector, node) {
        return (0, _polymerDom.matchesSelector)(node || this, selector);
      }

      /**
       * Toggles an HTML attribute on or off.
       *
       * @param {string} name HTML attribute name
       * @param {boolean=} bool Boolean to force the attribute on or off.
       *    When unspecified, the state of the attribute will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       */

    }, {
      key: 'toggleAttribute',
      value: function toggleAttribute(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.hasAttribute(name);
        }
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      }

      /**
       * Toggles a CSS class on or off.
       *
       * @param {string} name CSS class name
       * @param {boolean=} bool Boolean to force the class on or off.
       *    When unspecified, the state of the class will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       */

    }, {
      key: 'toggleClass',
      value: function toggleClass(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.classList.contains(name);
        }
        if (bool) {
          node.classList.add(name);
        } else {
          node.classList.remove(name);
        }
      }

      /**
       * Cross-platform helper for setting an element's CSS `transform` property.
       *
       * @param {string} transformText Transform setting.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`
       */

    }, {
      key: 'transform',
      value: function transform(transformText, node) {
        node = /** @type {Element} */node || this;
        node.style.webkitTransform = transformText;
        node.style.transform = transformText;
      }

      /**
       * Cross-platform helper for setting an element's CSS `translate3d`
       * property.
       *
       * @param {number} x X offset.
       * @param {number} y Y offset.
       * @param {number} z Z offset.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`.
       */

    }, {
      key: 'translate3d',
      value: function translate3d(x, y, z, node) {
        node = /** @type {Element} */node || this;
        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
      }

      /**
       * Removes an item from an array, if it exists.
       *
       * If the array is specified by path, a change notification is
       * generated, so that observers, data bindings and computed
       * properties watching that path can update.
       *
       * If the array is passed directly, **no change
       * notification is generated**.
       *
       * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
       *   (or the array itself).
       * @param {*} item Item to remove.
       * @return {Array} Array containing item removed.
       */

    }, {
      key: 'arrayDelete',
      value: function arrayDelete(arrayOrPath, item) {
        var index = void 0;
        if (Array.isArray(arrayOrPath)) {
          index = arrayOrPath.indexOf(item);
          if (index >= 0) {
            return arrayOrPath.splice(index, 1);
          }
        } else {
          var arr = (0, _path.get)(this, arrayOrPath);
          index = arr.indexOf(item);
          if (index >= 0) {
            return this.splice(arrayOrPath, index, 1);
          }
        }
        return null;
      }

      // logging

      /**
       * Facades `console.log`/`warn`/`error` as override point.
       *
       * @param {string} level One of 'log', 'warn', 'error'
       * @param {Array} args Array of strings or objects to log
       */

    }, {
      key: '_logger',
      value: function _logger(level, args) {
        var _console;

        // accept ['foo', 'bar'] and [['foo', 'bar']]
        if (Array.isArray(args) && args.length === 1) {
          args = args[0];
        }
        switch (level) {
          case 'log':
          case 'warn':
          case 'error':
            (_console = console)[level].apply(_console, _toConsumableArray(args));
        }
      }

      /**
       * Facades `console.log` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_log',
      value: function _log() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        this._logger('log', args);
      }

      /**
       * Facades `console.warn` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_warn',
      value: function _warn() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        this._logger('warn', args);
      }

      /**
       * Facades `console.error` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       */

    }, {
      key: '_error',
      value: function _error() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        this._logger('error', args);
      }

      /**
       * Formats a message using the element type an a method name.
       *
       * @param {string} methodName Method name to associate with message
       * @param {...*} args Array of strings or objects to log
       * @return {Array} Array with formatting information for `console`
       *   logging.
       */

    }, {
      key: '_logf',
      value: function _logf(methodName) {
        for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        return ['[%s::%s]', this.is, methodName].concat(args);
      }
    }, {
      key: 'domHost',
      get: function get() {
        var root = this.getRootNode();
        return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
      }
    }]);

    return LegacyElement;
  }(legacyElementBase);

  LegacyElement.prototype.is = '';

  return LegacyElement;
});

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toCssText = toCssText;
exports.rulesForStyle = rulesForStyle;
exports.isKeyframesSelector = isKeyframesSelector;
exports.forEachRule = forEachRule;
exports.applyCss = applyCss;
exports.createScopeStyle = createScopeStyle;
exports.applyStylePlaceHolder = applyStylePlaceHolder;
exports.applyStyle = applyStyle;
exports.isTargetedBuild = isTargetedBuild;
exports.getCssBuildType = getCssBuildType;
exports.processVariableAndFallback = processVariableAndFallback;
exports.setElementClassRaw = setElementClassRaw;
exports.getIsExtends = getIsExtends;

var _styleSettings = __webpack_require__(37);

var _cssParse = __webpack_require__(38);

var _commonRegex = __webpack_require__(39);

/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */
function toCssText(rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = (0, _cssParse.parse)(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return (0, _cssParse.stringify)(rules, _styleSettings.nativeCssVariables);
}

/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */
// eslint-disable-line no-unused-vars
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = (0, _cssParse.parse)(style.textContent);
  }
  return style['__cssRules'] || null;
}

// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */
function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) && rule['parent']['type'] === _cssParse.types.KEYFRAMES_RULE;
}

/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  var skipRules = false;
  var type = node['type'];
  if (onlyActiveRules) {
    if (type === _cssParse.types.MEDIA_RULE) {
      var matchMedia = node['selector'].match(_commonRegex.MEDIA_MATCH);
      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === _cssParse.types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === _cssParse.types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === _cssParse.types.MIXIN_RULE) {
    skipRules = true;
  }
  var r$ = node['rules'];
  if (r$ && !skipRules) {
    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}

// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */
function applyCss(cssText, moniker, target, contextNode) {
  var style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}

/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */
function createScopeStyle(cssText, moniker) {
  var style = /** @type {HTMLStyleElement} */document.createElement('style');
  if (moniker) {
    style.setAttribute('scope', moniker);
  }
  style.textContent = cssText;
  return style;
}

/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */
var lastHeadApplyNode = null;

// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {!Comment}
 */
function applyStylePlaceHolder(moniker) {
  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
  var after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;
  var scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}

/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */
function applyStyle(style, target, contextNode) {
  target = target || document.head;
  var after = contextNode && contextNode.nextSibling || target.firstChild;
  target.insertBefore(style, after);
  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    var position = style.compareDocumentPosition(lastHeadApplyNode);
    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}

/**
 * @param {string} buildType
 * @return {boolean}
 */
function isTargetedBuild(buildType) {
  return _styleSettings.nativeShadow ? buildType === 'shadow' : buildType === 'shady';
}

/**
 * @param {Element} element
 * @return {?string}
 */
function getCssBuildType(element) {
  return element.getAttribute('css-build');
}

/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */
function findMatchingParen(text, start) {
  var level = 0;
  for (var i = start, l = text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */
function processVariableAndFallback(str, callback) {
  // find 'var('
  var start = str.indexOf('var(');
  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  }
  //${prefix}var(${inner})${suffix}
  var end = findMatchingParen(str, start + 3);
  var inner = str.substring(start + 4, end);
  var prefix = str.substring(0, start);
  // suffix may have other variables
  var suffix = processVariableAndFallback(str.substring(end + 1), callback);
  var comma = inner.indexOf(',');
  // value and fallback args should be trimmed to match in property lookup
  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  }
  // var(${value},${fallback})
  var value = inner.substring(0, comma).trim();
  var fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}

/**
 * @param {Element} element
 * @param {string} value
 */
function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (_styleSettings.nativeShadow) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}

/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */
function getIsExtends(element) {
  var localName = element['localName'];
  var is = '',
      typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = element.getAttribute && element.getAttribute('is') || '';
    }
  } else {
    is = /** @type {?} */element.is;
    typeExtension = /** @type {?} */element.extends;
  }
  return { is: is, typeExtension: typeExtension };
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var templateMap = {};
exports.default = templateMap;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {Promise<void>} */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = documentWait;
var readyPromise = null;

/** @type {?function(?function())} */
var whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
var resolveFn = void 0;

/**
 * @param {?function()} callback
 */
function documentWait(callback) {
  requestAnimationFrame(function () {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise(function (resolve) {
          resolveFn = resolve;
        });
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', function () {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function () {
        callback && callback();
      });
    }
  });
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStyleInterfaceInterface = exports.CustomStyleProvider = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _documentWait = __webpack_require__(63);

var _documentWait2 = _interopRequireDefault(_documentWait);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
 */
var CustomStyleProvider = exports.CustomStyleProvider = void 0;

var SEEN_MARKER = '__seenByShadyCSS';
var CACHED_STYLE = '__shadyCSSCachedStyle';

/** @type {?function(!HTMLStyleElement)} */
var transformFn = null;

/** @type {?function()} */
var validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/

var CustomStyleInterface = function () {
  function CustomStyleInterface() {
    _classCallCheck(this, CustomStyleInterface);

    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */


  _createClass(CustomStyleInterface, [{
    key: 'enqueueDocumentValidation',
    value: function enqueueDocumentValidation() {
      if (this['enqueued'] || !validateFn) {
        return;
      }
      this['enqueued'] = true;
      (0, _documentWait2.default)(validateFn);
    }
    /**
     * @param {!HTMLStyleElement} style
     */

  }, {
    key: 'addCustomStyle',
    value: function addCustomStyle(style) {
      if (!style[SEEN_MARKER]) {
        style[SEEN_MARKER] = true;
        this['customStyles'].push(style);
        this.enqueueDocumentValidation();
      }
    }
    /**
     * @param {!CustomStyleProvider} customStyle
     * @return {HTMLStyleElement}
     */

  }, {
    key: 'getStyleForCustomStyle',
    value: function getStyleForCustomStyle(customStyle) {
      if (customStyle[CACHED_STYLE]) {
        return customStyle[CACHED_STYLE];
      }
      var style = void 0;
      if (customStyle['getStyle']) {
        style = customStyle['getStyle']();
      } else {
        style = customStyle;
      }
      return style;
    }
    /**
     * @return {!Array<!CustomStyleProvider>}
     */

  }, {
    key: 'processStyles',
    value: function processStyles() {
      var cs = this['customStyles'];
      for (var i = 0; i < cs.length; i++) {
        var customStyle = cs[i];
        if (customStyle[CACHED_STYLE]) {
          continue;
        }
        var style = this.getStyleForCustomStyle(customStyle);
        if (style) {
          // HTMLImports polyfill may have cloned the style into the main document,
          // which is referenced with __appliedElement.
          var styleToTransform = /** @type {!HTMLStyleElement} */style['__appliedElement'] || style;
          if (transformFn) {
            transformFn(styleToTransform);
          }
          customStyle[CACHED_STYLE] = styleToTransform;
        }
      }
      return cs;
    }
  }]);

  return CustomStyleInterface;
}();

exports.default = CustomStyleInterface;


CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get: function get() {
      return transformFn;
    },

    /** @param {?function(!HTMLStyleElement)} fn */
    set: function set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get: function get() {
      return validateFn;
    },

    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set: function set(fn) {
      var needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    }
  }
});

/** @typedef {{
 * customStyles: !Array<!CustomStyleProvider>,
 * addCustomStyle: function(!CustomStyleProvider),
 * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
 * findStyles: function(),
 * transformCallback: ?function(!HTMLStyleElement),
 * validateCallback: ?function()
 * }}
 */
var CustomStyleInterfaceInterface = exports.CustomStyleInterfaceInterface = void 0;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GestureEventListeners = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _gestures = __webpack_require__(41);

var gestures$0 = _interopRequireWildcard(_gestures);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @const {Polymer.Gestures}
 */
var gestures = gestures$0;

var GestureEventListeners = exports.GestureEventListeners = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  var GestureEventListeners = function (_superClass) {
    _inherits(GestureEventListeners, _superClass);

    function GestureEventListeners() {
      _classCallCheck(this, GestureEventListeners);

      return _possibleConstructorReturn(this, (GestureEventListeners.__proto__ || Object.getPrototypeOf(GestureEventListeners)).apply(this, arguments));
    }

    _createClass(GestureEventListeners, [{
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        if (!gestures.addListener(node, eventName, handler)) {
          _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_addEventListenerToNode', this).call(this, node, eventName, handler);
        }
      }
    }, {
      key: '_removeEventListenerFromNode',
      value: function _removeEventListenerFromNode(node, eventName, handler) {
        if (!gestures.removeListener(node, eventName, handler)) {
          _get(GestureEventListeners.prototype.__proto__ || Object.getPrototypeOf(GestureEventListeners.prototype), '_removeEventListenerFromNode', this).call(this, node, eventName, handler);
        }
      }
    }]);

    return GestureEventListeners;
  }(superClass);

  return GestureEventListeners;
});

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flush = undefined;
exports.beforeNextRender = beforeNextRender;
exports.afterNextRender = afterNextRender;

__webpack_require__(2);

var scheduled = false;
var beforeRenderQueue = [];
var afterRenderQueue = [];

function schedule() {
  scheduled = true;
  // before next render
  requestAnimationFrame(function () {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    // after the render
    setTimeout(function () {
      runQueue(afterRenderQueue);
    });
  });
}

function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}

function runQueue(queue) {
  for (var i = 0, l = queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}

function callMethod(info) {
  var context = info[0];
  var callback = info[1];
  var args = info[2];
  try {
    callback.apply(context, args);
  } catch (e) {
    setTimeout(function () {
      throw e;
    });
  }
}

function flush() {
  while (beforeRenderQueue.length || afterRenderQueue.length) {
    flushQueue(beforeRenderQueue);
    flushQueue(afterRenderQueue);
  }
  scheduled = false;
}

function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}

function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}

exports.flush = flush;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlattenedNodesObserver = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _arraySplice = __webpack_require__(68);

var _async = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Returns true if `node` is a slot element
 * @param {HTMLElement} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */
function isSlot(node) {
  return node.localName === 'slot';
}

/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * @memberof Polymer
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 */

var FlattenedNodesObserver = function () {
  _createClass(FlattenedNodesObserver, null, [{
    key: 'getFlattenedNodes',


    /**
     * Returns the list of flattened nodes for the given `node`.
     * This list consists of a node's children and, for any children
     * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
     * For example, if the observed node has children `<a></a><slot></slot><b></b>`
     * and the `<slot>` has one `<div>` assigned to it, then the flattened
     * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
     * `<slot>` elements assigned to it, these are flattened as well.
     *
     * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
     * @return {Array} The list of flattened nodes for the given `node`.
    */
    value: function getFlattenedNodes(node) {
      if (isSlot(node)) {
        return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
        );
      } else {
        return Array.from(node.childNodes).map(function (node) {
          if (isSlot(node)) {
            return (/** @type {HTMLSlotElement} */node.assignedNodes({ flatten: true })
            );
          } else {
            return [node];
          }
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
      }
    }

    /**
     * @param {Node} target Node on which to listen for changes.
     * @param {Function} callback Function called when there are additions
     * or removals from the target's list of flattened nodes.
    */

  }]);

  function FlattenedNodesObserver(target, callback) {
    var _this = this;

    _classCallCheck(this, FlattenedNodesObserver);

    /** @type {MutationObserver} */
    this._shadyChildrenObserver = null;
    /** @type {MutationObserver} */
    this._nativeChildrenObserver = null;
    this._connected = false;
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /** @type {function()} */
    this._boundSchedule = function () {
      _this._schedule();
    };
    this.connect();
    this._schedule();
  }

  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   */


  _createClass(FlattenedNodesObserver, [{
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (isSlot(this._target)) {
        this._listenSlots([this._target]);
      } else {
        this._listenSlots(this._target.children);
        if (window.ShadyDOM) {
          this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, function (mutations) {
            _this2._processMutations(mutations);
          });
        } else {
          this._nativeChildrenObserver = new MutationObserver(function (mutations) {
            _this2._processMutations(mutations);
          });
          this._nativeChildrenObserver.observe(this._target, { childList: true });
        }
      }
      this._connected = true;
    }

    /**
     * Deactivates the flattened nodes observer. After calling this method
     * the observer callback will not be called when changes to flattened nodes
     * occur. The `connect` method may be subsequently called to reactivate
     * the observer.
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (isSlot(this._target)) {
        this._unlistenSlots([this._target]);
      } else {
        this._unlistenSlots(this._target.children);
        if (window.ShadyDOM && this._shadyChildrenObserver) {
          ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
          this._shadyChildrenObserver = null;
        } else if (this._nativeChildrenObserver) {
          this._nativeChildrenObserver.disconnect();
          this._nativeChildrenObserver = null;
        }
      }
      this._connected = false;
    }
  }, {
    key: '_schedule',
    value: function _schedule() {
      var _this3 = this;

      if (!this._scheduled) {
        this._scheduled = true;
        _async.microTask.run(function () {
          return _this3.flush();
        });
      }
    }
  }, {
    key: '_processMutations',
    value: function _processMutations(mutations) {
      this._processSlotMutations(mutations);
      this.flush();
    }
  }, {
    key: '_processSlotMutations',
    value: function _processSlotMutations(mutations) {
      if (mutations) {
        for (var i = 0; i < mutations.length; i++) {
          var mutation = mutations[i];
          if (mutation.addedNodes) {
            this._listenSlots(mutation.addedNodes);
          }
          if (mutation.removedNodes) {
            this._unlistenSlots(mutation.removedNodes);
          }
        }
      }
    }

    /**
     * Flushes the observer causing any pending changes to be immediately
     * delivered the observer callback. By default these changes are delivered
     * asynchronously at the next microtask checkpoint.
     *
     * @return {boolean} Returns true if any pending changes caused the observer
     * callback to run.
     */

  }, {
    key: 'flush',
    value: function flush() {
      if (!this._connected) {
        return false;
      }
      if (window.ShadyDOM) {
        ShadyDOM.flush();
      }
      if (this._nativeChildrenObserver) {
        this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
      } else if (this._shadyChildrenObserver) {
        this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
      }
      this._scheduled = false;
      var info = {
        target: this._target,
        addedNodes: [],
        removedNodes: []
      };
      var newNodes = this.constructor.getFlattenedNodes(this._target);
      var splices = (0, _arraySplice.calculateSplices)(newNodes, this._effectiveNodes);
      // process removals
      for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
          info.removedNodes.push(n);
        }
      }
      // process adds
      for (var _i = 0, _s; _i < splices.length && (_s = splices[_i]); _i++) {
        for (var _j = _s.index; _j < _s.index + _s.addedCount; _j++) {
          info.addedNodes.push(newNodes[_j]);
        }
      }
      // update cache
      this._effectiveNodes = newNodes;
      var didFlush = false;
      if (info.addedNodes.length || info.removedNodes.length) {
        didFlush = true;
        this.callback.call(this._target, info);
      }
      return didFlush;
    }
  }, {
    key: '_listenSlots',
    value: function _listenSlots(nodeList) {
      for (var i = 0; i < nodeList.length; i++) {
        var n = nodeList[i];
        if (isSlot(n)) {
          n.addEventListener('slotchange', this._boundSchedule);
        }
      }
    }
  }, {
    key: '_unlistenSlots',
    value: function _unlistenSlots(nodeList) {
      for (var i = 0; i < nodeList.length; i++) {
        var n = nodeList[i];
        if (isSlot(n)) {
          n.removeEventListener('slotchange', this._boundSchedule);
        }
      }
    }
  }]);

  return FlattenedNodesObserver;
}();

exports.FlattenedNodesObserver = FlattenedNodesObserver;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSplices = undefined;

__webpack_require__(2);

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;

// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  // "Deletion" columns
  var rowCount = oldEnd - oldStart + 1;
  var columnCount = currentEnd - currentStart + 1;
  var distances = new Array(rowCount);

  // "Addition" rows. Initialize null column.
  for (var i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }

  // Initialize null row
  for (var j = 0; j < columnCount; j++) {
    distances[0][j] = j;
  }for (var _i = 1; _i < rowCount; _i++) {
    for (var _j = 1; _j < columnCount; _j++) {
      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
        var north = distances[_i - 1][_j] + 1;
        var west = distances[_i][_j - 1] + 1;
        distances[_i][_j] = north < west ? north : west;
      }
    }
  }

  return distances;
}

// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
  var i = distances.length - 1;
  var j = distances[0].length - 1;
  var current = distances[i][j];
  var edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    var northWest = distances[i - 1][j - 1];
    var west = distances[i - 1][j];
    var north = distances[i][j - 1];

    var min = void 0;
    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}

/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  var prefixCount = 0;
  var suffixCount = 0;
  var splice = void 0;

  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;

  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd) {
      splice.removed.push(old[oldStart++]);
    }return [splice];
  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

  splice = undefined;
  var splices = [];
  var index = currentStart;
  var oldIndex = oldStart;
  for (var i = 0; i < ops.length; i++) {
    switch (ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice) splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice) splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice) splice = newSplice(index, [], 0);

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }
  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (var i = 0; i < searchLength; i++) {
    if (!equals(current[i], old[i])) return i;
  }return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  var index1 = current.length;
  var index2 = old.length;
  var count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2])) {
    count++;
  }return count;
}

function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0, previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}

exports.calculateSplices = calculateSplices;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n\n      /* Material Design color palette for Google products */\n\n      --google-red-100: #f4c7c3;\n      --google-red-300: #e67c73;\n      --google-red-500: #db4437;\n      --google-red-700: #c53929;\n\n      --google-blue-100: #c6dafc;\n      --google-blue-300: #7baaf7;\n      --google-blue-500: #4285f4;\n      --google-blue-700: #3367d6;\n\n      --google-green-100: #b7e1cd;\n      --google-green-300: #57bb8a;\n      --google-green-500: #0f9d58;\n      --google-green-700: #0b8043;\n\n      --google-yellow-100: #fce8b2;\n      --google-yellow-300: #f7cb4d;\n      --google-yellow-500: #f4b400;\n      --google-yellow-700: #f09300;\n\n      --google-grey-100: #f5f5f5;\n      --google-grey-300: #e0e0e0;\n      --google-grey-500: #9e9e9e;\n      --google-grey-700: #616161;\n\n      /* Material Design color palette from online spec document */\n\n      --paper-red-50: #ffebee;\n      --paper-red-100: #ffcdd2;\n      --paper-red-200: #ef9a9a;\n      --paper-red-300: #e57373;\n      --paper-red-400: #ef5350;\n      --paper-red-500: #f44336;\n      --paper-red-600: #e53935;\n      --paper-red-700: #d32f2f;\n      --paper-red-800: #c62828;\n      --paper-red-900: #b71c1c;\n      --paper-red-a100: #ff8a80;\n      --paper-red-a200: #ff5252;\n      --paper-red-a400: #ff1744;\n      --paper-red-a700: #d50000;\n\n      --paper-pink-50: #fce4ec;\n      --paper-pink-100: #f8bbd0;\n      --paper-pink-200: #f48fb1;\n      --paper-pink-300: #f06292;\n      --paper-pink-400: #ec407a;\n      --paper-pink-500: #e91e63;\n      --paper-pink-600: #d81b60;\n      --paper-pink-700: #c2185b;\n      --paper-pink-800: #ad1457;\n      --paper-pink-900: #880e4f;\n      --paper-pink-a100: #ff80ab;\n      --paper-pink-a200: #ff4081;\n      --paper-pink-a400: #f50057;\n      --paper-pink-a700: #c51162;\n\n      --paper-purple-50: #f3e5f5;\n      --paper-purple-100: #e1bee7;\n      --paper-purple-200: #ce93d8;\n      --paper-purple-300: #ba68c8;\n      --paper-purple-400: #ab47bc;\n      --paper-purple-500: #9c27b0;\n      --paper-purple-600: #8e24aa;\n      --paper-purple-700: #7b1fa2;\n      --paper-purple-800: #6a1b9a;\n      --paper-purple-900: #4a148c;\n      --paper-purple-a100: #ea80fc;\n      --paper-purple-a200: #e040fb;\n      --paper-purple-a400: #d500f9;\n      --paper-purple-a700: #aa00ff;\n\n      --paper-deep-purple-50: #ede7f6;\n      --paper-deep-purple-100: #d1c4e9;\n      --paper-deep-purple-200: #b39ddb;\n      --paper-deep-purple-300: #9575cd;\n      --paper-deep-purple-400: #7e57c2;\n      --paper-deep-purple-500: #673ab7;\n      --paper-deep-purple-600: #5e35b1;\n      --paper-deep-purple-700: #512da8;\n      --paper-deep-purple-800: #4527a0;\n      --paper-deep-purple-900: #311b92;\n      --paper-deep-purple-a100: #b388ff;\n      --paper-deep-purple-a200: #7c4dff;\n      --paper-deep-purple-a400: #651fff;\n      --paper-deep-purple-a700: #6200ea;\n\n      --paper-indigo-50: #e8eaf6;\n      --paper-indigo-100: #c5cae9;\n      --paper-indigo-200: #9fa8da;\n      --paper-indigo-300: #7986cb;\n      --paper-indigo-400: #5c6bc0;\n      --paper-indigo-500: #3f51b5;\n      --paper-indigo-600: #3949ab;\n      --paper-indigo-700: #303f9f;\n      --paper-indigo-800: #283593;\n      --paper-indigo-900: #1a237e;\n      --paper-indigo-a100: #8c9eff;\n      --paper-indigo-a200: #536dfe;\n      --paper-indigo-a400: #3d5afe;\n      --paper-indigo-a700: #304ffe;\n\n      --paper-blue-50: #e3f2fd;\n      --paper-blue-100: #bbdefb;\n      --paper-blue-200: #90caf9;\n      --paper-blue-300: #64b5f6;\n      --paper-blue-400: #42a5f5;\n      --paper-blue-500: #2196f3;\n      --paper-blue-600: #1e88e5;\n      --paper-blue-700: #1976d2;\n      --paper-blue-800: #1565c0;\n      --paper-blue-900: #0d47a1;\n      --paper-blue-a100: #82b1ff;\n      --paper-blue-a200: #448aff;\n      --paper-blue-a400: #2979ff;\n      --paper-blue-a700: #2962ff;\n\n      --paper-light-blue-50: #e1f5fe;\n      --paper-light-blue-100: #b3e5fc;\n      --paper-light-blue-200: #81d4fa;\n      --paper-light-blue-300: #4fc3f7;\n      --paper-light-blue-400: #29b6f6;\n      --paper-light-blue-500: #03a9f4;\n      --paper-light-blue-600: #039be5;\n      --paper-light-blue-700: #0288d1;\n      --paper-light-blue-800: #0277bd;\n      --paper-light-blue-900: #01579b;\n      --paper-light-blue-a100: #80d8ff;\n      --paper-light-blue-a200: #40c4ff;\n      --paper-light-blue-a400: #00b0ff;\n      --paper-light-blue-a700: #0091ea;\n\n      --paper-cyan-50: #e0f7fa;\n      --paper-cyan-100: #b2ebf2;\n      --paper-cyan-200: #80deea;\n      --paper-cyan-300: #4dd0e1;\n      --paper-cyan-400: #26c6da;\n      --paper-cyan-500: #00bcd4;\n      --paper-cyan-600: #00acc1;\n      --paper-cyan-700: #0097a7;\n      --paper-cyan-800: #00838f;\n      --paper-cyan-900: #006064;\n      --paper-cyan-a100: #84ffff;\n      --paper-cyan-a200: #18ffff;\n      --paper-cyan-a400: #00e5ff;\n      --paper-cyan-a700: #00b8d4;\n\n      --paper-teal-50: #e0f2f1;\n      --paper-teal-100: #b2dfdb;\n      --paper-teal-200: #80cbc4;\n      --paper-teal-300: #4db6ac;\n      --paper-teal-400: #26a69a;\n      --paper-teal-500: #009688;\n      --paper-teal-600: #00897b;\n      --paper-teal-700: #00796b;\n      --paper-teal-800: #00695c;\n      --paper-teal-900: #004d40;\n      --paper-teal-a100: #a7ffeb;\n      --paper-teal-a200: #64ffda;\n      --paper-teal-a400: #1de9b6;\n      --paper-teal-a700: #00bfa5;\n\n      --paper-green-50: #e8f5e9;\n      --paper-green-100: #c8e6c9;\n      --paper-green-200: #a5d6a7;\n      --paper-green-300: #81c784;\n      --paper-green-400: #66bb6a;\n      --paper-green-500: #4caf50;\n      --paper-green-600: #43a047;\n      --paper-green-700: #388e3c;\n      --paper-green-800: #2e7d32;\n      --paper-green-900: #1b5e20;\n      --paper-green-a100: #b9f6ca;\n      --paper-green-a200: #69f0ae;\n      --paper-green-a400: #00e676;\n      --paper-green-a700: #00c853;\n\n      --paper-light-green-50: #f1f8e9;\n      --paper-light-green-100: #dcedc8;\n      --paper-light-green-200: #c5e1a5;\n      --paper-light-green-300: #aed581;\n      --paper-light-green-400: #9ccc65;\n      --paper-light-green-500: #8bc34a;\n      --paper-light-green-600: #7cb342;\n      --paper-light-green-700: #689f38;\n      --paper-light-green-800: #558b2f;\n      --paper-light-green-900: #33691e;\n      --paper-light-green-a100: #ccff90;\n      --paper-light-green-a200: #b2ff59;\n      --paper-light-green-a400: #76ff03;\n      --paper-light-green-a700: #64dd17;\n\n      --paper-lime-50: #f9fbe7;\n      --paper-lime-100: #f0f4c3;\n      --paper-lime-200: #e6ee9c;\n      --paper-lime-300: #dce775;\n      --paper-lime-400: #d4e157;\n      --paper-lime-500: #cddc39;\n      --paper-lime-600: #c0ca33;\n      --paper-lime-700: #afb42b;\n      --paper-lime-800: #9e9d24;\n      --paper-lime-900: #827717;\n      --paper-lime-a100: #f4ff81;\n      --paper-lime-a200: #eeff41;\n      --paper-lime-a400: #c6ff00;\n      --paper-lime-a700: #aeea00;\n\n      --paper-yellow-50: #fffde7;\n      --paper-yellow-100: #fff9c4;\n      --paper-yellow-200: #fff59d;\n      --paper-yellow-300: #fff176;\n      --paper-yellow-400: #ffee58;\n      --paper-yellow-500: #ffeb3b;\n      --paper-yellow-600: #fdd835;\n      --paper-yellow-700: #fbc02d;\n      --paper-yellow-800: #f9a825;\n      --paper-yellow-900: #f57f17;\n      --paper-yellow-a100: #ffff8d;\n      --paper-yellow-a200: #ffff00;\n      --paper-yellow-a400: #ffea00;\n      --paper-yellow-a700: #ffd600;\n\n      --paper-amber-50: #fff8e1;\n      --paper-amber-100: #ffecb3;\n      --paper-amber-200: #ffe082;\n      --paper-amber-300: #ffd54f;\n      --paper-amber-400: #ffca28;\n      --paper-amber-500: #ffc107;\n      --paper-amber-600: #ffb300;\n      --paper-amber-700: #ffa000;\n      --paper-amber-800: #ff8f00;\n      --paper-amber-900: #ff6f00;\n      --paper-amber-a100: #ffe57f;\n      --paper-amber-a200: #ffd740;\n      --paper-amber-a400: #ffc400;\n      --paper-amber-a700: #ffab00;\n\n      --paper-orange-50: #fff3e0;\n      --paper-orange-100: #ffe0b2;\n      --paper-orange-200: #ffcc80;\n      --paper-orange-300: #ffb74d;\n      --paper-orange-400: #ffa726;\n      --paper-orange-500: #ff9800;\n      --paper-orange-600: #fb8c00;\n      --paper-orange-700: #f57c00;\n      --paper-orange-800: #ef6c00;\n      --paper-orange-900: #e65100;\n      --paper-orange-a100: #ffd180;\n      --paper-orange-a200: #ffab40;\n      --paper-orange-a400: #ff9100;\n      --paper-orange-a700: #ff6500;\n\n      --paper-deep-orange-50: #fbe9e7;\n      --paper-deep-orange-100: #ffccbc;\n      --paper-deep-orange-200: #ffab91;\n      --paper-deep-orange-300: #ff8a65;\n      --paper-deep-orange-400: #ff7043;\n      --paper-deep-orange-500: #ff5722;\n      --paper-deep-orange-600: #f4511e;\n      --paper-deep-orange-700: #e64a19;\n      --paper-deep-orange-800: #d84315;\n      --paper-deep-orange-900: #bf360c;\n      --paper-deep-orange-a100: #ff9e80;\n      --paper-deep-orange-a200: #ff6e40;\n      --paper-deep-orange-a400: #ff3d00;\n      --paper-deep-orange-a700: #dd2c00;\n\n      --paper-brown-50: #efebe9;\n      --paper-brown-100: #d7ccc8;\n      --paper-brown-200: #bcaaa4;\n      --paper-brown-300: #a1887f;\n      --paper-brown-400: #8d6e63;\n      --paper-brown-500: #795548;\n      --paper-brown-600: #6d4c41;\n      --paper-brown-700: #5d4037;\n      --paper-brown-800: #4e342e;\n      --paper-brown-900: #3e2723;\n\n      --paper-grey-50: #fafafa;\n      --paper-grey-100: #f5f5f5;\n      --paper-grey-200: #eeeeee;\n      --paper-grey-300: #e0e0e0;\n      --paper-grey-400: #bdbdbd;\n      --paper-grey-500: #9e9e9e;\n      --paper-grey-600: #757575;\n      --paper-grey-700: #616161;\n      --paper-grey-800: #424242;\n      --paper-grey-900: #212121;\n\n      --paper-blue-grey-50: #eceff1;\n      --paper-blue-grey-100: #cfd8dc;\n      --paper-blue-grey-200: #b0bec5;\n      --paper-blue-grey-300: #90a4ae;\n      --paper-blue-grey-400: #78909c;\n      --paper-blue-grey-500: #607d8b;\n      --paper-blue-grey-600: #546e7a;\n      --paper-blue-grey-700: #455a64;\n      --paper-blue-grey-800: #37474f;\n      --paper-blue-grey-900: #263238;\n\n      /* opacity for dark text on a light background */\n      --dark-divider-opacity: 0.12;\n      --dark-disabled-opacity: 0.38; /* or hint text or icon */\n      --dark-secondary-opacity: 0.54;\n      --dark-primary-opacity: 0.87;\n\n      /* opacity for light text on a dark background */\n      --light-divider-opacity: 0.12;\n      --light-disabled-opacity: 0.3; /* or hint text or icon */\n      --light-secondary-opacity: 0.7;\n      --light-primary-opacity: 1.0;\n\n    }\n\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronButtonState = exports.IronButtonStateImpl = undefined;

__webpack_require__(7);

var _ironA11yKeysBehavior = __webpack_require__(71);

__webpack_require__(72);

var _polymerDom = __webpack_require__(17);

var IronButtonStateImpl = exports.IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: ['_focusChanged(focused)', '_activeChanged(active, ariaActiveAttribute)'],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler'
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function _tapHandler() {
    if (this.toggles) {
      // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function _focusChanged(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function _detectKeyboardFocus(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function _userActivate(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function _downHandler(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function _upHandler() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function _spaceKeyDownHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = (0, _polymerDom.dom)(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function _spaceKeyUpHandler(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = (0, _polymerDom.dom)(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant( /** @type {Node} */target)) return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function _asyncClick() {
    this.async(function () {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function _pressedChanged(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function _ariaActiveAttributeChanged(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function _activeChanged(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute, active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function _controlStateChanged() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function _changedButtonState() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};

var IronButtonState = exports.IronButtonState = [_ironA11yKeysBehavior.IronA11yKeysBehavior, IronButtonStateImpl];

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronA11yKeysBehavior = undefined;

__webpack_require__(7);

/**
 * Chrome uses an older version of DOM Level 3 Keyboard Events
 *
 * Most keys are labeled as text, but some are Unicode codepoints.
 * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
 */
var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};

/**
 * Special table for KeyboardEvent.keyCode.
 * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
 * than that.
 *
 * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
 */
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};

/**
 * MODIFIER_KEYS maps the short name for modifier keys used in a key
 * combo string to the property name that references those same keys
 * in a KeyboardEvent instance.
 */
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};

/**
 * KeyboardEvent.key is mostly represented by printable character made by
 * the keyboard, with unprintable keys labeled nicely.
 *
 * However, on OS X, Alt+char can make a Unicode character that follows an
 * Apple-specific mapping. In this case, we fall back to .keyCode.
 */
var KEY_CHAR = /[a-z0-9*]/;

/**
 * Matches a keyIdentifier string.
 */
var IDENT_CHAR = /U\+/;

/**
 * Matches arrow keys in Gecko 27.0+
 */
var ARROW_KEY = /^arrow/;

/**
 * Matches space keys everywhere (notably including IE10's exceptional name
 * `spacebar`).
 */
var SPACE_KEY = /^space(bar)?/;

/**
 * Matches ESC key.
 *
 * Value from: http://w3c.github.io/uievents-key/#key-Escape
 */
var ESC_KEY = /^escape$/;

/**
 * Transforms the key.
 * @param {string} key The KeyBoardEvent.key
 * @param {Boolean} [noSpecialChars] Limits the transformation to
 * alpha-numeric characters.
 */
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      // numpad '*' can map to Multiply on IE/Windows
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}

function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}

function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      // ascii a-z
      // lowercase is 32 offset from uppercase
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      // function keys f1-f12
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      // top 0-9 keys
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      // num pad 0-9
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}

/**
  * Calculates the normalized key for a KeyboardEvent.
  * @param {KeyboardEvent} keyEvent
  * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
  * transformation to alpha-numeric chars. This is useful with key
  * combinations like shift + 2, which on FF for MacOS produces
  * keyEvent.key = @
  * To get 2 returned, set noSpecialChars = true
  * To get @ returned, set noSpecialChars = false
 */
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  // Fall back from .key, to .detail.key for artifical keyboard events,
  // and then to deprecated .keyIdentifier and .keyCode.
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) || transformKeyCode(keyEvent.keyCode) || '';
}

function keyComboMatchesEvent(keyCombo, event) {
  // For combos with modifiers we support only alpha-numeric keys
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key && (!keyCombo.hasModifiers || !!event.shiftKey === !!keyCombo.shiftKey && !!event.ctrlKey === !!keyCombo.ctrlKey && !!event.altKey === !!keyCombo.altKey && !!event.metaKey === !!keyCombo.metaKey);
}

function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {
      combo: keyComboString,
      key: keyComboString,
      event: 'keydown'
    };
  }
  return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
    var eventParts = keyComboPart.split(':');
    var keyName = eventParts[0];
    var event = eventParts[1];

    if (keyName in MODIFIER_KEYS) {
      parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
      parsedKeyCombo.hasModifiers = true;
    } else {
      parsedKeyCombo.key = keyName;
      parsedKeyCombo.event = event || 'keydown';
    }

    return parsedKeyCombo;
  }, {
    combo: keyComboString.split(':').shift()
  });
}

function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function (keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}

var IronA11yKeysBehavior = exports.IronA11yKeysBehavior = {
  properties: {
    /**
     * The EventTarget that will be firing relevant KeyboardEvents. Set it to
     * `null` to disable the listeners.
     * @type {?EventTarget}
     */
    keyEventTarget: {
      type: Object,
      value: function value() {
        return this;
      }
    },

    /**
     * If true, this property will cause the implementing element to
     * automatically stop propagation on any handled KeyboardEvents.
     */
    stopKeyboardEventPropagation: {
      type: Boolean,
      value: false
    },

    _boundKeyHandlers: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    // We use this due to a limitation in IE10 where instances will have
    // own properties of everything on the "prototype".
    _imperativeKeyBindings: {
      type: Object,
      value: function value() {
        return {};
      }
    }
  },

  observers: ['_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'],

  /**
   * To be used to express what combination of keys  will trigger the relative
   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
   * @type {!Object}
   */
  keyBindings: {},

  registered: function registered() {
    this._prepKeyBindings();
  },

  attached: function attached() {
    this._listenKeyEventListeners();
  },

  detached: function detached() {
    this._unlistenKeyEventListeners();
  },

  /**
   * Can be used to imperatively add a key binding to the implementing
   * element. This is the imperative equivalent of declaring a keybinding
   * in the `keyBindings` prototype property.
   *
   * @param {string} eventString
   * @param {string} handlerName
   */
  addOwnKeyBinding: function addOwnKeyBinding(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * When called, will remove all imperatively-added key bindings.
   */
  removeOwnKeyBindings: function removeOwnKeyBindings() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * Returns true if a keyboard event matches `eventString`.
   *
   * @param {KeyboardEvent} event
   * @param {string} eventString
   * @return {boolean}
   */
  keyboardEventMatchesKeys: function keyboardEventMatchesKeys(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },

  _collectKeyBindings: function _collectKeyBindings() {
    var keyBindings = this.behaviors.map(function (behavior) {
      return behavior.keyBindings;
    });

    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }

    return keyBindings;
  },

  _prepKeyBindings: function _prepKeyBindings() {
    this._keyBindings = {};

    this._collectKeyBindings().forEach(function (keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);

    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
    }

    // Give precedence to combos with modifiers to be checked first.
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function (kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return b1 === b2 ? 0 : b1 ? -1 : 1;
      });
    }
  },

  _addKeyBinding: function _addKeyBinding(eventString, handlerName) {
    parseEventString(eventString).forEach(function (keyCombo) {
      this._keyBindings[keyCombo.event] = this._keyBindings[keyCombo.event] || [];

      this._keyBindings[keyCombo.event].push([keyCombo, handlerName]);
    }, this);
  },

  _resetKeyEventListeners: function _resetKeyEventListeners() {
    this._unlistenKeyEventListeners();

    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },

  _listenKeyEventListeners: function _listenKeyEventListeners() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function (eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },

  _unlistenKeyEventListeners: function _unlistenKeyEventListeners() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;

    while (this._boundKeyHandlers.length) {
      // My kingdom for block-scope binding and destructuring assignment..
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];

      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },

  _onKeyBindingEvent: function _onKeyBindingEvent(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }

    // if event has been already prevented, don't do anything
    if (event.defaultPrevented) {
      return;
    }

    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        // exit the loop if eventDefault was prevented
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },

  _triggerKeyHandler: function _triggerKeyHandler(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event = new CustomEvent(keyCombo.event, {
      detail: detail,
      cancelable: true
    });
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronControlState = undefined;

__webpack_require__(7);

var _polymerElement = __webpack_require__(11);

var _polymerDom = __webpack_require__(17);

var IronControlState = exports.IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function value() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function value() {
        return !this.shadowRoot && !_polymerElement.Element;
      }
    }
  },

  observers: ['_changedControlState(focused, disabled)'],

  ready: function ready() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function _focusBlurHandler(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (_polymerElement.Element) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */(0, _polymerDom.dom)(event).localTarget;
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, { sourceEvent: event }, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function _disabledChanged(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function _changedControlState() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EPSG900913 = exports.EPSG3857 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(74);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = exports.EPSG3857 = Util.extend({}, _CRS.Earth, {
  code: 'EPSG:3857',
  projection: _Projection.SphericalMercator,

  transformation: function () {
    var scale = 0.5 / (Math.PI * _Projection.SphericalMercator.R);
    return (0, _Transformation.toTransformation)(scale, 0.5, -scale, 0.5);
  }()
});

var EPSG900913 = exports.EPSG900913 = Util.extend({}, EPSG3857, {
  code: 'EPSG:900913'
});

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SphericalMercator = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(5);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var SphericalMercator = exports.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function project(latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new _Point.Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function unproject(point) {
		var d = 180 / Math.PI;

		return new _LatLng.LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
	},

	bounds: function () {
		var d = 6378137 * Math.PI;
		return new _Bounds.Bounds([-d, -d], [d, d]);
	}()
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.svgCreate = svgCreate;
exports.pointsToPath = pointsToPath;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	    i,
	    j,
	    len,
	    len2,
	    points,
	    p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? Browser.svg ? 'z' : 'x' : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports._pointersCount = undefined;
exports.addPointerListener = addPointerListener;
exports.removePointerListener = removePointerListener;

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown';
var POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove';
var POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup';
var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';
var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

var _pointers = {};
var _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = exports._pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);
	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);
	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);
	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);
	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = Util.bind(function (e) {
		if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				DomEvent.preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	exports._pointersCount = _pointersCount += 1;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	exports._pointersCount = _pointersCount -= 1;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function onMove(e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
			return;
		}

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function onUp(e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.PosAnimation = undefined;

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Events = __webpack_require__(19);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = exports.PosAnimation = _Events.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function run(el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function stop() {
		if (!this._inProgress) {
			return;
		}

		this._step(true);
		this._complete();
	},

	_animate: function _animate() {
		// animation loop
		this._animId = Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function _step(round) {
		var elapsed = +new Date() - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function _runFrame(progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function _complete() {
		Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function _easeOut(t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.IconDefault = undefined;

var _Icon = __webpack_require__(30);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = exports.IconDefault = _Icon.Icon.extend({

	options: {
		iconUrl: 'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl: 'marker-shadow.png',
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize: [41, 41]
	},

	_getIconUrl: function _getIconUrl(name) {
		if (!IconDefault.imagePath) {
			// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right path.
		return (this.options.imagePath || IconDefault.imagePath) + _Icon.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function _detectIconPath() {
		var el = DomUtil.create('div', 'leaflet-default-icon-path', document.body);
		var path = DomUtil.getStyle(el, 'background-image') || DomUtil.getStyle(el, 'backgroundImage'); // IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
		}

		return path;
	}
});

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = exports.Map = undefined;

var _Map = __webpack_require__(8);

Object.defineProperty(exports, 'Map', {
  enumerable: true,
  get: function get() {
    return _Map.Map;
  }
});
Object.defineProperty(exports, 'map', {
  enumerable: true,
  get: function get() {
    return _Map.createMap;
  }
});

var _Map2 = __webpack_require__(121);

var _Map3 = __webpack_require__(122);

var _Map4 = __webpack_require__(123);

var _Map5 = __webpack_require__(124);

var _Map6 = __webpack_require__(125);

var _Map7 = __webpack_require__(126);

var _Map8 = __webpack_require__(127);

_Map.Map.BoxZoom = _Map2.BoxZoom;

_Map.Map.DoubleClickZoom = _Map3.DoubleClickZoom;

_Map.Map.Drag = _Map4.Drag;

_Map.Map.Keyboard = _Map5.Keyboard;

_Map.Map.ScrollWheelZoom = _Map6.ScrollWheelZoom;

_Map.Map.Tap = _Map7.Tap;

_Map.Map.TouchZoom = _Map8.TouchZoom;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.attribution = exports.Attribution = undefined;

var _Control = __webpack_require__(22);

var _Map = __webpack_require__(8);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = exports.Attribution = _Control.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function onAdd(map) {
		map.attributionControl = this;
		this._container = DomUtil.create('div', 'leaflet-control-attribution');
		DomEvent.disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function setPrefix(prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function addAttribution(text) {
		if (!text) {
			return this;
		}

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function removeAttribution(text) {
		if (!text) {
			return this;
		}

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function _update() {
		if (!this._map) {
			return;
		}

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
_Map.Map.mergeOptions({
	attributionControl: true
});

_Map.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = exports.attribution = function attribution(options) {
	return new Attribution(options);
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.control = exports.Control = undefined;

var _Control = __webpack_require__(22);

var _Control2 = __webpack_require__(128);

var _Control3 = __webpack_require__(129);

var _Control4 = __webpack_require__(130);

var _Control5 = __webpack_require__(80);

_Control.Control.Layers = _Control2.Layers;
_Control.Control.Zoom = _Control3.Zoom;
_Control.Control.Scale = _Control4.Scale;
_Control.Control.Attribution = _Control5.Attribution;

_Control.control.layers = _Control2.layers;
_Control.control.zoom = _Control3.zoom;
_Control.control.scale = _Control4.scale;
_Control.control.attribution = _Control5.attribution;

exports.Control = _Control.Control;
exports.control = _Control.control;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tooltip = exports.Tooltip = exports.popup = exports.Popup = exports.DivOverlay = exports.videoOverlay = exports.VideoOverlay = exports.imageOverlay = exports.ImageOverlay = exports.geoJson = exports.geoJSON = exports.GeoJSON = exports.featureGroup = exports.FeatureGroup = exports.layerGroup = exports.LayerGroup = exports.Layer = undefined;

var _Layer = __webpack_require__(12);

Object.defineProperty(exports, 'Layer', {
  enumerable: true,
  get: function get() {
    return _Layer.Layer;
  }
});

var _LayerGroup = __webpack_require__(46);

Object.defineProperty(exports, 'LayerGroup', {
  enumerable: true,
  get: function get() {
    return _LayerGroup.LayerGroup;
  }
});
Object.defineProperty(exports, 'layerGroup', {
  enumerable: true,
  get: function get() {
    return _LayerGroup.layerGroup;
  }
});

var _FeatureGroup = __webpack_require__(18);

Object.defineProperty(exports, 'FeatureGroup', {
  enumerable: true,
  get: function get() {
    return _FeatureGroup.FeatureGroup;
  }
});
Object.defineProperty(exports, 'featureGroup', {
  enumerable: true,
  get: function get() {
    return _FeatureGroup.featureGroup;
  }
});

var _ImageOverlay = __webpack_require__(50);

Object.defineProperty(exports, 'ImageOverlay', {
  enumerable: true,
  get: function get() {
    return _ImageOverlay.ImageOverlay;
  }
});
Object.defineProperty(exports, 'imageOverlay', {
  enumerable: true,
  get: function get() {
    return _ImageOverlay.imageOverlay;
  }
});

var _VideoOverlay = __webpack_require__(131);

Object.defineProperty(exports, 'VideoOverlay', {
  enumerable: true,
  get: function get() {
    return _VideoOverlay.VideoOverlay;
  }
});
Object.defineProperty(exports, 'videoOverlay', {
  enumerable: true,
  get: function get() {
    return _VideoOverlay.videoOverlay;
  }
});

var _DivOverlay = __webpack_require__(51);

Object.defineProperty(exports, 'DivOverlay', {
  enumerable: true,
  get: function get() {
    return _DivOverlay.DivOverlay;
  }
});

var _Popup = __webpack_require__(132);

Object.defineProperty(exports, 'Popup', {
  enumerable: true,
  get: function get() {
    return _Popup.Popup;
  }
});
Object.defineProperty(exports, 'popup', {
  enumerable: true,
  get: function get() {
    return _Popup.popup;
  }
});

var _Tooltip = __webpack_require__(133);

Object.defineProperty(exports, 'Tooltip', {
  enumerable: true,
  get: function get() {
    return _Tooltip.Tooltip;
  }
});
Object.defineProperty(exports, 'tooltip', {
  enumerable: true,
  get: function get() {
    return _Tooltip.tooltip;
  }
});

var _index = __webpack_require__(134);

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

var _index2 = __webpack_require__(136);

Object.keys(_index2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index2[key];
    }
  });
});

var _index3 = __webpack_require__(137);

Object.keys(_index3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index3[key];
    }
  });
});

var _GeoJSON = __webpack_require__(88);

_GeoJSON.GeoJSON.geometryToLayer = _GeoJSON.geometryToLayer;
_GeoJSON.GeoJSON.coordsToLatLng = _GeoJSON.coordsToLatLng;
_GeoJSON.GeoJSON.coordsToLatLngs = _GeoJSON.coordsToLatLngs;
_GeoJSON.GeoJSON.latLngToCoords = _GeoJSON.latLngToCoords;
_GeoJSON.GeoJSON.latLngsToCoords = _GeoJSON.latLngsToCoords;
_GeoJSON.GeoJSON.getFeature = _GeoJSON.getFeature;
_GeoJSON.GeoJSON.asFeature = _GeoJSON.asFeature;
exports.GeoJSON = _GeoJSON.GeoJSON;
exports.geoJSON = _GeoJSON.geoJSON;
exports.geoJson = _GeoJSON.geoJson;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.GridLayer = undefined;
exports.gridLayer = gridLayer;

var _Layer = __webpack_require__(12);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Point = __webpack_require__(3);

var _Bounds = __webpack_require__(5);

var _LatLngBounds = __webpack_require__(10);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */

var GridLayer = exports.GridLayer = _Layer.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function initialize(options) {
		Util.setOptions(this, options);
	},

	onAdd: function onAdd() {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function beforeAdd(map) {
		map._addZoomLimit(this);
	},

	onRemove: function onRemove(map) {
		this._removeAllTiles();
		DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = undefined;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function bringToFront() {
		if (this._map) {
			DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function bringToBack() {
		if (this._map) {
			DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function getContainer() {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function setZIndex(zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function isLoading() {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function redraw() {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function getEvents() {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overridden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function createTile() {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function getTileSize() {
		var s = this.options.tileSize;
		return s instanceof _Point.Point ? s : new _Point.Point(s, s);
	},

	_updateZIndex: function _updateZIndex() {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function _setAutoZIndex(compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function _updateOpacity() {
		if (!this._map) {
			return;
		}

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (Browser.ielt9) {
			return;
		}

		DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) {
				continue;
			}

			var fade = Math.min(1, (now - tile.loaded) / 200);

			DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) {
			this._pruneTiles();
		}

		if (nextFrame) {
			Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: Util.falseFn,

	_initContainer: function _initContainer() {
		if (this._container) {
			return;
		}

		this._container = DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function _updateLevels() {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) {
			return undefined;
		}

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			Util.falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: Util.falseFn,

	_onRemoveLevel: Util.falseFn,

	_onCreateLevel: Util.falseFn,

	_pruneTiles: function _pruneTiles() {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function _removeTilesAtZoom(zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function _removeAllTiles() {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function _invalidateAll() {
		for (var z in this._levels) {
			DomUtil.remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = undefined;
	},

	_retainParent: function _retainParent(x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new _Point.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;
		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function _retainChildren(x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new _Point.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;
				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function _resetView(e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function _animateZoom(e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function _clampZoom(zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function _setView(center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function _setZoomTransforms(center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function _setZoomTransform(level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (Browser.any3d) {
			DomUtil.setTransform(level.el, translate, scale);
		} else {
			DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function _resetGrid() {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
	},

	_onMoveEnd: function _onMoveEnd() {
		if (!this._map || this._map._animatingZoom) {
			return;
		}

		this._update();
	},

	_getTiledPixelBounds: function _getTiledPixelBounds(center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new _Bounds.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function _update(center) {
		var map = this._map;
		if (!map) {
			return;
		}
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) {
			center = map.getCenter();
		}
		if (this._tileZoom === undefined) {
			return;
		} // if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new _Bounds.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
			throw new Error('Attempted to load an infinite number of tiles');
		}

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new _Point.Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) {
			this._setView(center, zoom);return;
		}

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new _Point.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) {
					continue;
				}

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function _isValidTile(coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
				return false;
			}
		}

		if (!this.options.bounds) {
			return true;
		}

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return (0, _LatLngBounds.toLatLngBounds)(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function _keyToBounds(key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	_tileCoordsToNwSe: function _tileCoordsToNwSe(coords) {
		var map = this._map,
		    tileSize = this.getTileSize(),
		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),
		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z);
		return [nw, se];
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function _tileCoordsToBounds(coords) {
		var bp = this._tileCoordsToNwSe(coords),
		    bounds = new _LatLngBounds.LatLngBounds(bp[0], bp[1]);

		if (!this.options.noWrap) {
			bounds = this._map.wrapLatLngBounds(bounds);
		}
		return bounds;
	},
	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function _tileCoordsToKey(coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function _keyToTileCoords(key) {
		var k = key.split(':'),
		    coords = new _Point.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function _removeTile(key) {
		var tile = this._tiles[key];
		if (!tile) {
			return;
		}

		// Cancels any pending http requests associated with the tile
		// unless we're on Android's stock browser,
		// see https://github.com/Leaflet/Leaflet/issues/137
		if (!Browser.androidStock) {
			tile.el.setAttribute('src', Util.emptyImageUrl);
		}
		DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function _initTile(tile) {
		DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = Util.falseFn;
		tile.onmousemove = Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (Browser.ielt9 && this.options.opacity < 1) {
			DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (Browser.android && !Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function _addTile(coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), Util.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			Util.requestAnimFrame(Util.bind(this._tileReady, this, coords, null, tile));
		}

		DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function _tileReady(coords, err, tile) {
		if (!this._map) {
			return;
		}

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) {
			return;
		}

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			DomUtil.setOpacity(tile.el, 0);
			Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (Browser.ielt9 || !this._map._fadeAnimated) {
				Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(Util.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function _getTilePos(coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function _wrapCoords(coords) {
		var newCoords = new _Point.Point(this._wrapX ? Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {
		var tileSize = this.getTileSize();
		return new _Bounds.Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function _noTilesToLoad() {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) {
				return false;
			}
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Canvas = undefined;
exports.canvas = canvas;

var _Renderer = __webpack_require__(31);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Bounds = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = exports.Canvas = _Renderer.Renderer.extend({
	getEvents: function getEvents() {
		var events = _Renderer.Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function _onViewPreReset() {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function onAdd() {
		_Renderer.Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function _initContainer() {
		var container = this._container = document.createElement('canvas');

		DomEvent.on(container, 'mousemove', Util.throttle(this._onMouseMove, 32, this), this);
		DomEvent.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		DomEvent.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function _destroyContainer() {
		delete this._ctx;
		DomUtil.remove(this._container);
		DomEvent.off(this._container);
		delete this._container;
	},

	_updatePaths: function _updatePaths() {
		if (this._postponeUpdatePaths) {
			return;
		}

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function _update() {
		if (this._map._animatingZoom && this._bounds) {
			return;
		}

		this._drawnLayers = {};

		_Renderer.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = Browser.retina ? 2 : 1;

		DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function _reset() {
		_Renderer.Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function _initPath(layer) {
		this._updateDashArray(layer);
		this._layers[Util.stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) {
			this._drawLast.next = order;
		}
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function _addPath(layer) {
		this._requestRedraw(layer);
	},

	_removePath: function _removePath(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[L.stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function _updatePath(layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function _updateStyle(layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function _updateDashArray(layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function _requestRedraw(layer) {
		if (!this._map) {
			return;
		}

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || Util.requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function _extendRedrawBounds(layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new _Bounds.Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function _redraw() {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function _clear() {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function _draw() {
		var layer,
		    bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore(); // Restore state before clipping.
	},

	_updatePoly: function _updatePoly(layer, closed) {
		if (!this._drawing) {
			return;
		}

		var i,
		    j,
		    len2,
		    p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) {
			return;
		}

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function _updateCircle(layer) {

		if (!this._drawing || layer._empty()) {
			return;
		}

		var p = layer._point,
		    ctx = this._ctx,
		    r = Math.max(Math.round(layer._radius), 1),
		    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function _fillStroke(ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function _onClick(e) {
		var point = this._map.mouseEventToLayerPoint(e),
		    layer,
		    clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer) {
			DomEvent.fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function _onMouseMove(e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
			return;
		}

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},

	_handleMouseOut: function _handleMouseOut(e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function _handleMouseHover(e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function _fireEvent(layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function _bringToFront(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// single entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function _bringToBack(layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// single entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas(options) {
	return Browser.canvas ? new Canvas(options) : null;
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Circle = undefined;
exports.circle = circle;

var _CircleMarker = __webpack_require__(32);

var _Path = __webpack_require__(23);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _LatLng = __webpack_require__(9);

var _LatLngBounds = __webpack_require__(10);

var _CRS = __webpack_require__(16);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = exports.Circle = _CircleMarker.CircleMarker.extend({

	initialize: function initialize(latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = Util.extend({}, legacyOptions, { radius: options });
		}
		Util.setOptions(this, options);
		this._latlng = (0, _LatLng.toLatLng)(latlng);

		if (isNaN(this.options.radius)) {
			throw new Error('Circle radius cannot be NaN');
		}

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function setRadius(radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function getRadius() {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function getBounds() {
		var half = [this._radius, this._radiusY || this._radius];

		return new _LatLngBounds.LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: _Path.Path.prototype.setStyle,

	_project: function _project() {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === _CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = this._mRadius / _CRS.Earth.R / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
			this._radiusY = p.y - top.y;
		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.clipPolygon = clipPolygon;

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a separate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i,
	    j,
	    k,
	    a,
	    b,
	    len,
	    edge,
	    p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = LineUtil._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = LineUtil._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = LineUtil._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

				// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = LineUtil._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = LineUtil._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SVG = exports.create = exports.pointsToPath = undefined;
exports.svg = svg;

var _Renderer = __webpack_require__(31);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Util = __webpack_require__(0);

var _SVG = __webpack_require__(75);

var _SVG2 = __webpack_require__(139);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.pointsToPath = _SVG.pointsToPath;
var create = exports.create = Browser.vml ? _SVG2.vmlCreate : _SVG.svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = exports.SVG = _Renderer.Renderer.extend({

	getEvents: function getEvents() {
		var events = _Renderer.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function _initContainer() {
		this._container = create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function _destroyContainer() {
		DomUtil.remove(this._container);
		DomEvent.off(this._container);
		delete this._container;
		delete this._rootGroup;
		delete this._svgSize;
	},

	_onZoomStart: function _onZoomStart() {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function _update() {
		if (this._map._animatingZoom && this._bounds) {
			return;
		}

		_Renderer.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function _initPath(layer) {
		var path = layer._path = create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[(0, _Util.stamp)(layer)] = layer;
	},

	_addPath: function _addPath(layer) {
		if (!this._rootGroup) {
			this._initContainer();
		}
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function _removePath(layer) {
		DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[(0, _Util.stamp)(layer)];
	},

	_updatePath: function _updatePath(layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function _updateStyle(layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) {
			return;
		}

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function _updatePoly(layer, closed) {
		this._setPath(layer, (0, _SVG.pointsToPath)(layer._parts, closed));
	},

	_updateCircle: function _updateCircle(layer) {
		var p = layer._point,
		    r = Math.max(Math.round(layer._radius), 1),
		    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function _setPath(layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function _bringToFront(layer) {
		DomUtil.toFront(layer._path);
	},

	_bringToBack: function _bringToBack(layer) {
		DomUtil.toBack(layer._path);
	}
});

if (Browser.vml) {
	SVG.include(_SVG2.vmlMixin);
}

// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg(options) {
	return Browser.svg || Browser.vml ? new SVG(options) : null;
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.geoJson = exports.GeoJSON = undefined;
exports.geometryToLayer = geometryToLayer;
exports.coordsToLatLng = coordsToLatLng;
exports.coordsToLatLngs = coordsToLatLngs;
exports.latLngToCoords = latLngToCoords;
exports.latLngsToCoords = latLngsToCoords;
exports.getFeature = getFeature;
exports.asFeature = asFeature;
exports.geoJSON = geoJSON;

var _LayerGroup = __webpack_require__(46);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Marker = __webpack_require__(48);

var _Circle = __webpack_require__(85);

var _CircleMarker = __webpack_require__(32);

var _Polyline = __webpack_require__(56);

var _Polygon = __webpack_require__(57);

var _LatLng = __webpack_require__(9);

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = exports.GeoJSON = _FeatureGroup.FeatureGroup.extend({

	/* @section
  * @aka GeoJSON options
  *
  * @option pointToLayer: Function = *
  * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
  * called when data is added, passing the GeoJSON point feature and its `LatLng`.
  * The default is to spawn a default `Marker`:
  * ```js
  * function(geoJsonPoint, latlng) {
  * 	return L.marker(latlng);
  * }
  * ```
  *
  * @option style: Function = *
  * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
  * called internally when data is added.
  * The default value is to not override any defaults:
  * ```js
  * function (geoJsonFeature) {
  * 	return {}
  * }
  * ```
  *
  * @option onEachFeature: Function = *
  * A `Function` that will be called once for each created `Feature`, after it has
  * been created and styled. Useful for attaching events and popups to features.
  * The default is to do nothing with the newly created layers:
  * ```js
  * function (feature, layer) {}
  * ```
  *
  * @option filter: Function = *
  * A `Function` that will be used to decide whether to include a feature or not.
  * The default is to include all features:
  * ```js
  * function (geoJsonFeature) {
  * 	return true;
  * }
  * ```
  * Note: dynamically changing the `filter` option will have effect only on newly
  * added data. It will _not_ re-evaluate already included features.
  *
  * @option coordsToLatLng: Function = *
  * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
  * The default is the `coordsToLatLng` static method.
  */

	initialize: function initialize(geojson, options) {
		Util.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function addData(geojson) {
		var features = Util.isArray(geojson) ? geojson : geojson.features,
		    i,
		    len,
		    feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) {
			return this;
		}

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function resetStyle(layer) {
		// reset any custom styles
		layer.options = Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function setStyle(style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function _setLayerStyle(layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
	    coords = geometry ? geometry.coordinates : null,
	    layers = [],
	    pointToLayer = options && options.pointToLayer,
	    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
	    latlng,
	    latlngs,
	    i,
	    len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
		case 'Point':
			latlng = _coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new _Marker.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = _coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new _Marker.Marker(latlng));
			}
			return new _FeatureGroup.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
			return new _Polyline.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
			return new _Polygon.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new _FeatureGroup.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
	}
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new _LatLng.LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ? [Util.formatNum(latlng.lng, precision), Util.formatNum(latlng.lat, precision), Util.formatNum(latlng.alt, precision)] : [Util.formatNum(latlng.lng, precision), Util.formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ? Util.extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function toGeoJSON(precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
_Marker.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
_Circle.Circle.include(PointToGeoJSON);
_CircleMarker.CircleMarker.include(PointToGeoJSON);

// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
_Polyline.Polyline.include({
	toGeoJSON: function toGeoJSON(precision) {
		var multi = !LineUtil.isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
_Polygon.Polygon.include({
	toGeoJSON: function toGeoJSON(precision) {
		var holes = !LineUtil.isFlat(this._latlngs),
		    multi = holes && !LineUtil.isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});

// @namespace LayerGroup
_LayerGroup.LayerGroup.include({
	toMultiPoint: function toMultiPoint(precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function toGeoJSON(precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = exports.geoJson = geoJSON;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Mercator = undefined;

var _LatLng = __webpack_require__(9);

var _Bounds = __webpack_require__(5);

var _Point = __webpack_require__(3);

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

var Mercator = exports.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new _Bounds.Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function project(latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new _Point.Point(latlng.lng * d * r, y);
	},

	unproject: function unproject(point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new _LatLng.LatLng(phi * d, point.x * d / r);
	}
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GGMapViewer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

__webpack_require__(93);

var _FeatureGroup = __webpack_require__(18);

var _Marker = __webpack_require__(48);

var _Icon = __webpack_require__(30);

var _markerIcon = __webpack_require__(118);

var _markerIcon2 = _interopRequireDefault(_markerIcon);

var _markerShadow = __webpack_require__(119);

var _markerShadow2 = _interopRequireDefault(_markerShadow);

var _leafletMap = __webpack_require__(120);

var _leafletWmsGroup = __webpack_require__(141);

var _leafletTileLayer = __webpack_require__(144);

var _leafletGeojsonPoints = __webpack_require__(145);

var _appTemplate = __webpack_require__(164);

var _appTemplate2 = _interopRequireDefault(_appTemplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var yaml = __webpack_require__(165);

var GGMapViewer = exports.GGMapViewer = function (_PolymerElement) {
  _inherits(GGMapViewer, _PolymerElement);

  _createClass(GGMapViewer, null, [{
    key: 'template',
    get: function get() {
      return _appTemplate2.default;
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        config: {
          type: String
        },
        mapTitle: {
          type: String,
          value: 'City of Garden Grove Public Maps'
        },
        flat: {
          type: Boolean,
          value: false
        },
        map: {
          type: Object
        },
        baseSource: {
          type: String
        },
        baseFormat: {
          type: String
        },
        selectedOverlay: {
          type: Object,
          observer: '_overlayChanged'
        },
        wmsGroups: {
          type: Array,
          value: []
        },
        geojsonLayers: {
          type: Array,
          value: []
        },
        baseMaps: {
          type: Array
        },
        overlayMaps: {
          type: Array
        },
        searchMarkers: {
          type: Array,
          value: [],
          observer: '_markMap'
        }
      };
    }
  }]);

  function GGMapViewer() {
    _classCallCheck(this, GGMapViewer);

    var _this = _possibleConstructorReturn(this, (GGMapViewer.__proto__ || Object.getPrototypeOf(GGMapViewer)).call(this));

    _this._markersGroup = new _FeatureGroup.FeatureGroup([]);
    return _this;
  }

  _createClass(GGMapViewer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(GGMapViewer.prototype.__proto__ || Object.getPrototypeOf(GGMapViewer.prototype), 'connectedCallback', this).call(this);

      fetch(this.config).then(function (r) {
        return r.text();
      }).then(this.initializeMap.bind(this));

      this.initializeSearch();
    }
  }, {
    key: 'initializeMap',
    value: function initializeMap(response) {
      var rjson = yaml.safeLoad(response);

      this.baseMaps = rjson.baseMaps;
      this.overlayMaps = rjson.overlayMaps;

      if (this.flat && this.overlayMaps.length > 1) {
        console.error('You cannot enable flat mode with multiple overlays at this time.');
      }

      if (this.overlayMaps.length === 1) {
        this.flat = true;
      }

      if (rjson.mapTitle) {
        this.mapTitle = rjson.mapTitle;
      }

      // iterate through groups of layers
      for (var i = 0; i < this.overlayMaps.length; i++) {
        var l = this.overlayMaps[i].layers;
        this.overlayMaps[i].flattenedLayers = [];

        // iterate through layer interaction types (always on, exclusives, optionals)
        for (var t in l) {
          this.overlayMaps[i].flattenedLayers = this.overlayMaps[i].flattenedLayers.concat(l[t]);

          // iterate through all layers
          for (var j = 0; j < l[t].length; j++) {
            l[t][j].interaction = t;

            // always on layers should always be visible
            if (t === 'alwaysOn') {
              l[t][j].visible = true;
            } else {
              if (location.hash !== '') {
                if (l[t][j].machineName === location.hash.substring(1)) {
                  l[t][j].visible = true;
                } else {
                  l[t][j].visible = false;
                }
              }
            }

            // For convenience, allow source to be globally defined, but propagate it here.
            if ((l[t][j].type === 'wms' || l[t][j].type === undefined) && l[t][j].source === undefined) {
              l[t][j].type = 'wms';
              l[t][j].source = rjson.wmsDefaultSource;
            }
          }
        }
      }

      // FIXME: hacky hardcoded initial view
      this._selectedBasemap = 0;
      if (this.baseMaps && this.baseMaps[0]) {
        this.baseSource = this.baseMaps[0].source;
        this.baseFormat = this.baseMaps[0].format;
        this.baseLayers = this.baseMaps[0].layers;
      }

      this.overlaySelect();
    }
  }, {
    key: 'initializeSearch',
    value: function initializeSearch() {
      var _this2 = this;

      this._markersGroup.addTo(this.map);

      jQuery('#search', this.shadowRoot).autocomplete({
        preventBadQueries: false,
        deferRequestBy: 200,
        minChars: 3,
        serviceUrl: '//www.ci.garden-grove.ca.us/maps/api/addresses/search',
        paramName: 'q',
        // params: { limit: 10 },
        transformResult: function transformResult(response) {
          var addresses = JSON.parse(response).addresses;
          return {
            suggestions: addresses.map(function (d) {
              return { value: d.address, data: d };
            })
          };
        },
        onSearchStart: function onSearchStart() {
          return _this2.set('searchMakers', []);
        },
        onSearchComplete: function onSearchComplete(q, s) {
          return _this2.set('searchMarkers', s.map(function (obj) {
            return { coords: [obj.data.latitude, obj.data.longitude], address: obj.data.address };
          }));
        },
        onSelect: function onSelect(obj) {
          return _this2.set('searchMarkers', [{ coords: [obj.data.latitude, obj.data.longitude], address: obj.data.address }]);
        }
      });
    }
  }, {
    key: 'toggleLayer',
    value: function toggleLayer(event) {
      // First save the current state
      var currVisible = event.model.layer.visible;

      if (event.model.layer.interaction === 'exclusives') {
        // Turn all exclusive layers off
        for (var i = 0; i < this.selectedOverlay.layers.exclusives.length; i++) {
          this.set('selectedOverlay.layers.exclusives.' + i + '.visible', false);
        }
      }

      // Compute toggle on original state
      event.model.set('layer.visible', !currVisible);

      this._parseLayers(this.selectedOverlay);
    }
  }, {
    key: 'overlaySelect',
    value: function overlaySelect(event) {
      this.selectedOverlay = event ? event.model.item : this.overlayMaps[0];

      if (this.selectedOverlay.resetViewOnSelect) {
        this.map.flyTo(this.selectedOverlay.initialCenter, this.selectedOverlay.initialZoom);
      }
    }

    // FIXE: Achtung! Uber hacky!!!

  }, {
    key: 'switchBasemap',
    value: function switchBasemap(event) {
      var idx = ++this._selectedBasemap % 2;
      this.baseSource = this.baseMaps[idx].source;
      this.baseFormat = this.baseMaps[idx].format;
      this.baseLayers = this.baseMaps[idx].layers;

      if (idx === 1) {
        event.target.style.backgroundImage = "url(./vector.png)";
      } else {
        event.target.style.backgroundImage = "url(./aerial.png)";
      }
    }
  }, {
    key: 'toggleLayersMenu',
    value: function toggleLayersMenu() {
      var layersMenu = this.shadowRoot.querySelector('main#layers-menu');
      layersMenu.classList.toggle('show');
    }
  }, {
    key: '_parseLayers',
    value: function _parseLayers(overlay) {
      var _this3 = this;

      var layers = overlay.flattenedLayers;
      var wmsLayers = {};

      // reset
      this.set('wmsGroups', []);
      this.set('geojsonLayers', []);

      layers.filter(function (l) {
        return l.visible;
      }).forEach(function (l) {
        if (l.type === 'wms') {
          // group the sources
          wmsLayers[l.source] = wmsLayers[l.source] || { layers: [], identify: false };
          wmsLayers[l.source].layers.push(l.machineName);
          wmsLayers[l.source].identify = wmsLayers[l.source].identify || l.identify;
        } else if (l.type === 'geojson') {
          _this3.push('geojsonLayers', l);
        }
      });

      // flattened the grouped WMS sources
      for (var s in wmsLayers) {
        this.push('wmsGroups', { source: s, layers: wmsLayers[s].layers, identify: wmsLayers[s].identify });
      }
    }
  }, {
    key: '_markMap',
    value: function _markMap(markersData) {
      var _this4 = this;

      this._markersGroup.clearLayers();
      if (markersData.length === 0) return;

      markersData.forEach(function (m) {
        _this4._markersGroup.addLayer(new _Marker.Marker(m.coords, {
          icon: new _Icon.Icon({
            iconUrl: _markerIcon2.default,
            shadowUrl: _markerShadow2.default,
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
          })
        }).bindPopup(m.address));
      });

      if (markersData.length === 1) this.map.flyTo(markersData[0].coords);else this.map.fitBounds(this._markersGroup.getBounds());
    }
  }, {
    key: '_isCurrentExclusive',
    value: function _isCurrentExclusive(layer) {
      return layer.visible;
    }
  }, {
    key: '_isCurrentOverlay',
    value: function _isCurrentOverlay(selected, item) {
      return selected === item;
    }
  }, {
    key: '_overlayChanged',
    value: function _overlayChanged(newOverlay) {
      this._parseLayers(newOverlay);
    }
  }, {
    key: '_overlayLayersShow',
    value: function _overlayLayersShow(selected, item) {
      if (selected === item || this.flat) return "collapse show";
      return "collapse";
    }
  }, {
    key: '_overlayItemClass',
    value: function _overlayItemClass(selected, item) {
      var defaultClass = "overlay-item d-flex justify-content-start";
      if (selected === item) return defaultClass + ' selected';
      return defaultClass;
    }

    // FIXME: make this less hardcodey

  }, {
    key: 'downloadLayer',
    value: function downloadLayer(event) {
      event.stopPropagation();
      event.preventDefault();

      // if modal is not already found in light DOM, pull from shadow DOM
      var dom = document.querySelector('#download-modal') ? document : this.shadowRoot;

      var layer = event.model.layer;
      // FIXME: hardcoded url
      var downloadURL = 'https://www.ci.garden-grove.ca.us/geoserver/gis/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=' + layer.machineName;

      jQuery('#layer-name', dom).html(layer.name);
      jQuery('#geojson-download', dom).attr('href', downloadURL + '&outputFormat=application/json');
      jQuery('#csv-download', dom).attr('href', downloadURL + '&outputFormat=csv');
      jQuery('#kml-download', dom).attr('href', downloadURL + '&outputFormat=application/vnd.google-earth.kml+xml');
      jQuery('#shapefile-download', dom).attr('href', downloadURL + '&outputFormat=SHAPE-ZIP');
      jQuery('#download-modal', dom).modal();
    }
  }]);

  return GGMapViewer;
}(_polymerElement.Element);

customElements.define('gg-map-viewer', GGMapViewer);

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertyAccessors = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _mixin = __webpack_require__(13);

var _caseMap = __webpack_require__(35);

var caseMap$0 = _interopRequireWildcard(_caseMap);

var _async = __webpack_require__(15);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var caseMap = caseMap$0;

var microtask = _async.microTask;

// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
var nativeProperties = {};
var proto = HTMLElement.prototype;
while (proto) {
  var props = Object.getOwnPropertyNames(proto);
  for (var i = 0; i < props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}

/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @private
 */
function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    var value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}

var PropertyAccessors = exports.PropertyAccessors = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends HTMLElement
   * @unrestricted
   */
  var PropertyAccessors = function (_superClass) {
    _inherits(PropertyAccessors, _superClass);

    _createClass(PropertyAccessors, null, [{
      key: 'createPropertiesForAttributes',


      /**
       * Generates property accessors for all attributes in the standard
       * static `observedAttributes` array.
       *
       * Attribute names are mapped to property names using the `dash-case` to
       * `camelCase` convention
       *
       */
      value: function createPropertiesForAttributes() {
        var a$ = this.observedAttributes;
        for (var _i = 0; _i < a$.length; _i++) {
          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[_i]));
        }
      }
    }]);

    function PropertyAccessors() {
      _classCallCheck(this, PropertyAccessors);

      /** @type {boolean} */
      var _this = _possibleConstructorReturn(this, (PropertyAccessors.__proto__ || Object.getPrototypeOf(PropertyAccessors)).call(this));

      _this.__serializing;
      /** @type {number} */
      _this.__dataCounter;
      /** @type {boolean} */
      _this.__dataEnabled;
      /** @type {boolean} */
      _this.__dataReady;
      /** @type {boolean} */
      _this.__dataInvalid;
      /** @type {!Object} */
      _this.__data;
      /** @type {Object} */
      _this.__dataPending;
      /** @type {Object} */
      _this.__dataOld;
      /** @type {Object} */
      _this.__dataProto;
      /** @type {Object} */
      _this.__dataHasAccessor;
      /** @type {Object} */
      _this.__dataInstanceProps;
      _this._initializeProperties();
      return _this;
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     */


    _createClass(PropertyAccessors, [{
      key: 'attributeChangedCallback',
      value: function attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this._attributeToProperty(name, value);
        }
      }

      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @protected
       */

    }, {
      key: '_initializeProperties',
      value: function _initializeProperties() {
        this.__serializing = false;
        this.__dataCounter = 0;
        this.__dataEnabled = false;
        this.__dataReady = false;
        this.__dataInvalid = false;
        this.__data = {};
        this.__dataPending = null;
        this.__dataOld = null;
        if (this.__dataProto) {
          this._initializeProtoProperties(this.__dataProto);
          this.__dataProto = null;
        }
        // Capture instance properties; these will be set into accessors
        // during first flush. Don't set them here, since we want
        // these to overwrite defaults/constructor assignments
        for (var p in this.__dataHasAccessor) {
          if (this.hasOwnProperty(p)) {
            this.__dataInstanceProps = this.__dataInstanceProps || {};
            this.__dataInstanceProps[p] = this[p];
            delete this[p];
          }
        }
      }

      /**
       * Called at instance time with bag of properties that were overwritten
       * by accessors on the prototype when accessors were created.
       *
       * The default implementation sets these properties back into the
       * setter at instance time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @protected
       */

    }, {
      key: '_initializeProtoProperties',
      value: function _initializeProtoProperties(props) {
        for (var p in props) {
          this._setProperty(p, props[p]);
        }
      }

      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @protected
       */

    }, {
      key: '_initializeInstanceProperties',
      value: function _initializeInstanceProperties(props) {
        Object.assign(this, props);
      }

      /**
       * Ensures the element has the given attribute. If it does not,
       * assigns the given value to the attribute.
       *
       *
       * @param {string} attribute Name of attribute to ensure is set.
       * @param {string} value of the attribute.
       */

    }, {
      key: '_ensureAttribute',
      value: function _ensureAttribute(attribute, value) {
        if (!this.hasAttribute(attribute)) {
          this._valueToNodeAttribute(this, value, attribute);
        }
      }

      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to.
       */

    }, {
      key: '_attributeToProperty',
      value: function _attributeToProperty(attribute, value, type) {
        // Don't deserialize back to property if currently reflecting
        if (!this.__serializing) {
          var property = caseMap.dashToCamelCase(attribute);
          this[property] = this._deserializeValue(value, type);
        }
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */

    }, {
      key: '_propertyToAttribute',
      value: function _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = arguments.length < 3 ? this[property] : value;
        this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));
        this.__serializing = false;
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       */

    }, {
      key: '_valueToNodeAttribute',
      value: function _valueToNodeAttribute(node, value, attribute) {
        var str = this._serializeValue(value);
        if (str === undefined) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(attribute, str);
        }
      }

      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called by Polymer when setting JS property values to
       * HTML attributes.  Users may override this method on Polymer element
       * prototypes to provide serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided property value.
       */

    }, {
      key: '_serializeValue',
      value: function _serializeValue(value) {
        /* eslint-disable no-fallthrough */
        switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
          case 'boolean':
            return value ? '' : undefined;

          case 'object':
            if (value instanceof Date) {
              return value.toString();
            } else if (value) {
              try {
                return JSON.stringify(value);
              } catch (x) {
                return '';
              }
            }

          default:
            return value != null ? value.toString() : undefined;
        }
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called by Polymer when reading HTML attribute values to
       * JS properties.  Users may override this method on Polymer element
       * prototypes to provide deserialization for custom `type`s.  Note,
       * the `type` argument is the value of the `type` field provided in the
       * `properties` configuration object for a given property, and is
       * by convention the constructor for the type to deserialize.
       *
       * Note: The return value of `undefined` is used as a sentinel value to
       * indicate the attribute should be removed.
       *
       * @param {?string} value Attribute value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       */

    }, {
      key: '_deserializeValue',
      value: function _deserializeValue(value, type) {
        /**
         * @type {*}
         */
        var outValue = void 0;
        switch (type) {
          case Number:
            outValue = Number(value);
            break;

          case Boolean:
            outValue = value !== null;
            break;

          case Object:
            try {
              outValue = JSON.parse( /** @type string */value);
            } catch (x) {
              // allow non-JSON literals like Strings and Numbers
            }
            break;

          case Array:
            try {
              outValue = JSON.parse( /** @type string */value);
            } catch (x) {
              outValue = null;
              console.warn('Polymer::Attributes: couldn\'t decode Array as JSON: ' + value);
            }
            break;

          case Date:
            outValue = new Date(value);
            break;

          case String:
          default:
            outValue = value;
            break;
        }

        return outValue;
      }
      /* eslint-enable no-fallthrough */

      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.  When calling on
       * a prototype, any overwritten values are saved in `__dataProto`,
       * and it is up to the subclasser to decide how/when to set those
       * properties back into the accessor.  When calling on an instance,
       * the overwritten value is set via `_setPendingProperty`, and the
       * user should call `_invalidateProperties` or `_flushProperties`
       * for the values to take effect.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @protected
       */

    }, {
      key: '_createPropertyAccessor',
      value: function _createPropertyAccessor(property, readOnly) {
        if (!this.hasOwnProperty('__dataHasAccessor')) {
          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
        }
        if (!this.__dataHasAccessor[property]) {
          this.__dataHasAccessor[property] = true;
          saveAccessorValue(this, property);
          Object.defineProperty(this, property, {
            /* eslint-disable valid-jsdoc */
            /** @this {PropertyAccessors} */
            get: function get() {
              return this.__data[property];
            },
            /** @this {PropertyAccessors} */
            set: readOnly ? function () {} : function (value) {
              this._setProperty(property, value);
            }
            /* eslint-enable */
          });
        }
      }

      /**
       * Returns true if this library created an accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if an accessor was created
       */

    }, {
      key: '_hasAccessor',
      value: function _hasAccessor(property) {
        return this.__dataHasAccessor && this.__dataHasAccessor[property];
      }

      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @protected
       */

    }, {
      key: '_setProperty',
      value: function _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }

      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {boolean} Returns true if the property changed
       * @protected
       */

    }, {
      key: '_setPendingProperty',
      value: function _setPendingProperty(property, value) {
        var old = this.__data[property];
        var changed = this._shouldPropertyChange(property, value, old);
        if (changed) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (this.__dataOld && !(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
        }
        return changed;
      }

      /**
       * Returns true if the specified property has a pending change.
       *
       * @param {string} prop Property name
       * @return {boolean} True if property has a pending change
       * @protected
       */

    }, {
      key: '_isPropertyPending',
      value: function _isPropertyPending(prop) {
        return Boolean(this.__dataPending && prop in this.__dataPending);
      }

      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @protected
       */

    }, {
      key: '_invalidateProperties',
      value: function _invalidateProperties() {
        var _this2 = this;

        if (!this.__dataInvalid && this.__dataReady) {
          this.__dataInvalid = true;
          microtask.run(function () {
            if (_this2.__dataInvalid) {
              _this2.__dataInvalid = false;
              _this2._flushProperties();
            }
          });
        }
      }

      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       */

    }, {
      key: '_enableProperties',
      value: function _enableProperties() {
        if (!this.__dataEnabled) {
          this.__dataEnabled = true;
          if (this.__dataInstanceProps) {
            this._initializeInstanceProperties(this.__dataInstanceProps);
            this.__dataInstanceProps = null;
          }
          this.ready();
        }
      }

      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       *
       * @protected
       */

    }, {
      key: '_flushProperties',
      value: function _flushProperties() {
        if (this.__dataPending && this.__dataOld) {
          var changedProps = this.__dataPending;
          this.__dataPending = null;
          this.__dataCounter++;
          this._propertiesChanged(this.__data, changedProps, this.__dataOld);
          this.__dataCounter--;
        }
      }

      /**
       * Lifecycle callback called the first time properties are being flushed.
       * Prior to `ready`, all property sets through accessors are queued and
       * their effects are flushed after this method returns.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its properties initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @public
       */

    }, {
      key: 'ready',
      value: function ready() {
        this.__dataReady = true;
        // Run normal flush
        this._flushProperties();
      }

      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {!Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {!Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @protected
       */

    }, {
      key: '_propertiesChanged',
      value: function _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` for primitive types if a
       * strict equality check fails, and returns `true` for all Object/Arrays.
       * The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       */

    }, {
      key: '_shouldPropertyChange',
      value: function _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check
          old !== value && (
          // This ensures (old==NaN, value==NaN) always returns false
          old === old || value === value)
        );
      }
    }]);

    return PropertyAccessors;
  }(superClass);

  return PropertyAccessors;
});

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TemplateStamp = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _mixin = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
var templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
function wrapTemplateExtension(node) {
  var is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    var t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while (t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }
  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  // unwind the stack, returning the indexed node at each level
  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}

// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}

// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}

// push configuration references at configure time
function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;
  var handler = function handler(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}

var TemplateStamp = exports.TemplateStamp = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  var TemplateStamp = function (_superClass) {
    _inherits(TemplateStamp, _superClass);

    function TemplateStamp() {
      _classCallCheck(this, TemplateStamp);

      return _possibleConstructorReturn(this, (TemplateStamp.__proto__ || Object.getPrototypeOf(TemplateStamp)).apply(this, arguments));
    }

    _createClass(TemplateStamp, [{
      key: '_stampTemplate',


      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       */
      value: function _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        var templateInfo = this.constructor._parseTemplate(template);
        var nodeInfo = templateInfo.nodeInfoList;
        var content = templateInfo.content || template.content;
        var dom = /** @type DocumentFragment */document.importNode(content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
        var nodes = dom.nodeList = new Array(nodeInfo.length);
        dom.$ = {};
        for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
          var node = nodes[i] = findTemplateNode(dom, info);
          applyIdToMap(this, dom.$, node, info);
          applyTemplateContent(this, node, info);
          applyEventListener(this, node, info);
        }
        return (/** @type {!StampedTemplate} */dom
        );
      }

      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {Node} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       */

    }, {
      key: '_addMethodEventListenerToNode',
      value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        var handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {Node} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {Function} handler Listener function to add
       */

    }, {
      key: '_addEventListenerToNode',
      value: function _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {Node} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {Function} handler Listener function to remove
       */

    }, {
      key: '_removeEventListenerFromNode',
      value: function _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }
    }], [{
      key: '_parseTemplate',


      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       */
      value: function _parseTemplate(template, outerTemplateInfo) {
        // since a template may be re-used, memo-ize metadata
        if (!template._templateInfo) {
          var templateInfo = template._templateInfo = {};
          templateInfo.nodeInfoList = [];
          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
          this._parseTemplateContent(template, templateInfo, { parent: null });
        }
        return template._templateInfo;
      }
    }, {
      key: '_parseTemplateContent',
      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {
        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
      }

      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNode',
      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {
        var noted = void 0;
        var element = /** @type Element */node;
        if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
        } else if (element.localName === 'slot') {
          // For ShadyDom optimization, indicating there is an insertion point
          templateInfo.hasInsertionPoint = true;
        }
        if (element.firstChild) {
          noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
        }
        if (element.hasAttributes && element.hasAttributes()) {
          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
        }
        return noted;
      }

      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       */

    }, {
      key: '_parseTemplateChildNodes',
      value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
        for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {
          // Wrap templates
          if (node.localName == 'template') {
            node = wrapTemplateExtension(node);
          }
          // collapse adjacent textNodes: fixes an IE issue that can cause
          // text nodes to be inexplicably split =(
          // note that root.normalize() should work but does not so we do this
          // manually.
          next = node.nextSibling;
          if (node.nodeType === Node.TEXT_NODE) {
            var /** Node */n = next;
            while (n && n.nodeType === Node.TEXT_NODE) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root.removeChild(n);
              n = next;
            }
            // optionally strip whitespace
            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
              root.removeChild(node);
              continue;
            }
          }
          var childInfo = { parentIndex: parentIndex, parentInfo: nodeInfo };
          if (this._parseTemplateNode(node, templateInfo, childInfo)) {
            childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
          }
          // Increment if not removed
          if (node.parentNode) {
            parentIndex++;
          }
        }
      }

      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNestedTemplate',
      value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
        var templateInfo = this._parseTemplate(node, outerTemplateInfo);
        var content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
        content.appendChild(node.content);
        nodeInfo.templateInfo = templateInfo;
        return true;
      }

      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNodeAttributes',
      value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
        // Make copy of original attribute list, since the order may change
        // as attributes are added and removed
        var noted = false;
        var attrs = Array.from(node.attributes);
        for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
        }
        return noted;
      }

      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */

    }, {
      key: '_parseTemplateNodeAttribute',
      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        // events (on-*)
        if (name.slice(0, 3) === 'on-') {
          node.removeAttribute(name);
          nodeInfo.events = nodeInfo.events || [];
          nodeInfo.events.push({
            name: name.slice(3),
            value: value
          });
          return true;
        }
        // static id
        else if (name === 'id') {
            nodeInfo.id = value;
            return true;
          }
        return false;
      }

      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       */

    }, {
      key: '_contentForTemplate',
      value: function _contentForTemplate(template) {
        var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
        return templateInfo && templateInfo.content || template.content;
      }
    }]);

    return TemplateStamp;
  }(superClass);

  return TemplateStamp;
});

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

__webpack_require__(107);

__webpack_require__(69);

__webpack_require__(108);

var _paperCheckedElementBehavior = __webpack_require__(109);

var _polymerFn = __webpack_require__(28);

var _renderStatus = __webpack_require__(66);

var _gestures = __webpack_require__(41);

var _paperRippleBehavior = __webpack_require__(45);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<dom-module id="paper-toggle-button">\n  <template strip-whitespace="">\n\n    <style>\n      :host {\n        display: inline-block;\n        @apply --layout-horizontal;\n        @apply --layout-center;\n        @apply --paper-font-common-base;\n      }\n\n      :host([disabled]) {\n        pointer-events: none;\n      }\n\n      :host(:focus) {\n        outline:none;\n      }\n\n      .toggle-bar {\n        position: absolute;\n        height: 100%;\n        width: 100%;\n        border-radius: 8px;\n        pointer-events: none;\n        opacity: 0.4;\n        transition: background-color linear .08s;\n        background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);\n\n        @apply --paper-toggle-button-unchecked-bar;\n      }\n\n      .toggle-button {\n        position: absolute;\n        top: -3px;\n        left: 0;\n        height: 20px;\n        width: 20px;\n        border-radius: 50%;\n        box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);\n        transition: -webkit-transform linear .08s, background-color linear .08s;\n        transition: transform linear .08s, background-color linear .08s;\n        will-change: transform;\n        background-color: var(--paper-toggle-button-unchecked-button-color, var(--paper-grey-50));\n\n        @apply --paper-toggle-button-unchecked-button;\n      }\n\n      .toggle-button.dragging {\n        -webkit-transition: none;\n        transition: none;\n      }\n\n      :host([checked]:not([disabled])) .toggle-bar {\n        opacity: 0.5;\n        background-color: var(--paper-toggle-button-checked-bar-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-bar;\n      }\n\n      :host([disabled]) .toggle-bar {\n        background-color: #000;\n        opacity: 0.12;\n      }\n\n      :host([checked]) .toggle-button {\n        -webkit-transform: translate(16px, 0);\n        transform: translate(16px, 0);\n      }\n\n      :host([checked]:not([disabled])) .toggle-button {\n        background-color: var(--paper-toggle-button-checked-button-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-button;\n      }\n\n      :host([disabled]) .toggle-button {\n        background-color: #bdbdbd;\n        opacity: 1;\n      }\n\n      .toggle-ink {\n        position: absolute;\n        top: -14px;\n        left: -14px;\n        right: auto;\n        bottom: auto;\n        width: 48px;\n        height: 48px;\n        opacity: 0.5;\n        pointer-events: none;\n        color: var(--paper-toggle-button-unchecked-ink-color, var(--primary-text-color));\n\n        @apply --paper-toggle-button-unchecked-ink;\n      }\n\n      :host([checked]) .toggle-ink {\n        color: var(--paper-toggle-button-checked-ink-color, var(--primary-color));\n\n        @apply --paper-toggle-button-checked-ink;\n      }\n\n      .toggle-container {\n        display: inline-block;\n        position: relative;\n        width: 36px;\n        height: 14px;\n        /* The toggle button has an absolute position of -3px; The extra 1px\n        /* accounts for the toggle button shadow box. */\n        margin: 4px 1px;\n      }\n\n      .toggle-label {\n        position: relative;\n        display: inline-block;\n        vertical-align: middle;\n        padding-left: var(--paper-toggle-button-label-spacing, 8px);\n        pointer-events: none;\n        color: var(--paper-toggle-button-label-color, var(--primary-text-color));\n      }\n\n      /* invalid state */\n      :host([invalid]) .toggle-bar {\n        background-color: var(--paper-toggle-button-invalid-bar-color, var(--error-color));\n      }\n\n      :host([invalid]) .toggle-button {\n        background-color: var(--paper-toggle-button-invalid-button-color, var(--error-color));\n      }\n\n      :host([invalid]) .toggle-ink {\n        color: var(--paper-toggle-button-invalid-ink-color, var(--error-color));\n      }\n    </style>\n\n    <div class="toggle-container">\n      <div id="toggleBar" class="toggle-bar"></div>\n      <div id="toggleButton" class="toggle-button"></div>\n    </div>\n\n    <div class="toggle-label"><slot></slot></div>\n\n  </template>\n\n  \n</dom-module>';

document.head.appendChild($_documentContainer);
(0, _polymerFn.Polymer)({
  is: 'paper-toggle-button',

  behaviors: [_paperCheckedElementBehavior.PaperCheckedElementBehavior],

  hostAttributes: {
    role: 'button',
    'aria-pressed': 'false',
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
  },

  listeners: {
    track: '_ontrack'
  },

  attached: function attached() {
    (0, _renderStatus.afterNextRender)(this, function () {
      (0, _gestures.setTouchAction)(this, 'pan-y');
    });
  },

  _ontrack: function _ontrack(event) {
    var track = event.detail;
    if (track.state === 'start') {
      this._trackStart(track);
    } else if (track.state === 'track') {
      this._trackMove(track);
    } else if (track.state === 'end') {
      this._trackEnd(track);
    }
  },

  _trackStart: function _trackStart(track) {
    this._width = this.$.toggleBar.offsetWidth / 2;
    /*
     * keep an track-only check state to keep the dragging behavior smooth
     * while toggling activations
     */
    this._trackChecked = this.checked;
    this.$.toggleButton.classList.add('dragging');
  },

  _trackMove: function _trackMove(track) {
    var dx = track.dx;
    this._x = Math.min(this._width, Math.max(0, this._trackChecked ? this._width + dx : dx));
    this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
    this._userActivate(this._x > this._width / 2);
  },

  _trackEnd: function _trackEnd(track) {
    this.$.toggleButton.classList.remove('dragging');
    this.transform('', this.$.toggleButton);
  },

  // customize the element's ripple
  _createRipple: function _createRipple() {
    this._rippleContainer = this.$.toggleButton;
    var ripple = _paperRippleBehavior.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('recenters', '');
    ripple.classList.add('circle', 'toggle-ink');
    return ripple;
  }

});

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


var _applyShim = __webpack_require__(95);

var _applyShim2 = _interopRequireDefault(_applyShim);

var _templateMap = __webpack_require__(62);

var _templateMap2 = _interopRequireDefault(_templateMap);

var _styleUtil = __webpack_require__(61);

var _applyShimUtils = __webpack_require__(96);

var ApplyShimUtils = _interopRequireWildcard(_applyShimUtils);

var _documentWait = __webpack_require__(63);

var _documentWait2 = _interopRequireDefault(_documentWait);

var _commonUtils = __webpack_require__(40);

var _customStyleInterface = __webpack_require__(64);

var _styleSettings = __webpack_require__(37);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** @const {ApplyShim} */
var applyShim = new _applyShim2.default();

var ApplyShimInterface = function () {
  function ApplyShimInterface() {
    var _this = this;

    _classCallCheck(this, ApplyShimInterface);

    /** @type {?CustomStyleInterfaceInterface} */
    this.customStyleInterface = null;
    (0, _documentWait2.default)(function () {
      _this.ensure();
    });
    applyShim['invalidCallback'] = ApplyShimUtils.invalidate;
  }

  _createClass(ApplyShimInterface, [{
    key: 'ensure',
    value: function ensure() {
      var _this2 = this;

      if (this.customStyleInterface) {
        return;
      }
      this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
      if (this.customStyleInterface) {
        this.customStyleInterface['transformCallback'] = function (style) {
          applyShim.transformCustomStyle(style);
        };
        this.customStyleInterface['validateCallback'] = function () {
          requestAnimationFrame(function () {
            if (_this2.customStyleInterface['enqueued']) {
              _this2.flushCustomStyles();
            }
          });
        };
      }
    }
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     */

  }, {
    key: 'prepareTemplate',
    value: function prepareTemplate(template, elementName) {
      this.ensure();
      _templateMap2.default[elementName] = template;
      var ast = applyShim.transformTemplate(template, elementName);
      // save original style ast to use for revalidating instances
      template['_styleAst'] = ast;
    }
  }, {
    key: 'flushCustomStyles',
    value: function flushCustomStyles() {
      this.ensure();
      if (!this.customStyleInterface) {
        return;
      }
      var styles = this.customStyleInterface['processStyles']();
      if (!this.customStyleInterface['enqueued']) {
        return;
      }
      for (var i = 0; i < styles.length; i++) {
        var cs = styles[i];
        var style = this.customStyleInterface['getStyleForCustomStyle'](cs);
        if (style) {
          applyShim.transformCustomStyle(style);
        }
      }
      this.customStyleInterface['enqueued'] = false;
    }
    /**
     * @param {HTMLElement} element
     * @param {Object=} properties
     */

  }, {
    key: 'styleSubtree',
    value: function styleSubtree(element, properties) {
      this.ensure();
      if (properties) {
        (0, _commonUtils.updateNativeProperties)(element, properties);
      }
      if (element.shadowRoot) {
        this.styleElement(element);
        var shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
        for (var i = 0; i < shadowChildren.length; i++) {
          this.styleSubtree( /** @type {HTMLElement} */shadowChildren[i]);
        }
      } else {
        var children = element.children || element.childNodes;
        for (var _i = 0; _i < children.length; _i++) {
          this.styleSubtree( /** @type {HTMLElement} */children[_i]);
        }
      }
    }
    /**
     * @param {HTMLElement} element
     */

  }, {
    key: 'styleElement',
    value: function styleElement(element) {
      this.ensure();

      var _getIsExtends = (0, _styleUtil.getIsExtends)(element),
          is = _getIsExtends.is;

      var template = _templateMap2.default[is];
      if (template && !ApplyShimUtils.templateIsValid(template)) {
        // only revalidate template once
        if (!ApplyShimUtils.templateIsValidating(template)) {
          this.prepareTemplate(template, is);
          ApplyShimUtils.startValidatingTemplate(template);
        }
        // update this element instance
        var root = element.shadowRoot;
        if (root) {
          var style = /** @type {HTMLStyleElement} */root.querySelector('style');
          if (style) {
            // reuse the template's style ast, it has all the original css text
            style['__cssRules'] = template['_styleAst'];
            style.textContent = (0, _styleUtil.toCssText)(template['_styleAst']);
          }
        }
      }
    }
    /**
     * @param {Object=} properties
     */

  }, {
    key: 'styleDocument',
    value: function styleDocument(properties) {
      this.ensure();
      this.styleSubtree(document.body, properties);
    }
  }]);

  return ApplyShimInterface;
}();

if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  var applyShimInterface = new ApplyShimInterface();
  var CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;

  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate: function prepareTemplate(template, elementName, elementExtends) {
      // eslint-disable-line no-unused-vars
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName);
    },


    /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */
    styleSubtree: function styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },


    /**
     * @param {!HTMLElement} element
     */
    styleElement: function styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },


    /**
     * @param {Object=} properties
     */
    styleDocument: function styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },


    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue: function getComputedStyleValue(element, property) {
      return (0, _commonUtils.getComputedStyleValue)(element, property);
    },

    nativeCss: _styleSettings.nativeCssVariables,
    nativeShadow: _styleSettings.nativeShadow
  };

  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}

window.ShadyCSS.ApplyShim = applyShim;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/*
 * The apply shim simulates the behavior of `@apply` proposed at
 * https://tabatkins.github.io/specs/css-apply-rule/.
 * The approach is to convert a property like this:
 *
 *    --foo: {color: red; background: blue;}
 *
 * to this:
 *
 *    --foo_-_color: red;
 *    --foo_-_background: blue;
 *
 * Then where `@apply --foo` is used, that is converted to:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background);
 *
 * This approach generally works but there are some issues and limitations.
 * Consider, for example, that somewhere *between* where `--foo` is set and used,
 * another element sets it to:
 *
 *    --foo: { border: 2px solid red; }
 *
 * We must now ensure that the color and background from the previous setting
 * do not apply. This is accomplished by changing the property set to this:
 *
 *    --foo_-_border: 2px solid red;
 *    --foo_-_color: initial;
 *    --foo_-_background: initial;
 *
 * This works but introduces one new issue.
 * Consider this setup at the point where the `@apply` is used:
 *
 *    background: orange;
 *    `@apply` --foo;
 *
 * In this case the background will be unset (initial) rather than the desired
 * `orange`. We address this by altering the property set to use a fallback
 * value like this:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background, orange);
 *    border: var(--foo_-_border);
 *
 * Note that the default is retained in the property set and the `background` is
 * the desired `orange`. This leads us to a limitation.
 *
 * Limitation 1:

 * Only properties in the rule where the `@apply`
 * is used are considered as default values.
 * If another rule matches the element and sets `background` with
 * less specificity than the rule in which `@apply` appears,
 * the `background` will not be set.
 *
 * Limitation 2:
 *
 * When using Polymer's `updateStyles` api, new properties may not be set for
 * `@apply` properties.

*/



Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _styleUtil = __webpack_require__(61);

var _commonRegex = __webpack_require__(39);

var _commonUtils = __webpack_require__(40);

var _cssParse = __webpack_require__(38);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// eslint-disable-line no-unused-vars

var APPLY_NAME_CLEAN = /;\s*/m;
var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;

// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
var MIXIN_VAR_SEP = '_-_';

/**
 * @typedef {!Object<string, string>}
 */
var PropertyEntry = void 0; // eslint-disable-line no-unused-vars

/**
 * @typedef {!Object<string, boolean>}
 */
var DependantsEntry = void 0; // eslint-disable-line no-unused-vars

/** @typedef {{
 *    properties: PropertyEntry,
 *    dependants: DependantsEntry
 * }}
 */
var MixinMapEntry = void 0; // eslint-disable-line no-unused-vars

// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}

var MixinMap = function () {
  function MixinMap() {
    _classCallCheck(this, MixinMap);

    /** @type {!Object<string, !MixinMapEntry>} */
    this._map = {};
  }
  /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */


  _createClass(MixinMap, [{
    key: 'set',
    value: function set(name, props) {
      name = name.trim();
      this._map[name] = {
        properties: props,
        dependants: {}
      };
    }
    /**
     * @param {string} name
     * @return {MixinMapEntry}
     */

  }, {
    key: 'get',
    value: function get(name) {
      name = name.trim();
      return this._map[name] || null;
    }
  }]);

  return MixinMap;
}();

/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */


var invalidCallback = null;

/** @unrestricted */

var ApplyShim = function () {
  function ApplyShim() {
    _classCallCheck(this, ApplyShim);

    /** @type {?string} */
    this._currentElement = null;
    /** @type {HTMLMetaElement} */
    this._measureElement = null;
    this._map = new MixinMap();
  }
  /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */


  _createClass(ApplyShim, [{
    key: 'detectMixin',
    value: function detectMixin(cssText) {
      return (0, _commonUtils.detectMixin)(cssText);
    }
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @return {StyleNode}
     */

  }, {
    key: 'transformTemplate',
    value: function transformTemplate(template, elementName) {
      var style = /** @type {HTMLStyleElement} */template.content.querySelector('style');
      /** @type {StyleNode} */
      var ast = null;
      if (style) {
        ast = this.transformStyle(style, elementName);
      }
      return ast;
    }
    /**
     * @param {!HTMLStyleElement} style
     * @param {string} elementName
     * @return {StyleNode}
     */

  }, {
    key: 'transformStyle',
    value: function transformStyle(style) {
      var elementName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var ast = (0, _styleUtil.rulesForStyle)(style);
      this.transformRules(ast, elementName);
      style.textContent = (0, _styleUtil.toCssText)(ast);
      return ast;
    }
    /**
     * @param {!HTMLStyleElement} style
     * @return {StyleNode}
     */

  }, {
    key: 'transformCustomStyle',
    value: function transformCustomStyle(style) {
      var _this = this;

      var ast = (0, _styleUtil.rulesForStyle)(style);
      (0, _styleUtil.forEachRule)(ast, function (rule) {
        if (rule['selector'] === ':root') {
          rule['selector'] = 'html';
        }
        _this.transformRule(rule);
      });
      style.textContent = (0, _styleUtil.toCssText)(ast);
      return ast;
    }
    /**
     * @param {StyleNode} rules
     * @param {string} elementName
     */

  }, {
    key: 'transformRules',
    value: function transformRules(rules, elementName) {
      var _this2 = this;

      this._currentElement = elementName;
      (0, _styleUtil.forEachRule)(rules, function (r) {
        _this2.transformRule(r);
      });
      this._currentElement = null;
    }
    /**
     * @param {!StyleNode} rule
     */

  }, {
    key: 'transformRule',
    value: function transformRule(rule) {
      rule['cssText'] = this.transformCssText(rule['parsedCssText']);
      // :root was only used for variable assignment in property shim,
      // but generates invalid selectors with real properties.
      // replace with `:host > *`, which serves the same effect
      if (rule['selector'] === ':root') {
        rule['selector'] = ':host > *';
      }
    }
    /**
     * @param {string} cssText
     * @return {string}
     */

  }, {
    key: 'transformCssText',
    value: function transformCssText(cssText) {
      var _this3 = this;

      // produce variables
      cssText = cssText.replace(_commonRegex.VAR_ASSIGN, function (matchText, propertyName, valueProperty, valueMixin) {
        return _this3._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);
      });
      // consume mixins
      return this._consumeCssProperties(cssText);
    }
    /**
     * @param {string} property
     * @return {string}
     */

  }, {
    key: '_getInitialValueForProperty',
    value: function _getInitialValueForProperty(property) {
      if (!this._measureElement) {
        this._measureElement = /** @type {HTMLMetaElement} */document.createElement('meta');
        this._measureElement.setAttribute('apply-shim-measure', '');
        this._measureElement.style.all = 'initial';
        document.head.appendChild(this._measureElement);
      }
      return window.getComputedStyle(this._measureElement).getPropertyValue(property);
    }
    /**
     * replace mixin consumption with variable consumption
     * @param {string} text
     * @return {string}
     */

  }, {
    key: '_consumeCssProperties',
    value: function _consumeCssProperties(text) {
      /** @type {Array} */
      var m = null;
      // loop over text until all mixins with defintions have been applied
      while (m = _commonRegex.MIXIN_MATCH.exec(text)) {
        var matchText = m[0];
        var mixinName = m[1];
        var idx = m.index;
        // collect properties before apply to be "defaults" if mixin might override them
        // match includes a "prefix", so find the start and end positions of @apply
        var applyPos = idx + matchText.indexOf('@apply');
        var afterApplyPos = idx + matchText.length;
        // find props defined before this @apply
        var textBeforeApply = text.slice(0, applyPos);
        var textAfterApply = text.slice(afterApplyPos);
        var defaults = this._cssTextToMap(textBeforeApply);
        var replacement = this._atApplyToCssProperties(mixinName, defaults);
        // use regex match position to replace mixin, keep linear processing time
        text = '' + textBeforeApply + replacement + textAfterApply;
        // move regex search to _after_ replacement
        _commonRegex.MIXIN_MATCH.lastIndex = idx + replacement.length;
      }
      return text;
    }
    /**
     * produce variable consumption at the site of mixin consumption
     * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
     * Example:
     *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
     *
     * @param {string} mixinName
     * @param {Object} fallbacks
     * @return {string}
     */

  }, {
    key: '_atApplyToCssProperties',
    value: function _atApplyToCssProperties(mixinName, fallbacks) {
      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
      var vars = [];
      var mixinEntry = this._map.get(mixinName);
      // if we depend on a mixin before it is created
      // make a sentinel entry in the map to add this element as a dependency for when it is defined.
      if (!mixinEntry) {
        this._map.set(mixinName, {});
        mixinEntry = this._map.get(mixinName);
      }
      if (mixinEntry) {
        if (this._currentElement) {
          mixinEntry.dependants[this._currentElement] = true;
        }
        var p = void 0,
            parts = void 0,
            f = void 0;
        for (p in mixinEntry.properties) {
          f = fallbacks && fallbacks[p];
          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
          if (f) {
            parts.push(',', f);
          }
          parts.push(')');
          vars.push(parts.join(''));
        }
      }
      return vars.join('; ');
    }

    /**
     * @param {string} property
     * @param {string} value
     * @return {string}
     */

  }, {
    key: '_replaceInitialOrInherit',
    value: function _replaceInitialOrInherit(property, value) {
      var match = INITIAL_INHERIT.exec(value);
      if (match) {
        if (match[1]) {
          // initial
          // replace `initial` with the concrete initial value for this property
          value = this._getInitialValueForProperty(property);
        } else {
          // inherit
          // with this purposfully illegal value, the variable will be invalid at
          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
          // and for inheriting values, will behave similarly
          // we cannot support the same behavior for non inheriting values like 'border'
          value = 'apply-shim-inherit';
        }
      }
      return value;
    }

    /**
     * "parse" a mixin definition into a map of properties and values
     * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
     * @param {string} text
     * @return {!Object<string, string>}
     */

  }, {
    key: '_cssTextToMap',
    value: function _cssTextToMap(text) {
      var props = text.split(';');
      var property = void 0,
          value = void 0;
      var out = {};
      for (var i = 0, p, sp; i < props.length; i++) {
        p = props[i];
        if (p) {
          sp = p.split(':');
          // ignore lines that aren't definitions like @media
          if (sp.length > 1) {
            property = sp[0].trim();
            // some properties may have ':' in the value, like data urls
            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
            out[property] = value;
          }
        }
      }
      return out;
    }

    /**
     * @param {MixinMapEntry} mixinEntry
     */

  }, {
    key: '_invalidateMixinEntry',
    value: function _invalidateMixinEntry(mixinEntry) {
      if (!invalidCallback) {
        return;
      }
      for (var elementName in mixinEntry.dependants) {
        if (elementName !== this._currentElement) {
          invalidCallback(elementName);
        }
      }
    }

    /**
     * @param {string} matchText
     * @param {string} propertyName
     * @param {?string} valueProperty
     * @param {?string} valueMixin
     * @return {string}
     */

  }, {
    key: '_produceCssProperties',
    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
      var _this4 = this;

      // handle case where property value is a mixin
      if (valueProperty) {
        // form: --mixin2: var(--mixin1), where --mixin1 is in the map
        (0, _styleUtil.processVariableAndFallback)(valueProperty, function (prefix, value) {
          if (value && _this4._map.get(value)) {
            valueMixin = '@apply ' + value + ';';
          }
        });
      }
      if (!valueMixin) {
        return matchText;
      }
      var mixinAsProperties = this._consumeCssProperties(valueMixin);
      var prefix = matchText.slice(0, matchText.indexOf('--'));
      var mixinValues = this._cssTextToMap(mixinAsProperties);
      var combinedProps = mixinValues;
      var mixinEntry = this._map.get(propertyName);
      var oldProps = mixinEntry && mixinEntry.properties;
      if (oldProps) {
        // NOTE: since we use mixin, the map of properties is updated here
        // and this is what we want.
        combinedProps = Object.assign(Object.create(oldProps), mixinValues);
      } else {
        this._map.set(propertyName, combinedProps);
      }
      var out = [];
      var p = void 0,
          v = void 0;
      // set variables defined by current mixin
      var needToInvalidate = false;
      for (p in combinedProps) {
        v = mixinValues[p];
        // if property not defined by current mixin, set initial
        if (v === undefined) {
          v = 'initial';
        }
        if (oldProps && !(p in oldProps)) {
          needToInvalidate = true;
        }
        out.push('' + propertyName + MIXIN_VAR_SEP + p + ': ' + v);
      }
      if (needToInvalidate) {
        this._invalidateMixinEntry(mixinEntry);
      }
      if (mixinEntry) {
        mixinEntry.properties = combinedProps;
      }
      // because the mixinMap is global, the mixin might conflict with
      // a different scope's simple variable definition:
      // Example:
      // some style somewhere:
      // --mixin1:{ ... }
      // --mixin2: var(--mixin1);
      // some other element:
      // --mixin1: 10px solid red;
      // --foo: var(--mixin1);
      // In this case, we leave the original variable definition in place.
      if (valueProperty) {
        prefix = matchText + ';' + prefix;
      }
      return '' + prefix + out.join('; ') + ';';
    }
  }]);

  return ApplyShim;
}();

/* exports */


ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  /** @return {?function(string)} */
  get: function get() {
    return invalidCallback;
  },

  /** @param {?function(string)} cb */
  set: function set(cb) {
    invalidCallback = cb;
  }
});

exports.default = ApplyShim;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invalidate = invalidate;
exports.invalidateTemplate = invalidateTemplate;
exports.isValid = isValid;
exports.templateIsValid = templateIsValid;
exports.isValidating = isValidating;
exports.templateIsValidating = templateIsValidating;
exports.startValidating = startValidating;
exports.startValidatingTemplate = startValidatingTemplate;
exports.elementsAreInvalid = elementsAreInvalid;

var _templateMap = __webpack_require__(62);

var _templateMap2 = _interopRequireDefault(_templateMap);

var _cssParse = __webpack_require__(38);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line no-unused-vars

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */
var CURRENT_VERSION = '_applyShimCurrentVersion';

/** @const {string} */
var NEXT_VERSION = '_applyShimNextVersion';

/** @const {string} */
var VALIDATING_VERSION = '_applyShimValidatingVersion';

/**
 * @const {Promise<void>}
 */
var promise = Promise.resolve();

/**
 * @param {string} elementName
 */
function invalidate(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */
function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  // ensure the "validating for" flag exists
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  // increment the next version
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValid(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    return templateIsValid(template);
  }
  return true;
}

/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValidating(elementName) {
  var template = _templateMap2.default[elementName];
  if (template) {
    return templateIsValidating(template);
  }
  return false;
}

/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}

/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
*/
function startValidating(elementName) {
  var template = _templateMap2.default[elementName];
  startValidatingTemplate(template);
}

/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */
function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  // however, there only needs to be one async task to clear the counters
  if (!template._validating) {
    template._validating = true;
    promise.then(function () {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
 * @return {boolean}
 */
function elementsAreInvalid() {
  for (var elementName in _templateMap2.default) {
    var template = _templateMap2.default[elementName];
    if (!templateIsValid(template)) {
      return true;
    }
  }
  return false;
}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.importHref = undefined;

__webpack_require__(2);

// run a callback when HTMLImports are ready or immediately if
// this api is not available.
function whenImportsReady(cb) {
  if (window.HTMLImports) {
    HTMLImports.whenReady(cb);
  } else {
    cb();
  }
}

var importHref = exports.importHref = function importHref(href, onload, onerror, optAsync) {
  var link = /** @type {HTMLLinkElement} */
  document.head.querySelector('link[href="' + href + '"][import-href]');
  if (!link) {
    link = /** @type {HTMLLinkElement} */document.createElement('link');
    link.rel = 'import';
    link.href = href;
    link.setAttribute('import-href', '');
  }
  // always ensure link has `async` attribute if user specified one,
  // even if it was previously not async. This is considered less confusing.
  if (optAsync) {
    link.setAttribute('async', '');
  }
  // NOTE: the link may now be in 3 states: (1) pending insertion,
  // (2) inflight, (3) already laoded. In each case, we need to add
  // event listeners to process callbacks.
  var cleanup = function cleanup() {
    link.removeEventListener('load', loadListener);
    link.removeEventListener('error', errorListener);
  };
  var loadListener = function loadListener(event) {
    cleanup();
    // In case of a successful load, cache the load event on the link so
    // that it can be used to short-circuit this method in the future when
    // it is called with the same href param.
    link.__dynamicImportLoaded = true;
    if (onload) {
      whenImportsReady(function () {
        onload(event);
      });
    }
  };
  var errorListener = function errorListener(event) {
    cleanup();
    // In case of an error, remove the link from the document so that it
    // will be automatically created again the next time `importHref` is
    // called.
    if (link.parentNode) {
      link.parentNode.removeChild(link);
    }
    if (onerror) {
      whenImportsReady(function () {
        onerror(event);
      });
    }
  };
  link.addEventListener('load', loadListener);
  link.addEventListener('error', errorListener);
  if (link.parentNode == null) {
    document.head.appendChild(link);
    // if the link already loaded, dispatch a fake load event
    // so that listeners are called and get a proper event argument.
  } else if (link.__dynamicImportLoaded) {
    link.dispatchEvent(new Event('load'));
  }
  return link;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function resolve() {
  document.body.removeAttribute('unresolved');
}

if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mixinBehaviors = exports.Class = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _legacyElementMixin = __webpack_require__(60);

var _domModule = __webpack_require__(59);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var metaProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  // meta objects
  behaviors: true
};

/**
 * Applies a "legacy" behavior or array of behaviors to the provided class.
 *
 * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
 * to ensure that any legacy behaviors can rely on legacy Polymer API on
 * the underlying element.
 *
 * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
 * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
 * @return {function(new:HTMLElement)} Returns a new Element class extended by the
 * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
 * @memberof Polymer
 * @suppress {invalidCasts, checkTypes}
 */
function mixinBehaviors(behaviors, klass) {
  if (!behaviors) {
    return (/** @type {HTMLElement} */klass
    );
  }
  // NOTE: ensure the bahevior is extending a class with
  // legacy element api. This is necessary since behaviors expect to be able
  // to access 1.x legacy api.
  klass = (0, _legacyElementMixin.LegacyElementMixin)(klass);
  if (!Array.isArray(behaviors)) {
    behaviors = [behaviors];
  }
  var superBehaviors = klass.prototype.behaviors;
  // get flattened, deduped list of behaviors *not* already on super class
  behaviors = flattenBehaviors(behaviors, null, superBehaviors);
  // mixin new behaviors
  klass = _mixinBehaviors(behaviors, klass);
  if (superBehaviors) {
    behaviors = superBehaviors.concat(behaviors);
  }
  // Set behaviors on prototype for BC...
  klass.prototype.behaviors = behaviors;
  return klass;
}

// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function _mixinBehaviors(behaviors, klass) {
  for (var i = 0; i < behaviors.length; i++) {
    var b = behaviors[i];
    if (b) {
      klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
    }
  }
  return klass;
}

/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (var i = behaviors.length - 1; i >= 0; i--) {
    var b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        // dedup
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}

/**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */
function GenerateClassFromInfo(info, Base) {
  var PolymerGenerated = function (_Base) {
    _inherits(PolymerGenerated, _Base);

    function PolymerGenerated() {
      _classCallCheck(this, PolymerGenerated);

      return _possibleConstructorReturn(this, (PolymerGenerated.__proto__ || Object.getPrototypeOf(PolymerGenerated)).apply(this, arguments));
    }

    _createClass(PolymerGenerated, [{
      key: 'created',
      value: function created() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'created', this).call(this);
        if (info.created) {
          info.created.call(this);
        }
      }
    }, {
      key: '_registered',
      value: function _registered() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_registered', this).call(this);
        /* NOTE: `beforeRegister` is called here for bc, but the behavior
         is different than in 1.x. In 1.0, the method was called *after*
         mixing prototypes together but *before* processing of meta-objects.
         However, dynamic effects can still be set here and can be done either
         in `beforeRegister` or `registered`. It is no longer possible to set
         `is` in `beforeRegister` as you could in 1.x.
        */
        if (info.beforeRegister) {
          info.beforeRegister.call(Object.getPrototypeOf(this));
        }
        if (info.registered) {
          info.registered.call(Object.getPrototypeOf(this));
        }
      }
    }, {
      key: '_applyListeners',
      value: function _applyListeners() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_applyListeners', this).call(this);
        if (info.listeners) {
          for (var l in info.listeners) {
            this._addMethodEventListenerToNode(this, l, info.listeners[l]);
          }
        }
      }

      // note: exception to "super then me" rule;
      // do work before calling super so that super attributes
      // only apply if not already set.

    }, {
      key: '_ensureAttributes',
      value: function _ensureAttributes() {
        if (info.hostAttributes) {
          for (var a in info.hostAttributes) {
            this._ensureAttribute(a, info.hostAttributes[a]);
          }
        }
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), '_ensureAttributes', this).call(this);
      }
    }, {
      key: 'ready',
      value: function ready() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'ready', this).call(this);
        if (info.ready) {
          info.ready.call(this);
        }
      }
    }, {
      key: 'attached',
      value: function attached() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attached', this).call(this);
        if (info.attached) {
          info.attached.call(this);
        }
      }
    }, {
      key: 'detached',
      value: function detached() {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'detached', this).call(this);
        if (info.detached) {
          info.detached.call(this);
        }
      }
    }, {
      key: 'attributeChanged',
      value: function attributeChanged(name, old, value) {
        _get(PolymerGenerated.prototype.__proto__ || Object.getPrototypeOf(PolymerGenerated.prototype), 'attributeChanged', this).call(this, name, old, value);
        if (info.attributeChanged) {
          info.attributeChanged.call(this, name, old, value);
        }
      }
    }], [{
      key: 'properties',
      get: function get() {
        return info.properties;
      }
    }, {
      key: 'observers',
      get: function get() {
        return info.observers;
      }

      /**
       * @return {HTMLTemplateElement} template for this class
       */

    }, {
      key: 'template',
      get: function get() {
        // get template first from any imperative set in `info._template`
        return info._template ||
        // next look in dom-module associated with this element's is.
        _domModule.DomModule && _domModule.DomModule.import(this.is, 'template') ||
        // next look for superclass template (note: use superclass symbol
        // to ensure correct `this.is`)
        Base.template ||
        // finally fall back to `_template` in element's protoype.
        this.prototype._template || null;
      }
    }]);

    return PolymerGenerated;
  }(Base);

  PolymerGenerated.generatedFrom = info;

  for (var p in info) {
    // NOTE: cannot copy `metaProps` methods onto prototype at least because
    // `super.ready` must be called and is not included in the user fn.
    if (!(p in metaProps)) {
      var pd = Object.getOwnPropertyDescriptor(info, p);
      if (pd) {
        Object.defineProperty(PolymerGenerated.prototype, p, pd);
      }
    }
  }

  return PolymerGenerated;
}

var Class = exports.Class = function Class(info) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  var klass = GenerateClassFromInfo(info, info.behaviors ?
  // note: mixinBehaviors ensures `LegacyElementMixin`.
  mixinBehaviors(info.behaviors, HTMLElement) : (0, _legacyElementMixin.LegacyElementMixin)(HTMLElement));
  // decorate klass with registration info
  klass.is = info.is;
  return klass;
};

exports.mixinBehaviors = mixinBehaviors;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Templatizer = undefined;

var _templatize = __webpack_require__(43);

var TemplateInstanceBase = _templatize.TemplateInstanceBase; // eslint-disable-line

/**
 * @typedef {{
 *   _templatizerTemplate: HTMLTemplateElement,
 *   _parentModel: boolean,
 *   _instanceProps: Object,
 *   _forwardHostPropV2: Function,
 *   _notifyInstancePropV2: Function,
 *   ctor: TemplateInstanceBase
 * }}
 */
var TemplatizerUser = void 0; // eslint-disable-line

/**
 * The `Polymer.Templatizer` behavior adds methods to generate instances of
 * templates that are each managed by an anonymous `Polymer.PropertyEffects`
 * instance where data-bindings in the stamped template content are bound to
 * accessors on itself.
 *
 * This behavior is provided in Polymer 2.x as a hybrid-element convenience
 * only.  For non-hybrid usage, the `Polymer.Templatize` library
 * should be used instead.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     this.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = this.stamp({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. light DOM
 *     Polymer.dom(this).appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * Users of `Templatizer` may need to implement the following abstract
 * API's to determine how properties and paths from the host should be
 * forwarded into to instances:
 *
 *     _forwardHostPropV2: function(prop, value)
 *
 * Likewise, users may implement these additional abstract API's to determine
 * how instance-specific properties that change on the instance should be
 * forwarded out to the host, if necessary.
 *
 *     _notifyInstancePropV2: function(inst, prop, value)
 *
 * In order to determine which properties are instance-specific and require
 * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
 * object containing keys for each instance prop, for example:
 *
 *     _instanceProps: {
 *       item: true,
 *       index: true
 *     }
 *
 * Any properties used in the template that are not defined in _instanceProp
 * will be forwarded out to the Templatize `owner` automatically.
 *
 * Users may also implement the following abstract function to show or
 * hide any DOM generated using `stamp`:
 *
 *     _showHideChildren: function(shouldHide)
 *
 * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
 * as the implementations will need to differ from the callbacks required
 * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
 * between versions 1.x and 2.x.
 *
 * @polymerBehavior
 * @memberof Polymer
 */
var Templatizer = {

  /**
   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
   * for the provided template.  This method should be called once per
   * template to prepare an element for stamping the template, followed
   * by `stamp` to create new instances of the template.
   *
   * @param {HTMLTemplateElement} template Template to prepare
   * @param {boolean=} mutableData When `true`, the generated class will skip
   *   strict dirty-checking for objects and arrays (always consider them to
   *   be "dirty"). Defaults to false.
   * @this {TemplatizerUser}
   */
  templatize: function templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = _templatize.Templatize.templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },


  /**
   * Creates an instance of the template prepared by `templatize`.  The object
   * returned is an instance of the anonymous class generated by `templatize`
   * whose `root` property is a document fragment containing newly cloned
   * template content, and which has property accessors corresponding to
   * properties referenced in template bindings.
   *
   * @param {Object=} model Object containing initial property values to
   *   populate into the template bindings.
   * @return {TemplateInstanceBase} Returns the created instance of
   * the template prepared by `templatize`.
   * @this {TemplatizerUser}
   */
  stamp: function stamp(model) {
    return new this.ctor(model);
  },


  /**
   * Returns the template "model" (`TemplateInstance`) associated with
   * a given element, which serves as the binding scope for the template
   * instance the element is contained in.  A template model should be used
   * to manipulate data associated with this template instance.
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   * @this {TemplatizerUser}
   */
  modelForElement: function modelForElement(el) {
    return _templatize.Templatize.modelForElement(this._templatizerTemplate, el);
  }
};

exports.Templatizer = Templatizer;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomBind = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(2);

var _propertyEffects = __webpack_require__(36);

var _mutableData = __webpack_require__(29);

var _gestureEventListeners = __webpack_require__(65);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 */
var domBindBase = (0, _gestureEventListeners.GestureEventListeners)((0, _mutableData.OptionalMutableData)((0, _propertyEffects.PropertyEffects)(HTMLElement)));

/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @appliesMixin Polymer.OptionalMutableData
 * @appliesMixin Polymer.GestureEventListeners
 * @extends {domBindBase}
 * @memberof Polymer
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */

var DomBind = function (_domBindBase) {
  _inherits(DomBind, _domBindBase);

  _createClass(DomBind, null, [{
    key: 'observedAttributes',
    get: function get() {
      return ['mutable-data'];
    }
  }]);

  function DomBind() {
    _classCallCheck(this, DomBind);

    var _this = _possibleConstructorReturn(this, (DomBind.__proto__ || Object.getPrototypeOf(DomBind)).call(this));

    _this.root = null;
    _this.$ = null;
    _this.__children = null;
    return _this;
  }

  // assumes only one observed attribute


  _createClass(DomBind, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback() {
      this.mutableData = true;
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.render();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.__removeChildren();
    }
  }, {
    key: '__insertChildren',
    value: function __insertChildren() {
      this.parentNode.insertBefore(this.root, this);
    }
  }, {
    key: '__removeChildren',
    value: function __removeChildren() {
      if (this.__children) {
        for (var i = 0; i < this.__children.length; i++) {
          this.root.appendChild(this.__children[i]);
        }
      }
    }

    /**
     * Forces the element to render its content. This is typically only
     * necessary to call if HTMLImports with the async attribute are used.
     */

  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var template = void 0;
      if (!this.__children) {
        template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
        if (!template) {
          // Wait until childList changes and template should be there by then
          var observer = new MutationObserver(function () {
            template = /** @type {HTMLTemplateElement} */_this2.querySelector('template');
            if (template) {
              observer.disconnect();
              _this2.render();
            } else {
              throw new Error('dom-bind requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return;
        }
        this.root = this._stampTemplate(template);
        this.$ = this.root.$;
        this.__children = [];
        for (var n = this.root.firstChild; n; n = n.nextSibling) {
          this.__children[this.__children.length] = n;
        }
        this._enableProperties();
      }
      this.__insertChildren();
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
    }
  }]);

  return DomBind;
}(domBindBase);

customElements.define('dom-bind', DomBind);

exports.DomBind = DomBind;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DomIf = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _templatize = __webpack_require__(43);

var _debounce = __webpack_require__(27);

var _flush = __webpack_require__(42);

var _async = __webpack_require__(15);

var _path = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsey, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends Polymer.Element
 * @memberof Polymer
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */
var DomIf = function (_Element) {
  _inherits(DomIf, _Element);

  _createClass(DomIf, null, [{
    key: 'is',


    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'dom-if';
    }
  }, {
    key: 'template',
    get: function get() {
      return null;
    }
  }, {
    key: 'properties',
    get: function get() {

      return {

        /**
         * Fired whenever DOM is added or removed/hidden by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */

        /**
         * A boolean indicating whether this template should stamp.
         */
        if: {
          type: Boolean,
          observer: '__debounceRender'
        },

        /**
         * When true, elements will be removed from DOM and discarded when `if`
         * becomes false and re-created and added back to the DOM when `if`
         * becomes true.  By default, stamped elements will be hidden but left
         * in the DOM when `if` becomes false, which is generally results
         * in better performance.
         */
        restamp: {
          type: Boolean,
          observer: '__debounceRender'
        }

      };
    }
  }]);

  function DomIf() {
    _classCallCheck(this, DomIf);

    var _this = _possibleConstructorReturn(this, (DomIf.__proto__ || Object.getPrototypeOf(DomIf)).call(this));

    _this.__renderDebouncer = null;
    _this.__invalidProps = null;
    _this.__instance = null;
    _this._lastIf = false;
    _this.__ctor = null;
    return _this;
  }

  _createClass(DomIf, [{
    key: '__debounceRender',
    value: function __debounceRender() {
      var _this2 = this;

      // Render is async for 2 reasons:
      // 1. To eliminate dom creation trashing if user code thrashes `if` in the
      //    same turn. This was more common in 1.x where a compound computed
      //    property could result in the result changing multiple times, but is
      //    mitigated to a large extent by batched property processing in 2.x.
      // 2. To avoid double object propagation when a bag including values bound
      //    to the `if` property as well as one or more hostProps could enqueue
      //    the <dom-if> to flush before the <template>'s host property
      //    forwarding. In that scenario creating an instance would result in
      //    the host props being set once, and then the enqueued changes on the
      //    template would set properties a second time, potentially causing an
      //    object to be set to an instance more than once.  Creating the
      //    instance async from flushing data ensures this doesn't happen. If
      //    we wanted a sync option in the future, simply having <dom-if> flush
      //    (or clear) its template's pending host properties before creating
      //    the instance would also avoid the problem.
      this.__renderDebouncer = _debounce.Debouncer.debounce(this.__renderDebouncer, _async.microTask, function () {
        return _this2.__render();
      });
      (0, _flush.enqueueDebouncer)(this.__renderDebouncer);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'disconnectedCallback', this).call(this);
      if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
        this.__teardownInstance();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(DomIf.prototype.__proto__ || Object.getPrototypeOf(DomIf.prototype), 'connectedCallback', this).call(this);
      if (this.if) {
        this.__debounceRender();
      }
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     */

  }, {
    key: 'render',
    value: function render() {
      (0, _flush.flush)();
    }
  }, {
    key: '__render',
    value: function __render() {
      if (this.if) {
        if (!this.__ensureInstance()) {
          // No template found yet
          return;
        }
        this._showHideChildren();
      } else if (this.restamp) {
        this.__teardownInstance();
      }
      if (!this.restamp && this.__instance) {
        this._showHideChildren();
      }
      if (this.if != this._lastIf) {
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        this._lastIf = this.if;
      }
    }
  }, {
    key: '__ensureInstance',
    value: function __ensureInstance() {
      var _this3 = this;

      var parentNode = this.parentNode;
      // Guard against element being detached while render was queued
      if (parentNode) {
        if (!this.__ctor) {
          var template = this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              if (_this3.querySelector('template')) {
                observer.disconnect();
                _this3.__render();
              } else {
                throw new Error('dom-if requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          this.__ctor = _templatize.Templatize.templatize(template, this, {
            // dom-if templatizer instances require `mutable: true`, as
            // `__syncHostProperties` relies on that behavior to sync objects
            mutableData: true,
            /**
             * @param {string} prop Property to forward
             * @param {*} value Value of property
             * @this {this}
             */
            forwardHostProp: function forwardHostProp(prop, value) {
              if (this.__instance) {
                if (this.if) {
                  this.__instance.forwardHostProp(prop, value);
                } else {
                  // If we have an instance but are squelching host property
                  // forwarding due to if being false, note the invalidated
                  // properties so `__syncHostProperties` can sync them the next
                  // time `if` becomes true
                  this.__invalidProps = this.__invalidProps || Object.create(null);
                  this.__invalidProps[(0, _path.root)(prop)] = true;
                }
              }
            }
          });
        }
        if (!this.__instance) {
          this.__instance = new this.__ctor();
          parentNode.insertBefore(this.__instance.root, this);
        } else {
          this.__syncHostProperties();
          var c$ = this.__instance.children;
          if (c$ && c$.length) {
            // Detect case where dom-if was re-attached in new position
            var lastChild = this.previousSibling;
            if (lastChild !== c$[c$.length - 1]) {
              for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                parentNode.insertBefore(n, this);
              }
            }
          }
        }
      }
      return true;
    }
  }, {
    key: '__syncHostProperties',
    value: function __syncHostProperties() {
      var props = this.__invalidProps;
      if (props) {
        for (var prop in props) {
          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
        }
        this.__invalidProps = null;
        this.__instance._flushProperties();
      }
    }
  }, {
    key: '__teardownInstance',
    value: function __teardownInstance() {
      if (this.__instance) {
        var c$ = this.__instance.children;
        if (c$ && c$.length) {
          // use first child parent, for case when dom-if may have been detached
          var parent = c$[0].parentNode;
          for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
            parent.removeChild(n);
          }
        }
        this.__instance = null;
        this.__invalidProps = null;
      }
    }
  }, {
    key: '_showHideChildren',
    value: function _showHideChildren() {
      var hidden = this.__hideTemplateChildren__ || !this.if;
      if (this.__instance) {
        this.__instance._showHideChildren(hidden);
      }
    }
  }]);

  return DomIf;
}(_polymerElement.Element);

customElements.define(DomIf.is, DomIf);

exports.DomIf = DomIf;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArraySelector = exports.ArraySelectorMixin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _mixin = __webpack_require__(13);

var _arraySplice = __webpack_require__(68);

var _elementMixin = __webpack_require__(33);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin Polymer.ElementMixin
 * @memberof Polymer
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */
var ArraySelectorMixin = (0, _mixin.dedupingMixin)(function (superClass) {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_ElementMixin}
   */
  var elementBase = (0, _elementMixin.ElementMixin)(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */

  var ArraySelectorMixin = function (_elementBase) {
    _inherits(ArraySelectorMixin, _elementBase);

    _createClass(ArraySelectorMixin, null, [{
      key: 'properties',
      get: function get() {

        return {

          /**
           * An array containing items from which selection will be made.
           */
          items: {
            type: Array
          },

          /**
           * When `true`, multiple items may be selected at once (in this case,
           * `selected` is an array of currently selected items).  When `false`,
           * only one item may be selected at a time.
           */
          multi: {
            type: Boolean,
            value: false
          },

          /**
           * When `multi` is true, this is an array that contains any selected.
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?(Object|Array<!Object>)}
           */
          selected: {
            type: Object,
            notify: true
          },

          /**
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?Object}
           */
          selectedItem: {
            type: Object,
            notify: true
          },

          /**
           * When `true`, calling `select` on an item that is already selected
           * will deselect the item.
           */
          toggle: {
            type: Boolean,
            value: false
          }

        };
      }
    }, {
      key: 'observers',
      get: function get() {
        return ['__updateSelection(multi, items.*)'];
      }
    }]);

    function ArraySelectorMixin() {
      _classCallCheck(this, ArraySelectorMixin);

      var _this = _possibleConstructorReturn(this, (ArraySelectorMixin.__proto__ || Object.getPrototypeOf(ArraySelectorMixin)).call(this));

      _this.__lastItems = null;
      _this.__lastMulti = null;
      _this.__selectedMap = null;
      return _this;
    }

    _createClass(ArraySelectorMixin, [{
      key: '__updateSelection',
      value: function __updateSelection(multi, itemsInfo) {
        var path = itemsInfo.path;
        if (path == 'items') {
          // Case 1 - items array changed, so diff against previous array and
          // deselect any removed items and adjust selected indices
          var newItems = itemsInfo.base || [];
          var lastItems = this.__lastItems;
          var lastMulti = this.__lastMulti;
          if (multi !== lastMulti) {
            this.clearSelection();
          }
          if (lastItems) {
            var splices = (0, _arraySplice.calculateSplices)(newItems, lastItems);
            this.__applySplices(splices);
          }
          this.__lastItems = newItems;
          this.__lastMulti = multi;
        } else if (itemsInfo.path == 'items.splices') {
          // Case 2 - got specific splice information describing the array mutation:
          // deselect any removed items and adjust selected indices
          this.__applySplices(itemsInfo.value.indexSplices);
        } else {
          // Case 3 - an array element was changed, so deselect the previous
          // item for that index if it was previously selected
          var part = path.slice('items.'.length);
          var idx = parseInt(part, 10);
          if (part.indexOf('.') < 0 && part == idx) {
            this.__deselectChangedIdx(idx);
          }
        }
      }
    }, {
      key: '__applySplices',
      value: function __applySplices(splices) {
        var _this2 = this;

        var selected = this.__selectedMap;
        // Adjust selected indices and mark removals

        var _loop = function _loop(i) {
          var s = splices[i];
          selected.forEach(function (idx, item) {
            if (idx < s.index) {
              // no change
            } else if (idx >= s.index + s.removed.length) {
              // adjust index
              selected.set(item, idx + s.addedCount - s.removed.length);
            } else {
              // remove index
              selected.set(item, -1);
            }
          });
          for (var j = 0; j < s.addedCount; j++) {
            var idx = s.index + j;
            if (selected.has(_this2.items[idx])) {
              selected.set(_this2.items[idx], idx);
            }
          }
        };

        for (var i = 0; i < splices.length; i++) {
          _loop(i);
        }
        // Update linked paths
        this.__updateLinks();
        // Remove selected items that were removed from the items array
        var sidx = 0;
        selected.forEach(function (idx, item) {
          if (idx < 0) {
            if (_this2.multi) {
              _this2.splice('selected', sidx, 1);
            } else {
              _this2.selected = _this2.selectedItem = null;
            }
            selected.delete(item);
          } else {
            sidx++;
          }
        });
      }
    }, {
      key: '__updateLinks',
      value: function __updateLinks() {
        var _this3 = this;

        this.__dataLinkedPaths = {};
        if (this.multi) {
          var sidx = 0;
          this.__selectedMap.forEach(function (idx) {
            if (idx >= 0) {
              _this3.linkPaths('items.' + idx, 'selected.' + sidx++);
            }
          });
        } else {
          this.__selectedMap.forEach(function (idx) {
            _this3.linkPaths('selected', 'items.' + idx);
            _this3.linkPaths('selectedItem', 'items.' + idx);
          });
        }
      }

      /**
       * Clears the selection state.
       *
       */

    }, {
      key: 'clearSelection',
      value: function clearSelection() {
        // Unbind previous selection
        this.__dataLinkedPaths = {};
        // The selected map stores 3 pieces of information:
        // key: items array object
        // value: items array index
        // order: selected array index
        this.__selectedMap = new Map();
        // Initialize selection
        this.selected = this.multi ? [] : null;
        this.selectedItem = null;
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {*} item Item from `items` array to test
       * @return {boolean} Whether the item is selected
       */

    }, {
      key: 'isSelected',
      value: function isSelected(item) {
        return this.__selectedMap.has(item);
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {number} idx Index from `items` array to test
       * @return {boolean} Whether the item is selected
       */

    }, {
      key: 'isIndexSelected',
      value: function isIndexSelected(idx) {
        return this.isSelected(this.items[idx]);
      }
    }, {
      key: '__deselectChangedIdx',
      value: function __deselectChangedIdx(idx) {
        var _this4 = this;

        var sidx = this.__selectedIndexForItemIndex(idx);
        if (sidx >= 0) {
          var i = 0;
          this.__selectedMap.forEach(function (idx, item) {
            if (sidx == i++) {
              _this4.deselect(item);
            }
          });
        }
      }
    }, {
      key: '__selectedIndexForItemIndex',
      value: function __selectedIndexForItemIndex(idx) {
        var selected = this.__dataLinkedPaths['items.' + idx];
        if (selected) {
          return parseInt(selected.slice('selected.'.length), 10);
        }
      }

      /**
       * Deselects the given item if it is already selected.
       *
       * @param {*} item Item from `items` array to deselect
       */

    }, {
      key: 'deselect',
      value: function deselect(item) {
        var idx = this.__selectedMap.get(item);
        if (idx >= 0) {
          this.__selectedMap.delete(item);
          var sidx = void 0;
          if (this.multi) {
            sidx = this.__selectedIndexForItemIndex(idx);
          }
          this.__updateLinks();
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
        }
      }

      /**
       * Deselects the given index if it is already selected.
       *
       * @param {number} idx Index from `items` array to deselect
       */

    }, {
      key: 'deselectIndex',
      value: function deselectIndex(idx) {
        this.deselect(this.items[idx]);
      }

      /**
       * Selects the given item.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {*} item Item from `items` array to select
       */

    }, {
      key: 'select',
      value: function select(item) {
        this.selectIndex(this.items.indexOf(item));
      }

      /**
       * Selects the given index.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {number} idx Index from `items` array to select
       */

    }, {
      key: 'selectIndex',
      value: function selectIndex(idx) {
        var item = this.items[idx];
        if (!this.isSelected(item)) {
          if (!this.multi) {
            this.__selectedMap.clear();
          }
          this.__selectedMap.set(item, idx);
          this.__updateLinks();
          if (this.multi) {
            this.push('selected', item);
          } else {
            this.selected = this.selectedItem = item;
          }
        } else if (this.toggle) {
          this.deselectIndex(idx);
        }
      }
    }]);

    return ArraySelectorMixin;
  }(elementBase);

  return ArraySelectorMixin;
});

exports.ArraySelectorMixin = ArraySelectorMixin;

/**
 * @constructor
 * @extends {Polymer.Element}
 * @implements {Polymer_ArraySelectorMixin}
 */

var baseArraySelector = ArraySelectorMixin(_polymerElement.Element);

/**
 * Element implementing the `Polymer.ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *         <button on-click="toggleSelection">Select</button>
 *     </template>
 *
 *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
 *
 *     <div> Selected employees: </div>
 *     <template is="dom-repeat" items="{{selected}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * ```js
 * Polymer({
 *   is: 'employee-list',
 *   ready() {
 *     this.employees = [
 *         {first: 'Bob', last: 'Smith'},
 *         {first: 'Sally', last: 'Johnson'},
 *         ...
 *     ];
 *   },
 *   toggleSelection(e) {
 *     let item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * });
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin Polymer.ArraySelectorMixin
 * @memberof Polymer
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */

var ArraySelector = function (_baseArraySelector) {
  _inherits(ArraySelector, _baseArraySelector);

  function ArraySelector() {
    _classCallCheck(this, ArraySelector);

    return _possibleConstructorReturn(this, (ArraySelector.__proto__ || Object.getPrototypeOf(ArraySelector)).apply(this, arguments));
  }

  _createClass(ArraySelector, null, [{
    key: 'is',

    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    get: function get() {
      return 'array-selector';
    }
  }]);

  return ArraySelector;
}(baseArraySelector);

customElements.define(ArraySelector.is, ArraySelector);
exports.ArraySelector = ArraySelector;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(105);

var _styleGather = __webpack_require__(58);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var attr = 'include';

var CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 * ...
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */

var CustomStyle = function (_HTMLElement) {
  _inherits(CustomStyle, _HTMLElement);

  function CustomStyle() {
    _classCallCheck(this, CustomStyle);

    var _this = _possibleConstructorReturn(this, (CustomStyle.__proto__ || Object.getPrototypeOf(CustomStyle)).call(this));

    _this._style = null;
    CustomStyleInterface.addCustomStyle(_this);
    return _this;
  }
  /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */


  _createClass(CustomStyle, [{
    key: 'getStyle',
    value: function getStyle() {
      if (this._style) {
        return this._style;
      }
      var style = /** @type {HTMLStyleElement} */this.querySelector('style');
      if (!style) {
        return null;
      }
      this._style = style;
      var include = style.getAttribute(attr);
      if (include) {
        style.removeAttribute(attr);
        style.textContent = (0, _styleGather.cssFromModules)(include) + style.textContent;
      }
      return this._style;
    }
  }]);

  return CustomStyle;
}(HTMLElement);

window.customElements.define('custom-style', CustomStyle);
exports.CustomStyle = CustomStyle;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



var _customStyleInterface = __webpack_require__(64);

var _customStyleInterface2 = _interopRequireDefault(_customStyleInterface);

var _commonUtils = __webpack_require__(40);

var _styleSettings = __webpack_require__(37);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var customStyleInterface = new _customStyleInterface2.default();

if (!window.ShadyCSS) {
  window.ShadyCSS = {
    /**
     * @param {HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate: function prepareTemplate(template, elementName, elementExtends) {},
    // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    styleSubtree: function styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      (0, _commonUtils.updateNativeProperties)(element, properties);
    },


    /**
     * @param {Element} element
     */
    styleElement: function styleElement(element) {
      // eslint-disable-line no-unused-vars
      customStyleInterface.processStyles();
    },


    /**
     * @param {Object=} properties
     */
    styleDocument: function styleDocument(properties) {
      customStyleInterface.processStyles();
      (0, _commonUtils.updateNativeProperties)(document.body, properties);
    },


    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue: function getComputedStyleValue(element, property) {
      return (0, _commonUtils.getComputedStyleValue)(element, property);
    },

    nativeCss: _styleSettings.nativeCssVariables,
    nativeShadow: _styleSettings.nativeShadow
  };
}

window.ShadyCSS.CustomStyleInterface = customStyleInterface;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionalMutableDataBehavior = exports.MutableDataBehavior = undefined;

var _mutableData = __webpack_require__(29);

var mutablePropertyChange = void 0;
(
/** @suppress {missingProperties} */
function () {
  mutablePropertyChange = _mutableData.MutableData._mutablePropertyChange;
})();

var MutableDataBehavior = exports.MutableDataBehavior = {

  /**
   * Overrides `Polymer.PropertyEffects` to provide option for skipping
   * strict equality checking for Objects and Arrays.
   *
   * This method pulls the value to dirty check against from the `__dataTemp`
   * cache (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   */
  _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, true);
  }
};

var OptionalMutableDataBehavior = exports.OptionalMutableDataBehavior = {

  properties: {
    /**
     * Instance-level flag for configuring the dirty-checking strategy
     * for this element.  When true, Objects and Arrays will skip dirty
     * checking, otherwise strict equality checking will be used.
     */
    mutableData: Boolean
  },

  /**
   * Overrides `Polymer.PropertyEffects` to skip strict equality checking
   * for Objects and Arrays.
   *
   * Pulls the value to dirty check against from the `__dataTemp` cache
   * (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @this {this}
   * @protected
   */
  _shouldPropertyChange: function _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n\n      --layout: {\n        display: -ms-flexbox;\n        display: -webkit-flex;\n        display: flex;\n      };\n\n      --layout-inline: {\n        display: -ms-inline-flexbox;\n        display: -webkit-inline-flex;\n        display: inline-flex;\n      };\n\n      --layout-horizontal: {\n        @apply --layout;\n\n        -ms-flex-direction: row;\n        -webkit-flex-direction: row;\n        flex-direction: row;\n      };\n\n      --layout-horizontal-reverse: {\n        @apply --layout;\n\n        -ms-flex-direction: row-reverse;\n        -webkit-flex-direction: row-reverse;\n        flex-direction: row-reverse;\n      };\n\n      --layout-vertical: {\n        @apply --layout;\n\n        -ms-flex-direction: column;\n        -webkit-flex-direction: column;\n        flex-direction: column;\n      };\n\n      --layout-vertical-reverse: {\n        @apply --layout;\n\n        -ms-flex-direction: column-reverse;\n        -webkit-flex-direction: column-reverse;\n        flex-direction: column-reverse;\n      };\n\n      --layout-wrap: {\n        -ms-flex-wrap: wrap;\n        -webkit-flex-wrap: wrap;\n        flex-wrap: wrap;\n      };\n\n      --layout-wrap-reverse: {\n        -ms-flex-wrap: wrap-reverse;\n        -webkit-flex-wrap: wrap-reverse;\n        flex-wrap: wrap-reverse;\n      };\n\n      --layout-flex-auto: {\n        -ms-flex: 1 1 auto;\n        -webkit-flex: 1 1 auto;\n        flex: 1 1 auto;\n      };\n\n      --layout-flex-none: {\n        -ms-flex: none;\n        -webkit-flex: none;\n        flex: none;\n      };\n\n      --layout-flex: {\n        -ms-flex: 1 1 0.000000001px;\n        -webkit-flex: 1;\n        flex: 1;\n        -webkit-flex-basis: 0.000000001px;\n        flex-basis: 0.000000001px;\n      };\n\n      --layout-flex-2: {\n        -ms-flex: 2;\n        -webkit-flex: 2;\n        flex: 2;\n      };\n\n      --layout-flex-3: {\n        -ms-flex: 3;\n        -webkit-flex: 3;\n        flex: 3;\n      };\n\n      --layout-flex-4: {\n        -ms-flex: 4;\n        -webkit-flex: 4;\n        flex: 4;\n      };\n\n      --layout-flex-5: {\n        -ms-flex: 5;\n        -webkit-flex: 5;\n        flex: 5;\n      };\n\n      --layout-flex-6: {\n        -ms-flex: 6;\n        -webkit-flex: 6;\n        flex: 6;\n      };\n\n      --layout-flex-7: {\n        -ms-flex: 7;\n        -webkit-flex: 7;\n        flex: 7;\n      };\n\n      --layout-flex-8: {\n        -ms-flex: 8;\n        -webkit-flex: 8;\n        flex: 8;\n      };\n\n      --layout-flex-9: {\n        -ms-flex: 9;\n        -webkit-flex: 9;\n        flex: 9;\n      };\n\n      --layout-flex-10: {\n        -ms-flex: 10;\n        -webkit-flex: 10;\n        flex: 10;\n      };\n\n      --layout-flex-11: {\n        -ms-flex: 11;\n        -webkit-flex: 11;\n        flex: 11;\n      };\n\n      --layout-flex-12: {\n        -ms-flex: 12;\n        -webkit-flex: 12;\n        flex: 12;\n      };\n\n      /* alignment in cross axis */\n\n      --layout-start: {\n        -ms-flex-align: start;\n        -webkit-align-items: flex-start;\n        align-items: flex-start;\n      };\n\n      --layout-center: {\n        -ms-flex-align: center;\n        -webkit-align-items: center;\n        align-items: center;\n      };\n\n      --layout-end: {\n        -ms-flex-align: end;\n        -webkit-align-items: flex-end;\n        align-items: flex-end;\n      };\n\n      --layout-baseline: {\n        -ms-flex-align: baseline;\n        -webkit-align-items: baseline;\n        align-items: baseline;\n      };\n\n      /* alignment in main axis */\n\n      --layout-start-justified: {\n        -ms-flex-pack: start;\n        -webkit-justify-content: flex-start;\n        justify-content: flex-start;\n      };\n\n      --layout-center-justified: {\n        -ms-flex-pack: center;\n        -webkit-justify-content: center;\n        justify-content: center;\n      };\n\n      --layout-end-justified: {\n        -ms-flex-pack: end;\n        -webkit-justify-content: flex-end;\n        justify-content: flex-end;\n      };\n\n      --layout-around-justified: {\n        -ms-flex-pack: distribute;\n        -webkit-justify-content: space-around;\n        justify-content: space-around;\n      };\n\n      --layout-justified: {\n        -ms-flex-pack: justify;\n        -webkit-justify-content: space-between;\n        justify-content: space-between;\n      };\n\n      --layout-center-center: {\n        @apply --layout-center;\n        @apply --layout-center-justified;\n      };\n\n      /* self alignment */\n\n      --layout-self-start: {\n        -ms-align-self: flex-start;\n        -webkit-align-self: flex-start;\n        align-self: flex-start;\n      };\n\n      --layout-self-center: {\n        -ms-align-self: center;\n        -webkit-align-self: center;\n        align-self: center;\n      };\n\n      --layout-self-end: {\n        -ms-align-self: flex-end;\n        -webkit-align-self: flex-end;\n        align-self: flex-end;\n      };\n\n      --layout-self-stretch: {\n        -ms-align-self: stretch;\n        -webkit-align-self: stretch;\n        align-self: stretch;\n      };\n\n      --layout-self-baseline: {\n        -ms-align-self: baseline;\n        -webkit-align-self: baseline;\n        align-self: baseline;\n      };\n\n      /* multi-line alignment in main axis */\n\n      --layout-start-aligned: {\n        -ms-flex-line-pack: start;  /* IE10 */\n        -ms-align-content: flex-start;\n        -webkit-align-content: flex-start;\n        align-content: flex-start;\n      };\n\n      --layout-end-aligned: {\n        -ms-flex-line-pack: end;  /* IE10 */\n        -ms-align-content: flex-end;\n        -webkit-align-content: flex-end;\n        align-content: flex-end;\n      };\n\n      --layout-center-aligned: {\n        -ms-flex-line-pack: center;  /* IE10 */\n        -ms-align-content: center;\n        -webkit-align-content: center;\n        align-content: center;\n      };\n\n      --layout-between-aligned: {\n        -ms-flex-line-pack: justify;  /* IE10 */\n        -ms-align-content: space-between;\n        -webkit-align-content: space-between;\n        align-content: space-between;\n      };\n\n      --layout-around-aligned: {\n        -ms-flex-line-pack: distribute;  /* IE10 */\n        -ms-align-content: space-around;\n        -webkit-align-content: space-around;\n        align-content: space-around;\n      };\n\n      /*******************************\n                Other Layout\n      *******************************/\n\n      --layout-block: {\n        display: block;\n      };\n\n      --layout-invisible: {\n        visibility: hidden !important;\n      };\n\n      --layout-relative: {\n        position: relative;\n      };\n\n      --layout-fit: {\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n      --layout-scroll: {\n        -webkit-overflow-scrolling: touch;\n        overflow: auto;\n      };\n\n      --layout-fullbleed: {\n        margin: 0;\n        height: 100vh;\n      };\n\n      /* fixed position */\n\n      --layout-fixed-top: {\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n      };\n\n      --layout-fixed-right: {\n        position: fixed;\n        top: 0;\n        right: 0;\n        bottom: 0;\n      };\n\n      --layout-fixed-bottom: {\n        position: fixed;\n        right: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n      --layout-fixed-left: {\n        position: fixed;\n        top: 0;\n        bottom: 0;\n        left: 0;\n      };\n\n    }\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

__webpack_require__(69);

var $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = '<custom-style>\n  <style is="custom-style">\n    html {\n      /*\n       * You can use these generic variables in your elements for easy theming.\n       * For example, if all your elements use `--primary-text-color` as its main\n       * color, then switching from a light to a dark theme is just a matter of\n       * changing the value of `--primary-text-color` in your application.\n       */\n      --primary-text-color: var(--light-theme-text-color);\n      --primary-background-color: var(--light-theme-background-color);\n      --secondary-text-color: var(--light-theme-secondary-color);\n      --disabled-text-color: var(--light-theme-disabled-color);\n      --divider-color: var(--light-theme-divider-color);\n      --error-color: var(--paper-deep-orange-a700);\n\n      /*\n       * Primary and accent colors. Also see color.html for more colors.\n       */\n      --primary-color: var(--paper-indigo-500);\n      --light-primary-color: var(--paper-indigo-100);\n      --dark-primary-color: var(--paper-indigo-700);\n\n      --accent-color: var(--paper-pink-a200);\n      --light-accent-color: var(--paper-pink-a100);\n      --dark-accent-color: var(--paper-pink-a400);\n\n\n      /*\n       * Material Design Light background theme\n       */\n      --light-theme-background-color: #ffffff;\n      --light-theme-base-color: #000000;\n      --light-theme-text-color: var(--paper-grey-900);\n      --light-theme-secondary-color: #737373;  /* for secondary text and icons */\n      --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */\n      --light-theme-divider-color: #dbdbdb;\n\n      /*\n       * Material Design Dark background theme\n       */\n      --dark-theme-background-color: var(--paper-grey-900);\n      --dark-theme-base-color: #ffffff;\n      --dark-theme-text-color: #ffffff;\n      --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */\n      --dark-theme-disabled-color: #646464;  /* disabled/hint text */\n      --dark-theme-divider-color: #3c3c3c;\n\n      /*\n       * Deprecated values because of their confusing names.\n       */\n      --text-primary-color: var(--dark-theme-text-color);\n      --default-primary-color: var(--primary-color);\n    }\n  </style>\n</custom-style>';

document.head.appendChild($_documentContainer);

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperCheckedElementBehavior = exports.PaperCheckedElementBehaviorImpl = undefined;

__webpack_require__(7);

var _ironCheckedElementBehavior = __webpack_require__(110);

var _paperInkyFocusBehavior = __webpack_require__(114);

var _paperRippleBehavior = __webpack_require__(45);

var PaperCheckedElementBehaviorImpl = exports.PaperCheckedElementBehaviorImpl = {
  /**
   * Synchronizes the element's checked state with its ripple effect.
   */
  _checkedChanged: function _checkedChanged() {
    _ironCheckedElementBehavior.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
    if (this.hasRipple()) {
      if (this.checked) {
        this._ripple.setAttribute('checked', '');
      } else {
        this._ripple.removeAttribute('checked');
      }
    }
  },

  /**
   * Synchronizes the element's `active` and `checked` state.
   */
  _buttonStateChanged: function _buttonStateChanged() {
    _paperRippleBehavior.PaperRippleBehavior._buttonStateChanged.call(this);
    if (this.disabled) {
      return;
    }
    if (this.isAttached) {
      this.checked = this.active;
    }
  }
};

var PaperCheckedElementBehavior = exports.PaperCheckedElementBehavior = [_paperInkyFocusBehavior.PaperInkyFocusBehavior, _ironCheckedElementBehavior.IronCheckedElementBehavior, PaperCheckedElementBehaviorImpl];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronCheckedElementBehavior = exports.IronCheckedElementBehaviorImpl = undefined;

__webpack_require__(7);

var _ironValidatableBehavior = __webpack_require__(111);

var _ironFormElementBehavior = __webpack_require__(113);

var IronCheckedElementBehaviorImpl = exports.IronCheckedElementBehaviorImpl = {

  properties: {
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */

    /**
     * Gets or sets the state, `true` is checked and `false` is unchecked.
     */
    checked: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      notify: true,
      observer: '_checkedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: true,
      reflectToAttribute: true
    },

    /* Overriden from Polymer.IronFormElementBehavior */
    value: {
      type: String,
      value: 'on',
      observer: '_valueChanged'
    }
  },

  observers: ['_requiredChanged(required)'],

  created: function created() {
    // Used by `iron-form` to handle the case that an element with this behavior
    // doesn't have a role of 'checkbox' or 'radio', but should still only be
    // included when the form is serialized if `this.checked === true`.
    this._hasIronCheckedElementBehavior = true;
  },

  /**
   * Returns false if the element is required and not checked, and true otherwise.
   * @param {*=} _value Ignored.
   * @return {boolean} true if `required` is false or if `checked` is true.
   */
  _getValidity: function _getValidity(_value) {
    return this.disabled || !this.required || this.checked;
  },

  /**
   * Update the aria-required label when `required` is changed.
   */
  _requiredChanged: function _requiredChanged() {
    if (this.required) {
      this.setAttribute('aria-required', 'true');
    } else {
      this.removeAttribute('aria-required');
    }
  },

  /**
   * Fire `iron-changed` when the checked state changes.
   */
  _checkedChanged: function _checkedChanged() {
    this.active = this.checked;
    this.fire('iron-change');
  },

  /**
   * Reset value to 'on' if it is set to `undefined`.
   */
  _valueChanged: function _valueChanged() {
    if (this.value === undefined || this.value === null) {
      this.value = 'on';
    }
  }
};

var IronCheckedElementBehavior = exports.IronCheckedElementBehavior = [_ironFormElementBehavior.IronFormElementBehavior, _ironValidatableBehavior.IronValidatableBehavior, IronCheckedElementBehaviorImpl];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronValidatableBehavior = exports.IronValidatableBehaviorMeta = undefined;

__webpack_require__(7);

var _ironMeta = __webpack_require__(112);

var IronValidatableBehaviorMeta = exports.IronValidatableBehaviorMeta = null;

var IronValidatableBehavior = exports.IronValidatableBehavior = {

  properties: {
    /**
     * Name of the validator to use.
     */
    validator: {
      type: String
    },

    /**
     * True if the last call to `validate` is invalid.
     */
    invalid: {
      notify: true,
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_invalidChanged'
    }
  },

  registered: function registered() {
    exports.IronValidatableBehaviorMeta = IronValidatableBehaviorMeta = new _ironMeta.IronMeta({ type: 'validator' });
  },

  _invalidChanged: function _invalidChanged() {
    if (this.invalid) {
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('aria-invalid');
    }
  },

  /* Recompute this every time it's needed, because we don't know if the
   * underlying IronValidatableBehaviorMeta has changed. */
  get _validator() {
    return IronValidatableBehaviorMeta && IronValidatableBehaviorMeta.byKey(this.validator);
  },

  /**
   * @return {boolean} True if the validator `validator` exists.
   */
  hasValidator: function hasValidator() {
    return this._validator != null;
  },

  /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.
    * @param {Object} value Deprecated: The value to be validated. By default,
   * it is passed to the validator's `validate()` function, if a validator is set.
   * If this argument is not specified, then the element's `value` property
   * is used, if it exists.
   * @return {boolean} True if `value` is valid.
   */
  validate: function validate(value) {
    // If this is an element that also has a value property, and there was
    // no explicit value argument passed, use the element's property instead.
    if (value === undefined && this.value !== undefined) this.invalid = !this._getValidity(this.value);else this.invalid = !this._getValidity(value);
    return !this.invalid;
  },

  /**
   * Returns true if `value` is valid.  By default, it is passed
   * to the validator's `validate()` function, if a validator is set. You
   * should override this method if you want to implement custom validity
   * logic for your element.
   *
   * @param {Object} value The value to be validated.
   * @return {boolean} True if `value` is valid.
   */

  _getValidity: function _getValidity(value) {
    if (this.hasValidator()) {
      return this._validator.validate(value);
    }
    return true;
  }
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronMeta = undefined;

__webpack_require__(7);

var _polymerFn = __webpack_require__(28);

/**
 * @constructor
 * @param {{type: (string|null), key: (string|null), value: *}} options
 */
function IronMeta(options) {
  this.type = options && options.type || 'default';
  this.key = options && options.key;
  if ('value' in options) {
    this.value = options.value;
  }
}

IronMeta.types = {};

IronMeta.prototype = {
  get value() {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      return IronMeta.types[type] && IronMeta.types[type][key];
    }
  },

  set value(value) {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      type = IronMeta.types[type] = IronMeta.types[type] || {};
      if (value == null) {
        delete type[key];
      } else {
        type[key] = value;
      }
    }
  },

  get list() {
    var type = this.type;

    if (type) {
      return Object.keys(IronMeta.types[this.type]).map(function (key) {
        return metaDatas[this.type][key];
      }, this);
    }
  },

  byKey: function byKey(key) {
    this.key = key;
    return this.value;
  }
};

exports.IronMeta = IronMeta;


var metaDatas = IronMeta.types;

(0, _polymerFn.Polymer)({

  is: 'iron-meta',

  properties: {

    /**
     * The type of meta-data.  All meta-data of the same type is stored
     * together.
     * @type {string}
     */
    type: {
      type: String,
      value: 'default'
    },

    /**
     * The key used to store `value` under the `type` namespace.
     * @type {?string}
     */
    key: {
      type: String
    },

    /**
     * The meta-data to store or retrieve.
     * @type {*}
     */
    value: {
      type: String,
      notify: true
    },

    /**
     * If true, `value` is set to the iron-meta instance itself.
     */
    self: {
      type: Boolean,
      observer: '_selfChanged'
    },

    __meta: {
      type: Boolean,
      computed: '__computeMeta(type, key, value)'
    }
  },

  hostAttributes: {
    hidden: true
  },

  __computeMeta: function __computeMeta(type, key, value) {
    var meta = new IronMeta({
      type: type,
      key: key
    });

    if (value !== undefined && value !== meta.value) {
      meta.value = value;
    } else if (this.value !== meta.value) {
      this.value = meta.value;
    }

    return meta;
  },

  get list() {
    return this.__meta && this.__meta.list;
  },

  _selfChanged: function _selfChanged(self) {
    if (self) {
      this.value = this;
    }
  },

  /**
   * Retrieves meta data value by key.
   *
   * @method byKey
   * @param {string} key The key of the meta-data to be returned.
   * @return {*}
   */
  byKey: function byKey(key) {
    return new IronMeta({
      type: this.type,
      key: key
    }).value;
  }
});

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IronFormElementBehavior = undefined;

__webpack_require__(7);

var _polymerElement = __webpack_require__(11);

var IronFormElementBehavior = exports.IronFormElementBehavior = {

  properties: {
    /**
     * Fired when the element is added to an `iron-form`.
     *
     * @event iron-form-element-register
     */

    /**
     * Fired when the element is removed from an `iron-form`.
     *
     * @event iron-form-element-unregister
     */

    /**
     * The name of this element.
     */
    name: {
      type: String
    },

    /**
     * The value for this element.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to mark the input as required. If used in a form, a
     * custom element that uses this behavior should also use
     * Polymer.IronValidatableBehavior and define a custom validation method.
     * Otherwise, a `required` element will always be considered valid.
     * It's also strongly recommended to provide a visual style for the element
     * when its value is invalid.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The form that the element is registered to.
     */
    _parentForm: {
      type: Object
    }
  },

  attached: _polymerElement.Element ? null : function () {
    // Note: the iron-form that this element belongs to will set this
    // element's _parentForm property when handling this event.
    this.fire('iron-form-element-register');
  },

  detached: _polymerElement.Element ? null : function () {
    if (this._parentForm) {
      this._parentForm.fire('iron-form-element-unregister', { target: this });
    }
  }

};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaperInkyFocusBehavior = exports.PaperInkyFocusBehaviorImpl = undefined;

__webpack_require__(7);

var _ironButtonState = __webpack_require__(70);

var _paperRippleBehavior = __webpack_require__(45);

var _ironControlState = __webpack_require__(72);

var PaperInkyFocusBehaviorImpl = exports.PaperInkyFocusBehaviorImpl = {
  observers: ['_focusedChanged(receivedFocusFromKeyboard)'],

  _focusedChanged: function _focusedChanged(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function _createRipple() {
    var ripple = _paperRippleBehavior.PaperRippleBehavior._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};

var PaperInkyFocusBehavior = exports.PaperInkyFocusBehavior = [_ironButtonState.IronButtonState, _ironControlState.IronControlState, _paperRippleBehavior.PaperRippleBehavior, PaperInkyFocusBehaviorImpl];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(7);

var _ironA11yKeysBehavior = __webpack_require__(71);

var _polymerDom = __webpack_require__(17);

var _polymerFn = __webpack_require__(28);

var Utility = {
  distance: function distance(x1, y1, x2, y2) {
    var xDelta = x1 - x2;
    var yDelta = y1 - y2;

    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },

  now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;

  this.size = Math.max(this.width, this.height);
}

ElementMetrics.prototype = {
  get boundingRect() {
    return this.element.getBoundingClientRect();
  },

  furthestCornerDistanceFrom: function furthestCornerDistanceFrom(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);

    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;

  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  (0, _polymerDom.dom)(this.waveContainer).appendChild(this.wave);

  this.resetInteractionState();
}

Ripple.MAX_RADIUS = 300;

Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },

  get center() {
    return this.element.center;
  },

  get mouseDownElapsed() {
    var elapsed;

    if (!this.mouseDownStart) {
      return 0;
    }

    elapsed = Utility.now() - this.mouseDownStart;

    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }

    return elapsed;
  },

  get mouseUpElapsed() {
    return this.mouseUpStart ? Utility.now() - this.mouseUpStart : 0;
  },

  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },

  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },

  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },

  get initialOpacity() {
    return this.element.initialOpacity;
  },

  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },

  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius = Math.min(Math.sqrt(width2 + height2), Ripple.MAX_RADIUS) * 1.1 + 5;

    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));

    return Math.abs(size);
  },

  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }

    return Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity);
  },

  get outerOpacity() {
    // Linear increase in background opacity, capped at the opacity
    // of the wavefront (waveOpacity).
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;

    return Math.max(0, Math.min(outerOpacity, waveOpacity));
  },

  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isAnimationComplete() {
    return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
  },

  get translationFraction() {
    return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2));
  },

  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }

    return this.xStart;
  },

  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }

    return this.yStart;
  },

  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },

  resetInteractionState: function resetInteractionState() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;

    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;

    this.containerMetrics = new ElementMetrics(this.element);
  },

  draw: function draw() {
    var scale;
    var translateString;
    var dx;
    var dy;

    this.wave.style.opacity = this.opacity;

    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - this.containerMetrics.width / 2;
    dy = this.yNow - this.containerMetrics.height / 2;

    // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
    // https://bugs.webkit.org/show_bug.cgi?id=98538
    this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },

  /** @param {Event=} event */
  downAction: function downAction(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;

    this.resetInteractionState();
    this.mouseDownStart = Utility.now();

    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    } else {
      this.xStart = event ? event.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2;
      this.yStart = event ? event.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2;
    }

    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance = Utility.distance(this.xStart, this.yStart, this.xEnd, this.yEnd);
    }

    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);

    this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },

  /** @param {Event=} event */
  upAction: function upAction(event) {
    if (!this.isMouseDown) {
      return;
    }

    this.mouseUpStart = Utility.now();
  },

  remove: function remove() {
    (0, _polymerDom.dom)(this.waveContainer.parentNode).removeChild(this.waveContainer);
  }
};

(0, _polymerFn.Polymer)({
  _template: '\n    <style>\n      :host {\n        display: block;\n        position: absolute;\n        border-radius: inherit;\n        overflow: hidden;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n\n        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,\n         * creating a node (with a position:absolute) in the middle of an event\n         * handler "interrupts" that event handler (which happens when the\n         * ripple is created on demand) */\n        pointer-events: none;\n      }\n\n      :host([animating]) {\n        /* This resolves a rendering issue in Chrome (as of 40) where the\n           ripple is not properly clipped by its parent (which may have\n           rounded corners). See: http://jsbin.com/temexa/4\n\n           Note: We only apply this style conditionally. Otherwise, the browser\n           will create a new compositing layer for every ripple element on the\n           page, and that would be bad. */\n        -webkit-transform: translate(0, 0);\n        transform: translate3d(0, 0, 0);\n      }\n\n      #background,\n      #waves,\n      .wave-container,\n      .wave {\n        pointer-events: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      #background,\n      .wave {\n        opacity: 0;\n      }\n\n      #waves,\n      .wave {\n        overflow: hidden;\n      }\n\n      .wave-container,\n      .wave {\n        border-radius: 50%;\n      }\n\n      :host(.circle) #background,\n      :host(.circle) #waves {\n        border-radius: 50%;\n      }\n\n      :host(.circle) .wave-container {\n        overflow: hidden;\n      }\n    </style>\n\n    <div id="background"></div>\n    <div id="waves"></div>\n',

  is: 'paper-ripple',

  behaviors: [_ironA11yKeysBehavior.IronA11yKeysBehavior],

  properties: {
    /**
     * The initial opacity set on the wave.
     *
     * @attribute initialOpacity
     * @type number
     * @default 0.25
     */
    initialOpacity: {
      type: Number,
      value: 0.25
    },

    /**
     * How fast (opacity per second) the wave fades out.
     *
     * @attribute opacityDecayVelocity
     * @type number
     * @default 0.8
     */
    opacityDecayVelocity: {
      type: Number,
      value: 0.8
    },

    /**
     * If true, ripples will exhibit a gravitational pull towards
     * the center of their container as they fade away.
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    recenters: {
      type: Boolean,
      value: false
    },

    /**
     * If true, ripples will center inside its container
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    center: {
      type: Boolean,
      value: false
    },

    /**
     * A list of the visual ripples.
     *
     * @attribute ripples
     * @type Array
     * @default []
     */
    ripples: {
      type: Array,
      value: function value() {
        return [];
      }
    },

    /**
     * True when there are visible ripples animating within the
     * element.
     */
    animating: {
      type: Boolean,
      readOnly: true,
      reflectToAttribute: true,
      value: false
    },

    /**
     * If true, the ripple will remain in the "down" state until `holdDown`
     * is set to false again.
     */
    holdDown: {
      type: Boolean,
      value: false,
      observer: '_holdDownChanged'
    },

    /**
     * If true, the ripple will not generate a ripple effect
     * via pointer interaction.
     * Calling ripple's imperative api like `simulatedRipple` will
     * still generate the ripple effect.
     */
    noink: {
      type: Boolean,
      value: false
    },

    _animating: {
      type: Boolean
    },

    _boundAnimate: {
      type: Function,
      value: function value() {
        return this.animate.bind(this);
      }
    }
  },

  get target() {
    return this.keyEventTarget;
  },

  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },

  attached: function attached() {
    // Set up a11yKeysBehavior to listen to key events on the target,
    // so that space and enter activate the ripple even if the target doesn't
    // handle key events. The key handlers deal with `noink` themselves.
    if (this.parentNode.nodeType == 11) {
      // DOCUMENT_FRAGMENT_NODE
      this.keyEventTarget = (0, _polymerDom.dom)(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = this.parentNode;
    }
    var keyEventTarget = /** @type {!EventTarget} */this.keyEventTarget;
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },

  detached: function detached() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },

  get shouldKeepAnimating() {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }

    return false;
  },

  simulatedRipple: function simulatedRipple() {
    this.downAction(null);

    // Please see polymer/polymer#1305
    this.async(function () {
      this.upAction();
    }, 1);
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiDownAction: function uiDownAction(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  downAction: function downAction(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }

    var ripple = this.addRipple();

    ripple.downAction(event);

    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiUpAction: function uiUpAction(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  upAction: function upAction(event) {
    if (this.holdDown) {
      return;
    }

    this.ripples.forEach(function (ripple) {
      ripple.upAction(event);
    });

    this._animating = true;
    this.animate();
  },

  onAnimationComplete: function onAnimationComplete() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire('transitionend');
  },

  addRipple: function addRipple() {
    var ripple = new Ripple(this);

    (0, _polymerDom.dom)(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);

    this._setAnimating(true);

    return ripple;
  },

  removeRipple: function removeRipple(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);

    if (rippleIndex < 0) {
      return;
    }

    this.ripples.splice(rippleIndex, 1);

    ripple.remove();

    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },

  /**
   * This conflicts with Element#antimate().
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
   * @suppress {checkTypes}
   */
  animate: function animate() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;

    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];

      ripple.draw();

      this.$.background.style.opacity = ripple.outerOpacity;

      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }

    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },

  _onEnterKeydown: function _onEnterKeydown() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },

  _onSpaceKeydown: function _onSpaceKeydown() {
    this.uiDownAction();
  },

  _onSpaceKeyup: function _onSpaceKeyup() {
    this.uiUpAction();
  },

  // note: holdDown does not respect noink since it can be a focus based
  // effect.
  _holdDownChanged: function _holdDownChanged(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.
   @event transitionend
  @param {{node: Object}} detail Contains the animated node.
  */
});

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.addDoubleTapListener = addDoubleTapListener;
exports.removeDoubleTapListener = removeDoubleTapListener;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(76);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = Browser.msPointer ? 'MSPointerDown' : Browser.pointer ? 'pointerdown' : 'touchstart';
var _touchend = Browser.msPointer ? 'MSPointerUp' : Browser.pointer ? 'pointerup' : 'touchend';
var _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last,
	    touch,
	    doubleTap = false,
	    delay = 250;

	function onTouchStart(e) {
		var count;

		if (Browser.pointer) {
			if (!Browser.edge || e.pointerType === 'mouse') {
				return;
			}
			count = _DomEvent._pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) {
			return;
		}

		var now = Date.now(),
		    delta = now - (last || now);

		touch = e.touches ? e.touches[0] : e;
		doubleTap = delta > 0 && delta <= delay;
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch.cancelBubble) {
			if (Browser.pointer) {
				if (!Browser.edge || e.pointerType === 'mouse') {
					return;
				}
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
				    prop,
				    i;

				for (i in touch) {
					prop = touch[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
				}
				touch = newTouch;
			}
			touch.type = 'dblclick';
			handler(touch);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, false);
	obj.addEventListener(_touchend, onTouchEnd, false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
	    touchend = obj[_pre + _touchend + id],
	    dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, false);
	obj.removeEventListener(_touchend, touchend, false);
	if (!Browser.edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.MarkerDrag = undefined;

var _Handler = __webpack_require__(14);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Draggable = __webpack_require__(49);

var _Bounds = __webpack_require__(5);

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = exports.MarkerDrag = _Handler.Handler.extend({
	initialize: function initialize(marker) {
		this._marker = marker;
	},

	addHooks: function addHooks() {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new _Draggable.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function removeHooks() {
		this._draggable.off({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function moved() {
		return this._draggable && this._draggable._moved;
	},

	_adjustPan: function _adjustPan(e) {
		var marker = this._marker,
		    map = marker._map,
		    speed = this._marker.options.autoPanSpeed,
		    padding = this._marker.options.autoPanPadding,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    bounds = map.getPixelBounds(),
		    origin = map.getPixelOrigin();

		var panBounds = (0, _Bounds.toBounds)(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));

		if (!panBounds.contains(iconPos)) {
			// Compute incremental movement
			var movement = (0, _Point.toPoint)((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);

			map.panBy(movement, { animate: false });

			this._draggable._newPos._add(movement);
			this._draggable._startPos._add(movement);

			L.DomUtil.setPosition(marker._icon, this._draggable._newPos);
			this._onDrag(e);

			this._panRequest = (0, _Util.requestAnimFrame)(this._adjustPan.bind(this, e));
		}
	},

	_onDragStart: function _onDragStart() {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker.closePopup().fire('movestart').fire('dragstart');
	},

	_onPreDrag: function _onPreDrag(e) {
		if (this._marker.options.autoPan) {
			(0, _Util.cancelAnimFrame)(this._panRequest);
			this._panRequest = (0, _Util.requestAnimFrame)(this._adjustPan.bind(this, e));
		}
	},

	_onDrag: function _onDrag(e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker.fire('move', e).fire('drag', e);
	},

	_onDragEnd: function _onDragEnd(e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		(0, _Util.cancelAnimFrame)(this._panRequest);

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker.fire('moveend').fire('dragend', e);
	}
});

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "2273e3d8ad9264b7daa5bdbf8e6b47f8.png";

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "44a526eed258222515aa21eaffd14a96.png";

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletMap = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _flattenedNodesObserver = __webpack_require__(67);

var _map = __webpack_require__(79);

var _ControlAttribution = __webpack_require__(80);

__webpack_require__(81);

__webpack_require__(82);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Need these side effects


var LeafletMap = exports.LeafletMap = function (_PolymerElement) {
  _inherits(LeafletMap, _PolymerElement);

  _createClass(LeafletMap, null, [{
    key: 'template',
    get: function get() {
      return '\n      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />\n\n      <!-- FIXME: Figure out Shadow DOM so this doesn\'t have to be included here -->\n      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css" media="screen">\n      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css" media="screen">\n\n      <style>\n        #map {\n          width: 100%;\n          height: 100%;\n          @apply (--leaflet-map-component)\n        }\n      </style>\n\n      <div id="map">\n        <slot></slot>\n      </div>\n    ';
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          notify: true
        },
        latitude: {
          type: Number
        },
        longitude: {
          type: Number
        },
        zoom: {
          type: Number
        },
        minZoom: {
          type: Number
        },
        maxZoom: {
          type: Number
        },
        zoomControl: {
          type: Boolean,
          value: false
        },
        attributionPrefix: {
          type: String
        },
        _childrenObserver: Object
      };
    }
  }]);

  function LeafletMap() {
    _classCallCheck(this, LeafletMap);

    return _possibleConstructorReturn(this, (LeafletMap.__proto__ || Object.getPrototypeOf(LeafletMap)).call(this));
  }

  _createClass(LeafletMap, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletMap.prototype.__proto__ || Object.getPrototypeOf(LeafletMap.prototype), 'connectedCallback', this).call(this);

      this.map = new _map.Map(this.$.map, {
        center: [this.latitude, this.longitude],
        zoom: this.zoom,
        zoomControl: this.zoomControl,
        inertiaDeceleration: 3000,
        inertiaMaxSpeed: 3000,
        attributionControl: false,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        tapTolerance: 40,
        tap: false
      });

      if (this.attributionPrefix) {
        var attrControl = new _ControlAttribution.Attribution({ prefix: this.attributionPrefix });
        this.map.addControl(attrControl);
      }

      // L.marker([this.latitude, this.longitude]).addTo(this.map);

      var slot = this.shadowRoot.querySelector('slot');
      this._childrenObserver = new _flattenedNodesObserver.FlattenedNodesObserver(slot, this._bindDependencies.bind(this));
    }

    /* Shitty way of passing value to children */

  }, {
    key: '_bindDependencies',
    value: function _bindDependencies(_ref) {
      var _this2 = this;

      var addedNodes = _ref.addedNodes;

      addedNodes.forEach(function (n) {
        n.map = _this2.map;
      });
    }
  }]);

  return LeafletMap;
}(_polymerElement.Element);

customElements.define('leaflet-map', LeafletMap);

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.BoxZoom = undefined;

var _Map = __webpack_require__(8);

var _Handler = __webpack_require__(14);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = exports.BoxZoom = _Handler.Handler.extend({
	initialize: function initialize(map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function addHooks() {
		DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function moved() {
		return this._moved;
	},

	_destroy: function _destroy() {
		DomUtil.remove(this._pane);
		delete this._pane;
	},

	_resetState: function _resetState() {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function _clearDeferredResetState() {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function _onMouseDown(e) {
		if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
			return false;
		}

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		DomUtil.disableTextSelection();
		DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		DomEvent.on(document, {
			contextmenu: DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function _onMouseMove(e) {
		if (!this._moved) {
			this._moved = true;

			this._box = DomUtil.create('div', 'leaflet-zoom-box', this._container);
			DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new _Bounds.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function _finish() {
		if (this._moved) {
			DomUtil.remove(this._box);
			DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		DomUtil.enableTextSelection();
		DomUtil.enableImageDrag();

		DomEvent.off(document, {
			contextmenu: DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function _onMouseUp(e) {
		if (e.which !== 1 && e.button !== 1) {
			return;
		}

		this._finish();

		if (!this._moved) {
			return;
		}
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(Util.bind(this._resetState, this), 0);

		var bounds = new _LatLngBounds.LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

		this._map.fitBounds(bounds).fire('boxzoomend', { boxZoomBounds: bounds });
	},

	_onKeyDown: function _onKeyDown(e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
_Map.Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DoubleClickZoom = undefined;

var _Map = __webpack_require__(8);

var _Handler = __webpack_require__(14);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

_Map.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = exports.DoubleClickZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function removeHooks() {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function _onDoubleClick(e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
_Map.Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Drag = undefined;

var _Map = __webpack_require__(8);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Handler = __webpack_require__(14);

var _Draggable = __webpack_require__(49);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _LatLngBounds = __webpack_require__(10);

var _Bounds = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = exports.Drag = _Handler.Handler.extend({
	addHooks: function addHooks() {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new _Draggable.Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function removeHooks() {
		DomUtil.removeClass(this._map._container, 'leaflet-grab');
		DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function moved() {
		return this._draggable && this._draggable._moved;
	},

	moving: function moving() {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function _onDragStart() {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = (0, _LatLngBounds.toLatLngBounds)(this._map.options.maxBounds);

			this._offsetLimit = (0, _Bounds.toBounds)(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map.fire('movestart').fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function _onDrag(e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			this._prunePositions(time);
		}

		this._map.fire('move', e).fire('drag', e);
	},

	_prunePositions: function _prunePositions(time) {
		while (this._positions.length > 1 && time - this._times[0] > 50) {
			this._positions.shift();
			this._times.shift();
		}
	},

	_onZoomEnd: function _onZoomEnd() {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function _viscousLimit(value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function _onPreDragLimit() {
		if (!this._viscosity || !this._offsetLimit) {
			return;
		}

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) {
			offset.x = this._viscousLimit(offset.x, limit.min.x);
		}
		if (offset.y < limit.min.y) {
			offset.y = this._viscousLimit(offset.y, limit.min.y);
		}
		if (offset.x > limit.max.x) {
			offset.x = this._viscousLimit(offset.x, limit.max.x);
		}
		if (offset.y > limit.max.y) {
			offset.y = this._viscousLimit(offset.y, limit.max.y);
		}

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function _onPreDragWrap() {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function _onDragEnd(e) {
		var map = this._map,
		    options = map.options,
		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');
		} else {
			this._prunePositions(+new Date());

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,
			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),
			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');
			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
_Map.Map.addInitHook('addHandler', 'dragging', Drag);

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Keyboard = undefined;

var _Map = __webpack_require__(8);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(6);

var _Point = __webpack_require__(3);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
_Map.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = exports.Keyboard = _Handler.Handler.extend({

	keyCodes: {
		left: [37],
		right: [39],
		down: [40],
		up: [38],
		zoomIn: [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function initialize(map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function addHooks() {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		(0, _DomEvent.on)(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function removeHooks() {
		this._removeHooks();

		(0, _DomEvent.off)(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function _onMouseDown() {
		if (this._focused) {
			return;
		}

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function _onFocus() {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function _onBlur() {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function _setPanDelta(panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i,
		    len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function _setZoomDelta(zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i,
		    len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function _addHooks() {
		(0, _DomEvent.on)(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function _removeHooks() {
		(0, _DomEvent.off)(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function _onKeyDown(e) {
		if (e.altKey || e.ctrlKey || e.metaKey) {
			return;
		}

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) {
				return;
			}

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = (0, _Point.toPoint)(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
			map.closePopup();
		} else {
			return;
		}

		(0, _DomEvent.stop)(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
_Map.Map.addInitHook('addHandler', 'keyboard', Keyboard);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ScrollWheelZoom = undefined;

var _Map = __webpack_require__(8);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = exports.ScrollWheelZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function _onWheelScroll(e) {
		var delta = DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(Util.bind(this._performZoom, this), left);

		DomEvent.stop(e);
	},

	_performZoom: function _performZoom() {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) {
			return;
		}

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
_Map.Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Tap = undefined;

var _Map = __webpack_require__(8);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Point = __webpack_require__(3);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = exports.Tap = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function removeHooks() {
		DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function _onDown(e) {
		if (!e.touches) {
			return;
		}

		DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new _Point.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(Util.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function _onUp(e) {
		clearTimeout(this._holdTimeout);

		DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function _isTapValid() {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function _onMove(e) {
		var first = e.touches[0];
		this._newPos = new _Point.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function _simulateEvent(type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (Browser.touch && !Browser.pointer) {
	_Map.Map.addInitHook('addHandler', 'tap', Tap);
}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TouchZoom = undefined;

var _Map = __webpack_require__(8);

var _Handler = __webpack_require__(14);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
_Map.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: Browser.touch && !Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = exports.TouchZoom = _Handler.Handler.extend({
	addHooks: function addHooks() {
		DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function removeHooks() {
		DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function _onTouchStart(e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
			return;
		}

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		DomEvent.on(document, 'touchmove', this._onTouchMove, this);
		DomEvent.on(document, 'touchend', this._onTouchEnd, this);

		DomEvent.preventDefault(e);
	},

	_onTouchMove: function _onTouchMove(e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) {
			return;
		}

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) {
				return;
			}
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) {
				return;
			}
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true, false);
			this._moved = true;
		}

		Util.cancelAnimFrame(this._animRequest);

		var moveFn = Util.bind(map._move, map, this._center, this._zoom, { pinch: true, round: false });
		this._animRequest = Util.requestAnimFrame(moveFn, this, true);

		DomEvent.preventDefault(e);
	},

	_onTouchEnd: function _onTouchEnd() {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		Util.cancelAnimFrame(this._animRequest);

		DomEvent.off(document, 'touchmove', this._onTouchMove);
		DomEvent.off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
_Map.Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.layers = exports.Layers = undefined;

var _Control = __webpack_require__(22);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = exports.Layers = _Control.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function sortFunction(layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
		}
	},

	initialize: function initialize(baseLayers, overlays, options) {
		Util.setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function onAdd(map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function addTo(map) {
		_Control.Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function onRemove() {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function addBaseLayer(layer, name) {
		this._addLayer(layer, name);
		return this._map ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function addOverlay(layer, name) {
		this._addLayer(layer, name, true);
		return this._map ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function removeLayer(layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(Util.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return this._map ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function expand() {
		DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function collapse() {
		DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function _initLayout() {
		var className = 'leaflet-control-layers',
		    container = this._container = DomUtil.create('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		DomEvent.disableClickPropagation(container);
		DomEvent.disableScrollPropagation(container);

		var form = this._form = DomUtil.create('form', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!Browser.android) {
				DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = DomUtil.create('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (Browser.touch) {
			DomEvent.on(link, 'click', DomEvent.stop);
			DomEvent.on(link, 'click', this.expand, this);
		} else {
			DomEvent.on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = DomUtil.create('div', className + '-base', form);
		this._separator = DomUtil.create('div', className + '-separator', form);
		this._overlaysList = DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function _getLayer(id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && Util.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function _addLayer(layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(Util.bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function _update() {
		if (!this._container) {
			return this;
		}

		DomUtil.empty(this._baseLayersList);
		DomUtil.empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent,
		    overlaysPresent,
		    i,
		    obj,
		    baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function _onLayerChange(e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(Util.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function _createRadioElement(name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function _addItem(obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = Util.stamp(obj.layer);

		DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function _onInputClick() {
		var inputs = this._layerControlInputs,
		    input,
		    layer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function _checkDisabledLayers() {
		var inputs = this._layerControlInputs,
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
		}
	},

	_expandIfNotCollapsed: function _expandIfNotCollapsed() {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function _expand() {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function _collapse() {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});

// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = exports.layers = function layers(baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.zoom = exports.Zoom = undefined;

var _Control = __webpack_require__(22);

var _Map = __webpack_require__(8);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = exports.Zoom = _Control.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function onAdd(map) {
		var zoomName = 'leaflet-control-zoom',
		    container = DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function onRemove(map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function disable() {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function enable() {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function _zoomIn(e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function _zoomOut(e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function _createButton(html, title, className, container, fn) {
		var link = DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
   * Will force screen readers like VoiceOver to read this as "Zoom in - button"
   */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		DomEvent.disableClickPropagation(link);
		DomEvent.on(link, 'click', DomEvent.stop);
		DomEvent.on(link, 'click', fn, this);
		DomEvent.on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function _updateDisabled() {
		var map = this._map,
		    className = 'leaflet-disabled';

		DomUtil.removeClass(this._zoomInButton, className);
		DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
_Map.Map.mergeOptions({
	zoomControl: true
});

_Map.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = exports.zoom = function zoom(options) {
	return new Zoom(options);
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.scale = exports.Scale = undefined;

var _Control = __webpack_require__(22);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = exports.Scale = _Control.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function onAdd(map) {
		var className = 'leaflet-control-scale',
		    container = DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function onRemove(map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function _addScales(options, className, container) {
		if (options.metric) {
			this._mScale = DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = DomUtil.create('div', className, container);
		}
	},

	_update: function _update() {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function _updateScales(maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function _updateMetric(maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function _updateImperial(maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles,
		    miles,
		    feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function _updateScale(scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function _getRoundNum(num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = exports.scale = function scale(options) {
	return new Scale(options);
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.VideoOverlay = undefined;
exports.videoOverlay = videoOverlay;

var _ImageOverlay = __webpack_require__(50);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.VideoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = exports.VideoOverlay = _ImageOverlay.ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true
	},

	_initImage: function _initImage() {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : DomUtil.create('video');

		DomUtil.addClass(vid, 'leaflet-image-layer');
		if (this._zoomAnimated) {
			DomUtil.addClass(vid, 'leaflet-zoom-animated');
		}

		vid.onselectstart = Util.falseFn;
		vid.onmousemove = Util.falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = Util.bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			var sourceElements = vid.getElementsByTagName('source');
			var sources = [];
			for (var j = 0; j < sourceElements.length; j++) {
				sources.push(sourceElements[j].src);
			}

			this._url = sourceElements.length > 0 ? sources : [vid.src];
			return;
		}

		if (!Util.isArray(this._url)) {
			this._url = [this._url];
		}

		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = DomUtil.create('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});

// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.popup = exports.Popup = undefined;

var _DivOverlay = __webpack_require__(51);

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Point = __webpack_require__(3);

var _Map = __webpack_require__(8);

var _Layer = __webpack_require__(12);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Path = __webpack_require__(23);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */

// @namespace Popup
var Popup = exports.Popup = _DivOverlay.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnEscapeKey: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the ESC key for closing of the popup.
		closeOnEscapeKey: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function openOn(map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function onAdd(map) {
		_DivOverlay.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', { popup: this });

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', { popup: this }, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof _Path.Path)) {
				this._source.on('preclick', DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function onRemove(map) {
		_DivOverlay.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', { popup: this });

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', { popup: this }, true);
			if (!(this._source instanceof _Path.Path)) {
				this._source.off('preclick', DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function getEvents() {
		var events = _DivOverlay.DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function _close() {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function _initLayout() {
		var prefix = 'leaflet-popup',
		    container = this._container = DomUtil.create('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');

		var wrapper = this._wrapper = DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = DomUtil.create('div', prefix + '-content', wrapper);

		DomEvent.disableClickPropagation(wrapper);
		DomEvent.disableScrollPropagation(this._contentNode);
		DomEvent.on(wrapper, 'contextmenu', DomEvent.stopPropagation);

		this._tipContainer = DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = DomUtil.create('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function _updateLayout() {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = width + 1 + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			DomUtil.addClass(container, scrolledClass);
		} else {
			DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function _animateZoom(e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function _adjustPan() {
		if (!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress) {
			return;
		}

		var map = this._map,
		    marginBottom = parseInt(DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new _Point.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = (0, _Point.toPoint)(this.options.autoPanPadding),
		    paddingTL = (0, _Point.toPoint)(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = (0, _Point.toPoint)(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) {
			// right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) {
			// left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) {
			// bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) {
			// top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map.fire('autopanstart').panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function _onCloseButtonClick(e) {
		this._close();
		DomEvent.stop(e);
	},

	_getAnchor: function _getAnchor() {
		// Where should we anchor the popup on the source layer?
		return (0, _Point.toPoint)(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = exports.popup = function popup(options, source) {
	return new Popup(options, source);
};

/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
_Map.Map.mergeOptions({
	closePopupOnClick: true
});

// @namespace Map
// @section Methods for Layers and Controls
_Map.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function openPopup(popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function closePopup(popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
_Layer.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function bindPopup(content, options) {

		if (content instanceof Popup) {
			Util.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function unbindPopup() {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function openPopup(layer, latlng) {
		if (!(layer instanceof _Layer.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof _FeatureGroup.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function closePopup() {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function togglePopup(target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function isPopupOpen() {
		return this._popup ? this._popup.isOpen() : false;
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function setPopupContent(content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function getPopup() {
		return this._popup;
	},

	_openPopup: function _openPopup(e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof _Path.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function _movePopup(e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function _onKeyPress(e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.tooltip = exports.Tooltip = undefined;

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _DivOverlay = __webpack_require__(51);

var _Point = __webpack_require__(3);

var _Map = __webpack_require__(8);

var _Layer = __webpack_require__(12);

var _FeatureGroup = __webpack_require__(18);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offsetting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */

// @namespace Tooltip
var Tooltip = exports.Tooltip = _DivOverlay.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamically switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function onAdd(map) {
		_DivOverlay.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', { tooltip: this });

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', { tooltip: this }, true);
		}
	},

	onRemove: function onRemove(map) {
		_DivOverlay.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', { tooltip: this });

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', { tooltip: this }, true);
		}
	},

	getEvents: function getEvents() {
		var events = _DivOverlay.DivOverlay.prototype.getEvents.call(this);

		if (Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function _close() {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function _initLayout() {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = DomUtil.create('div', className);
	},

	_updateLayout: function _updateLayout() {},

	_adjustPan: function _adjustPan() {},

	_setPosition: function _setPosition(pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = (0, _Point.toPoint)(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add((0, _Point.toPoint)(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add((0, _Point.toPoint)(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract((0, _Point.toPoint)(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		DomUtil.removeClass(container, 'leaflet-tooltip-right');
		DomUtil.removeClass(container, 'leaflet-tooltip-left');
		DomUtil.removeClass(container, 'leaflet-tooltip-top');
		DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		DomUtil.setPosition(container, pos);
	},

	_updatePosition: function _updatePosition() {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function setOpacity(opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function _animateZoom(e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function _getAnchor() {
		// Where should we anchor the tooltip on the source layer?
		return (0, _Point.toPoint)(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = exports.tooltip = function tooltip(options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
_Map.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function openTooltip(tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function closeTooltip(tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
_Layer.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function bindTooltip(content, options) {

		if (content instanceof Tooltip) {
			Util.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);
		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function unbindTooltip() {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function _initTooltipInteractions(remove) {
		if (!remove && this._tooltipHandlersAdded) {
			return;
		}
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		};
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function openTooltip(layer, latlng) {
		if (!(layer instanceof _Layer.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof _FeatureGroup.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function closeTooltip() {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function toggleTooltip(target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function isTooltipOpen() {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function setTooltipContent(content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function getTooltip() {
		return this._tooltip;
	},

	_openTooltip: function _openTooltip(e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function _moveTooltip(e) {
		var latlng = e.latlng,
		    containerPoint,
		    layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.marker = exports.Marker = exports.divIcon = exports.DivIcon = exports.Icon = exports.icon = undefined;

var _Icon = __webpack_require__(30);

Object.defineProperty(exports, 'icon', {
  enumerable: true,
  get: function get() {
    return _Icon.icon;
  }
});

var _DivIcon = __webpack_require__(135);

Object.defineProperty(exports, 'DivIcon', {
  enumerable: true,
  get: function get() {
    return _DivIcon.DivIcon;
  }
});
Object.defineProperty(exports, 'divIcon', {
  enumerable: true,
  get: function get() {
    return _DivIcon.divIcon;
  }
});

var _Marker = __webpack_require__(48);

Object.defineProperty(exports, 'Marker', {
  enumerable: true,
  get: function get() {
    return _Marker.Marker;
  }
});
Object.defineProperty(exports, 'marker', {
  enumerable: true,
  get: function get() {
    return _Marker.marker;
  }
});

var _Icon2 = __webpack_require__(78);

_Icon.Icon.Default = _Icon2.IconDefault;
exports.Icon = _Icon.Icon;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.DivIcon = undefined;
exports.divIcon = divIcon;

var _Icon = __webpack_require__(30);

var _Point = __webpack_require__(3);

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = exports.DivIcon = _Icon.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function createIcon(oldIcon) {
		var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = (0, _Point.toPoint)(options.bgPos);
			div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function createShadow() {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tileLayer = exports.TileLayer = exports.gridLayer = exports.GridLayer = undefined;

var _GridLayer = __webpack_require__(83);

Object.defineProperty(exports, 'GridLayer', {
  enumerable: true,
  get: function get() {
    return _GridLayer.GridLayer;
  }
});
Object.defineProperty(exports, 'gridLayer', {
  enumerable: true,
  get: function get() {
    return _GridLayer.gridLayer;
  }
});

var _TileLayer = __webpack_require__(52);

var _TileLayer2 = __webpack_require__(53);

_TileLayer.TileLayer.WMS = _TileLayer2.TileLayerWMS;
_TileLayer.tileLayer.wms = _TileLayer2.tileLayerWMS;
exports.TileLayer = _TileLayer.TileLayer;
exports.tileLayer = _TileLayer.tileLayer;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectangle = exports.Rectangle = exports.polygon = exports.Polygon = exports.polyline = exports.Polyline = exports.circle = exports.Circle = exports.circleMarker = exports.CircleMarker = exports.Path = exports.svg = exports.SVG = exports.canvas = exports.Canvas = exports.Renderer = undefined;

var _Renderer = __webpack_require__(31);

Object.defineProperty(exports, 'Renderer', {
  enumerable: true,
  get: function get() {
    return _Renderer.Renderer;
  }
});

var _Canvas = __webpack_require__(84);

Object.defineProperty(exports, 'Canvas', {
  enumerable: true,
  get: function get() {
    return _Canvas.Canvas;
  }
});
Object.defineProperty(exports, 'canvas', {
  enumerable: true,
  get: function get() {
    return _Canvas.canvas;
  }
});

var _Path = __webpack_require__(23);

Object.defineProperty(exports, 'Path', {
  enumerable: true,
  get: function get() {
    return _Path.Path;
  }
});

var _CircleMarker = __webpack_require__(32);

Object.defineProperty(exports, 'CircleMarker', {
  enumerable: true,
  get: function get() {
    return _CircleMarker.CircleMarker;
  }
});
Object.defineProperty(exports, 'circleMarker', {
  enumerable: true,
  get: function get() {
    return _CircleMarker.circleMarker;
  }
});

var _Circle = __webpack_require__(85);

Object.defineProperty(exports, 'Circle', {
  enumerable: true,
  get: function get() {
    return _Circle.Circle;
  }
});
Object.defineProperty(exports, 'circle', {
  enumerable: true,
  get: function get() {
    return _Circle.circle;
  }
});

var _Polyline = __webpack_require__(56);

Object.defineProperty(exports, 'Polyline', {
  enumerable: true,
  get: function get() {
    return _Polyline.Polyline;
  }
});
Object.defineProperty(exports, 'polyline', {
  enumerable: true,
  get: function get() {
    return _Polyline.polyline;
  }
});

var _Polygon = __webpack_require__(57);

Object.defineProperty(exports, 'Polygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.Polygon;
  }
});
Object.defineProperty(exports, 'polygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.polygon;
  }
});

var _Rectangle = __webpack_require__(138);

Object.defineProperty(exports, 'Rectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.Rectangle;
  }
});
Object.defineProperty(exports, 'rectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.rectangle;
  }
});

var _SVG = __webpack_require__(87);

__webpack_require__(140);

_SVG.SVG.create = _SVG.create;
_SVG.SVG.pointsToPath = _SVG.pointsToPath;
exports.SVG = _SVG.SVG;
exports.svg = _SVG.svg;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rectangle = undefined;
exports.rectangle = rectangle;

var _Polygon = __webpack_require__(57);

var _LatLngBounds = __webpack_require__(10);

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Rectangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */

var Rectangle = exports.Rectangle = _Polygon.Polygon.extend({
  initialize: function initialize(latLngBounds, options) {
    _Polygon.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
  },

  // @method setBounds(latLngBounds: LatLngBounds): this
  // Redraws the rectangle with the passed bounds.
  setBounds: function setBounds(latLngBounds) {
    return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
  },

  _boundsToLatLngs: function _boundsToLatLngs(latLngBounds) {
    latLngBounds = (0, _LatLngBounds.toLatLngBounds)(latLngBounds);
    return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
  }
});

// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
  return new Rectangle(latLngBounds, options);
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.vmlMixin = exports.vmlCreate = undefined;

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

var _Renderer = __webpack_require__(31);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

var vmlCreate = exports.vmlCreate = function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
}();

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = exports.vmlMixin = {

	_initContainer: function _initContainer() {
		this._container = DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function _update() {
		if (this._map._animatingZoom) {
			return;
		}
		_Renderer.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function _initPath(layer) {
		var container = layer._container = vmlCreate('shape');

		DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[Util.stamp(layer)] = layer;
	},

	_addPath: function _addPath(layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function _removePath(layer) {
		var container = layer._container;
		DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[Util.stamp(layer)];
	},

	_updateStyle: function _updateStyle(layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = Util.isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;
		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;
		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function _updateCircle(layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
	},

	_setPath: function _setPath(layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function _bringToFront(layer) {
		DomUtil.toFront(layer._container);
	},

	_bringToBack: function _bringToBack(layer) {
		DomUtil.toBack(layer._container);
	}
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Map = __webpack_require__(8);

var _Canvas = __webpack_require__(84);

var _SVG = __webpack_require__(87);

_Map.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function getRenderer(layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = this.options.preferCanvas && (0, _Canvas.canvas)() || (0, _SVG.svg)();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function _getPaneRenderer(name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = _SVG.SVG && (0, _SVG.svg)({ pane: name }) || _Canvas.Canvas && (0, _Canvas.canvas)({ pane: name });
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletWMSGroup = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _domRepeat = __webpack_require__(44);

var _leafletWms = __webpack_require__(142);

__webpack_require__(143);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletWMSGroup = exports.LeafletWMSGroup = function (_PolymerElement) {
  _inherits(LeafletWMSGroup, _PolymerElement);

  _createClass(LeafletWMSGroup, null, [{
    key: 'template',
    get: function get() {
      // return `
      //   <template is="dom-repeat" items="{{subLayers}}">
      //     <leaflet-wms-layer wms-source="[[wmsSource]]" layer="[[item]]"></leaflet-wms-layer>
      //   </template>
      // `;
    }
  }, {
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },

        source: {
          type: String,
          observer: '_sourceChange',
          reflectToAttribute: true
        },
        layers: {
          type: Array,
          observer: '_layersChange',
          reflectToAttribute: true
        },

        transparent: {
          type: Boolean,
          value: true,
          reflectToAttribute: true
        },
        format: {
          type: String,
          value: 'image/png',
          reflectToAttribute: true
        },
        identify: Boolean,
        minZoom: Number,
        maxZoom: Number,
        attribution: String,

        wmsSource: Object,
        subLayers: {
          type: Array,
          value: []
        }
      };
    }
  }]);

  function LeafletWMSGroup() {
    _classCallCheck(this, LeafletWMSGroup);

    return _possibleConstructorReturn(this, (LeafletWMSGroup.__proto__ || Object.getPrototypeOf(LeafletWMSGroup)).call(this));
  }

  _createClass(LeafletWMSGroup, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletWMSGroup.prototype.__proto__ || Object.getPrototypeOf(LeafletWMSGroup.prototype), 'connectedCallback', this).call(this);
    }
  }, {
    key: '_sourceChange',
    value: function _sourceChange() {
      if (this.wmsSource) this.wmsSource.removeFrom(this.map);

      this._wmsOptions = {
        transparent: this.transparent,
        format: this.format,
        identify: this.identify,
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        attribution: this.attribution
      };

      this.wmsSource = new _leafletWms.wms.Source(this.source, this._wmsOptions);
      if (this.map) this.wmsSource.addTo(this.map);

      this._layersChange();
    }
  }, {
    key: '_layersChange',
    value: function _layersChange(newValue, oldValue) {
      // FIXME: use promise instead please
      if (this.wmsSource) this.wmsSource.replaceAllSubLayers(this.layers);
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      this.wmsSource.addTo(this.map); // FIXME: there could be a race condition here for this.map
    }
  }]);

  return LeafletWMSGroup;
}(_polymerElement.Element);

customElements.define('leaflet-wms-group', LeafletWMSGroup);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wms = undefined;

var _Layer = __webpack_require__(12);

var _ImageOverlay = __webpack_require__(50);

var _TileLayerWMS = __webpack_require__(53);

var _CRSEPSG = __webpack_require__(54);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var wms = exports.wms = {};

/*
 * wms.Source
 * The Source object manages a single WMS connection.  Multiple "layers" can be
 * created with the getLayer function, but a single request will be sent for
 * each image update.  Can be used in non-tiled "overlay" mode (default), or
 * tiled mode, via an internal wms.Overlay or wms.TileLayer, respectively.
 */
/*!
 * leaflet.wms.js
 * A collection of Leaflet utilities for working with Web Mapping services.
 * (c) 2014-2016, Houston Engineering, Inc.
 * MIT License
 */

wms.Source = _Layer.Layer.extend({
    'options': {
        'untiled': true,
        'identify': true
    },

    'initialize': function initialize(url, options) {
        Util.setOptions(this, options);
        if (this.options.tiled) {
            this.options.untiled = false;
        }
        this._url = url;
        this._subLayers = {};
        this._overlay = this.createOverlay(this.options.untiled);
    },

    'createOverlay': function createOverlay(untiled) {
        // Create overlay with all options other than untiled & identify
        var overlayOptions = {};
        for (var opt in this.options) {
            if (opt != 'untiled' && opt != 'identify') {
                overlayOptions[opt] = this.options[opt];
            }
        }
        if (untiled) {
            return wms.overlay(this._url, overlayOptions);
        } else {
            return wms.tileLayer(this._url, overlayOptions);
        }
    },

    'onAdd': function onAdd() {
        this.refreshOverlay();
    },

    'onRemove': function onRemove() {
        if (this._map) this._overlay.removeFrom(this._map);
    },

    'getEvents': function getEvents() {
        if (this.options.identify) {
            return { 'click': this.identify };
        } else {
            return {};
        }
    },

    'setOpacity': function setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._overlay) {
            this._overlay.setOpacity(opacity);
        }
    },

    'bringToBack': function bringToBack() {
        this.options.isBack = true;
        if (this._overlay) {
            this._overlay.bringToBack();
        }
    },

    'bringToFront': function bringToFront() {
        this.options.isBack = false;
        if (this._overlay) {
            this._overlay.bringToFront();
        }
    },

    'getLayer': function getLayer(name) {
        return wms.layer(this, name);
    },

    'getSubLayers': function getSubLayers() {
        return this._subLayers;
    },

    'addSubLayer': function addSubLayer(name) {
        this._subLayers[name] = true;
        this.refreshOverlay();
    },

    'removeSubLayer': function removeSubLayer(name) {
        delete this._subLayers[name];
        this.refreshOverlay();
    },

    /* Efficient way to swap out all sub layers */
    'replaceAllSubLayers': function replaceAllSubLayers(newSubLayers) {
        this._subLayers = {};
        for (var i = 0; i < newSubLayers.length; i++) {
            this._subLayers[newSubLayers[i]] = true;
        }this.refreshOverlay();
    },

    'refreshOverlay': function refreshOverlay() {
        var subLayers = Object.keys(this._subLayers).join(",");
        if (!this._map) {
            return;
        }
        if (!subLayers) {
            this._overlay.remove();
        } else {
            this._overlay.setParams({ 'layers': subLayers });
            this._overlay.addTo(this._map);
        }
    },

    'identify': function identify(evt) {
        // Identify map features in response to map clicks. To customize this
        // behavior, create a class extending wms.Source and override one or
        // more of the following hook functions.

        var layers = this.getIdentifyLayers();
        if (!layers.length) {
            return;
        }
        this.getFeatureInfo(evt.containerPoint, evt.latlng, layers, this.showFeatureInfo);
    },

    'getFeatureInfo': function getFeatureInfo(point, latlng, layers, callback) {
        // Request WMS GetFeatureInfo and call callback with results
        // (split from identify() to faciliate use outside of map events)
        var params = this.getFeatureInfoParams(point, layers),
            url = this._url + Util.getParamString(params, this._url);

        this.showWaiting();
        this.ajax(url, done);

        function done(result) {
            this.hideWaiting();
            var text = this.parseFeatureInfo(result, url);
            callback.call(this, latlng, text);
        }
    },

    'ajax': function ajax(url, callback) {
        wms.ajax.call(this, url, callback);
    },

    'getIdentifyLayers': function getIdentifyLayers() {
        // Hook to determine which layers to identify
        if (this.options.identifyLayers) return this.options.identifyLayers;
        return Object.keys(this._subLayers);
    },

    'getFeatureInfoParams': function getFeatureInfoParams(point, layers) {
        // Hook to generate parameters for WMS service GetFeatureInfo request
        var wmsParams, overlay;
        if (this.options.untiled) {
            // Use existing overlay
            wmsParams = this._overlay.wmsParams;
        } else {
            // Create overlay instance to leverage updateWmsParams
            overlay = this.createOverlay(true);
            overlay.updateWmsParams(this._map);
            wmsParams = overlay.wmsParams;
            wmsParams.layers = layers.join(',');
        }
        var infoParams = {
            'request': 'GetFeatureInfo',
            'query_layers': layers.join(','),
            'X': Math.round(point.x),
            'Y': Math.round(point.y)
        };
        return Util.extend({}, wmsParams, infoParams);
    },

    'parseFeatureInfo': function parseFeatureInfo(result, url) {
        // Hook to handle parsing AJAX response
        if (result == "error") {
            // AJAX failed, possibly due to CORS issues.
            // Try loading content in <iframe>.
            result = "<iframe src='" + url + "' style='border:none'>";
        }
        return result;
    },

    'showFeatureInfo': function showFeatureInfo(latlng, info) {
        // Hook to handle displaying parsed AJAX response to the user
        if (!this._map) {
            return;
        }
        this._map.openPopup(info, latlng);
    },

    'showWaiting': function showWaiting() {
        // Hook to customize AJAX wait animation
        if (!this._map) return;
        this._map._container.style.cursor = "progress";
    },

    'hideWaiting': function hideWaiting() {
        // Hook to remove AJAX wait animation
        if (!this._map) return;
        this._map._container.style.cursor = "default";
    }
});

wms.source = function (url, options) {
    return new wms.Source(url, options);
};

/*
 * Layer
 * Leaflet "layer" with all actual rendering handled via an underlying Source
 * object.  Can be called directly with a URL to automatically create or reuse
 * an existing Source.  Note that the auto-source feature doesn't work well in
 * multi-map environments; so for best results, create a Source first and use
 * getLayer() to retrieve wms.Layer instances.
 */

wms.Layer = _Layer.Layer.extend({
    'initialize': function initialize(source, layerName, options) {
        Util.setOptions(this, options);
        if (!source.addSubLayer) {
            // Assume source is a URL
            source = wms.getSourceForUrl(source, options);
        }
        this._source = source;
        this._name = layerName;
    },
    'onAdd': function onAdd() {
        if (!this._source._map) this._source.addTo(this._map);
        this._source.addSubLayer(this._name);
    },
    'onRemove': function onRemove() {
        this._source.removeSubLayer(this._name);
    },
    'setOpacity': function setOpacity(opacity) {
        this._source.setOpacity(opacity);
    },
    'bringToBack': function bringToBack() {
        this._source.bringToBack();
    },
    'bringToFront': function bringToFront() {
        this._source.bringToFront();
    }
});

wms.layer = function (source, options) {
    return new wms.Layer(source, options);
};

// Cache of sources for use with wms.Layer auto-source option
wms.sources = {};
wms.getSourceForUrl = function (url, options) {
    if (!wms.sources[url]) {
        wms.sources[url] = wms.source(url, options);
    }
    return wms.sources[url];
};

// Copy tiled WMS layer from leaflet core, in case we need to subclass it later
wms.TileLayer = _TileLayerWMS.TileLayerWMS;
wms.tileLayer = _TileLayerWMS.tileLayerWMS;

/*
 * wms.Overlay:
 * "Single Tile" WMS image overlay that updates with map changes.
 * Portions of wms.Overlay are directly extracted from L.TileLayer.WMS.
 * See Leaflet license.
 */
wms.Overlay = _Layer.Layer.extend({
    'defaultWmsParams': {
        'service': 'WMS',
        'request': 'GetMap',
        'version': '1.1.1',
        'layers': '',
        'styles': '',
        'format': 'image/jpeg',
        'transparent': false
    },

    'options': {
        'crs': null,
        'uppercase': false,
        'attribution': '',
        'opacity': 1,
        'isBack': false,
        'minZoom': 0,
        'maxZoom': 18
    },

    'initialize': function initialize(url, options) {
        this._url = url;

        // Move WMS parameters to params object
        var params = {},
            opts = {};
        for (var opt in options) {
            if (opt in this.options) {
                opts[opt] = options[opt];
            } else {
                params[opt] = options[opt];
            }
        }
        Util.setOptions(this, opts);
        this.wmsParams = Util.extend({}, this.defaultWmsParams, params);
    },

    'setParams': function setParams(params) {
        Util.extend(this.wmsParams, params);
        this.update();
    },

    'getAttribution': function getAttribution() {
        return this.options.attribution;
    },

    'onAdd': function onAdd() {
        this.update();
    },

    'onRemove': function onRemove(map) {
        if (this._currentOverlay) {
            map.removeLayer(this._currentOverlay);
            delete this._currentOverlay;
        }
        if (this._currentUrl) {
            delete this._currentUrl;
        }
    },

    'getEvents': function getEvents() {
        return {
            'moveend': this.update
        };
    },

    'update': function update() {
        if (!this._map) {
            return;
        }
        // Determine image URL and whether it has changed since last update
        this.updateWmsParams();
        var url = this.getImageUrl();
        if (this._currentUrl == url) {
            return;
        }
        this._currentUrl = url;

        // Keep current image overlay in place until new one loads
        // (inspired by esri.leaflet)
        var bounds = this._map.getBounds();
        var overlay = new _ImageOverlay.ImageOverlay(url, bounds, { 'opacity': 0 });
        overlay.addTo(this._map);
        overlay.once('load', _swap, this);
        function _swap() {
            if (!this._map) {
                return;
            }
            if (overlay._url != this._currentUrl) {
                this._map.removeLayer(overlay);
                return;
            } else if (this._currentOverlay) {
                this._map.removeLayer(this._currentOverlay);
            }
            this._currentOverlay = overlay;
            overlay.setOpacity(this.options.opacity ? this.options.opacity : 1);
            if (this.options.isBack === true) {
                overlay.bringToBack();
            }
            if (this.options.isBack === false) {
                overlay.bringToFront();
            }
        }
        if (this._map.getZoom() < this.options.minZoom || this._map.getZoom() > this.options.maxZoom) {
            this._map.removeLayer(overlay);
        }
    },

    'setOpacity': function setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._currentOverlay) {
            this._currentOverlay.setOpacity(opacity);
        }
    },

    'bringToBack': function bringToBack() {
        this.options.isBack = true;
        if (this._currentOverlay) {
            this._currentOverlay.bringToBack();
        }
    },

    'bringToFront': function bringToFront() {
        this.options.isBack = false;
        if (this._currentOverlay) {
            this._currentOverlay.bringToFront();
        }
    },

    // See L.TileLayer.WMS: onAdd() & getTileUrl()
    'updateWmsParams': function updateWmsParams(map) {
        if (!map) {
            map = this._map;
        }
        // Compute WMS options
        var bounds = map.getBounds();
        var size = map.getSize();
        var wmsVersion = parseFloat(this.wmsParams.version);
        var crs = this.options.crs || map.options.crs;
        var projectionKey = wmsVersion >= 1.3 ? 'crs' : 'srs';
        var nw = crs.project(bounds.getNorthWest());
        var se = crs.project(bounds.getSouthEast());

        // Assemble WMS parameter string
        var params = {
            'width': size.x,
            'height': size.y
        };
        params[projectionKey] = crs.code;
        params.bbox = (wmsVersion >= 1.3 && crs.code === _CRSEPSG.EPSG4326.code ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(',');

        Util.extend(this.wmsParams, params);
    },

    'getImageUrl': function getImageUrl() {
        var uppercase = this.options.uppercase || false;
        var pstr = Util.getParamString(this.wmsParams, this._url, uppercase);
        return this._url + pstr;
    }
});

wms.overlay = function (url, options) {
    return new wms.Overlay(url, options);
};

// Simple AJAX helper (since we can't assume jQuery etc. are present)
wms.ajax = function (url, callback) {
    var context = this,
        request = new XMLHttpRequest();
    request.onreadystatechange = change;
    request.open('GET', url);
    request.send();

    function change() {
        if (request.readyState === 4) {
            if (request.status === 200) {
                callback.call(context, request.responseText);
            } else {
                callback.call(context, "error");
            }
        }
    }
};

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletWMSLayer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletWMSLayer = exports.LeafletWMSLayer = function (_PolymerElement) {
  _inherits(LeafletWMSLayer, _PolymerElement);

  _createClass(LeafletWMSLayer, null, [{
    key: 'properties',
    get: function get() {
      return {
        wmsSource: Object,
        layer: {
          type: String,
          reflectToAttribute: true
        }
      };
    }
  }]);

  function LeafletWMSLayer() {
    _classCallCheck(this, LeafletWMSLayer);

    return _possibleConstructorReturn(this, (LeafletWMSLayer.__proto__ || Object.getPrototypeOf(LeafletWMSLayer)).call(this));
  }

  _createClass(LeafletWMSLayer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletWMSLayer.prototype.__proto__ || Object.getPrototypeOf(LeafletWMSLayer.prototype), 'connectedCallback', this).call(this);

      if (this.wmsSource === undefined || this.layer === '') return;
      this.wmsSource.addSubLayer(this.layer);
    }
  }]);

  return LeafletWMSLayer;
}(_polymerElement.Element);

customElements.define('leaflet-wms-layer', LeafletWMSLayer);

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletTileLayer = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _TileLayer = __webpack_require__(52);

var _TileLayerWMS = __webpack_require__(53);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletTileLayer = exports.LeafletTileLayer = function (_PolymerElement) {
  _inherits(LeafletTileLayer, _PolymerElement);

  _createClass(LeafletTileLayer, null, [{
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object,
          observer: '_mapSet'
        },
        base: Boolean,
        url: {
          type: String,
          value: "//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          observer: '_urlChanged',
          reflectToAttribute: true
        },
        format: {
          type: String,
          observer: '_formatChanged',
          reflectToAttribute: true
        },
        layers: {
          type: String,
          observer: '_layersChanged'
        },
        minZoom: Number,
        maxZoom: Number,
        attribution: String
      };
    }
  }]);

  function LeafletTileLayer() {
    _classCallCheck(this, LeafletTileLayer);

    return _possibleConstructorReturn(this, (LeafletTileLayer.__proto__ || Object.getPrototypeOf(LeafletTileLayer)).call(this));
  }

  _createClass(LeafletTileLayer, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletTileLayer.prototype.__proto__ || Object.getPrototypeOf(LeafletTileLayer.prototype), 'connectedCallback', this).call(this);
    }
  }, {
    key: '_urlChanged',
    value: function _urlChanged() {
      console.log('url changed', this.url);
      if (this.leafletLayer) this.leafletLayer.setUrl(this.url);
    }
  }, {
    key: '_layersChanged',
    value: function _layersChanged() {
      console.log('layers changed', this.layers);
      if (this.leafletLayer && this.leafletLayer instanceof _TileLayerWMS.TileLayerWMS) this.leafletLayer.setParams({ layers: this.layers });
    }
  }, {
    key: '_formatChanged',
    value: function _formatChanged() {
      console.log('format changed', this.format);

      if (this.leafletLayer && this.map) {
        this.leafletLayer.removeFrom(this.map);
      }

      var options = {
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        attribution: this.attribution
      };

      switch (this.format) {
        case 'XYZ':
          this.leafletLayer = new _TileLayer.TileLayer(this.url, options);
          break;
        case 'WMS':
          this.leafletLayer = new _TileLayerWMS.TileLayerWMS(this.url, Object.assign(options, {
            layers: this.layers,
            format: 'image/png',
            transparent: false,
            hints: 'quality'
          }));
          break;
        default:
          console.error('Invalid leaflet-tile-layer format: ', this.format);
          return;
      }

      if (this.map) this.leafletLayer.addTo(this.map);else console.log('map not yet set');
    }
  }, {
    key: '_mapSet',
    value: function _mapSet() {
      console.log('map set');
      if (this.leafletLayer && !this.map.hasLayer(this.leafletLayer)) {
        console.log('no layer yet, adding');
        this.leafletLayer.addTo(this.map);
      } else {
        console.log('layer object not set / layer exists, skipping');
      }
    }
  }]);

  return LeafletTileLayer;
}(_polymerElement.Element);

customElements.define('leaflet-tile-layer', LeafletTileLayer);

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletGeoJSON = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _polymerElement = __webpack_require__(11);

var _domRepeat = __webpack_require__(44);

var _CircleMarker = __webpack_require__(32);

var _GeoJSON = __webpack_require__(88);

__webpack_require__(146);

var _src = __webpack_require__(156);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeafletGeoJSON = exports.LeafletGeoJSON = function (_PolymerElement) {
  _inherits(LeafletGeoJSON, _PolymerElement);

  _createClass(LeafletGeoJSON, null, [{
    key: 'properties',
    get: function get() {
      return {
        map: {
          type: Object
        },

        source: {
          type: String,
          observer: '_sourceChange',
          reflectToAttribute: true
        },

        fillColor: {
          type: String,
          value: '#FF80AB'
        },

        outlineColor: {
          type: String,
          value: '#FF1744'
        },

        radius: {
          type: Number,
          value: 10
        },

        weight: {
          type: Number,
          value: 3
        },

        opacity: {
          type: Number,
          value: 1.0
        },

        fillOpacity: {
          type: Number,
          value: 1.0
        },

        cluster: Boolean,
        maxClusterRadius: {
          type: Number,
          value: 80
        },
        identify: Boolean,
        minZoom: Number,
        maxZoom: Number,
        attribution: String
      };
    }
  }]);

  function LeafletGeoJSON() {
    _classCallCheck(this, LeafletGeoJSON);

    return _possibleConstructorReturn(this, (LeafletGeoJSON.__proto__ || Object.getPrototypeOf(LeafletGeoJSON)).call(this));
  }

  _createClass(LeafletGeoJSON, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      _get(LeafletGeoJSON.prototype.__proto__ || Object.getPrototypeOf(LeafletGeoJSON.prototype), 'connectedCallback', this).call(this);

      this._clusterGroup = new _src.MarkerClusterGroup({
        showCoverageOnHover: false,
        maxClusterRadius: this.maxClusterRadius
      });

      this._circleMakerOptions = {
        color: this.outlineColor,
        fillColor: this.fillColor,
        radius: this.radius,
        weight: this.weight,
        opacity: this.opacity,
        fillOpacity: this.fillOpacity
      };
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      _get(LeafletGeoJSON.prototype.__proto__ || Object.getPrototypeOf(LeafletGeoJSON.prototype), 'disconnectedCallback', this).call(this);
      this.map.removeLayer(this._clusterGroup);
      this._clusterGroup.clearLayers();
    }
  }, {
    key: '_addGeoJSONLayer',
    value: function _addGeoJSONLayer(geojson) {
      this._clusterGroup.clearLayers();

      this._geoJSONOptions = {
        pointToLayer: this._pointToLayer.bind(this),
        attribution: this.attribution
      };
      this._geoJSONLayer = new _GeoJSON.GeoJSON(geojson, this._geoJSONOptions);

      if (this.cluster) {
        this.map.addLayer(this._clusterGroup);
      } else {
        this.map.addLayer(this._geoJSONLayer);
      }
    }
  }, {
    key: '_pointToLayer',
    value: function _pointToLayer(feature, latlng) {
      var marker = new _CircleMarker.CircleMarker(latlng, this._circleMakerOptions);
      if (this.identify) marker.bindPopup(this._generatePopupContent(feature));

      if (this.cluster) this._clusterGroup.addLayer(marker);
      return marker;
    }
  }, {
    key: '_generatePopupContent',
    value: function _generatePopupContent(feature) {
      var rows = '';
      for (var p in feature.properties) {
        var fieldName = p.replace(/\w\S*/g, function (txt) {
          return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase().replace('_', ' ');
        });
        rows += '<tr><td>' + fieldName + ':</td><td><strong>' + feature.properties[p] + '</strong></td></tr>';
      }

      return '<table>' + rows + '</table>';
    }
  }, {
    key: '_sourceChange',
    value: function _sourceChange() {
      if (this.map && this._geoJSONLayer) this._geoJSONLayer.removeFrom(this.map);

      fetch(this.source).then(function (res) {
        return res.json();
      }).then(this._addGeoJSONLayer.bind(this));
      // .catch(() => alert('Unable to load layer'));
    }
  }]);

  return LeafletGeoJSON;
}(_polymerElement.Element);

customElements.define('leaflet-geojson-points', LeafletGeoJSON);

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.version = undefined;

var _index = __webpack_require__(81);

Object.keys(_index).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index[key];
		}
	});
});

var _index2 = __webpack_require__(147);

Object.keys(_index2).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index2[key];
		}
	});
});

var _index3 = __webpack_require__(148);

Object.keys(_index3).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index3[key];
		}
	});
});

var _index4 = __webpack_require__(149);

Object.keys(_index4).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index4[key];
		}
	});
});

var _index5 = __webpack_require__(150);

Object.keys(_index5).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index5[key];
		}
	});
});

var _index6 = __webpack_require__(82);

Object.keys(_index6).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index6[key];
		}
	});
});

var _index7 = __webpack_require__(79);

Object.keys(_index7).forEach(function (key) {
	if (key === "default" || key === "__esModule") return;
	Object.defineProperty(exports, key, {
		enumerable: true,
		get: function get() {
			return _index7[key];
		}
	});
});
exports.noConflict = noConflict;

var _package = __webpack_require__(155);

var _Util = __webpack_require__(0);

exports.version = _package.version;

// control


// core


// dom


// geometry


// geo


// layer


// map

// misc

var oldL = window.L;
function noConflict() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

Object.freeze = _Util.freeze;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setOptions = exports.stamp = exports.bind = exports.extend = exports.Util = exports.Handler = exports.Mixin = exports.Evented = exports.Class = exports.Browser = undefined;

var _Class = __webpack_require__(20);

Object.defineProperty(exports, 'Class', {
  enumerable: true,
  get: function get() {
    return _Class.Class;
  }
});

var _Handler = __webpack_require__(14);

Object.defineProperty(exports, 'Handler', {
  enumerable: true,
  get: function get() {
    return _Handler.Handler;
  }
});

var _Util = __webpack_require__(0);

Object.defineProperty(exports, 'extend', {
  enumerable: true,
  get: function get() {
    return _Util.extend;
  }
});
Object.defineProperty(exports, 'bind', {
  enumerable: true,
  get: function get() {
    return _Util.bind;
  }
});
Object.defineProperty(exports, 'stamp', {
  enumerable: true,
  get: function get() {
    return _Util.stamp;
  }
});
Object.defineProperty(exports, 'setOptions', {
  enumerable: true,
  get: function get() {
    return _Util.setOptions;
  }
});

var _Browser = __webpack_require__(4);

var Browser = _interopRequireWildcard(_Browser);

var _Events = __webpack_require__(19);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Browser = Browser;
exports.Evented = _Events.Evented;
var Mixin = exports.Mixin = { Events: _Events.Events };

exports.Util = Util;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Draggable = exports.DomUtil = exports.DomEvent = exports.PosAnimation = undefined;

var _PosAnimation = __webpack_require__(77);

Object.defineProperty(exports, 'PosAnimation', {
  enumerable: true,
  get: function get() {
    return _PosAnimation.PosAnimation;
  }
});

var _Draggable = __webpack_require__(49);

Object.defineProperty(exports, 'Draggable', {
  enumerable: true,
  get: function get() {
    return _Draggable.Draggable;
  }
});

var _DomEvent = __webpack_require__(6);

var DomEvent = _interopRequireWildcard(_DomEvent);

var _DomUtil = __webpack_require__(1);

var DomUtil = _interopRequireWildcard(_DomUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolyUtil = exports.LineUtil = exports.transformation = exports.Transformation = exports.bounds = exports.Bounds = exports.point = exports.Point = undefined;

var _Point = __webpack_require__(3);

Object.defineProperty(exports, 'Point', {
  enumerable: true,
  get: function get() {
    return _Point.Point;
  }
});
Object.defineProperty(exports, 'point', {
  enumerable: true,
  get: function get() {
    return _Point.toPoint;
  }
});

var _Bounds = __webpack_require__(5);

Object.defineProperty(exports, 'Bounds', {
  enumerable: true,
  get: function get() {
    return _Bounds.Bounds;
  }
});
Object.defineProperty(exports, 'bounds', {
  enumerable: true,
  get: function get() {
    return _Bounds.toBounds;
  }
});

var _Transformation = __webpack_require__(21);

Object.defineProperty(exports, 'Transformation', {
  enumerable: true,
  get: function get() {
    return _Transformation.Transformation;
  }
});
Object.defineProperty(exports, 'transformation', {
  enumerable: true,
  get: function get() {
    return _Transformation.toTransformation;
  }
});

var _LineUtil = __webpack_require__(24);

var LineUtil = _interopRequireWildcard(_LineUtil);

var _PolyUtil = __webpack_require__(86);

var PolyUtil = _interopRequireWildcard(_PolyUtil);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Projection = exports.latLngBounds = exports.LatLngBounds = exports.latLng = exports.LatLng = undefined;

var _LatLng = __webpack_require__(9);

Object.defineProperty(exports, 'LatLng', {
  enumerable: true,
  get: function get() {
    return _LatLng.LatLng;
  }
});
Object.defineProperty(exports, 'latLng', {
  enumerable: true,
  get: function get() {
    return _LatLng.toLatLng;
  }
});

var _LatLngBounds = __webpack_require__(10);

Object.defineProperty(exports, 'LatLngBounds', {
  enumerable: true,
  get: function get() {
    return _LatLngBounds.LatLngBounds;
  }
});
Object.defineProperty(exports, 'latLngBounds', {
  enumerable: true,
  get: function get() {
    return _LatLngBounds.toLatLngBounds;
  }
});

var _index = __webpack_require__(151);

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

var _index2 = __webpack_require__(154);

var Projection = _interopRequireWildcard(_index2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.Projection = Projection;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CRS = undefined;

var _CRS = __webpack_require__(47);

var _CRS2 = __webpack_require__(16);

var _CRS3 = __webpack_require__(152);

var _CRS4 = __webpack_require__(73);

var _CRS5 = __webpack_require__(54);

var _CRS6 = __webpack_require__(153);

_CRS.CRS.Earth = _CRS2.Earth;
_CRS.CRS.EPSG3395 = _CRS3.EPSG3395;
_CRS.CRS.EPSG3857 = _CRS4.EPSG3857;
_CRS.CRS.EPSG900913 = _CRS4.EPSG900913;
_CRS.CRS.EPSG4326 = _CRS5.EPSG4326;
_CRS.CRS.Simple = _CRS6.Simple;

exports.CRS = _CRS.CRS;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.EPSG3395 = undefined;

var _CRS = __webpack_require__(16);

var _Projection = __webpack_require__(89);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = exports.EPSG3395 = Util.extend({}, _CRS.Earth, {
	code: 'EPSG:3395',
	projection: _Projection.Mercator,

	transformation: function () {
		var scale = 0.5 / (Math.PI * _Projection.Mercator.R);
		return (0, _Transformation.toTransformation)(scale, 0.5, -scale, 0.5);
	}()
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Simple = undefined;

var _CRS = __webpack_require__(47);

var _Projection = __webpack_require__(55);

var _Transformation = __webpack_require__(21);

var _Util = __webpack_require__(0);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = exports.Simple = Util.extend({}, _CRS.CRS, {
	projection: _Projection.LonLat,
	transformation: (0, _Transformation.toTransformation)(1, 0, -1, 0),

	scale: function scale(zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function zoom(scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function distance(latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Projection = __webpack_require__(55);

Object.defineProperty(exports, 'LonLat', {
  enumerable: true,
  get: function get() {
    return _Projection.LonLat;
  }
});

var _Projection2 = __webpack_require__(89);

Object.defineProperty(exports, 'Mercator', {
  enumerable: true,
  get: function get() {
    return _Projection2.Mercator;
  }
});

var _Projection3 = __webpack_require__(74);

Object.defineProperty(exports, 'SphericalMercator', {
  enumerable: true,
  get: function get() {
    return _Projection3.SphericalMercator;
  }
});

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = {"name":"leaflet","version":"1.3.1","description":"JavaScript library for mobile-friendly interactive maps","devDependencies":{"eslint":"^4.5.0","eslint-config-mourner":"^2.0.1","git-rev-sync":"^1.8.0","happen":"~0.3.2","jake":"~8.0.12","karma":"^1.3.0","karma-chrome-launcher":"^2.0.0","karma-coverage":"~1.1.1","karma-firefox-launcher":"~1.0.0","karma-mocha":"^1.2.0","karma-phantomjs-launcher":"^1.0.2","karma-rollup-preprocessor":"^5.0.1","karma-safari-launcher":"~1.0.0","leafdoc":"^1.4.1","mocha":"^3.1.0","phantomjs-prebuilt":"^2.1.12","prosthetic-hand":"^1.3.1","rollup":"^0.51.8","rollup-plugin-git-version":"0.2.1","rollup-plugin-json":"^2.1.0","rollup-watch":"^4.3.1","source-map":"^0.5.6","ssri":"^4.1.2","uglify-js":"~3.0.26"},"main":"dist/leaflet-src.js","style":"dist/leaflet.css","files":["dist","src","!dist/leaflet.zip"],"scripts":{"docs":"jake docs","test-jake":"jake test","test":"jake test","build-jake":"jake build","build":"npm run rollup && npm run uglify","release":"./build/publish.sh","lint":"eslint src; eslint spec/suites","lintfix":"eslint src --fix; eslint spec/suites --fix; ","rollup":"rollup -c build/rollup-config.js","watch":"rollup -w -c build/rollup-watch-config.js","uglify":"uglifyjs dist/leaflet-src.js -c -m -o dist/leaflet.js --source-map filename=dist/leaflet.js.map --in-source-map dist/leaflet-src.js.map --source-map-url leaflet.js.map --comments","integrity":"nodejs ./build/integrity.js"},"eslintConfig":{"root":true,"globals":{"L":true},"env":{"commonjs":true,"amd":true,"node":false},"extends":"mourner","parserOptions":{"ecmaVersion":6,"sourceType":"module"},"rules":{"linebreak-style":[0,"unix"],"no-mixed-spaces-and-tabs":[2,"smart-tabs"],"indent":[2,"tab",{"VariableDeclarator":0,"flatTernaryExpressions":true}],"curly":2,"spaced-comment":2,"strict":0,"wrap-iife":0,"key-spacing":0,"consistent-return":0}},"repository":{"type":"git","url":"git://github.com/Leaflet/Leaflet.git"},"keywords":["gis","map"],"license":"BSD-2-Clause"}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerCluster = exports.MarkerClusterGroup = undefined;

var _MarkerClusterGroup = __webpack_require__(157);

Object.defineProperty(exports, 'MarkerClusterGroup', {
  enumerable: true,
  get: function get() {
    return _MarkerClusterGroup.MarkerClusterGroup;
  }
});

var _MarkerCluster = __webpack_require__(158);

Object.defineProperty(exports, 'MarkerCluster', {
  enumerable: true,
  get: function get() {
    return _MarkerCluster.MarkerCluster;
  }
});

__webpack_require__(159);

__webpack_require__(160);

__webpack_require__(161);

__webpack_require__(162);

__webpack_require__(163);

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

var MarkerClusterGroup = exports.MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({

	options: {
		maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
		iconCreateFunction: null,
		clusterPane: L.Marker.prototype.options.pane,

		spiderfyOnMaxZoom: true,
		showCoverageOnHover: true,
		zoomToBoundsOnClick: true,
		singleMarkerMode: false,

		disableClusteringAtZoom: null,

		// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
		// is the default behaviour for performance reasons.
		removeOutsideVisibleBounds: true,

		// Set to false to disable all animations (zoom and spiderfy).
		// If false, option animateAddingMarkers below has no effect.
		// If L.DomUtil.TRANSITION is falsy, this option has no effect.
		animate: true,

		//Whether to animate adding markers after adding the MarkerClusterGroup to the map
		// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
		animateAddingMarkers: false,

		//Increase to increase the distance away that spiderfied markers appear from the center
		spiderfyDistanceMultiplier: 1,

		// Make it possible to specify a polyline options on a spider leg
		spiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },

		// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
		chunkedLoading: false,
		chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
		chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
		chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

		//Options to pass to the L.Polygon constructor
		polygonOptions: {}
	},

	initialize: function initialize(options) {
		L.Util.setOptions(this, options);
		if (!this.options.iconCreateFunction) {
			this.options.iconCreateFunction = this._defaultIconCreateFunction;
		}

		this._featureGroup = L.featureGroup();
		this._featureGroup.addEventParent(this);

		this._nonPointGroup = L.featureGroup();
		this._nonPointGroup.addEventParent(this);

		this._inZoomAnimation = 0;
		this._needsClustering = [];
		this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
		//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
		this._currentShownBounds = null;

		this._queue = [];

		this._childMarkerEventHandlers = {
			'dragstart': this._childMarkerDragStart,
			'move': this._childMarkerMoved,
			'dragend': this._childMarkerDragEnd
		};

		// Hook the appropriate animation methods.
		var animate = L.DomUtil.TRANSITION && this.options.animate;
		L.extend(this, animate ? this._withAnimation : this._noAnimation);
		// Remember which MarkerCluster class to instantiate (animated or not).
		this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
	},

	addLayer: function addLayer(layer) {

		if (layer instanceof L.LayerGroup) {
			return this.addLayers([layer]);
		}

		//Don't cluster non point data
		if (!layer.getLatLng) {
			this._nonPointGroup.addLayer(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (!this._map) {
			this._needsClustering.push(layer);
			this.fire('layeradd', { layer: layer });
			return this;
		}

		if (this.hasLayer(layer)) {
			return this;
		}

		//If we have already clustered we'll need to add this one to a cluster

		if (this._unspiderfy) {
			this._unspiderfy();
		}

		this._addLayer(layer, this._maxZoom);
		this.fire('layeradd', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Work out what is visible
		var visibleLayer = layer,
		    currentZoom = this._zoom;
		if (layer.__parent) {
			while (visibleLayer.__parent._zoom >= currentZoom) {
				visibleLayer = visibleLayer.__parent;
			}
		}

		if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
			if (this.options.animateAddingMarkers) {
				this._animationAddLayer(layer, visibleLayer);
			} else {
				this._animationAddLayerNonAnimated(layer, visibleLayer);
			}
		}
		return this;
	},

	removeLayer: function removeLayer(layer) {

		if (layer instanceof L.LayerGroup) {
			return this.removeLayers([layer]);
		}

		//Non point layers
		if (!layer.getLatLng) {
			this._nonPointGroup.removeLayer(layer);
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!this._map) {
			if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
				this._needsRemoving.push({ layer: layer, latlng: layer._latlng });
			}
			this.fire('layerremove', { layer: layer });
			return this;
		}

		if (!layer.__parent) {
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			this._unspiderfyLayer(layer);
		}

		//Remove the marker from clusters
		this._removeLayer(layer, true);
		this.fire('layerremove', { layer: layer });

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		layer.off(this._childMarkerEventHandlers, this);

		if (this._featureGroup.hasLayer(layer)) {
			this._featureGroup.removeLayer(layer);
			if (layer.clusterShow) {
				layer.clusterShow();
			}
		}

		return this;
	},

	//Takes an array of markers and adds them in bulk
	addLayers: function addLayers(layersArray, skipLayerAddEvent) {
		if (!L.Util.isArray(layersArray)) {
			return this.addLayer(layersArray);
		}

		var fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    chunked = this.options.chunkedLoading,
		    chunkInterval = this.options.chunkInterval,
		    chunkProgress = this.options.chunkProgress,
		    l = layersArray.length,
		    offset = 0,
		    originalArray = true,
		    m;

		if (this._map) {
			var started = new Date().getTime();
			var process = L.bind(function () {
				var start = new Date().getTime();
				for (; offset < l; offset++) {
					if (chunked && offset % 200 === 0) {
						// every couple hundred markers, instrument the time elapsed since processing started:
						var elapsed = new Date().getTime() - start;
						if (elapsed > chunkInterval) {
							break; // been working too hard, time to take a break :-)
						}
					}

					m = layersArray[offset];

					// Group of layers, append children to layersArray and skip.
					// Side effects:
					// - Total increases, so chunkProgress ratio jumps backward.
					// - Groups are not included in this group, only their non-group child layers (hasLayer).
					// Changing array length while looping does not affect performance in current browsers:
					// http://jsperf.com/for-loop-changing-length/6
					if (m instanceof L.LayerGroup) {
						if (originalArray) {
							layersArray = layersArray.slice();
							originalArray = false;
						}
						this._extractNonGroupLayers(m, layersArray);
						l = layersArray.length;
						continue;
					}

					//Not point data, can't be clustered
					if (!m.getLatLng) {
						npg.addLayer(m);
						if (!skipLayerAddEvent) {
							this.fire('layeradd', { layer: m });
						}
						continue;
					}

					if (this.hasLayer(m)) {
						continue;
					}

					this._addLayer(m, this._maxZoom);
					if (!skipLayerAddEvent) {
						this.fire('layeradd', { layer: m });
					}

					//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
					if (m.__parent) {
						if (m.__parent.getChildCount() === 2) {
							var markers = m.__parent.getAllChildMarkers(),
							    otherMarker = markers[0] === m ? markers[1] : markers[0];
							fg.removeLayer(otherMarker);
						}
					}
				}

				if (chunkProgress) {
					// report progress and time elapsed:
					chunkProgress(offset, l, new Date().getTime() - started);
				}

				// Completed processing all markers.
				if (offset === l) {

					// Refresh bounds and weighted positions.
					this._topClusterLevel._recalculateBounds();

					this._refreshClustersIcons();

					this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
				} else {
					setTimeout(process, this.options.chunkDelay);
				}
			}, this);

			process();
		} else {
			var needsClustering = this._needsClustering;

			for (; offset < l; offset++) {
				m = layersArray[offset];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				//Not point data, can't be clustered
				if (!m.getLatLng) {
					npg.addLayer(m);
					continue;
				}

				if (this.hasLayer(m)) {
					continue;
				}

				needsClustering.push(m);
			}
		}
		return this;
	},

	//Takes an array of markers and removes them in bulk
	removeLayers: function removeLayers(layersArray) {
		var i,
		    m,
		    l = layersArray.length,
		    fg = this._featureGroup,
		    npg = this._nonPointGroup,
		    originalArray = true;

		if (!this._map) {
			for (i = 0; i < l; i++) {
				m = layersArray[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					if (originalArray) {
						layersArray = layersArray.slice();
						originalArray = false;
					}
					this._extractNonGroupLayers(m, layersArray);
					l = layersArray.length;
					continue;
				}

				this._arraySplice(this._needsClustering, m);
				npg.removeLayer(m);
				if (this.hasLayer(m)) {
					this._needsRemoving.push({ layer: m, latlng: m._latlng });
				}
				this.fire('layerremove', { layer: m });
			}
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();

			// Work on a copy of the array, so that next loop is not affected.
			var layersArray2 = layersArray.slice(),
			    l2 = l;
			for (i = 0; i < l2; i++) {
				m = layersArray2[i];

				// Group of layers, append children to layersArray and skip.
				if (m instanceof L.LayerGroup) {
					this._extractNonGroupLayers(m, layersArray2);
					l2 = layersArray2.length;
					continue;
				}

				this._unspiderfyLayer(m);
			}
		}

		for (i = 0; i < l; i++) {
			m = layersArray[i];

			// Group of layers, append children to layersArray and skip.
			if (m instanceof L.LayerGroup) {
				if (originalArray) {
					layersArray = layersArray.slice();
					originalArray = false;
				}
				this._extractNonGroupLayers(m, layersArray);
				l = layersArray.length;
				continue;
			}

			if (!m.__parent) {
				npg.removeLayer(m);
				this.fire('layerremove', { layer: m });
				continue;
			}

			this._removeLayer(m, true, true);
			this.fire('layerremove', { layer: m });

			if (fg.hasLayer(m)) {
				fg.removeLayer(m);
				if (m.clusterShow) {
					m.clusterShow();
				}
			}
		}

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		this._refreshClustersIcons();

		//Fix up the clusters and markers on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

		return this;
	},

	//Removes all layers from the MarkerClusterGroup
	clearLayers: function clearLayers() {
		//Need our own special implementation as the LayerGroup one doesn't work for us

		//If we aren't on the map (yet), blow away the markers we know of
		if (!this._map) {
			this._needsClustering = [];
			delete this._gridClusters;
			delete this._gridUnclustered;
		}

		if (this._noanimationUnspiderfy) {
			this._noanimationUnspiderfy();
		}

		//Remove all the visible layers
		this._featureGroup.clearLayers();
		this._nonPointGroup.clearLayers();

		this.eachLayer(function (marker) {
			marker.off(this._childMarkerEventHandlers, this);
			delete marker.__parent;
		}, this);

		if (this._map) {
			//Reset _topClusterLevel and the DistanceGrids
			this._generateInitialClusters();
		}

		return this;
	},

	//Override FeatureGroup.getBounds as it doesn't work
	getBounds: function getBounds() {
		var bounds = new L.LatLngBounds();

		if (this._topClusterLevel) {
			bounds.extend(this._topClusterLevel._bounds);
		}

		for (var i = this._needsClustering.length - 1; i >= 0; i--) {
			bounds.extend(this._needsClustering[i].getLatLng());
		}

		bounds.extend(this._nonPointGroup.getBounds());

		return bounds;
	},

	//Overrides LayerGroup.eachLayer
	eachLayer: function eachLayer(method, context) {
		var markers = this._needsClustering.slice(),
		    needsRemoving = this._needsRemoving,
		    thisNeedsRemoving,
		    i,
		    j;

		if (this._topClusterLevel) {
			this._topClusterLevel.getAllChildMarkers(markers);
		}

		for (i = markers.length - 1; i >= 0; i--) {
			thisNeedsRemoving = true;

			for (j = needsRemoving.length - 1; j >= 0; j--) {
				if (needsRemoving[j].layer === markers[i]) {
					thisNeedsRemoving = false;
					break;
				}
			}

			if (thisNeedsRemoving) {
				method.call(context, markers[i]);
			}
		}

		this._nonPointGroup.eachLayer(method, context);
	},

	//Overrides LayerGroup.getLayers
	getLayers: function getLayers() {
		var layers = [];
		this.eachLayer(function (l) {
			layers.push(l);
		});
		return layers;
	},

	//Overrides LayerGroup.getLayer, WARNING: Really bad performance
	getLayer: function getLayer(id) {
		var result = null;

		id = parseInt(id, 10);

		this.eachLayer(function (l) {
			if (L.stamp(l) === id) {
				result = l;
			}
		});

		return result;
	},

	//Returns true if the given layer is in this MarkerClusterGroup
	hasLayer: function hasLayer(layer) {
		if (!layer) {
			return false;
		}

		var i,
		    anArray = this._needsClustering;

		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return true;
			}
		}

		anArray = this._needsRemoving;
		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i].layer === layer) {
				return false;
			}
		}

		return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
	},

	//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
	zoomToShowLayer: function zoomToShowLayer(layer, callback) {

		if (typeof callback !== 'function') {
			callback = function callback() {};
		}

		var showMarker = function showMarker() {
			if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
				this._map.off('moveend', showMarker, this);
				this.off('animationend', showMarker, this);

				if (layer._icon) {
					callback();
				} else if (layer.__parent._icon) {
					this.once('spiderfied', callback, this);
					layer.__parent.spiderfy();
				}
			}
		};

		if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
			//Layer is visible ond on screen, immediate return
			callback();
		} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {
			//Layer should be visible at this zoom level. It must not be on screen so just pan over to it
			this._map.on('moveend', showMarker, this);
			this._map.panTo(layer.getLatLng());
		} else {
			this._map.on('moveend', showMarker, this);
			this.on('animationend', showMarker, this);
			layer.__parent.zoomToBounds();
		}
	},

	//Overrides FeatureGroup.onAdd
	onAdd: function onAdd(map) {
		this._map = map;
		var i, l, layer;

		if (!isFinite(this._map.getMaxZoom())) {
			throw "Map has no maxZoom specified";
		}

		this._featureGroup.addTo(map);
		this._nonPointGroup.addTo(map);

		if (!this._gridClusters) {
			this._generateInitialClusters();
		}

		this._maxLat = map.options.crs.projection.MAX_LATITUDE;

		//Restore all the positions as they are in the MCG before removing them
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			layer.newlatlng = layer.layer._latlng;
			layer.layer._latlng = layer.latlng;
		}
		//Remove them, then restore their new positions
		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			this._removeLayer(layer.layer, true);
			layer.layer._latlng = layer.newlatlng;
		}
		this._needsRemoving = [];

		//Remember the current zoom level and bounds
		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();

		this._map.on('zoomend', this._zoomEnd, this);
		this._map.on('moveend', this._moveEnd, this);

		if (this._spiderfierOnAdd) {
			//TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnAdd();
		}

		this._bindEvents();

		//Actually add our markers to the map:
		l = this._needsClustering;
		this._needsClustering = [];
		this.addLayers(l, true);
	},

	//Overrides FeatureGroup.onRemove
	onRemove: function onRemove(map) {
		map.off('zoomend', this._zoomEnd, this);
		map.off('moveend', this._moveEnd, this);

		this._unbindEvents();

		//In case we are in a cluster animation
		this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

		if (this._spiderfierOnRemove) {
			//TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnRemove();
		}

		delete this._maxLat;

		//Clean up all the layers we added to the map
		this._hideCoverage();
		this._featureGroup.remove();
		this._nonPointGroup.remove();

		this._featureGroup.clearLayers();

		this._map = null;
	},

	getVisibleParent: function getVisibleParent(marker) {
		var vMarker = marker;
		while (vMarker && !vMarker._icon) {
			vMarker = vMarker.__parent;
		}
		return vMarker || null;
	},

	//Remove the given object from the given array
	_arraySplice: function _arraySplice(anArray, obj) {
		for (var i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === obj) {
				anArray.splice(i, 1);
				return true;
			}
		}
	},

	/**
  * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
  * @param marker to be removed from _gridUnclustered.
  * @param z integer bottom start zoom level (included)
  * @private
  */
	_removeFromGridUnclustered: function _removeFromGridUnclustered(marker, z) {
		var map = this._map,
		    gridUnclustered = this._gridUnclustered,
		    minZoom = Math.floor(this._map.getMinZoom());

		for (; z >= minZoom; z--) {
			if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
				break;
			}
		}
	},

	_childMarkerDragStart: function _childMarkerDragStart(e) {
		e.target.__dragStart = e.target._latlng;
	},

	_childMarkerMoved: function _childMarkerMoved(e) {
		if (!this._ignoreMove && !e.target.__dragStart) {
			var isPopupOpen = e.target._popup && e.target._popup.isOpen();

			this._moveChild(e.target, e.oldLatLng, e.latlng);

			if (isPopupOpen) {
				e.target.openPopup();
			}
		}
	},

	_moveChild: function _moveChild(layer, from, to) {
		layer._latlng = from;
		this.removeLayer(layer);

		layer._latlng = to;
		this.addLayer(layer);
	},

	_childMarkerDragEnd: function _childMarkerDragEnd(e) {
		if (e.target.__dragStart) {
			this._moveChild(e.target, e.target.__dragStart, e.target._latlng);
		}
		delete e.target.__dragStart;
	},

	//Internal function for removing a marker from everything.
	//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
	_removeLayer: function _removeLayer(marker, removeFromDistanceGrid, dontUpdateMap) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    fg = this._featureGroup,
		    map = this._map,
		    minZoom = Math.floor(this._map.getMinZoom());

		//Remove the marker from distance clusters it might be in
		if (removeFromDistanceGrid) {
			this._removeFromGridUnclustered(marker, this._maxZoom);
		}

		//Work our way up the clusters removing them as we go if required
		var cluster = marker.__parent,
		    markers = cluster._markers,
		    otherMarker;

		//Remove the marker from the immediate parents marker list
		this._arraySplice(markers, marker);

		while (cluster) {
			cluster._childCount--;
			cluster._boundsNeedUpdate = true;

			if (cluster._zoom < minZoom) {
				//Top level, do nothing
				break;
			} else if (removeFromDistanceGrid && cluster._childCount <= 1) {
				//Cluster no longer required
				//We need to push the other marker up to the parent
				otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

				//Update distance grid
				gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
				gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

				//Move otherMarker up to parent
				this._arraySplice(cluster.__parent._childClusters, cluster);
				cluster.__parent._markers.push(otherMarker);
				otherMarker.__parent = cluster.__parent;

				if (cluster._icon) {
					//Cluster is currently on the map, need to put the marker on the map instead
					fg.removeLayer(cluster);
					if (!dontUpdateMap) {
						fg.addLayer(otherMarker);
					}
				}
			} else {
				cluster._iconNeedsUpdate = true;
			}

			cluster = cluster.__parent;
		}

		delete marker.__parent;
	},

	_isOrIsParent: function _isOrIsParent(el, oel) {
		while (oel) {
			if (el === oel) {
				return true;
			}
			oel = oel.parentNode;
		}
		return false;
	},

	//Override L.Evented.fire
	fire: function fire(type, data, propagate) {
		if (data && data.layer instanceof L.MarkerCluster) {
			//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
			if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {
				return;
			}
			type = 'cluster' + type;
		}

		L.FeatureGroup.prototype.fire.call(this, type, data, propagate);
	},

	//Override L.Evented.listens
	listens: function listens(type, propagate) {
		return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);
	},

	//Default functionality
	_defaultIconCreateFunction: function _defaultIconCreateFunction(cluster) {
		var childCount = cluster.getChildCount();

		var c = ' marker-cluster-';
		if (childCount < 10) {
			c += 'small';
		} else if (childCount < 100) {
			c += 'medium';
		} else {
			c += 'large';
		}

		return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
	},

	_bindEvents: function _bindEvents() {
		var map = this._map,
		    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

		//Zoom on cluster click or spiderfy if we are at the lowest level
		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.on('clusterclick', this._zoomOrSpiderfy, this);
		}

		//Show convex hull (boundary) polygon on mouse over
		if (showCoverageOnHover) {
			this.on('clustermouseover', this._showCoverage, this);
			this.on('clustermouseout', this._hideCoverage, this);
			map.on('zoomend', this._hideCoverage, this);
		}
	},

	_zoomOrSpiderfy: function _zoomOrSpiderfy(e) {
		var cluster = e.layer,
		    bottomCluster = cluster;

		while (bottomCluster._childClusters.length === 1) {
			bottomCluster = bottomCluster._childClusters[0];
		}

		if (bottomCluster._zoom === this._maxZoom && bottomCluster._childCount === cluster._childCount && this.options.spiderfyOnMaxZoom) {

			// All child markers are contained in a single cluster from this._maxZoom to this cluster.
			cluster.spiderfy();
		} else if (this.options.zoomToBoundsOnClick) {
			cluster.zoomToBounds();
		}

		// Focus the map again for keyboard users.
		if (e.originalEvent && e.originalEvent.keyCode === 13) {
			this._map._container.focus();
		}
	},

	_showCoverage: function _showCoverage(e) {
		var map = this._map;
		if (this._inZoomAnimation) {
			return;
		}
		if (this._shownPolygon) {
			map.removeLayer(this._shownPolygon);
		}
		if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
			this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
			map.addLayer(this._shownPolygon);
		}
	},

	_hideCoverage: function _hideCoverage() {
		if (this._shownPolygon) {
			this._map.removeLayer(this._shownPolygon);
			this._shownPolygon = null;
		}
	},

	_unbindEvents: function _unbindEvents() {
		var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
		    map = this._map;

		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.off('clusterclick', this._zoomOrSpiderfy, this);
		}
		if (showCoverageOnHover) {
			this.off('clustermouseover', this._showCoverage, this);
			this.off('clustermouseout', this._hideCoverage, this);
			map.off('zoomend', this._hideCoverage, this);
		}
	},

	_zoomEnd: function _zoomEnd() {
		if (!this._map) {
			//May have been removed from the map by a zoomEnd handler
			return;
		}
		this._mergeSplitClusters();

		this._zoom = Math.round(this._map._zoom);
		this._currentShownBounds = this._getExpandedVisibleBounds();
	},

	_moveEnd: function _moveEnd() {
		if (this._inZoomAnimation) {
			return;
		}

		var newBounds = this._getExpandedVisibleBounds();

		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);

		this._currentShownBounds = newBounds;
		return;
	},

	_generateInitialClusters: function _generateInitialClusters() {
		var maxZoom = Math.ceil(this._map.getMaxZoom()),
		    minZoom = Math.floor(this._map.getMinZoom()),
		    radius = this.options.maxClusterRadius,
		    radiusFn = radius;

		//If we just set maxClusterRadius to a single number, we need to create
		//a simple function to return that number. Otherwise, we just have to
		//use the function we've passed in.
		if (typeof radius !== "function") {
			radiusFn = function radiusFn() {
				return radius;
			};
		}

		if (this.options.disableClusteringAtZoom !== null) {
			maxZoom = this.options.disableClusteringAtZoom - 1;
		}
		this._maxZoom = maxZoom;
		this._gridClusters = {};
		this._gridUnclustered = {};

		//Set up DistanceGrids for each zoom
		for (var zoom = maxZoom; zoom >= minZoom; zoom--) {
			this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
			this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
		}

		// Instantiate the appropriate L.MarkerCluster class (animated or not).
		this._topClusterLevel = new this._markerCluster(this, minZoom - 1);
	},

	//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
	_addLayer: function _addLayer(layer, zoom) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    minZoom = Math.floor(this._map.getMinZoom()),
		    markerPoint,
		    z;

		if (this.options.singleMarkerMode) {
			this._overrideMarkerIcon(layer);
		}

		layer.on(this._childMarkerEventHandlers, this);

		//Find the lowest zoom level to slot this one in
		for (; zoom >= minZoom; zoom--) {
			markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

			//Try find a cluster close by
			var closest = gridClusters[zoom].getNearObject(markerPoint);
			if (closest) {
				closest._addChild(layer);
				layer.__parent = closest;
				return;
			}

			//Try find a marker close by to form a new cluster with
			closest = gridUnclustered[zoom].getNearObject(markerPoint);
			if (closest) {
				var parent = closest.__parent;
				if (parent) {
					this._removeLayer(closest, false);
				}

				//Create new cluster with these 2 in it

				var newCluster = new this._markerCluster(this, zoom, closest, layer);
				gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
				closest.__parent = newCluster;
				layer.__parent = newCluster;

				//First create any new intermediate parent clusters that don't exist
				var lastParent = newCluster;
				for (z = zoom - 1; z > parent._zoom; z--) {
					lastParent = new this._markerCluster(this, z, lastParent);
					gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
				}
				parent._addChild(lastParent);

				//Remove closest from this zoom level and any above that it is in, replace with newCluster
				this._removeFromGridUnclustered(closest, zoom);

				return;
			}

			//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
			gridUnclustered[zoom].addObject(layer, markerPoint);
		}

		//Didn't get in anything, add us to the top
		this._topClusterLevel._addChild(layer);
		layer.__parent = this._topClusterLevel;
		return;
	},

	/**
  * Refreshes the icon of all "dirty" visible clusters.
  * Non-visible "dirty" clusters will be updated when they are added to the map.
  * @private
  */
	_refreshClustersIcons: function _refreshClustersIcons() {
		this._featureGroup.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
				c._updateIcon();
			}
		});
	},

	//Enqueue code to fire after the marker expand/contract has happened
	_enqueue: function _enqueue(fn) {
		this._queue.push(fn);
		if (!this._queueTimeout) {
			this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
		}
	},
	_processQueue: function _processQueue() {
		for (var i = 0; i < this._queue.length; i++) {
			this._queue[i].call(this);
		}
		this._queue.length = 0;
		clearTimeout(this._queueTimeout);
		this._queueTimeout = null;
	},

	//Merge and split any existing clusters that are too big or small
	_mergeSplitClusters: function _mergeSplitClusters() {
		var mapZoom = Math.round(this._map._zoom);

		//In case we are starting to split before the animation finished
		this._processQueue();

		if (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) {
			//Zoom in, split
			this._animationStart();
			//Remove clusters now off screen
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());

			this._animationZoomIn(this._zoom, mapZoom);
		} else if (this._zoom > mapZoom) {
			//Zoom out, merge
			this._animationStart();

			this._animationZoomOut(this._zoom, mapZoom);
		} else {
			this._moveEnd();
		}
	},

	//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
	_getExpandedVisibleBounds: function _getExpandedVisibleBounds() {
		if (!this.options.removeOutsideVisibleBounds) {
			return this._mapBoundsInfinite;
		} else if (L.Browser.mobile) {
			return this._checkBoundsMaxLat(this._map.getBounds());
		}

		return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.
	},

	/**
  * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
  * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
  * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
  * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
  * making the user think that MCG "eats" them and never displays them again.
  * @param bounds L.LatLngBounds
  * @returns {L.LatLngBounds}
  * @private
  */
	_checkBoundsMaxLat: function _checkBoundsMaxLat(bounds) {
		var maxLat = this._maxLat;

		if (maxLat !== undefined) {
			if (bounds.getNorth() >= maxLat) {
				bounds._northEast.lat = Infinity;
			}
			if (bounds.getSouth() <= -maxLat) {
				bounds._southWest.lat = -Infinity;
			}
		}

		return bounds;
	},

	//Shared animation code
	_animationAddLayerNonAnimated: function _animationAddLayerNonAnimated(layer, newCluster) {
		if (newCluster === layer) {
			this._featureGroup.addLayer(layer);
		} else if (newCluster._childCount === 2) {
			newCluster._addToMap();

			var markers = newCluster.getAllChildMarkers();
			this._featureGroup.removeLayer(markers[0]);
			this._featureGroup.removeLayer(markers[1]);
		} else {
			newCluster._updateIcon();
		}
	},

	/**
  * Extracts individual (i.e. non-group) layers from a Layer Group.
  * @param group to extract layers from.
  * @param output {Array} in which to store the extracted layers.
  * @returns {*|Array}
  * @private
  */
	_extractNonGroupLayers: function _extractNonGroupLayers(group, output) {
		var layers = group.getLayers(),
		    i = 0,
		    layer;

		output = output || [];

		for (; i < layers.length; i++) {
			layer = layers[i];

			if (layer instanceof L.LayerGroup) {
				this._extractNonGroupLayers(layer, output);
				continue;
			}

			output.push(layer);
		}

		return output;
	},

	/**
  * Implements the singleMarkerMode option.
  * @param layer Marker to re-style using the Clusters iconCreateFunction.
  * @returns {L.Icon} The newly created icon.
  * @private
  */
	_overrideMarkerIcon: function _overrideMarkerIcon(layer) {
		var icon = layer.options.icon = this.options.iconCreateFunction({
			getChildCount: function getChildCount() {
				return 1;
			},
			getAllChildMarkers: function getAllChildMarkers() {
				return [layer];
			}
		});

		return icon;
	}
});

// Constant bounds used in case option "removeOutsideVisibleBounds" is set to false.
L.MarkerClusterGroup.include({
	_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))
});

L.MarkerClusterGroup.include({
	_noAnimation: {
		//Non Animated versions of everything
		_animationStart: function _animationStart() {
			//Do nothing...
		},
		_animationZoomIn: function _animationZoomIn(previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationZoomOut: function _animationZoomOut(previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationAddLayer: function _animationAddLayer(layer, newCluster) {
			this._animationAddLayerNonAnimated(layer, newCluster);
		}
	},

	_withAnimation: {
		//Animated versions here
		_animationStart: function _animationStart() {
			this._map._mapPane.className += ' leaflet-cluster-anim';
			this._inZoomAnimation++;
		},

		_animationZoomIn: function _animationZoomIn(previousZoomLevel, newZoomLevel) {
			var bounds = this._getExpandedVisibleBounds(),
			    fg = this._featureGroup,
			    minZoom = Math.floor(this._map.getMinZoom()),
			    i;

			this._ignoreMove = true;

			//Add all children of current clusters to map and remove those clusters from map
			this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
				var startPos = c._latlng,
				    markers = c._markers,
				    m;

				if (!bounds.contains(startPos)) {
					startPos = null;
				}

				if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) {
					//Immediately add the new child and remove us
					fg.removeLayer(c);
					c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
				} else {
					//Fade out old cluster
					c.clusterHide();
					c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
				}

				//Remove all markers that aren't visible any more
				//TODO: Do we actually need to do this on the higher levels too?
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];
					if (!bounds.contains(m._latlng)) {
						fg.removeLayer(m);
					}
				}
			});

			this._forceLayout();

			//Update opacities
			this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
			//TODO Maybe? Update markers in _recursivelyBecomeVisible
			fg.eachLayer(function (n) {
				if (!(n instanceof L.MarkerCluster) && n._icon) {
					n.clusterShow();
				}
			});

			//update the positions of the just added clusters/markers
			this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
				c._recursivelyRestoreChildPositions(newZoomLevel);
			});

			this._ignoreMove = false;

			//Remove the old clusters and close the zoom animation
			this._enqueue(function () {
				//update the positions of the just added clusters/markers
				this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {
					fg.removeLayer(c);
					c.clusterShow();
				});

				this._animationEnd();
			});
		},

		_animationZoomOut: function _animationZoomOut(previousZoomLevel, newZoomLevel) {
			this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

			//Need to add markers for those that weren't on the map before but are now
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
			//Remove markers that were on the map before but won't be now
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());
		},

		_animationAddLayer: function _animationAddLayer(layer, newCluster) {
			var me = this,
			    fg = this._featureGroup;

			fg.addLayer(layer);
			if (newCluster !== layer) {
				if (newCluster._childCount > 2) {
					//Was already a cluster

					newCluster._updateIcon();
					this._forceLayout();
					this._animationStart();

					layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
					layer.clusterHide();

					this._enqueue(function () {
						fg.removeLayer(layer);
						layer.clusterShow();

						me._animationEnd();
					});
				} else {
					//Just became a cluster
					this._forceLayout();

					me._animationStart();
					me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);
				}
			}
		}
	},

	// Private methods for animated versions.
	_animationZoomOutSingle: function _animationZoomOutSingle(cluster, previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds(),
		    minZoom = Math.floor(this._map.getMinZoom());

		//Animate all of the markers in the clusters to move to their cluster center point
		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);

		var me = this;

		//Update the opacity (If we immediately set it they won't animate)
		this._forceLayout();
		cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

		//TODO: Maybe use the transition timing stuff to make this more reliable
		//When the animations are done, tidy up
		this._enqueue(function () {

			//This cluster stopped being a cluster before the timeout fired
			if (cluster._childCount === 1) {
				var m = cluster._markers[0];
				//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
				this._ignoreMove = true;
				m.setLatLng(m.getLatLng());
				this._ignoreMove = false;
				if (m.clusterShow) {
					m.clusterShow();
				}
			} else {
				cluster._recursively(bounds, newZoomLevel, minZoom, function (c) {
					c._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);
				});
			}
			me._animationEnd();
		});
	},

	_animationEnd: function _animationEnd() {
		if (this._map) {
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
		}
		this._inZoomAnimation--;
		this.fire('animationend');
	},

	//Force a browser layout of stuff in the map
	// Should apply the current opacity and location to all elements so we can update them again for an animation
	_forceLayout: function _forceLayout() {
		//In my testing this works, infact offsetWidth of any element seems to work.
		//Could loop all this._layers and do this for each _icon if it stops working

		L.Util.falseFn(document.body.offsetWidth);
	}
});

L.markerClusterGroup = function (options) {
	return new L.MarkerClusterGroup(options);
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var MarkerCluster = exports.MarkerCluster = L.MarkerCluster = L.Marker.extend({
	options: L.Icon.prototype.options,

	initialize: function initialize(group, zoom, a, b) {

		L.Marker.prototype.initialize.call(this, a ? a._cLatLng || a.getLatLng() : new L.LatLng(0, 0), { icon: this, pane: group.options.clusterPane });

		this._group = group;
		this._zoom = zoom;

		this._markers = [];
		this._childClusters = [];
		this._childCount = 0;
		this._iconNeedsUpdate = true;
		this._boundsNeedUpdate = true;

		this._bounds = new L.LatLngBounds();

		if (a) {
			this._addChild(a);
		}
		if (b) {
			this._addChild(b);
		}
	},

	//Recursively retrieve all child markers of this cluster
	getAllChildMarkers: function getAllChildMarkers(storageArray) {
		storageArray = storageArray || [];

		for (var i = this._childClusters.length - 1; i >= 0; i--) {
			this._childClusters[i].getAllChildMarkers(storageArray);
		}

		for (var j = this._markers.length - 1; j >= 0; j--) {
			storageArray.push(this._markers[j]);
		}

		return storageArray;
	},

	//Returns the count of how many child markers we have
	getChildCount: function getChildCount() {
		return this._childCount;
	},

	//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
	zoomToBounds: function zoomToBounds(fitBoundsOptions) {
		var childClusters = this._childClusters.slice(),
		    map = this._group._map,
		    boundsZoom = map.getBoundsZoom(this._bounds),
		    zoom = this._zoom + 1,
		    mapZoom = map.getZoom(),
		    i;

		//calculate how far we need to zoom down to see all of the markers
		while (childClusters.length > 0 && boundsZoom > zoom) {
			zoom++;
			var newClusters = [];
			for (i = 0; i < childClusters.length; i++) {
				newClusters = newClusters.concat(childClusters[i]._childClusters);
			}
			childClusters = newClusters;
		}

		if (boundsZoom > zoom) {
			this._group._map.setView(this._latlng, zoom);
		} else if (boundsZoom <= mapZoom) {
			//If fitBounds wouldn't zoom us down, zoom us down instead
			this._group._map.setView(this._latlng, mapZoom + 1);
		} else {
			this._group._map.fitBounds(this._bounds, fitBoundsOptions);
		}
	},

	getBounds: function getBounds() {
		var bounds = new L.LatLngBounds();
		bounds.extend(this._bounds);
		return bounds;
	},

	_updateIcon: function _updateIcon() {
		this._iconNeedsUpdate = true;
		if (this._icon) {
			this.setIcon(this);
		}
	},

	//Cludge for Icon, we pretend to be an icon for performance
	createIcon: function createIcon() {
		if (this._iconNeedsUpdate) {
			this._iconObj = this._group.options.iconCreateFunction(this);
			this._iconNeedsUpdate = false;
		}
		return this._iconObj.createIcon();
	},
	createShadow: function createShadow() {
		return this._iconObj.createShadow();
	},

	_addChild: function _addChild(new1, isNotificationFromChild) {

		this._iconNeedsUpdate = true;

		this._boundsNeedUpdate = true;
		this._setClusterCenter(new1);

		if (new1 instanceof L.MarkerCluster) {
			if (!isNotificationFromChild) {
				this._childClusters.push(new1);
				new1.__parent = this;
			}
			this._childCount += new1._childCount;
		} else {
			if (!isNotificationFromChild) {
				this._markers.push(new1);
			}
			this._childCount++;
		}

		if (this.__parent) {
			this.__parent._addChild(new1, true);
		}
	},

	/**
  * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
  * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
  * @private
  */
	_setClusterCenter: function _setClusterCenter(child) {
		if (!this._cLatLng) {
			// when clustering, take position of the first point as the cluster center
			this._cLatLng = child._cLatLng || child._latlng;
		}
	},

	/**
  * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
  * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
  * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
  * @private
  */
	_resetBounds: function _resetBounds() {
		var bounds = this._bounds;

		if (bounds._southWest) {
			bounds._southWest.lat = Infinity;
			bounds._southWest.lng = Infinity;
		}
		if (bounds._northEast) {
			bounds._northEast.lat = -Infinity;
			bounds._northEast.lng = -Infinity;
		}
	},

	_recalculateBounds: function _recalculateBounds() {
		var markers = this._markers,
		    childClusters = this._childClusters,
		    latSum = 0,
		    lngSum = 0,
		    totalCount = this._childCount,
		    i,
		    child,
		    childLatLng,
		    childCount;

		// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.
		if (totalCount === 0) {
			return;
		}

		// Reset rather than creating a new object, for performance.
		this._resetBounds();

		// Child markers.
		for (i = 0; i < markers.length; i++) {
			childLatLng = markers[i]._latlng;

			this._bounds.extend(childLatLng);

			latSum += childLatLng.lat;
			lngSum += childLatLng.lng;
		}

		// Child clusters.
		for (i = 0; i < childClusters.length; i++) {
			child = childClusters[i];

			// Re-compute child bounds and weighted position first if necessary.
			if (child._boundsNeedUpdate) {
				child._recalculateBounds();
			}

			this._bounds.extend(child._bounds);

			childLatLng = child._wLatLng;
			childCount = child._childCount;

			latSum += childLatLng.lat * childCount;
			lngSum += childLatLng.lng * childCount;
		}

		this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);

		// Reset dirty flag.
		this._boundsNeedUpdate = false;
	},

	//Set our markers position as given and add it to the map
	_addToMap: function _addToMap(startPos) {
		if (startPos) {
			this._backupLatlng = this._latlng;
			this.setLatLng(startPos);
		}
		this._group._featureGroup.addLayer(this);
	},

	_recursivelyAnimateChildrenIn: function _recursivelyAnimateChildrenIn(bounds, center, maxZoom) {
		this._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1, function (c) {
			var markers = c._markers,
			    i,
			    m;
			for (i = markers.length - 1; i >= 0; i--) {
				m = markers[i];

				//Only do it if the icon is still on the map
				if (m._icon) {
					m._setPos(center);
					m.clusterHide();
				}
			}
		}, function (c) {
			var childClusters = c._childClusters,
			    j,
			    cm;
			for (j = childClusters.length - 1; j >= 0; j--) {
				cm = childClusters[j];
				if (cm._icon) {
					cm._setPos(center);
					cm.clusterHide();
				}
			}
		});
	},

	_recursivelyAnimateChildrenInAndAddSelfToMap: function _recursivelyAnimateChildrenInAndAddSelfToMap(bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {
		this._recursively(bounds, newZoomLevel, mapMinZoom, function (c) {
			c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

			//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
			//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
			if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
				c.clusterShow();
				c._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
			} else {
				c.clusterHide();
			}

			c._addToMap();
		});
	},

	_recursivelyBecomeVisible: function _recursivelyBecomeVisible(bounds, zoomLevel) {
		this._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {
			c.clusterShow();
		});
	},

	_recursivelyAddChildrenToMap: function _recursivelyAddChildrenToMap(startPos, zoomLevel, bounds) {
		this._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel, function (c) {
			if (zoomLevel === c._zoom) {
				return;
			}

			//Add our child markers at startPos (so they can be animated out)
			for (var i = c._markers.length - 1; i >= 0; i--) {
				var nm = c._markers[i];

				if (!bounds.contains(nm._latlng)) {
					continue;
				}

				if (startPos) {
					nm._backupLatlng = nm.getLatLng();

					nm.setLatLng(startPos);
					if (nm.clusterHide) {
						nm.clusterHide();
					}
				}

				c._group._featureGroup.addLayer(nm);
			}
		}, function (c) {
			c._addToMap(startPos);
		});
	},

	_recursivelyRestoreChildPositions: function _recursivelyRestoreChildPositions(zoomLevel) {
		//Fix positions of child markers
		for (var i = this._markers.length - 1; i >= 0; i--) {
			var nm = this._markers[i];
			if (nm._backupLatlng) {
				nm.setLatLng(nm._backupLatlng);
				delete nm._backupLatlng;
			}
		}

		if (zoomLevel - 1 === this._zoom) {
			//Reposition child clusters
			for (var j = this._childClusters.length - 1; j >= 0; j--) {
				this._childClusters[j]._restorePosition();
			}
		} else {
			for (var k = this._childClusters.length - 1; k >= 0; k--) {
				this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
			}
		}
	},

	_restorePosition: function _restorePosition() {
		if (this._backupLatlng) {
			this.setLatLng(this._backupLatlng);
			delete this._backupLatlng;
		}
	},

	//exceptBounds: If set, don't remove any markers/clusters in it
	_recursivelyRemoveChildrenFromMap: function _recursivelyRemoveChildrenFromMap(previousBounds, mapMinZoom, zoomLevel, exceptBounds) {
		var m, i;
		this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1, function (c) {
			//Remove markers at every level
			for (i = c._markers.length - 1; i >= 0; i--) {
				m = c._markers[i];
				if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
					c._group._featureGroup.removeLayer(m);
					if (m.clusterShow) {
						m.clusterShow();
					}
				}
			}
		}, function (c) {
			//Remove child clusters at just the bottom level
			for (i = c._childClusters.length - 1; i >= 0; i--) {
				m = c._childClusters[i];
				if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
					c._group._featureGroup.removeLayer(m);
					if (m.clusterShow) {
						m.clusterShow();
					}
				}
			}
		});
	},

	//Run the given functions recursively to this and child clusters
	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
	// zoomLevelToStart: zoom level to start running functions (inclusive)
	// zoomLevelToStop: zoom level to stop running functions (inclusive)
	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
	_recursively: function _recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
		var childClusters = this._childClusters,
		    zoom = this._zoom,
		    i,
		    c;

		if (zoomLevelToStart <= zoom) {
			if (runAtEveryLevel) {
				runAtEveryLevel(this);
			}
			if (runAtBottomLevel && zoom === zoomLevelToStop) {
				runAtBottomLevel(this);
			}
		}

		if (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {
			for (i = childClusters.length - 1; i >= 0; i--) {
				c = childClusters[i];
				if (boundsToApplyTo.intersects(c._bounds)) {
					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
				}
			}
		}
	},

	//Returns true if we are the parent of only one cluster and that cluster is the same as us
	_isSingleParent: function _isSingleParent() {
		//Don't need to check this._markers as the rest won't work if there are any
		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
	}
});

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
* Extends L.Marker to include two extra methods: clusterHide and clusterShow.
* 
* They work as setOpacity(0) and setOpacity(1) respectively, but
* they will remember the marker's opacity when hiding and showing it again.
* 
*/

L.Marker.include({

	clusterHide: function clusterHide() {
		this.options.opacityWhenUnclustered = this.options.opacity || 1;
		return this.setOpacity(0);
	},

	clusterShow: function clusterShow() {
		var ret = this.setOpacity(this.options.opacity || this.options.opacityWhenUnclustered);
		delete this.options.opacityWhenUnclustered;
		return ret;
	}

});

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


L.DistanceGrid = function (cellSize) {
	this._cellSize = cellSize;
	this._sqCellSize = cellSize * cellSize;
	this._grid = {};
	this._objectPoint = {};
};

L.DistanceGrid.prototype = {

	addObject: function addObject(obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    stamp = L.Util.stamp(obj);

		this._objectPoint[stamp] = point;

		cell.push(obj);
	},

	updateObject: function updateObject(obj, point) {
		this.removeObject(obj);
		this.addObject(obj, point);
	},

	//Returns true if the object was found
	removeObject: function removeObject(obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    i,
		    len;

		delete this._objectPoint[L.Util.stamp(obj)];

		for (i = 0, len = cell.length; i < len; i++) {
			if (cell[i] === obj) {

				cell.splice(i, 1);

				if (len === 1) {
					delete row[x];
				}

				return true;
			}
		}
	},

	eachObject: function eachObject(fn, context) {
		var i,
		    j,
		    k,
		    len,
		    row,
		    cell,
		    removed,
		    grid = this._grid;

		for (i in grid) {
			row = grid[i];

			for (j in row) {
				cell = row[j];

				for (k = 0, len = cell.length; k < len; k++) {
					removed = fn.call(context, cell[k]);
					if (removed) {
						k--;
						len--;
					}
				}
			}
		}
	},

	getNearObject: function getNearObject(point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    i,
		    j,
		    k,
		    row,
		    cell,
		    len,
		    obj,
		    dist,
		    objectPoint = this._objectPoint,
		    closestDistSq = this._sqCellSize,
		    closest = null;

		for (i = y - 1; i <= y + 1; i++) {
			row = this._grid[i];
			if (row) {

				for (j = x - 1; j <= x + 1; j++) {
					cell = row[j];
					if (cell) {

						for (k = 0, len = cell.length; k < len; k++) {
							obj = cell[k];
							dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
							if (dist < closestDistSq || dist <= closestDistSq && closest === null) {
								closestDistSq = dist;
								closest = obj;
							}
						}
					}
				}
			}
		}
		return closest;
	},

	_getCoord: function _getCoord(x) {
		var coord = Math.floor(x / this._cellSize);
		return isFinite(coord) ? coord : x;
	},

	_sqDist: function _sqDist(p, p2) {
		var dx = p2.x - p.x,
		    dy = p2.y - p.y;
		return dx * dx + dy * dy;
	}
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* Copyright (c) 2012 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
*/

(function () {
	L.QuickHull = {

		/*
   * @param {Object} cpt a point to be measured from the baseline
   * @param {Array} bl the baseline, as represented by a two-element
   *   array of latlng objects.
   * @returns {Number} an approximate distance measure
   */
		getDistant: function getDistant(cpt, bl) {
			var vY = bl[1].lat - bl[0].lat,
			    vX = bl[0].lng - bl[1].lng;
			return vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng);
		},

		/*
   * @param {Array} baseLine a two-element array of latlng objects
   *   representing the baseline to project from
   * @param {Array} latLngs an array of latlng objects
   * @returns {Object} the maximum point and all new points to stay
   *   in consideration for the hull.
   */
		findMostDistantPointFromBaseLine: function findMostDistantPointFromBaseLine(baseLine, latLngs) {
			var maxD = 0,
			    maxPt = null,
			    newPoints = [],
			    i,
			    pt,
			    d;

			for (i = latLngs.length - 1; i >= 0; i--) {
				pt = latLngs[i];
				d = this.getDistant(pt, baseLine);

				if (d > 0) {
					newPoints.push(pt);
				} else {
					continue;
				}

				if (d > maxD) {
					maxD = d;
					maxPt = pt;
				}
			}

			return { maxPoint: maxPt, newPoints: newPoints };
		},

		/*
   * Given a baseline, compute the convex hull of latLngs as an array
   * of latLngs.
   *
   * @param {Array} latLngs
   * @returns {Array}
   */
		buildConvexHull: function buildConvexHull(baseLine, latLngs) {
			var convexHullBaseLines = [],
			    t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

			if (t.maxPoint) {
				// if there is still a point "outside" the base line
				convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints));
				convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints));
				return convexHullBaseLines;
			} else {
				// if there is no more point "outside" the base line, the current base line is part of the convex hull
				return [baseLine[0]];
			}
		},

		/*
   * Given an array of latlngs, compute a convex hull as an array
   * of latlngs
   *
   * @param {Array} latLngs
   * @returns {Array}
   */
		getConvexHull: function getConvexHull(latLngs) {
			// find first baseline
			var maxLat = false,
			    minLat = false,
			    maxLng = false,
			    minLng = false,
			    maxLatPt = null,
			    minLatPt = null,
			    maxLngPt = null,
			    minLngPt = null,
			    maxPt = null,
			    minPt = null,
			    i;

			for (i = latLngs.length - 1; i >= 0; i--) {
				var pt = latLngs[i];
				if (maxLat === false || pt.lat > maxLat) {
					maxLatPt = pt;
					maxLat = pt.lat;
				}
				if (minLat === false || pt.lat < minLat) {
					minLatPt = pt;
					minLat = pt.lat;
				}
				if (maxLng === false || pt.lng > maxLng) {
					maxLngPt = pt;
					maxLng = pt.lng;
				}
				if (minLng === false || pt.lng < minLng) {
					minLngPt = pt;
					minLng = pt.lng;
				}
			}

			if (minLat !== maxLat) {
				minPt = minLatPt;
				maxPt = maxLatPt;
			} else {
				minPt = minLngPt;
				maxPt = maxLngPt;
			}

			var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs), this.buildConvexHull([maxPt, minPt], latLngs));
			return ch;
		}
	};
})();

L.MarkerCluster.include({
	getConvexHull: function getConvexHull() {
		var childMarkers = this.getAllChildMarkers(),
		    points = [],
		    p,
		    i;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			p = childMarkers[i].getLatLng();
			points.push(p);
		}

		return L.QuickHull.getConvexHull(points);
	}
});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

L.MarkerCluster.include({

	_2PI: Math.PI * 2,
	_circleFootSeparation: 25, //related to circumference of circle
	_circleStartAngle: 0,

	_spiralFootSeparation: 28, //related to size of spiral (experiment!)
	_spiralLengthStart: 11,
	_spiralLengthFactor: 5,

	_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
	// 0 -> always spiral; Infinity -> always circle

	spiderfy: function spiderfy() {
		if (this._group._spiderfied === this || this._group._inZoomAnimation) {
			return;
		}

		var childMarkers = this.getAllChildMarkers(),
		    group = this._group,
		    map = group._map,
		    center = map.latLngToLayerPoint(this._latlng),
		    positions;

		this._group._unspiderfy();
		this._group._spiderfied = this;

		//TODO Maybe: childMarkers order by distance to center

		if (childMarkers.length >= this._circleSpiralSwitchover) {
			positions = this._generatePointsSpiral(childMarkers.length, center);
		} else {
			center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.
			positions = this._generatePointsCircle(childMarkers.length, center);
		}

		this._animationSpiderfy(childMarkers, positions);
	},

	unspiderfy: function unspiderfy(zoomDetails) {
		/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
		if (this._group._inZoomAnimation) {
			return;
		}
		this._animationUnspiderfy(zoomDetails);

		this._group._spiderfied = null;
	},

	_generatePointsCircle: function _generatePointsCircle(count, centerPt) {
		var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
		    legLength = circumference / this._2PI,
		    //radius from circumference
		angleStep = this._2PI / count,
		    res = [],
		    i,
		    angle;

		legLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.

		res.length = count;

		for (i = 0; i < count; i++) {
			// Clockwise, like spiral.
			angle = this._circleStartAngle + i * angleStep;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
		}

		return res;
	},

	_generatePointsSpiral: function _generatePointsSpiral(count, centerPt) {
		var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,
		    legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,
		    separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,
		    lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,
		    angle = 0,
		    res = [],
		    i;

		res.length = count;

		// Higher index, closer position to cluster center.
		for (i = count; i >= 0; i--) {
			// Skip the first position, so that we are already farther from center and we avoid
			// being under the default cluster icon (especially important for Circle Markers).
			if (i < count) {
				res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			}
			angle += separation / legLength + i * 0.0005;
			legLength += lengthFactor / angle;
		}
		return res;
	},

	_noanimationUnspiderfy: function _noanimationUnspiderfy() {
		var group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    childMarkers = this.getAllChildMarkers(),
		    m,
		    i;

		group._ignoreMove = true;

		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			fg.removeLayer(m);

			if (m._preSpiderfyLatlng) {
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;
			}
			if (m.setZIndexOffset) {
				m.setZIndexOffset(0);
			}

			if (m._spiderLeg) {
				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
		}

		group.fire('unspiderfied', {
			cluster: this,
			markers: childMarkers
		});
		group._ignoreMove = false;
		group._spiderfied = null;
	}
});

//Non Animated versions of everything
L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
	_animationSpiderfy: function _animationSpiderfy(childMarkers, positions) {
		var group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    legOptions = this._group.options.spiderLegPolylineOptions,
		    i,
		    m,
		    leg,
		    newPos;

		group._ignoreMove = true;

		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([this._latlng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Now add the marker.
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
			}

			fg.addLayer(m);
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;
		group.fire('spiderfied', {
			cluster: this,
			markers: childMarkers
		});
	},

	_animationUnspiderfy: function _animationUnspiderfy() {
		this._noanimationUnspiderfy();
	}
});

//Animated versions here
L.MarkerCluster.include({

	_animationSpiderfy: function _animationSpiderfy(childMarkers, positions) {
		var me = this,
		    group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    thisLayerLatLng = this._latlng,
		    thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),
		    svg = L.Path.SVG,
		    legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions),
		    // Copy the options so that we can modify them for animation.
		finalLegOpacity = legOptions.opacity,
		    i,
		    m,
		    leg,
		    legPath,
		    legLength,
		    newPos;

		if (finalLegOpacity === undefined) {
			finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;
		}

		if (svg) {
			// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.
			legOptions.opacity = 0;

			// Add the class for CSS transitions.
			legOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';
		} else {
			// Make sure we have a defined opacity.
			legOptions.opacity = finalLegOpacity;
		}

		group._ignoreMove = true;

		// Add markers and spider legs to map, hidden at our center point.
		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			m = childMarkers[i];

			newPos = map.layerPointToLatLng(positions[i]);

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([thisLayerLatLng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/
			// In our case the transition property is declared in the CSS file.
			if (svg) {
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.
				legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.
				legPath.style.strokeDashoffset = legLength;
			}

			// If it is a marker, add it now and we'll animate it out
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING
			}
			if (m.clusterHide) {
				m.clusterHide();
			}

			// Vectors just get immediately added
			fg.addLayer(m);

			if (m._setPos) {
				m._setPos(thisLayerPos);
			}
		}

		group._forceLayout();
		group._animationStart();

		// Reveal markers and spider legs.
		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			//Move marker to new position
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);

			if (m.clusterShow) {
				m.clusterShow();
			}

			// Animate leg (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legPath.style.strokeDashoffset = 0;
				//legPath.style.strokeOpacity = finalLegOpacity;
				leg.setStyle({ opacity: finalLegOpacity });
			}
		}
		this.setOpacity(0.3);

		group._ignoreMove = false;

		setTimeout(function () {
			group._animationEnd();
			group.fire('spiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	},

	_animationUnspiderfy: function _animationUnspiderfy(zoomDetails) {
		var me = this,
		    group = this._group,
		    map = group._map,
		    fg = group._featureGroup,
		    thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
		    childMarkers = this.getAllChildMarkers(),
		    svg = L.Path.SVG,
		    m,
		    i,
		    leg,
		    legPath,
		    legLength,
		    nonAnimatable;

		group._ignoreMove = true;
		group._animationStart();

		//Make us visible and bring the child markers back in
		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//Marker was added to us after we were spiderfied
			if (!m._preSpiderfyLatlng) {
				continue;
			}

			//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll
			m.closePopup();

			//Fix up the location to the real one
			m.setLatLng(m._preSpiderfyLatlng);
			delete m._preSpiderfyLatlng;

			//Hack override the location to be our center
			nonAnimatable = true;
			if (m._setPos) {
				m._setPos(thisLayerPos);
				nonAnimatable = false;
			}
			if (m.clusterHide) {
				m.clusterHide();
				nonAnimatable = false;
			}
			if (nonAnimatable) {
				fg.removeLayer(m);
			}

			// Animate the spider leg back in (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1;
				legPath.style.strokeDashoffset = legLength;
				leg.setStyle({ opacity: 0 });
			}
		}

		group._ignoreMove = false;

		setTimeout(function () {
			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
			var stillThereChildCount = 0;
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];
				if (m._spiderLeg) {
					stillThereChildCount++;
				}
			}

			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				if (!m._spiderLeg) {
					//Has already been unspiderfied
					continue;
				}

				if (m.clusterShow) {
					m.clusterShow();
				}
				if (m.setZIndexOffset) {
					m.setZIndexOffset(0);
				}

				if (stillThereChildCount > 1) {
					fg.removeLayer(m);
				}

				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
			group._animationEnd();
			group.fire('unspiderfied', {
				cluster: me,
				markers: childMarkers
			});
		}, 200);
	}
});

L.MarkerClusterGroup.include({
	//The MarkerCluster currently spiderfied (if any)
	_spiderfied: null,

	unspiderfy: function unspiderfy() {
		this._unspiderfy.apply(this, arguments);
	},

	_spiderfierOnAdd: function _spiderfierOnAdd() {
		this._map.on('click', this._unspiderfyWrapper, this);

		if (this._map.options.zoomAnimation) {
			this._map.on('zoomstart', this._unspiderfyZoomStart, this);
		}
		//Browsers without zoomAnimation or a big zoom don't fire zoomstart
		this._map.on('zoomend', this._noanimationUnspiderfy, this);

		if (!L.Browser.touch) {
			this._map.getRenderer(this);
			//Needs to happen in the pageload, not after, or animations don't work in webkit
			//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
			//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
		}
	},

	_spiderfierOnRemove: function _spiderfierOnRemove() {
		this._map.off('click', this._unspiderfyWrapper, this);
		this._map.off('zoomstart', this._unspiderfyZoomStart, this);
		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._map.off('zoomend', this._noanimationUnspiderfy, this);

		//Ensure that markers are back where they should be
		// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane
		this._noanimationUnspiderfy();
	},

	//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
	//This means we can define the animation they do rather than Markers doing an animation to their actual location
	_unspiderfyZoomStart: function _unspiderfyZoomStart() {
		if (!this._map) {
			//May have been removed from the map by a zoomEnd handler
			return;
		}

		this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
	},

	_unspiderfyZoomAnim: function _unspiderfyZoomAnim(zoomDetails) {
		//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
		if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
			return;
		}

		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._unspiderfy(zoomDetails);
	},

	_unspiderfyWrapper: function _unspiderfyWrapper() {
		/// <summary>_unspiderfy but passes no arguments</summary>
		this._unspiderfy();
	},

	_unspiderfy: function _unspiderfy(zoomDetails) {
		if (this._spiderfied) {
			this._spiderfied.unspiderfy(zoomDetails);
		}
	},

	_noanimationUnspiderfy: function _noanimationUnspiderfy() {
		if (this._spiderfied) {
			this._spiderfied._noanimationUnspiderfy();
		}
	},

	//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
	_unspiderfyLayer: function _unspiderfyLayer(layer) {
		if (layer._spiderLeg) {
			this._featureGroup.removeLayer(layer);

			if (layer.clusterShow) {
				layer.clusterShow();
			}
			//Position will be fixed up immediately in _animationUnspiderfy
			if (layer.setZIndexOffset) {
				layer.setZIndexOffset(0);
			}

			this._map.removeLayer(layer._spiderLeg);
			delete layer._spiderLeg;
		}
	}
});

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
 * markers' icon options and refreshing their icon and their parent clusters
 * accordingly (case where their iconCreateFunction uses data of childMarkers
 * to make up the cluster icon).
 */

L.MarkerClusterGroup.include({
	/**
  * Updates the icon of all clusters which are parents of the given marker(s).
  * In singleMarkerMode, also updates the given marker(s) icon.
  * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
  * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
  * clusters need to be updated. If not provided, retrieves all child markers of this.
  * @returns {L.MarkerClusterGroup}
  */
	refreshClusters: function refreshClusters(layers) {
		if (!layers) {
			layers = this._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.MarkerClusterGroup) {
			layers = layers._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.LayerGroup) {
			layers = layers._layers;
		} else if (layers instanceof L.MarkerCluster) {
			layers = layers.getAllChildMarkers();
		} else if (layers instanceof L.Marker) {
			layers = [layers];
		} // else: must be an Array(L.Marker)|Map(L.Marker)
		this._flagParentsIconsNeedUpdate(layers);
		this._refreshClustersIcons();

		// In case of singleMarkerMode, also re-draw the markers.
		if (this.options.singleMarkerMode) {
			this._refreshSingleMarkerModeMarkers(layers);
		}

		return this;
	},

	/**
  * Simply flags all parent clusters of the given markers as having a "dirty" icon.
  * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
  * @private
  */
	_flagParentsIconsNeedUpdate: function _flagParentsIconsNeedUpdate(layers) {
		var id, parent;

		// Assumes layers is an Array or an Object whose prototype is non-enumerable.
		for (id in layers) {
			// Flag parent clusters' icon as "dirty", all the way up.
			// Dumb process that flags multiple times upper parents, but still
			// much more efficient than trying to be smart and make short lists,
			// at least in the case of a hierarchy following a power law:
			// http://jsperf.com/flag-nodes-in-power-hierarchy/2
			parent = layers[id].__parent;
			while (parent) {
				parent._iconNeedsUpdate = true;
				parent = parent.__parent;
			}
		}
	},

	/**
  * Re-draws the icon of the supplied markers.
  * To be used in singleMarkerMode only.
  * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
  * @private
  */
	_refreshSingleMarkerModeMarkers: function _refreshSingleMarkerModeMarkers(layers) {
		var id, layer;

		for (id in layers) {
			layer = layers[id];

			// Make sure we do not override markers that do not belong to THIS group.
			if (this.hasLayer(layer)) {
				// Need to re-create the icon first, then re-draw the marker.
				layer.setIcon(this._overrideMarkerIcon(layer));
			}
		}
	}
});

L.Marker.include({
	/**
  * Updates the given options in the marker's icon and refreshes the marker.
  * @param options map object of icon options.
  * @param directlyRefreshClusters boolean (optional) true to trigger
  * MCG.refreshClustersOf() right away with this single marker.
  * @returns {L.Marker}
  */
	refreshIconOptions: function refreshIconOptions(options, directlyRefreshClusters) {
		var icon = this.options.icon;

		L.setOptions(icon, options);

		this.setIcon(icon);

		// Shortcut to refresh the associated MCG clusters right away.
		// To be used when refreshing a single marker.
		// Otherwise, better use MCG.refreshClusters() once at the end with
		// the list of modified markers.
		if (directlyRefreshClusters && this.__parent) {
			this.__parent._group.refreshClusters(this);
		}

		return this;
	}
});

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "<link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\" integrity=\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\"\n  crossorigin=\"anonymous\">\n<link href=\"https://fonts.googleapis.com/css?family=Lato:300,400,400i,900\" rel=\"stylesheet\">\n<link href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\" rel=\"stylesheet\" integrity=\"sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN\"\n  crossorigin=\"anonymous\">\n\n\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.css\" media=\"screen\">\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet.markercluster@1.3.0/dist/MarkerCluster.Default.css\" media=\"screen\">\n\n\n<style>\n   :host {\n    font-family: 'Lato', sans-serif;\n    --primary-color: #003d7d;\n    --secondary-color: #ff4b5f;\n  }\n\n  main.card {\n    position: absolute;\n    left: 15px;\n    top: 15px;\n    bottom: 15px;\n    width: 300px;\n    z-index: 1005;\n\n    background-color: #fff;\n    box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.3);\n\n    transition: transform 175ms;\n  }\n\n  a {\n    color: var(--primary-color, inherit);\n  }\n\n  .btn-primary {\n    color: #fff;\n    background-color: var(--primary-color, inherit);\n    border-color: var(--primary-color, inherit);\n  }\n\n  header#page-title {\n    padding: 10px;\n    background-color: var(--primary-color);\n    height: 150px;\n  }\n\n  header#page-title h1 {\n    color: #fff;\n    font-weight: 900;\n  }\n\n  section#overlays {\n    overflow: auto;\n    padding-bottom: 5px;\n  }\n\n  section#overlays>ul>li.list-group-item {\n    padding: 0;\n  }\n\n  section#overlays .overlay-item {\n    font-size: 1.1rem;\n    padding: 0.75rem 1.25rem;\n    color: #444;\n  }\n\n  section#overlays .overlay-item:hover {\n    cursor: pointer;\n    background-color: #eee;\n  }\n\n  section#overlays .overlay-item.selected {\n    background-color: #ddd;\n    color: var(--primary-color);\n\n    /* left border and offset text back */\n    border-left: 0.25rem solid var(--primary-color);\n    padding-left: 1rem;\n  }\n\n  ul.overlay-layers>li.list-group-item {\n    border: 0;\n    border-left: 0.25rem solid var(--primary-color);\n    padding-left: 1.75rem;\n    background-color: #eee;\n    cursor: pointer;\n  }\n\n  ul.overlay-layers .overlay-layers-toggle {\n    --primary-color: var(--secondary-color);\n  }\n\n  button#basemap-switcher,\n  button#layers-menu-toggle {\n    position: absolute;\n    right: 30px;\n    width: 160px;\n    height: 90px;\n    z-index: 1001;\n    border: 5px solid #ffffff;\n    box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.3);\n    cursor: pointer;\n  }\n\n  button#basemap-switcher {\n    background-image: url('./aerial.png');\n    bottom: 30px;\n  }\n\n  button#layers-menu-toggle {\n    display: none;\n    bottom: 130px;\n  }\n\n  section#download-disclaimer {\n    max-height: 400px;\n    overflow: auto;\n    text-align: justify;\n  }\n\n  .show-mobile {\n    display: none;\n  }\n\n  @media (max-width: 600px) {\n    main.card {\n      right: 30px;\n      left: 30px;\n      top: 30px;\n      bottom: 30px;\n      width: unset;\n      transform: scale(0);\n    }\n\n    main.show {\n      transform: scale(1);\n    }\n\n    .show-mobile {\n      display: block;\n    }\n\n    button#basemap-switcher,\n    button#layers-menu-toggle {\n      display: block;\n      width: 90px;\n      height: 90px;\n      border-radius: 90px;\n    }\n  }\n</style>\n\n<!--link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css\" integrity=\"sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M\" crossorigin=\"anonymous\"-->\n\n<main id=\"layers-menu\" class=\"card\">\n  <header id=\"page-title\" class=\"card-img-top d-flex align-items-end\">\n    <h1 class=\"h2\">[[mapTitle]]</h1>\n  </header>\n\n  <!-- Search section -->\n  <section id=\"search-section\" class=\"input-group\">\n    <input type=\"text\" name=\"search\" id=\"search\" class=\"form-control rounded-0\" placeholder=\"Search address\">\n    <span class=\"input-group-btn rounded-0\">\n      <button class=\"btn btn-secondary rounded-0\">\n        <i class=\"fa fa-fw fa-search\"></i>\n      </button>\n    </span>\n  </section>\n\n  <!-- List of available overlays -->\n  <section id=\"overlays\">\n    <ul class=\"list-group\">\n\n      <template is=\"dom-repeat\" items=\"{{overlayMaps}}\">\n        <li class=\"list-group-item\">\n\n          <!-- Main overlay toggle -->\n          <template is=\"dom-if\" if=\"{{!flat}}\">\n            <div title=\"[[item.description]]\" class$=\"[[_overlayItemClass(selectedOverlay, item)]]\" on-click=\"overlaySelect\">\n              <paper-toggle-button checked=\"[[_isCurrentOverlay(selectedOverlay, item)]]\"></paper-toggle-button>\n              <span>[[item.name]]</span>\n            </div>\n          </template>\n\n          <div class$=\"[[_overlayLayersShow(selectedOverlay, item)]]\">\n            <ul class=\"overlay-layers list-group list-group-flush\">\n\n              <!-- Exclusive layers -->\n              <template is=\"dom-repeat\" items=\"{{item.layers.exclusives}}\" as=\"layer\">\n                <li class=\"list-group-item d-flex justify-content-start\" on-click=\"toggleLayer\">\n                  <paper-toggle-button class=\"overlay-layers-toggle\" checked=\"[[_isCurrentExclusive(layer, wmsGroups)]]\"></paper-toggle-button>\n                  <span class=\"mr-auto\">\n                    [[layer.name]]\n                  </span>\n                  <a href=\"#\" on-click=\"downloadLayer\" class=\"justify-self-end\"><i title=\"Download [[layer.name]]\" class=\"fa fa-fw fa-download\"></i></a>\n                </li>\n              </template>\n\n              <!-- Optional layers -->\n              <template is=\"dom-repeat\" items=\"{{item.layers.optionals}}\" as=\"layer\">\n                <li class=\"list-group-item d-flex justify-content-start\" on-click=\"toggleLayer\">\n                  <paper-toggle-button class=\"overlay-layers-toggle\" checked=\"[[layer.visible]]\"></paper-toggle-button>\n                  <span class=\"mr-auto\">\n                    [[layer.name]]\n                  </span>\n                  <a href=\"#\" on-click=\"downloadLayer\" class=\"justify-self-end\"><i title=\"Download [[layer.name]]\" class=\"fa fa-fw fa-download\"></i></a>\n                </li>\n              </template>\n\n            </ul>\n          </div>\n\n        </li>\n      </template>\n\n    </ul>\n  </section>\n\n  <footer class=\"card-body\">\n    <!-- <a href=\"#\" class=\"btn btn-link\">Help</a>\n    <a href=\"#\" class=\"btn btn-link\">Tour</a> -->\n    <div class=\"pull-right show-mobile\">\n      <a href=\"#\" class=\"btn btn-primary\" on-click=\"toggleLayersMenu\">\n        <i class=\"fa fa-map\"></i>\n        View Map\n      </a>\n    </div>\n  </footer>\n</main>\n\n<!-- Basemap toggle button -->\n<button id=\"basemap-switcher\" on-click=\"switchBasemap\"></button>\n\n<!-- Layers control menu (mobile only) -->\n<button id=\"layers-menu-toggle\" class=\"btn btn-primary\" on-click=\"toggleLayersMenu\"><i class=\"fa fa-bars fa-3x\"></i></button>\n\n<leaflet-map map=\"{{map}}\" latitude=\"33.778724\" longitude=\"-117.960058\" zoom=\"13\" min-zoom=\"11\" max-zoom=\"19\" attribution-prefix=\"City of Garden Grove\">\n\n  <template is=\"dom-if\" if=\"{{baseSource}}\" restamp>\n    <leaflet-tile-layer map=\"{{map}}\" url=\"[[baseSource]]\" format=\"[[baseFormat]]\" layers=\"[[baseLayers]]\" attribution=\"&copy; OpenStreetMap\">\n    </leaflet-tile-layer>\n  </template>\n\n  <template is=\"dom-repeat\" items=\"{{wmsGroups}}\" as=\"group\">\n    <leaflet-wms-group map=\"{{map}}\" source=\"[[group.source]]\" layers=\"[[group.layers]]\" transparent format=\"image/png\" identify=\"[[group.identify]]\">\n    </leaflet-wms-group>\n  </template>\n\n  <template is=\"dom-repeat\" items=\"{{geojsonLayers}}\" as=\"layer\">\n    <leaflet-geojson-points map=\"{{map}}\" source$=\"[[layer.source]]\" radius$=\"[[layer.radius]]\" weight$=\"[[layer.weight]]\" max-cluster-radius$=\"[[layer.maxClusterRadius]]\"\n      fill-color$=\"[[layer.fillColor]]\" outline-color$=\"[[layer.outlineColor]]\" opacity$=\"[[layer.opacity]]\" fill-opacity$=\"[[layer.fillOpacity]]\" identify$=\"[[layer.identify]]\"\n      attribution$=\"[[layer.attribution]]\" cluster$=\"[[layer.cluster]]\">\n    </leaflet-geojson-points>\n  </template>\n</leaflet-map>\n\n<!-- Download Modal -->\n<div class=\"modal fade\" id=\"download-modal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"download-modal-label\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h3 class=\"modal-title\" id=\"download-modal-label\">\n          <span id=\"layer-name\"></span>\n        </h3>\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n          <span aria-hidden=\"true\">&times;</span>\n        </button>\n      </div>\n      <div class=\"modal-body\">\n        <section style=\"height: 400px; overflow: auto; padding: 10px; background-color: #eee; font-size: 0.85rem;\">\n          <h5>Download Disclaimer</h5>\n\n          <p>The City of Garden Grove provides the data as a public resource of general information for use \"as is.\" The City\n            of Garden Grove provides this information with the understanding that it is not guaranteed to be accurate, correct\n            or complete and any conclusions drawn from such information are the sole responsibility of the user. Further,\n            the City of Garden Grove makes no warranty, representation or guaranty as to the content, sequence, accuracy,\n            timeliness or completeness of any of the spatial or database information provided herein. While every effort\n            has been made to ensure the content, sequence, accuracy, timeliness or completeness of materials presented within\n            these pages, the City of Garden Grove assumes no responsibility for errors or omissions, and explicitly disclaims\n            any representations and warranties, including, without limitation, the implied warranties of merchantability\n            and fitness for a particular purpose. The City of Garden Grove shall assume no liability for:</p>\n          <p>1.Any errors, omissions, or inaccuracies in the information provided, regardless of how caused; or 2.Any decision\n            made or action taken or not taken by viewer in reliance upon any information or data furnished hereunder.</p>\n          <p>Availability of the City of Garden Grove GIS is not guaranteed. Applications, servers, and network connections\n            may be unavailable at any time for maintenance or unscheduled outages. Outages may be of long duration. Users\n            are cautioned to create dependencies on these services for critical needs.</p>\n          <p>THE FOREGOING WARRANTY IS EXCLUSIVE AND IN LIEU OF ALL OTHER WARRANTIES OF MERCHANTABILITY, FITNESS FOR PARTICULAR\n            PURPOSE AND/OR ANY OTHER TYPE WHETHER EXPRESSED OR IMPLIED. In no event shall The City of Garden Grove become\n            liable to users of these data, or any other party, for any loss or direct, indirect, special, incidental or consequential\n            damages, including, but not limited to, time, money or goodwill, arising from the use or modification of the\n            data.\n          </p>\n          <p>To assist The City of Garden Grove in the maintenance and/or correction of the data, users should provide the City\n            of Garden Grove with information concerning errors or discrepancies found in using the data. Please acknowledge\n            the City of Garden Grove as the source when data is used in the preparation of reports, papers, publications,\n            maps, or other products.</p>\n        </section>\n      </div>\n      <div class=\"modal-footer\">\n        <!--button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\">Close</button-->\n        <span id=\"download-buttons-label\">Download as:</span>\n        <a id=\"geojson-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>GeoJSON\n        </a>\n        <a id=\"csv-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>CSV\n        </a>\n        <a id=\"kml-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>KML\n        </a>\n        <a id=\"shapefile-download\" href=\"#\" target=\"_blank\" class=\"btn btn-link\" aria-labelledby=\"download-buttons-label\">\n          <i class=\"fa fa-download\"></i>Shapefile\n        </a>\n      </div>\n    </div>\n  </div>\n</div>\n"

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e) {
  if ("object" == ( false ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = e();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {
    ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).jsyaml = e();
  }
}(function () {
  return function e(t, n, i) {
    function r(a, s) {
      if (!n[a]) {
        if (!t[a]) {
          var c = "function" == typeof require && require;if (!s && c) return require(a, !0);if (o) return o(a, !0);var u = new Error("Cannot find module '" + a + "'");throw u.code = "MODULE_NOT_FOUND", u;
        }var l = n[a] = { exports: {} };t[a][0].call(l.exports, function (e) {
          var n = t[a][1][e];return r(n || e);
        }, l, l.exports, e, t, n, i);
      }return n[a].exports;
    }for (var o = "function" == typeof require && require, a = 0; a < i.length; a++) {
      r(i[a]);
    }return r;
  }({ 1: [function (e, t, n) {
      "use strict";
      function i(e) {
        return function () {
          throw new Error("Function " + e + " is deprecated and cannot be used.");
        };
      }var r = e("./js-yaml/loader"),
          o = e("./js-yaml/dumper");t.exports.Type = e("./js-yaml/type"), t.exports.Schema = e("./js-yaml/schema"), t.exports.FAILSAFE_SCHEMA = e("./js-yaml/schema/failsafe"), t.exports.JSON_SCHEMA = e("./js-yaml/schema/json"), t.exports.CORE_SCHEMA = e("./js-yaml/schema/core"), t.exports.DEFAULT_SAFE_SCHEMA = e("./js-yaml/schema/default_safe"), t.exports.DEFAULT_FULL_SCHEMA = e("./js-yaml/schema/default_full"), t.exports.load = r.load, t.exports.loadAll = r.loadAll, t.exports.safeLoad = r.safeLoad, t.exports.safeLoadAll = r.safeLoadAll, t.exports.dump = o.dump, t.exports.safeDump = o.safeDump, t.exports.YAMLException = e("./js-yaml/exception"), t.exports.MINIMAL_SCHEMA = e("./js-yaml/schema/failsafe"), t.exports.SAFE_SCHEMA = e("./js-yaml/schema/default_safe"), t.exports.DEFAULT_SCHEMA = e("./js-yaml/schema/default_full"), t.exports.scan = i("scan"), t.exports.parse = i("parse"), t.exports.compose = i("compose"), t.exports.addConstructor = i("addConstructor");
    }, { "./js-yaml/dumper": 3, "./js-yaml/exception": 4, "./js-yaml/loader": 5, "./js-yaml/schema": 7, "./js-yaml/schema/core": 8, "./js-yaml/schema/default_full": 9, "./js-yaml/schema/default_safe": 10, "./js-yaml/schema/failsafe": 11, "./js-yaml/schema/json": 12, "./js-yaml/type": 13 }], 2: [function (e, t, n) {
      "use strict";
      function i(e) {
        return void 0 === e || null === e;
      }t.exports.isNothing = i, t.exports.isObject = function (e) {
        return "object" == (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e;
      }, t.exports.toArray = function (e) {
        return Array.isArray(e) ? e : i(e) ? [] : [e];
      }, t.exports.repeat = function (e, t) {
        var n,
            i = "";for (n = 0; n < t; n += 1) {
          i += e;
        }return i;
      }, t.exports.isNegativeZero = function (e) {
        return 0 === e && Number.NEGATIVE_INFINITY === 1 / e;
      }, t.exports.extend = function (e, t) {
        var n, i, r, o;if (t) for (n = 0, i = (o = Object.keys(t)).length; n < i; n += 1) {
          e[r = o[n]] = t[r];
        }return e;
      };
    }, {}], 3: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        var n, i, r, o, a, s, c;if (null === t) return {};for (n = {}, r = 0, o = (i = Object.keys(t)).length; r < o; r += 1) {
          a = i[r], s = String(t[a]), "!!" === a.slice(0, 2) && (a = "tag:yaml.org,2002:" + a.slice(2)), (c = e.compiledTypeMap.fallback[a]) && T.call(c.styleAliases, s) && (s = c.styleAliases[s]), n[a] = s;
        }return n;
      }function r(e) {
        var t, n, i;if (t = e.toString(16).toUpperCase(), e <= 255) n = "x", i = 2;else if (e <= 65535) n = "u", i = 4;else {
          if (!(e <= 4294967295)) throw new F("code point within a string may not be greater than 0xFFFFFFFF");n = "U", i = 8;
        }return "\\" + n + E.repeat("0", i - t.length) + t;
      }function o(e) {
        this.schema = e.schema || _, this.indent = Math.max(1, e.indent || 2), this.skipInvalid = e.skipInvalid || !1, this.flowLevel = E.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = i(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
      }function a(e, t) {
        for (var n, i = E.repeat(" ", t), r = 0, o = -1, a = "", s = e.length; r < s;) {
          -1 === (o = e.indexOf("\n", r)) ? (n = e.slice(r), r = s) : (n = e.slice(r, o + 1), r = o + 1), n.length && "\n" !== n && (a += i), a += n;
        }return a;
      }function s(e, t) {
        return "\n" + E.repeat(" ", e.indent * t);
      }function c(e, t) {
        var n, i;for (n = 0, i = e.implicitTypes.length; n < i; n += 1) {
          if (e.implicitTypes[n].resolve(t)) return !0;
        }return !1;
      }function u(e) {
        return e === U || e === L;
      }function l(e) {
        return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && 8232 !== e && 8233 !== e || 57344 <= e && e <= 65533 && 65279 !== e || 65536 <= e && e <= 1114111;
      }function p(e) {
        return l(e) && 65279 !== e && e !== $ && e !== J && e !== Q && e !== ee && e !== ne && e !== G && e !== R;
      }function f(e) {
        return l(e) && 65279 !== e && !u(e) && e !== H && e !== Z && e !== G && e !== $ && e !== J && e !== Q && e !== ee && e !== ne && e !== R && e !== W && e !== K && e !== q && e !== te && e !== V && e !== B && e !== Y && e !== P && e !== z && e !== X;
      }function d(e, t, n, i, r) {
        var o,
            a,
            s = !1,
            c = !1,
            d = -1 !== i,
            h = -1,
            m = f(e.charCodeAt(0)) && !u(e.charCodeAt(e.length - 1));if (t) for (o = 0; o < e.length; o++) {
          if (a = e.charCodeAt(o), !l(a)) return ue;m = m && p(a);
        } else {
          for (o = 0; o < e.length; o++) {
            if ((a = e.charCodeAt(o)) === D) s = !0, d && (c = c || o - h - 1 > i && " " !== e[h + 1], h = o);else if (!l(a)) return ue;m = m && p(a);
          }c = c || d && o - h - 1 > i && " " !== e[h + 1];
        }return s || c ? " " === e[0] && n > 9 ? ue : c ? ce : se : m && !r(e) ? oe : ae;
      }function h(e, t, n, i) {
        e.dump = function () {
          if (0 === t.length) return "''";if (!e.noCompatMode && -1 !== re.indexOf(t)) return "'" + t + "'";var r = e.indent * Math.max(1, n),
              o = -1 === e.lineWidth ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - r),
              s = i || e.flowLevel > -1 && n >= e.flowLevel;switch (d(t, s, e.indent, o, function (t) {
            return c(e, t);
          })) {case oe:
              return t;case ae:
              return "'" + t.replace(/'/g, "''") + "'";case se:
              return "|" + m(t, e.indent) + g(a(t, r));case ce:
              return ">" + m(t, e.indent) + g(a(y(t, o), r));case ue:
              return '"' + v(t) + '"';default:
              throw new F("impossible error: invalid scalar style");}
        }();
      }function m(e, t) {
        var n = " " === e[0] ? String(t) : "",
            i = "\n" === e[e.length - 1];return n + (i && ("\n" === e[e.length - 2] || "\n" === e) ? "+" : i ? "" : "-") + "\n";
      }function g(e) {
        return "\n" === e[e.length - 1] ? e.slice(0, -1) : e;
      }function y(e, t) {
        for (var n, i, r = /(\n+)([^\n]*)/g, o = function () {
          var n = e.indexOf("\n");return n = -1 !== n ? n : e.length, r.lastIndex = n, x(e.slice(0, n), t);
        }(), a = "\n" === e[0] || " " === e[0]; i = r.exec(e);) {
          var s = i[1],
              c = i[2];n = " " === c[0], o += s + (a || n || "" === c ? "" : "\n") + x(c, t), a = n;
        }return o;
      }function x(e, t) {
        if ("" === e || " " === e[0]) return e;for (var n, i, r = / [^ ]/g, o = 0, a = 0, s = 0, c = ""; n = r.exec(e);) {
          (s = n.index) - o > t && (i = a > o ? a : s, c += "\n" + e.slice(o, i), o = i + 1), a = s;
        }return c += "\n", e.length - o > t && a > o ? c += e.slice(o, a) + "\n" + e.slice(a + 1) : c += e.slice(o), c.slice(1);
      }function v(e) {
        for (var t, n, i, o = "", a = 0; a < e.length; a++) {
          (t = e.charCodeAt(a)) >= 55296 && t <= 56319 && (n = e.charCodeAt(a + 1)) >= 56320 && n <= 57343 ? (o += r(1024 * (t - 55296) + n - 56320 + 65536), a++) : o += !(i = ie[t]) && l(t) ? e[a] : i || r(t);
        }return o;
      }function A(e, t, n) {
        var i,
            r,
            o = "",
            a = e.tag;for (i = 0, r = n.length; i < r; i += 1) {
          j(e, t, n[i], !1, !1) && (0 !== i && (o += "," + (e.condenseFlow ? "" : " ")), o += e.dump);
        }e.tag = a, e.dump = "[" + o + "]";
      }function b(e, t, n, i) {
        var r,
            o,
            a = "",
            c = e.tag;for (r = 0, o = n.length; r < o; r += 1) {
          j(e, t + 1, n[r], !0, !0) && (i && 0 === r || (a += s(e, t)), e.dump && D === e.dump.charCodeAt(0) ? a += "-" : a += "- ", a += e.dump);
        }e.tag = c, e.dump = a || "[]";
      }function w(e, t, n) {
        var i,
            r,
            o,
            a,
            s,
            c = "",
            u = e.tag,
            l = Object.keys(n);for (i = 0, r = l.length; i < r; i += 1) {
          s = e.condenseFlow ? '"' : "", 0 !== i && (s += ", "), a = n[o = l[i]], j(e, t, o, !1, !1) && (e.dump.length > 1024 && (s += "? "), s += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), j(e, t, a, !1, !1) && (c += s += e.dump));
        }e.tag = u, e.dump = "{" + c + "}";
      }function C(e, t, n, i) {
        var r,
            o,
            a,
            c,
            u,
            l,
            p = "",
            f = e.tag,
            d = Object.keys(n);if (!0 === e.sortKeys) d.sort();else if ("function" == typeof e.sortKeys) d.sort(e.sortKeys);else if (e.sortKeys) throw new F("sortKeys must be a boolean or a function");for (r = 0, o = d.length; r < o; r += 1) {
          l = "", i && 0 === r || (l += s(e, t)), c = n[a = d[r]], j(e, t + 1, a, !0, !0, !0) && ((u = null !== e.tag && "?" !== e.tag || e.dump && e.dump.length > 1024) && (e.dump && D === e.dump.charCodeAt(0) ? l += "?" : l += "? "), l += e.dump, u && (l += s(e, t)), j(e, t + 1, c, !0, u) && (e.dump && D === e.dump.charCodeAt(0) ? l += ":" : l += ": ", p += l += e.dump));
        }e.tag = f, e.dump = p || "{}";
      }function k(e, t, n) {
        var i, r, o, a, s, c;for (o = 0, a = (r = n ? e.explicitTypes : e.implicitTypes).length; o < a; o += 1) {
          if (((s = r[o]).instanceOf || s.predicate) && (!s.instanceOf || "object" == (typeof t === "undefined" ? "undefined" : _typeof(t)) && t instanceof s.instanceOf) && (!s.predicate || s.predicate(t))) {
            if (e.tag = n ? s.tag : "?", s.represent) {
              if (c = e.styleMap[s.tag] || s.defaultStyle, "[object Function]" === M.call(s.represent)) i = s.represent(t, c);else {
                if (!T.call(s.represent, c)) throw new F("!<" + s.tag + '> tag resolver accepts not "' + c + '" style');i = s.represent[c](t, c);
              }e.dump = i;
            }return !0;
          }
        }return !1;
      }function j(e, t, n, i, r, o) {
        e.tag = null, e.dump = n, k(e, n, !1) || k(e, n, !0);var a = M.call(e.dump);i && (i = e.flowLevel < 0 || e.flowLevel > t);var s,
            c,
            u = "[object Object]" === a || "[object Array]" === a;if (u && (c = -1 !== (s = e.duplicates.indexOf(n))), (null !== e.tag && "?" !== e.tag || c || 2 !== e.indent && t > 0) && (r = !1), c && e.usedDuplicates[s]) e.dump = "*ref_" + s;else {
          if (u && c && !e.usedDuplicates[s] && (e.usedDuplicates[s] = !0), "[object Object]" === a) i && 0 !== Object.keys(e.dump).length ? (C(e, t, e.dump, r), c && (e.dump = "&ref_" + s + e.dump)) : (w(e, t, e.dump), c && (e.dump = "&ref_" + s + " " + e.dump));else if ("[object Array]" === a) i && 0 !== e.dump.length ? (b(e, t, e.dump, r), c && (e.dump = "&ref_" + s + e.dump)) : (A(e, t, e.dump), c && (e.dump = "&ref_" + s + " " + e.dump));else {
            if ("[object String]" !== a) {
              if (e.skipInvalid) return !1;throw new F("unacceptable kind of an object to dump " + a);
            }"?" !== e.tag && h(e, e.dump, t, o);
          }null !== e.tag && "?" !== e.tag && (e.dump = "!<" + e.tag + "> " + e.dump);
        }return !0;
      }function I(e, t) {
        var n,
            i,
            r = [],
            o = [];for (S(e, r, o), n = 0, i = o.length; n < i; n += 1) {
          t.duplicates.push(r[o[n]]);
        }t.usedDuplicates = new Array(i);
      }function S(e, t, n) {
        var i, r, o;if (null !== e && "object" == (typeof e === "undefined" ? "undefined" : _typeof(e))) if (-1 !== (r = t.indexOf(e))) -1 === n.indexOf(r) && n.push(r);else if (t.push(e), Array.isArray(e)) for (r = 0, o = e.length; r < o; r += 1) {
          S(e[r], t, n);
        } else for (r = 0, o = (i = Object.keys(e)).length; r < o; r += 1) {
          S(e[i[r]], t, n);
        }
      }function O(e, t) {
        var n = new o(t = t || {});return n.noRefs || I(e, n), j(n, 0, e, !0, !0) ? n.dump + "\n" : "";
      }var E = e("./common"),
          F = e("./exception"),
          _ = e("./schema/default_full"),
          N = e("./schema/default_safe"),
          M = Object.prototype.toString,
          T = Object.prototype.hasOwnProperty,
          L = 9,
          D = 10,
          U = 32,
          q = 33,
          Y = 34,
          R = 35,
          P = 37,
          W = 38,
          B = 39,
          K = 42,
          $ = 44,
          H = 45,
          G = 58,
          V = 62,
          Z = 63,
          z = 64,
          J = 91,
          Q = 93,
          X = 96,
          ee = 123,
          te = 124,
          ne = 125,
          ie = {};ie[0] = "\\0", ie[7] = "\\a", ie[8] = "\\b", ie[9] = "\\t", ie[10] = "\\n", ie[11] = "\\v", ie[12] = "\\f", ie[13] = "\\r", ie[27] = "\\e", ie[34] = '\\"', ie[92] = "\\\\", ie[133] = "\\N", ie[160] = "\\_", ie[8232] = "\\L", ie[8233] = "\\P";var re = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
          oe = 1,
          ae = 2,
          se = 3,
          ce = 4,
          ue = 5;t.exports.dump = O, t.exports.safeDump = function (e, t) {
        return O(e, E.extend({ schema: N }, t));
      };
    }, { "./common": 2, "./exception": 4, "./schema/default_full": 9, "./schema/default_safe": 10 }], 4: [function (e, t, n) {
      "use strict";
      function i(e, t) {
        Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
      }(i.prototype = Object.create(Error.prototype)).constructor = i, i.prototype.toString = function (e) {
        var t = this.name + ": ";return t += this.reason || "(unknown reason)", !e && this.mark && (t += " " + this.mark.toString()), t;
      }, t.exports = i;
    }, {}], 5: [function (e, t, n) {
      "use strict";
      function i(e) {
        return 10 === e || 13 === e;
      }function r(e) {
        return 9 === e || 32 === e;
      }function o(e) {
        return 9 === e || 32 === e || 10 === e || 13 === e;
      }function a(e) {
        return 44 === e || 91 === e || 93 === e || 123 === e || 125 === e;
      }function s(e) {
        var t;return 48 <= e && e <= 57 ? e - 48 : 97 <= (t = 32 | e) && t <= 102 ? t - 97 + 10 : -1;
      }function c(e) {
        return 120 === e ? 2 : 117 === e ? 4 : 85 === e ? 8 : 0;
      }function u(e) {
        return 48 <= e && e <= 57 ? e - 48 : -1;
      }function l(e) {
        return 48 === e ? "\0" : 97 === e ? "" : 98 === e ? "\b" : 116 === e ? "\t" : 9 === e ? "\t" : 110 === e ? "\n" : 118 === e ? "\v" : 102 === e ? "\f" : 114 === e ? "\r" : 101 === e ? "" : 32 === e ? " " : 34 === e ? '"' : 47 === e ? "/" : 92 === e ? "\\" : 78 === e ? "" : 95 === e ? " " : 76 === e ? "\u2028" : 80 === e ? "\u2029" : "";
      }function p(e) {
        return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(55296 + (e - 65536 >> 10), 56320 + (e - 65536 & 1023));
      }function f(e, t) {
        this.input = e, this.filename = t.filename || null, this.schema = t.schema || W, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
      }function d(e, t) {
        return new Y(t, new R(e.filename, e.input, e.position, e.line, e.position - e.lineStart));
      }function h(e, t) {
        throw d(e, t);
      }function m(e, t) {
        e.onWarning && e.onWarning.call(null, d(e, t));
      }function g(e, t, n, i) {
        var r, o, a, s;if (t < n) {
          if (s = e.input.slice(t, n), i) for (r = 0, o = s.length; r < o; r += 1) {
            9 === (a = s.charCodeAt(r)) || 32 <= a && a <= 1114111 || h(e, "expected valid JSON character");
          } else J.test(s) && h(e, "the stream contains non-printable characters");e.result += s;
        }
      }function y(e, t, n, i) {
        var r, o, a, s;for (q.isObject(n) || h(e, "cannot merge mappings; the provided source object is unacceptable"), a = 0, s = (r = Object.keys(n)).length; a < s; a += 1) {
          o = r[a], B.call(t, o) || (t[o] = n[o], i[o] = !0);
        }
      }function x(e, t, n, i, r, o, a, s) {
        var c, u;if (r = String(r), null === t && (t = {}), "tag:yaml.org,2002:merge" === i) {
          if (Array.isArray(o)) for (c = 0, u = o.length; c < u; c += 1) {
            y(e, t, o[c], n);
          } else y(e, t, o, n);
        } else e.json || B.call(n, r) || !B.call(t, r) || (e.line = a || e.line, e.position = s || e.position, h(e, "duplicated mapping key")), t[r] = o, delete n[r];return t;
      }function v(e) {
        var t;10 === (t = e.input.charCodeAt(e.position)) ? e.position++ : 13 === t ? (e.position++, 10 === e.input.charCodeAt(e.position) && e.position++) : h(e, "a line break is expected"), e.line += 1, e.lineStart = e.position;
      }function A(e, t, n) {
        for (var o = 0, a = e.input.charCodeAt(e.position); 0 !== a;) {
          for (; r(a);) {
            a = e.input.charCodeAt(++e.position);
          }if (t && 35 === a) do {
            a = e.input.charCodeAt(++e.position);
          } while (10 !== a && 13 !== a && 0 !== a);if (!i(a)) break;for (v(e), a = e.input.charCodeAt(e.position), o++, e.lineIndent = 0; 32 === a;) {
            e.lineIndent++, a = e.input.charCodeAt(++e.position);
          }
        }return -1 !== n && 0 !== o && e.lineIndent < n && m(e, "deficient indentation"), o;
      }function b(e) {
        var t,
            n = e.position;return !(45 !== (t = e.input.charCodeAt(n)) && 46 !== t || t !== e.input.charCodeAt(n + 1) || t !== e.input.charCodeAt(n + 2) || (n += 3, 0 !== (t = e.input.charCodeAt(n)) && !o(t)));
      }function w(e, t) {
        1 === t ? e.result += " " : t > 1 && (e.result += q.repeat("\n", t - 1));
      }function C(e, t, n) {
        var s,
            c,
            u,
            l,
            p,
            f,
            d,
            h,
            m,
            y = e.kind,
            x = e.result;if (m = e.input.charCodeAt(e.position), o(m) || a(m) || 35 === m || 38 === m || 42 === m || 33 === m || 124 === m || 62 === m || 39 === m || 34 === m || 37 === m || 64 === m || 96 === m) return !1;if ((63 === m || 45 === m) && (c = e.input.charCodeAt(e.position + 1), o(c) || n && a(c))) return !1;for (e.kind = "scalar", e.result = "", u = l = e.position, p = !1; 0 !== m;) {
          if (58 === m) {
            if (c = e.input.charCodeAt(e.position + 1), o(c) || n && a(c)) break;
          } else if (35 === m) {
            if (s = e.input.charCodeAt(e.position - 1), o(s)) break;
          } else {
            if (e.position === e.lineStart && b(e) || n && a(m)) break;if (i(m)) {
              if (f = e.line, d = e.lineStart, h = e.lineIndent, A(e, !1, -1), e.lineIndent >= t) {
                p = !0, m = e.input.charCodeAt(e.position);continue;
              }e.position = l, e.line = f, e.lineStart = d, e.lineIndent = h;break;
            }
          }p && (g(e, u, l, !1), w(e, e.line - f), u = l = e.position, p = !1), r(m) || (l = e.position + 1), m = e.input.charCodeAt(++e.position);
        }return g(e, u, l, !1), !!e.result || (e.kind = y, e.result = x, !1);
      }function k(e, t) {
        var n, r, o;if (39 !== (n = e.input.charCodeAt(e.position))) return !1;for (e.kind = "scalar", e.result = "", e.position++, r = o = e.position; 0 !== (n = e.input.charCodeAt(e.position));) {
          if (39 === n) {
            if (g(e, r, e.position, !0), 39 !== (n = e.input.charCodeAt(++e.position))) return !0;r = e.position, e.position++, o = e.position;
          } else i(n) ? (g(e, r, o, !0), w(e, A(e, !1, t)), r = o = e.position) : e.position === e.lineStart && b(e) ? h(e, "unexpected end of the document within a single quoted scalar") : (e.position++, o = e.position);
        }h(e, "unexpected end of the stream within a single quoted scalar");
      }function j(e, t) {
        var n, r, o, a, u, l;if (34 !== (l = e.input.charCodeAt(e.position))) return !1;for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; 0 !== (l = e.input.charCodeAt(e.position));) {
          if (34 === l) return g(e, n, e.position, !0), e.position++, !0;if (92 === l) {
            if (g(e, n, e.position, !0), l = e.input.charCodeAt(++e.position), i(l)) A(e, !1, t);else if (l < 256 && ne[l]) e.result += ie[l], e.position++;else if ((u = c(l)) > 0) {
              for (o = u, a = 0; o > 0; o--) {
                (u = s(l = e.input.charCodeAt(++e.position))) >= 0 ? a = (a << 4) + u : h(e, "expected hexadecimal character");
              }e.result += p(a), e.position++;
            } else h(e, "unknown escape sequence");n = r = e.position;
          } else i(l) ? (g(e, n, r, !0), w(e, A(e, !1, t)), n = r = e.position) : e.position === e.lineStart && b(e) ? h(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
        }h(e, "unexpected end of the stream within a double quoted scalar");
      }function I(e, t) {
        var n,
            i,
            r,
            a,
            s,
            c,
            u,
            l,
            p,
            f,
            d = !0,
            m = e.tag,
            g = e.anchor,
            y = {};if (91 === (f = e.input.charCodeAt(e.position))) r = 93, c = !1, i = [];else {
          if (123 !== f) return !1;r = 125, c = !0, i = {};
        }for (null !== e.anchor && (e.anchorMap[e.anchor] = i), f = e.input.charCodeAt(++e.position); 0 !== f;) {
          if (A(e, !0, t), (f = e.input.charCodeAt(e.position)) === r) return e.position++, e.tag = m, e.anchor = g, e.kind = c ? "mapping" : "sequence", e.result = i, !0;d || h(e, "missed comma between flow collection entries"), l = u = p = null, a = s = !1, 63 === f && o(e.input.charCodeAt(e.position + 1)) && (a = s = !0, e.position++, A(e, !0, t)), n = e.line, M(e, t, K, !1, !0), l = e.tag, u = e.result, A(e, !0, t), f = e.input.charCodeAt(e.position), !s && e.line !== n || 58 !== f || (a = !0, f = e.input.charCodeAt(++e.position), A(e, !0, t), M(e, t, K, !1, !0), p = e.result), c ? x(e, i, y, l, u, p) : a ? i.push(x(e, null, y, l, u, p)) : i.push(u), A(e, !0, t), 44 === (f = e.input.charCodeAt(e.position)) ? (d = !0, f = e.input.charCodeAt(++e.position)) : d = !1;
        }h(e, "unexpected end of the stream within a flow collection");
      }function S(e, t) {
        var n,
            o,
            a,
            s,
            c = V,
            l = !1,
            p = !1,
            f = t,
            d = 0,
            m = !1;if (124 === (s = e.input.charCodeAt(e.position))) o = !1;else {
          if (62 !== s) return !1;o = !0;
        }for (e.kind = "scalar", e.result = ""; 0 !== s;) {
          if (43 === (s = e.input.charCodeAt(++e.position)) || 45 === s) V === c ? c = 43 === s ? z : Z : h(e, "repeat of a chomping mode identifier");else {
            if (!((a = u(s)) >= 0)) break;0 === a ? h(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : p ? h(e, "repeat of an indentation width identifier") : (f = t + a - 1, p = !0);
          }
        }if (r(s)) {
          do {
            s = e.input.charCodeAt(++e.position);
          } while (r(s));if (35 === s) do {
            s = e.input.charCodeAt(++e.position);
          } while (!i(s) && 0 !== s);
        }for (; 0 !== s;) {
          for (v(e), e.lineIndent = 0, s = e.input.charCodeAt(e.position); (!p || e.lineIndent < f) && 32 === s;) {
            e.lineIndent++, s = e.input.charCodeAt(++e.position);
          }if (!p && e.lineIndent > f && (f = e.lineIndent), i(s)) d++;else {
            if (e.lineIndent < f) {
              c === z ? e.result += q.repeat("\n", l ? 1 + d : d) : c === V && l && (e.result += "\n");break;
            }for (o ? r(s) ? (m = !0, e.result += q.repeat("\n", l ? 1 + d : d)) : m ? (m = !1, e.result += q.repeat("\n", d + 1)) : 0 === d ? l && (e.result += " ") : e.result += q.repeat("\n", d) : e.result += q.repeat("\n", l ? 1 + d : d), l = !0, p = !0, d = 0, n = e.position; !i(s) && 0 !== s;) {
              s = e.input.charCodeAt(++e.position);
            }g(e, n, e.position, !1);
          }
        }return !0;
      }function O(e, t) {
        var n,
            i,
            r,
            a = e.tag,
            s = e.anchor,
            c = [],
            u = !1;for (null !== e.anchor && (e.anchorMap[e.anchor] = c), r = e.input.charCodeAt(e.position); 0 !== r && 45 === r && (i = e.input.charCodeAt(e.position + 1), o(i));) {
          if (u = !0, e.position++, A(e, !0, -1) && e.lineIndent <= t) c.push(null), r = e.input.charCodeAt(e.position);else if (n = e.line, M(e, t, H, !1, !0), c.push(e.result), A(e, !0, -1), r = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && 0 !== r) h(e, "bad indentation of a sequence entry");else if (e.lineIndent < t) break;
        }return !!u && (e.tag = a, e.anchor = s, e.kind = "sequence", e.result = c, !0);
      }function E(e, t, n) {
        var i,
            a,
            s,
            c,
            u,
            l = e.tag,
            p = e.anchor,
            f = {},
            d = {},
            m = null,
            g = null,
            y = null,
            v = !1,
            b = !1;for (null !== e.anchor && (e.anchorMap[e.anchor] = f), u = e.input.charCodeAt(e.position); 0 !== u;) {
          if (i = e.input.charCodeAt(e.position + 1), s = e.line, c = e.position, 63 !== u && 58 !== u || !o(i)) {
            if (!M(e, n, $, !1, !0)) break;if (e.line === s) {
              for (u = e.input.charCodeAt(e.position); r(u);) {
                u = e.input.charCodeAt(++e.position);
              }if (58 === u) o(u = e.input.charCodeAt(++e.position)) || h(e, "a whitespace character is expected after the key-value separator within a block mapping"), v && (x(e, f, d, m, g, null), m = g = y = null), b = !0, v = !1, a = !1, m = e.tag, g = e.result;else {
                if (!b) return e.tag = l, e.anchor = p, !0;h(e, "can not read an implicit mapping pair; a colon is missed");
              }
            } else {
              if (!b) return e.tag = l, e.anchor = p, !0;h(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
            }
          } else 63 === u ? (v && (x(e, f, d, m, g, null), m = g = y = null), b = !0, v = !0, a = !0) : v ? (v = !1, a = !0) : h(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, u = i;if ((e.line === s || e.lineIndent > t) && (M(e, t, G, !0, a) && (v ? g = e.result : y = e.result), v || (x(e, f, d, m, g, y, s, c), m = g = y = null), A(e, !0, -1), u = e.input.charCodeAt(e.position)), e.lineIndent > t && 0 !== u) h(e, "bad indentation of a mapping entry");else if (e.lineIndent < t) break;
        }return v && x(e, f, d, m, g, null), b && (e.tag = l, e.anchor = p, e.kind = "mapping", e.result = f), b;
      }function F(e) {
        var t,
            n,
            i,
            r,
            a = !1,
            s = !1;if (33 !== (r = e.input.charCodeAt(e.position))) return !1;if (null !== e.tag && h(e, "duplication of a tag property"), 60 === (r = e.input.charCodeAt(++e.position)) ? (a = !0, r = e.input.charCodeAt(++e.position)) : 33 === r ? (s = !0, n = "!!", r = e.input.charCodeAt(++e.position)) : n = "!", t = e.position, a) {
          do {
            r = e.input.charCodeAt(++e.position);
          } while (0 !== r && 62 !== r);e.position < e.length ? (i = e.input.slice(t, e.position), r = e.input.charCodeAt(++e.position)) : h(e, "unexpected end of the stream within a verbatim tag");
        } else {
          for (; 0 !== r && !o(r);) {
            33 === r && (s ? h(e, "tag suffix cannot contain exclamation marks") : (n = e.input.slice(t - 1, e.position + 1), ee.test(n) || h(e, "named tag handle cannot contain such characters"), s = !0, t = e.position + 1)), r = e.input.charCodeAt(++e.position);
          }i = e.input.slice(t, e.position), X.test(i) && h(e, "tag suffix cannot contain flow indicator characters");
        }return i && !te.test(i) && h(e, "tag name cannot contain such characters: " + i), a ? e.tag = i : B.call(e.tagMap, n) ? e.tag = e.tagMap[n] + i : "!" === n ? e.tag = "!" + i : "!!" === n ? e.tag = "tag:yaml.org,2002:" + i : h(e, 'undeclared tag handle "' + n + '"'), !0;
      }function _(e) {
        var t, n;if (38 !== (n = e.input.charCodeAt(e.position))) return !1;for (null !== e.anchor && h(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; 0 !== n && !o(n) && !a(n);) {
          n = e.input.charCodeAt(++e.position);
        }return e.position === t && h(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
      }function N(e) {
        var t, n, i;if (42 !== (i = e.input.charCodeAt(e.position))) return !1;for (i = e.input.charCodeAt(++e.position), t = e.position; 0 !== i && !o(i) && !a(i);) {
          i = e.input.charCodeAt(++e.position);
        }return e.position === t && h(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), e.anchorMap.hasOwnProperty(n) || h(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], A(e, !0, -1), !0;
      }function M(e, t, n, i, r) {
        var o,
            a,
            s,
            c,
            u,
            l,
            p,
            f,
            d = 1,
            m = !1,
            g = !1;if (null !== e.listener && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, o = a = s = G === n || H === n, i && A(e, !0, -1) && (m = !0, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)), 1 === d) for (; F(e) || _(e);) {
          A(e, !0, -1) ? (m = !0, s = o, e.lineIndent > t ? d = 1 : e.lineIndent === t ? d = 0 : e.lineIndent < t && (d = -1)) : s = !1;
        }if (s && (s = m || r), 1 !== d && G !== n || (p = K === n || $ === n ? t : t + 1, f = e.position - e.lineStart, 1 === d ? s && (O(e, f) || E(e, f, p)) || I(e, p) ? g = !0 : (a && S(e, p) || k(e, p) || j(e, p) ? g = !0 : N(e) ? (g = !0, null === e.tag && null === e.anchor || h(e, "alias node should not have any properties")) : C(e, p, K === n) && (g = !0, null === e.tag && (e.tag = "?")), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : 0 === d && (g = s && O(e, f))), null !== e.tag && "!" !== e.tag) if ("?" === e.tag) {
          for (c = 0, u = e.implicitTypes.length; c < u; c += 1) {
            if ((l = e.implicitTypes[c]).resolve(e.result)) {
              e.result = l.construct(e.result), e.tag = l.tag, null !== e.anchor && (e.anchorMap[e.anchor] = e.result);break;
            }
          }
        } else B.call(e.typeMap[e.kind || "fallback"], e.tag) ? (l = e.typeMap[e.kind || "fallback"][e.tag], null !== e.result && l.kind !== e.kind && h(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + l.kind + '", not "' + e.kind + '"'), l.resolve(e.result) ? (e.result = l.construct(e.result), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : h(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")) : h(e, "unknown tag !<" + e.tag + ">");return null !== e.listener && e.listener("close", e), null !== e.tag || null !== e.anchor || g;
      }function T(e) {
        var t,
            n,
            a,
            s,
            c = e.position,
            u = !1;for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = {}, e.anchorMap = {}; 0 !== (s = e.input.charCodeAt(e.position)) && (A(e, !0, -1), s = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || 37 !== s));) {
          for (u = !0, s = e.input.charCodeAt(++e.position), t = e.position; 0 !== s && !o(s);) {
            s = e.input.charCodeAt(++e.position);
          }for (a = [], (n = e.input.slice(t, e.position)).length < 1 && h(e, "directive name must not be less than one character in length"); 0 !== s;) {
            for (; r(s);) {
              s = e.input.charCodeAt(++e.position);
            }if (35 === s) {
              do {
                s = e.input.charCodeAt(++e.position);
              } while (0 !== s && !i(s));break;
            }if (i(s)) break;for (t = e.position; 0 !== s && !o(s);) {
              s = e.input.charCodeAt(++e.position);
            }a.push(e.input.slice(t, e.position));
          }0 !== s && v(e), B.call(oe, n) ? oe[n](e, n, a) : m(e, 'unknown document directive "' + n + '"');
        }A(e, !0, -1), 0 === e.lineIndent && 45 === e.input.charCodeAt(e.position) && 45 === e.input.charCodeAt(e.position + 1) && 45 === e.input.charCodeAt(e.position + 2) ? (e.position += 3, A(e, !0, -1)) : u && h(e, "directives end mark is expected"), M(e, e.lineIndent - 1, G, !1, !0), A(e, !0, -1), e.checkLineBreaks && Q.test(e.input.slice(c, e.position)) && m(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && b(e) ? 46 === e.input.charCodeAt(e.position) && (e.position += 3, A(e, !0, -1)) : e.position < e.length - 1 && h(e, "end of the stream or a document separator is expected");
      }function L(e, t) {
        e = String(e), t = t || {}, 0 !== e.length && (10 !== e.charCodeAt(e.length - 1) && 13 !== e.charCodeAt(e.length - 1) && (e += "\n"), 65279 === e.charCodeAt(0) && (e = e.slice(1)));var n = new f(e, t);for (n.input += "\0"; 32 === n.input.charCodeAt(n.position);) {
          n.lineIndent += 1, n.position += 1;
        }for (; n.position < n.length - 1;) {
          T(n);
        }return n.documents;
      }function D(e, t, n) {
        var i,
            r,
            o = L(e, n);if ("function" != typeof t) return o;for (i = 0, r = o.length; i < r; i += 1) {
          t(o[i]);
        }
      }function U(e, t) {
        var n = L(e, t);if (0 !== n.length) {
          if (1 === n.length) return n[0];throw new Y("expected a single document in the stream, but found more");
        }
      }for (var q = e("./common"), Y = e("./exception"), R = e("./mark"), P = e("./schema/default_safe"), W = e("./schema/default_full"), B = Object.prototype.hasOwnProperty, K = 1, $ = 2, H = 3, G = 4, V = 1, Z = 2, z = 3, J = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Q = /[\x85\u2028\u2029]/, X = /[,\[\]\{\}]/, ee = /^(?:!|!!|![a-z\-]+!)$/i, te = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i, ne = new Array(256), ie = new Array(256), re = 0; re < 256; re++) {
        ne[re] = l(re) ? 1 : 0, ie[re] = l(re);
      }var oe = { YAML: function YAML(e, t, n) {
          var i, r, o;null !== e.version && h(e, "duplication of %YAML directive"), 1 !== n.length && h(e, "YAML directive accepts exactly one argument"), null === (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])) && h(e, "ill-formed argument of the YAML directive"), r = parseInt(i[1], 10), o = parseInt(i[2], 10), 1 !== r && h(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = o < 2, 1 !== o && 2 !== o && m(e, "unsupported YAML version of the document");
        }, TAG: function TAG(e, t, n) {
          var i, r;2 !== n.length && h(e, "TAG directive accepts exactly two arguments"), i = n[0], r = n[1], ee.test(i) || h(e, "ill-formed tag handle (first argument) of the TAG directive"), B.call(e.tagMap, i) && h(e, 'there is a previously declared suffix for "' + i + '" tag handle'), te.test(r) || h(e, "ill-formed tag prefix (second argument) of the TAG directive"), e.tagMap[i] = r;
        } };t.exports.loadAll = D, t.exports.load = U, t.exports.safeLoadAll = function (e, t, n) {
        if ("function" != typeof t) return D(e, q.extend({ schema: P }, n));D(e, t, q.extend({ schema: P }, n));
      }, t.exports.safeLoad = function (e, t) {
        return U(e, q.extend({ schema: P }, t));
      };
    }, { "./common": 2, "./exception": 4, "./mark": 6, "./schema/default_full": 9, "./schema/default_safe": 10 }], 6: [function (e, t, n) {
      "use strict";
      function i(e, t, n, i, r) {
        this.name = e, this.buffer = t, this.position = n, this.line = i, this.column = r;
      }var r = e("./common");i.prototype.getSnippet = function (e, t) {
        var n, i, o, a, s;if (!this.buffer) return null;for (e = e || 4, t = t || 75, n = "", i = this.position; i > 0 && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(i - 1));) {
          if (i -= 1, this.position - i > t / 2 - 1) {
            n = " ... ", i += 5;break;
          }
        }for (o = "", a = this.position; a < this.buffer.length && -1 === "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(a));) {
          if ((a += 1) - this.position > t / 2 - 1) {
            o = " ... ", a -= 5;break;
          }
        }return s = this.buffer.slice(i, a), r.repeat(" ", e) + n + s + o + "\n" + r.repeat(" ", e + this.position - i + n.length) + "^";
      }, i.prototype.toString = function (e) {
        var t,
            n = "";return this.name && (n += 'in "' + this.name + '" '), n += "at line " + (this.line + 1) + ", column " + (this.column + 1), e || (t = this.getSnippet()) && (n += ":\n" + t), n;
      }, t.exports = i;
    }, { "./common": 2 }], 7: [function (e, t, n) {
      "use strict";
      function i(e, t, n) {
        var r = [];return e.include.forEach(function (e) {
          n = i(e, t, n);
        }), e[t].forEach(function (e) {
          n.forEach(function (t, n) {
            t.tag === e.tag && t.kind === e.kind && r.push(n);
          }), n.push(e);
        }), n.filter(function (e, t) {
          return -1 === r.indexOf(t);
        });
      }function r() {
        var e,
            t,
            n = { scalar: {}, sequence: {}, mapping: {}, fallback: {} };for (e = 0, t = arguments.length; e < t; e += 1) {
          arguments[e].forEach(function (e) {
            n[e.kind][e.tag] = n.fallback[e.tag] = e;
          });
        }return n;
      }function o(e) {
        this.include = e.include || [], this.implicit = e.implicit || [], this.explicit = e.explicit || [], this.implicit.forEach(function (e) {
          if (e.loadKind && "scalar" !== e.loadKind) throw new s("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }), this.compiledImplicit = i(this, "implicit", []), this.compiledExplicit = i(this, "explicit", []), this.compiledTypeMap = r(this.compiledImplicit, this.compiledExplicit);
      }var a = e("./common"),
          s = e("./exception"),
          c = e("./type");o.DEFAULT = null, o.create = function () {
        var e, t;switch (arguments.length) {case 1:
            e = o.DEFAULT, t = arguments[0];break;case 2:
            e = arguments[0], t = arguments[1];break;default:
            throw new s("Wrong number of arguments for Schema.create function");}if (e = a.toArray(e), t = a.toArray(t), !e.every(function (e) {
          return e instanceof o;
        })) throw new s("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");if (!t.every(function (e) {
          return e instanceof c;
        })) throw new s("Specified list of YAML types (or a single Type object) contains a non-Type object.");return new o({ include: e, explicit: t });
      }, t.exports = o;
    }, { "./common": 2, "./exception": 4, "./type": 13 }], 8: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./json")] });
    }, { "../schema": 7, "./json": 12 }], 9: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = i.DEFAULT = new i({ include: [e("./default_safe")], explicit: [e("../type/js/undefined"), e("../type/js/regexp"), e("../type/js/function")] });
    }, { "../schema": 7, "../type/js/function": 18, "../type/js/regexp": 19, "../type/js/undefined": 20, "./default_safe": 10 }], 10: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./core")], implicit: [e("../type/timestamp"), e("../type/merge")], explicit: [e("../type/binary"), e("../type/omap"), e("../type/pairs"), e("../type/set")] });
    }, { "../schema": 7, "../type/binary": 14, "../type/merge": 22, "../type/omap": 24, "../type/pairs": 25, "../type/set": 27, "../type/timestamp": 29, "./core": 8 }], 11: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ explicit: [e("../type/str"), e("../type/seq"), e("../type/map")] });
    }, { "../schema": 7, "../type/map": 21, "../type/seq": 26, "../type/str": 28 }], 12: [function (e, t, n) {
      "use strict";
      var i = e("../schema");t.exports = new i({ include: [e("./failsafe")], implicit: [e("../type/null"), e("../type/bool"), e("../type/int"), e("../type/float")] });
    }, { "../schema": 7, "../type/bool": 15, "../type/float": 16, "../type/int": 17, "../type/null": 23, "./failsafe": 11 }], 13: [function (e, t, n) {
      "use strict";
      function i(e) {
        var t = {};return null !== e && Object.keys(e).forEach(function (n) {
          e[n].forEach(function (e) {
            t[String(e)] = n;
          });
        }), t;
      }var r = e("./exception"),
          o = ["kind", "resolve", "construct", "instanceOf", "predicate", "represent", "defaultStyle", "styleAliases"],
          a = ["scalar", "sequence", "mapping"];t.exports = function (e, t) {
        if (t = t || {}, Object.keys(t).forEach(function (t) {
          if (-1 === o.indexOf(t)) throw new r('Unknown option "' + t + '" is met in definition of "' + e + '" YAML type.');
        }), this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function () {
          return !0;
        }, this.construct = t.construct || function (e) {
          return e;
        }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.defaultStyle = t.defaultStyle || null, this.styleAliases = i(t.styleAliases || null), -1 === a.indexOf(this.kind)) throw new r('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
      };
    }, { "./exception": 4 }], 14: [function (e, t, n) {
      "use strict";
      var i;try {
        i = e("buffer").Buffer;
      } catch (e) {}var r = e("../type"),
          o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";t.exports = new r("tag:yaml.org,2002:binary", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t,
              n,
              i = 0,
              r = e.length,
              a = o;for (n = 0; n < r; n++) {
            if (!((t = a.indexOf(e.charAt(n))) > 64)) {
              if (t < 0) return !1;i += 6;
            }
          }return i % 8 == 0;
        }, construct: function construct(e) {
          var t,
              n,
              r = e.replace(/[\r\n=]/g, ""),
              a = r.length,
              s = o,
              c = 0,
              u = [];for (t = 0; t < a; t++) {
            t % 4 == 0 && t && (u.push(c >> 16 & 255), u.push(c >> 8 & 255), u.push(255 & c)), c = c << 6 | s.indexOf(r.charAt(t));
          }return 0 == (n = a % 4 * 6) ? (u.push(c >> 16 & 255), u.push(c >> 8 & 255), u.push(255 & c)) : 18 === n ? (u.push(c >> 10 & 255), u.push(c >> 2 & 255)) : 12 === n && u.push(c >> 4 & 255), i ? i.from ? i.from(u) : new i(u) : u;
        }, predicate: function predicate(e) {
          return i && i.isBuffer(e);
        }, represent: function represent(e) {
          var t,
              n,
              i = "",
              r = 0,
              a = e.length,
              s = o;for (t = 0; t < a; t++) {
            t % 3 == 0 && t && (i += s[r >> 18 & 63], i += s[r >> 12 & 63], i += s[r >> 6 & 63], i += s[63 & r]), r = (r << 8) + e[t];
          }return 0 == (n = a % 3) ? (i += s[r >> 18 & 63], i += s[r >> 12 & 63], i += s[r >> 6 & 63], i += s[63 & r]) : 2 === n ? (i += s[r >> 10 & 63], i += s[r >> 4 & 63], i += s[r << 2 & 63], i += s[64]) : 1 === n && (i += s[r >> 2 & 63], i += s[r << 4 & 63], i += s[64], i += s[64]), i;
        } });
    }, { "../type": 13 }], 15: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:bool", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t = e.length;return 4 === t && ("true" === e || "True" === e || "TRUE" === e) || 5 === t && ("false" === e || "False" === e || "FALSE" === e);
        }, construct: function construct(e) {
          return "true" === e || "True" === e || "TRUE" === e;
        }, predicate: function predicate(e) {
          return "[object Boolean]" === Object.prototype.toString.call(e);
        }, represent: { lowercase: function lowercase(e) {
            return e ? "true" : "false";
          }, uppercase: function uppercase(e) {
            return e ? "TRUE" : "FALSE";
          }, camelcase: function camelcase(e) {
            return e ? "True" : "False";
          } }, defaultStyle: "lowercase" });
    }, { "../type": 13 }], 16: [function (e, t, n) {
      "use strict";
      var i = e("../common"),
          r = e("../type"),
          o = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"),
          a = /^[-+]?[0-9]+e/;t.exports = new r("tag:yaml.org,2002:float", { kind: "scalar", resolve: function resolve(e) {
          return null !== e && !(!o.test(e) || "_" === e[e.length - 1]);
        }, construct: function construct(e) {
          var t, n, i, r;return t = e.replace(/_/g, "").toLowerCase(), n = "-" === t[0] ? -1 : 1, r = [], "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), ".inf" === t ? 1 === n ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : ".nan" === t ? NaN : t.indexOf(":") >= 0 ? (t.split(":").forEach(function (e) {
            r.unshift(parseFloat(e, 10));
          }), t = 0, i = 1, r.forEach(function (e) {
            t += e * i, i *= 60;
          }), n * t) : n * parseFloat(t, 10);
        }, predicate: function predicate(e) {
          return "[object Number]" === Object.prototype.toString.call(e) && (e % 1 != 0 || i.isNegativeZero(e));
        }, represent: function represent(e, t) {
          var n;if (isNaN(e)) switch (t) {case "lowercase":
              return ".nan";case "uppercase":
              return ".NAN";case "camelcase":
              return ".NaN";} else if (Number.POSITIVE_INFINITY === e) switch (t) {case "lowercase":
              return ".inf";case "uppercase":
              return ".INF";case "camelcase":
              return ".Inf";} else if (Number.NEGATIVE_INFINITY === e) switch (t) {case "lowercase":
              return "-.inf";case "uppercase":
              return "-.INF";case "camelcase":
              return "-.Inf";} else if (i.isNegativeZero(e)) return "-0.0";return n = e.toString(10), a.test(n) ? n.replace("e", ".e") : n;
        }, defaultStyle: "lowercase" });
    }, { "../common": 2, "../type": 13 }], 17: [function (e, t, n) {
      "use strict";
      function i(e) {
        return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
      }function r(e) {
        return 48 <= e && e <= 55;
      }function o(e) {
        return 48 <= e && e <= 57;
      }var a = e("../common"),
          s = e("../type");t.exports = new s("tag:yaml.org,2002:int", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;var t,
              n = e.length,
              a = 0,
              s = !1;if (!n) return !1;if ("-" !== (t = e[a]) && "+" !== t || (t = e[++a]), "0" === t) {
            if (a + 1 === n) return !0;if ("b" === (t = e[++a])) {
              for (a++; a < n; a++) {
                if ("_" !== (t = e[a])) {
                  if ("0" !== t && "1" !== t) return !1;s = !0;
                }
              }return s && "_" !== t;
            }if ("x" === t) {
              for (a++; a < n; a++) {
                if ("_" !== (t = e[a])) {
                  if (!i(e.charCodeAt(a))) return !1;s = !0;
                }
              }return s && "_" !== t;
            }for (; a < n; a++) {
              if ("_" !== (t = e[a])) {
                if (!r(e.charCodeAt(a))) return !1;s = !0;
              }
            }return s && "_" !== t;
          }if ("_" === t) return !1;for (; a < n; a++) {
            if ("_" !== (t = e[a])) {
              if (":" === t) break;if (!o(e.charCodeAt(a))) return !1;s = !0;
            }
          }return !(!s || "_" === t) && (":" !== t || /^(:[0-5]?[0-9])+$/.test(e.slice(a)));
        }, construct: function construct(e) {
          var t,
              n,
              i = e,
              r = 1,
              o = [];return -1 !== i.indexOf("_") && (i = i.replace(/_/g, "")), "-" !== (t = i[0]) && "+" !== t || ("-" === t && (r = -1), t = (i = i.slice(1))[0]), "0" === i ? 0 : "0" === t ? "b" === i[1] ? r * parseInt(i.slice(2), 2) : "x" === i[1] ? r * parseInt(i, 16) : r * parseInt(i, 8) : -1 !== i.indexOf(":") ? (i.split(":").forEach(function (e) {
            o.unshift(parseInt(e, 10));
          }), i = 0, n = 1, o.forEach(function (e) {
            i += e * n, n *= 60;
          }), r * i) : r * parseInt(i, 10);
        }, predicate: function predicate(e) {
          return "[object Number]" === Object.prototype.toString.call(e) && e % 1 == 0 && !a.isNegativeZero(e);
        }, represent: { binary: function binary(e) {
            return "0b" + e.toString(2);
          }, octal: function octal(e) {
            return "0" + e.toString(8);
          }, decimal: function decimal(e) {
            return e.toString(10);
          }, hexadecimal: function hexadecimal(e) {
            return "0x" + e.toString(16).toUpperCase();
          } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } });
    }, { "../common": 2, "../type": 13 }], 18: [function (e, t, n) {
      "use strict";
      var i;try {
        i = e("esprima");
      } catch (e) {
        "undefined" != typeof window && (i = window.esprima);
      }var r = e("../../type");t.exports = new r("tag:yaml.org,2002:js/function", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;try {
            var t = "(" + e + ")",
                n = i.parse(t, { range: !0 });return "Program" === n.type && 1 === n.body.length && "ExpressionStatement" === n.body[0].type && "FunctionExpression" === n.body[0].expression.type;
          } catch (e) {
            return !1;
          }
        }, construct: function construct(e) {
          var t,
              n = "(" + e + ")",
              r = i.parse(n, { range: !0 }),
              o = [];if ("Program" !== r.type || 1 !== r.body.length || "ExpressionStatement" !== r.body[0].type || "FunctionExpression" !== r.body[0].expression.type) throw new Error("Failed to resolve function");return r.body[0].expression.params.forEach(function (e) {
            o.push(e.name);
          }), t = r.body[0].expression.body.range, new Function(o, n.slice(t[0] + 1, t[1] - 1));
        }, predicate: function predicate(e) {
          return "[object Function]" === Object.prototype.toString.call(e);
        }, represent: function represent(e) {
          return e.toString();
        } });
    }, { "../../type": 13 }], 19: [function (e, t, n) {
      "use strict";
      var i = e("../../type");t.exports = new i("tag:yaml.org,2002:js/regexp", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !1;if (0 === e.length) return !1;var t = e,
              n = /\/([gim]*)$/.exec(e),
              i = "";if ("/" === t[0]) {
            if (n && (i = n[1]), i.length > 3) return !1;if ("/" !== t[t.length - i.length - 1]) return !1;
          }return !0;
        }, construct: function construct(e) {
          var t = e,
              n = /\/([gim]*)$/.exec(e),
              i = "";return "/" === t[0] && (n && (i = n[1]), t = t.slice(1, t.length - i.length - 1)), new RegExp(t, i);
        }, predicate: function predicate(e) {
          return "[object RegExp]" === Object.prototype.toString.call(e);
        }, represent: function represent(e) {
          var t = "/" + e.source + "/";return e.global && (t += "g"), e.multiline && (t += "m"), e.ignoreCase && (t += "i"), t;
        } });
    }, { "../../type": 13 }], 20: [function (e, t, n) {
      "use strict";
      var i = e("../../type");t.exports = new i("tag:yaml.org,2002:js/undefined", { kind: "scalar", resolve: function resolve() {
          return !0;
        }, construct: function construct() {}, predicate: function predicate(e) {
          return void 0 === e;
        }, represent: function represent() {
          return "";
        } });
    }, { "../../type": 13 }], 21: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:map", { kind: "mapping", construct: function construct(e) {
          return null !== e ? e : {};
        } });
    }, { "../type": 13 }], 22: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:merge", { kind: "scalar", resolve: function resolve(e) {
          return "<<" === e || null === e;
        } });
    }, { "../type": 13 }], 23: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:null", { kind: "scalar", resolve: function resolve(e) {
          if (null === e) return !0;var t = e.length;return 1 === t && "~" === e || 4 === t && ("null" === e || "Null" === e || "NULL" === e);
        }, construct: function construct() {
          return null;
        }, predicate: function predicate(e) {
          return null === e;
        }, represent: { canonical: function canonical() {
            return "~";
          }, lowercase: function lowercase() {
            return "null";
          }, uppercase: function uppercase() {
            return "NULL";
          }, camelcase: function camelcase() {
            return "Null";
          } }, defaultStyle: "lowercase" });
    }, { "../type": 13 }], 24: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.hasOwnProperty,
          o = Object.prototype.toString;t.exports = new i("tag:yaml.org,2002:omap", { kind: "sequence", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n,
              i,
              a,
              s,
              c = [],
              u = e;for (t = 0, n = u.length; t < n; t += 1) {
            if (i = u[t], s = !1, "[object Object]" !== o.call(i)) return !1;for (a in i) {
              if (r.call(i, a)) {
                if (s) return !1;s = !0;
              }
            }if (!s) return !1;if (-1 !== c.indexOf(a)) return !1;c.push(a);
          }return !0;
        }, construct: function construct(e) {
          return null !== e ? e : [];
        } });
    }, { "../type": 13 }], 25: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.toString;t.exports = new i("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n,
              i,
              o,
              a,
              s = e;for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1) {
            if (i = s[t], "[object Object]" !== r.call(i)) return !1;if (1 !== (o = Object.keys(i)).length) return !1;a[t] = [o[0], i[o[0]]];
          }return !0;
        }, construct: function construct(e) {
          if (null === e) return [];var t,
              n,
              i,
              r,
              o,
              a = e;for (o = new Array(a.length), t = 0, n = a.length; t < n; t += 1) {
            i = a[t], r = Object.keys(i), o[t] = [r[0], i[r[0]]];
          }return o;
        } });
    }, { "../type": 13 }], 26: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:seq", { kind: "sequence", construct: function construct(e) {
          return null !== e ? e : [];
        } });
    }, { "../type": 13 }], 27: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = Object.prototype.hasOwnProperty;t.exports = new i("tag:yaml.org,2002:set", { kind: "mapping", resolve: function resolve(e) {
          if (null === e) return !0;var t,
              n = e;for (t in n) {
            if (r.call(n, t) && null !== n[t]) return !1;
          }return !0;
        }, construct: function construct(e) {
          return null !== e ? e : {};
        } });
    }, { "../type": 13 }], 28: [function (e, t, n) {
      "use strict";
      var i = e("../type");t.exports = new i("tag:yaml.org,2002:str", { kind: "scalar", construct: function construct(e) {
          return null !== e ? e : "";
        } });
    }, { "../type": 13 }], 29: [function (e, t, n) {
      "use strict";
      var i = e("../type"),
          r = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
          o = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");t.exports = new i("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: function resolve(e) {
          return null !== e && (null !== r.exec(e) || null !== o.exec(e));
        }, construct: function construct(e) {
          var t,
              n,
              i,
              a,
              s,
              c,
              u,
              l,
              p = 0,
              f = null;if (null === (t = r.exec(e)) && (t = o.exec(e)), null === t) throw new Error("Date resolve error");if (n = +t[1], i = +t[2] - 1, a = +t[3], !t[4]) return new Date(Date.UTC(n, i, a));if (s = +t[4], c = +t[5], u = +t[6], t[7]) {
            for (p = t[7].slice(0, 3); p.length < 3;) {
              p += "0";
            }p = +p;
          }return t[9] && (f = 6e4 * (60 * +t[10] + +(t[11] || 0)), "-" === t[9] && (f = -f)), l = new Date(Date.UTC(n, i, a, s, c, u, p)), f && l.setTime(l.getTime() - f), l;
        }, instanceOf: Date, represent: function represent(e) {
          return e.toISOString();
        } });
    }, { "../type": 13 }], "/": [function (e, t, n) {
      "use strict";
      var i = e("./lib/js-yaml.js");t.exports = i;
    }, { "./lib/js-yaml.js": 1 }] }, {}, [])("/");
});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODQ3YWQzODE1ZTM1NTdiZGNiYTkiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL1V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L0JvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vTGF0TG5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL0xhdExuZ0JvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9GZWF0dXJlR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9QYXRoLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL211dGFibGUtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXNldHRpbmdzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2Nzcy1wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3RlbXBsYXRpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRHJhZ2dhYmxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvRGl2T3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS11dGlsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3RlbXBsYXRlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9kb2N1bWVudC13YWl0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2NvbG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLkVQU0czODU3LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZG9tL1Bvc0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuQXR0cmlidXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL0dyaWRMYXllci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9DYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvUG9seVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvR2VvSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4uL2dnLW1hcC12aWV3ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvYXBwbHktc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9pbXBvcnQtaHJlZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvY2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1pZi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tbWV0YS9pcm9uLW1ldGEuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvTWFya2VyLkRyYWcuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L2Rpc3QvaW1hZ2VzL21hcmtlci1pY29uLnBuZyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmciLCJ3ZWJwYWNrOi8vLy92YXIvd3d3L2h0bWwvQGdnY2l0eS9sZWFmbGV0LW1hcC9sZWFmbGV0LW1hcC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5EcmFnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5UYXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuVG91Y2hab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5ab29tLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLlNjYWxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvUG9wdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9Ub29sdGlwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci90aWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9TVkcuVk1MLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmdldFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8vdmFyL3d3dy9odG1sL0BnZ2NpdHkvbGVhZmxldC13bXMvbGVhZmxldC13bXMtZ3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy92YXIvd3d3L2h0bWwvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0Lndtcy5qcyIsIndlYnBhY2s6Ly8vL3Zhci93d3cvaHRtbC9AZ2djaXR5L2xlYWZsZXQtd21zL2xlYWZsZXQtd21zLWxheWVyLmpzIiwid2VicGFjazovLy8vdmFyL3d3dy9odG1sL0BnZ2NpdHkvbGVhZmxldC10aWxlLWxheWVyL2xlYWZsZXQtdGlsZS1sYXllci5qcyIsIndlYnBhY2s6Ly8vL3Zhci93d3cvaHRtbC9AZ2djaXR5L2xlYWZsZXQtZ2VvanNvbi9sZWFmbGV0LWdlb2pzb24tcG9pbnRzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvTGVhZmxldC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC9wYWNrYWdlLmpzb24iLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlck9wYWNpdHkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL0Rpc3RhbmNlR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlci5RdWlja0h1bGwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXIuU3BpZGVyZmllci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvTWFya2VyQ2x1c3Rlckdyb3VwLlJlZnJlc2guanMiLCJ3ZWJwYWNrOi8vLy4uL2FwcC50ZW1wbGF0ZS5odG1sIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9kaXN0L2pzLXlhbWwubWluLmpzIl0sIm5hbWVzIjpbImV4dGVuZCIsImJpbmQiLCJzdGFtcCIsInRocm90dGxlIiwid3JhcE51bSIsImZhbHNlRm4iLCJmb3JtYXROdW0iLCJ0cmltIiwic3BsaXRXb3JkcyIsInNldE9wdGlvbnMiLCJnZXRQYXJhbVN0cmluZyIsInRlbXBsYXRlIiwiaW5kZXhPZiIsInJlcXVlc3RBbmltRnJhbWUiLCJjYW5jZWxBbmltRnJhbWUiLCJmcmVlemUiLCJPYmplY3QiLCJvYmoiLCJkZXN0IiwiaSIsImoiLCJsZW4iLCJzcmMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjcmVhdGUiLCJGIiwicHJvdG8iLCJwcm90b3R5cGUiLCJmbiIsInNsaWNlIiwiQXJyYXkiLCJhcHBseSIsImNhbGwiLCJhcmdzIiwiY29uY2F0IiwibGFzdElkIiwiX2xlYWZsZXRfaWQiLCJ0aW1lIiwiY29udGV4dCIsImxvY2siLCJ3cmFwcGVyRm4iLCJsYXRlciIsInNldFRpbWVvdXQiLCJ4IiwicmFuZ2UiLCJpbmNsdWRlTWF4IiwibWF4IiwibWluIiwiZCIsIm51bSIsImRpZ2l0cyIsInBvdyIsIk1hdGgiLCJ1bmRlZmluZWQiLCJyb3VuZCIsInN0ciIsInJlcGxhY2UiLCJzcGxpdCIsIm9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsImV4aXN0aW5nVXJsIiwidXBwZXJjYXNlIiwicGFyYW1zIiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsInRvVXBwZXJDYXNlIiwiam9pbiIsInRlbXBsYXRlUmUiLCJkYXRhIiwia2V5IiwidmFsdWUiLCJFcnJvciIsImlzQXJyYXkiLCJ0b1N0cmluZyIsImFycmF5IiwiZWwiLCJlbXB0eUltYWdlVXJsIiwiZ2V0UHJlZml4ZWQiLCJuYW1lIiwid2luZG93IiwibGFzdFRpbWUiLCJ0aW1lb3V0RGVmZXIiLCJEYXRlIiwidGltZVRvQ2FsbCIsInJlcXVlc3RGbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEZuIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpZCIsImNsZWFyVGltZW91dCIsImltbWVkaWF0ZSIsImdldCIsImdldFN0eWxlIiwicmVtb3ZlIiwiZW1wdHkiLCJ0b0Zyb250IiwidG9CYWNrIiwiaGFzQ2xhc3MiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwic2V0Q2xhc3MiLCJnZXRDbGFzcyIsInNldE9wYWNpdHkiLCJ0ZXN0UHJvcCIsInNldFRyYW5zZm9ybSIsInNldFBvc2l0aW9uIiwiZ2V0UG9zaXRpb24iLCJkaXNhYmxlSW1hZ2VEcmFnIiwiZW5hYmxlSW1hZ2VEcmFnIiwicHJldmVudE91dGxpbmUiLCJyZXN0b3JlT3V0bGluZSIsIkRvbUV2ZW50IiwiVXRpbCIsIkJyb3dzZXIiLCJUUkFOU0ZPUk0iLCJUUkFOU0lUSU9OIiwiVFJBTlNJVElPTl9FTkQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3R5bGUiLCJjdXJyZW50U3R5bGUiLCJkZWZhdWx0VmlldyIsImNzcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0YWdOYW1lIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwicGFyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsImluc2VydEJlZm9yZSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiUmVnRXhwIiwidGVzdCIsImNsYXNzZXMiLCJhZGQiLCJiYXNlVmFsIiwib3BhY2l0eSIsIl9zZXRPcGFjaXR5SUUiLCJmaWx0ZXIiLCJmaWx0ZXJOYW1lIiwiZmlsdGVycyIsIml0ZW0iLCJlIiwiRW5hYmxlZCIsIk9wYWNpdHkiLCJwcm9wcyIsImRvY3VtZW50RWxlbWVudCIsIm9mZnNldCIsInNjYWxlIiwicG9zIiwiaWUzZCIsInkiLCJwb2ludCIsIl9sZWFmbGV0X3BvcyIsImFueTNkIiwibGVmdCIsInRvcCIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwiZW5hYmxlVGV4dFNlbGVjdGlvbiIsIl91c2VyU2VsZWN0Iiwib24iLCJwcmV2ZW50RGVmYXVsdCIsIm9mZiIsInVzZXJTZWxlY3RQcm9wZXJ0eSIsIl9vdXRsaW5lRWxlbWVudCIsIl9vdXRsaW5lU3R5bGUiLCJlbGVtZW50IiwidGFiSW5kZXgiLCJvdXRsaW5lIiwiSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSIsInByb3AiLCJQb2x5bWVyIiwiUG9pbnQiLCJ0b1BvaW50IiwidHJ1bmMiLCJ2IiwiZmxvb3IiLCJjZWlsIiwiY2xvbmUiLCJfYWRkIiwic3VidHJhY3QiLCJfc3VidHJhY3QiLCJkaXZpZGVCeSIsIl9kaXZpZGVCeSIsIm11bHRpcGx5QnkiLCJfbXVsdGlwbHlCeSIsInNjYWxlQnkiLCJ1bnNjYWxlQnkiLCJfcm91bmQiLCJfZmxvb3IiLCJfY2VpbCIsIl90cnVuYyIsImRpc3RhbmNlVG8iLCJzcXJ0IiwiZXF1YWxzIiwiYWJzIiwiaWUiLCJpZWx0OSIsImFkZEV2ZW50TGlzdGVuZXIiLCJlZGdlIiwibmF2aWdhdG9yIiwid2Via2l0IiwidXNlckFnZW50Q29udGFpbnMiLCJhbmRyb2lkIiwiYW5kcm9pZDIzIiwid2Via2l0VmVyIiwicGFyc2VJbnQiLCJleGVjIiwidXNlckFnZW50IiwiYW5kcm9pZFN0b2NrIiwib3BlcmEiLCJjaHJvbWUiLCJnZWNrbyIsInNhZmFyaSIsInBoYW50b20iLCJvcGVyYTEyIiwid2luIiwicGxhdGZvcm0iLCJ3ZWJraXQzZCIsIldlYktpdENTU01hdHJpeCIsImdlY2tvM2QiLCJMX0RJU0FCTEVfM0QiLCJtb2JpbGUiLCJvcmllbnRhdGlvbiIsIm1vYmlsZVdlYmtpdCIsIm1vYmlsZVdlYmtpdDNkIiwibXNQb2ludGVyIiwiUG9pbnRlckV2ZW50IiwiTVNQb2ludGVyRXZlbnQiLCJwb2ludGVyIiwidG91Y2giLCJMX05PX1RPVUNIIiwiRG9jdW1lbnRUb3VjaCIsIm1vYmlsZU9wZXJhIiwibW9iaWxlR2Vja28iLCJyZXRpbmEiLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsInN2ZyIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVNWR1JlY3QiLCJ2bWwiLCJkaXYiLCJpbm5lckhUTUwiLCJzaGFwZSIsImJlaGF2aW9yIiwiYWRqIiwidG9Mb3dlckNhc2UiLCJCb3VuZHMiLCJ0b0JvdW5kcyIsImEiLCJiIiwicG9pbnRzIiwiZ2V0Q2VudGVyIiwiZ2V0Qm90dG9tTGVmdCIsImdldFRvcFJpZ2h0IiwiZ2V0VG9wTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiZ2V0U2l6ZSIsImludGVyc2VjdHMiLCJib3VuZHMiLCJtaW4yIiwibWF4MiIsInhJbnRlcnNlY3RzIiwieUludGVyc2VjdHMiLCJvdmVybGFwcyIsInhPdmVybGFwcyIsInlPdmVybGFwcyIsImlzVmFsaWQiLCJzdG9wUHJvcGFnYXRpb24iLCJkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24iLCJkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbiIsInN0b3AiLCJnZXRNb3VzZVBvc2l0aW9uIiwiZ2V0V2hlZWxEZWx0YSIsImZha2VTdG9wIiwic2tpcHBlZCIsImlzRXh0ZXJuYWxUYXJnZXQiLCJ0eXBlcyIsInR5cGUiLCJhZGRPbmUiLCJldmVudHNLZXkiLCJyZW1vdmVPbmUiLCJoYW5kbGVyIiwiZXZlbnQiLCJvcmlnaW5hbEhhbmRsZXIiLCJmaWx0ZXJDbGljayIsImF0dGFjaEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50Iiwib3JpZ2luYWxFdmVudCIsIl9zdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwicmV0dXJuVmFsdWUiLCJjbGllbnRYIiwiY2xpZW50WSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZVgiLCJ3aWR0aCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiY2xpZW50TGVmdCIsImNsaWVudFRvcCIsIndoZWVsUHhGYWN0b3IiLCJ3aGVlbERlbHRhWSIsImRlbHRhWSIsImRlbHRhTW9kZSIsImRlbHRhWCIsImRlbHRhWiIsIndoZWVsRGVsdGEiLCJkZXRhaWwiLCJza2lwRXZlbnRzIiwiZXZlbnRzIiwicmVsYXRlZCIsInJlbGF0ZWRUYXJnZXQiLCJlcnIiLCJsYXN0Q2xpY2siLCJ0aW1lU3RhbXAiLCJlbGFwc2VkIiwidGFyZ2V0IiwiX3NpbXVsYXRlZENsaWNrIiwiX3NpbXVsYXRlZCIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJCYXNlIiwiSFRNTEVsZW1lbnQiLCJjcmVhdGVNYXAiLCJEb21VdGlsIiwiTWFwIiwiY3JzIiwiY2VudGVyIiwiem9vbSIsIm1pblpvb20iLCJtYXhab29tIiwibGF5ZXJzIiwibWF4Qm91bmRzIiwicmVuZGVyZXIiLCJ6b29tQW5pbWF0aW9uIiwiem9vbUFuaW1hdGlvblRocmVzaG9sZCIsImZhZGVBbmltYXRpb24iLCJtYXJrZXJab29tQW5pbWF0aW9uIiwidHJhbnNmb3JtM0RMaW1pdCIsInpvb21TbmFwIiwiem9vbURlbHRhIiwidHJhY2tSZXNpemUiLCJpbml0aWFsaXplIiwiX2luaXRDb250YWluZXIiLCJfaW5pdExheW91dCIsIl9vblJlc2l6ZSIsIl9pbml0RXZlbnRzIiwic2V0TWF4Qm91bmRzIiwiX3pvb20iLCJfbGltaXRab29tIiwic2V0VmlldyIsInJlc2V0IiwiX2hhbmRsZXJzIiwiX2xheWVycyIsIl96b29tQm91bmRMYXllcnMiLCJfc2l6ZUNoYW5nZWQiLCJjYWxsSW5pdEhvb2tzIiwiX3pvb21BbmltYXRlZCIsIl9jcmVhdGVBbmltUHJveHkiLCJfcHJveHkiLCJfY2F0Y2hUcmFuc2l0aW9uRW5kIiwiX2FkZExheWVycyIsIl9saW1pdENlbnRlciIsIl9zdG9wIiwiX2xvYWRlZCIsImFuaW1hdGUiLCJwYW4iLCJkdXJhdGlvbiIsIm1vdmVkIiwiX3RyeUFuaW1hdGVkWm9vbSIsIl90cnlBbmltYXRlZFBhbiIsIl9zaXplVGltZXIiLCJfcmVzZXRWaWV3Iiwic2V0Wm9vbSIsInpvb21JbiIsImRlbHRhIiwiem9vbU91dCIsInNldFpvb21Bcm91bmQiLCJsYXRsbmciLCJnZXRab29tU2NhbGUiLCJ2aWV3SGFsZiIsImNvbnRhaW5lclBvaW50IiwibGF0TG5nVG9Db250YWluZXJQb2ludCIsImNlbnRlck9mZnNldCIsIm5ld0NlbnRlciIsImNvbnRhaW5lclBvaW50VG9MYXRMbmciLCJfZ2V0Qm91bmRzQ2VudGVyWm9vbSIsImdldEJvdW5kcyIsInBhZGRpbmdUTCIsInBhZGRpbmdUb3BMZWZ0IiwicGFkZGluZyIsInBhZGRpbmdCUiIsInBhZGRpbmdCb3R0b21SaWdodCIsImdldEJvdW5kc1pvb20iLCJJbmZpbml0eSIsInBhZGRpbmdPZmZzZXQiLCJzd1BvaW50IiwicHJvamVjdCIsImdldFNvdXRoV2VzdCIsIm5lUG9pbnQiLCJnZXROb3J0aEVhc3QiLCJ1bnByb2plY3QiLCJmaXRCb3VuZHMiLCJmaXRXb3JsZCIsInBhblRvIiwicGFuQnkiLCJmaXJlIiwiZ2V0Wm9vbSIsIl9wYW5BbmltIiwiX29uUGFuVHJhbnNpdGlvblN0ZXAiLCJfb25QYW5UcmFuc2l0aW9uRW5kIiwibm9Nb3ZlU3RhcnQiLCJfbWFwUGFuZSIsIm5ld1BvcyIsIl9nZXRNYXBQYW5lUG9zIiwicnVuIiwiZWFzZUxpbmVhcml0eSIsIl9yYXdQYW5CeSIsImZseVRvIiwidGFyZ2V0Q2VudGVyIiwidGFyZ2V0Wm9vbSIsImZyb20iLCJ0byIsInNpemUiLCJzdGFydFpvb20iLCJ3MCIsIncxIiwidTEiLCJyaG8iLCJyaG8yIiwiciIsInMxIiwiczIiLCJ0MSIsImIxIiwic3EiLCJsb2ciLCJzaW5oIiwibiIsImV4cCIsImNvc2giLCJ0YW5oIiwicjAiLCJ3IiwicyIsInUiLCJlYXNlT3V0IiwidCIsInN0YXJ0Iiwibm93IiwiUyIsImZyYW1lIiwiX2ZseVRvRnJhbWUiLCJfbW92ZSIsImdldFNjYWxlWm9vbSIsIl9tb3ZlRW5kIiwiX21vdmVTdGFydCIsImZseVRvQm91bmRzIiwiX3Bhbkluc2lkZU1heEJvdW5kcyIsInNldE1pblpvb20iLCJvbGRab29tIiwic2V0TWF4Wm9vbSIsInBhbkluc2lkZUJvdW5kcyIsIl9lbmZvcmNpbmdCb3VuZHMiLCJpbnZhbGlkYXRlU2l6ZSIsIm9sZFNpemUiLCJfbGFzdENlbnRlciIsIm5ld1NpemUiLCJvbGRDZW50ZXIiLCJkZWJvdW5jZU1vdmVlbmQiLCJsb2NhdGUiLCJfbG9jYXRlT3B0aW9ucyIsInRpbWVvdXQiLCJ3YXRjaCIsIl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJvblJlc3BvbnNlIiwiX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UiLCJvbkVycm9yIiwiX2xvY2F0aW9uV2F0Y2hJZCIsImdlb2xvY2F0aW9uIiwid2F0Y2hQb3NpdGlvbiIsImdldEN1cnJlbnRQb3NpdGlvbiIsInN0b3BMb2NhdGUiLCJjbGVhcldhdGNoIiwiZXJyb3IiLCJjIiwibGF0IiwiY29vcmRzIiwibGF0aXR1ZGUiLCJsbmciLCJsb25naXR1ZGUiLCJhY2N1cmFjeSIsInRpbWVzdGFtcCIsImFkZEhhbmRsZXIiLCJIYW5kbGVyQ2xhc3MiLCJlbmFibGUiLCJfY29udGFpbmVySWQiLCJfY29udGFpbmVyIiwiX2NsZWFyQ29udHJvbFBvcyIsIl9jbGVhckhhbmRsZXJzIiwiX3BhbmVzIiwiX3JlbmRlcmVyIiwiY3JlYXRlUGFuZSIsInBhbmUiLCJfY2hlY2tJZkxvYWRlZCIsIl9tb3ZlZCIsImxheWVyUG9pbnRUb0xhdExuZyIsIl9nZXRDZW50ZXJMYXllclBvaW50IiwiZ2V0UGl4ZWxCb3VuZHMiLCJzdyIsIm5lIiwiZ2V0TWluWm9vbSIsIl9sYXllcnNNaW5ab29tIiwiZ2V0TWF4Wm9vbSIsIl9sYXllcnNNYXhab29tIiwiaW5zaWRlIiwibnciLCJnZXROb3J0aFdlc3QiLCJzZSIsImdldFNvdXRoRWFzdCIsImJvdW5kc1NpemUiLCJzbmFwIiwic2NhbGV4Iiwic2NhbGV5IiwiX3NpemUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInRvcExlZnRQb2ludCIsIl9nZXRUb3BMZWZ0UG9pbnQiLCJnZXRQaXhlbE9yaWdpbiIsIl9waXhlbE9yaWdpbiIsImdldFBpeGVsV29ybGRCb3VuZHMiLCJnZXRQcm9qZWN0ZWRCb3VuZHMiLCJnZXRQYW5lIiwiZ2V0UGFuZXMiLCJnZXRDb250YWluZXIiLCJ0b1pvb20iLCJmcm9tWm9vbSIsImlzTmFOIiwibGF0TG5nVG9Qb2ludCIsInBvaW50VG9MYXRMbmciLCJwcm9qZWN0ZWRQb2ludCIsImxhdExuZ1RvTGF5ZXJQb2ludCIsIndyYXBMYXRMbmciLCJ3cmFwTGF0TG5nQm91bmRzIiwiZGlzdGFuY2UiLCJsYXRsbmcxIiwibGF0bG5nMiIsImNvbnRhaW5lclBvaW50VG9MYXllclBvaW50IiwibGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQiLCJsYXllclBvaW50IiwibW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXllclBvaW50IiwibW91c2VFdmVudFRvTGF0TG5nIiwiX29uU2Nyb2xsIiwiX2ZhZGVBbmltYXRlZCIsInBvc2l0aW9uIiwiX2luaXRQYW5lcyIsIl9pbml0Q29udHJvbFBvcyIsInBhbmVzIiwiX3BhbmVSZW5kZXJlcnMiLCJtYXJrZXJQYW5lIiwic2hhZG93UGFuZSIsImxvYWRpbmciLCJ6b29tQ2hhbmdlZCIsIl9nZXROZXdQaXhlbE9yaWdpbiIsInBpbmNoIiwiX2dldFpvb21TcGFuIiwiX3RhcmdldHMiLCJvbk9mZiIsIl9oYW5kbGVET01FdmVudCIsIl9vbk1vdmVFbmQiLCJfcmVzaXplUmVxdWVzdCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJfZmluZEV2ZW50VGFyZ2V0cyIsInRhcmdldHMiLCJpc0hvdmVyIiwic3JjRWxlbWVudCIsImRyYWdnaW5nIiwiX2RyYWdnYWJsZU1vdmVkIiwibGlzdGVucyIsIl9maXJlRE9NRXZlbnQiLCJfbW91c2VFdmVudHMiLCJzeW50aCIsImlzTWFya2VyIiwiZ2V0TGF0TG5nIiwiX3JhZGl1cyIsImJ1YmJsaW5nTW91c2VFdmVudHMiLCJlbmFibGVkIiwiYm94Wm9vbSIsImRpc2FibGUiLCJ3aGVuUmVhZHkiLCJjYWxsYmFjayIsInBpeGVsT3JpZ2luIiwiX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCIsInRvcExlZnQiLCJfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyIsImxhdExuZ0JvdW5kcyIsIl9nZXRDZW50ZXJPZmZzZXQiLCJjZW50ZXJQb2ludCIsInZpZXdCb3VuZHMiLCJfZ2V0Qm91bmRzT2Zmc2V0IiwiX2xpbWl0T2Zmc2V0IiwibmV3Qm91bmRzIiwicHhCb3VuZHMiLCJwcm9qZWN0ZWRNYXhCb3VuZHMiLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJkeCIsIl9yZWJvdW5kIiwiZHkiLCJyaWdodCIsInByb3h5IiwibWFwUGFuZSIsInRyYW5zZm9ybSIsIl9hbmltYXRpbmdab29tIiwiX29uWm9vbVRyYW5zaXRpb25FbmQiLCJ6IiwiX29uIiwiX2Rlc3Ryb3lBbmltUHJveHkiLCJwcm9wZXJ0eU5hbWUiLCJfbm90aGluZ1RvQW5pbWF0ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYW5pbWF0ZVpvb20iLCJzdGFydEFuaW0iLCJub1VwZGF0ZSIsIl9hbmltYXRlVG9DZW50ZXIiLCJfYW5pbWF0ZVRvWm9vbSIsIkxhdExuZyIsInRvTGF0TG5nIiwiYWx0IiwibWF4TWFyZ2luIiwibWFyZ2luIiwicHJlY2lzaW9uIiwib3RoZXIiLCJ3cmFwIiwic2l6ZUluTWV0ZXJzIiwibGF0QWNjdXJhY3kiLCJsbmdBY2N1cmFjeSIsImNvcyIsIlBJIiwibG9uIiwiTGF0TG5nQm91bmRzIiwidG9MYXRMbmdCb3VuZHMiLCJjb3JuZXIxIiwiY29ybmVyMiIsImxhdGxuZ3MiLCJfc291dGhXZXN0IiwiX25vcnRoRWFzdCIsInN3MiIsIm5lMiIsInBhZCIsImJ1ZmZlclJhdGlvIiwiaGVpZ2h0QnVmZmVyIiwid2lkdGhCdWZmZXIiLCJnZXROb3J0aCIsImdldFdlc3QiLCJnZXRTb3V0aCIsImdldEVhc3QiLCJsYXRJbnRlcnNlY3RzIiwibG5nSW50ZXJzZWN0cyIsImxhdE92ZXJsYXBzIiwibG5nT3ZlcmxhcHMiLCJ0b0JCb3hTdHJpbmciLCJFbGVtZW50IiwiTGF5ZXIiLCJhdHRyaWJ1dGlvbiIsImFkZFRvIiwibWFwIiwiYWRkTGF5ZXIiLCJyZW1vdmVGcm9tIiwiX21hcCIsIl9tYXBUb0FkZCIsInJlbW92ZUxheWVyIiwiYWRkSW50ZXJhY3RpdmVUYXJnZXQiLCJ0YXJnZXRFbCIsInJlbW92ZUludGVyYWN0aXZlVGFyZ2V0IiwiZ2V0QXR0cmlidXRpb24iLCJfbGF5ZXJBZGQiLCJoYXNMYXllciIsImdldEV2ZW50cyIsIm9uY2UiLCJvbkFkZCIsImF0dHJpYnV0aW9uQ29udHJvbCIsImFkZEF0dHJpYnV0aW9uIiwibGF5ZXIiLCJpbmNsdWRlIiwiYmVmb3JlQWRkIiwib25SZW1vdmUiLCJyZW1vdmVBdHRyaWJ1dGlvbiIsImVhY2hMYXllciIsIm1ldGhvZCIsIl9hZGRab29tTGltaXQiLCJfdXBkYXRlWm9vbUxldmVscyIsIl9yZW1vdmVab29tTGltaXQiLCJvbGRab29tU3BhbiIsImRlZHVwZUlkIiwiTWl4aW5GdW5jdGlvbiIsIl9fbWl4aW5BcHBsaWNhdGlvbnMiLCJfX21peGluU2V0IiwiZGVkdXBpbmdNaXhpbiIsIm1peGluIiwibWl4aW5BcHBsaWNhdGlvbnMiLCJXZWFrTWFwIiwibWl4aW5EZWR1cGVJZCIsImJhc2UiLCJiYXNlU2V0IiwiZXh0ZW5kZWQiLCJzZXQiLCJtaXhpblNldCIsIkhhbmRsZXIiLCJfZW5hYmxlZCIsImFkZEhvb2tzIiwicmVtb3ZlSG9va3MiLCJBc3luY0ludGVyZmFjZSIsIm1pY3JvdGFza0N1cnJIYW5kbGUiLCJtaWNyb3Rhc2tMYXN0SGFuZGxlIiwibWljcm90YXNrQ2FsbGJhY2tzIiwibWljcm90YXNrTm9kZUNvbnRlbnQiLCJtaWNyb3Rhc2tOb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJNdXRhdGlvbk9ic2VydmVyIiwibWljcm90YXNrRmx1c2giLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsImNiIiwic3BsaWNlIiwidGltZU91dCIsImFmdGVyIiwiZGVsYXkiLCJjYW5jZWwiLCJhbmltYXRpb25GcmFtZSIsImlkbGVQZXJpb2QiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiaGFuZGxlIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwibWljcm9UYXNrIiwidGV4dENvbnRlbnQiLCJpZHgiLCJFYXJ0aCIsIndyYXBMbmciLCJSIiwicmFkIiwibGF0MSIsImxhdDIiLCJzaW5ETGF0Iiwic2luIiwic2luRExvbiIsImF0YW4yIiwicCIsIm5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibm9kZSIsInNlbGVjdG9yIiwiRG9tQXBpIiwib2JzZXJ2ZXJIYW5kbGUiLCJkaXNjb25uZWN0IiwiZG9jIiwib3duZXJEb2N1bWVudCIsImhvc3QiLCJnZXRSb290Tm9kZSIsImxvY2FsTmFtZSIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiaXAkIiwiYXNzaWduZWRTbG90IiwiZGVlcCIsIkRvY3VtZW50IiwiaW1wb3J0Tm9kZSIsImdldEZsYXR0ZW5lZE5vZGVzIiwiYyQiLCJnZXRFZmZlY3RpdmVDaGlsZE5vZGVzIiwibGlzdCIsImwiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJfYWN0aXZlRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJmb3J3YXJkTWV0aG9kcyIsIm1ldGhvZHMiLCJmb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzIiwicHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZm9yd2FyZFByb3BlcnRpZXMiLCJFdmVudEFwaSIsImNvbXBvc2VkUGF0aCIsImRvbSIsIl9fZG9tQXBpIiwiaGVscGVyIiwiRXZlbnQiLCJmbHVzaCIsImFkZERlYm91bmNlciIsIkZlYXR1cmVHcm91cCIsImFkZEV2ZW50UGFyZW50IiwicmVtb3ZlRXZlbnRQYXJlbnQiLCJzZXRTdHlsZSIsImludm9rZSIsImJyaW5nVG9Gcm9udCIsImJyaW5nVG9CYWNrIiwiZmVhdHVyZUdyb3VwIiwiRXZlbnRzIiwiX2V2ZW50cyIsIl9vZmYiLCJ0eXBlTGlzdGVuZXJzIiwibmV3TGlzdGVuZXIiLCJjdHgiLCJsaXN0ZW5lcnMiLCJfZmlyaW5nQ291bnQiLCJwcm9wYWdhdGUiLCJzb3VyY2VUYXJnZXQiLCJfcHJvcGFnYXRlRXZlbnQiLCJfZXZlbnRQYXJlbnRzIiwicHJvcGFnYXRlZEZyb20iLCJjbGVhckFsbEV2ZW50TGlzdGVuZXJzIiwiYWRkT25lVGltZUV2ZW50TGlzdGVuZXIiLCJmaXJlRXZlbnQiLCJoYXNFdmVudExpc3RlbmVycyIsIkV2ZW50ZWQiLCJDbGFzcyIsIk5ld0NsYXNzIiwicGFyZW50UHJvdG8iLCJfX3N1cGVyX18iLCJjb25zdHJ1Y3RvciIsInN0YXRpY3MiLCJpbmNsdWRlcyIsImNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzIiwiX2luaXRIb29rcyIsIl9pbml0SG9va3NDYWxsZWQiLCJtZXJnZU9wdGlvbnMiLCJhZGRJbml0SG9vayIsImluaXQiLCJMIiwiTWl4aW4iLCJjb25zb2xlIiwid2FybiIsInN0YWNrIiwiVHJhbnNmb3JtYXRpb24iLCJ0b1RyYW5zZm9ybWF0aW9uIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfdHJhbnNmb3JtIiwidW50cmFuc2Zvcm0iLCJDb250cm9sIiwicmVtb3ZlQ29udHJvbCIsImFkZENvbnRyb2wiLCJjb3JuZXIiLCJfY29udHJvbENvcm5lcnMiLCJfcmVmb2N1c09uTWFwIiwic2NyZWVuWCIsInNjcmVlblkiLCJmb2N1cyIsImNvbnRyb2wiLCJjb3JuZXJzIiwiX2NvbnRyb2xDb250YWluZXIiLCJjcmVhdGVDb3JuZXIiLCJ2U2lkZSIsImhTaWRlIiwiUGF0aCIsInN0cm9rZSIsImNvbG9yIiwid2VpZ2h0IiwibGluZUNhcCIsImxpbmVKb2luIiwiZGFzaEFycmF5IiwiZGFzaE9mZnNldCIsImZpbGwiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImZpbGxSdWxlIiwiaW50ZXJhY3RpdmUiLCJnZXRSZW5kZXJlciIsIl9pbml0UGF0aCIsIl9yZXNldCIsIl9hZGRQYXRoIiwiX3JlbW92ZVBhdGgiLCJyZWRyYXciLCJfdXBkYXRlUGF0aCIsIl91cGRhdGVTdHlsZSIsIl9icmluZ1RvRnJvbnQiLCJfYnJpbmdUb0JhY2siLCJnZXRFbGVtZW50IiwiX3BhdGgiLCJfcHJvamVjdCIsIl91cGRhdGUiLCJfY2xpY2tUb2xlcmFuY2UiLCJ0b2xlcmFuY2UiLCJzaW1wbGlmeSIsInBvaW50VG9TZWdtZW50RGlzdGFuY2UiLCJjbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJjbGlwU2VnbWVudCIsIl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwiX2dldEJpdENvZGUiLCJfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJpc0ZsYXQiLCJfZmxhdCIsInNxVG9sZXJhbmNlIiwiX3JlZHVjZVBvaW50cyIsIl9zaW1wbGlmeURQIiwicDEiLCJwMiIsIkFycmF5Q29uc3RydWN0b3IiLCJVaW50OEFycmF5IiwibWFya2VycyIsIl9zaW1wbGlmeURQU3RlcCIsIm5ld1BvaW50cyIsImZpcnN0IiwibGFzdCIsIm1heFNxRGlzdCIsImluZGV4Iiwic3FEaXN0IiwicmVkdWNlZFBvaW50cyIsInByZXYiLCJfc3FEaXN0IiwiX2xhc3RDb2RlIiwidXNlTGFzdENvZGUiLCJjb2RlQSIsImNvZGVCIiwiY29kZU91dCIsIm5ld0NvZGUiLCJkb3QiLCJDU1NfVVJMX1JYIiwiQUJTX1VSTCIsIndvcmtpbmdVUkwiLCJyZXNvbHZlRG9jIiwicmVzb2x2ZVVybCIsInVybCIsImJhc2VVUkkiLCJVUkwiLCJwYXRobmFtZSIsImhyZWYiLCJsb2NhdGlvbiIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiaGVhZCIsImFuY2hvciIsImJvZHkiLCJyZXNvbHZlQ3NzIiwiY3NzVGV4dCIsIm0iLCJwcmUiLCJwb3N0IiwicGF0aEZyb21VcmwiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImlzUGF0aCIsInJvb3QiLCJpc0FuY2VzdG9yIiwiaXNEZXNjZW5kYW50IiwidHJhbnNsYXRlIiwibm9ybWFsaXplIiwicGF0aCIsImRvdEluZGV4IiwibmV3QmFzZSIsInBhcnRzIiwiaW5mbyIsInBhcnQiLCJpc0RlZXAiLCJBc3luY01vZHVsZSIsIkRlYm91bmNlciIsIl9hc3luY01vZHVsZSIsIl9jYWxsYmFjayIsIl90aW1lciIsImFzeW5jTW9kdWxlIiwiaXNBY3RpdmUiLCJkZWJvdW5jZXIiLCJzZXRDb25maWciLCJrbGFzcyIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIiwiaXMiLCJtdXRhYmxlUHJvcGVydHlDaGFuZ2UiLCJpbnN0IiwicHJvcGVydHkiLCJvbGQiLCJtdXRhYmxlRGF0YSIsImlzT2JqZWN0IiwiX19kYXRhVGVtcCIsInNob3VsZENoYW5nZSIsIk11dGFibGVEYXRhIiwic3VwZXJDbGFzcyIsIk9wdGlvbmFsTXV0YWJsZURhdGEiLCJCb29sZWFuIiwiX211dGFibGVQcm9wZXJ0eUNoYW5nZSIsImljb24iLCJJY29uIiwicG9wdXBBbmNob3IiLCJ0b29sdGlwQW5jaG9yIiwiY3JlYXRlSWNvbiIsIm9sZEljb24iLCJfY3JlYXRlSWNvbiIsImNyZWF0ZVNoYWRvdyIsIl9nZXRJY29uVXJsIiwiaW1nIiwiX2NyZWF0ZUltZyIsIl9zZXRJY29uU3R5bGVzIiwic2l6ZU9wdGlvbiIsInNoYWRvd0FuY2hvciIsImljb25BbmNob3IiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwiUmVuZGVyZXIiLCJfdXBkYXRlUGF0aHMiLCJfZGVzdHJveUNvbnRhaW5lciIsInZpZXdyZXNldCIsIl9vblpvb20iLCJtb3ZlZW5kIiwiem9vbWVuZCIsIl9vblpvb21FbmQiLCJ6b29tYW5pbSIsIl9vbkFuaW1ab29tIiwiZXYiLCJfdXBkYXRlVHJhbnNmb3JtIiwiY3VycmVudENlbnRlclBvaW50IiwiX2NlbnRlciIsImRlc3RDZW50ZXJQb2ludCIsInRvcExlZnRPZmZzZXQiLCJfYm91bmRzIiwiY2lyY2xlTWFya2VyIiwiQ2lyY2xlTWFya2VyIiwicmFkaXVzIiwiX2xhdGxuZyIsInNldExhdExuZyIsInNldFJhZGl1cyIsImdldFJhZGl1cyIsIl9wb2ludCIsIl91cGRhdGVCb3VuZHMiLCJyMiIsIl9yYWRpdXNZIiwiX3B4Qm91bmRzIiwiX3VwZGF0ZUNpcmNsZSIsIl9lbXB0eSIsIl9jb250YWluc1BvaW50IiwiX3JlZ0xvZyIsInJlZ2lzdGVyIiwiZHVtcFJlZ2lzdHJhdGlvbnMiLCJjYXNlTWFwJDAiLCJFbGVtZW50TWl4aW4iLCJwb2x5bWVyRWxlbWVudEJhc2UiLCJjYXNlTWFwIiwib3duUHJvcGVydGllc0ZvckNsYXNzIiwiX19vd25Qcm9wZXJ0aWVzIiwib3duT2JzZXJ2ZXJzRm9yQ2xhc3MiLCJfX293bk9ic2VydmVycyIsIm9ic2VydmVycyIsImZsYXR0ZW5Qcm9wZXJ0aWVzIiwiZmxhdHRlbmVkUHJvcHMiLCJvIiwicHJvcGVydGllc0ZvckNsYXNzIiwiX19jbGFzc1Byb3BlcnRpZXMiLCJzdXBlckN0b3IiLCJnZXRQcm90b3R5cGVPZiIsIlBvbHltZXJFbGVtZW50IiwiYXNzaWduIiwicHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzIiwiX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMiLCJoYXNDbGFzc0ZpbmFsaXplZCIsImZpbmFsaXplQ2xhc3NBbmRTdXBlciIsImZpbmFsaXplIiwiZmluYWxpemVDbGFzcyIsIl9fZmluYWxpemVkIiwiZmluYWxpemVQcm9wZXJ0aWVzIiwiZmluYWxpemVPYnNlcnZlcnMiLCJjbG9uZU5vZGUiLCJfdGVtcGxhdGUiLCJjcmVhdGVQcm9wZXJ0eUZyb21Db25maWciLCJkeW5hbWljRm5zIiwiX2NyZWF0ZU1ldGhvZE9ic2VydmVyIiwiYWxsUHJvcHMiLCJjb21wdXRlZCIsInJlYWRPbmx5IiwiX2hhc1JlYWRPbmx5RWZmZWN0IiwiX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkiLCJfY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eSIsInJlZmxlY3RUb0F0dHJpYnV0ZSIsIl9oYXNSZWZsZWN0RWZmZWN0IiwiX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5Iiwibm90aWZ5IiwiX2hhc05vdGlmeUVmZmVjdCIsIl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eSIsIm9ic2VydmVyIiwiX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIiLCJmaW5hbGl6ZVRlbXBsYXRlIiwiZXh0IiwiY29udGVudCIsIlNoYWR5Q1NTIiwicHJlcGFyZVRlbXBsYXRlIiwiX2JpbmRUZW1wbGF0ZSIsIl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiaW1wb3J0IiwibW9kdWxlIiwiX2ltcG9ydFBhdGgiLCJhc3NldHBhdGgiLCJpbXBvcnRQYXRoIiwicm9vdFBhdGgiLCIkIiwiaW5zdGFuY2VDb3VudCIsIl9fcG9seW1lckZpbmFsaXplZCIsIl9fcHJvdG9fXyIsInAkIiwiX2hhc0FjY2Vzc29yIiwiX3NldFBlbmRpbmdQcm9wZXJ0eSIsInN0eWxlRWxlbWVudCIsIl9lbmFibGVQcm9wZXJ0aWVzIiwiX3N0YW1wVGVtcGxhdGUiLCJfYXR0YWNoRG9tIiwiYXR0YWNoU2hhZG93Iiwic2hhZG93Um9vdCIsIm1vZGUiLCJkYXNoVG9DYW1lbENhc2UiLCJfYXR0cmlidXRlVG9Qcm9wZXJ0eSIsInN0eWxlU3VidHJlZSIsInRlbXBsYXRlSW5mbyIsIm5vZGVJbmZvIiwicmVnaXN0cmF0aW9ucyIsImZvckVhY2giLCJ1cGRhdGVTdHlsZXMiLCJzdHlsZURvY3VtZW50Iiwic2V0dGluZ3MiLCJ1c2VTaGFkb3ciLCJTaGFkeURPTSIsInVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMiLCJuYXRpdmVDc3MiLCJ1c2VOYXRpdmVDdXN0b21FbGVtZW50cyIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJTZXR0aW5ncyIsInNldFJvb3RQYXRoIiwic2FuaXRpemVET01WYWx1ZSIsInNldFNhbml0aXplRE9NVmFsdWUiLCJuZXdTYW5pdGl6ZURPTVZhbHVlIiwiY2FtZWxUb0Rhc2hDYXNlIiwiREFTSF9UT19DQU1FTCIsIkNBTUVMX1RPX0RBU0giLCJkYXNoIiwiY2FtZWwiLCJDYXNlTWFwIiwiVFlQRVMiLCJDT01QVVRFIiwiUkVGTEVDVCIsIk5PVElGWSIsIlBST1BBR0FURSIsIk9CU0VSVkUiLCJSRUFEX09OTFkiLCJEYXRhVHJpZ2dlciIsIkRhdGFFZmZlY3QiLCJQcm9wZXJ0eUVmZmVjdHNUeXBlIiwiZW5zdXJlT3duRWZmZWN0TWFwIiwibW9kZWwiLCJlZmZlY3RzIiwicHJvdG9GeCIsImluc3RGeCIsInJ1bkVmZmVjdHMiLCJvbGRQcm9wcyIsImhhc1BhdGhzIiwiZXh0cmFBcmdzIiwicmFuIiwicnVuRWZmZWN0c0ZvclByb3BlcnR5Iiwicm9vdFByb3BlcnR5IiwiZnhzIiwiZngiLCJsYXN0UnVuIiwicGF0aE1hdGNoZXNUcmlnZ2VyIiwidHJpZ2dlciIsInRyaWdnZXJQYXRoIiwic3RydWN0dXJlZCIsIndpbGRjYXJkIiwicnVuT2JzZXJ2ZXJFZmZlY3QiLCJtZXRob2ROYW1lIiwiY2hhbmdlZFByb3AiLCJfX2RhdGEiLCJkeW5hbWljRm4iLCJydW5Ob3RpZnlFZmZlY3RzIiwibm90aWZ5UHJvcHMiLCJub3RpZmllZCIsIm5vdGlmeVBhdGgiLCJfX2RhdGFIb3N0IiwiX2ludmFsaWRhdGVQcm9wZXJ0aWVzIiwiZXZlbnROYW1lIiwiZGlzcGF0Y2hOb3RpZnlFdmVudCIsInF1ZXVlUHJvcGVydHkiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJydW5Ob3RpZnlFZmZlY3QiLCJoYW5kbGVOb3RpZmljYXRpb24iLCJmcm9tUHJvcCIsInRvUGF0aCIsIm5lZ2F0ZSIsImZyb21QYXRoIiwiX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCIsInJ1blJlZmxlY3RFZmZlY3QiLCJhdHRyTmFtZSIsIl9wcm9wZXJ0eVRvQXR0cmlidXRlIiwicnVuQ29tcHV0ZWRFZmZlY3RzIiwiY2hhbmdlZFByb3BzIiwiY29tcHV0ZUVmZmVjdHMiLCJpbnB1dFByb3BzIiwiX19kYXRhT2xkIiwiX19kYXRhUGVuZGluZyIsInJ1bkNvbXB1dGVkRWZmZWN0IiwicmVzdWx0IiwicnVuTWV0aG9kRWZmZWN0IiwiY29tcHV0ZWRQcm9wIiwibWV0aG9kSW5mbyIsIl9fZGF0YUhhc0FjY2Vzc29yIiwiY29tcHV0ZUxpbmtlZFBhdGhzIiwibGlua3MiLCJfX2RhdGFMaW5rZWRQYXRocyIsImxpbmsiLCJhZGRCaW5kaW5nIiwia2luZCIsImxpdGVyYWwiLCJiaW5kaW5ncyIsImJpbmRpbmciLCJpc0NvbXBvdW5kIiwic2hvdWxkQWRkTGlzdGVuZXIiLCJsaXN0ZW5lckV2ZW50IiwibGlzdGVuZXJOZWdhdGUiLCJub2RlSW5mb0xpc3QiLCJjb21wb3VuZEluZGV4IiwiYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQiLCJkZXBlbmRlbmNpZXMiLCJldmFsdWF0b3IiLCJwYXJzZUFyZyIsIl9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0IiwicnVuQmluZGluZ0VmZmVjdCIsIm5vZGVMaXN0Iiwic291cmNlIiwiX2VucXVldWVDbGllbnQiLCJfZXZhbHVhdGVCaW5kaW5nIiwiYXBwbHlCaW5kaW5nVmFsdWUiLCJjb21wdXRlQmluZGluZ1ZhbHVlIiwiX3ZhbHVlVG9Ob2RlQXR0cmlidXRlIiwiX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlIiwic3RvcmFnZSIsIl9fZGF0YUNvbXBvdW5kU3RvcmFnZSIsInNldHVwQmluZGluZ3MiLCJzZXR1cENvbXBvdW5kU3RvcmFnZSIsImFkZE5vdGlmeUxpc3RlbmVyIiwibGl0ZXJhbHMiLCJjcmVhdGVNZXRob2RFZmZlY3QiLCJzaWciLCJlZmZlY3RGbiIsInN0YXRpYyIsImFyZyIsIl9hZGRQcm9wZXJ0eUVmZmVjdCIsIl9tZXRob2RIb3N0IiwibWFyc2hhbEFyZ3MiLCJlbXB0eUFycmF5IiwiSURFTlQiLCJOVU1CRVIiLCJTUVVPVEVfU1RSSU5HIiwiRFFVT1RFX1NUUklORyIsIlNUUklORyIsIkFSR1VNRU5UIiwiQVJHVU1FTlRTIiwiQVJHVU1FTlRfTElTVCIsIkJJTkRJTkciLCJPUEVOX0JSQUNLRVQiLCJDTE9TRV9CUkFDS0VUIiwiTkVHQVRFIiwiRVhQUkVTU0lPTiIsImJpbmRpbmdSZWdleCIsImxpdGVyYWxGcm9tUGFydHMiLCJwYXJzZU1ldGhvZCIsImV4cHJlc3Npb24iLCJtYXRjaCIsInBhcnNlQXJncyIsImFyZ0xpc3QiLCJyYXdBcmciLCJmYyIsIk51bWJlciIsInZhbHVlcyIsImJhc2VDaGFuZ2VkIiwibm90aWZ5U3BsaWNlcyIsInNwbGljZXMiLCJzcGxpY2VzUGF0aCIsImluZGV4U3BsaWNlcyIsIm5vdGlmeVNwbGljZSIsImFkZGVkQ291bnQiLCJyZW1vdmVkIiwib2JqZWN0IiwidXBwZXIiLCJQcm9wZXJ0eUVmZmVjdHMiLCJwcm9wZXJ0eUVmZmVjdHNCYXNlIiwiX19kYXRhQ2xpZW50c1JlYWR5IiwiX19kYXRhUGVuZGluZ0NsaWVudHMiLCJfX2RhdGFUb05vdGlmeSIsIl9fZGF0YUhhc1BhdGhzIiwiX19kYXRhQ2xpZW50c0luaXRpYWxpemVkIiwiX19jb21wdXRlRWZmZWN0cyIsIl9fcmVmbGVjdEVmZmVjdHMiLCJfX25vdGlmeUVmZmVjdHMiLCJfX3Byb3BhZ2F0ZUVmZmVjdHMiLCJfX29ic2VydmVFZmZlY3RzIiwiX19yZWFkT25seSIsIl9fZGF0YUNvdW50ZXIiLCJfX3RlbXBsYXRlSW5mbyIsImhvc3RTdGFjayIsInJlZ2lzdGVySG9zdCIsImVmZmVjdCIsIl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yIiwiX2hhc1Byb3BlcnR5RWZmZWN0Iiwic2hvdWxkTm90aWZ5IiwiaXNQYXRoTm90aWZpY2F0aW9uIiwicHJldlByb3BzIiwiX3Nob3VsZFByb3BlcnR5Q2hhbmdlIiwiX19kYXRhUmVhZHkiLCJfZmx1c2hQcm9wZXJ0aWVzIiwiY2xpZW50IiwiX3JlYWR5Q2xpZW50cyIsIl9fZW5hYmxlT3JGbHVzaENsaWVudHMiLCJjbGllbnRzIiwiX19kYXRhRW5hYmxlZCIsInNldFJlYWRPbmx5IiwiX2ZsdXNoQ2xpZW50cyIsImN1cnJlbnRQcm9wcyIsIl9wcm9wYWdhdGVQcm9wZXJ0eUNoYW5nZXMiLCJwcm9wZXJ0eUVmZmVjdHMiLCJuZXh0VGVtcGxhdGVJbmZvIiwiaXRlbXMiLCJyZXQiLCJoYWRMZW5ndGgiLCJwb3AiLCJkZWxldGVDb3VudCIsInNoaWZ0IiwidW5zaGlmdCIsInByb3BQYXRoIiwicHJvdGVjdGVkU2V0dGVyIiwiX3NldFByb3BlcnR5IiwiYXR0ciIsImluc3RhbmNlQmluZGluZyIsIl9wYXJzZVRlbXBsYXRlIiwid2FzUHJlQm91bmQiLCJfX3RlbXBsYXRlSW5mb0xhc3QiLCJwcmV2aW91c1RlbXBsYXRlSW5mbyIsImJlZ2luSG9zdGluZyIsImVuZEhvc3RpbmciLCJub2RlcyIsImNoaWxkTm9kZXMiLCJuZXh0U2libGluZyIsImhvc3RQcm9wcyIsInByb3BFZmZlY3RzIiwibm90ZWQiLCJURVhUX05PREUiLCJfcGFyc2VCaW5kaW5ncyIsIm9yaWdOYW1lIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwidGV4dCIsImxhc3RJbmRleCIsImN1c3RvbUV2ZW50Iiwibm90aWZ5RXZlbnQiLCJjb2xvbiIsInNpZ25hdHVyZSIsInN0YWNrTGVuIiwibmF0aXZlU2hhZG93IiwibmF0aXZlQ3NzVmFyaWFibGVzIiwiY2FsY0Nzc1ZhcmlhYmxlcyIsIkNTUyIsInN1cHBvcnRzIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJyZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudCIsIlN0eWxlTm9kZSIsImNsZWFuIiwicGFyc2VDc3MiLCJsZXgiLCJSWCIsImNvbW1lbnRzIiwicG9ydCIsIk9QRU5fQlJBQ0UiLCJwcmV2aW91cyIsIkNMT1NFX0JSQUNFIiwic3MiLCJfZXhwYW5kVW5pY29kZUVzY2FwZXMiLCJtdWx0aXBsZVNwYWNlcyIsIkFUX1NUQVJUIiwiTUVESUFfU1RBUlQiLCJNRURJQV9SVUxFIiwia2V5ZnJhbWVzUnVsZSIsIktFWUZSQU1FU19SVUxFIiwiVkFSX1NUQVJUIiwiTUlYSU5fUlVMRSIsIlNUWUxFX1JVTEUiLCJyJCIsInJlcGVhdCIsInByZXNlcnZlUHJvcGVydGllcyIsIl9oYXNNaXhpblJ1bGVzIiwicmVtb3ZlQ3VzdG9tUHJvcHMiLCJydWxlcyIsInJlbW92ZUN1c3RvbVByb3BBcHBseSIsImN1c3RvbVByb3AiLCJtaXhpblByb3AiLCJtaXhpbkFwcGx5IiwidmFyQXBwbHkiLCJWQVJfQVNTSUdOIiwiTUlYSU5fTUFUQ0giLCJWQVJfQ09OU1VNRUQiLCJBTklNQVRJT05fTUFUQ0giLCJNRURJQV9NQVRDSCIsIklTX1ZBUiIsIkJSQUNLRVRFRCIsIkhPU1RfUFJFRklYIiwiSE9TVF9TVUZGSVgiLCJ1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzIiwiZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlIiwiZGV0ZWN0TWl4aW4iLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwiZ2V0UHJvcGVydHlWYWx1ZSIsImhhcyIsImRlZXBUYXJnZXRGaW5kIiwiX2ZpbmRPcmlnaW5hbFRhcmdldCIsIl9oYW5kbGVOYXRpdmUiLCJfaGFuZGxlVG91Y2hBY3Rpb24iLCJfcmVtb3ZlIiwiX2ZpbmRSZWNvZ25pemVyQnlFdmVudCIsInNldFRvdWNoQWN0aW9uIiwicmVzZXRNb3VzZUNhbmNlbGxlciIsIkhBU19OQVRJVkVfVEEiLCJ0b3VjaEFjdGlvbiIsIkdFU1RVUkVfS0VZIiwiSEFORExFRF9PQkoiLCJUT1VDSF9BQ1RJT04iLCJUQVBfRElTVEFOQ0UiLCJUUkFDS19ESVNUQU5DRSIsIlRSQUNLX0xFTkdUSCIsIk1PVVNFX1RJTUVPVVQiLCJNT1VTRV9FVkVOVFMiLCJNT1VTRV9XSElDSF9UT19CVVRUT05TIiwiTU9VU0VfSEFTX0JVVFRPTlMiLCJNb3VzZUV2ZW50IiwiYnV0dG9ucyIsIlNVUFBPUlRTX1BBU1NJVkUiLCJvcHRzIiwiSVNfVE9VQ0hfT05MWSIsIkdlc3R1cmVSZWNvZ25pemVyIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsImNsaWNrIiwibW91c2VDYW5jZWxsZXIiLCJtb3VzZUV2ZW50Iiwic2MiLCJzb3VyY2VDYXBhYmlsaXRpZXMiLCJmaXJlc1RvdWNoRXZlbnRzIiwic2tpcCIsIlBPSU5URVJTVEFURSIsIm1vdXNlIiwic2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyIiwic2V0dXAiLCJlbiIsImlnbm9yZU1vdXNlIiwibW91c2VJZ25vcmVKb2IiLCJ1bnNldCIsImRlYm91bmNlIiwiaGFzTGVmdE1vdXNlQnV0dG9uIiwid2hpY2giLCJidXR0b24iLCJpc1N5bnRoZXRpY0NsaWNrIiwiYmNyIiwicGFnZVgiLCJwYWdlWSIsImJvdHRvbSIsInNjcm9sbERlY2lkZWQiLCJmaXJzdFRvdWNoQWN0aW9uIiwidGEiLCJ0cmFja0RvY3VtZW50Iiwic3RhdGVPYmoiLCJtb3ZlZm4iLCJ1cGZuIiwidW50cmFja0RvY3VtZW50IiwicGFzc2l2ZSIsImdlc3R1cmVzIiwicmVjb2duaXplcnMiLCJlbGVtZW50RnJvbVBvaW50IiwibmV4dCIsIm9sZE5leHQiLCJoYW5kbGVkIiwiY3VycmVudFRhcmdldCIsImdvYmoiLCJncyIsImNoYW5nZWRUb3VjaGVzIiwidG91Y2hlcyIsImlkZW50aWZpZXIiLCJmbG93IiwicHJldmVudCIsImNhbmNlbGFibGUiLCJldlR5cGUiLCJyZWNvZ25pemVyIiwiZGVwcyIsImRlcCIsImdkIiwiX2NvdW50IiwicmVjb2ciLCJlbWl0cyIsImV2TmFtZSIsIl9maXJlIiwiYnViYmxlcyIsImNvbXBvc2VkIiwiZGVmYXVsdFByZXZlbnRlZCIsInByZXZlbnRlciIsInNvdXJjZUV2ZW50IiwiZW5kIiwic2VsZiIsInN0YXRlIiwic3RhcnRlZCIsIm1vdmVzIiwiYWRkTW92ZSIsIm1vdmUiLCJoYXNNb3ZlZEVub3VnaCIsImN0Iiwic2Vjb25kbGFzdCIsImxhc3Rtb3ZlIiwiZGR4IiwiZGR5IiwiaG92ZXIiLCJOYU4iLCJzYXZlIiwiZm9yd2FyZCIsImZpbmRPcmlnaW5hbFRhcmdldCIsImRlYm91bmNlclF1ZXVlIiwiZW5xdWV1ZURlYm91bmNlciIsImZsdXNoRGVib3VuY2VycyIsImRpZEZsdXNoIiwic2hhZHlET00iLCJkZWJvdW5jZXJzIiwiU2NvcGluZ1NoaW0iLCJuZXdJbnN0YW5jZSIsIkhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24iLCJIVE1MVGVtcGxhdGVFbGVtZW50Iiwid3JpdGFibGUiLCJEYXRhVGVtcGxhdGUiLCJNdXRhYmxlRGF0YVRlbXBsYXRlIiwidXBncmFkZVRlbXBsYXRlIiwic2V0UHJvdG90eXBlT2YiLCJUZW1wbGF0ZUluc3RhbmNlQmFzZSIsIl9jb25maWd1cmVQcm9wZXJ0aWVzIiwiY2hpbGRyZW4iLCJfX3RlbXBsYXRpemVJbnN0YW5jZSIsIl9fdGVtcGxhdGl6ZU93bmVyIiwiX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fIiwiX3Nob3dIaWRlQ2hpbGRyZW4iLCJfX3RlbXBsYXRpemVPcHRpb25zIiwiaW5zdGFuY2VQcm9wcyIsImlwcm9wIiwiaHByb3AiLCJfX2hvc3RQcm9wcyIsInBhcmVudE1vZGVsIiwiX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUiLCJ0ZW1wbGF0ZUhvc3QiLCJoaWRlIiwiX19wb2x5bWVyVGV4dENvbnRlbnRfXyIsIl9fcG9seW1lckRpc3BsYXlfXyIsImRpc3BsYXkiLCJfX3BhcmVudE1vZGVsIiwiTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlIiwiZmluZE1ldGhvZEhvc3QiLCJjcmVhdGVUZW1wbGF0aXplckNsYXNzIiwiYWRkTm90aWZ5RWZmZWN0cyIsImFkZFByb3BhZ2F0ZUVmZmVjdHMiLCJ1c2VyRm9yd2FyZEhvc3RQcm9wIiwiZm9yd2FyZEhvc3RQcm9wIiwidGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MiLCJQUk9QRVJUWV9FRkZFQ1RfVFlQRVMiLCJjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QiLCJfX2RhdGFQcm90byIsImhvc3RQcm9wIiwidXNlck5vdGlmeUluc3RhbmNlUHJvcCIsIm5vdGlmeUluc3RhbmNlUHJvcCIsImNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdCIsImNyZWF0ZU5vdGlmeUhvc3RQcm9wRWZmZWN0IiwiaW5zdFByb3AiLCJub3RpZnlIb3N0UHJvcCIsIlRlbXBsYXRpemUiLCJ0ZW1wbGF0aXplIiwib3duZXIiLCJiYXNlQ2xhc3MiLCJ0ZW1wbGF0aXplSW5zdGFuY2VDbGFzcyIsIm1vZGVsRm9yRWxlbWVudCIsImRvbVJlcGVhdEJhc2UiLCJEb21SZXBlYXQiLCJhcyIsIlN0cmluZyIsImluZGV4QXMiLCJpdGVtc0luZGV4QXMiLCJzb3J0IiwiRnVuY3Rpb24iLCJyZW5kZXJlZEl0ZW1Db3VudCIsImluaXRpYWxDb3VudCIsInRhcmdldEZyYW1lcmF0ZSIsIl90YXJnZXRGcmFtZVRpbWUiLCJfX2luc3RhbmNlcyIsIl9fbGltaXQiLCJfX3Bvb2wiLCJfX3JlbmRlckRlYm91bmNlciIsIl9faXRlbXNJZHhUb0luc3RJZHgiLCJfX2NodW5rQ291bnQiLCJfX2xhc3RDaHVua1RpbWUiLCJfX3NvcnRGbiIsIl9fZmlsdGVyRm4iLCJfX29ic2VydmVQYXRocyIsIl9fY3RvciIsIl9faXNEZXRhY2hlZCIsIl9fZGV0YWNoSW5zdGFuY2UiLCJfX2F0dGFjaEluc3RhbmNlIiwicXVlcnlTZWxlY3RvciIsIl9fcmVuZGVyIiwiY2hpbGRMaXN0IiwiaSQiLCJtZXRob2RIb3N0IiwiX19nZXRNZXRob2RIb3N0IiwiX19kZWJvdW5jZVJlbmRlciIsInJhdGUiLCJwZXJmb3JtYW5jZSIsIl9fcmVxdWVzdFJlbmRlckNodW5rIiwiX19yZW5kZXJDaHVuayIsImN1cnJDaHVua1RpbWUiLCJyYXRpbyIsImNoYW5nZSIsIl9faGFuZGxlSXRlbVBhdGgiLCJfX2luaXRpYWxpemVDaHVua2luZyIsInBhdGhzIiwiX19lbnN1cmVUZW1wbGF0aXplZCIsIl9fYXBwbHlGdWxsUmVmcmVzaCIsIl9zZXRSZW5kZXJlZEl0ZW1Db3VudCIsIl9fdHJ5UmVuZGVyQ2h1bmsiLCJpc250SWR4VG9JdGVtc0lkeCIsIml0ZW1zSWR4VG9JbnN0SWR4IiwiaW5zdElkeCIsImxpbWl0IiwiaXRlbUlkeCIsIl9faW5zZXJ0SW5zdGFuY2UiLCJfX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlIiwiX19zdGFtcEluc3RhbmNlIiwiYmVmb3JlUm93IiwiYmVmb3JlTm9kZSIsImhpZGRlbiIsIml0ZW1zUGF0aCIsIml0ZW1zSWR4IiwiaXRlbVN1YlBhdGgiLCJfX2hhbmRsZU9ic2VydmVkUGF0aHMiLCJpdGVtUGF0aCIsImluc3RhbmNlIiwiUGFwZXJSaXBwbGVCZWhhdmlvciIsIm5vaW5rIiwiX3JpcHBsZUNvbnRhaW5lciIsIl9idXR0b25TdGF0ZUNoYW5nZWQiLCJmb2N1c2VkIiwiZW5zdXJlUmlwcGxlIiwiX2Rvd25IYW5kbGVyIiwicHJlc3NlZCIsIm9wdFRyaWdnZXJpbmdFdmVudCIsImhhc1JpcHBsZSIsIl9yaXBwbGUiLCJfY3JlYXRlUmlwcGxlIiwicmlwcGxlQ29udGFpbmVyIiwiZG9tQ29udGFpbmVyIiwicm9vdFRhcmdldCIsImRlZXBDb250YWlucyIsInVpRG93bkFjdGlvbiIsImdldFJpcHBsZSIsIl9ub2lua0NoYW5nZWQiLCJMYXllckdyb3VwIiwiZ2V0TGF5ZXJJZCIsImNsZWFyTGF5ZXJzIiwiZ2V0TGF5ZXIiLCJnZXRMYXllcnMiLCJzZXRaSW5kZXgiLCJ6SW5kZXgiLCJsYXllckdyb3VwIiwiQ1JTIiwicHJvamVjdGlvbiIsInRyYW5zZm9ybWF0aW9uIiwidW50cmFuc2Zvcm1lZFBvaW50IiwiTE4yIiwiaW5maW5pdGUiLCJ3cmFwTGF0IiwibGF0U2hpZnQiLCJsbmdTaGlmdCIsIm5ld1N3IiwibmV3TmUiLCJtYXJrZXIiLCJNYXJrZXIiLCJkcmFnZ2FibGUiLCJhdXRvUGFuIiwiYXV0b1BhblBhZGRpbmciLCJhdXRvUGFuU3BlZWQiLCJrZXlib2FyZCIsInRpdGxlIiwiekluZGV4T2Zmc2V0IiwicmlzZU9uSG92ZXIiLCJyaXNlT2Zmc2V0IiwiX2luaXRJY29uIiwidXBkYXRlIiwiX3JlbW92ZUljb24iLCJfcmVtb3ZlU2hhZG93Iiwib2xkTGF0TG5nIiwic2V0WkluZGV4T2Zmc2V0Iiwic2V0SWNvbiIsIl9wb3B1cCIsImJpbmRQb3B1cCIsIl9pY29uIiwiX3NldFBvcyIsImNsYXNzVG9BZGQiLCJhZGRJY29uIiwibW91c2VvdmVyIiwibW91c2VvdXQiLCJfcmVzZXRaSW5kZXgiLCJuZXdTaGFkb3ciLCJfc2hhZG93IiwiYWRkU2hhZG93IiwiX3VwZGF0ZU9wYWNpdHkiLCJfaW5pdEludGVyYWN0aW9uIiwiX3pJbmRleCIsIl91cGRhdGVaSW5kZXgiLCJvcHQiLCJfZ2V0UG9wdXBBbmNob3IiLCJfZ2V0VG9vbHRpcEFuY2hvciIsIlNUQVJUIiwiRU5EIiwicG9pbnRlcmRvd24iLCJNU1BvaW50ZXJEb3duIiwiTU9WRSIsIkRyYWdnYWJsZSIsImNsaWNrVG9sZXJhbmNlIiwiZHJhZ1N0YXJ0VGFyZ2V0IiwiX2VsZW1lbnQiLCJfZHJhZ1N0YXJ0VGFyZ2V0IiwiX3ByZXZlbnRPdXRsaW5lIiwiX29uRG93biIsIl9kcmFnZ2luZyIsImZpbmlzaERyYWciLCJzaGlmdEtleSIsIl9tb3ZpbmciLCJfc3RhcnRQb2ludCIsIl9vbk1vdmUiLCJfb25VcCIsIm5ld1BvaW50IiwiX3N0YXJ0UG9zIiwiX2xhc3RUYXJnZXQiLCJTVkdFbGVtZW50SW5zdGFuY2UiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsIl9uZXdQb3MiLCJfYW5pbVJlcXVlc3QiLCJfbGFzdEV2ZW50IiwiX3VwZGF0ZVBvc2l0aW9uIiwiSW1hZ2VPdmVybGF5IiwiY3Jvc3NPcmlnaW4iLCJlcnJvck92ZXJsYXlVcmwiLCJfdXJsIiwiX2ltYWdlIiwiX2luaXRJbWFnZSIsInN0eWxlT3B0cyIsInNldFVybCIsInNldEJvdW5kcyIsIndhc0VsZW1lbnRTdXBwbGllZCIsIm9uc2VsZWN0c3RhcnQiLCJvbm1vdXNlbW92ZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfb3ZlcmxheU9uRXJyb3IiLCJpbWFnZSIsImVycm9yVXJsIiwiaW1hZ2VPdmVybGF5IiwiRGl2T3ZlcmxheSIsIl9zb3VyY2UiLCJfcmVtb3ZlVGltZW91dCIsIl9hZGp1c3RQYW4iLCJnZXRDb250ZW50IiwiX2NvbnRlbnQiLCJzZXRDb250ZW50IiwidmlzaWJpbGl0eSIsIl91cGRhdGVDb250ZW50IiwiX3VwZGF0ZUxheW91dCIsImlzT3BlbiIsIl9jb250ZW50Tm9kZSIsImhhc0NoaWxkTm9kZXMiLCJfZ2V0QW5jaG9yIiwiX2NvbnRhaW5lckJvdHRvbSIsIl9jb250YWluZXJMZWZ0IiwiX2NvbnRhaW5lcldpZHRoIiwidGlsZUxheWVyIiwiVGlsZUxheWVyIiwic3ViZG9tYWlucyIsImVycm9yVGlsZVVybCIsInpvb21PZmZzZXQiLCJ0bXMiLCJ6b29tUmV2ZXJzZSIsImRldGVjdFJldGluYSIsInRpbGVTaXplIiwiX29uVGlsZVJlbW92ZSIsIm5vUmVkcmF3IiwiY3JlYXRlVGlsZSIsImRvbmUiLCJ0aWxlIiwiX3RpbGVPbkxvYWQiLCJfdGlsZU9uRXJyb3IiLCJnZXRUaWxlVXJsIiwiX2dldFN1YmRvbWFpbiIsIl9nZXRab29tRm9yVXJsIiwiaW52ZXJ0ZWRZIiwiX2dsb2JhbFRpbGVSYW5nZSIsImdldEF0dHJpYnV0ZSIsIl90aWxlWm9vbSIsInRpbGVQb2ludCIsIl9hYm9ydExvYWRpbmciLCJfdGlsZXMiLCJjb21wbGV0ZSIsInRpbGVMYXllcldNUyIsIlRpbGVMYXllcldNUyIsImRlZmF1bHRXbXNQYXJhbXMiLCJzZXJ2aWNlIiwicmVxdWVzdCIsInN0eWxlcyIsImZvcm1hdCIsInRyYW5zcGFyZW50IiwidmVyc2lvbiIsIndtc1BhcmFtcyIsInJlYWxSZXRpbmEiLCJnZXRUaWxlU2l6ZSIsIl9jcnMiLCJfd21zVmVyc2lvbiIsInBhcnNlRmxvYXQiLCJwcm9qZWN0aW9uS2V5IiwidGlsZUJvdW5kcyIsIl90aWxlQ29vcmRzVG9Od1NlIiwiYmJveCIsInNldFBhcmFtcyIsIkVQU0c0MzI2IiwiTG9uTGF0IiwicG9seWxpbmUiLCJMaW5lVXRpbCIsIlBvbHlsaW5lIiwic21vb3RoRmFjdG9yIiwibm9DbGlwIiwiX3NldExhdExuZ3MiLCJnZXRMYXRMbmdzIiwiX2xhdGxuZ3MiLCJzZXRMYXRMbmdzIiwiaXNFbXB0eSIsImNsb3Nlc3RMYXllclBvaW50IiwibWluRGlzdGFuY2UiLCJtaW5Qb2ludCIsImNsb3Nlc3QiLCJqTGVuIiwiX3BhcnRzIiwiaGFsZkRpc3QiLCJzZWdEaXN0IiwiZGlzdCIsIl9yaW5ncyIsImFkZExhdExuZyIsIl9kZWZhdWx0U2hhcGUiLCJfY29udmVydExhdExuZ3MiLCJmbGF0IiwiX3Byb2plY3RMYXRsbmdzIiwicHJvamVjdGVkQm91bmRzIiwicmluZyIsIl9jbGlwUG9pbnRzIiwiayIsImxlbjIiLCJzZWdtZW50IiwiX3NpbXBsaWZ5UG9pbnRzIiwiX3VwZGF0ZVBvbHkiLCJjbG9zZWQiLCJwb2x5Z29uIiwiUG9seVV0aWwiLCJQb2x5Z29uIiwiZiIsImFyZWEiLCJjbGlwcGVkIiwiY2xpcFBvbHlnb24iLCJjc3NGcm9tTW9kdWxlcyIsImNzc0Zyb21Nb2R1bGUiLCJjc3NGcm9tVGVtcGxhdGUiLCJjc3NGcm9tTW9kdWxlSW1wb3J0cyIsIl9jc3NGcm9tTW9kdWxlSW1wb3J0cyIsIk1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SIiwiSU5DTFVERV9BVFRSIiwiaW1wb3J0TW9kdWxlIiwibW9kdWxlSWQiLCJQb2x5bWVyRG9tTW9kdWxlIiwidGVtcGxhdGVXaXRoQXNzZXRQYXRoIiwibW9kdWxlSWRzIiwibW9kdWxlcyIsIl9jc3NUZXh0IiwiZSQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW1wb3J0RG9jIiwibGNNb2R1bGVzIiwiZmluZE1vZHVsZSIsInN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2siLCJEb21Nb2R1bGUiLCJfX2Fzc2V0cGF0aCIsIkhUTUxJbXBvcnRzIiwiaW1wb3J0Rm9yRWxlbWVudCIsInN0eWxlSW50ZXJmYWNlIiwiTGVnYWN5RWxlbWVudE1peGluIiwibGVnYWN5RWxlbWVudEJhc2UiLCJESVJFQ1RJT05fTUFQIiwiTGVnYWN5RWxlbWVudCIsImlzQXR0YWNoZWQiLCJfX2JvdW5kTGlzdGVuZXJzIiwiX2RlYm91bmNlcnMiLCJjcmVhdGVkIiwiYXR0YWNoZWQiLCJkZXRhY2hlZCIsImF0dHJpYnV0ZUNoYW5nZWQiLCJfX2hhc1JlZ2lzdGVyRmluaXNoZWQiLCJfcmVnaXN0ZXJlZCIsIl9lbnN1cmVBdHRyaWJ1dGVzIiwiX2FwcGx5TGlzdGVuZXJzIiwiX3NlcmlhbGl6ZVZhbHVlIiwiX2Rlc2VyaWFsaXplVmFsdWUiLCJhdHRyaWJ1dGUiLCJhcGkiLCJuJCIsImdldE93blByb3BlcnR5TmFtZXMiLCJwZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9jb250ZW50Rm9yVGVtcGxhdGUiLCJoYmwiLCJibCIsIl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlIiwiX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZSIsImRpcmVjdGlvbiIsInNsY3RyIiwicXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzIiwiY24iLCJ0YyIsIkNPTU1FTlRfTk9ERSIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJnZXRDb250ZW50Q2hpbGROb2RlcyIsInNob3VsZE9ic2VydmUiLCJqb2JOYW1lIiwid2FpdCIsIndhaXRUaW1lIiwidGFnIiwiZWx0Iiwic2V0UHJvcGVydGllcyIsIm9wdEFzeW5jIiwibG9hZEZuIiwiZXJyb3JGbiIsImJvb2wiLCJoYXNBdHRyaWJ1dGUiLCJ0cmFuc2Zvcm1UZXh0Iiwid2Via2l0VHJhbnNmb3JtIiwiYXJyYXlPclBhdGgiLCJhcnIiLCJsZXZlbCIsIl9sb2dnZXIiLCJEb2N1bWVudEZyYWdtZW50IiwidG9Dc3NUZXh0IiwicnVsZXNGb3JTdHlsZSIsImlzS2V5ZnJhbWVzU2VsZWN0b3IiLCJmb3JFYWNoUnVsZSIsImFwcGx5Q3NzIiwiY3JlYXRlU2NvcGVTdHlsZSIsImFwcGx5U3R5bGVQbGFjZUhvbGRlciIsImFwcGx5U3R5bGUiLCJpc1RhcmdldGVkQnVpbGQiLCJnZXRDc3NCdWlsZFR5cGUiLCJwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayIsInNldEVsZW1lbnRDbGFzc1JhdyIsImdldElzRXh0ZW5kcyIsInJ1bGUiLCJzdHlsZVJ1bGVDYWxsYmFjayIsImtleWZyYW1lc1J1bGVDYWxsYmFjayIsIm9ubHlBY3RpdmVSdWxlcyIsInNraXBSdWxlcyIsIm1hdGNoTWVkaWEiLCJtb25pa2VyIiwiY29udGV4dE5vZGUiLCJsYXN0SGVhZEFwcGx5Tm9kZSIsInBsYWNlSG9sZGVyIiwiY3JlYXRlQ29tbWVudCIsInNjb3BlIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJidWlsZFR5cGUiLCJmaW5kTWF0Y2hpbmdQYXJlbiIsImlubmVyIiwicHJlZml4Iiwic3VmZml4IiwiY29tbWEiLCJmYWxsYmFjayIsInR5cGVFeHRlbnNpb24iLCJleHRlbmRzIiwidGVtcGxhdGVNYXAiLCJkb2N1bWVudFdhaXQiLCJyZWFkeVByb21pc2UiLCJyZXNvbHZlRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWR5U3RhdGUiLCJ0aGVuIiwiQ3VzdG9tU3R5bGVQcm92aWRlciIsIlNFRU5fTUFSS0VSIiwiQ0FDSEVEX1NUWUxFIiwidHJhbnNmb3JtRm4iLCJ2YWxpZGF0ZUZuIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJlbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uIiwiY3VzdG9tU3R5bGUiLCJjcyIsImdldFN0eWxlRm9yQ3VzdG9tU3R5bGUiLCJzdHlsZVRvVHJhbnNmb3JtIiwiYWRkQ3VzdG9tU3R5bGUiLCJwcm9jZXNzU3R5bGVzIiwiZGVmaW5lUHJvcGVydGllcyIsIm5lZWRzRW5xdWV1ZSIsIkN1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlIiwiZ2VzdHVyZXMkMCIsIkdlc3R1cmVFdmVudExpc3RlbmVycyIsImJlZm9yZU5leHRSZW5kZXIiLCJhZnRlck5leHRSZW5kZXIiLCJzY2hlZHVsZWQiLCJiZWZvcmVSZW5kZXJRdWV1ZSIsImFmdGVyUmVuZGVyUXVldWUiLCJzY2hlZHVsZSIsImZsdXNoUXVldWUiLCJydW5RdWV1ZSIsInF1ZXVlIiwiY2FsbE1ldGhvZCIsImlzU2xvdCIsIkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIiLCJyZWR1Y2UiLCJfc2hhZHlDaGlsZHJlbk9ic2VydmVyIiwiX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIiLCJfY29ubmVjdGVkIiwiX3RhcmdldCIsIl9lZmZlY3RpdmVOb2RlcyIsIl9vYnNlcnZlciIsIl9zY2hlZHVsZWQiLCJfYm91bmRTY2hlZHVsZSIsIl9zY2hlZHVsZSIsImNvbm5lY3QiLCJfbGlzdGVuU2xvdHMiLCJvYnNlcnZlQ2hpbGRyZW4iLCJtdXRhdGlvbnMiLCJfcHJvY2Vzc011dGF0aW9ucyIsIl91bmxpc3RlblNsb3RzIiwidW5vYnNlcnZlQ2hpbGRyZW4iLCJfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMiLCJtdXRhdGlvbiIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJ0YWtlUmVjb3JkcyIsIm5ld05vZGVzIiwibmV3U3BsaWNlIiwiRURJVF9MRUFWRSIsIkVESVRfVVBEQVRFIiwiRURJVF9BREQiLCJFRElUX0RFTEVURSIsImNhbGNFZGl0RGlzdGFuY2VzIiwiY3VycmVudCIsImN1cnJlbnRTdGFydCIsImN1cnJlbnRFbmQiLCJvbGRTdGFydCIsIm9sZEVuZCIsInJvd0NvdW50IiwiY29sdW1uQ291bnQiLCJkaXN0YW5jZXMiLCJub3J0aCIsIndlc3QiLCJzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMiLCJlZGl0cyIsIm5vcnRoV2VzdCIsInJldmVyc2UiLCJjYWxjU3BsaWNlcyIsInByZWZpeENvdW50Iiwic3VmZml4Q291bnQiLCJtaW5MZW5ndGgiLCJzaGFyZWRQcmVmaXgiLCJzaGFyZWRTdWZmaXgiLCJvcHMiLCJvbGRJbmRleCIsInNlYXJjaExlbmd0aCIsImluZGV4MSIsImluZGV4MiIsImNvdW50IiwiY2FsY3VsYXRlU3BsaWNlcyIsImN1cnJlbnRWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCIkX2RvY3VtZW50Q29udGFpbmVyIiwiSXJvbkJ1dHRvblN0YXRlSW1wbCIsInRvZ2dsZXMiLCJhY3RpdmUiLCJwb2ludGVyRG93biIsInJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQiLCJhcmlhQWN0aXZlQXR0cmlidXRlIiwiZG93biIsInVwIiwidGFwIiwia2V5QmluZGluZ3MiLCJfbW91c2VFdmVudFJlIiwiX3RhcEhhbmRsZXIiLCJfdXNlckFjdGl2YXRlIiwiX2ZvY3VzQ2hhbmdlZCIsIl9kZXRlY3RLZXlib2FyZEZvY3VzIiwiX3NldFByZXNzZWQiLCJfc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCIsIl9zZXRQb2ludGVyRG93biIsIl91cEhhbmRsZXIiLCJfc3BhY2VLZXlEb3duSGFuZGxlciIsImtleWJvYXJkRXZlbnQiLCJsb2NhbFRhcmdldCIsImlzTGlnaHREZXNjZW5kYW50Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiX3NwYWNlS2V5VXBIYW5kbGVyIiwiX2FzeW5jQ2xpY2siLCJhc3luYyIsIl9wcmVzc2VkQ2hhbmdlZCIsIl9jaGFuZ2VkQnV0dG9uU3RhdGUiLCJfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQiLCJvbGRWYWx1ZSIsIl9hY3RpdmVDaGFuZ2VkIiwiX2NvbnRyb2xTdGF0ZUNoYW5nZWQiLCJkaXNhYmxlZCIsIklyb25CdXR0b25TdGF0ZSIsIktFWV9JREVOVElGSUVSIiwiS0VZX0NPREUiLCJNT0RJRklFUl9LRVlTIiwiS0VZX0NIQVIiLCJJREVOVF9DSEFSIiwiQVJST1dfS0VZIiwiU1BBQ0VfS0VZIiwiRVNDX0tFWSIsInRyYW5zZm9ybUtleSIsIm5vU3BlY2lhbENoYXJzIiwidmFsaWRLZXkiLCJsS2V5IiwidHJhbnNmb3JtS2V5SWRlbnRpZmllciIsImtleUlkZW50IiwiZnJvbUNoYXJDb2RlIiwidHJhbnNmb3JtS2V5Q29kZSIsImtleUNvZGUiLCJub3JtYWxpemVkS2V5Rm9yRXZlbnQiLCJrZXlFdmVudCIsImtleUlkZW50aWZpZXIiLCJrZXlDb21ib01hdGNoZXNFdmVudCIsImtleUNvbWJvIiwiaGFzTW9kaWZpZXJzIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJwYXJzZUtleUNvbWJvU3RyaW5nIiwia2V5Q29tYm9TdHJpbmciLCJjb21ibyIsInBhcnNlZEtleUNvbWJvIiwia2V5Q29tYm9QYXJ0IiwiZXZlbnRQYXJ0cyIsImtleU5hbWUiLCJwYXJzZUV2ZW50U3RyaW5nIiwiZXZlbnRTdHJpbmciLCJJcm9uQTExeUtleXNCZWhhdmlvciIsImtleUV2ZW50VGFyZ2V0Iiwic3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbiIsIl9ib3VuZEtleUhhbmRsZXJzIiwiX2ltcGVyYXRpdmVLZXlCaW5kaW5ncyIsInJlZ2lzdGVyZWQiLCJfcHJlcEtleUJpbmRpbmdzIiwiX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzIiwiX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMiLCJhZGRPd25LZXlCaW5kaW5nIiwiaGFuZGxlck5hbWUiLCJfcmVzZXRLZXlFdmVudExpc3RlbmVycyIsInJlbW92ZU93bktleUJpbmRpbmdzIiwia2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzIiwia2V5Q29tYm9zIiwiX2NvbGxlY3RLZXlCaW5kaW5ncyIsImJlaGF2aW9ycyIsIl9rZXlCaW5kaW5ncyIsIl9hZGRLZXlCaW5kaW5nIiwia2IxIiwia2IyIiwiYjIiLCJrZXlzIiwiYm91bmRLZXlIYW5kbGVyIiwiX29uS2V5QmluZGluZ0V2ZW50Iiwia2V5SGFuZGxlclR1cGxlIiwiX3RyaWdnZXJLZXlIYW5kbGVyIiwiSXJvbkNvbnRyb2xTdGF0ZSIsIl9vbGRUYWJJbmRleCIsIl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIiLCJfZm9jdXNCbHVySGFuZGxlciIsIl9faGFuZGxlRXZlbnRSZXRhcmdldGluZyIsInJlYWR5IiwiX3NldEZvY3VzZWQiLCJfZGlzYWJsZWRDaGFuZ2VkIiwicG9pbnRlckV2ZW50cyIsImJsdXIiLCJfY2hhbmdlZENvbnRyb2xTdGF0ZSIsIkVQU0czODU3IiwiRVBTRzkwMDkxMyIsIlNwaGVyaWNhbE1lcmNhdG9yIiwiTUFYX0xBVElUVURFIiwiYXRhbiIsInN2Z0NyZWF0ZSIsInBvaW50c1RvUGF0aCIsInJpbmdzIiwiYWRkUG9pbnRlckxpc3RlbmVyIiwicmVtb3ZlUG9pbnRlckxpc3RlbmVyIiwiUE9JTlRFUl9ET1dOIiwiUE9JTlRFUl9NT1ZFIiwiUE9JTlRFUl9VUCIsIlBPSU5URVJfQ0FOQ0VMIiwiVEFHX1dISVRFX0xJU1QiLCJfcG9pbnRlcnMiLCJfcG9pbnRlckRvY0xpc3RlbmVyIiwiX3BvaW50ZXJzQ291bnQiLCJfYWRkUG9pbnRlclN0YXJ0IiwiX2FkZFBvaW50ZXJNb3ZlIiwiX2FkZFBvaW50ZXJFbmQiLCJvbkRvd24iLCJwb2ludGVyVHlwZSIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwiX2hhbmRsZVBvaW50ZXIiLCJfZ2xvYmFsUG9pbnRlckRvd24iLCJfZ2xvYmFsUG9pbnRlck1vdmUiLCJfZ2xvYmFsUG9pbnRlclVwIiwicG9pbnRlcklkIiwib25Nb3ZlIiwib25VcCIsIlBvc0FuaW1hdGlvbiIsIl9lbCIsIl9pblByb2dyZXNzIiwiX2R1cmF0aW9uIiwiX2Vhc2VPdXRQb3dlciIsIl9vZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2FuaW1hdGUiLCJfc3RlcCIsIl9jb21wbGV0ZSIsIl9hbmltSWQiLCJfcnVuRnJhbWUiLCJfZWFzZU91dCIsInByb2dyZXNzIiwiSWNvbkRlZmF1bHQiLCJpY29uVXJsIiwiaWNvblJldGluYVVybCIsInNoYWRvd1VybCIsImljb25TaXplIiwic2hhZG93U2l6ZSIsImltYWdlUGF0aCIsIl9kZXRlY3RJY29uUGF0aCIsIkJveFpvb20iLCJEb3VibGVDbGlja1pvb20iLCJEcmFnIiwiS2V5Ym9hcmQiLCJTY3JvbGxXaGVlbFpvb20iLCJUYXAiLCJUb3VjaFpvb20iLCJBdHRyaWJ1dGlvbiIsIl9hdHRyaWJ1dGlvbnMiLCJzZXRQcmVmaXgiLCJhdHRyaWJzIiwicHJlZml4QW5kQXR0cmlicyIsIkxheWVycyIsIlpvb20iLCJTY2FsZSIsIlZpZGVvT3ZlcmxheSIsInZpZGVvT3ZlcmxheSIsIlBvcHVwIiwicG9wdXAiLCJUb29sdGlwIiwidG9vbHRpcCIsImdlb21ldHJ5VG9MYXllciIsImNvb3Jkc1RvTGF0TG5nIiwiY29vcmRzVG9MYXRMbmdzIiwibGF0TG5nVG9Db29yZHMiLCJsYXRMbmdzVG9Db29yZHMiLCJnZXRGZWF0dXJlIiwiYXNGZWF0dXJlIiwiR2VvSlNPTiIsImdlb0pTT04iLCJnZW9Kc29uIiwiZ3JpZExheWVyIiwiR3JpZExheWVyIiwidXBkYXRlV2hlbklkbGUiLCJ1cGRhdGVXaGVuWm9vbWluZyIsInVwZGF0ZUludGVydmFsIiwibWF4TmF0aXZlWm9vbSIsIm1pbk5hdGl2ZVpvb20iLCJub1dyYXAiLCJrZWVwQnVmZmVyIiwiX2xldmVscyIsIl9yZW1vdmVBbGxUaWxlcyIsIl9zZXRBdXRvWkluZGV4IiwiaXNMb2FkaW5nIiwiX2xvYWRpbmciLCJ2aWV3cHJlcmVzZXQiLCJfaW52YWxpZGF0ZUFsbCIsImNvbXBhcmUiLCJlZGdlWkluZGV4IiwiaXNGaW5pdGUiLCJuZXh0RnJhbWUiLCJ3aWxsUHJ1bmUiLCJsb2FkZWQiLCJmYWRlIiwiX29uT3BhcXVlVGlsZSIsIl9ub1BydW5lIiwiX3BydW5lVGlsZXMiLCJfZmFkZUZyYW1lIiwiX3VwZGF0ZUxldmVscyIsIl9vblVwZGF0ZUxldmVsIiwiX3JlbW92ZVRpbGVzQXRab29tIiwiX29uUmVtb3ZlTGV2ZWwiLCJvcmlnaW4iLCJfc2V0Wm9vbVRyYW5zZm9ybSIsIl9vbkNyZWF0ZUxldmVsIiwiX2xldmVsIiwicmV0YWluIiwiX3JldGFpblBhcmVudCIsIl9yZXRhaW5DaGlsZHJlbiIsIl9yZW1vdmVUaWxlIiwieDIiLCJ5MiIsInoyIiwiY29vcmRzMiIsIl90aWxlQ29vcmRzVG9LZXkiLCJhbmltYXRpbmciLCJfc2V0VmlldyIsIl9jbGFtcFpvb20iLCJub1BydW5lIiwidGlsZVpvb20iLCJ0aWxlWm9vbUNoYW5nZWQiLCJfcmVzZXRHcmlkIiwiX3NldFpvb21UcmFuc2Zvcm1zIiwiX3RpbGVTaXplIiwiX3B4Qm91bmRzVG9UaWxlUmFuZ2UiLCJfd3JhcFgiLCJfd3JhcFkiLCJfZ2V0VGlsZWRQaXhlbEJvdW5kcyIsIm1hcFpvb20iLCJwaXhlbENlbnRlciIsImhhbGZTaXplIiwicGl4ZWxCb3VuZHMiLCJ0aWxlUmFuZ2UiLCJ0aWxlQ2VudGVyIiwibm9QcnVuZVJhbmdlIiwiX2lzVmFsaWRUaWxlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiX2FkZFRpbGUiLCJfdGlsZUNvb3Jkc1RvQm91bmRzIiwiX2tleVRvQm91bmRzIiwiX2tleVRvVGlsZUNvb3JkcyIsIm53UG9pbnQiLCJzZVBvaW50IiwiYnAiLCJfaW5pdFRpbGUiLCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkiLCJ0aWxlUG9zIiwiX2dldFRpbGVQb3MiLCJfd3JhcENvb3JkcyIsIl90aWxlUmVhZHkiLCJfbm9UaWxlc1RvTG9hZCIsIm5ld0Nvb3JkcyIsIkNhbnZhcyIsIl9vblZpZXdQcmVSZXNldCIsIl9wb3N0cG9uZVVwZGF0ZVBhdGhzIiwiX2RyYXciLCJfb25Nb3VzZU1vdmUiLCJfb25DbGljayIsIl9oYW5kbGVNb3VzZU91dCIsIl9jdHgiLCJfcmVkcmF3Qm91bmRzIiwiX3JlZHJhdyIsIl9kcmF3bkxheWVycyIsIl91cGRhdGVEYXNoQXJyYXkiLCJvcmRlciIsIl9vcmRlciIsIl9kcmF3TGFzdCIsIl9kcmF3Rmlyc3QiLCJfcmVxdWVzdFJlZHJhdyIsIl9leHRlbmRSZWRyYXdCb3VuZHMiLCJfZGFzaEFycmF5IiwiX3JlZHJhd1JlcXVlc3QiLCJfY2xlYXIiLCJjbGVhclJlY3QiLCJiZWdpblBhdGgiLCJjbGlwIiwiX2RyYXdpbmciLCJyZXN0b3JlIiwiY2xvc2VQYXRoIiwiX2ZpbGxTdHJva2UiLCJhcmMiLCJnbG9iYWxBbHBoYSIsImZpbGxTdHlsZSIsInNldExpbmVEYXNoIiwibGluZVdpZHRoIiwic3Ryb2tlU3R5bGUiLCJjbGlja2VkTGF5ZXIiLCJfZmlyZUV2ZW50IiwibW92aW5nIiwiX2hhbmRsZU1vdXNlSG92ZXIiLCJfaG92ZXJlZExheWVyIiwiY2FuZGlkYXRlSG92ZXJlZExheWVyIiwiY2lyY2xlIiwiQ2lyY2xlIiwibGVnYWN5T3B0aW9ucyIsIl9tUmFkaXVzIiwiaGFsZiIsImxhdFIiLCJsbmdSIiwiYWNvcyIsImNsaXBwZWRQb2ludHMiLCJlZGdlcyIsIl9jb2RlIiwiU1ZHIiwiem9vbXN0YXJ0IiwiX29uWm9vbVN0YXJ0IiwiX3Jvb3RHcm91cCIsIl9zdmdTaXplIiwiX3NldFBhdGgiLCJnZW9qc29uIiwiYWRkRGF0YSIsImZlYXR1cmVzIiwiZmVhdHVyZSIsImdlb21ldHJpZXMiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwiZGVmYXVsdE9wdGlvbnMiLCJyZXNldFN0eWxlIiwib25FYWNoRmVhdHVyZSIsIl9zZXRMYXllclN0eWxlIiwicG9pbnRUb0xheWVyIiwiX2Nvb3Jkc1RvTGF0TG5nIiwibGV2ZWxzRGVlcCIsIm5ld0dlb21ldHJ5IiwiUG9pbnRUb0dlb0pTT04iLCJ0b0dlb0pTT04iLCJtdWx0aSIsImhvbGVzIiwidG9NdWx0aVBvaW50IiwiaXNHZW9tZXRyeUNvbGxlY3Rpb24iLCJqc29ucyIsImpzb24iLCJNZXJjYXRvciIsIlJfTUlOT1IiLCJ0bXAiLCJjb24iLCJ0cyIsInRhbiIsInBoaSIsImRwaGkiLCJ5YW1sIiwicmVxdWlyZSIsIkdHTWFwVmlld2VyIiwiY29uZmlnIiwibWFwVGl0bGUiLCJiYXNlU291cmNlIiwiYmFzZUZvcm1hdCIsInNlbGVjdGVkT3ZlcmxheSIsIndtc0dyb3VwcyIsImdlb2pzb25MYXllcnMiLCJiYXNlTWFwcyIsIm92ZXJsYXlNYXBzIiwic2VhcmNoTWFya2VycyIsIl9tYXJrZXJzR3JvdXAiLCJmZXRjaCIsImluaXRpYWxpemVNYXAiLCJpbml0aWFsaXplU2VhcmNoIiwicmVzcG9uc2UiLCJyanNvbiIsInNhZmVMb2FkIiwiZmxhdHRlbmVkTGF5ZXJzIiwiaW50ZXJhY3Rpb24iLCJ2aXNpYmxlIiwiaGFzaCIsIm1hY2hpbmVOYW1lIiwid21zRGVmYXVsdFNvdXJjZSIsIl9zZWxlY3RlZEJhc2VtYXAiLCJiYXNlTGF5ZXJzIiwib3ZlcmxheVNlbGVjdCIsImpRdWVyeSIsImF1dG9jb21wbGV0ZSIsInByZXZlbnRCYWRRdWVyaWVzIiwiZGVmZXJSZXF1ZXN0QnkiLCJtaW5DaGFycyIsInNlcnZpY2VVcmwiLCJwYXJhbU5hbWUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJhZGRyZXNzZXMiLCJKU09OIiwic3VnZ2VzdGlvbnMiLCJhZGRyZXNzIiwib25TZWFyY2hTdGFydCIsIm9uU2VhcmNoQ29tcGxldGUiLCJxIiwib25TZWxlY3QiLCJjdXJyVmlzaWJsZSIsImV4Y2x1c2l2ZXMiLCJfcGFyc2VMYXllcnMiLCJyZXNldFZpZXdPblNlbGVjdCIsImluaXRpYWxDZW50ZXIiLCJpbml0aWFsWm9vbSIsImJhY2tncm91bmRJbWFnZSIsImxheWVyc01lbnUiLCJ0b2dnbGUiLCJvdmVybGF5Iiwid21zTGF5ZXJzIiwiaWRlbnRpZnkiLCJtYXJrZXJzRGF0YSIsInNlbGVjdGVkIiwibmV3T3ZlcmxheSIsImRlZmF1bHRDbGFzcyIsImRvd25sb2FkVVJMIiwiaHRtbCIsIm1vZGFsIiwibWljcm90YXNrIiwibmF0aXZlUHJvcGVydGllcyIsInNhdmVBY2Nlc3NvclZhbHVlIiwiUHJvcGVydHlBY2Nlc3NvcnMiLCJhJCIsIm9ic2VydmVkQXR0cmlidXRlcyIsIl9fc2VyaWFsaXppbmciLCJfX2RhdGFJbnZhbGlkIiwiX19kYXRhSW5zdGFuY2VQcm9wcyIsIl9pbml0aWFsaXplUHJvcGVydGllcyIsIl9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzIiwib3V0VmFsdWUiLCJjaGFuZ2VkIiwiX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMiLCJfcHJvcGVydGllc0NoYW5nZWQiLCJ0ZW1wbGF0ZUV4dGVuc2lvbnMiLCJ3cmFwVGVtcGxhdGVFeHRlbnNpb24iLCJyZXBsYWNlQ2hpbGQiLCJhdHRyaWJ1dGVzIiwiZmluZFRlbXBsYXRlTm9kZSIsInBhcmVudEluZm8iLCJwYXJlbnRJbmRleCIsImFwcGx5SWRUb01hcCIsImFwcGx5RXZlbnRMaXN0ZW5lciIsImFwcGx5VGVtcGxhdGVDb250ZW50IiwiX3RlbXBsYXRlSW5mbyIsImNyZWF0ZU5vZGVFdmVudEhhbmRsZXIiLCJUZW1wbGF0ZVN0YW1wIiwiZGVjb3JhdGUiLCJfX25vSW5zZXJ0aW9uUG9pbnQiLCJoYXNJbnNlcnRpb25Qb2ludCIsIm91dGVyVGVtcGxhdGVJbmZvIiwic3RyaXBXaGl0ZVNwYWNlIiwiX3BhcnNlVGVtcGxhdGVDb250ZW50IiwiX3BhcnNlVGVtcGxhdGVOb2RlIiwiX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZSIsIl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyIsImhhc0F0dHJpYnV0ZXMiLCJfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzIiwiY2hpbGRJbmZvIiwiaW5mb0luZGV4IiwiYXR0cnMiLCJfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUiLCJob3N0QXR0cmlidXRlcyIsInJvbGUiLCJ0YWJpbmRleCIsInRyYWNrIiwiX29udHJhY2siLCJfdHJhY2tTdGFydCIsIl90cmFja01vdmUiLCJfdHJhY2tFbmQiLCJfd2lkdGgiLCJ0b2dnbGVCYXIiLCJfdHJhY2tDaGVja2VkIiwiY2hlY2tlZCIsInRvZ2dsZUJ1dHRvbiIsIl94IiwidHJhbnNsYXRlM2QiLCJyaXBwbGUiLCJBcHBseVNoaW1VdGlscyIsImFwcGx5U2hpbSIsIkFwcGx5U2hpbUludGVyZmFjZSIsImN1c3RvbVN0eWxlSW50ZXJmYWNlIiwiZW5zdXJlIiwiaW52YWxpZGF0ZSIsInRyYW5zZm9ybUN1c3RvbVN0eWxlIiwiZmx1c2hDdXN0b21TdHlsZXMiLCJlbGVtZW50TmFtZSIsImFzdCIsInRyYW5zZm9ybVRlbXBsYXRlIiwic2hhZG93Q2hpbGRyZW4iLCJ0ZW1wbGF0ZUlzVmFsaWQiLCJ0ZW1wbGF0ZUlzVmFsaWRhdGluZyIsInN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlIiwiYXBwbHlTaGltSW50ZXJmYWNlIiwiZWxlbWVudEV4dGVuZHMiLCJBcHBseVNoaW0iLCJBUFBMWV9OQU1FX0NMRUFOIiwiSU5JVElBTF9JTkhFUklUIiwiTUlYSU5fVkFSX1NFUCIsIlByb3BlcnR5RW50cnkiLCJEZXBlbmRhbnRzRW50cnkiLCJNaXhpbk1hcEVudHJ5IiwiTWl4aW5NYXAiLCJkZXBlbmRhbnRzIiwiaW52YWxpZENhbGxiYWNrIiwiX2N1cnJlbnRFbGVtZW50IiwiX21lYXN1cmVFbGVtZW50IiwidHJhbnNmb3JtU3R5bGUiLCJ0cmFuc2Zvcm1SdWxlcyIsInRyYW5zZm9ybVJ1bGUiLCJ0cmFuc2Zvcm1Dc3NUZXh0IiwibWF0Y2hUZXh0IiwidmFsdWVQcm9wZXJ0eSIsInZhbHVlTWl4aW4iLCJfcHJvZHVjZUNzc1Byb3BlcnRpZXMiLCJfY29uc3VtZUNzc1Byb3BlcnRpZXMiLCJhbGwiLCJtaXhpbk5hbWUiLCJhcHBseVBvcyIsImFmdGVyQXBwbHlQb3MiLCJ0ZXh0QmVmb3JlQXBwbHkiLCJ0ZXh0QWZ0ZXJBcHBseSIsImRlZmF1bHRzIiwiX2Nzc1RleHRUb01hcCIsInJlcGxhY2VtZW50IiwiX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMiLCJmYWxsYmFja3MiLCJ2YXJzIiwibWl4aW5FbnRyeSIsIl9nZXRJbml0aWFsVmFsdWVGb3JQcm9wZXJ0eSIsIm91dCIsInNwIiwiX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0IiwibWl4aW5Bc1Byb3BlcnRpZXMiLCJtaXhpblZhbHVlcyIsImNvbWJpbmVkUHJvcHMiLCJuZWVkVG9JbnZhbGlkYXRlIiwiX2ludmFsaWRhdGVNaXhpbkVudHJ5IiwiaW52YWxpZGF0ZVRlbXBsYXRlIiwiaXNWYWxpZGF0aW5nIiwic3RhcnRWYWxpZGF0aW5nIiwiZWxlbWVudHNBcmVJbnZhbGlkIiwiQ1VSUkVOVF9WRVJTSU9OIiwiTkVYVF9WRVJTSU9OIiwiVkFMSURBVElOR19WRVJTSU9OIiwicHJvbWlzZSIsIl92YWxpZGF0aW5nIiwid2hlbkltcG9ydHNSZWFkeSIsImltcG9ydEhyZWYiLCJyZWwiLCJjbGVhbnVwIiwibG9hZExpc3RlbmVyIiwiZXJyb3JMaXN0ZW5lciIsIl9fZHluYW1pY0ltcG9ydExvYWRlZCIsIm1ldGFQcm9wcyIsImJlZm9yZVJlZ2lzdGVyIiwibWl4aW5CZWhhdmlvcnMiLCJzdXBlckJlaGF2aW9ycyIsImZsYXR0ZW5CZWhhdmlvcnMiLCJfbWl4aW5CZWhhdmlvcnMiLCJHZW5lcmF0ZUNsYXNzRnJvbUluZm8iLCJleGNsdWRlIiwiUG9seW1lckdlbmVyYXRlZCIsIl9lbnN1cmVBdHRyaWJ1dGUiLCJnZW5lcmF0ZWRGcm9tIiwiVGVtcGxhdGl6ZXJVc2VyIiwiVGVtcGxhdGl6ZXIiLCJfdGVtcGxhdGl6ZXJUZW1wbGF0ZSIsImN0b3IiLCJfcGFyZW50TW9kZWwiLCJfaW5zdGFuY2VQcm9wcyIsIl9mb3J3YXJkSG9zdFByb3BWMiIsIl9ub3RpZnlJbnN0YW5jZVByb3BWMiIsImRvbUJpbmRCYXNlIiwiRG9tQmluZCIsIl9fY2hpbGRyZW4iLCJyZW5kZXIiLCJfX3JlbW92ZUNoaWxkcmVuIiwiX19pbnNlcnRDaGlsZHJlbiIsIkRvbUlmIiwiaWYiLCJyZXN0YW1wIiwiX19pbnZhbGlkUHJvcHMiLCJfX2luc3RhbmNlIiwiX2xhc3RJZiIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJfX3RlYXJkb3duSW5zdGFuY2UiLCJfX2Vuc3VyZUluc3RhbmNlIiwiX19zeW5jSG9zdFByb3BlcnRpZXMiLCJwcmV2aW91c1NpYmxpbmciLCJBcnJheVNlbGVjdG9yTWl4aW4iLCJlbGVtZW50QmFzZSIsInNlbGVjdGVkSXRlbSIsIl9fbGFzdEl0ZW1zIiwiX19sYXN0TXVsdGkiLCJfX3NlbGVjdGVkTWFwIiwiaXRlbXNJbmZvIiwibmV3SXRlbXMiLCJsYXN0SXRlbXMiLCJsYXN0TXVsdGkiLCJjbGVhclNlbGVjdGlvbiIsIl9fYXBwbHlTcGxpY2VzIiwiX19kZXNlbGVjdENoYW5nZWRJZHgiLCJfX3VwZGF0ZUxpbmtzIiwic2lkeCIsImRlbGV0ZSIsImxpbmtQYXRocyIsImlzU2VsZWN0ZWQiLCJfX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgiLCJkZXNlbGVjdCIsInNlbGVjdEluZGV4IiwiY2xlYXIiLCJkZXNlbGVjdEluZGV4IiwiYmFzZUFycmF5U2VsZWN0b3IiLCJBcnJheVNlbGVjdG9yIiwiQ3VzdG9tU3R5bGUiLCJfc3R5bGUiLCJNdXRhYmxlRGF0YUJlaGF2aW9yIiwiT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yIiwiUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCIsIl9jaGVja2VkQ2hhbmdlZCIsIlBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciIsIklyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCIsIl9oYXNJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciIsIl9nZXRWYWxpZGl0eSIsIl92YWx1ZSIsInJlcXVpcmVkIiwiX3JlcXVpcmVkQ2hhbmdlZCIsIl92YWx1ZUNoYW5nZWQiLCJJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciIsIklyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSIsIklyb25WYWxpZGF0YWJsZUJlaGF2aW9yIiwidmFsaWRhdG9yIiwiaW52YWxpZCIsIl9pbnZhbGlkQ2hhbmdlZCIsIl92YWxpZGF0b3IiLCJieUtleSIsImhhc1ZhbGlkYXRvciIsInZhbGlkYXRlIiwiSXJvbk1ldGEiLCJtZXRhRGF0YXMiLCJfX21ldGEiLCJfX2NvbXB1dGVNZXRhIiwibWV0YSIsIl9zZWxmQ2hhbmdlZCIsIklyb25Gb3JtRWxlbWVudEJlaGF2aW9yIiwiX3BhcmVudEZvcm0iLCJQYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbCIsIl9mb2N1c2VkQ2hhbmdlZCIsImhvbGREb3duIiwiUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciIsIlV0aWxpdHkiLCJ4MSIsInkxIiwieERlbHRhIiwieURlbHRhIiwiRWxlbWVudE1ldHJpY3MiLCJib3VuZGluZ1JlY3QiLCJmdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbSIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwiUmlwcGxlIiwid2F2ZSIsIndhdmVDb250YWluZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJyZXNldEludGVyYWN0aW9uU3RhdGUiLCJNQVhfUkFESVVTIiwicmVjZW50ZXJzIiwibW91c2VEb3duRWxhcHNlZCIsIm1vdXNlRG93blN0YXJ0IiwibW91c2VVcFN0YXJ0IiwibW91c2VVcEVsYXBzZWQiLCJtb3VzZURvd25FbGFwc2VkU2Vjb25kcyIsIm1vdXNlVXBFbGFwc2VkU2Vjb25kcyIsIm1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzIiwiaW5pdGlhbE9wYWNpdHkiLCJvcGFjaXR5RGVjYXlWZWxvY2l0eSIsIndpZHRoMiIsImNvbnRhaW5lck1ldHJpY3MiLCJoZWlnaHQyIiwid2F2ZVJhZGl1cyIsInRpbWVOb3ciLCJvdXRlck9wYWNpdHkiLCJ3YXZlT3BhY2l0eSIsImlzT3BhY2l0eUZ1bGx5RGVjYXllZCIsIm1heFJhZGl1cyIsImlzUmVzdGluZ0F0TWF4UmFkaXVzIiwiaXNBbmltYXRpb25Db21wbGV0ZSIsInRyYW5zbGF0aW9uRnJhY3Rpb24iLCJ4Tm93IiwieEVuZCIsInhTdGFydCIsInlOb3ciLCJ5RW5kIiwieVN0YXJ0IiwiaXNNb3VzZURvd24iLCJzbGlkZURpc3RhbmNlIiwiZHJhdyIsInRyYW5zbGF0ZVN0cmluZyIsImRvd25BY3Rpb24iLCJ4Q2VudGVyIiwieUNlbnRlciIsInVwQWN0aW9uIiwicmlwcGxlcyIsIl9hbmltYXRpbmciLCJfYm91bmRBbmltYXRlIiwiZ2V0T3duZXJSb290IiwibGlzdGVuIiwidW5saXN0ZW4iLCJzaG91bGRLZWVwQW5pbWF0aW5nIiwic2ltdWxhdGVkUmlwcGxlIiwiYWRkUmlwcGxlIiwidWlVcEFjdGlvbiIsIm9uQW5pbWF0aW9uQ29tcGxldGUiLCJiYWNrZ3JvdW5kIiwid2F2ZXMiLCJfc2V0QW5pbWF0aW5nIiwicmVtb3ZlUmlwcGxlIiwicmlwcGxlSW5kZXgiLCJfb25FbnRlcktleWRvd24iLCJfb25TcGFjZUtleWRvd24iLCJfb25TcGFjZUtleXVwIiwiX2hvbGREb3duQ2hhbmdlZCIsIm5ld1ZhbCIsIm9sZFZhbCIsImFkZERvdWJsZVRhcExpc3RlbmVyIiwicmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIiLCJfdG91Y2hzdGFydCIsIl90b3VjaGVuZCIsIl9wcmUiLCJkb3VibGVUYXAiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoRW5kIiwibmV3VG91Y2giLCJkYmxjbGljayIsIk1hcmtlckRyYWciLCJfbWFya2VyIiwiX2RyYWdnYWJsZSIsImRyYWdzdGFydCIsIl9vbkRyYWdTdGFydCIsInByZWRyYWciLCJfb25QcmVEcmFnIiwiZHJhZyIsIl9vbkRyYWciLCJkcmFnZW5kIiwiX29uRHJhZ0VuZCIsInNwZWVkIiwiaWNvblBvcyIsInBhbkJvdW5kcyIsIm1vdmVtZW50IiwiX3BhblJlcXVlc3QiLCJfb2xkTGF0TG5nIiwiY2xvc2VQb3B1cCIsInNoYWRvdyIsIkxlYWZsZXRNYXAiLCJ6b29tQ29udHJvbCIsImF0dHJpYnV0aW9uUHJlZml4IiwiX2NoaWxkcmVuT2JzZXJ2ZXIiLCJpbmVydGlhRGVjZWxlcmF0aW9uIiwiaW5lcnRpYU1heFNwZWVkIiwidGFwVG9sZXJhbmNlIiwiYXR0ckNvbnRyb2wiLCJzbG90IiwiX2JpbmREZXBlbmRlbmNpZXMiLCJfcGFuZSIsIm92ZXJsYXlQYW5lIiwiX3Jlc2V0U3RhdGVUaW1lb3V0IiwiX2Rlc3Ryb3kiLCJfb25Nb3VzZURvd24iLCJfcmVzZXRTdGF0ZSIsIl9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZSIsImNvbnRleHRtZW51IiwiX29uTW91c2VVcCIsImtleWRvd24iLCJfb25LZXlEb3duIiwiX2JveCIsIl9maW5pc2giLCJib3hab29tQm91bmRzIiwiZG91YmxlQ2xpY2tab29tIiwiX29uRG91YmxlQ2xpY2siLCJpbmVydGlhIiwid29ybGRDb3B5SnVtcCIsIm1heEJvdW5kc1Zpc2Nvc2l0eSIsIl9vblByZURyYWdMaW1pdCIsIl9vblByZURyYWdXcmFwIiwiX3Bvc2l0aW9ucyIsIl90aW1lcyIsIl9vZmZzZXRMaW1pdCIsIl92aXNjb3NpdHkiLCJfbGFzdFRpbWUiLCJfbGFzdFBvcyIsIl9hYnNQb3MiLCJfcHJ1bmVQb3NpdGlvbnMiLCJweENlbnRlciIsInB4V29ybGRDZW50ZXIiLCJfaW5pdGlhbFdvcmxkT2Zmc2V0IiwiX3dvcmxkV2lkdGgiLCJfdmlzY291c0xpbWl0IiwidGhyZXNob2xkIiwid29ybGRXaWR0aCIsImhhbGZXaWR0aCIsIm5ld1gxIiwibmV3WDIiLCJuZXdYIiwibm9JbmVydGlhIiwiZWFzZSIsInNwZWVkVmVjdG9yIiwibGltaXRlZFNwZWVkIiwibGltaXRlZFNwZWVkVmVjdG9yIiwiZGVjZWxlcmF0aW9uRHVyYXRpb24iLCJrZXlib2FyZFBhbkRlbHRhIiwia2V5Q29kZXMiLCJfc2V0UGFuRGVsdGEiLCJfc2V0Wm9vbURlbHRhIiwiX29uRm9jdXMiLCJfb25CbHVyIiwiX2FkZEhvb2tzIiwiX3JlbW92ZUhvb2tzIiwiX2ZvY3VzZWQiLCJkb2NFbCIsInNjcm9sbFRvIiwicGFuRGVsdGEiLCJfcGFuS2V5cyIsImNvZGVzIiwiX3pvb21LZXlzIiwiY2xvc2VPbkVzY2FwZUtleSIsInNjcm9sbFdoZWVsWm9vbSIsIndoZWVsRGVib3VuY2VUaW1lIiwid2hlZWxQeFBlclpvb21MZXZlbCIsIl9vbldoZWVsU2Nyb2xsIiwiX2RlbHRhIiwiX2xhc3RNb3VzZVBvcyIsIl9wZXJmb3JtWm9vbSIsImQyIiwiZDMiLCJkNCIsIl9maXJlQ2xpY2siLCJfaG9sZFRpbWVvdXQiLCJfaXNUYXBWYWxpZCIsIl9zaW11bGF0ZUV2ZW50Iiwic2ltdWxhdGVkRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50IiwidG91Y2hab29tIiwiYm91bmNlQXRab29tTGltaXRzIiwiX29uVG91Y2hTdGFydCIsIl96b29taW5nIiwiX2NlbnRlclBvaW50IiwiX3N0YXJ0TGF0TG5nIiwiX3BpbmNoU3RhcnRMYXRMbmciLCJfc3RhcnREaXN0IiwiX3N0YXJ0Wm9vbSIsIl9vblRvdWNoTW92ZSIsIl9vblRvdWNoRW5kIiwibW92ZUZuIiwiY29sbGFwc2VkIiwiYXV0b1pJbmRleCIsImhpZGVTaW5nbGVCYXNlIiwic29ydExheWVycyIsInNvcnRGdW5jdGlvbiIsImxheWVyQSIsImxheWVyQiIsIm5hbWVBIiwibmFtZUIiLCJvdmVybGF5cyIsIl9sYXllckNvbnRyb2xJbnB1dHMiLCJfbGFzdFpJbmRleCIsIl9oYW5kbGluZ0NsaWNrIiwiX2FkZExheWVyIiwiX2NoZWNrRGlzYWJsZWRMYXllcnMiLCJfb25MYXllckNoYW5nZSIsIl9leHBhbmRJZk5vdENvbGxhcHNlZCIsImFkZEJhc2VMYXllciIsImFkZE92ZXJsYXkiLCJfZ2V0TGF5ZXIiLCJleHBhbmQiLCJfZm9ybSIsImFjY2VwdGFibGVIZWlnaHQiLCJvZmZzZXRUb3AiLCJjb2xsYXBzZSIsImZvcm0iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIl9sYXllcnNMaW5rIiwiX2Jhc2VMYXllcnNMaXN0IiwiX3NlcGFyYXRvciIsIl9vdmVybGF5c0xpc3QiLCJiYXNlTGF5ZXJzUHJlc2VudCIsIm92ZXJsYXlzUHJlc2VudCIsImJhc2VMYXllcnNDb3VudCIsIl9hZGRJdGVtIiwiX2NyZWF0ZVJhZGlvRWxlbWVudCIsInJhZGlvSHRtbCIsInJhZGlvRnJhZ21lbnQiLCJsYWJlbCIsImlucHV0IiwiZGVmYXVsdENoZWNrZWQiLCJsYXllcklkIiwiX29uSW5wdXRDbGljayIsImhvbGRlciIsImlucHV0cyIsImFkZGVkTGF5ZXJzIiwicmVtb3ZlZExheWVycyIsIl9leHBhbmQiLCJfY29sbGFwc2UiLCJ6b29tSW5UZXh0Iiwiem9vbUluVGl0bGUiLCJ6b29tT3V0VGV4dCIsInpvb21PdXRUaXRsZSIsInpvb21OYW1lIiwiX3pvb21JbkJ1dHRvbiIsIl9jcmVhdGVCdXR0b24iLCJfem9vbUluIiwiX3pvb21PdXRCdXR0b24iLCJfem9vbU91dCIsIl91cGRhdGVEaXNhYmxlZCIsIl9kaXNhYmxlZCIsIm1heFdpZHRoIiwibWV0cmljIiwiaW1wZXJpYWwiLCJfYWRkU2NhbGVzIiwiX21TY2FsZSIsIl9pU2NhbGUiLCJtYXhNZXRlcnMiLCJfdXBkYXRlU2NhbGVzIiwiX3VwZGF0ZU1ldHJpYyIsIl91cGRhdGVJbXBlcmlhbCIsIm1ldGVycyIsIl9nZXRSb3VuZE51bSIsIl91cGRhdGVTY2FsZSIsIm1heEZlZXQiLCJtYXhNaWxlcyIsIm1pbGVzIiwiZmVldCIsInBvdzEwIiwiYXV0b3BsYXkiLCJsb29wIiwidmlkIiwib25sb2FkZWRkYXRhIiwic291cmNlRWxlbWVudHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInNvdXJjZXMiLCJ2aWRlbyIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwiYXV0b1BhblBhZGRpbmdUb3BMZWZ0IiwiYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCIsImtlZXBJblZpZXciLCJjbG9zZUJ1dHRvbiIsImF1dG9DbG9zZSIsIm9wZW5PbiIsIm9wZW5Qb3B1cCIsImNsb3NlT25DbGljayIsImNsb3NlUG9wdXBPbkNsaWNrIiwicHJlY2xpY2siLCJfY2xvc2UiLCJ3cmFwcGVyIiwiX3dyYXBwZXIiLCJfdGlwQ29udGFpbmVyIiwiX3RpcCIsIl9jbG9zZUJ1dHRvbiIsIl9vbkNsb3NlQnV0dG9uQ2xpY2siLCJ3aGl0ZVNwYWNlIiwic2Nyb2xsZWRDbGFzcyIsIm1hcmdpbkJvdHRvbSIsImNvbnRhaW5lckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibGF5ZXJQb3MiLCJjb250YWluZXJQb3MiLCJfcG9wdXBIYW5kbGVyc0FkZGVkIiwiX29wZW5Qb3B1cCIsImtleXByZXNzIiwiX29uS2V5UHJlc3MiLCJfbW92ZVBvcHVwIiwidW5iaW5kUG9wdXAiLCJ0b2dnbGVQb3B1cCIsImlzUG9wdXBPcGVuIiwic2V0UG9wdXBDb250ZW50IiwiZ2V0UG9wdXAiLCJwZXJtYW5lbnQiLCJzdGlja3kiLCJjbG9zZVRvb2x0aXAiLCJfc2V0UG9zaXRpb24iLCJ0b29sdGlwUG9pbnQiLCJ0b29sdGlwV2lkdGgiLCJ0b29sdGlwSGVpZ2h0Iiwib3BlblRvb2x0aXAiLCJiaW5kVG9vbHRpcCIsIl90b29sdGlwIiwiX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zIiwidW5iaW5kVG9vbHRpcCIsIl90b29sdGlwSGFuZGxlcnNBZGRlZCIsIl9tb3ZlVG9vbHRpcCIsIl9vcGVuVG9vbHRpcCIsInRvZ2dsZVRvb2x0aXAiLCJpc1Rvb2x0aXBPcGVuIiwic2V0VG9vbHRpcENvbnRlbnQiLCJnZXRUb29sdGlwIiwiRGl2SWNvbiIsImRpdkljb24iLCJEZWZhdWx0IiwiYmdQb3MiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJXTVMiLCJ3bXMiLCJSZWN0YW5nbGUiLCJyZWN0YW5nbGUiLCJfYm91bmRzVG9MYXRMbmdzIiwidm1sQ3JlYXRlIiwibmFtZXNwYWNlcyIsInZtbE1peGluIiwiY29vcmRzaXplIiwiX3N0cm9rZSIsIl9maWxsIiwic3Ryb2tlZCIsImZpbGxlZCIsImRhc2hTdHlsZSIsImVuZGNhcCIsImpvaW5zdHlsZSIsIl9nZXRQYW5lUmVuZGVyZXIiLCJwcmVmZXJDYW52YXMiLCJMZWFmbGV0V01TR3JvdXAiLCJ3bXNTb3VyY2UiLCJzdWJMYXllcnMiLCJfd21zT3B0aW9ucyIsIlNvdXJjZSIsIl9sYXllcnNDaGFuZ2UiLCJuZXdWYWx1ZSIsInJlcGxhY2VBbGxTdWJMYXllcnMiLCJ0aWxlZCIsInVudGlsZWQiLCJfc3ViTGF5ZXJzIiwiX292ZXJsYXkiLCJjcmVhdGVPdmVybGF5Iiwib3ZlcmxheU9wdGlvbnMiLCJyZWZyZXNoT3ZlcmxheSIsImlzQmFjayIsIm5ld1N1YkxheWVycyIsImV2dCIsImdldElkZW50aWZ5TGF5ZXJzIiwiZ2V0RmVhdHVyZUluZm8iLCJzaG93RmVhdHVyZUluZm8iLCJnZXRGZWF0dXJlSW5mb1BhcmFtcyIsInNob3dXYWl0aW5nIiwiYWpheCIsImhpZGVXYWl0aW5nIiwicGFyc2VGZWF0dXJlSW5mbyIsImlkZW50aWZ5TGF5ZXJzIiwidXBkYXRlV21zUGFyYW1zIiwiaW5mb1BhcmFtcyIsImN1cnNvciIsImxheWVyTmFtZSIsImFkZFN1YkxheWVyIiwiZ2V0U291cmNlRm9yVXJsIiwiX25hbWUiLCJyZW1vdmVTdWJMYXllciIsIk92ZXJsYXkiLCJfY3VycmVudE92ZXJsYXkiLCJfY3VycmVudFVybCIsImdldEltYWdlVXJsIiwiX3N3YXAiLCJ3bXNWZXJzaW9uIiwicHN0ciIsIlhNTEh0dHBSZXF1ZXN0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwib3BlbiIsInNlbmQiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJMZWFmbGV0V01TTGF5ZXIiLCJMZWFmbGV0VGlsZUxheWVyIiwibGVhZmxldExheWVyIiwiaGludHMiLCJMZWFmbGV0R2VvSlNPTiIsIm91dGxpbmVDb2xvciIsImNsdXN0ZXIiLCJtYXhDbHVzdGVyUmFkaXVzIiwiX2NsdXN0ZXJHcm91cCIsInNob3dDb3ZlcmFnZU9uSG92ZXIiLCJfY2lyY2xlTWFrZXJPcHRpb25zIiwiX2dlb0pTT05PcHRpb25zIiwiX3BvaW50VG9MYXllciIsIl9nZW9KU09OTGF5ZXIiLCJfZ2VuZXJhdGVQb3B1cENvbnRlbnQiLCJyb3dzIiwiZmllbGROYW1lIiwidHh0IiwiY2hhckF0Iiwic3Vic3RyIiwicmVzIiwiX2FkZEdlb0pTT05MYXllciIsIm5vQ29uZmxpY3QiLCJvbGRMIiwiZXhwb3J0cyIsIlByb2plY3Rpb24iLCJFUFNHMzM5NSIsIlNpbXBsZSIsIk1hcmtlckNsdXN0ZXJHcm91cCIsIk1hcmtlckNsdXN0ZXIiLCJpY29uQ3JlYXRlRnVuY3Rpb24iLCJjbHVzdGVyUGFuZSIsInNwaWRlcmZ5T25NYXhab29tIiwiem9vbVRvQm91bmRzT25DbGljayIsInNpbmdsZU1hcmtlck1vZGUiLCJkaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSIsInJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzIiwiYW5pbWF0ZUFkZGluZ01hcmtlcnMiLCJzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciIsInNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyIsImNodW5rZWRMb2FkaW5nIiwiY2h1bmtJbnRlcnZhbCIsImNodW5rRGVsYXkiLCJjaHVua1Byb2dyZXNzIiwicG9seWdvbk9wdGlvbnMiLCJfZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbiIsIl9mZWF0dXJlR3JvdXAiLCJfbm9uUG9pbnRHcm91cCIsIl9pblpvb21BbmltYXRpb24iLCJfbmVlZHNDbHVzdGVyaW5nIiwiX25lZWRzUmVtb3ZpbmciLCJfY3VycmVudFNob3duQm91bmRzIiwiX3F1ZXVlIiwiX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycyIsIl9jaGlsZE1hcmtlckRyYWdTdGFydCIsIl9jaGlsZE1hcmtlck1vdmVkIiwiX2NoaWxkTWFya2VyRHJhZ0VuZCIsIl93aXRoQW5pbWF0aW9uIiwiX25vQW5pbWF0aW9uIiwiX21hcmtlckNsdXN0ZXIiLCJNYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQiLCJhZGRMYXllcnMiLCJfdW5zcGlkZXJmeSIsIl9tYXhab29tIiwiX3RvcENsdXN0ZXJMZXZlbCIsIl9yZWNhbGN1bGF0ZUJvdW5kcyIsIl9yZWZyZXNoQ2x1c3RlcnNJY29ucyIsInZpc2libGVMYXllciIsImN1cnJlbnRab29tIiwiX19wYXJlbnQiLCJfYW5pbWF0aW9uQWRkTGF5ZXIiLCJfYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZCIsInJlbW92ZUxheWVycyIsIl9hcnJheVNwbGljZSIsIl91bnNwaWRlcmZ5TGF5ZXIiLCJfcmVtb3ZlTGF5ZXIiLCJjbHVzdGVyU2hvdyIsImxheWVyc0FycmF5Iiwic2tpcExheWVyQWRkRXZlbnQiLCJmZyIsIm5wZyIsImNodW5rZWQiLCJvcmlnaW5hbEFycmF5IiwiZ2V0VGltZSIsInByb2Nlc3MiLCJfZXh0cmFjdE5vbkdyb3VwTGF5ZXJzIiwiZ2V0Q2hpbGRDb3VudCIsImdldEFsbENoaWxkTWFya2VycyIsIm90aGVyTWFya2VyIiwiX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcCIsIm5lZWRzQ2x1c3RlcmluZyIsImxheWVyc0FycmF5MiIsImwyIiwiX2dyaWRDbHVzdGVycyIsIl9ncmlkVW5jbHVzdGVyZWQiLCJfbm9hbmltYXRpb25VbnNwaWRlcmZ5IiwiX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzIiwibmVlZHNSZW1vdmluZyIsInRoaXNOZWVkc1JlbW92aW5nIiwiYW5BcnJheSIsIl9ncm91cCIsInpvb21Ub1Nob3dMYXllciIsInNob3dNYXJrZXIiLCJzcGlkZXJmeSIsInpvb21Ub0JvdW5kcyIsIl9tYXhMYXQiLCJuZXdsYXRsbmciLCJfZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzIiwiX3pvb21FbmQiLCJfc3BpZGVyZmllck9uQWRkIiwiX2JpbmRFdmVudHMiLCJfdW5iaW5kRXZlbnRzIiwiX3NwaWRlcmZpZXJPblJlbW92ZSIsIl9oaWRlQ292ZXJhZ2UiLCJnZXRWaXNpYmxlUGFyZW50Iiwidk1hcmtlciIsIl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkIiwiZ3JpZFVuY2x1c3RlcmVkIiwicmVtb3ZlT2JqZWN0IiwiX19kcmFnU3RhcnQiLCJfaWdub3JlTW92ZSIsIl9tb3ZlQ2hpbGQiLCJyZW1vdmVGcm9tRGlzdGFuY2VHcmlkIiwiZG9udFVwZGF0ZU1hcCIsImdyaWRDbHVzdGVycyIsIl9tYXJrZXJzIiwiX2NoaWxkQ291bnQiLCJfYm91bmRzTmVlZFVwZGF0ZSIsIl9jTGF0TG5nIiwiYWRkT2JqZWN0IiwiX2NoaWxkQ2x1c3RlcnMiLCJfaWNvbk5lZWRzVXBkYXRlIiwiX2lzT3JJc1BhcmVudCIsIm9lbCIsImNoaWxkQ291bnQiLCJfem9vbU9yU3BpZGVyZnkiLCJfc2hvd0NvdmVyYWdlIiwiYm90dG9tQ2x1c3RlciIsIl9zaG93blBvbHlnb24iLCJfc3BpZGVyZmllZCIsImdldENvbnZleEh1bGwiLCJfbWVyZ2VTcGxpdENsdXN0ZXJzIiwiX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwIiwicmFkaXVzRm4iLCJEaXN0YW5jZUdyaWQiLCJtYXJrZXJQb2ludCIsIl9vdmVycmlkZU1hcmtlckljb24iLCJnZXROZWFyT2JqZWN0IiwiX2FkZENoaWxkIiwibmV3Q2x1c3RlciIsImxhc3RQYXJlbnQiLCJfdXBkYXRlSWNvbiIsIl9lbnF1ZXVlIiwiX3F1ZXVlVGltZW91dCIsIl9wcm9jZXNzUXVldWUiLCJfYW5pbWF0aW9uU3RhcnQiLCJfYW5pbWF0aW9uWm9vbUluIiwiX2FuaW1hdGlvblpvb21PdXQiLCJfbWFwQm91bmRzSW5maW5pdGUiLCJfY2hlY2tCb3VuZHNNYXhMYXQiLCJtYXhMYXQiLCJfYWRkVG9NYXAiLCJncm91cCIsIm91dHB1dCIsInByZXZpb3VzWm9vbUxldmVsIiwibmV3Wm9vbUxldmVsIiwiX3JlY3Vyc2l2ZWx5Iiwic3RhcnRQb3MiLCJfaXNTaW5nbGVQYXJlbnQiLCJjbHVzdGVySGlkZSIsIl9mb3JjZUxheW91dCIsIl9yZWN1cnNpdmVseUJlY29tZVZpc2libGUiLCJfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMiLCJfYW5pbWF0aW9uRW5kIiwiX2FuaW1hdGlvblpvb21PdXRTaW5nbGUiLCJtZSIsIl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwIiwibWFya2VyQ2x1c3Rlckdyb3VwIiwic3RvcmFnZUFycmF5IiwiZml0Qm91bmRzT3B0aW9ucyIsImNoaWxkQ2x1c3RlcnMiLCJib3VuZHNab29tIiwibmV3Q2x1c3RlcnMiLCJfaWNvbk9iaiIsIm5ldzEiLCJpc05vdGlmaWNhdGlvbkZyb21DaGlsZCIsIl9zZXRDbHVzdGVyQ2VudGVyIiwiY2hpbGQiLCJfcmVzZXRCb3VuZHMiLCJsYXRTdW0iLCJsbmdTdW0iLCJ0b3RhbENvdW50IiwiY2hpbGRMYXRMbmciLCJfd0xhdExuZyIsIl9iYWNrdXBMYXRsbmciLCJfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbiIsImNtIiwibWFwTWluWm9vbSIsInpvb21MZXZlbCIsIm5tIiwiX3Jlc3RvcmVQb3NpdGlvbiIsInByZXZpb3VzQm91bmRzIiwiZXhjZXB0Qm91bmRzIiwiYm91bmRzVG9BcHBseVRvIiwiem9vbUxldmVsVG9TdGFydCIsInpvb21MZXZlbFRvU3RvcCIsInJ1bkF0RXZlcnlMZXZlbCIsInJ1bkF0Qm90dG9tTGV2ZWwiLCJvcGFjaXR5V2hlblVuY2x1c3RlcmVkIiwiY2VsbFNpemUiLCJfY2VsbFNpemUiLCJfc3FDZWxsU2l6ZSIsIl9ncmlkIiwiX29iamVjdFBvaW50IiwiX2dldENvb3JkIiwiZ3JpZCIsInJvdyIsImNlbGwiLCJ1cGRhdGVPYmplY3QiLCJlYWNoT2JqZWN0Iiwib2JqZWN0UG9pbnQiLCJjbG9zZXN0RGlzdFNxIiwiY29vcmQiLCJRdWlja0h1bGwiLCJnZXREaXN0YW50IiwiY3B0IiwidlkiLCJ2WCIsImZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lIiwiYmFzZUxpbmUiLCJsYXRMbmdzIiwibWF4RCIsIm1heFB0IiwicHQiLCJtYXhQb2ludCIsImJ1aWxkQ29udmV4SHVsbCIsImNvbnZleEh1bGxCYXNlTGluZXMiLCJtaW5MYXQiLCJtYXhMbmciLCJtaW5MbmciLCJtYXhMYXRQdCIsIm1pbkxhdFB0IiwibWF4TG5nUHQiLCJtaW5MbmdQdCIsIm1pblB0IiwiY2giLCJjaGlsZE1hcmtlcnMiLCJfMlBJIiwiX2NpcmNsZUZvb3RTZXBhcmF0aW9uIiwiX2NpcmNsZVN0YXJ0QW5nbGUiLCJfc3BpcmFsRm9vdFNlcGFyYXRpb24iLCJfc3BpcmFsTGVuZ3RoU3RhcnQiLCJfc3BpcmFsTGVuZ3RoRmFjdG9yIiwiX2NpcmNsZVNwaXJhbFN3aXRjaG92ZXIiLCJwb3NpdGlvbnMiLCJfZ2VuZXJhdGVQb2ludHNTcGlyYWwiLCJfZ2VuZXJhdGVQb2ludHNDaXJjbGUiLCJfYW5pbWF0aW9uU3BpZGVyZnkiLCJ1bnNwaWRlcmZ5Iiwiem9vbURldGFpbHMiLCJfYW5pbWF0aW9uVW5zcGlkZXJmeSIsImNlbnRlclB0IiwiY2lyY3VtZmVyZW5jZSIsImxlZ0xlbmd0aCIsImFuZ2xlU3RlcCIsImFuZ2xlIiwic2VwYXJhdGlvbiIsImxlbmd0aEZhY3RvciIsIl9wcmVTcGlkZXJmeUxhdGxuZyIsIl9zcGlkZXJMZWciLCJsZWdPcHRpb25zIiwibGVnIiwidGhpc0xheWVyTGF0TG5nIiwidGhpc0xheWVyUG9zIiwiZmluYWxMZWdPcGFjaXR5IiwibGVnUGF0aCIsImdldFRvdGFsTGVuZ3RoIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsIm5vbkFuaW1hdGFibGUiLCJzdGlsbFRoZXJlQ2hpbGRDb3VudCIsIl91bnNwaWRlcmZ5V3JhcHBlciIsIl91bnNwaWRlcmZ5Wm9vbVN0YXJ0IiwiX3Vuc3BpZGVyZnlab29tQW5pbSIsInJlZnJlc2hDbHVzdGVycyIsIl9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZSIsIl9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnMiLCJyZWZyZXNoSWNvbk9wdGlvbnMiLCJkaXJlY3RseVJlZnJlc2hDbHVzdGVycyIsImdsb2JhbCIsImpzeWFtbCIsIlR5cGUiLCJTY2hlbWEiLCJGQUlMU0FGRV9TQ0hFTUEiLCJKU09OX1NDSEVNQSIsIkNPUkVfU0NIRU1BIiwiREVGQVVMVF9TQUZFX1NDSEVNQSIsIkRFRkFVTFRfRlVMTF9TQ0hFTUEiLCJsb2FkIiwibG9hZEFsbCIsInNhZmVMb2FkQWxsIiwiZHVtcCIsInNhZmVEdW1wIiwiWUFNTEV4Y2VwdGlvbiIsIk1JTklNQUxfU0NIRU1BIiwiU0FGRV9TQ0hFTUEiLCJERUZBVUxUX1NDSEVNQSIsInNjYW4iLCJjb21wb3NlIiwiYWRkQ29uc3RydWN0b3IiLCJpc05vdGhpbmciLCJ0b0FycmF5IiwiaXNOZWdhdGl2ZVplcm8iLCJORUdBVElWRV9JTkZJTklUWSIsImNvbXBpbGVkVHlwZU1hcCIsIlQiLCJzdHlsZUFsaWFzZXMiLCJFIiwic2NoZW1hIiwiXyIsImluZGVudCIsInNraXBJbnZhbGlkIiwiZmxvd0xldmVsIiwic3R5bGVNYXAiLCJzb3J0S2V5cyIsIm5vUmVmcyIsIm5vQ29tcGF0TW9kZSIsImNvbmRlbnNlRmxvdyIsImltcGxpY2l0VHlwZXMiLCJjb21waWxlZEltcGxpY2l0IiwiZXhwbGljaXRUeXBlcyIsImNvbXBpbGVkRXhwbGljaXQiLCJkdXBsaWNhdGVzIiwidXNlZER1cGxpY2F0ZXMiLCJVIiwiSiIsIlEiLCJlZSIsIkciLCJIIiwiWiIsIlciLCJLIiwidGUiLCJWIiwiQiIsIlkiLCJQIiwiWCIsImgiLCJjaGFyQ29kZUF0IiwidWUiLCJEIiwiY2UiLCJvZSIsImFlIiwicmUiLCJnIiwiQSIsIkMiLCJpbnN0YW5jZU9mIiwicHJlZGljYXRlIiwicmVwcmVzZW50IiwiZGVmYXVsdFN0eWxlIiwiTSIsIkkiLCJPIiwiTiIsInJlYXNvbiIsIm1hcmsiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImZpbGVuYW1lIiwib25XYXJuaW5nIiwibGVnYWN5IiwibGlzdGVuZXIiLCJ0eXBlTWFwIiwibGluZSIsImxpbmVTdGFydCIsImxpbmVJbmRlbnQiLCJkb2N1bWVudHMiLCJhbmNob3JNYXAiLCJ0YWdNYXAiLCJjb25zdHJ1Y3QiLCJjaGVja0xpbmVCcmVha3MiLCJZQU1MIiwiVEFHIiwiYnVmZmVyIiwiY29sdW1uIiwiZ2V0U25pcHBldCIsInNjYWxhciIsInNlcXVlbmNlIiwibWFwcGluZyIsImltcGxpY2l0IiwiZXhwbGljaXQiLCJsb2FkS2luZCIsIkRFRkFVTFQiLCJldmVyeSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwibG93ZXJjYXNlIiwiY2FtZWxjYXNlIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJiaW5hcnkiLCJvY3RhbCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsImVzcHJpbWEiLCJtdWx0aWxpbmUiLCJpZ25vcmVDYXNlIiwiY2Fub25pY2FsIiwiVVRDIiwic2V0VGltZSIsInRvSVNPU3RyaW5nIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7UUNsRGdCQSxNLEdBQUFBLE07UUF5QkFDLEksR0FBQUEsSTtRQW9CQUMsSyxHQUFBQSxLO1FBY0FDLFEsR0FBQUEsUTtRQWdDQUMsTyxHQUFBQSxPO1FBU0FDLE8sR0FBQUEsTztRQUlBQyxTLEdBQUFBLFM7UUFPQUMsSSxHQUFBQSxJO1FBTUFDLFUsR0FBQUEsVTtRQU1BQyxVLEdBQUFBLFU7UUFlQUMs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QWFrUCxDQUFiLEVBQWV3TSxDQUFmLEVBQWlCMkMsQ0FBakIsRUFBbUIxQyxDQUFuQixFQUFxQm1ULENBQXJCLENBQVQsQ0FBNUQsRUFBOEYwbUMsS0FBRzdrQyxFQUFFc3ZGLE9BQUYsQ0FBVXR2RixFQUFFODZFLE9BQUYsS0FBWWoyQyxDQUF0QixDQUFqRyxFQUEwSDdrQyxDQUFqSTtBQUFtSSxTQUEzZixFQUE0Zm1zRixZQUFXOTRHLElBQXZnQixFQUE0Z0JnNUcsV0FBVSxtQkFBUzkwRyxDQUFULEVBQVc7QUFBQyxpQkFBT0EsRUFBRWc0RyxXQUFGLEVBQVA7QUFBdUIsU0FBempCLEVBQXBDLENBQVY7QUFBMG1CLEtBQS81QixFQUFnNkIsRUFBQyxXQUFVLEVBQVgsRUFBaDZCLENBQXYzdUMsRUFBdXl3QyxLQUFJLENBQUMsVUFBU2g0RyxDQUFULEVBQVcyVCxDQUFYLEVBQWFULENBQWIsRUFBZTtBQUFDO0FBQWEsVUFBSXBiLElBQUVrSSxFQUFFLGtCQUFGLENBQU4sQ0FBNEIyVCxFQUFFaXNGLE9BQUYsR0FBVTluRyxDQUFWO0FBQVksS0FBdEUsRUFBdUUsRUFBQyxvQkFBbUIsQ0FBcEIsRUFBdkUsQ0FBM3l3QyxFQUFwYixFQUErenhDLEVBQS96eEMsRUFBazB4QyxFQUFsMHhDLEVBQXMweEMsR0FBdDB4QyxDQUFQO0FBQWsxeEMsQ0FBMW15QyxDQUFELEMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gOTApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDg0N2FkMzgxNWUzNTU3YmRjYmE5IiwiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgZnJlZXplID0gT2JqZWN0LmZyZWV6ZTtcclxuT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iajsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrbGFzdElkO1xyXG5cdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgZGlnaXRzPzogTnVtYmVyKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHRvIGBkaWdpdHNgIGRlY2ltYWxzLCBvciB0byA2IGRlY2ltYWxzIGJ5IGRlZmF1bHQuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW0obnVtLCBkaWdpdHMpIHtcclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIChkaWdpdHMgPT09IHVuZGVmaW5lZCA/IDYgOiBkaWdpdHMpKTtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdHJpbShzdHI6IFN0cmluZyk6IFN0cmluZ1xyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW0oc3RyKSB7XHJcblx0cmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzcGxpdFdvcmRzKHN0cjogU3RyaW5nKTogU3RyaW5nW11cclxuLy8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHIpIHtcclxuXHRyZXR1cm4gdHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcHRpb25zKG9iajogT2JqZWN0LCBvcHRpb25zOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBnaXZlbiBwcm9wZXJ0aWVzIHRvIHRoZSBgb3B0aW9uc2Agb2YgdGhlIGBvYmpgIG9iamVjdCwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgb3B0aW9ucy4gU2VlIGBDbGFzcyBvcHRpb25zYC4gSGFzIGFuIGBMLnNldE9wdGlvbnNgIHNob3J0Y3V0LlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcclxuXHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfLV0rKSAqXFx9L2c7XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVtcGxhdGUoc3RyOiBTdHJpbmcsIGRhdGE6IE9iamVjdCk6IFN0cmluZ1xyXG4vLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuLy8gYW5kIGEgZGF0YSBvYmplY3QgbGlrZSBge2E6ICdmb28nLCBiOiAnYmFyJ31gLCByZXR1cm5zIGV2YWx1YXRlZCBzdHJpbmdcclxuLy8gYCgnSGVsbG8gZm9vLCBiYXInKWAuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgZm9yXHJcbi8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKHRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0dmFyIHZhbHVlID0gZGF0YVtrZXldO1xyXG5cclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUoZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW0FycmF5LmlzQXJyYXldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXkpXHJcbmV4cG9ydCB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGluZGV4T2YoYXJyYXk6IEFycmF5LCBlbDogT2JqZWN0KTogTnVtYmVyXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsKSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKGFycmF5W2ldID09PSBlbCkgeyByZXR1cm4gaTsgfVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBlbXB0eUltYWdlVXJsOiBTdHJpbmdcclxuLy8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcbi8vIFVzZWQgYXMgYSBoYWNrIHRvIGZyZWUgbWVtb3J5IGZyb20gdW51c2VkIGltYWdlcyBvbiBXZWJLaXQtcG93ZXJlZFxyXG4vLyBtb2JpbGUgZGV2aWNlcyAoYnkgc2V0dGluZyBpbWFnZSBgc3JjYCB0byB0aGlzIHN0cmluZykuXHJcbmV4cG9ydCB2YXIgZW1wdHlJbWFnZVVybCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9JztcclxuXHJcbi8vIGluc3BpcmVkIGJ5IGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcblxyXG5mdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0cmV0dXJuIHdpbmRvd1snd2Via2l0JyArIG5hbWVdIHx8IHdpbmRvd1snbW96JyArIG5hbWVdIHx8IHdpbmRvd1snbXMnICsgbmFtZV07XHJcbn1cclxuXHJcbnZhciBsYXN0VGltZSA9IDA7XHJcblxyXG4vLyBmYWxsYmFjayBmb3IgSUUgNy04XHJcbmZ1bmN0aW9uIHRpbWVvdXREZWZlcihmbikge1xyXG5cdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0ICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lIC0gbGFzdFRpbWUpKTtcclxuXHJcblx0bGFzdFRpbWUgPSB0aW1lICsgdGltZVRvQ2FsbDtcclxuXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcjtcclxuZXhwb3J0IHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdFx0Z2V0UHJlZml4ZWQoJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IGZ1bmN0aW9uIChpZCkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTsgfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCwgaW1tZWRpYXRlPzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBTY2hlZHVsZXMgYGZuYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBicm93c2VyIHJlcGFpbnRzLiBgZm5gIGlzIGJvdW5kIHRvXHJcbi8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcbi8vIHRoZSBicm93c2VyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3JcclxuLy8gW2B3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLFxyXG4vLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSkge1xyXG5cdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoaWQ6IE51bWJlcik6IHVuZGVmaW5lZFxyXG4vLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZCkge1xyXG5cdGlmIChpZCkge1xyXG5cdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHR9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL1V0aWwuanMiLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tVXRpbFxyXG4gKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggdGhlIFtET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudF9PYmplY3RfTW9kZWwpXHJcbiAqIHRyZWUsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBNb3N0IGZ1bmN0aW9ucyBleHBlY3Rpbmcgb3IgcmV0dXJuaW5nIGEgYEhUTUxFbGVtZW50YCBhbHNvIHdvcmsgZm9yXHJcbiAqIFNWRyBlbGVtZW50cy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IGNsYXNzZXMgcmVmZXIgdG8gQ1NTIGNsYXNzZXNcclxuICogaW4gSFRNTCBhbmQgU1ZHIGNsYXNzZXMgaW4gU1ZHLlxyXG4gKi9cclxuXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zZm9ybSBzdHlsZSBuYW1lIChlLmcuIGAnd2Via2l0VHJhbnNmb3JtJ2AgZm9yIFdlYktpdCkuXHJcbmV4cG9ydCB2YXIgVFJBTlNGT1JNID0gdGVzdFByb3AoXHJcblx0Wyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ10pO1xyXG5cclxuLy8gd2Via2l0VHJhbnNpdGlvbiBjb21lcyBmaXJzdCBiZWNhdXNlIHNvbWUgYnJvd3NlciB2ZXJzaW9ucyB0aGF0IGRyb3AgdmVuZG9yIHByZWZpeCBkb24ndCBkb1xyXG4vLyB0aGUgc2FtZSBmb3IgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQsIGluIHBhcnRpY3VsYXIgdGhlIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcclxuXHJcbi8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb24gc3R5bGUgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OID0gdGVzdFByb3AoXHJcblx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTl9FTkQ6IFN0cmluZ1xyXG4vLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNpdGlvbmVuZCBldmVudCBuYW1lLlxyXG5leHBvcnQgdmFyIFRSQU5TSVRJT05fRU5EID1cclxuXHRUUkFOU0lUSU9OID09PSAnd2Via2l0VHJhbnNpdGlvbicgfHwgVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/IFRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBSZXR1cm5zIGFuIGVsZW1lbnQgZ2l2ZW4gaXRzIERPTSBpZCwgb3IgcmV0dXJucyB0aGUgZWxlbWVudCBpdHNlbGZcclxuLy8gaWYgaXQgd2FzIHBhc3NlZCBkaXJlY3RseS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldChpZCkge1xyXG5cdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRTdHlsZShlbDogSFRNTEVsZW1lbnQsIHN0eWxlQXR0cmliOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgdmFsdWUgZm9yIGEgY2VydGFpbiBzdHlsZSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudCxcclxuLy8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIHN0eWxlKSB7XHJcblx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG5cdGlmICgoIXZhbHVlIHx8IHZhbHVlID09PSAnYXV0bycpICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XHJcblx0XHR2YXIgY3NzID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XHJcblx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gdmFsdWUgPT09ICdhdXRvJyA/IG51bGwgOiB2YWx1ZTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lOiBTdHJpbmcsIGNsYXNzTmFtZT86IFN0cmluZywgY29udGFpbmVyPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG4vLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0ZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8ICcnO1xyXG5cclxuXHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdH1cclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShlbCkge1xyXG5cdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdGlmIChwYXJlbnQpIHtcclxuXHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZW1wdHkoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbCkge1xyXG5cdHdoaWxlIChlbC5maXJzdENoaWxkKSB7XHJcblx0XHRlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0Zyb250KGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgbGFzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGluIGZyb250IG9mIHRoZSBvdGhlciBjaGlsZHJlbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRnJvbnQoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50Lmxhc3RDaGlsZCAhPT0gZWwpIHtcclxuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuLy8gTWFrZXMgYGVsYCB0aGUgZmlyc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBiZWhpbmQgdGhlIG90aGVyIGNoaWxkcmVuLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9CYWNrKGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHZhciBjbGFzc2VzID0gVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHNldENsYXNzKGVsLCBVdGlsLnRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuXHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3BhY2l0eShlbDogSFRNTEVsZW1lbnQsIG9wYWNpdHk6IE51bWJlcilcclxuLy8gU2V0IHRoZSBvcGFjaXR5IG9mIGFuIGVsZW1lbnQgKGluY2x1ZGluZyBvbGQgSUUgc3VwcG9ydCkuXHJcbi8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wYWNpdHkoZWwsIHZhbHVlKSB7XHJcblx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0ZWwuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xyXG5cdH0gZWxzZSBpZiAoJ2ZpbHRlcicgaW4gZWwuc3R5bGUpIHtcclxuXHRcdF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRPcGFjaXR5SUUoZWwsIHZhbHVlKSB7XHJcblx0dmFyIGZpbHRlciA9IGZhbHNlLFxyXG5cdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0Ly8gZmlsdGVycyBjb2xsZWN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB3ZSB0cnkgdG8gcmV0cmlldmUgYSBmaWx0ZXIgdGhhdCBkb2Vzbid0IGV4aXN0XHJcblx0dHJ5IHtcclxuXHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHQvLyBkb24ndCBzZXQgb3BhY2l0eSB0byAxIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBzZXQgYW4gb3BhY2l0eSxcclxuXHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRpZiAodmFsdWUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblx0fVxyXG5cclxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRpZiAoZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIuRW5hYmxlZCA9ICh2YWx1ZSAhPT0gMTAwKTtcclxuXHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmZpbHRlciArPSAnIHByb2dpZDonICsgZmlsdGVyTmFtZSArICcob3BhY2l0eT0nICsgdmFsdWUgKyAnKSc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGVzdFByb3AocHJvcHM6IFN0cmluZ1tdKTogU3RyaW5nfGZhbHNlXHJcbi8vIEdvZXMgdGhyb3VnaCB0aGUgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IG5hbWVcclxuLy8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuLy8gaXQgcmV0dXJucyBmYWxzZS4gVXNlZnVsIGZvciB2ZW5kb3ItcHJlZml4ZWQgc3R5bGVzIGxpa2UgYHRyYW5zZm9ybWAuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wcykge1xyXG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdHJldHVybiBwcm9wc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsOiBIVE1MRWxlbWVudCwgb2Zmc2V0OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpXHJcbi8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcbi8vIGFuZCBvcHRpb25hbGx5IHNjYWxlZCBieSBgc2NhbGVgLiBEb2VzIG5vdCBoYXZlIGFuIGVmZmVjdCBpZiB0aGVcclxuLy8gYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgM0QgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWwsIG9mZnNldCwgc2NhbGUpIHtcclxuXHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHJcblx0ZWwuc3R5bGVbVFJBTlNGT1JNXSA9XHJcblx0XHQoQnJvd3Nlci5pZTNkID9cclxuXHRcdFx0J3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScgOlxyXG5cdFx0XHQndHJhbnNsYXRlM2QoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCwwKScpICtcclxuXHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogUG9pbnQpXHJcbi8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGBlbGAgdG8gY29vcmRpbmF0ZXMgc3BlY2lmaWVkIGJ5IGBwb3NpdGlvbmAsXHJcbi8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcbi8vICh1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseSB0byBwb3NpdGlvbiBpdHMgbGF5ZXJzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFBvc2l0aW9uKGVsLCBwb2ludCkge1xyXG5cclxuXHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0ZWwuX2xlYWZsZXRfcG9zID0gcG9pbnQ7XHJcblx0LyogZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRpZiAoQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0c2V0VHJhbnNmb3JtKGVsLCBwb2ludCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsLnN0eWxlLmxlZnQgPSBwb2ludC54ICsgJ3B4JztcclxuXHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsOiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIGFuIGVsZW1lbnQgcHJldmlvdXNseSBwb3NpdGlvbmVkIHdpdGggc2V0UG9zaXRpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdC8vIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSB0aGUgcG9zaXRpb24gZm9yIHBlcmZvcm1hbmNlXHJcblxyXG5cdHJldHVybiBlbC5fbGVhZmxldF9wb3MgfHwgbmV3IFBvaW50KDAsIDApO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBQcmV2ZW50cyB0aGUgdXNlciBmcm9tIGdlbmVyYXRpbmcgYHNlbGVjdHN0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZFxyXG4vLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZSB0aHJvdWdoIGEgcGFnZSB3aXRoIHRleHQuIFVzZWQgaW50ZXJuYWxseVxyXG4vLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcbi8vIHRoZSBtYXAuIEFmZmVjdHMgZHJhZyBpbnRlcmFjdGlvbnMgb24gdGhlIHdob2xlIGRvY3VtZW50LlxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZVRleHRTZWxlY3Rpb24oKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcbmV4cG9ydCB2YXIgZGlzYWJsZVRleHRTZWxlY3Rpb247XHJcbmV4cG9ydCB2YXIgZW5hYmxlVGV4dFNlbGVjdGlvbjtcclxudmFyIF91c2VyU2VsZWN0O1xyXG5pZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vbih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cdGVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21FdmVudC5vZmYod2luZG93LCAnc2VsZWN0c3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0fTtcclxufSBlbHNlIHtcclxuXHR2YXIgdXNlclNlbGVjdFByb3BlcnR5ID0gdGVzdFByb3AoXHJcblx0XHRbJ3VzZXJTZWxlY3QnLCAnV2Via2l0VXNlclNlbGVjdCcsICdPVXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKTtcclxuXHJcblx0ZGlzYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gJ25vbmUnO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSBfdXNlclNlbGVjdDtcclxuXHRcdFx0X3VzZXJTZWxlY3QgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVJbWFnZURyYWcoKVxyXG4vLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcbi8vIGZvciBgZHJhZ3N0YXJ0YCBET00gZXZlbnRzLCB1c3VhbGx5IGdlbmVyYXRlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGFuIGltYWdlLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vbih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG4vLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZ2BdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpIHtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAnZHJhZ3N0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG59XHJcblxyXG52YXIgX291dGxpbmVFbGVtZW50LCBfb3V0bGluZVN0eWxlO1xyXG4vLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyB0aGUgW291dGxpbmVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0NTUy9vdXRsaW5lKVxyXG4vLyBvZiB0aGUgZWxlbWVudCBgZWxgIGludmlzaWJsZS4gVXNlZCBpbnRlcm5hbGx5IGJ5IExlYWZsZXQgdG8gcHJldmVudFxyXG4vLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcbi8vIGRyYWcgaW50ZXJhY3Rpb24gb24gdGhlbS5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnRPdXRsaW5lKGVsZW1lbnQpIHtcclxuXHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdGlmICghZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRyZXN0b3JlT3V0bGluZSgpO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0X291dGxpbmVTdHlsZSA9IGVsZW1lbnQuc3R5bGUub3V0bGluZTtcclxuXHRlbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lID0gX291dGxpbmVTdHlsZTtcclxuXHRfb3V0bGluZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcblx0X291dGxpbmVTdHlsZSA9IHVuZGVmaW5lZDtcclxuXHREb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21VdGlsLmpzIiwid2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCBvYmopIHsgcmV0dXJuIHByb3A7IH1cblxuLyoqIEBuYW1lc3BhY2UgKi9cbmxldCBQb2x5bWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9ib290LmpzIiwiaW1wb3J0IHtpc0FycmF5LCBmb3JtYXROdW19IGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9pbnRcclxuICogQGFrYSBMLlBvaW50XHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBwb2ludCB3aXRoIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGluIHBpeGVscy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHBvaW50ID0gTC5wb2ludCgyMDAsIDMwMCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIGFuZCBvcHRpb25zIHRoYXQgYWNjZXB0IGBQb2ludGAgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGVzZSBsaW5lcyBhcmUgZXF1aXZhbGVudDpcclxuICpcclxuICogYGBganNcclxuICogbWFwLnBhbkJ5KFsyMDAsIDMwMF0pO1xyXG4gKiBtYXAucGFuQnkoTC5wb2ludCgyMDAsIDMwMCkpO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBQb2ludGAgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFBvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0Ly8gQHByb3BlcnR5IHg6IE51bWJlcjsgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludFxyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHQvLyBAcHJvcGVydHkgeTogTnVtYmVyOyBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59XHJcblxyXG52YXIgdHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh2KSB7XHJcblx0cmV0dXJuIHYgPiAwID8gTWF0aC5mbG9vcih2KSA6IE1hdGguY2VpbCh2KTtcclxufTtcclxuXHJcblBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGl0aW9uIG9mIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBub24tZGVzdHJ1Y3RpdmUsIHJldHVybnMgYSBuZXcgcG9pbnRcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2FkZCh0b1BvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X2FkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHQvLyBkZXN0cnVjdGl2ZSwgdXNlZCBkaXJlY3RseSBmb3IgcGVyZm9ybWFuY2UgaW4gc2l0dWF0aW9ucyB3aGVyZSBpdCdzIHNhZmUgdG8gbW9kaWZ5IGV4aXN0aW5nIHBvaW50XHJcblx0XHR0aGlzLnggKz0gcG9pbnQueDtcclxuXHRcdHRoaXMueSArPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzdWJ0cmFjdChvdGhlclBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW9uIG9mIHRoZSBnaXZlbiBwb2ludCBmcm9tIHRoZSBjdXJyZW50LlxyXG5cdHN1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3N1YnRyYWN0KHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dGhpcy54IC09IHBvaW50Lng7XHJcblx0XHR0aGlzLnkgLT0gcG9pbnQueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGl2aWRlQnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdGRpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXZpZGVCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9kaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54IC89IG51bTtcclxuXHRcdHRoaXMueSAvPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG11bHRpcGx5QnkobnVtOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvbiBvZiB0aGUgY3VycmVudCBwb2ludCBieSB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG5cdG11bHRpcGx5Qnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfbXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0dGhpcy54ICo9IG51bTtcclxuXHRcdHRoaXMueSAqPSBudW07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBNdWx0aXBseSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnkgZWFjaCBjb29yZGluYXRlIG9mXHJcblx0Ly8gYHNjYWxlYC4gSW4gbGluZWFyIGFsZ2VicmEgdGVybXMsIG11bHRpcGx5IHRoZSBwb2ludCBieSB0aGVcclxuXHQvLyBbc2NhbGluZyBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjYWxpbmdfJTI4Z2VvbWV0cnklMjkjTWF0cml4X3JlcHJlc2VudGF0aW9uKVxyXG5cdC8vIGRlZmluZWQgYnkgYHNjYWxlYC5cclxuXHRzY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogcG9pbnQueCwgdGhpcy55ICogcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnNjYWxlQnkoc2NhbGU6IFBvaW50KTogUG9pbnRcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZUJ5YC4gRGl2aWRlIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieVxyXG5cdC8vIGVhY2ggY29vcmRpbmF0ZSBvZiBgc2NhbGVgLlxyXG5cdHVuc2NhbGVCeTogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdHJ1bmMoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHRydW5jYXRlZCBjb29yZGluYXRlcyAocm91bmRlZCB0b3dhcmRzIHplcm8pLlxyXG5cdHRydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl90cnVuYygpO1xyXG5cdH0sXHJcblxyXG5cdF90cnVuYzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gdHJ1bmModGhpcy54KTtcclxuXHRcdHRoaXMueSA9IHRydW5jKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJQb2ludDogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjYXJ0ZXNpYW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIGdpdmVuIHBvaW50cy5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBvaW50IGhhcyB0aGUgc2FtZSBjb29yZGluYXRlcy5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA9PT0gdGhpcy54ICYmXHJcblx0XHQgICAgICAgcG9pbnQueSA9PT0gdGhpcy55O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJQb2ludDogUG9pbnQpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gcG9pbnQgYXJlIGxlc3MgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBjdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzIChpbiBhYnNvbHV0ZSB2YWx1ZXMpLlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHBvaW50LngpIDw9IE1hdGguYWJzKHRoaXMueCkgJiZcclxuXHRcdCAgICAgICBNYXRoLmFicyhwb2ludC55KSA8PSBNYXRoLmFicyh0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgZm9ybWF0TnVtKHRoaXMueSkgKyAnKSc7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQGZhY3RvcnkgTC5wb2ludCh4OiBOdW1iZXIsIHk6IE51bWJlciwgcm91bmQ/OiBCb29sZWFuKVxyXG4vLyBDcmVhdGVzIGEgUG9pbnQgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzLiBJZiBvcHRpb25hbCBgcm91bmRgIGlzIHNldCB0byB0cnVlLCByb3VuZHMgdGhlIGB4YCBhbmQgYHlgIHZhbHVlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogTnVtYmVyW10pXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5XWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KGNvb3JkczogT2JqZWN0KVxyXG4vLyBFeHBlY3RzIGEgcGxhaW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eDogTnVtYmVyLCB5OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Qb2ludCh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgUG9pbnQpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4WzBdLCB4WzFdKTtcclxuXHR9XHJcblx0aWYgKHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiAneCcgaW4geCAmJiAneScgaW4geCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh4LngsIHgueSk7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvUG9pbnQuanMiLCJpbXBvcnQge3N2Z0NyZWF0ZX0gZnJvbSAnLi4vbGF5ZXIvdmVjdG9yL1NWRy5VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQnJvd3NlclxyXG4gKiBAYWthIEwuQnJvd3NlclxyXG4gKlxyXG4gKiBBIG5hbWVzcGFjZSB3aXRoIHN0YXRpYyBwcm9wZXJ0aWVzIGZvciBicm93c2VyL2ZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcbiAqICAgYWxlcnQoJ1VwZ3JhZGUgeW91ciBicm93c2VyLCBkdWRlIScpO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbnZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuZXhwb3J0IHZhciBpZSA9ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3c7XHJcblxyXG4vLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW47IGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcbmV4cG9ydCB2YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG5leHBvcnQgdmFyIGVkZ2UgPSAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQ6IEJvb2xlYW47XHJcbi8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIGxpa2UgQ2hyb21lIGFuZCBTYWZhcmkgKGluY2x1ZGluZyBtb2JpbGUgdmVyc2lvbnMpLlxyXG5leHBvcnQgdmFyIHdlYmtpdCA9IHVzZXJBZ2VudENvbnRhaW5zKCd3ZWJraXQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG5leHBvcnQgdmFyIGFuZHJvaWQgPSB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCcpO1xyXG5cclxuLy8gQHByb3BlcnR5IGFuZHJvaWQyMzogQm9vbGVhbjsgYHRydWVgIGZvciBicm93c2VycyBydW5uaW5nIG9uIEFuZHJvaWQgMiBvciBBbmRyb2lkIDMuXHJcbmV4cG9ydCB2YXIgYW5kcm9pZDIzID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQgMicpIHx8IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDMnKTtcclxuXHJcbi8qIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc5NjEyNjYgZm9yIGRldGFpbHMgb24gZGV0ZWN0aW5nIHN0b2NrIEFuZHJvaWQgKi9cclxudmFyIHdlYmtpdFZlciA9IHBhcnNlSW50KC9XZWJLaXRcXC8oWzAtOV0rKXwkLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzFdLCAxMCk7IC8vIGFsc28gbWF0Y2hlcyBBcHBsZVdlYktpdFxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZFN0b2NrOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBBbmRyb2lkIHN0b2NrIGJyb3dzZXIgKGkuZS4gbm90IENocm9tZSlcclxuZXhwb3J0IHZhciBhbmRyb2lkU3RvY2sgPSBhbmRyb2lkICYmIHVzZXJBZ2VudENvbnRhaW5zKCdHb29nbGUnKSAmJiB3ZWJraXRWZXIgPCA1MzcgJiYgISgnQXVkaW9Ob2RlJyBpbiB3aW5kb3cpO1xyXG5cclxuLy8gQHByb3BlcnR5IG9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyXHJcbmV4cG9ydCB2YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG5leHBvcnQgdmFyIGNocm9tZSA9IHVzZXJBZ2VudENvbnRhaW5zKCdjaHJvbWUnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcbmV4cG9ydCB2YXIgZ2Vja28gPSB1c2VyQWdlbnRDb250YWlucygnZ2Vja28nKSAmJiAhd2Via2l0ICYmICFvcGVyYSAmJiAhaWU7XHJcblxyXG4vLyBAcHJvcGVydHkgc2FmYXJpOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBTYWZhcmkgYnJvd3Nlci5cclxuZXhwb3J0IHZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbmV4cG9ydCB2YXIgcGhhbnRvbSA9IHVzZXJBZ2VudENvbnRhaW5zKCdwaGFudG9tJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgb3BlcmExMjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMgKHZlcnNpb24gMTIgb3IgbGF0ZXIpLlxyXG5leHBvcnQgdmFyIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIHN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IHdpbjogQm9vbGVhbjsgYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIFdpbmRvd3MgcGxhdGZvcm1cclxuZXhwb3J0IHZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBzdHlsZSk7XHJcblxyXG4vLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW47IGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMztcclxuXHJcbi8vIEBwcm9wZXJ0eSBnZWNrbzNkOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcbmV4cG9ydCB2YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IHZhciBhbnkzZCA9ICF3aW5kb3cuTF9ESVNBQkxFXzNEICYmIChpZTNkIHx8IHdlYmtpdDNkIHx8IGdlY2tvM2QpICYmICFvcGVyYTEyICYmICFwaGFudG9tO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZTogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlID0gdHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJyB8fCB1c2VyQWdlbnRDb250YWlucygnbW9iaWxlJyk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5leHBvcnQgdmFyIG1vYmlsZVdlYmtpdDNkID0gbW9iaWxlICYmIHdlYmtpdDNkO1xyXG5cclxuLy8gQHByb3BlcnR5IG1zUG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuZXhwb3J0IHZhciBtc1BvaW50ZXIgPSAhd2luZG93LlBvaW50ZXJFdmVudCAmJiB3aW5kb3cuTVNQb2ludGVyRXZlbnQ7XHJcblxyXG4vLyBAcHJvcGVydHkgcG9pbnRlcjogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFtwb2ludGVyIGV2ZW50c10oaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kbjQzMzI0NCUyOHY9dnMuODUlMjkuYXNweCkuXHJcbmV4cG9ydCB2YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyBUaGlzIGRvZXMgbm90IG5lY2Vzc2FyaWx5IG1lYW4gdGhhdCB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgY29tcHV0ZXIgd2l0aFxyXG4vLyBhIHRvdWNoc2NyZWVuLCBpdCBvbmx5IG1lYW5zIHRoYXQgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nXHJcbi8vIHRvdWNoIGV2ZW50cy5cclxuZXhwb3J0IHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdCh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlT3BlcmE6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgaW4gYSBtb2JpbGUgZGV2aWNlLlxyXG5leHBvcnQgdmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbmV4cG9ydCB2YXIgbW9iaWxlR2Vja28gPSBtb2JpbGUgJiYgZ2Vja287XHJcblxyXG4vLyBAcHJvcGVydHkgcmV0aW5hOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgb24gYSBoaWdoLXJlc29sdXRpb24gXCJyZXRpbmFcIiBzY3JlZW4uXHJcbmV4cG9ydCB2YXIgcmV0aW5hID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxO1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBjYW52YXM6IEJvb2xlYW5cclxuLy8gYHRydWVgIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cclxuZXhwb3J0IHZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbmV4cG9ydCB2YXIgc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIHN2Z0NyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XHJcblxyXG4vLyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKS5cclxuZXhwb3J0IHZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0Jyb3dzZXIuanMiLCJpbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICpcclxuICogTm90ZSB0aGF0IGBCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogd2hpY2ggbWVhbnMgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIGl0LCBhbmQgbmV3IG1ldGhvZHNcclxuICogY2FuJ3QgYmUgYWRkZWQgdG8gaXQgd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufVxyXG5cclxuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChwb2ludDogUG9pbnQpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kcyB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LlxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHBvaW50ID0gdG9Qb2ludChwb2ludCk7XHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1pbjogUG9pbnRcclxuXHRcdC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtYXg6IFBvaW50XHJcblx0XHQvLyBUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0XHR0aGlzLm1heCA9IHBvaW50LmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4ocG9pbnQueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChwb2ludC54LCB0aGlzLm1heC54KTtcclxuXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgocG9pbnQueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcihyb3VuZD86IEJvb2xlYW4pOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKHJvdW5kKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMubWF4LngsIHRoaXMubWluLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wTGVmdCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1pbmBdKCNib3VuZHMtbWluKSkuXHJcblx0Z2V0VG9wTGVmdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWluOyAvLyBsZWZ0LCB0b3BcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbVJpZ2h0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLXJpZ2h0IHBvaW50IG9mIHRoZSBib3VuZHMgKGkuZS4gW2B0aGlzLm1heGBdKCNib3VuZHMtbWF4KSkuXHJcblx0Z2V0Qm90dG9tUmlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heDsgLy8gcmlnaHQsIGJvdHRvbVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm1heC5zdWJ0cmFjdCh0aGlzLm1pbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKHBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludC5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIG1pbiwgbWF4O1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0XHRvYmogPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKGNvcm5lcjE6IFBvaW50LCBjb3JuZXIyOiBQb2ludClcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0d28gY29ybmVycyBjb29yZGluYXRlIHBhaXJzLlxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5ib3VuZHMocG9pbnRzOiBQb2ludFtdKVxyXG4vLyBDcmVhdGVzIGEgQm91bmRzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEJvdW5kcyhhLCBiKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L0JvdW5kcy5qcyIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7YWRkUG9pbnRlckxpc3RlbmVyLCByZW1vdmVQb2ludGVyTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuUG9pbnRlcic7XHJcbmltcG9ydCB7YWRkRG91YmxlVGFwTGlzdGVuZXIsIHJlbW92ZURvdWJsZVRhcExpc3RlbmVyfSBmcm9tICcuL0RvbUV2ZW50LkRvdWJsZVRhcCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbUV2ZW50XHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTSBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9FdmVudCksIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucy5cclxuXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIHR5cGVzOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcbi8vIGVsZW1lbnQgYGVsYC4gWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIGNvbnRleHQgb2YgdGhlIGxpc3RlbmVyXHJcbi8vIChvYmplY3QgdGhlIGB0aGlzYCBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsXHJcbi8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvbihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9uKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdGFkZE9uZShvYmosIHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lciBmdW5jdGlvbi5cclxuLy8gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBvbiwgeW91IG11c3QgcGFzcyB0aGUgc2FtZVxyXG4vLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9mZihlbDogSFRNTEVsZW1lbnQsIGV2ZW50TWFwOiBPYmplY3QsIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuZXhwb3J0IGZ1bmN0aW9uIG9mZihvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaiBpbiBvYmpbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCBqLCBvYmpbZXZlbnRzS2V5XVtqXSk7XHJcblx0XHR9XHJcblx0XHRkZWxldGUgb2JqW2V2ZW50c0tleV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiBhZGREb3VibGVUYXBMaXN0ZW5lciAmJlxyXG5cdCAgICAgICAgICAgIShCcm93c2VyLnBvaW50ZXIgJiYgQnJvd3Nlci5jaHJvbWUpKSB7XHJcblx0XHQvLyBDaHJvbWUgPjU1IGRvZXMgbm90IG5lZWQgdGhlIHN5bnRoZXRpYyBkYmxjbGlja3MgZnJvbSBhZGREb3VibGVUYXBMaXN0ZW5lclxyXG5cdFx0Ly8gU2VlICM1MTgwXHJcblx0XHRhZGREb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0eXBlID09PSAnY2xpY2snICYmIEJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0b2JqLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHR9XHJcblxyXG5cdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gaGFuZGxlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0dmFyIGlkID0gdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdCAgICBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lciAmJlxyXG5cdCAgICAgICAgICAgIShCcm93c2VyLnBvaW50ZXIgJiYgQnJvd3Nlci5jaHJvbWUpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKTtcclxuXHJcblx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignb253aGVlbCcgaW4gb2JqID8gJ3doZWVsJyA6ICdtb3VzZXdoZWVsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG5cdFx0XHRcdHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDpcclxuXHRcdFx0XHR0eXBlID09PSAnbW91c2VsZWF2ZScgPyAnbW91c2VvdXQnIDogdHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gb2JqKSB7XHJcblx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdH1cclxuXHJcblx0b2JqW2V2ZW50c0tleV1baWRdID0gbnVsbDtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG4vLyBgYGBqc1xyXG4vLyBMLkRvbUV2ZW50Lm9uKGRpdiwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbi8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG4vLyB9KTtcclxuLy8gYGBgXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xyXG5cclxuXHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0fSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQpIHsgIC8vIEluIGNhc2Ugb2YgTGVhZmxldCBldmVudC5cclxuXHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuXHR9XHJcblx0c2tpcHBlZChlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCdtb3VzZXdoZWVsJ2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGVsKSB7XHJcblx0YWRkT25lKGVsLCAnbW91c2V3aGVlbCcsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihlbDogSFRNTEVsZW1lbnQpOiB0aGlzXHJcbi8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZG91YmxlY2xpY2snYCxcclxuLy8gYCdtb3VzZWRvd24nYCBhbmQgYCd0b3VjaHN0YXJ0J2AgZXZlbnRzIChwbHVzIGJyb3dzZXIgdmFyaWFudHMpLlxyXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWwpIHtcclxuXHRvbihlbCwgJ21vdXNlZG93biB0b3VjaHN0YXJ0IGRibGNsaWNrJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRhZGRPbmUoZWwsICdjbGljaycsIGZha2VTdG9wKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG4vLyBmb2xsb3dpbmcgYSBsaW5rIGluIHRoZSBocmVmIG9mIHRoZSBhIGVsZW1lbnQsIG9yIGRvaW5nIGEgUE9TVCByZXF1ZXN0XHJcbi8vIHdpdGggcGFnZSByZWxvYWQgd2hlbiBhIGA8Zm9ybT5gIGlzIHN1Ym1pdHRlZCkuXHJcbi8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZSkge1xyXG5cdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzdG9wKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gRG9lcyBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBhdCB0aGUgc2FtZSB0aW1lLlxyXG5leHBvcnQgZnVuY3Rpb24gc3RvcChlKSB7XHJcblx0cHJldmVudERlZmF1bHQoZSk7XHJcblx0c3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihldjogRE9NRXZlbnQsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcbi8vIGBjb250YWluZXJgIG9yIHRvIHRoZSB3aG9sZSBwYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUsIGNvbnRhaW5lcikge1xyXG5cdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuXHR9XHJcblxyXG5cdHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHR2YXIgc2NhbGVYID0gcmVjdC53aWR0aCAvIGNvbnRhaW5lci5vZmZzZXRXaWR0aCB8fCAxO1xyXG5cdHZhciBzY2FsZVkgPSByZWN0LmhlaWdodCAvIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgMTtcclxuXHRyZXR1cm4gbmV3IFBvaW50KFxyXG5cdFx0ZS5jbGllbnRYIC8gc2NhbGVYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHRlLmNsaWVudFkgLyBzY2FsZVkgLSByZWN0LnRvcCAtIGNvbnRhaW5lci5jbGllbnRUb3ApO1xyXG59XHJcblxyXG4vLyBDaHJvbWUgb24gV2luIHNjcm9sbHMgZG91YmxlIHRoZSBwaXhlbHMgYXMgaW4gb3RoZXIgcGxhdGZvcm1zIChzZWUgIzQ1MzgpLFxyXG4vLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXHJcbnZhciB3aGVlbFB4RmFjdG9yID1cclxuXHQoQnJvd3Nlci53aW4gJiYgQnJvd3Nlci5jaHJvbWUpID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLmdlY2tvID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2V3aGVlbCBET00gZXZlbnQsIGluIHZlcnRpY2FsXHJcbi8vIHBpeGVscyBzY3JvbGxlZCAobmVnYXRpdmUgaWYgc2Nyb2xsaW5nIGRvd24pLlxyXG4vLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG4vLyBhIGJlc3QgZ3Vlc3Mgb2YgNjAgcGl4ZWxzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XHJcblx0cmV0dXJuIChCcm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAwKSA/IC1lLmRlbHRhWSAvIHdoZWVsUHhGYWN0b3IgOiAvLyBQaXhlbHNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAxKSA/IC1lLmRlbHRhWSAqIDIwIDogLy8gTGluZXNcclxuXHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHQgICAgICAgKGUuZGVsdGFYIHx8IGUuZGVsdGFaKSA/IDAgOlx0Ly8gU2tpcCBob3Jpem9udGFsL2RlcHRoIHdoZWVsIGV2ZW50c1xyXG5cdCAgICAgICBlLndoZWVsRGVsdGEgPyAoZS53aGVlbERlbHRhWSB8fCBlLndoZWVsRGVsdGEpIC8gMiA6IC8vIExlZ2FjeSBJRSBwaXhlbHNcclxuXHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdCAgICAgICBlLmRldGFpbCA/IGUuZGV0YWlsIC8gLTMyNzY1ICogNjAgOiAvLyBMZWdhY3kgTW96IHBhZ2VzXHJcblx0ICAgICAgIDA7XHJcbn1cclxuXHJcbnZhciBza2lwRXZlbnRzID0ge307XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmFrZVN0b3AoZSkge1xyXG5cdC8vIGZha2VzIHN0b3BQcm9wYWdhdGlvbiBieSBzZXR0aW5nIGEgc3BlY2lhbCBldmVudCBmbGFnLCBjaGVja2VkL3Jlc2V0IHdpdGggc2tpcHBlZChlKVxyXG5cdHNraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBza2lwcGVkKGUpIHtcclxuXHR2YXIgZXZlbnRzID0gc2tpcEV2ZW50c1tlLnR5cGVdO1xyXG5cdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0c2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0cmV0dXJuIGV2ZW50cztcclxufVxyXG5cclxuLy8gY2hlY2sgaWYgZWxlbWVudCByZWFsbHkgbGVmdC9lbnRlcmVkIHRoZSBldmVudCB0YXJnZXQgKGZvciBtb3VzZWVudGVyL21vdXNlbGVhdmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsVGFyZ2V0KGVsLCBlKSB7XHJcblxyXG5cdHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0O1xyXG5cclxuXHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0dHJ5IHtcclxuXHRcdHdoaWxlIChyZWxhdGVkICYmIChyZWxhdGVkICE9PSBlbCkpIHtcclxuXHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIChyZWxhdGVkICE9PSBlbCk7XHJcbn1cclxuXHJcbnZhciBsYXN0Q2xpY2s7XHJcblxyXG4vLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcbmZ1bmN0aW9uIGZpbHRlckNsaWNrKGUsIGhhbmRsZXIpIHtcclxuXHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LnRpbWVTdGFtcCkpLFxyXG5cdCAgICBlbGFwc2VkID0gbGFzdENsaWNrICYmICh0aW1lU3RhbXAgLSBsYXN0Q2xpY2spO1xyXG5cclxuXHQvLyBhcmUgdGhleSBjbG9zZXIgdG9nZXRoZXIgdGhhbiA1MDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdC8vIEFuZHJvaWQgdHlwaWNhbGx5IHRyaWdnZXJzIHRoZW0gfjMwMG1zIGFwYXJ0IHdoaWxlIG11bHRpcGxlIGxpc3RlbmVyc1xyXG5cdC8vIG9uIHRoZSBzYW1lIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZmFyIGZhc3RlcjtcclxuXHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRpZiAoKGVsYXBzZWQgJiYgZWxhcHNlZCA+IDEwMCAmJiBlbGFwc2VkIDwgNTAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRzdG9wKGUpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHRsYXN0Q2xpY2sgPSB0aW1lU3RhbXA7XHJcblxyXG5cdGhhbmRsZXIoZSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuZXhwb3J0IHtvbiBhcyBhZGRMaXN0ZW5lcn07XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuZXhwb3J0IHtvZmYgYXMgcmVtb3ZlTGlzdGVuZXJ9O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5qcyIsImltcG9ydCB7IExlZ2FjeUVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgJy4vbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCAnLi9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWJpbmQuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWlmLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanMnO1xuaW1wb3J0ICcuL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzJztcbmV4cG9ydCBjb25zdCBCYXNlID0gTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KS5wcm90b3R5cGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCB7RVBTRzM4NTd9IGZyb20gJy4uL2dlby9jcnMvQ1JTLkVQU0czODU3JztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge0JvdW5kcywgdG9Cb3VuZHN9IGZyb20gJy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuLi9kb20vUG9zQW5pbWF0aW9uJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBVdGlsLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gdGhpcy5fbGltaXRab29tKG9wdGlvbnMuem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuY2VudGVyICYmIG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc2V0Vmlldyh0b0xhdExuZyhvcHRpb25zLmNlbnRlciksIG9wdGlvbnMuem9vbSwge3Jlc2V0OiB0cnVlfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBEb21VdGlsLlRSQU5TSVRJT04gJiYgQnJvd3Nlci5hbnkzZCAmJiAhQnJvd3Nlci5tb2JpbGVPcGVyYSAmJlxyXG5cdFx0XHRcdHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xyXG5cdFx0XHREb21FdmVudC5vbih0aGlzLl9wcm94eSwgRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fY2F0Y2hUcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRjZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcih0b0xhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG5cdFx0XHRcdG9wdGlvbnMucGFuID0gVXRpbC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSwgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb259LCBvcHRpb25zLnBhbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cclxuXHRcdFx0dmFyIG1vdmVkID0gKHRoaXMuX3pvb20gIT09IHpvb20pID9cclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XHJcblxyXG5cdFx0XHRpZiAobW92ZWQpIHtcclxuXHRcdFx0XHQvLyBwcmV2ZW50IHJlc2l6ZSBoYW5kbGVyIGNhbGwsIHRoZSB2aWV3IHdpbGwgcmVmcmVzaCBhZnRlciBhbmltYXRpb24gYW55d2F5XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRpb24gZGlkbid0IHN0YXJ0LCBqdXN0IHJlc2V0IHRoZSBtYXAgdmlld1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KGNlbnRlciwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgem9vbSBvZiB0aGUgbWFwLlxyXG5cdHNldFpvb206IGZ1bmN0aW9uICh6b29tLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHt6b29tOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tSW4oZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gSW5jcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbUluOiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbURlbHRhIDogMSk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyBkZWx0YSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tT3V0KGRlbHRhPzogTnVtYmVyLCBvcHRpb25zPzogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIERlY3JlYXNlcyB0aGUgem9vbSBvZiB0aGUgbWFwIGJ5IGBkZWx0YWAgKFtgem9vbURlbHRhYF0oI21hcC16b29tZGVsdGEpIGJ5IGRlZmF1bHQpLlxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgUG9pbnQgPyBsYXRsbmcgOiB0aGlzLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQobGF0bG5nKSxcclxuXHJcblx0XHQgICAgY2VudGVyT2Zmc2V0ID0gY29udGFpbmVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLm11bHRpcGx5QnkoMSAtIDEgLyBzY2FsZSksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF0TG5nKHZpZXdIYWxmLmFkZChjZW50ZXJPZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KG5ld0NlbnRlciwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Qm91bmRzQ2VudGVyWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSk7XHJcblxyXG5cdFx0em9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhab29tID09PSAnbnVtYmVyJykgPyBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIHpvb20pIDogem9vbTtcclxuXHJcblx0XHRpZiAoem9vbSA9PT0gSW5maW5pdHkpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRjZW50ZXI6IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdFx0XHR6b29tOiB6b29tXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdPZmZzZXQgPSBwYWRkaW5nQlIuc3VidHJhY3QocGFkZGluZ1RMKS5kaXZpZGVCeSgyKSxcclxuXHJcblx0XHQgICAgc3dQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIG5lUG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICBjZW50ZXIgPSB0aGlzLnVucHJvamVjdChzd1BvaW50LmFkZChuZVBvaW50KS5kaXZpZGVCeSgyKS5hZGQocGFkZGluZ09mZnNldCksIHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZml0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50LCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIGJ5IGEgZ2l2ZW4gbnVtYmVyIG9mIHBpeGVscyAoYW5pbWF0ZWQpLlxyXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcblx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkucm91bmQoKTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHRcdC8vIElmIHdlIHBhbiB0b28gZmFyLCBDaHJvbWUgZ2V0cyBpc3N1ZXMgd2l0aCB0aWxlc1xyXG5cdFx0Ly8gYW5kIG1ha2VzIHRoZW0gZGlzYXBwZWFyIG9yIGFwcGVhciBpbiB0aGUgd3JvbmcgcGxhY2UgKHNsaWdodGx5IG9mZnNldCkgIzI2MDJcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMudW5wcm9qZWN0KHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKS5hZGQob2Zmc2V0KSksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgUG9zQW5pbWF0aW9uKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5BbmltLm9uKHtcclxuXHRcdFx0XHQnc3RlcCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvblN0ZXAsXHJcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkb24ndCBmaXJlIG1vdmVzdGFydCBpZiBhbmltYXRpbmcgaW5lcnRpYVxyXG5cdFx0aWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ucnVuKHRoaXMuX21hcFBhbmUsIG5ld1Bvcywgb3B0aW9ucy5kdXJhdGlvbiB8fCAwLjI1LCBvcHRpb25zLmVhc2VMaW5lYXJpdHkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJykuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG8obGF0bG5nOiBMYXRMbmcsIHpvb20/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxyXG5cdC8vIHBhbi16b29tIGFuaW1hdGlvbi5cclxuXHRmbHlUbzogZnVuY3Rpb24gKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIUJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20sIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHR2YXIgZnJvbSA9IHRoaXMucHJvamVjdCh0aGlzLmdldENlbnRlcigpKSxcclxuXHRcdCAgICB0byA9IHRoaXMucHJvamVjdCh0YXJnZXRDZW50ZXIpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBzdGFydFpvb20gPSB0aGlzLl96b29tO1xyXG5cclxuXHRcdHRhcmdldENlbnRlciA9IHRvTGF0TG5nKHRhcmdldENlbnRlcik7XHJcblx0XHR0YXJnZXRab29tID0gdGFyZ2V0Wm9vbSA9PT0gdW5kZWZpbmVkID8gc3RhcnRab29tIDogdGFyZ2V0Wm9vbTtcclxuXHJcblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXHJcblx0XHQgICAgdzEgPSB3MCAqIHRoaXMuZ2V0Wm9vbVNjYWxlKHN0YXJ0Wm9vbSwgdGFyZ2V0Wm9vbSksXHJcblx0XHQgICAgdTEgPSAodG8uZGlzdGFuY2VUbyhmcm9tKSkgfHwgMSxcclxuXHRcdCAgICByaG8gPSAxLjQyLFxyXG5cdFx0ICAgIHJobzIgPSByaG8gKiByaG87XHJcblxyXG5cdFx0ZnVuY3Rpb24gcihpKSB7XHJcblx0XHRcdHZhciBzMSA9IGkgPyAtMSA6IDEsXHJcblx0XHRcdCAgICBzMiA9IGkgPyB3MSA6IHcwLFxyXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxyXG5cdFx0XHQgICAgYjEgPSAyICogczIgKiByaG8yICogdTEsXHJcblx0XHRcdCAgICBiID0gdDEgLyBiMSxcclxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xyXG5cclxuXHRcdFx0ICAgIC8vIHdvcmthcm91bmQgZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBidWcgd2hlbiBzcSA9IDAsIGxvZyA9IC1JbmZpbml0ZSxcclxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXHJcblx0XHRcdCAgICB2YXIgbG9nID0gc3EgPCAwLjAwMDAwMDAwMSA/IC0xOCA6IE1hdGgubG9nKHNxKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxyXG5cdFx0ZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxyXG5cclxuXHRcdHZhciByMCA9IHIoMCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cclxuXHRcdGZ1bmN0aW9uIHUocykgeyByZXR1cm4gdzAgKiAoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yOyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cclxuXHJcblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcclxuXHRcdCAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPyAxMDAwICogb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAgKiBTICogMC44O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xyXG5cdFx0XHR2YXIgdCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb24sXHJcblx0XHRcdCAgICBzID0gZWFzZU91dCh0KSAqIFM7XHJcblxyXG5cdFx0XHRpZiAodCA8PSAxKSB7XHJcblx0XHRcdFx0dGhpcy5fZmx5VG9GcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShmcmFtZSwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21vdmUoXHJcblx0XHRcdFx0XHR0aGlzLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWJ0cmFjdChmcm9tKS5tdWx0aXBseUJ5KHUocykgLyB1MSkpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXRTY2FsZVpvb20odzAgLyB3KHMpLCBzdGFydFpvb20pLFxyXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXNcclxuXHRcdFx0XHRcdC5fbW92ZSh0YXJnZXRDZW50ZXIsIHRhcmdldFpvb20pXHJcblx0XHRcdFx0XHQuX21vdmVFbmQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSwgb3B0aW9ucy5ub01vdmVTdGFydCk7XHJcblxyXG5cdFx0ZnJhbWUuY2FsbCh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgd2l0aCBhIHNtb290aCBhbmltYXRpb24gbGlrZSBbYGZseVRvYF0oI21hcC1mbHl0byksXHJcblx0Ly8gYnV0IHRha2VzIGEgYm91bmRzIHBhcmFtZXRlciBsaWtlIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmx5VG8odGFyZ2V0LmNlbnRlciwgdGFyZ2V0Lnpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWF4Qm91bmRzKGJvdW5kczogQm91bmRzKTogdGhpc1xyXG5cdC8vIFJlc3RyaWN0cyB0aGUgbWFwIHZpZXcgdG8gdGhlIGdpdmVuIGJvdW5kcyAoc2VlIHRoZSBbbWF4Qm91bmRzXSgjbWFwLW1heGJvdW5kcykgb3B0aW9uKS5cclxuXHRzZXRNYXhCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5KSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIEFwcHJvcHJpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcCB2aWV3XHJcblx0Z2V0Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGJvdW5kcyB2aXNpYmxlIGluIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIHN3ID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldEJvdHRvbUxlZnQoKSksXHJcblx0XHQgICAgbmUgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0VG9wUmlnaHQoKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1pblpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1pblpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLCBvciBgMGAgYnkgZGVmYXVsdC5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX2xheWVyc01pblpvb20gfHwgMCA6IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWF4Wm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWF4Wm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycykuXHJcblx0Z2V0TWF4Wm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHQodGhpcy5fbGF5ZXJzTWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aGlzLl9sYXllcnNNYXhab29tKSA6XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhab29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzWm9vbShib3VuZHM6IExhdExuZ0JvdW5kcywgaW5zaWRlPzogQm9vbGVhbik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgZ2l2ZW4gYm91bmRzIGZpdCB0byB0aGUgbWFwXHJcblx0Ly8gdmlldyBpbiBpdHMgZW50aXJldHkuIElmIGBpbnNpZGVgIChvcHRpb25hbCkgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIG1ldGhvZFxyXG5cdC8vIGluc3RlYWQgcmV0dXJucyB0aGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBtYXAgdmlldyBmaXRzIGludG9cclxuXHQvLyB0aGUgZ2l2ZW4gYm91bmRzIGluIGl0cyBlbnRpcmV0eS5cclxuXHRnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHsgLy8gKExhdExuZ0JvdW5kc1ssIEJvb2xlYW4sIFBvaW50XSkgLT4gTnVtYmVyXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cdFx0cGFkZGluZyA9IHRvUG9pbnQocGFkZGluZyB8fCBbMCwgMF0pO1xyXG5cclxuXHRcdHZhciB6b29tID0gdGhpcy5nZXRab29tKCkgfHwgMCxcclxuXHRcdCAgICBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHRcdCAgICBzaXplID0gdGhpcy5nZXRTaXplKCkuc3VidHJhY3QocGFkZGluZyksXHJcblx0XHQgICAgYm91bmRzU2l6ZSA9IHRvQm91bmRzKHRoaXMucHJvamVjdChzZSwgem9vbSksIHRoaXMucHJvamVjdChudywgem9vbSkpLmdldFNpemUoKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDEsXHJcblx0XHQgICAgc2NhbGV4ID0gc2l6ZS54IC8gYm91bmRzU2l6ZS54LFxyXG5cdFx0ICAgIHNjYWxleSA9IHNpemUueSAvIGJvdW5kc1NpemUueSxcclxuXHRcdCAgICBzY2FsZSA9IGluc2lkZSA/IE1hdGgubWF4KHNjYWxleCwgc2NhbGV5KSA6IE1hdGgubWluKHNjYWxleCwgc2NhbGV5KTtcclxuXHJcblx0XHR6b29tID0gdGhpcy5nZXRTY2FsZVpvb20oc2NhbGUsIHpvb20pO1xyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyAoc25hcCAvIDEwMCkpICogKHNuYXAgLyAxMDApOyAvLyBkb24ndCBqdW1wIGlmIHdpdGhpbiAxJSBvZiBhIHNuYXAgbGV2ZWxcclxuXHRcdFx0em9vbSA9IGluc2lkZSA/IE1hdGguY2VpbCh6b29tIC8gc25hcCkgKiBzbmFwIDogTWF0aC5mbG9vcih6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgem9vbSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2l6ZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgbWFwIGNvbnRhaW5lciAoaW4gcGl4ZWxzKS5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBQb2ludChcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50V2lkdGggfHwgMCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDApO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHModG9wTGVmdFBvaW50LCB0b3BMZWZ0UG9pbnQuYWRkKHRoaXMuZ2V0U2l6ZSgpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETzogQ2hlY2sgc2VtYW50aWNzIC0gaXNuJ3QgdGhlIHBpeGVsIG9yaWdpbiB0aGUgMCwwIGNvb3JkIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIG1hcCBwYW5lPyBcImxlZnQgcG9pbnQgb2YgdGhlIG1hcCBsYXllclwiIGNhbiBiZSBjb25mdXNpbmcsIHNwZWNpYWxseVxyXG5cdC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBuZWdhdGl2ZSBvZmZzZXRzLlxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxPcmlnaW4oKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0ZWQgcGl4ZWwgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IHBvaW50IG9mXHJcblx0Ly8gdGhlIG1hcCBsYXllciAodXNlZnVsIGluIGN1c3RvbSBsYXllciBhbmQgb3ZlcmxheSBpbXBsZW1lbnRhdGlvbnMpLlxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxPcmlnaW47XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbFdvcmxkQm91bmRzKHpvb20/OiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSB3b3JsZCdzIGJvdW5kcyBpbiBwaXhlbCBjb29yZGluYXRlcyBmb3Igem9vbSBsZXZlbCBgem9vbWAuXHJcblx0Ly8gSWYgYHpvb21gIGlzIG9taXR0ZWQsIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwgaXMgdXNlZC5cclxuXHRnZXRQaXhlbFdvcmxkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZ2V0UHJvamVjdGVkQm91bmRzKHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmUocGFuZTogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIGEgW21hcCBwYW5lXSgjbWFwLXBhbmUpLCBnaXZlbiBpdHMgbmFtZSBvciBpdHMgSFRNTCBlbGVtZW50IChpdHMgaWRlbnRpdHkpLlxyXG5cdGdldFBhbmU6IGZ1bmN0aW9uIChwYW5lKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIHBhbmUgPT09ICdzdHJpbmcnID8gdGhpcy5fcGFuZXNbcGFuZV0gOiBwYW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZXMoKTogT2JqZWN0XHJcblx0Ly8gUmV0dXJucyBhIHBsYWluIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgW3BhbmVzXSgjbWFwLXBhbmUpIGFzIGtleXMgYW5kXHJcblx0Ly8gdGhlIHBhbmVzIGFzIHZhbHVlcy5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXAuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBDb252ZXJzaW9uIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tU2NhbGUodG9ab29tOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byBhIG1hcCB0cmFuc2l0aW9uIGZyb20gem9vbSBsZXZlbFxyXG5cdC8vIGBmcm9tWm9vbWAgdG8gYHRvWm9vbWAuIFVzZWQgaW50ZXJuYWxseSB0byBoZWxwIHdpdGggem9vbSBhbmltYXRpb25zLlxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSwgZnJvbVpvb20pIHtcclxuXHRcdC8vIFRPRE8gcmVwbGFjZSB3aXRoIHVuaXZlcnNhbCBpbXBsZW1lbnRhdGlvbiBhZnRlciByZWZhY3RvcmluZyBwcm9qZWN0aW9uc1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUoZnJvbVpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U2NhbGVab29tKHNjYWxlOiBOdW1iZXIsIGZyb21ab29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB6b29tIGxldmVsIHRoYXQgdGhlIG1hcCB3b3VsZCBlbmQgdXAgYXQsIGlmIGl0IGlzIGF0IGBmcm9tWm9vbWBcclxuXHQvLyBsZXZlbCBhbmQgZXZlcnl0aGluZyBpcyBzY2FsZWQgYnkgYSBmYWN0b3Igb2YgYHNjYWxlYC4gSW52ZXJzZSBvZlxyXG5cdC8vIFtgZ2V0Wm9vbVNjYWxlYF0oI21hcC1nZXRab29tU2NhbGUpLlxyXG5cdGdldFNjYWxlWm9vbTogZnVuY3Rpb24gKHNjYWxlLCBmcm9tWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRmcm9tWm9vbSA9IGZyb21ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogZnJvbVpvb207XHJcblx0XHR2YXIgem9vbSA9IGNycy56b29tKHNjYWxlICogY3JzLnNjYWxlKGZyb21ab29tKSk7XHJcblx0XHRyZXR1cm4gaXNOYU4oem9vbSkgPyBJbmZpbml0eSA6IHpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nLCB6b29tOiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgYExhdExuZ2AgYWNjb3JkaW5nIHRvIHRoZSBwcm9qZWN0aW9uXHJcblx0Ly8gb2YgdGhlIG1hcCdzIENSUywgdGhlbiBzY2FsZXMgaXQgYWNjb3JkaW5nIHRvIGB6b29tYCBhbmQgdGhlIENSUydzXHJcblx0Ly8gYFRyYW5zZm9ybWF0aW9uYC4gVGhlIHJlc3VsdCBpcyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIENSUyBvcmlnaW4uXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZywgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludCh0b0xhdExuZyhsYXRsbmcpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQsIHpvb206IE51bWJlcik6IExhdExuZ1xyXG5cdC8vIEludmVyc2Ugb2YgW2Bwcm9qZWN0YF0oI21hcC1wcm9qZWN0KS5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyh0b1BvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRvUG9pbnQocG9pbnQpLmFkZCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMudW5wcm9qZWN0KHByb2plY3RlZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KHRvTGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBgbGF0YCBhbmQgYGxuZ2AgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gbWFwJ3MgQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGVcclxuXHQvLyBDUlMncyBib3VuZHMuXHJcblx0Ly8gQnkgZGVmYXVsdCB0aGlzIG1lYW5zIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZyh0b0xhdExuZyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nIHRoYXRcclxuXHQvLyBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyB0aGUgY2VudGVyIGxvbmdpdHVkZSBpcyB3cmFwcGVkIGFyb3VuZCB0aGUgZGF0ZWxpbmUgc28gaXRzXHJcblx0Ly8gdmFsdWUgaXMgYmV0d2VlbiAtMTgwIGFuZCArMTgwIGRlZ3JlZXMsIGFuZCB0aGUgbWFqb3JpdHkgb2YgdGhlIGJvdW5kc1xyXG5cdC8vIG92ZXJsYXBzIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMud3JhcExhdExuZ0JvdW5kcyh0b0xhdExuZ0JvdW5kcyhsYXRsbmcpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlKGxhdGxuZzE6IExhdExuZywgbGF0bG5nMjogTGF0TG5nKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGFjY29yZGluZyB0b1xyXG5cdC8vIHRoZSBtYXAncyBDUlMuIEJ5IGRlZmF1bHQgdGhpcyBtZWFzdXJlcyBkaXN0YW5jZSBpbiBtZXRlcnMuXHJcblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5kaXN0YW5jZSh0b0xhdExuZyhsYXRsbmcxKSwgdG9MYXRMbmcobGF0bG5nMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmdcclxuXHQvLyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXllclBvaW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHJldHVybiB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zXHJcblx0Ly8gdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRjb250YWluZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBsYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0b1BvaW50KHBvaW50KSk7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0NvbnRhaW5lclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lci5cclxuXHRsYXRMbmdUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9Db250YWluZXJQb2ludCh0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0b0xhdExuZyhsYXRsbmcpKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChldjogTW91c2VFdmVudCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyB0aGUgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGVcclxuXHQvLyBtYXAgY29udGFpbmVyIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIHRoaXMpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVySWQgPSBVdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgQnJvd3Nlci5hbnkzZDtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udGFpbmVyJyArXHJcblx0XHRcdChCcm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuaWVsdDkgPyAnIGxlYWZsZXQtb2xkaWUnIDogJycpICtcclxuXHRcdFx0KEJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IERvbVV0aWwuZ2V0U3R5bGUoY29udGFpbmVyLCAncG9zaXRpb24nKTtcclxuXHJcblx0XHRpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0UGFuZXMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdENvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5faW5pdENvbnRyb2xQb3MoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaW5pdFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZXMgPSB0aGlzLl9wYW5lcyA9IHt9O1xyXG5cdFx0dGhpcy5fcGFuZVJlbmRlcmVycyA9IHt9O1xyXG5cclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvL1xyXG5cdFx0Ly8gUGFuZXMgYXJlIERPTSBlbGVtZW50cyB1c2VkIHRvIGNvbnRyb2wgdGhlIG9yZGVyaW5nIG9mIGxheWVycyBvbiB0aGUgbWFwLiBZb3VcclxuXHRcdC8vIGNhbiBhY2Nlc3MgcGFuZXMgd2l0aCBbYG1hcC5nZXRQYW5lYF0oI21hcC1nZXRwYW5lKSBvclxyXG5cdFx0Ly8gW2BtYXAuZ2V0UGFuZXNgXSgjbWFwLWdldHBhbmVzKSBtZXRob2RzLiBOZXcgcGFuZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuXHRcdC8vIFtgbWFwLmNyZWF0ZVBhbmVgXSgjbWFwLWNyZWF0ZXBhbmUpIG1ldGhvZC5cclxuXHRcdC8vXHJcblx0XHQvLyBFdmVyeSBtYXAgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdCBwYW5lcyB0aGF0IGRpZmZlciBvbmx5IGluIHpJbmRleC5cclxuXHRcdC8vXHJcblx0XHQvLyBAcGFuZSBtYXBQYW5lOiBIVE1MRWxlbWVudCA9ICdhdXRvJ1xyXG5cdFx0Ly8gUGFuZSB0aGF0IGNvbnRhaW5zIGFsbCBvdGhlciBtYXAgcGFuZXNcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gdGhpcy5jcmVhdGVQYW5lKCdtYXBQYW5lJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvcnMgKGBQYXRoYHMsIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHMpLCBgSW1hZ2VPdmVybGF5YHMgYW5kIGBWaWRlb092ZXJsYXlgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdzaGFkb3dQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBtYXJrZXJQYW5lOiBIVE1MRWxlbWVudCA9IDYwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEljb25gcyBvZiBgTWFya2VyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnbWFya2VyUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgdG9vbHRpcFBhbmU6IEhUTUxFbGVtZW50ID0gNjUwXHJcblx0XHQvLyBQYW5lIGZvciBgVG9vbHRpcGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCd0b29sdGlwUGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgcG9wdXBQYW5lOiBIVE1MRWxlbWVudCA9IDcwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYFBvcHVwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3BvcHVwUGFuZScpO1xyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLm1hcmtlclpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyBAc2VjdGlvbiBNYXAgc3RhdGUgY2hhbmdlIGV2ZW50c1xyXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBmYWxzZSlcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEpIHtcclxuXHRcdGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0em9vbSA9IHRoaXMuX3pvb207XHJcblx0XHR9XHJcblx0XHR2YXIgem9vbUNoYW5nZWQgPSB0aGlzLl96b29tICE9PSB6b29tO1xyXG5cclxuXHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0dGhpcy5fbGFzdENlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX3BpeGVsT3JpZ2luID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbTogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFueSBjaGFuZ2UgaW4gem9vbSBsZXZlbCwgaW5jbHVkaW5nIHpvb21cclxuXHRcdC8vIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCB8fCAoZGF0YSAmJiBkYXRhLnBpbmNoKSkge1x0Ly8gQWx3YXlzIGZpcmUgJ3pvb20nIGlmIHBpbmNoaW5nIGJlY2F1c2UgIzM1MzBcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tJywgZGF0YSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgbW92ZW1lbnQgb2YgdGhlIG1hcCwgaW5jbHVkaW5nIHBhbiBhbmRcclxuXHRcdC8vIGZseSBhbmltYXRpb25zLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGhhcyBjaGFuZ2VkLCBhZnRlciBhbnkgYW5pbWF0aW9ucy5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGNlbnRlciBvZiB0aGUgbWFwIHN0b3BzIGNoYW5naW5nIChlLmcuIHVzZXIgc3RvcHBlZFxyXG5cdFx0Ly8gZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3N0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmZvcmNpbmdCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gRE9NIGV2ZW50IGhhbmRsaW5nXHJcblxyXG5cdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIGV2ZW50c1xyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/IERvbUV2ZW50Lm9mZiA6IERvbUV2ZW50Lm9uO1xyXG5cclxuXHRcdC8vIEBldmVudCBjbGljazogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKG9yIHRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgZGJsY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyAob3IgZG91YmxlLXRhcHMpIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vkb3duOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2V1cDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdmVyOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtb3VzZSBlbnRlcnMgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBtb3VzZW91dDogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2Vtb3ZlOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGlsZSB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGNvbnRleHRtZW51OiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHB1c2hlcyB0aGUgcmlnaHQgbW91c2UgYnV0dG9uIG9uIHRoZSBtYXAsIHByZXZlbnRzXHJcblx0XHQvLyBkZWZhdWx0IGJyb3dzZXIgY29udGV4dCBtZW51IGZyb20gc2hvd2luZyBpZiB0aGVyZSBhcmUgbGlzdGVuZXJzIG9uXHJcblx0XHQvLyB0aGlzIGV2ZW50LiBBbHNvIGZpcmVkIG9uIG1vYmlsZSB3aGVuIHRoZSB1c2VyIGhvbGRzIGEgc2luZ2xlIHRvdWNoXHJcblx0XHQvLyBmb3IgYSBzZWNvbmQgKGFsc28gY2FsbGVkIGxvbmcgcHJlc3MpLlxyXG5cdFx0Ly8gQGV2ZW50IGtleXByZXNzOiBLZXlib2FyZEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgYSBrZXkgZnJvbSB0aGUga2V5Ym9hcmQgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0b25PZmYodGhpcy5fY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgJyArXHJcblx0XHRcdCdtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzJywgdGhpcy5faGFuZGxlRE9NRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0b25PZmYod2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChCcm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdChyZW1vdmUgPyB0aGlzLm9mZiA6IHRoaXMub24pLmNhbGwodGhpcywgJ21vdmVlbmQnLCB0aGlzLl9vbk1vdmVFbmQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFxyXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoKSB7IHRoaXMuaW52YWxpZGF0ZVNpemUoe2RlYm91bmNlTW92ZWVuZDogdHJ1ZX0pOyB9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25TY3JvbGw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgID0gMDtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0aWYgKE1hdGgubWF4KE1hdGguYWJzKHBvcy54KSwgTWF0aC5hYnMocG9zLnkpKSA+PSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjAzODczIGJ1dCBXZWJraXQgYWxzbyBoYXZlXHJcblx0XHRcdC8vIGEgcGl4ZWwgb2Zmc2V0IG9uIHZlcnkgaGlnaCB2YWx1ZXMsIHNlZTogaHR0cDovL2pzZmlkZGxlLm5ldC9kZzZyNWhoYi9cclxuXHRcdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHRoaXMuZ2V0Wm9vbSgpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZmluZEV2ZW50VGFyZ2V0czogZnVuY3Rpb24gKGUsIHR5cGUpIHtcclxuXHRcdHZhciB0YXJnZXRzID0gW10sXHJcblx0XHQgICAgdGFyZ2V0LFxyXG5cdFx0ICAgIGlzSG92ZXIgPSB0eXBlID09PSAnbW91c2VvdXQnIHx8IHR5cGUgPT09ICdtb3VzZW92ZXInLFxyXG5cdFx0ICAgIHNyYyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcclxuXHRcdCAgICBkcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdHdoaWxlIChzcmMpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHNyYyldO1xyXG5cdFx0XHRpZiAodGFyZ2V0ICYmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT09ICdwcmVjbGljaycpICYmICFlLl9zaW11bGF0ZWQgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgRG9tRXZlbnQuaXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBEb21FdmVudC5za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vkb3duJyB8fCB0eXBlID09PSAna2V5cHJlc3MnKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZmlyZURPTUV2ZW50KGUsIHR5cGUpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3VzZUV2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXSxcclxuXHJcblx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIHRhcmdldHMpIHtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcblx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcblx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG5cdFx0XHR2YXIgc3ludGggPSBVdGlsLmV4dGVuZCh7fSwgZSk7XHJcblx0XHRcdHN5bnRoLnR5cGUgPSAncHJlY2xpY2snO1xyXG5cdFx0XHR0aGlzLl9maXJlRE9NRXZlbnQoc3ludGgsIHN5bnRoLnR5cGUsIHRhcmdldHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLl9zdG9wcGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGxheWVyIHRoZSBldmVudCBpcyBwcm9wYWdhdGluZyBmcm9tIGFuZCBpdHMgcGFyZW50cy5cclxuXHRcdHRhcmdldHMgPSAodGFyZ2V0cyB8fCBbXSkuY29uY2F0KHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSkpO1xyXG5cclxuXHRcdGlmICghdGFyZ2V0cy5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbMF07XHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51JyAmJiB0YXJnZXQubGlzdGVucyh0eXBlLCB0cnVlKSkge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoZS50eXBlICE9PSAna2V5cHJlc3MnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGFyZ2V0c1tpXS5maXJlKHR5cGUsIGRhdGEsIHRydWUpO1xyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkIHx8XHJcblx0XHRcdFx0KHRhcmdldHNbaV0ub3B0aW9ucy5idWJibGluZ01vdXNlRXZlbnRzID09PSBmYWxzZSAmJiBVdGlsLmluZGV4T2YodGhpcy5fbW91c2VFdmVudHMsIHR5cGUpICE9PSAtMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2RyYWdnYWJsZU1vdmVkOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRvYmogPSBvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLmVuYWJsZWQoKSA/IG9iaiA6IHRoaXM7XHJcblx0XHRyZXR1cm4gKG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcubW92ZWQoKSkgfHwgKHRoaXMuYm94Wm9vbSAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIHdoZW5SZWFkeShmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYGZuYCB3aGVuIHRoZSBtYXAgZ2V0cyBpbml0aWFsaXplZCB3aXRoXHJcblx0Ly8gYSB2aWV3IChjZW50ZXIgYW5kIHpvb20pIGFuZCBhdCBsZWFzdCBvbmUgbGF5ZXIsIG9yIGltbWVkaWF0ZWx5XHJcblx0Ly8gaWYgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCBvcHRpb25hbGx5IHBhc3NpbmcgYSBmdW5jdGlvbiBjb250ZXh0LlxyXG5cdHdoZW5SZWFkeTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCB8fCB0aGlzLCB7dGFyZ2V0OiB0aGlzfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm9uKCdsb2FkJywgY2FsbGJhY2ssIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBQb2ludCgwLCAwKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRyZXR1cm4gcG9zICYmICFwb3MuZXF1YWxzKFswLCAwXSk7XHJcblx0fSxcclxuXHJcblx0X2dldFRvcExlZnRQb2ludDogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHBpeGVsT3JpZ2luID0gY2VudGVyICYmIHpvb20gIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkgOlxyXG5cdFx0XHR0aGlzLmdldFBpeGVsT3JpZ2luKCk7XHJcblx0XHRyZXR1cm4gcGl4ZWxPcmlnaW4uc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3UGl4ZWxPcmlnaW46IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKS5fc3VidHJhY3Qodmlld0hhbGYpLl9hZGQodGhpcy5fZ2V0TWFwUGFuZVBvcygpKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBjZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3QobGF0bG5nLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCk7XHJcblx0fSxcclxuXHJcblx0X2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHM6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFtcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEJvdW5kcyhjZW50ZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZiksIGNlbnRlclBvaW50LmFkZCh2aWV3SGFsZikpLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldEJvdW5kc09mZnNldCh2aWV3Qm91bmRzLCBib3VuZHMsIHpvb20pO1xyXG5cclxuXHRcdC8vIElmIG9mZnNldCBpcyBsZXNzIHRoYW4gYSBwaXhlbCwgaWdub3JlLlxyXG5cdFx0Ly8gVGhpcyBwcmV2ZW50cyB1bnN0YWJsZSBwcm9qZWN0aW9ucyBmcm9tIGdldHRpbmcgaW50b1xyXG5cdFx0Ly8gYW4gaW5maW5pdGUgbG9vcCBvZiB0aW55IG9mZnNldHMuXHJcblx0XHRpZiAob2Zmc2V0LnJvdW5kKCkuZXF1YWxzKFswLCAwXSkpIHtcclxuXHRcdFx0cmV0dXJuIGNlbnRlcjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBCb3VuZHModmlld0JvdW5kcy5taW4uYWRkKG9mZnNldCksIHZpZXdCb3VuZHMubWF4LmFkZChvZmZzZXQpKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobmV3Qm91bmRzLCBib3VuZHMpKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm5zIG9mZnNldCBuZWVkZWQgZm9yIHB4Qm91bmRzIHRvIGdldCBpbnNpZGUgbWF4Qm91bmRzIGF0IGEgc3BlY2lmaWVkIHpvb21cclxuXHRfZ2V0Qm91bmRzT2Zmc2V0OiBmdW5jdGlvbiAocHhCb3VuZHMsIG1heEJvdW5kcywgem9vbSkge1xyXG5cdFx0dmFyIHByb2plY3RlZE1heEJvdW5kcyA9IHRvQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKSxcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSlcclxuXHRcdCAgICApLFxyXG5cdFx0ICAgIG1pbk9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5taW4uc3VidHJhY3QocHhCb3VuZHMubWluKSxcclxuXHRcdCAgICBtYXhPZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWF4LnN1YnRyYWN0KHB4Qm91bmRzLm1heCksXHJcblxyXG5cdFx0ICAgIGR4ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueCwgLW1heE9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LnksIC1tYXhPZmZzZXQueSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tU25hcCA6IDE7XHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gc25hcCkgKiBzbmFwO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvblN0ZXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cdH0sXHJcblxyXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFBhbjogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykge1xyXG5cdFx0Ly8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIGN1cnJlbnQgY2VudGVycyBpbiBwaXhlbHNcclxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fdHJ1bmMoKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIHRvbyBmYXIgdW5sZXNzIGFuaW1hdGU6IHRydWUgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdHRoaXMucGFuQnkob2Zmc2V0LCBvcHRpb25zKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlQW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcclxuXHJcblx0XHR0aGlzLm9uKCd6b29tYW5pbScsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdHZhciBwcm9wID0gRG9tVXRpbC5UUkFOU0ZPUk0sXHJcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXTtcclxuXHJcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoZS5jZW50ZXIsIGUuem9vbSksIHRoaXMuZ2V0Wm9vbVNjYWxlKGUuem9vbSwgMSkpO1xyXG5cclxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcclxuXHRcdFx0aWYgKHRyYW5zZm9ybSA9PT0gdGhpcy5fcHJveHkuc3R5bGVbcHJvcF0gJiYgdGhpcy5fYW5pbWF0aW5nWm9vbSkge1xyXG5cdFx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYyA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHRcdCAgICB6ID0gdGhpcy5nZXRab29tKCk7XHJcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX29uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95QW5pbVByb3h5LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfZGVzdHJveUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcHJveHkpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG5cdH0sXHJcblxyXG5cdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSAmJiBlLnByb3BlcnR5TmFtZS5pbmRleE9mKCd0cmFuc2Zvcm0nKSA+PSAwKSB7XHJcblx0XHRcdHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICF0aGlzLl9jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVhZmxldC16b29tLWFuaW1hdGVkJykubGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdF90cnlBbmltYXRlZFpvb206IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgZGlzYWJsZWQsIG5vdCBzdXBwb3J0ZWQgb3Igem9vbSBkaWZmZXJlbmNlIGlzIHRvbyBsYXJnZVxyXG5cdFx0aWYgKCF0aGlzLl96b29tQW5pbWF0ZWQgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCB0aGlzLl9ub3RoaW5nVG9BbmltYXRlKCkgfHxcclxuXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ly8gb2Zmc2V0IGlzIHRoZSBwaXhlbCBjb29yZHMgb2YgdGhlIHpvb20gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2RpdmlkZUJ5KDEgLSAxIC8gc2NhbGUpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgem9vbWFuaW06IFpvb21BbmltRXZlbnRcclxuXHRcdC8vIEZpcmVkIG9uIGV2ZXJ5IGZyYW1lIG9mIGEgem9vbSBhbmltYXRpb25cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcclxuXHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsIHRoaXMpLCAyNTApO1xyXG5cdH0sXHJcblxyXG5cdF9vblpvb21UcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcFBhbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fbW92ZSh0aGlzLl9hbmltYXRlVG9DZW50ZXIsIHRoaXMuX2FuaW1hdGVUb1pvb20pO1xyXG5cclxuXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxyXG5cdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvTWFwLmpzIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0VhcnRofSBmcm9tICcuL2Nycy9DUlMuRWFydGgnO1xyXG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuL0xhdExuZ0JvdW5kcyc7XHJcblxyXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYExhdExuZ2AgZG9lcyBub3QgaW5oZXJpdCBmcm9tIExlYWZldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL0xhdExuZy5qcyIsImltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi9MYXRMbmcnO1xyXG5cclxuLypcclxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xyXG4gKiBAYWthIEwuTGF0TG5nQm91bmRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBnZW9ncmFwaGljYWwgYXJlYSBvbiBhIG1hcC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGNvcm5lcjEgPSBMLmxhdExuZyg0MC43MTIsIC03NC4yMjcpLFxyXG4gKiBjb3JuZXIyID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoY29ybmVyMSwgY29ybmVyMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZ0JvdW5kcyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZSBib3VuZHMgZXhhbXBsZSBhYm92ZSBjYW4gYmUgcGFzc2VkIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogbWFwLmZpdEJvdW5kcyhbXHJcbiAqIFx0WzQwLjcxMiwgLTc0LjIyN10sXHJcbiAqIFx0WzQwLjc3NCwgLTc0LjEyNV1cclxuICogXSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBDYXV0aW9uOiBpZiB0aGUgYXJlYSBjcm9zc2VzIHRoZSBhbnRpbWVyaWRpYW4gKG9mdGVuIGNvbmZ1c2VkIHdpdGggdGhlIEludGVybmF0aW9uYWwgRGF0ZSBMaW5lKSwgeW91IG11c3Qgc3BlY2lmeSBjb3JuZXJzIF9vdXRzaWRlXyB0aGUgWy0xODAsIDE4MF0gZGVncmVlcyBsb25naXR1ZGUgcmFuZ2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9MYXRMbmdCb3VuZHMuanMiLCJpbXBvcnQgeyBFbGVtZW50TWl4aW4gfSBmcm9tICcuL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzIG1ldGEtcHJvZ3JhbW1pbmdcbiAqIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLCBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLFxuICogYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvbi5cbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQHBvbHltZXJcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3NcbiAqICAga2V5IG1ldGEtcHJvZ3JhbW1pbmcgZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsXG4gKiAgIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb25cbiAqL1xuY29uc3QgRWxlbWVudCA9IEVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCk7XG5leHBvcnQgeyBFbGVtZW50IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgTGF5ZXJcbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBAYWthIEwuTGF5ZXJcbiAqIEBha2EgSUxheWVyXG4gKlxuICogQSBzZXQgb2YgbWV0aG9kcyBmcm9tIHRoZSBMYXllciBiYXNlIGNsYXNzIHRoYXQgYWxsIExlYWZsZXQgbGF5ZXJzIHVzZS5cbiAqIEluaGVyaXRzIGFsbCBtZXRob2RzLCBvcHRpb25zIGFuZCBldmVudHMgZnJvbSBgTC5FdmVudGVkYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF5ZXIgPSBMLk1hcmtlcihsYXRsbmcpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5hZGRUbyhtYXApO1xuICogbGF5ZXIucmVtb3ZlKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXZlbnQgYWRkOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIGFkZGVkIHRvIGEgbWFwXG4gKlxuICogQGV2ZW50IHJlbW92ZTogRXZlbnRcbiAqIEZpcmVkIGFmdGVyIHRoZSBsYXllciBpcyByZW1vdmVkIGZyb20gYSBtYXBcbiAqL1xuXG5cbmV4cG9ydCB2YXIgTGF5ZXIgPSBFdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYEwuTGF5ZXJgIHdpbGwgaW5oZXJpdCB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdvdmVybGF5UGFuZSdcblx0XHQvLyBCeSBkZWZhdWx0IHRoZSBsYXllciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAncyBbb3ZlcmxheSBwYW5lXSgjbWFwLW92ZXJsYXlwYW5lKS4gT3ZlcnJpZGluZyB0aGlzIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBsYXllciB0byBiZSBwbGFjZWQgb24gYW5vdGhlciBwYW5lIGJ5IGRlZmF1bHQuXG5cdFx0cGFuZTogJ292ZXJsYXlQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gYXR0cmlidXRpb246IFN0cmluZyA9IG51bGxcblx0XHQvLyBTdHJpbmcgdG8gYmUgc2hvd24gaW4gdGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wsIGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSwgZS5nLiBcIsKpIE1hcGJveFwiLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdHJlbW92ZUZyb206IGZ1bmN0aW9uIChvYmopIHtcblx0XHRpZiAob2JqKSB7XG5cdFx0XHRvYmoucmVtb3ZlTGF5ZXIodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShuYW1lPyA6IFN0cmluZyk6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgcmVwcmVzZW50aW5nIHRoZSBuYW1lZCBwYW5lIG9uIHRoZSBtYXAuIElmIGBuYW1lYCBpcyBvbWl0dGVkLCByZXR1cm5zIHRoZSBwYW5lIGZvciB0aGlzIGxheWVyLlxuXHRnZXRQYW5lOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0UGFuZShuYW1lID8gKHRoaXMub3B0aW9uc1tuYW1lXSB8fCBuYW1lKSA6IHRoaXMub3B0aW9ucy5wYW5lKTtcblx0fSxcblxuXHRhZGRJbnRlcmFjdGl2ZVRhcmdldDogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG5cdFx0dGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXSA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9tYXAuX3RhcmdldHNbVXRpbC5zdGFtcCh0YXJnZXRFbCldO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0X2xheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSBlLnRhcmdldDtcblxuXHRcdC8vIGNoZWNrIGluIGNhc2UgbGF5ZXIgZ2V0cyBhZGRlZCBhbmQgdGhlbiByZW1vdmVkIGJlZm9yZSB0aGUgbWFwIGlzIHJlYWR5XG5cdFx0aWYgKCFtYXAuaGFzTGF5ZXIodGhpcykpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XG5cblx0XHRpZiAodGhpcy5nZXRFdmVudHMpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLmdldEV2ZW50cygpO1xuXHRcdFx0bWFwLm9uKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR0aGlzLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bWFwLm9mZihldmVudHMsIHRoaXMpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbkFkZChtYXApO1xuXG5cdFx0aWYgKHRoaXMuZ2V0QXR0cmlidXRpb24gJiYgbWFwLmF0dHJpYnV0aW9uQ29udHJvbCkge1xuXHRcdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLmdldEF0dHJpYnV0aW9uICYmIHRoaXMuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbihsYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcblx0XHR9XG5cblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7bGF5ZXI6IGxheWVyfSk7XG5cdFx0XHRsYXllci5maXJlKCdyZW1vdmUnKTtcblx0XHR9XG5cblx0XHRsYXllci5fbWFwID0gbGF5ZXIuX21hcFRvQWRkID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBtYXBcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHJldHVybiAhIWxheWVyICYmIChVdGlsLnN0YW1wKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoaXNOYU4obGF5ZXIub3B0aW9ucy5tYXhab29tKSB8fCAhaXNOYU4obGF5ZXIub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGhpcy5fem9vbUJvdW5kTGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXSA9IGxheWVyO1xuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICh0aGlzLl96b29tQm91bmRMYXllcnNbaWRdKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWluWm9vbSA9IEluZmluaXR5LFxuXHRcdCAgICBtYXhab29tID0gLUluZmluaXR5LFxuXHRcdCAgICBvbGRab29tU3BhbiA9IHRoaXMuX2dldFpvb21TcGFuKCk7XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3pvb21Cb3VuZExheWVycykge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl96b29tQm91bmRMYXllcnNbaV0ub3B0aW9ucztcblxuXHRcdFx0bWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gbWluWm9vbSA6IE1hdGgubWluKG1pblpvb20sIG9wdGlvbnMubWluWm9vbSk7XG5cdFx0XHRtYXhab29tID0gb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgPyBtYXhab29tIDogTWF0aC5tYXgobWF4Wm9vbSwgb3B0aW9ucy5tYXhab29tKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gbWF4Wm9vbSA9PT0gLUluZmluaXR5ID8gdW5kZWZpbmVkIDogbWF4Wm9vbTtcblx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbSA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBtaW5ab29tO1xuXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcblx0XHQvLyBAZXZlbnQgem9vbWxldmVsc2NoYW5nZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBudW1iZXIgb2Ygem9vbWxldmVscyBvbiB0aGUgbWFwIGlzIGNoYW5nZWQgZHVlXG5cdFx0Ly8gdG8gYWRkaW5nIG9yIHJlbW92aW5nIGEgbGF5ZXIuXG5cdFx0aWYgKG9sZFpvb21TcGFuICE9PSB0aGlzLl9nZXRab29tU3BhbigpKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21sZXZlbHNjaGFuZ2UnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNYXhab29tICYmIHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5fbGF5ZXJzTWF4Wm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9sYXllcnNNaW5ab29tICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5fbGF5ZXJzTWluWm9vbSkge1xuXHRcdFx0dGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01pblpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0xheWVyLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyB1bmlxdWUgZ2xvYmFsIGlkIGZvciBkZWR1cGluZyBtaXhpbnMuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBNaXhpbkZ1bmN0aW9uKCl7fVxuLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG5NaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluQXBwbGljYXRpb25zO1xuLyoqIEB0eXBlIHsoT2JqZWN0IHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbmV4cG9ydCBjb25zdCBkZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgbGV0IG1peGluQXBwbGljYXRpb25zID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIGlmICghbWl4aW5BcHBsaWNhdGlvbnMpIHtcbiAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnMgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgfVxuICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICBsZXQgbWl4aW5EZWR1cGVJZCA9IGRlZHVwZUlkKys7XG4gIGZ1bmN0aW9uIGRlZHVwaW5nTWl4aW4oYmFzZSkge1xuICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICBpZiAoYmFzZVNldCAmJiBiYXNlU2V0W21peGluRGVkdXBlSWRdKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgbGV0IG1hcCA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIGxldCBleHRlbmRlZCA9IG1hcC5nZXQoYmFzZSk7XG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgZXh0ZW5kZWQgPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8obWl4aW4pKGJhc2UpO1xuICAgICAgbWFwLnNldChiYXNlLCBleHRlbmRlZCk7XG4gICAgfVxuICAgIC8vIGNvcHkgaW5oZXJpdGVkIG1peGluIHNldCBmcm9tIHRoZSBleHRlbmRlZCBjbGFzcywgb3IgdGhlIGJhc2UgY2xhc3NcbiAgICAvLyBOT1RFOiB3ZSBhdm9pZCB1c2Ugb2YgU2V0IGhlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXIgKElFMTEpXG4gICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgbGV0IG1peGluU2V0ID0gT2JqZWN0LmNyZWF0ZSgvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCB8fCBiYXNlU2V0IHx8IG51bGwpO1xuICAgIG1peGluU2V0W21peGluRGVkdXBlSWRdID0gdHJ1ZTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfVxuXG4gIHJldHVybiBkZWR1cGluZ01peGluO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanMiLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9IYW5kbGVyLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vKiogQHR5cGVkZWYge3tydW46IGZ1bmN0aW9uKGZ1bmN0aW9uKCksIG51bWJlcj0pOm51bWJlciwgY2FuY2VsOiBmdW5jdGlvbihudW1iZXIpfX0gKi9cbmxldCBBc3luY0ludGVyZmFjZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vLyBNaWNyb3Rhc2sgaW1wbGVtZW50ZWQgdXNpbmcgTXV0YXRpb24gT2JzZXJ2ZXJcbmxldCBtaWNyb3Rhc2tDdXJySGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tMYXN0SGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbmxldCBtaWNyb3Rhc2tOb2RlQ29udGVudCA9IDA7XG5sZXQgbWljcm90YXNrTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbm5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtaWNyb3Rhc2tGbHVzaCkub2JzZXJ2ZShtaWNyb3Rhc2tOb2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tGbHVzaCgpIHtcbiAgY29uc3QgbGVuID0gbWljcm90YXNrQ2FsbGJhY2tzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBjYiA9IG1pY3JvdGFza0NhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlOyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbWljcm90YXNrQ2FsbGJhY2tzLnNwbGljZSgwLCBsZW4pO1xuICBtaWNyb3Rhc2tMYXN0SGFuZGxlICs9IGxlbjtcbn1cblxuZXhwb3J0IGNvbnN0IHRpbWVPdXQgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3ViLW1vZHVsZSB3aXRoIHRoZSBhc3luYyBpbnRlcmZhY2UgcHJvdmlkaW5nIHRoZSBwcm92aWRlZFxuICAgKiBkZWxheS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIGNhbGxiYWNrcyBpbiBtc1xuICAgKiBAcmV0dXJuIHtBc3luY0ludGVyZmFjZX0gQW4gYXN5bmMgdGltZW91dCBpbnRlcmZhY2VcbiAgICovXG4gIGFmdGVyKGRlbGF5KSB7XG4gICAgcmV0dXJuICB7XG4gICAgICBydW4oZm4pIHsgcmV0dXJuIHNldFRpbWVvdXQoZm4sIGRlbGF5KTsgfSxcbiAgICAgIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgaW4gdGhlIG5leHQgdGFzay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bjogd2luZG93LnNldFRpbWVvdXQuYmluZCh3aW5kb3cpLFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYHRpbWVPdXRgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWw6IHdpbmRvdy5jbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpXG59O1xuXG5leHBvcnQgY29uc3QgYW5pbWF0aW9uRnJhbWUgPSB7XG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmFuaW1hdGlvbkZyYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBhbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbDogd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxufTtcblxuZXhwb3J0IGNvbnN0IGlkbGVQZXJpb2QgPSB7XG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdElkbGVDYWxsYmFja2AgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oSWRsZURlYWRsaW5lKX0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oZm4pIHtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgP1xuICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soZm4pIDpcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxNik7XG4gIH0sXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgaWRsZVBlcmlvZGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmlkbGVQZXJpb2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID9cbiAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaGFuZGxlKSA6XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBtaWNyb1Rhc2sgPSB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IG1pY3JvdGFzayB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihjYWxsYmFjaykge1xuICAgIG1pY3JvdGFza05vZGUudGV4dENvbnRlbnQgPSBtaWNyb3Rhc2tOb2RlQ29udGVudCsrO1xuICAgIG1pY3JvdGFza0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gbWljcm90YXNrQ3VyckhhbmRsZSsrO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgbWljcm9UYXNrYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgY29uc3QgaWR4ID0gaGFuZGxlIC0gbWljcm90YXNrTGFzdEhhbmRsZTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFzeW5jIGhhbmRsZTogJyArIGhhbmRsZSk7XG4gICAgICB9XG4gICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FzeW5jLmpzIiwiaW1wb3J0IHtDUlN9IGZyb20gJy4vQ1JTJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLkVhcnRoXG4gKlxuICogU2VydmVzIGFzIHRoZSBiYXNlIGZvciBDUlMgdGhhdCBhcmUgZ2xvYmFsIHN1Y2ggdGhhdCB0aGV5IGNvdmVyIHRoZSBlYXJ0aC5cbiAqIENhbiBvbmx5IGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIG90aGVyIENSUyBhbmQgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHksXG4gKiBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlIGEgYGNvZGVgLCBgcHJvamVjdGlvbmAgb3IgYHRyYW5zZm9ybWF0aW9uYC4gYGRpc3RhbmNlKClgIHJldHVybnNcbiAqIG1ldGVycy5cbiAqL1xuXG5leHBvcnQgdmFyIEVhcnRoID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHR3cmFwTG5nOiBbLTE4MCwgMTgwXSxcblxuXHQvLyBNZWFuIEVhcnRoIFJhZGl1cywgYXMgcmVjb21tZW5kZWQgZm9yIHVzZSBieVxuXHQvLyB0aGUgSW50ZXJuYXRpb25hbCBVbmlvbiBvZiBHZW9kZXN5IGFuZCBHZW9waHlzaWNzLFxuXHQvLyBzZWUgaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcblx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0ICcuLi91dGlscy9zZXR0aW5ncy5qcyc7XG5pbXBvcnQgeyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIH0gZnJvbSAnLi4vdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IGZsdXNoIGFzIGZsdXNoJDAsIGVucXVldWVEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5cbmNvbnN0IHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbi8qKlxuICogQGNvbnN0IHtmdW5jdGlvbih0aGlzOkVsZW1lbnQsIHN0cmluZyk6IGJvb2xlYW59XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gYGVsZW1lbnQubWF0Y2hlc2Agc2hpbS5cbiAqXG4gKiBAZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yXG4gKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGVjayBzZWxlY3RvciBhZ2FpbnN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gbWF0Y2hcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbm9kZSBtYXRjaGVkIHNlbGVjdG9yXG4gKi9cbmNvbnN0IG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xufTtcblxuLyoqXG4gKiBOb2RlIEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gKiBgdGFyZ2V0YCBpcyBhIGBOb2RlYC5cbiAqL1xuY2xhc3MgRG9tQXBpIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIFBvbHltZXIuZG9tIGhlbHBlciBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIHRoYXRcbiAgICogbGlzdGVucyBmb3Igbm9kZSBjaGFuZ2VzIG9uIHRoaXMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gZGlyZWN0IG9yIGRpc3RyaWJ1dGVkIGNoaWxkcmVuXG4gICAqICAgb2YgdGhpcyBlbGVtZW50IGNoYW5nZXNcbiAgICogQHJldHVybiB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBPYnNlcnZlciBpbnN0YW5jZVxuICAgKi9cbiAgb2JzZXJ2ZU5vZGVzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMubm9kZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuIG9ic2VydmVyIHByZXZpb3VzbHkgY3JlYXRlZCB2aWEgYG9ic2VydmVOb2Rlc2BcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IG9ic2VydmVySGFuZGxlIE9ic2VydmVyIGluc3RhbmNlXG4gICAqICAgdG8gZGlzY29ubmVjdC5cbiAgICovXG4gIHVub2JzZXJ2ZU5vZGVzKG9ic2VydmVySGFuZGxlKSB7XG4gICAgb2JzZXJ2ZXJIYW5kbGUuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVkIGFzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgQVBJIG9ubHkuICBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqL1xuICBub3RpZnlPYnNlcnZlcigpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgbm9kZSBpcyBjb250YWluZWQgd2l0aCB0aGlzIGVsZW1lbnQnc1xuICAgKiBsaWdodC1ET00gY2hpbGRyZW4gb3Igc2hhZG93IHJvb3QsIGluY2x1ZGluZyBhbnkgbmVzdGVkIHNoYWRvdyByb290c1xuICAgKiBvZiBjaGlsZHJlbiB0aGVyZWluLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byB0ZXN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGNvbnRhaW5lZCB3aXRoaW5cbiAgICogICB0aGlzIGVsZW1lbnQncyBsaWdodCBvciBzaGFkb3cgRE9NLlxuICAgKi9cbiAgZGVlcENvbnRhaW5zKG5vZGUpIHtcbiAgICBpZiAodGhpcy5ub2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG4gPSBub2RlO1xuICAgIGxldCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gd2FsayBmcm9tIG5vZGUgdG8gYHRoaXNgIG9yIGBkb2N1bWVudGBcbiAgICB3aGlsZSAobiAmJiBuICE9PSBkb2MgJiYgbiAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAvLyB1c2UgbG9naWNhbCBwYXJlbnRub2RlLCBvciBuYXRpdmUgU2hhZG93Um9vdCBob3N0XG4gICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIG4gPT09IHRoaXMubm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBub2RlLiAgRXF1aXZhbGVudCB0byBgZ2V0Um9vZE5vZGUoKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRvcCBtb3N0IGVsZW1lbnQgaW4gdGhlIGRvbSB0cmVlIGluIHdoaWNoIHRoZSBub2RlXG4gICAqIGV4aXN0cy4gSWYgdGhlIG5vZGUgaXMgY29ubmVjdGVkIHRvIGEgZG9jdW1lbnQgdGhpcyBpcyBlaXRoZXIgYVxuICAgKiBzaGFkb3dSb290IG9yIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBpdCBtYXkgYmUgdGhlIG5vZGVcbiAgICogaXRzZWxmIG9yIGEgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIGl0LlxuICAgKi9cbiAgZ2V0T3duZXJSb290KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc2xvdCBlbGVtZW50cywgcmV0dXJucyB0aGUgbm9kZXMgYXNzaWduZWQgdG8gdGhlIHNsb3Q7IG90aGVyd2lzZVxuICAgKiBhbiBlbXB0eSBhcnJheS4gSXQgaXMgZXF1aXZhbGVudCB0byBgPHNsb3Q+LmFkZGlnbmVkTm9kZXMoe2ZsYXR0ZW46dHJ1ZX0pYC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IEFycmF5IG9mIGFzc2lnbmVkIG5vZGVzXG4gICAqL1xuICBnZXREaXN0cmlidXRlZE5vZGVzKCkge1xuICAgIHJldHVybiAodGhpcy5ub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSA/XG4gICAgICB0aGlzLm5vZGUuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pIDpcbiAgICAgIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHNsb3RzIHRoaXMgZWxlbWVudCB3YXMgZGlzdHJpYnV0ZWQgdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxTbG90RWxlbWVudD59IERlc2NyaXB0aW9uXG4gICAqL1xuICBnZXREZXN0aW5hdGlvbkluc2VydGlvblBvaW50cygpIHtcbiAgICBsZXQgaXAkID0gW107XG4gICAgbGV0IG4gPSB0aGlzLm5vZGUuYXNzaWduZWRTbG90O1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpcCQucHVzaChuKTtcbiAgICAgIG4gPSBuLmFzc2lnbmVkU2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIGlwJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBvd25lckRvY3VtZW50YCBmb3IgdGhpcyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBpbXBvcnRcbiAgICogQHBhcmFtIHtib29sZWFufSBkZWVwIFRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIGNsb25lZCBkZWVwbHkgZHVyaW5nXG4gICAqICAgaW1wb3J0XG4gICAqIEByZXR1cm4ge05vZGV9IENsb25lIG9mIGdpdmVuIG5vZGUgaW1wb3J0ZWQgdG8gdGhpcyBvd25lciBkb2N1bWVudFxuICAgKi9cbiAgaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG4gICAgbGV0IGRvYyA9IHRoaXMubm9kZSBpbnN0YW5jZW9mIERvY3VtZW50ID8gdGhpcy5ub2RlIDpcbiAgICAgIHRoaXMubm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBkb2MuaW1wb3J0Tm9kZShub2RlLCBkZWVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIGFsbCBjaGlsZCBub2RlcyBhbmQgbm9kZXMgYXNzaWduZWRcbiAgICogdG8gY2hpbGQgc2xvdHMuXG4gICAqL1xuICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgIHJldHVybiBGbGF0dGVuZWROb2Rlc09ic2VydmVyLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMubm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZpbHRlcmVkIGxpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzIGZvciB0aGlzIGVsZW1lbnQgYmFzZWRcbiAgICogb24gdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gZmlsdGVyIG5vZGVzIGFnYWluc3RcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50c1xuICAgKi9cbiAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgbGV0IGMkID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgbGV0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpPTAsIGw9YyQubGVuZ3RoLCBjOyAoaTxsKSAmJiAoYz1jJFtpXSk7IGkrKykge1xuICAgICAgaWYgKChjLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiZcbiAgICAgICAgICBtYXRjaGVzU2VsZWN0b3IoYywgc2VsZWN0b3IpKSB7XG4gICAgICAgIGxpc3QucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHNoYWRvdyByb290cywgcmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB3aXRoaW4gdGhpc1xuICAgKiBzaGFkb3cgcm9vdC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IEN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICovXG4gIGdldCBhY3RpdmVFbGVtZW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5ub2RlO1xuICAgIHJldHVybiBub2RlLl9hY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBub2RlLl9hY3RpdmVFbGVtZW50IDogbm9kZS5hY3RpdmVFbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRNZXRob2RzKHByb3RvLCBtZXRob2RzKSB7XG4gIGZvciAobGV0IGk9MDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICBwcm90b1ttZXRob2RdID0gLyoqIEB0aGlzIHtEb21BcGl9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVttZXRob2RdLmFwcGx5KHRoaXMubm9kZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yd2FyZFByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mb3J3YXJkTWV0aG9kcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICdjbG9uZU5vZGUnLCAnYXBwZW5kQ2hpbGQnLCAnaW5zZXJ0QmVmb3JlJywgJ3JlbW92ZUNoaWxkJyxcbiAgJ3JlcGxhY2VDaGlsZCcsICdzZXRBdHRyaWJ1dGUnLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgJ3F1ZXJ5U2VsZWN0b3InLCAncXVlcnlTZWxlY3RvckFsbCdcbl0pO1xuXG5mb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgJ3BhcmVudE5vZGUnLCAnZmlyc3RDaGlsZCcsICdsYXN0Q2hpbGQnLFxuICAnbmV4dFNpYmxpbmcnLCAncHJldmlvdXNTaWJsaW5nJywgJ2ZpcnN0RWxlbWVudENoaWxkJyxcbiAgJ2xhc3RFbGVtZW50Q2hpbGQnLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnLFxuICAnY2hpbGROb2RlcycsICdjaGlsZHJlbicsICdjbGFzc0xpc3QnXG5dKTtcblxuZm9yd2FyZFByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJ1xuXSk7XG5cblxuLyoqXG4gKiBFdmVudCBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICogYHRhcmdldGAgaXMgYW4gYEV2ZW50YC5cbiAqL1xuY2xhc3MgRXZlbnRBcGkge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIG9uIHRoZSBgY29tcG9zZWRQYXRoYCBvZiB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZSB0aGlzIGV2ZW50IHdhcyBkaXNwYXRjaGVkIHRvXG4gICAqL1xuICBnZXQgcm9vdFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIGxvY2FsIChyZS10YXJnZXRlZCkgdGFyZ2V0IGZvciB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGxvY2FsVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgY29tcG9zZWRQYXRoYCBmb3IgdGhpcyBldmVudC5cbiAgICovXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydCB7IERvbUFwaSB9O1xuXG5leHBvcnQgY29uc3QgZG9tID0gZnVuY3Rpb24ob2JqKSB7XG4gIG9iaiA9IG9iaiB8fCBkb2N1bWVudDtcbiAgaWYgKCFvYmouX19kb21BcGkpIHtcbiAgICBsZXQgaGVscGVyO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgaGVscGVyID0gbmV3IEV2ZW50QXBpKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlbHBlciA9IG5ldyBEb21BcGkob2JqKTtcbiAgICB9XG4gICAgb2JqLl9fZG9tQXBpID0gaGVscGVyO1xuICB9XG4gIHJldHVybiBvYmouX19kb21BcGk7XG59O1xuXG5leHBvcnQgeyBtYXRjaGVzU2VsZWN0b3IgfTtcbmV4cG9ydCB7IGZsdXNoJDAgYXMgZmx1c2ggfTtcbmV4cG9ydCB7IGVucXVldWVEZWJvdW5jZXIgYXMgYWRkRGVib3VuY2VyIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyIsImltcG9ydCB7TGF5ZXJHcm91cH0gZnJvbSAnLi9MYXllckdyb3VwJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uL2dlby9MYXRMbmdCb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIEZlYXR1cmVHcm91cFxyXG4gKiBAYWthIEwuRmVhdHVyZUdyb3VwXHJcbiAqIEBpbmhlcml0cyBMYXllckdyb3VwXHJcbiAqXHJcbiAqIEV4dGVuZGVkIGBMYXllckdyb3VwYCB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBkbyB0aGUgc2FtZSB0aGluZyB0byBhbGwgaXRzIG1lbWJlciBsYXllcnM6XHJcbiAqICAqIFtgYmluZFBvcHVwYF0oI2xheWVyLWJpbmRwb3B1cCkgYmluZHMgYSBwb3B1cCB0byBhbGwgb2YgdGhlIGxheWVycyBhdCBvbmNlIChsaWtld2lzZSB3aXRoIFtgYmluZFRvb2x0aXBgXSgjbGF5ZXItYmluZHRvb2x0aXApKVxyXG4gKiAgKiBFdmVudHMgYXJlIHByb3BhZ2F0ZWQgdG8gdGhlIGBGZWF0dXJlR3JvdXBgLCBzbyBpZiB0aGUgZ3JvdXAgaGFzIGFuIGV2ZW50XHJcbiAqIGhhbmRsZXIsIGl0IHdpbGwgaGFuZGxlIGV2ZW50cyBmcm9tIGFueSBvZiB0aGUgbGF5ZXJzLiBUaGlzIGluY2x1ZGVzIG1vdXNlIGV2ZW50c1xyXG4gKiBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICogICogSGFzIGBsYXllcmFkZGAgYW5kIGBsYXllcnJlbW92ZWAgZXZlbnRzXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwuZmVhdHVyZUdyb3VwKFttYXJrZXIxLCBtYXJrZXIyLCBwb2x5bGluZV0pXHJcbiAqIFx0LmJpbmRQb3B1cCgnSGVsbG8gd29ybGQhJylcclxuICogXHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGFsZXJ0KCdDbGlja2VkIG9uIGEgbWVtYmVyIG9mIHRoZSBncm91cCEnKTsgfSlcclxuICogXHQuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBGZWF0dXJlR3JvdXAgPSBMYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMYXllckdyb3VwLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsIGxheWVyKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbGF5ZXJhZGQ6IExheWVyRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBsYXllciBpcyBhZGRlZCB0byB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBnaXZlbiBwYXRoIG9wdGlvbnMgdG8gZWFjaCBsYXllciBvZiB0aGUgZ3JvdXAgdGhhdCBoYXMgYSBgc2V0U3R5bGVgIG1ldGhvZC5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFN0eWxlJywgc3R5bGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIGxheWVyc1xyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvRnJvbnQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIGdyb3VwIHRvIHRoZSBiYWNrIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdGJvdW5kcy5leHRlbmQobGF5ZXIuZ2V0Qm91bmRzID8gbGF5ZXIuZ2V0Qm91bmRzKCkgOiBsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmZlYXR1cmVHcm91cChsYXllcnM6IExheWVyW10pXHJcbi8vIENyZWF0ZSBhIGZlYXR1cmUgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzLlxyXG5leHBvcnQgdmFyIGZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEZlYXR1cmVHcm91cChsYXllcnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ZlYXR1cmVHcm91cC5qcyIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRXZlbnRzID0ge1xyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0LyogQG1ldGhvZCBvZmYodHlwZTogU3RyaW5nLCBmbj86IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIG9mIHRoYXQgcGFydGljdWxhciBldmVudCBmcm9tIHRoZSBvYmplY3QuIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gYG9uYCwgeW91IG11c3QgcGFzcyB0aGUgc2FtZSBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9mZihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycy5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgb24gdGhlIG9iamVjdC5cclxuXHQgKi9cclxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgaWYgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzXHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcclxuXHJcblx0XHQvKiBnZXQvaW5pdCBsaXN0ZW5lcnMgZm9yIHR5cGUgKi9cclxuXHRcdHZhciB0eXBlTGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0aWYgKCF0eXBlTGlzdGVuZXJzKSB7XHJcblx0XHRcdHR5cGVMaXN0ZW5lcnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gdHlwZUxpc3RlbmVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR2YXIgbmV3TGlzdGVuZXIgPSB7Zm46IGZuLCBjdHg6IGNvbnRleHR9LFxyXG5cdFx0ICAgIGxpc3RlbmVycyA9IHR5cGVMaXN0ZW5lcnM7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgZm4gYWxyZWFkeSB0aGVyZVxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbiAmJiBsaXN0ZW5lcnNbaV0uY3R4ID09PSBjb250ZXh0KSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGlzdGVuZXJzLnB1c2gobmV3TGlzdGVuZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyxcclxuXHRcdCAgICBpLFxyXG5cdFx0ICAgIGxlbjtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2V2ZW50cykgeyByZXR1cm47IH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblxyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm4pIHtcclxuXHRcdFx0Ly8gU2V0IGFsbCByZW1vdmVkIGxpc3RlbmVycyB0byBub29wIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uZm4gPSBVdGlsLmZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHRcdFx0LyogY29weSBhcnJheSBpbiBjYXNlIGV2ZW50cyBhcmUgYmVpbmcgZmlyZWQgKi9cclxuXHRcdFx0XHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpcmUodHlwZTogU3RyaW5nLCBkYXRhPzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gWW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYW4gZGF0YVxyXG5cdC8vIG9iamVjdCDigJQgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB3aWxsIGNvbnRhaW4gaXRzXHJcblx0Ly8gcHJvcGVydGllcy4gVGhlIGV2ZW50IGNhbiBvcHRpb25hbGx5IGJlIHByb3BhZ2F0ZWQgdG8gZXZlbnQgcGFyZW50cy5cclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMubGlzdGVucyh0eXBlLCBwcm9wYWdhdGUpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gVXRpbC5leHRlbmQoe30sIGRhdGEsIHtcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzLFxyXG5cdFx0XHRzb3VyY2VUYXJnZXQ6IGRhdGEgJiYgZGF0YS5zb3VyY2VUYXJnZXQgfHwgdGhpc1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tVdGlsLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIFV0aWwuZXh0ZW5kKHtcclxuXHRcdFx0XHRsYXllcjogZS50YXJnZXQsXHJcblx0XHRcdFx0cHJvcGFnYXRlZEZyb206IGUudGFyZ2V0XHJcblx0XHRcdH0sIGUpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbkV2ZW50cy5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uO1xyXG5cclxuLy8gQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvZmYo4oCmKWBdKCNldmVudGVkLW9mZilcclxuXHJcbi8vIEBtZXRob2QgY2xlYXJBbGxFdmVudExpc3RlbmVycyjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKClgXSgjZXZlbnRlZC1vZmYpXHJcbkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMgPSBFdmVudHMub2ZmO1xyXG5cclxuLy8gQG1ldGhvZCBhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb25jZSjigKYpYF0oI2V2ZW50ZWQtb25jZSlcclxuRXZlbnRzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gRXZlbnRzLm9uY2U7XHJcblxyXG4vLyBAbWV0aG9kIGZpcmVFdmVudCjigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgZmlyZSjigKYpYF0oI2V2ZW50ZWQtZmlyZSlcclxuRXZlbnRzLmZpcmVFdmVudCA9IEV2ZW50cy5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxuRXZlbnRzLmhhc0V2ZW50TGlzdGVuZXJzID0gRXZlbnRzLmxpc3RlbnM7XHJcblxyXG5leHBvcnQgdmFyIEV2ZW50ZWQgPSBDbGFzcy5leHRlbmQoRXZlbnRzKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb3JlL0V2ZW50cy5qcyIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDbGFzcygpIHt9XHJcblxyXG5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChwcm9wczogT2JqZWN0KTogRnVuY3Rpb25cclxuXHQvLyBbRXh0ZW5kcyB0aGUgY3VycmVudCBjbGFzc10oI2NsYXNzLWluaGVyaXRhbmNlKSBnaXZlbiB0aGUgcHJvcGVydGllcyB0byBiZSBpbmNsdWRlZC5cclxuXHQvLyBSZXR1cm5zIGEgSmF2YXNjcmlwdCBmdW5jdGlvbiB0aGF0IGlzIGEgY2xhc3MgY29uc3RydWN0b3IgKHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgKS5cclxuXHR2YXIgTmV3Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gY2FsbCB0aGUgY29uc3RydWN0b3JcclxuXHRcdGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FsbCBhbGwgY29uc3RydWN0b3IgaG9va3NcclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cdH07XHJcblxyXG5cdHZhciBwYXJlbnRQcm90byA9IE5ld0NsYXNzLl9fc3VwZXJfXyA9IHRoaXMucHJvdG90eXBlO1xyXG5cclxuXHR2YXIgcHJvdG8gPSBVdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScgJiYgaSAhPT0gJ19fc3VwZXJfXycpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdFV0aWwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0Y2hlY2tEZXByZWNhdGVkTWl4aW5FdmVudHMocHJvcHMuaW5jbHVkZXMpO1xyXG5cdFx0VXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5pbmNsdWRlcztcclxuXHR9XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvcHMub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKFV0aWwuY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdFV0aWwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkNsYXNzLmluY2x1ZGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHRVdGlsLmV4dGVuZCh0aGlzLnByb3RvdHlwZSwgcHJvcHMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0aWYgKHR5cGVvZiBMID09PSAndW5kZWZpbmVkJyB8fCAhTCB8fCAhTC5NaXhpbikgeyByZXR1cm47IH1cclxuXHJcblx0aW5jbHVkZXMgPSBVdGlsLmlzQXJyYXkoaW5jbHVkZXMpID8gaW5jbHVkZXMgOiBbaW5jbHVkZXNdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaW5jbHVkZXNbaV0gPT09IEwuTWl4aW4uRXZlbnRzKSB7XHJcblx0XHRcdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCBpbmNsdWRlIG9mIEwuTWl4aW4uRXZlbnRzOiAnICtcclxuXHRcdFx0XHQndGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzLCAnICtcclxuXHRcdFx0XHQncGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC4nLCBuZXcgRXJyb3IoKS5zdGFjayk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9DbGFzcy5qcyIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uLmpzIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBQYXRoXG4gKiBAYWthIEwuUGF0aFxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXG4gKlxuICogQW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBjb250YWlucyBvcHRpb25zIGFuZCBjb25zdGFudHMgc2hhcmVkIGJldHdlZW4gdmVjdG9yXG4gKiBvdmVybGF5cyAoUG9seWdvbiwgUG9seWxpbmUsIENpcmNsZSkuIERvIG5vdCB1c2UgaXQgZGlyZWN0bHkuIEV4dGVuZHMgYExheWVyYC5cbiAqL1xuXG5leHBvcnQgdmFyIFBhdGggPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUGF0aCBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHN0cm9rZTogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGV0aGVyIHRvIGRyYXcgc3Ryb2tlIGFsb25nIHRoZSBwYXRoLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGJvcmRlcnMgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRzdHJva2U6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGNvbG9yOiBTdHJpbmcgPSAnIzMzODhmZidcblx0XHQvLyBTdHJva2UgY29sb3Jcblx0XHRjb2xvcjogJyMzMzg4ZmYnLFxuXG5cdFx0Ly8gQG9wdGlvbiB3ZWlnaHQ6IE51bWJlciA9IDNcblx0XHQvLyBTdHJva2Ugd2lkdGggaW4gcGl4ZWxzXG5cdFx0d2VpZ2h0OiAzLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBTdHJva2Ugb3BhY2l0eVxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVDYXA6IFN0cmluZz0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgZW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lY2FwKSBvZiB0aGUgc3Ryb2tlLlxuXHRcdGxpbmVDYXA6ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGxpbmVKb2luOiBTdHJpbmcgPSAncm91bmQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtzaGFwZSB0byBiZSB1c2VkIGF0IHRoZSBjb3JuZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1saW5lam9pbikgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lSm9pbjogJ3JvdW5kJyxcblxuXHRcdC8vIEBvcHRpb24gZGFzaEFycmF5OiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIHRoZSBzdHJva2UgW2Rhc2ggcGF0dGVybl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5KS4gRG9lc24ndCB3b3JrIG9uIGBDYW52YXNgLXBvd2VyZWQgbGF5ZXJzIGluIFtzb21lIG9sZCBicm93c2Vyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHkpLlxuXHRcdGRhc2hBcnJheTogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZGFzaE9mZnNldDogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgW2Rpc3RhbmNlIGludG8gdGhlIGRhc2ggcGF0dGVybiB0byBzdGFydCB0aGUgZGFzaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaG9mZnNldCkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoT2Zmc2V0OiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsOiBCb29sZWFuID0gZGVwZW5kc1xuXHRcdC8vIFdoZXRoZXIgdG8gZmlsbCB0aGUgcGF0aCB3aXRoIGNvbG9yLiBTZXQgaXQgdG8gYGZhbHNlYCB0byBkaXNhYmxlIGZpbGxpbmcgb24gcG9seWdvbnMgb3IgY2lyY2xlcy5cblx0XHRmaWxsOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gZmlsbENvbG9yOiBTdHJpbmcgPSAqXG5cdFx0Ly8gRmlsbCBjb2xvci4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIHRoZSBbYGNvbG9yYF0oI3BhdGgtY29sb3IpIG9wdGlvblxuXHRcdGZpbGxDb2xvcjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbE9wYWNpdHk6IE51bWJlciA9IDAuMlxuXHRcdC8vIEZpbGwgb3BhY2l0eS5cblx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXG5cdFx0Ly8gQG9wdGlvbiBmaWxsUnVsZTogU3RyaW5nID0gJ2V2ZW5vZGQnXG5cdFx0Ly8gQSBzdHJpbmcgdGhhdCBkZWZpbmVzIFtob3cgdGhlIGluc2lkZSBvZiBhIHNoYXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZSkgaXMgZGV0ZXJtaW5lZC5cblx0XHRmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuXG5cdFx0Ly8gY2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3Ncblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gYnViYmxpbmdNb3VzZUV2ZW50czogQm9vbGVhbiA9IHRydWVcblx0XHQvLyBXaGVuIGB0cnVlYCwgYSBtb3VzZSBldmVudCBvbiB0aGlzIHBhdGggd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cblx0XHRidWJibGluZ01vdXNlRXZlbnRzOiB0cnVlXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0Ly8gUmVuZGVyZXIgaXMgc2V0IGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhbGwgcmVuZGVyZXIuZ2V0RXZlbnRzXG5cdFx0Ly8gYmVmb3JlIHRoaXMuZ2V0RXZlbnRzLlxuXHRcdHRoaXMuX3JlbmRlcmVyID0gbWFwLmdldFJlbmRlcmVyKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fcmVtb3ZlUGF0aCh0aGlzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdygpOiB0aGlzXG5cdC8vIFJlZHJhd3MgdGhlIGxheWVyLiBTb21ldGltZXMgdXNlZnVsIGFmdGVyIHlvdSBjaGFuZ2VkIHRoZSBjb29yZGluYXRlcyB0aGF0IHRoZSBwYXRoIHVzZXMuXG5cdHJlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENoYW5nZXMgdGhlIGFwcGVhcmFuY2Ugb2YgYSBQYXRoIGJhc2VkIG9uIHRoZSBvcHRpb25zIGluIHRoZSBgUGF0aCBvcHRpb25zYCBvYmplY3QuXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVN0eWxlKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICsgdGhpcy5fcmVuZGVyZXIub3B0aW9ucy50b2xlcmFuY2U7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvUGF0aC5qcyIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW0RvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobSkuXHJcbi8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuLy8gZWFjaCB6b29tIGxldmVsIGFuZCBhbHNvIHJlZHVjaW5nIHZpc3VhbCBub2lzZS4gdG9sZXJhbmNlIGFmZmVjdHMgdGhlIGFtb3VudCBvZlxyXG4vLyBzaW1wbGlmaWNhdGlvbiAobGVzc2VyIHZhbHVlIG1lYW5zIGhpZ2hlciBxdWFsaXR5IGJ1dCBzbG93ZXIgYW5kIHdpdGggbW9yZSBwb2ludHMpLlxyXG4vLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwOi8vbW91cm5lci5naXRodWIuY29tL3NpbXBsaWZ5LWpzLykuXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdGlmICghdG9sZXJhbmNlIHx8ICFwb2ludHMubGVuZ3RoKSB7XHJcblx0XHRyZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdCAgICAvLyBzdGFnZSAyOiBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb25cclxuXHQgICAgcG9pbnRzID0gX3NpbXBsaWZ5RFAocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50IGBwYCBhbmQgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHAxLCBwMikge1xyXG5cdHJldHVybiBNYXRoLnNxcnQoX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY2xvc2VzdFBvaW50T25TZWdtZW50KHA6IFBvaW50LCBwMTogUG9pbnQsIHAyOiBQb2ludCk6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBjbG9zZXN0IHBvaW50IGZyb20gYSBwb2ludCBgcGAgb24gYSBzZWdtZW50IGBwMWAgdG8gYHAyYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcbn1cclxuXHJcbi8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5mdW5jdGlvbiBfc2ltcGxpZnlEUChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblxyXG5cdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG5cdCAgICBtYXJrZXJzID0gbmV3IEFycmF5Q29uc3RydWN0b3IobGVuKTtcclxuXHJcblx0ICAgIG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcblx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHR2YXIgaSxcclxuXHQgICAgbmV3UG9pbnRzID0gW107XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0bmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXdQb2ludHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuXHR2YXIgbWF4U3FEaXN0ID0gMCxcclxuXHRpbmRleCwgaSwgc3FEaXN0O1xyXG5cclxuXHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0c3FEaXN0ID0gX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0bWF4U3FEaXN0ID0gc3FEaXN0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0X3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBpbmRleCk7XHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5mdW5jdGlvbiBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0aWYgKF9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdHByZXYgPSBpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldiA8IGxlbiAtIDEpIHtcclxuXHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVkdWNlZFBvaW50cztcclxufVxyXG5cclxudmFyIF9sYXN0Q29kZTtcclxuXHJcbi8vIEBmdW5jdGlvbiBjbGlwU2VnbWVudChhOiBQb2ludCwgYjogUG9pbnQsIGJvdW5kczogQm91bmRzLCB1c2VMYXN0Q29kZT86IEJvb2xlYW4sIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W118Qm9vbGVhblxyXG4vLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcbi8vIFtDb2hlbi1TdXRoZXJsYW5kIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29oZW4lRTIlODAlOTNTdXRoZXJsYW5kX2FsZ29yaXRobSlcclxuLy8gKG1vZGlmeWluZyB0aGUgc2VnbWVudCBwb2ludHMgZGlyZWN0bHkhKS4gVXNlZCBieSBMZWFmbGV0IHRvIG9ubHkgc2hvdyBwb2x5bGluZVxyXG4vLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFNlZ21lbnQoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IF9sYXN0Q29kZSA6IF9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0ICAgIGNvZGVCID0gX2dldEJpdENvZGUoYiwgYm91bmRzKSxcclxuXHJcblx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdCAgICAvLyBzYXZlIDJuZCBjb2RlIHRvIGF2b2lkIGNhbGN1bGF0aW5nIGl0IG9uIHRoZSBuZXh0IHNlZ21lbnRcclxuXHQgICAgX2xhc3RDb2RlID0gY29kZUI7XHJcblxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xyXG5cdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGEsYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCByZWplY3QpXHJcblx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdHAgPSBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdG5ld0NvZGUgPSBfZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cclxuXHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRhID0gcDtcclxuXHRcdFx0Y29kZUEgPSBuZXdDb2RlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YiA9IHA7XHJcblx0XHRcdGNvZGVCID0gbmV3Q29kZTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGR4ID0gYi54IC0gYS54LFxyXG5cdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHQgICAgbWF4ID0gYm91bmRzLm1heCxcclxuXHQgICAgeCwgeTtcclxuXHJcblx0aWYgKGNvZGUgJiA4KSB7IC8vIHRvcFxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1heC55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG5cdFx0eCA9IGEueCArIGR4ICogKG1pbi55IC0gYS55KSAvIGR5O1xyXG5cdFx0eSA9IG1pbi55O1xyXG5cclxuXHR9IGVsc2UgaWYgKGNvZGUgJiAyKSB7IC8vIHJpZ2h0XHJcblx0XHR4ID0gbWF4Lng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDEpIHsgLy8gbGVmdFxyXG5cdFx0eCA9IG1pbi54O1xyXG5cdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qml0Q29kZShwLCBib3VuZHMpIHtcclxuXHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdGlmIChwLnggPCBib3VuZHMubWluLngpIHsgLy8gbGVmdFxyXG5cdFx0Y29kZSB8PSAxO1xyXG5cdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRjb2RlIHw9IDI7XHJcblx0fVxyXG5cclxuXHRpZiAocC55IDwgYm91bmRzLm1pbi55KSB7IC8vIGJvdHRvbVxyXG5cdFx0Y29kZSB8PSA0O1xyXG5cdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0Y29kZSB8PSA4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNvZGU7XHJcbn1cclxuXHJcbi8vIHNxdWFyZSBkaXN0YW5jZSAodG8gYXZvaWQgdW5uZWNlc3NhcnkgTWF0aC5zcXJ0IGNhbGxzKVxyXG5mdW5jdGlvbiBfc3FEaXN0KHAxLCBwMikge1xyXG5cdHZhciBkeCA9IHAyLnggLSBwMS54LFxyXG5cdCAgICBkeSA9IHAyLnkgLSBwMS55O1xyXG5cdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGNsb3Nlc3QgcG9pbnQgb24gc2VnbWVudCBvciBkaXN0YW5jZSB0byB0aGF0IHBvaW50XHJcbmV4cG9ydCBmdW5jdGlvbiBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyLCBzcURpc3QpIHtcclxuXHR2YXIgeCA9IHAxLngsXHJcblx0ICAgIHkgPSBwMS55LFxyXG5cdCAgICBkeCA9IHAyLnggLSB4LFxyXG5cdCAgICBkeSA9IHAyLnkgLSB5LFxyXG5cdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHQgICAgdDtcclxuXHJcblx0aWYgKGRvdCA+IDApIHtcclxuXHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0aWYgKHQgPiAxKSB7XHJcblx0XHRcdHggPSBwMi54O1xyXG5cdFx0XHR5ID0gcDIueTtcclxuXHRcdH0gZWxzZSBpZiAodCA+IDApIHtcclxuXHRcdFx0eCArPSBkeCAqIHQ7XHJcblx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHggPSBwLnggLSB4O1xyXG5cdGR5ID0gcC55IC0geTtcclxuXHJcblx0cmV0dXJuIHNxRGlzdCA/IGR4ICogZHggKyBkeSAqIGR5IDogbmV3IFBvaW50KHgsIHkpO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzOiBMYXRMbmdbXSk6IEJvb2xlYW5cclxuLy8gUmV0dXJucyB0cnVlIGlmIGBsYXRsbmdzYCBpcyBhIGZsYXQgYXJyYXksIGZhbHNlIGlzIG5lc3RlZC5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmxhdChsYXRsbmdzKSB7XHJcblx0cmV0dXJuICFVdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX2ZsYXQobGF0bG5ncykge1xyXG5cdGNvbnNvbGUud2FybignRGVwcmVjYXRlZCB1c2Ugb2YgX2ZsYXQsIHBsZWFzZSB1c2UgTC5MaW5lVXRpbC5pc0ZsYXQgaW5zdGVhZC4nKTtcclxuXHRyZXR1cm4gaXNGbGF0KGxhdGxuZ3MpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvTGluZVV0aWwuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG5sZXQgQUJTX1VSTCA9IC8oXlxcLyl8KF4jKXwoXltcXHctXFxkXSo6KS87XG5sZXQgd29ya2luZ1VSTDtcbmxldCByZXNvbHZlRG9jO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gVVJMIGFnYWluc3QgdGhlIHByb3ZpZGVkIGBiYXNlVXJpJy5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byByZXNvbHZlXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIFVSTFxuICovXG5mdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVSSSkge1xuICBpZiAodXJsICYmIEFCU19VUkwudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICAvLyBMYXp5IGZlYXR1cmUgZGV0ZWN0aW9uLlxuICBpZiAod29ya2luZ1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1ID0gbmV3IFVSTCgnYicsICdodHRwOi8vYScpO1xuICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICB3b3JraW5nVVJMID0gKHUuaHJlZiA9PT0gJ2h0dHA6Ly9hL2MlMjBkJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgZmFpbFxuICAgIH1cbiAgfVxuICBpZiAoIWJhc2VVUkkpIHtcbiAgICBiYXNlVVJJID0gZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgfVxuICBpZiAod29ya2luZ1VSTCkge1xuICAgIHJldHVybiAobmV3IFVSTCh1cmwsIGJhc2VVUkkpKS5ocmVmO1xuICB9XG4gIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICBpZiAoIXJlc29sdmVEb2MpIHtcbiAgICByZXNvbHZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd0ZW1wJyk7XG4gICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgcmVzb2x2ZURvYy5oZWFkLmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYmFzZSk7XG4gICAgcmVzb2x2ZURvYy5hbmNob3IgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICB9XG4gIHJlc29sdmVEb2MuYmFzZS5ocmVmID0gYmFzZVVSSTtcbiAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgcmV0dXJuIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgfHwgdXJsO1xuXG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYW55IHJlbGF0aXZlIFVSTCdzIGluIHRoZSBnaXZlbiBDU1MgdGV4dCBhZ2FpbnN0IHRoZSBwcm92aWRlZFxuICogYG93bmVyRG9jdW1lbnRgJ3MgYGJhc2VVUklgLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0IENTUyB0ZXh0IHRvIHByb2Nlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1MgdGV4dCB3aXRoIHJlc29sdmVkIFVSTCdzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSkge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKENTU19VUkxfUlgsIGZ1bmN0aW9uKG0sIHByZSwgdXJsLCBwb3N0KSB7XG4gICAgcmV0dXJuIHByZSArICdcXCcnICtcbiAgICAgIHJlc29sdmVVcmwodXJsLnJlcGxhY2UoL1tcIiddL2csICcnKSwgYmFzZVVSSSkgK1xuICAgICAgJ1xcJycgKyBwb3N0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gYHVybGAuIFRoZSBwYXRoIGluY2x1ZGVzIHRoZSB0cmFpbGluZ1xuICogYC9gIGZyb20gdGhlIHVybC5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgcGF0aFxuICovXG5mdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNzcyB9O1xuZXhwb3J0IHsgcmVzb2x2ZVVybCB9O1xuZXhwb3J0IHsgcGF0aEZyb21VcmwgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5pbmRleE9mKCcuJykgPj0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvb3QocGF0aCkge1xuICBsZXQgZG90SW5kZXggPSBwYXRoLmluZGV4T2YoJy4nKTtcbiAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGRvdEluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQW5jZXN0b3IoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgYmFzZS5zdGFydHNXaXRoKHBhdGggKyAnLicpO1xuICByZXR1cm4gYmFzZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpIHtcbiAgLy8gICAgIHBhdGguc3RhcnRzV2l0aChiYXNlICsgJy4nKTtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlICsgJy4nKSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShiYXNlLCBuZXdCYXNlLCBwYXRoKSB7XG4gIHJldHVybiBuZXdCYXNlICsgcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGJhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIChiYXNlID09PSBwYXRoKSB8fFxuICAgICAgICAgaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB8fFxuICAgICAgICAgaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8cGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGFyZ3MgPSBwYXRoW2ldLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgIGZvciAobGV0IGo9MDsgajxhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXJnc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHBhdGgpLnNwbGl0KCcuJyk7XG4gIH1cbiAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHJvb3QsIHBhdGgsIGluZm8pIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0xXSBhbmQgZGVyZWZlcmVuY2VcbiAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgcHJvcCA9IHByb3BbcGFydF07XG4gIH1cbiAgaWYgKGluZm8pIHtcbiAgICBpbmZvLnBhdGggPSBwYXJ0cy5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQocm9vdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgbGV0IGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMV07XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0yXSBhbmQgZGVyZWZlcmVuY2VcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0IHZhbHVlIHRvIG9iamVjdCBhdCBlbmQgb2YgcGF0aFxuICAgIHByb3BbbGFzdF0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTaW1wbGUgcHJvcGVydHkgc2V0XG4gICAgcHJvcFtwYXRoXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0RlZXAgPSBpc1BhdGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgJy4vbWl4aW4uanMnO1xuaW1wb3J0ICcuL2FzeW5jLmpzJztcblxuLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG5sZXQgQXN5bmNNb2R1bGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBAc3VtbWFyeSBDb2xsYXBzZSBtdWx0aXBsZSBjYWxsYmFja3MgaW50byBvbmUgaW52b2NhdGlvbiBhZnRlciBhIHRpbWVyLlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xuY2xhc3MgRGVib3VuY2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYXN5bmNNb2R1bGUgPSBudWxsO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjaGVkdWxlcjsgdGhhdCBpcywgYSBtb2R1bGUgd2l0aCB0aGUgQXN5bmMgaW50ZXJmYWNlLFxuICAgKiBhIGNhbGxiYWNrIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBydW4gZnVuY3Rpb25cbiAgICogZnJvbSB0aGUgYXN5bmMgbW9kdWxlLlxuICAgKlxuICAgKiBAcGFyYW0geyFBc3luY01vZHVsZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAgICovXG4gIHNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hc3luY01vZHVsZSA9IGFzeW5jTW9kdWxlO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZXIgPSB0aGlzLl9hc3luY01vZHVsZS5ydW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9hc3luY01vZHVsZS5jYW5jZWwodGhpcy5fdGltZXIpO1xuICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmx1c2hlcyBhbiBhY3RpdmUgZGVib3VuY2VyIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0c2VsZi5cbiAgICovXG4gIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFjdGl2ZS5cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lciAhPSBudWxsO1xuICB9XG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZXIgaWYgbm8gZGVib3VuY2VyIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICogb3IgaXQgY2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyIG90aGVyd2lzZS4gVGhlIGZvbGxvd2luZ1xuICogZXhhbXBsZSBzaG93cyBob3cgYSBkZWJvdW5jZXIgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoaW4gYVxuICogbWljcm90YXNrIGFuZCBcImRlYm91bmNlZFwiIHN1Y2ggdGhhdCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gaXNcbiAqIGNhbGxlZCBvbmNlLiBBZGQgdGhpcyBtZXRob2QgdG8gYSBjdXN0b20gZWxlbWVudDpcbiAqXG4gKiBfZGVib3VuY2VXb3JrKCkge1xuICogICB0aGlzLl9kZWJvdW5jZUpvYiA9IFBvbHltZXIuRGVib3VuY2VyLmRlYm91bmNlKHRoaXMuX2RlYm91bmNlSm9iLFxuICogICAgICAgUG9seW1lci5Bc3luYy5taWNyb1Rhc2ssICgpID0+IHtcbiAqICAgICB0aGlzLl9kb1dvcmsoKTtcbiAqICAgfSk7XG4gKiB9XG4gKlxuICogSWYgdGhlIGBfZGVib3VuY2VXb3JrYCBtZXRob2QgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiB0aGUgc2FtZVxuICogbWljcm90YXNrLCB0aGUgYF9kb1dvcmtgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBhdCB0aGUgbmV4dFxuICogbWljcm90YXNrIGNoZWNrcG9pbnQuXG4gKlxuICogTm90ZTogSW4gdGVzdGluZyBpdCBpcyBvZnRlbiBjb252ZW5pZW50IHRvIGF2b2lkIGFzeW5jaHJvbnkuIFRvIGFjY29tcGxpc2hcbiAqIHRoaXMgd2l0aCBhIGRlYm91bmNlciwgeW91IGNhbiB1c2UgYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcmAgYW5kXG4gKiBgUG9seW1lci5mbHVzaGAuIEZvciBleGFtcGxlLCBleHRlbmQgdGhlIGFib3ZlIGV4YW1wbGUgYnkgYWRkaW5nXG4gKiBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyKHRoaXMuX2RlYm91bmNlSm9iKWAgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGBfZGVib3VuY2VXb3JrYCBtZXRob2QuIFRoZW4gaW4gYSB0ZXN0LCBjYWxsIGBQb2x5bWVyLmZsdXNoYCB0byBlbnN1cmVcbiAqIHRoZSBkZWJvdW5jZXIgaGFzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge0RlYm91bmNlcj99IGRlYm91bmNlciBEZWJvdW5jZXIgb2JqZWN0LlxuICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZVxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayB0byBydW4uXG4gKiBAcmV0dXJuIHshRGVib3VuY2VyfSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdC5cbiAqL1xuICBzdGF0aWMgZGVib3VuY2UoZGVib3VuY2VyLCBhc3luY01vZHVsZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZGVib3VuY2VyIGluc3RhbmNlb2YgRGVib3VuY2VyKSB7XG4gICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYm91bmNlciA9IG5ldyBEZWJvdW5jZXIoKTtcbiAgICB9XG4gICAgZGVib3VuY2VyLnNldENvbmZpZyhhc3luY01vZHVsZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBkZWJvdW5jZXI7XG4gIH1cbn1cblxuZXhwb3J0IHsgRGVib3VuY2VyIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwiaW1wb3J0IHsgQ2xhc3MgfSBmcm9tICcuL2NsYXNzLmpzJztcblxuZXhwb3J0IGNvbnN0IFBvbHltZXIgPSBmdW5jdGlvbihpbmZvKSB7XG4gIC8vIGlmIGlucHV0IGlzIGEgYGNsYXNzYCAoYWthIGEgZnVuY3Rpb24gd2l0aCBhIHByb3RvdHlwZSksIHVzZSB0aGUgcHJvdG90eXBlXG4gIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGBjb25zdHJ1Y3RvcmAgd2lsbCBuZXZlciBiZSBjYWxsZWRcbiAgbGV0IGtsYXNzO1xuICBpZiAodHlwZW9mIGluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBrbGFzcyA9IGluZm87XG4gIH0gZWxzZSB7XG4gICAga2xhc3MgPSBDbGFzcyhpbmZvKTtcbiAgfVxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoa2xhc3MuaXMsIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhrbGFzcykpO1xuICByZXR1cm4ga2xhc3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyIsImltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbiBmb3IgbWl4aW4gJiBiZWhhdmlvclxuZnVuY3Rpb24gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKGluc3QsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCBtdXRhYmxlRGF0YSkge1xuICBsZXQgaXNPYmplY3Q7XG4gIGlmIChtdXRhYmxlRGF0YSkge1xuICAgIGlzT2JqZWN0ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpO1xuICAgIC8vIFB1bGwgYG9sZGAgZm9yIE9iamVjdHMgZnJvbSB0ZW1wIGNhY2hlLCBidXQgdHJlYXQgYG51bGxgIGFzIGEgcHJpbWl0aXZlXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBvbGQgPSBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2ssIGJ1dCByZXR1cm4gZmFsc2UgZm9yIE5hTj09PU5hTlxuICBsZXQgc2hvdWxkQ2hhbmdlID0gKG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpO1xuICAvLyBPYmplY3RzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZlxuICAvLyB0dXJuKSwgd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmdcbiAgaWYgKGlzT2JqZWN0ICYmIHNob3VsZENoYW5nZSkge1xuICAgIGluc3QuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gc2hvdWxkQ2hhbmdlO1xufVxuXG5leHBvcnQgY29uc3QgTXV0YWJsZURhdGEgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICovXG4gIGNsYXNzIE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBNdXRhYmxlRGF0YS5wcm90b3R5cGUubXV0YWJsZURhdGEgPSBmYWxzZTtcblxuICByZXR1cm4gTXV0YWJsZURhdGE7XG5cbn0pO1xuXG5leHBvcnQgY29uc3QgT3B0aW9uYWxNdXRhYmxlRGF0YSA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBwb2x5bWVyXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAqL1xuICBjbGFzcyBPcHRpb25hbE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGB0aGlzLm11dGFibGVEYXRhYCBpcyB0cnVlIG9uIHRoaXMgaW5zdGFuY2UsIHRoaXMgbWV0aG9kXG4gICAgICogcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlXG4gICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRoaXMubXV0YWJsZURhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcHRpb25hbE11dGFibGVEYXRhO1xuXG59KTtcblxuLy8gRXhwb3J0IGZvciB1c2UgYnkgbGVnYWN5IGJlaGF2aW9yXG5NdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi4vLi4vY29yZS9DbGFzcyc7XHJcbmltcG9ydCB7c2V0T3B0aW9uc30gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7cmV0aW5hfSBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuXHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXSxcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0c2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IHBvaW50KHNpemVPcHRpb24pLFxyXG5cdFx0ICAgIGFuY2hvciA9IHBvaW50KG5hbWUgPT09ICdzaGFkb3cnICYmIG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvciB8fFxyXG5cdFx0ICAgICAgICAgICAgc2l6ZSAmJiBzaXplLmRpdmlkZUJ5KDIsIHRydWUpKTtcclxuXHJcblx0XHRpbWcuY2xhc3NOYW1lID0gJ2xlYWZsZXQtbWFya2VyLScgKyBuYW1lICsgJyAnICsgKG9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRyZXR1cm4gcmV0aW5hICYmIHRoaXMub3B0aW9uc1tuYW1lICsgJ1JldGluYVVybCddIHx8IHRoaXMub3B0aW9uc1tuYW1lICsgJ1VybCddO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5pY29uKG9wdGlvbnM6IEljb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBpY29uIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbmV4cG9ydCBmdW5jdGlvbiBpY29uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEljb24ob3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvSWNvbi5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5cblxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5leHBvcnQgdmFyIFJlbmRlcmVyID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFJlbmRlcmVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFkZGluZzogTnVtYmVyID0gMC4xXG5cdFx0Ly8gSG93IG11Y2ggdG8gZXh0ZW5kIHRoZSBjbGlwIGFyZWEgYXJvdW5kIHRoZSBtYXAgdmlldyAocmVsYXRpdmUgdG8gaXRzIHNpemUpXG5cdFx0Ly8gZS5nLiAwLjEgd291bGQgYmUgMTAlIG9mIG1hcCB2aWV3IGluIGVhY2ggZGlyZWN0aW9uXG5cdFx0cGFkZGluZzogMC4xLFxuXG5cdFx0Ly8gQG9wdGlvbiB0b2xlcmFuY2U6IE51bWJlciA9IDBcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgY2xpY2sgdG9sZXJhbmNlIHJvdW5kIGEgcGF0aC9vYmplY3Qgb24gdGhlIG1hcFxuXHRcdHRvbGVyYW5jZSA6IDBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRVdGlsLnN0YW1wKHRoaXMpO1xuXHRcdHRoaXMuX2xheWVycyA9IHRoaXMuX2xheWVycyB8fCB7fTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7IC8vIGRlZmluZWQgYnkgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zXG5cblx0XHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMub24oJ3VwZGF0ZScsIHRoaXMuX3VwZGF0ZVBhdGhzLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMub2ZmKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdFx0dGhpcy5fZGVzdHJveUNvbnRhaW5lcigpO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0LFxuXHRcdFx0em9vbTogdGhpcy5fb25ab29tLFxuXHRcdFx0bW92ZWVuZDogdGhpcy5fdXBkYXRlLFxuXHRcdFx0em9vbWVuZDogdGhpcy5fb25ab29tRW5kXG5cdFx0fTtcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9vbkFuaW1ab29tO1xuXHRcdH1cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9vbkFuaW1ab29tOiBmdW5jdGlvbiAoZXYpIHtcblx0XHR0aGlzLl91cGRhdGVUcmFuc2Zvcm0oZXYuY2VudGVyLCBldi56b29tKTtcblx0fSxcblxuXHRfb25ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdH0sXG5cblx0X3VwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgdGhpcy5fem9vbSksXG5cdFx0ICAgIHBvc2l0aW9uID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0LCBzY2FsZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Jlc2V0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0uX3Byb2plY3QoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGhzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl91cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEJvdW5kcyhtaW4sIG1pbi5hZGQoc2l6ZS5tdWx0aXBseUJ5KDEgKyBwICogMikpLnJvdW5kKCkpO1xuXG5cdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHR9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmpzIiwiaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZU1hcmtlclxuICogQGFrYSBMLkNpcmNsZU1hcmtlclxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNpcmNsZSBvZiBhIGZpeGVkIHNpemUgd2l0aCByYWRpdXMgc3BlY2lmaWVkIGluIHBpeGVscy4gRXh0ZW5kcyBgUGF0aGAuXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGVNYXJrZXIgPSBQYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge2xhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fSxcblxuXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuXHRcdFBhdGgucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5zZXRSYWRpdXMocmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgciA9IHRoaXMuX3JhZGl1cyxcblx0XHQgICAgcjIgPSB0aGlzLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpLFxuXHRcdCAgICBwID0gW3IgKyB3LCByMiArIHddO1xuXHRcdHRoaXMuX3B4Qm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludC5zdWJ0cmFjdChwKSwgdGhpcy5fcG9pbnQuYWRkKHApKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyk7XG5cdH0sXG5cblx0X2VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cyAmJiAhdGhpcy5fcmVuZGVyZXIuX2JvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX3B4Qm91bmRzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHJldHVybiBwLmRpc3RhbmNlVG8odGhpcy5fcG9pbnQpIDw9IHRoaXMuX3JhZGl1cyArIHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyByb290UGF0aCBhcyByb290UGF0aCQwIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCAqIGFzIGNhc2VNYXAkMCBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjYW1lbFRvRGFzaENhc2UgfSBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjc3NGcm9tTW9kdWxlSW1wb3J0cywgY3NzRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmpzJztcbmltcG9ydCB7IHJlc29sdmVVcmwgYXMgcmVzb2x2ZVVybCQwIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuaW1wb3J0IHsgRG9tTW9kdWxlIH0gZnJvbSAnLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuXG5leHBvcnQgY29uc3QgRWxlbWVudE1peGluID0gZGVkdXBpbmdNaXhpbihiYXNlID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqL1xuICBjb25zdCBwb2x5bWVyRWxlbWVudEJhc2UgPSBQcm9wZXJ0eUVmZmVjdHMoYmFzZSk7XG5cbiAgbGV0IGNhc2VNYXAgPSBjYXNlTWFwJDA7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBwcm9wZXJ0aWVzYCBvYmplY3Qgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3I6XG4gICAqICgxKSBzdXBlciBjaGFpbiBtaXhlcyB0b2d0aGVyIHRvIG1ha2UgYHByb3BlcnRpZXNGb3JDbGFzc2Agd2hpY2ggaXNcbiAgICogdGhlbiB1c2VkIHRvIG1ha2UgYG9ic2VydmVkQXR0cmlidXRlc2AuXG4gICAqICgyKSBwcm9wZXJ0aWVzIGVmZmVjdHMgYW5kIG9ic2VydmVycyBhcmUgY3JlYXRlZCBmcm9tIGl0IGF0IGBmaW5hbGl6ZWAgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIG93biBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25Qcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAga2xhc3MuX19vd25Qcm9wZXJ0aWVzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgncHJvcGVydGllcycsIGtsYXNzKSkgP1xuICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3BlcnRpZXMgOiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fb3duUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgb2JzZXJ2ZXJzYCBhcnJheSBzcGVjaWZpY2FsbHkgb24gYGtsYXNzYC4gVXNlIGZvclxuICAgKiBzZXR0aW5nIHVwIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBvd24gb2JzZXJ2ZXJzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293bk9ic2VydmVycycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fb3duT2JzZXJ2ZXJzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnb2JzZXJ2ZXJzJywga2xhc3MpKSA/XG4gICAgICAgIC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykub2JzZXJ2ZXJzIDogW107XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX293bk9ic2VydmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXhlcyBgcHJvcHNgIGludG8gYGZsYXR0ZW5lZFByb3BzYCBidXQgdXBncmFkZXMgc2hvcnRoYW5kIHR5cGVcbiAgICogc3ludGF4IHRvIHsgdHlwZTogVHlwZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmbGF0dGVuZWRQcm9wcyBCYWcgdG8gY29sbGVjdCBmbGF0dGVuZWQgcHJvcGVydGllcyBpbnRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBhZGQgdG8gYGZsYXR0ZW5lZFByb3BzYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnB1dCBgZmxhdHRlbmVkUHJvcHNgIGJhZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmxhdHRlblByb3BlcnRpZXMoZmxhdHRlbmVkUHJvcHMsIHByb3BzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgbGV0IG8gPSBwcm9wc1twXTtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7IHR5cGU6IG8gfTtcbiAgICAgIH1cbiAgICAgIGZsYXR0ZW5lZFByb3BzW3BdID0gbztcbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFByb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmbGF0dGVuZWQgbGlzdCBvZiBwcm9wZXJ0aWVzIG1peGVkIHRvZ2V0aGVyIGZyb20gdGhlIGNoYWluIG9mIGFsbFxuICAgKiBjb25zdHJ1Y3RvcidzIGBjb25maWcucHJvcGVydGllc2AuIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGNyZWF0ZVxuICAgKiAoMSkgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgKiAoMikgY2xhc3MgcHJvcGVydHkgZGVmYXVsdCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge1BvbHltZXJFbGVtZW50UHJvcGVydGllc30gRmxhdHRlbmVkIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBhIHByb3BlcnR5IGZvciBzb21lIHJlYXNvbj9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2NsYXNzUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID1cbiAgICAgIGZsYXR0ZW5Qcm9wZXJ0aWVzKHt9LCBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpKTtcbiAgICAgIGxldCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2xhc3MucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUocHJvcGVydGllc0ZvckNsYXNzKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovKHN1cGVyQ3RvcikpKSxcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAqIFRoaXMgbGlzdCBpcyBjcmVhdGVkIGFzIGFuIG9wdGltaXphdGlvbiBzaW5jZSBpdCBpcyBhIHN1YnNldCBvZlxuICAgKiB0aGUgbGlzdCByZXR1cm5lZCBmcm9tIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgLlxuICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBpbiBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCB0byBzZXQgcHJvcGVydHkgZGVmYXVsdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqICAgdGhhdCBoYXZlIGRlZmF1bHQgdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyA9IG51bGw7XG4gICAgICBsZXQgcHJvcHMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICBsZXQgaW5mbyA9IHByb3BzW3BdO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBpbmZvKSB7XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0c1twXSA9IGluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGBrbGFzc2AgaGFzIGZpbmFsaXplZC4gQ2FsbGVkIGluIGBFbGVtZW50Q2xhc3MuZmluYWxpemUoKWBcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIG1ldGFwcm9ncmFtbWluZyBmb3IgdGhpcyBjbGFzcyBoYXMgYmVlblxuICAgKiAgIGNvbXBsZXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzQ2xhc3NGaW5hbGl6ZWQoa2xhc3MpIHtcbiAgICByZXR1cm4ga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19maW5hbGl6ZWQnLCBrbGFzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgLiBFbnN1cmVzIHRoaXMgYGtsYXNzYCBhbmRcbiAgICogKmFsbCBzdXBlcmNsYXNzZXMqIGFyZSBmaW5hbGl6ZWQgYnkgdHJhdmVyc2luZyB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAqIGFuZCBjYWxsaW5nIGBrbGFzcy5maW5hbGl6ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIoa2xhc3MpIHtcbiAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICB9XG4gICAgZmluYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhIGBrbGFzc2AgYmFzZWQgb24gYSBzdGFpYyBga2xhc3MuY29uZmlnYCBvYmplY3QgYW5kXG4gICAqIGEgYHRlbXBsYXRlYC4gVGhpcyBpbmNsdWRlcyBjcmVhdGluZyBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogZm9yIHByb3BlcnRpZXMgaW4gYGNvbmZpZ2AgYW5kIHRoZSBgdGVtcGxhdGVgIGFzIHdlbGwgYXMgcHJlcGFyaW5nIHRoZVxuICAgKiBgdGVtcGxhdGVgIGZvciBzdGFtcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzKGtsYXNzKSB7XG4gICAga2xhc3MuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgIGxldCBwcm90byA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvdG90eXBlO1xuICAgIGlmIChrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2lzJywga2xhc3MpKSAmJiBrbGFzcy5pcykge1xuICAgICAgcmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cbiAgICBsZXQgcHJvcHMgPSBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wcyk7XG4gICAgfVxuICAgIGxldCBvYnNlcnZlcnMgPSBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcyk7XG4gICAgaWYgKG9ic2VydmVycykge1xuICAgICAgZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgcHJvcHMpO1xuICAgIH1cbiAgICAvLyBub3RlOiBjcmVhdGUgXCJ3b3JraW5nXCIgdGVtcGxhdGUgdGhhdCBpcyBmaW5hbGl6ZWQgYXQgaW5zdGFuY2UgdGltZVxuICAgIGxldCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHQuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgICAgIHRlbXBsYXRlID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfVxuICAgICAgcHJvdG8uX3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYHByb3BlcnRpZXNgIG9iamVjdC5cbiAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogc3VwcG9ydGluZywgb2JzZXJ2ZXJzLCByZWZsZWN0aW5nIHRvIGF0dHJpYnV0ZXMsIGNoYW5nZSBub3RpZmljYXRpb24sXG4gICAqIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCByZWFkIG9ubHkgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgICBhbmQgZWZmZWN0cyB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBGbGF0dGVuZWQgYmFnIG9mIHByb3BlcnR5IGRlc2NyaXB0b3JzIGZvclxuICAgKiAgICB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgcCwgcHJvcGVydGllc1twXSwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYG9ic2VydmVyc2AgYXJyYXkuXG4gICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgb2JzZXJ2ZXJzLlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVycyBGbGF0dGVuZWQgYXJyYXkgb2Ygb2JzZXJ2ZXIgZGVzY3JpcHRvcnMgZm9yXG4gICAqICAgdGhpcyBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZHluYW1pY0ZucyBPYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBhbnkgcHJvcGVydGllc1xuICAgKiAgIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdCB3aGVuIHRoZSBmdW5jdGlvblxuICAgKiAgIHJlZmVyZW5jZSBpcyBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZU9ic2VydmVycyhwcm90bywgb2JzZXJ2ZXJzLCBkeW5hbWljRm5zKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgb2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm90by5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIob2JzZXJ2ZXJzW2ldLCBkeW5hbWljRm5zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBlZmZlY3RzIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBOb3RlLCBvbmNlIGEgcHJvcGVydHkgaGFzIGJlZW4gc2V0IHRvXG4gICAqIGByZWFkT25seWAsIGBjb21wdXRlZGAsIGByZWZsZWN0VG9BdHRyaWJ1dGVgLCBvciBgbm90aWZ5YFxuICAgKiB0aGVzZSB2YWx1ZXMgbWF5IG5vdCBiZSBjaGFuZ2VkLiBGb3IgZXhhbXBsZSwgYSBzdWJjbGFzcyBjYW5ub3RcbiAgICogYWx0ZXIgdGhlc2Ugc2V0dGluZ3MuIEhvd2V2ZXIsIGFkZGl0aW9uYWwgYG9ic2VydmVyc2AgbWF5IGJlIGFkZGVkXG4gICAqIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIFRoZSBpbmZvIG9iamVjdCBzaG91bGQgbWF5IGNvbnRhaW4gcHJvcGVydHkgbWV0YWRhdGEgYXMgZm9sbG93czpcbiAgICpcbiAgICogKiBgdHlwZWA6IHtmdW5jdGlvbn0gdHlwZSB0byB3aGljaCBhbiBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIHByb3BlcnR5XG4gICAqIGlzIGRlc2VyaWFsaXplZC4gTm90ZSB0aGUgcHJvcGVydHkgaXMgY2FtZWwtY2FzZWQgZnJvbSBhIGRhc2gtY2FzZWRcbiAgICogYXR0cmlidXRlLiBGb3IgZXhhbXBsZSwgJ2Zvby1iYXInIGF0dHJpYnV0ZSBpcyBkZXJzaWFsaXplZCB0byBhXG4gICAqIHByb3BlcnR5IG5hbWVkICdmb29CYXInLlxuICAgKlxuICAgKiAqIGByZWFkT25seWA6IHtib29sZWFufSBjcmVhdGVzIGEgcmVhZE9ubHkgcHJvcGVydHkgYW5kXG4gICAqIG1ha2VzIGEgcHJpdmF0ZSBzZXR0ZXIgZm9yIHRoZSBwcml2YXRlIG9mIHRoZSBmb3JtICdfc2V0Rm9vJyBmb3IgYVxuICAgKiBwcm9wZXJ0eSAnZm9vJyxcbiAgICpcbiAgICogKiBgY29tcHV0ZWRgOiB7c3RyaW5nfSBjcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkuIEEgY29tcHV0ZWQgcHJvcGVydHlcbiAgICogYWxzbyBhdXRvbWF0aWNhbGx5IGlzIHNldCB0byBgcmVhZE9ubHk6IHRydWVgLiBUaGUgdmFsdWUgaXMgY2FsY3VsYXRlZFxuICAgKiBieSBydW5uaW5nIGEgbWV0aG9kIGFuZCBhcmd1bWVudHMgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gRm9yXG4gICAqIGV4YW1wbGUgJ2NvbXB1dGUoZm9vKScgd2lsbCBjb21wdXRlIGEgZ2l2ZW4gcHJvcGVydHkgd2hlbiB0aGVcbiAgICogJ2ZvbycgcHJvcGVydHkgY2hhbmdlcyBieSBleGVjdXRpbmcgdGhlICdjb21wdXRlJyBtZXRob2QuIFRoaXMgbWV0aG9kXG4gICAqIG11c3QgcmV0dXJuIHRoZSBjb21wdXRlZCB2YWx1ZS5cbiAgICpcbiAgICogKiBgcmVmbGVjdFRvQXR0cml1dGVgOiB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlZmxlY3RlZFxuICAgKiB0byBhbiBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS4gTm90ZSwgdGhlIGF0dHJpYnV0ZSBpcyBkYXNoLWNhc2VkXG4gICAqIHNvIGEgcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicgaXMgcmVmbGVjdGVkIGFzICdmb28tYmFyJy5cbiAgICpcbiAgICogKiBgbm90aWZ5YDoge2Jvb2xlYW59IHNlbmRzIGEgbm9uLWJ1YmJsaW5nIG5vdGlmaWNhdGlvbiBldmVudCB3aGVuXG4gICAqIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSBwcm9wZXJ0eSBuYW1lZCAnZm9vJyBzZW5kcyBhblxuICAgKiBldmVudCBuYW1lZCAnZm9vLWNoYW5nZWQnIHdpdGggYGV2ZW50LmRldGFpbGAgc2V0IHRvIHRoZSB2YWx1ZSBvZlxuICAgKiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqICogb2JzZXJ2ZXI6IHtzdHJpbmd9IG5hbWUgb2YgYSBtZXRob2QgdGhhdCBydW5zIHdoZW4gdGhlIHByb3BlcnR5XG4gICAqIGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmUgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKS5cbiAgICpcbiAgICogTm90ZTogVXNlcnMgbWF5IHdhbnQgY29udHJvbCBvdmVyIG1vZGlmeWluZyBwcm9wZXJ0eVxuICAgKiBlZmZlY3RzIHZpYSBzdWJjbGFzc2luZy4gRm9yIGV4YW1wbGUsIGEgdXNlciBtaWdodCB3YW50IHRvIG1ha2UgYVxuICAgKiByZWZsZWN0VG9BdHRyaWJ1dGUgcHJvcGVydHkgbm90IGRvIHNvIGluIGEgc3ViY2xhc3MuIFdlJ3ZlIGNob3NlbiB0b1xuICAgKiBkaXNhYmxlIHRoaXMgYmVjYXVzZSBpdCBsZWFkcyB0byBhZGRpdGlvbmFsIGNvbXBsaWNhdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGEgcmVhZE9ubHkgZWZmZWN0IGdlbmVyYXRlcyBhIHNwZWNpYWwgc2V0dGVyLiBJZiBhIHN1YmNsYXNzXG4gICAqIGRpc2FibGVzIHRoZSBlZmZlY3QsIHRoZSBzZXR0ZXIgd291bGQgZmFpbCB1bmV4cGVjdGVkbHkuXG4gICAqIEJhc2VkIG9uIGZlZWRiYWNrLCB3ZSBtYXkgd2FudCB0byB0cnkgdG8gbWFrZSBlZmZlY3RzIG1vcmUgbWFsbGVhYmxlXG4gICAqIGFuZC9vciBwcm92aWRlIGFuIGFkdmFuY2VkIGFwaSBmb3IgbWFuaXB1bGF0aW5nIHRoZW0uXG4gICAqIEFsc28gY29uc2lkZXIgYWRkaW5nIHdhcm5pbmdzIHdoZW4gYW4gZWZmZWN0IGNhbm5vdCBiZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIEluZm8gb2JqZWN0IGZyb20gd2hpY2ggdG8gY3JlYXRlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqIFN1cHBvcnRlZCBrZXlzOlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWxsUHJvcHMgRmxhdHRlbmVkIG1hcCBvZiBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXNcbiAgICogICBlbGVtZW50IChpbmNsdWRpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIG5hbWUsIGluZm8sIGFsbFByb3BzKSB7XG4gICAgLy8gY29tcHV0ZWQgZm9yY2VzIHJlYWRPbmx5Li4uXG4gICAgaWYgKGluZm8uY29tcHV0ZWQpIHtcbiAgICAgIGluZm8ucmVhZE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBOb3RlLCBzaW5jZSBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZE9ubHksIHRoaXMgcHJldmVudHNcbiAgICAvLyBhZGRpbmcgYWRkaXRpb25hbCBjb21wdXRlZCBwcm9wZXJ0eSBlZmZlY3RzICh3aGljaCBsZWFkcyB0byBhIGNvbmZ1c2luZ1xuICAgIC8vIHNldHVwIHdoZXJlIG11bHRpcGxlIHRyaWdnZXJzIGZvciBzZXR0aW5nIGEgcHJvcGVydHkpXG4gICAgLy8gV2hpbGUgd2UgZG8gaGF2ZSBgaGFzQ29tcHV0ZWRFZmZlY3RgIHRoaXMgaXMgc2V0IG9uIHRoZSBwcm9wZXJ0eSdzXG4gICAgLy8gZGVwZW5kZW5jaWVzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAgICBpZiAoaW5mby5jb21wdXRlZCAgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkobmFtZSwgaW5mby5jb21wdXRlZCwgYWxsUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWFkT25seSAmJiAhcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShuYW1lLCAhaW5mby5jb21wdXRlZCk7XG4gICAgfVxuICAgIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSAmJiAhcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgaWYgKGluZm8ubm90aWZ5ICYmICFwcm90by5faGFzTm90aWZ5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhZGQgb2JzZXJ2ZXJcbiAgICBpZiAoaW5mby5vYnNlcnZlcikge1xuICAgICAgcHJvdG8uX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIobmFtZSwgaW5mby5vYnNlcnZlciwgYWxsUHJvcHNbaW5mby5vYnNlcnZlcl0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGFuIGVsZW1lbnQgYHByb3RvYCB0byBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gYHRlbXBsYXRlYC5cbiAgICogVGhlIGVsZW1lbnQgbmFtZSBgaXNgIGFuZCBleHRlbmRzIGBleHRgIG11c3QgYmUgc3BlY2lmaWVkIGZvciBTaGFkeUNTU1xuICAgKiBzdHlsZSBzY29waW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJvY2VzcyBhbmQgYmluZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBVUkwgYWdhaW5zdCB3aGljaCB0byByZXNvbHZlIHVybHMgaW5cbiAgICogICBzdHlsZSBlbGVtZW50IGNzc1RleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlzIFRhZyBuYW1lIChvciB0eXBlIGV4dGVuc2lvbiBuYW1lKSBmb3IgdGhpcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gZXh0IEZvciB0eXBlIGV4dGVuc2lvbnMsIHRoZSB0YWcgbmFtZSB0aGF0IHdhcyBleHRlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVUZW1wbGF0ZShwcm90bywgdGVtcGxhdGUsIGJhc2VVUkksIGlzLCBleHQpIHtcbiAgICAvLyBzdXBwb3J0IGBpbmNsdWRlPVwibW9kdWxlLW5hbWVcImBcbiAgICBsZXQgY3NzVGV4dCA9XG4gICAgICBjc3NGcm9tTW9kdWxlSW1wb3J0cyhpcykgK1xuICAgICAgY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKTtcbiAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgICAgIHRlbXBsYXRlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBpcywgZXh0KTtcbiAgICB9XG4gICAgcHJvdG8uX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQHVucmVzdHJpY3RlZFxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqL1xuICBjbGFzcyBQb2x5bWVyRWxlbWVudCBleHRlbmRzIHBvbHltZXJFbGVtZW50QmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBDdXN0b20gRWxlbWVudHMgVjEgQVBJLiAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xuICAgICAqIGEgbGlzdCBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYSBmbGF0dGVuaW5nIG9mIGFsbCBwcm9wZXJ0aWVzXG4gICAgICogZGVjbGFyZWQgaW4gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYCBmb3IgdGhpcyBlbGVtZW50IGFuZCBhbnlcbiAgICAgKiBzdXBlcmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gT2JzZXJ2ZWQgYXR0cmlidXRlIGxpc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX29ic2VydmVkQXR0cmlidXRlcycsIHRoaXMpKSkge1xuICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICBsZXQgcHJvcGVydGllcyA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGNhbWVsVG9EYXNoQ2FzZShwcm9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcyA9IGxpc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIGNyZWF0ZWQgdG9cbiAgICAgKiBlbnN1cmUgdGhhdCBjbGFzcyBmaW5hbGl6YXRpb24gd29yayBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICogTWF5IGJlIGNhbGxlZCBieSB1c2VycyB0byBlYWdlcmx5IHBlcmZvcm0gY2xhc3MgZmluYWxpemF0aW9uIHdvcmtcbiAgICAgKiBwcmlvciB0byB0aGUgY3JlYXRpb24gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBDbGFzcyBmaW5hbGl6YXRpb24gd29yayBnZW5lcmFsbHkgaW5jbHVkZXMgbWV0YS1wcm9ncmFtbWluZyBzdWNoIGFzXG4gICAgICogY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBhbnkgcHJvcGVydHkgZWZmZWN0IG1ldGFkYXRhIG5lZWRlZCBmb3JcbiAgICAgKiB0aGUgZmVhdHVyZXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzRmluYWxpemVkKHRoaXMpKSB7XG4gICAgICAgIGZpbmFsaXplQ2xhc3NBbmRTdXBlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoaXMgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqXG4gICAgICogSWYgYSBgc3RhdGljIGdldCBpcygpYCBnZXR0ZXIgaXMgZGVmaW5lZCwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gIGluIGEgYGRvbS1tb2R1bGVgIHdob3NlIGBpZGBcbiAgICAgKiBtYXRjaGVzIHRoaXMgZWxlbWVudCdzIGBpc2AuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgdG8gcmV0dXJuIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHRoZSBgaXNgIGdldHRlciBpcyB1bm5lY2Vzc2FyeSkuIFRoZSB0ZW1wbGF0ZSByZXR1cm5lZFxuICAgICAqIG1heSBiZSBlaXRoZXIgYW4gYEhUTUxUZW1wbGF0ZUVsZW1lbnRgIG9yIGEgc3RyaW5nIHRoYXQgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHN1YmNsYXNzaW5nLCBpZiB0aGUgc3VwZXIgY2xhc3Mgb3ZlcnJvZGUgdGhlIGRlZmF1bHRcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICAgKiB0ZW1wbGF0ZSB2aWEgYSBgZG9tLW1vZHVsZWAsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIGdldHRlciBhbmRcbiAgICAgKiByZXR1cm4gYFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKWAuXG4gICAgICpcbiAgICAgKiBJZiBhIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gbW9kaWZ5IHRoZSBzdXBlciBjbGFzcyB0ZW1wbGF0ZSwgaXQgc2hvdWxkXG4gICAgICogY2xvbmUgaXQgcmF0aGVyIHRoYW4gbW9kaWZ5IGl0IGluIHBsYWNlLiAgSWYgdGhlIGdldHRlciBkb2VzIGV4cGVuc2l2ZVxuICAgICAqIHdvcmsgc3VjaCBhcyBjbG9uaW5nL21vZGlmeWluZyBhIHRlbXBsYXRlLCBpdCBzaG91bGQgbWVtb2l6ZSB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZTpcbiAgICAgKlxuICAgICAqICAgbGV0IG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICBjbGFzcyBNeVN1YkNsYXNzIGV4dGVuZHMgTXlTdXBlckNsYXNzIHtcbiAgICAgKiAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgKiAgICAgICBpZiAoIW1lbW9pemVkVGVtcGxhdGUpIHtcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUgPSBzdXBlci50ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICAgICAgICBsZXQgc3ViQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqICAgICAgICAgc3ViQ29udGVudC50ZXh0Q29udGVudCA9ICdUaGlzIGNhbWUgZnJvbSBNeVN1YkNsYXNzJztcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChzdWJDb250ZW50KTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgICAgcmV0dXJuIG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR8c3RyaW5nfSBUZW1wbGF0ZSB0byBiZSBzdGFtcGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfdGVtcGxhdGUnLCB0aGlzKSkpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydChcbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgICAvLyBub3RlOiBpbXBsZW1lbnRlZCBzbyBhIHN1YmNsYXNzIGNhbiByZXRyaWV2ZSB0aGUgc3VwZXJcbiAgICAgICAgICAvLyB0ZW1wbGF0ZTsgY2FsbCB0aGUgc3VwZXIgaW1wbCB0aGlzIHdheSBzbyB0aGF0IGB0aGlzYCBwb2ludHNcbiAgICAgICAgICAvLyB0byB0aGUgc3VwZXJjbGFzcy5cbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRoIG1hdGNoaW5nIHRoZSB1cmwgZnJvbSB3aGljaCB0aGUgZWxlbWVudCB3YXMgaW1wb3J0ZWQuXG4gICAgICogVGhpcyBwYXRoIGlzIHVzZWQgdG8gcmVzb2x2ZSB1cmwncyBpbiB0ZW1wbGF0ZSBzdHlsZSBjc3NUZXh0LlxuICAgICAqIFRoZSBgaW1wb3J0UGF0aGAgcHJvcGVydHkgaXMgYWxzbyBzZXQgb24gZWxlbWVudCBpbnN0YW5jZXMgYW5kIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGJpbmRpbmdzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgcGF0aC5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBtYXRjaGluZyB0aGUgdXJsIGNvbnRhaW5pbmcgYSBgZG9tLW1vZHVsZWAgZWxlbWVudFxuICAgICAqIG1hdGNoaW5nIHRoaXMgZWxlbWVudCdzIHN0YXRpYyBgaXNgIHByb3BlcnR5LlxuICAgICAqIE5vdGUsIHRoaXMgcGF0aCBzaG91bGQgY29udGFpbiBhIHRyYWlsaW5nIGAvYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGltcG9ydCBwYXRoIGZvciB0aGlzIGVsZW1lbnQgY2xhc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGltcG9ydFBhdGgoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX2ltcG9ydFBhdGgnLCB0aGlzKSkpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydCgvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAodGhpcykuaXMpO1xuICAgICAgICAgIHRoaXMuX2ltcG9ydFBhdGggPSBtb2R1bGUgPyBtb2R1bGUuYXNzZXRwYXRoIDogJycgfHxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fdGVtcGxhdGU7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMucm9vdFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuaW1wb3J0UGF0aDtcbiAgICAgIC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlIHwgSFRNTEVsZW1lbnQgfCBTaGFkb3dSb290fSAqL1xuICAgICAgdGhpcy5yb290O1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU5vZGU+fSAqL1xuICAgICAgdGhpcy4kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgdG8gZW5zdXJlIGNsYXNzXG4gICAgICogbWV0YXByb2dyYW1taW5nIHJlbGF0ZWQgdG8gcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzIGhhc1xuICAgICAqIGNvbXBsZXRlZCAoY2FsbHMgYGZpbmFsaXplYCkuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGluaXRpYWxpemVzIGFueSBwcm9wZXJ0eSBkZWZhdWx0cyBwcm92aWRlZCB2aWEgYHZhbHVlYCBpblxuICAgICAqIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIGluc3RhbmNlQ291bnQrKztcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuZmluYWxpemUoKTtcbiAgICAgIGNvbnN0IGltcG9ydFBhdGggPSB0aGlzLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAvLyBub3RlOiBmaW5hbGl6ZSB0ZW1wbGF0ZSB3aGVuIHdlIGhhdmUgYWNjZXNzIHRvIGBsb2NhbE5hbWVgIHRvXG4gICAgICAvLyBhdm9pZCBkZXBlbmRlbmNlIG9uIGBpc2AgZm9yIHBvbHlmaWxsaW5nIHN0eWxpbmcuXG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiYgIXRoaXMuX3RlbXBsYXRlLl9fcG9seW1lckZpbmFsaXplZCkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBiYXNlVVJJID1cbiAgICAgICAgICBpbXBvcnRQYXRoID8gcmVzb2x2ZVVybCQwKGltcG9ydFBhdGgpIDogJyc7XG4gICAgICAgIGZpbmFsaXplVGVtcGxhdGUoLyoqIEB0eXBlIHshUG9seW1lckVsZW1lbnR9ICovKHRoaXMuX19wcm90b19fKSwgdGhpcy5fdGVtcGxhdGUsIGJhc2VVUkksXG4gICAgICAgICAgLyoqQHR5cGUgeyFIVE1MRWxlbWVudH0qLyh0aGlzKS5sb2NhbE5hbWUpO1xuICAgICAgfVxuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAvLyBzZXQgcGF0aCBkZWZhdWx0c1xuICAgICAgdGhpcy5yb290UGF0aCA9IHJvb3RQYXRoJDA7XG4gICAgICB0aGlzLmltcG9ydFBhdGggPSBpbXBvcnRQYXRoO1xuICAgICAgLy8gYXBwbHkgcHJvcGVydHkgZGVmYXVsdHMuLi5cbiAgICAgIGxldCBwJCA9IHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIGlmICghcCQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcCBpbiBwJCkge1xuICAgICAgICBsZXQgaW5mbyA9IHAkW3BdO1xuICAgICAgICAvLyBEb24ndCBzZXQgZGVmYXVsdCB2YWx1ZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG93biBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgICAgLy8gaGFwcGVucyB3aGVuIGEgYHByb3BlcnRpZXNgIHByb3BlcnR5IHdpdGggZGVmYXVsdCBidXQgbm8gZWZmZWN0cyBoYWRcbiAgICAgICAgLy8gYSBwcm9wZXJ0eSBzZXQgKGUuZy4gYm91bmQpIGJ5IGl0cyBob3N0IGJlZm9yZSB1cGdyYWRlXG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHR5cGVvZiBpbmZvLnZhbHVlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgaW5mby52YWx1ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAgIGluZm8udmFsdWU7XG4gICAgICAgICAgLy8gU2V0IHZpYSBgX3NldFByb3BlcnR5YCBpZiB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgdG8gZW5hYmxlXG4gICAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHJlYWRPbmx5IHByb3BlcnR5IGRlZmF1bHRzXG4gICAgICAgICAgaWYgKHRoaXMuX2hhc0FjY2Vzc29yKHApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZW5hYmxlcyB0aGUgcHJvcGVydHkgZWZmZWN0cyBzeXN0ZW0gYW5kXG4gICAgICogZmx1c2hlcyBhbnkgcGVuZGluZyBwcm9wZXJ0aWVzLCBhbmQgdXBkYXRlcyBzaGltbWVkIENTUyBwcm9wZXJ0aWVzXG4gICAgICogd2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZy9jdXN0b20gcHJvcGVydGllcyBwb2x5ZmlsbC5cbiAgICAgKlxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICAgIC8qKlxuICAgICAqIFN0YW1wcyB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fdGVtcGxhdGUpO1xuICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlFZmZlY3RzYCdzIGBfcmVhZHlDbGllbnRzYCBjYWxsLiBBdHRhY2hlc1xuICAgICAqIGVsZW1lbnQgZG9tIGJ5IGNhbGxpbmcgYF9hdHRhY2hEb21gIHdpdGggdGhlIGRvbSBzdGFtcGVkIGZyb20gdGhlXG4gICAgICogZWxlbWVudCdzIHRlbXBsYXRlIHZpYSBgX3N0YW1wVGVtcGxhdGVgLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3NcbiAgICAgKiBjbGllbnQgZG9tIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IHByaW9yIHRvIGFueSBvYnNlcnZlcnNcbiAgICAgKiBydW5uaW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9hdHRhY2hEb20oLyoqIEB0eXBlIHtTdGFtcGVkVGVtcGxhdGV9ICovKHRoaXMucm9vdCkpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHN1cGVyLl9yZWFkeUNsaWVudHMgaGVyZSBzZXRzIHRoZSBjbGllbnRzIGluaXRpYWxpemVkIGZsYWcuXG4gICAgICAvLyBXZSBtdXN0IHdhaXQgdG8gZG8gdGhpcyB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGNyZWF0ZWQvYXR0YWNoZWRcbiAgICAgIC8vIHNvIHRoYXQgdGhpcyBmbGFnIGNhbiBiZSBjaGVja2VkIHRvIHByZXZlbnQgbm90aWZpY2F0aW9ucyBmaXJlZFxuICAgICAgLy8gZHVyaW5nIHRoaXMgcHJvY2VzcyBmcm9tIGJlaW5nIGhhbmRsZWQgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgc3VwZXIuX3JlYWR5Q2xpZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gZWxlbWVudCdzIHN0YW1wZWQgZG9tIHRvIGl0c2VsZi4gQnkgZGVmYXVsdCxcbiAgICAgKiB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgYHNoYWRvd1Jvb3RgIGFuZCBhZGRzIHRoZSBkb20gdG8gaXQuXG4gICAgICogSG93ZXZlciwgdGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWxsb3cgYW4gZWxlbWVudFxuICAgICAqIHRvIHB1dCBpdHMgZG9tIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdSZXR1cm59XG4gICAgICogQHBhcmFtIHtTdGFtcGVkVGVtcGxhdGV9IGRvbSB0byBhdHRhY2ggdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7U2hhZG93Um9vdH0gbm9kZSB0byB3aGljaCB0aGUgZG9tIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIF9hdHRhY2hEb20oZG9tKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRvd0RPTSBub3QgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBtb3ZlIHRvIGNvbXBpbGUtdGltZSBjb25kaXRpb25hbCB3aGVuIHN1cHBvcnRlZFxuICAgICAgICAnUG9seW1lci5FbGVtZW50IGNhbiBjcmVhdGUgZG9tIGFzIGNoaWxkcmVuIGluc3RlYWQgb2YgaW4gJyArXG4gICAgICAgICdTaGFkb3dET00gYnkgc2V0dGluZyBgdGhpcy5yb290ID0gdGhpcztcXGAgYmVmb3JlIFxcYHJlYWR5XFxgLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBhdHRyaWJ1dGVzIGRlY2xhcmVkIGluIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YSBhcmVcbiAgICAgKiBkZXNlcmlhbGl6ZWQgdXNpbmcgdGhlaXIgYHR5cGVgIGluZm9ybWF0aW9uIHRvIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICogc2FtZSBuYW1lLiAgXCJEYXNoLWNhc2VkXCIgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWx6ZWQgdG8gXCJjYW1lbENhc2VcIlxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICBsZXQgdHlwZSA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKVtwcm9wZXJ0eV0udHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gICAgICogc2hpbW1lZCBzdHlsZXMgaW4gdGhpcyBlbGVtZW50IChhbmQgaXRzIHN1YnRyZWUpIHRvIGJlIHVwZGF0ZWRcbiAgICAgKiBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3B0aW9uYWwgcGFyYW1ldGVyIG92ZXJyaWRlcyBpbmxpbmUgY3VzdG9tIHByb3BlcnR5IHN0eWxlcyB3aXRoIGFuXG4gICAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgICAqIGFyZSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTogYHRoaXMudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgICAqXG4gICAgICogVGhlc2UgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgdW5sZXNzIGEgdmFsdWUgb2YgYG51bGxgIGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICAgKiAgIGFwcGx5IHRvIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICB1cGRhdGVTdHlsZXMocHJvcGVydGllcykge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV3cml0ZXMgYSBnaXZlbiBVUkwgcmVsYXRpdmUgdG8gYSBiYXNlIFVSTC4gVGhlIGJhc2UgVVJMIGRlZmF1bHRzIHRvXG4gICAgICogdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBgZG9tLW1vZHVsZWAgZm9yXG4gICAgICogdGhpcyBlbGVtZW50LiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBVUkwgYmVmb3JlIGFuZCBhZnRlclxuICAgICAqIGJ1bmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJhc2UgT3B0aW9uYWwgYmFzZSBVUkwgdG8gcmVzb2x2ZSBhZ2FpbnN0LCBkZWZhdWx0c1xuICAgICAqIHRvIHRoZSBlbGVtZW50J3MgYGltcG9ydFBhdGhgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXdyaXR0ZW4gVVJMIHJlbGF0aXZlIHRvIGJhc2VcbiAgICAgKi9cbiAgICByZXNvbHZlVXJsKHVybCwgYmFzZSkge1xuICAgICAgaWYgKCFiYXNlICYmIHRoaXMuaW1wb3J0UGF0aCkge1xuICAgICAgICBiYXNlID0gcmVzb2x2ZVVybCQwKHRoaXMuaW1wb3J0UGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZVVybCQwKHVybCwgYmFzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2AgdG8gYWRkIG1hcCBvZiBkeW5hbWljIGZ1bmN0aW9ucyBvblxuICAgICAqIHRlbXBsYXRlIGluZm8sIGZvciBjb25zdW1wdGlvbiBieSBgUHJvcGVydHlFZmZlY3RzYCB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICogY29kZS4gVGhpcyBtYXAgZGV0ZXJtaW5lcyB3aGljaCBtZXRob2QgdGVtcGxhdGVzIHNob3VsZCBoYXZlIGFjY2Vzc29yc1xuICAgICAqIGNyZWF0ZWQgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zIHx8IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBvbHltZXJFbGVtZW50O1xufSk7XG5cbmV4cG9ydCBsZXQgaW5zdGFuY2VDb3VudCA9IDA7XG5leHBvcnQgY29uc3QgcmVnaXN0cmF0aW9ucyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gX3JlZ0xvZyhwcm90b3R5cGUpIHtcbiAgY29uc29sZS5sb2coJ1snICsgcHJvdG90eXBlLmlzICsgJ106IHJlZ2lzdGVyZWQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHByb3RvdHlwZSkge1xuICByZWdpc3RyYXRpb25zLnB1c2gocHJvdG90eXBlKTtcbiAgdW5kZWZpbmVkICYmIF9yZWdMb2cocHJvdG90eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR1bXBSZWdpc3RyYXRpb25zKCkge1xuICByZWdpc3RyYXRpb25zLmZvckVhY2goX3JlZ0xvZyk7XG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTdHlsZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRG9jdW1lbnQocHJvcHMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IHBhdGhGcm9tVXJsIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5cbi8qKlxuICogTGVnYWN5IHNldHRpbmdzLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xuY29uc3Qgc2V0dGluZ3MgPSB1bmRlZmluZWQgfHwge307XG5leHBvcnQgY29uc3QgdXNlU2hhZG93ID0gISh3aW5kb3cuU2hhZHlET00pO1xuZXhwb3J0IGNvbnN0IHVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMgPSBCb29sZWFuKCF3aW5kb3cuU2hhZHlDU1MgfHwgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyk7XG5leHBvcnQgY29uc3QgdXNlTmF0aXZlQ3VzdG9tRWxlbWVudHMgPSAhKHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKTtcbmV4cG9ydCB7IHNldHRpbmdzIGFzIFNldHRpbmdzIH07XG5cbi8qKlxuICogR2xvYmFsbHkgc2V0dGFibGUgcHJvcGVydHkgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvXG4gKiBgUG9seW1lci5FbGVtZW50TWl4aW5gIGluc3RhbmNlcywgdXNlZnVsIGZvciBiaW5kaW5nIGluIHRlbXBsYXRlcyB0b1xuICogbWFrZSBVUkwncyByZWxhdGl2ZSB0byBhbiBhcHBsaWNhdGlvbidzIHJvb3QuICBEZWZhdWx0cyB0byB0aGUgbWFpblxuICogZG9jdW1lbnQgVVJMLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlcnMuICBJdCBtYXkgYmUgdXNlZnVsIHRvIHNldFxuICogYFBvbHltZXIucm9vdFBhdGhgIHRvIHByb3ZpZGUgYSBzdGFibGUgYXBwbGljYXRpb24gbW91bnQgcGF0aCB3aGVuXG4gKiB1c2luZyBjbGllbnQgc2lkZSByb3V0aW5nLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCByb290UGF0aCA9IHVuZGVmaW5lZCB8fFxuICBwYXRoRnJvbVVybChkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuZXhwb3J0IHsgcm9vdFBhdGggfTtcblxuZXhwb3J0IGNvbnN0IHNldFJvb3RQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICByb290UGF0aCA9IHBhdGg7XG59O1xuXG4vKipcbiAqIEEgZ2xvYmFsIGNhbGxiYWNrIHVzZWQgdG8gc2FuaXRpemUgYW55IHZhbHVlIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgRE9NLiBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuICpcbiAqICAgICBQb2x5bWVyID0ge1xuICogICAgICAgc2FuaXRpemVET01WYWx1ZTogZnVuY3Rpb24odmFsdWUsIG5hbWUsIHR5cGUsIG5vZGUpIHsgLi4uIH1cbiAqICAgICB9XG4gKlxuICogV2hlcmU6XG4gKlxuICogYHZhbHVlYCBpcyB0aGUgdmFsdWUgdG8gc2FuaXRpemUuXG4gKiBgbmFtZWAgaXMgdGhlIG5hbWUgb2YgYW4gYXR0cmlidXRlIG9yIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaHJlZikuXG4gKiBgdHlwZWAgaW5kaWNhdGVzIHdoZXJlIHRoZSB2YWx1ZSBpcyBiZWluZyBpbnNlcnRlZDogb25lIG9mIHByb3BlcnR5LCBhdHRyaWJ1dGUsIG9yIHRleHQuXG4gKiBgbm9kZWAgaXMgdGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIGJlaW5nIGluc2VydGVkLlxuICpcbiAqIEB0eXBlIHsoZnVuY3Rpb24oKixzdHJpbmcsc3RyaW5nLE5vZGUpOiopfHVuZGVmaW5lZH1cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCBzYW5pdGl6ZURPTVZhbHVlID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH07XG5cbmV4cG9ydCBjb25zdCBzZXRTYW5pdGl6ZURPTVZhbHVlID0gZnVuY3Rpb24obmV3U2FuaXRpemVET01WYWx1ZSkge1xuICBzYW5pdGl6ZURPTVZhbHVlID0gbmV3U2FuaXRpemVET01WYWx1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5jb25zdCBjYXNlTWFwID0ge307XG5jb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuY29uc3QgQ0FNRUxfVE9fREFTSCA9IC8oW0EtWl0pL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICByZXR1cm4gY2FzZU1hcFtkYXNoXSB8fCAoXG4gICAgY2FzZU1hcFtkYXNoXSA9IGRhc2guaW5kZXhPZignLScpIDwgMCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoREFTSF9UT19DQU1FTCxcbiAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbFRvRGFzaENhc2UoY2FtZWwpIHtcbiAgcmV0dXJuIGNhc2VNYXBbY2FtZWxdIHx8IChcbiAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHJvb3QgYXMgcm9vdCQwLCBpc0FuY2VzdG9yLCBpc0Rlc2NlbmRhbnQsIGdldCBhcyBnZXQkMCwgdHJhbnNsYXRlLCBpc1BhdGggYXMgaXNQYXRoJDAsIHNldCBhcyBzZXQkMCwgbm9ybWFsaXplIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwIGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoQ2FzZSBhcyBjYW1lbFRvRGFzaENhc2UkMCwgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlBY2Nlc3NvcnMgfSBmcm9tICcuL3Byb3BlcnR5LWFjY2Vzc29ycy5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVN0YW1wIH0gZnJvbSAnLi90ZW1wbGF0ZS1zdGFtcC5qcyc7XG5pbXBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtPYmplY3R9ICovXG5jb25zdCBDYXNlTWFwID0gY2FzZU1hcDtcblxuLy8gTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHVuaXF1ZSBJRCB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0cyB0cmlnZ2VyZWRcbi8vIGZyb20gbXVsdGlwbGUgcHJvcGVydGllcyBpbiB0aGUgc2FtZSB0dXJuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIFByb3BlcnR5IGVmZmVjdCB0eXBlczsgZWZmZWN0cyBhcmUgc3RvcmVkIG9uIHRoZSBwcm90b3R5cGUgdXNpbmcgdGhlc2Uga2V5c1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVFlQRVMgPSB7XG4gIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgUkVGTEVDVDogJ19fcmVmbGVjdEVmZmVjdHMnLFxuICBOT1RJRlk6ICdfX25vdGlmeUVmZmVjdHMnLFxuICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICBPQlNFUlZFOiAnX19vYnNlcnZlRWZmZWN0cycsXG4gIFJFQURfT05MWTogJ19fcmVhZE9ubHknXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBuYW1lOiAoc3RyaW5nIHwgdW5kZWZpbmVkKSxcbiAqIHN0cnVjdHVyZWQ6IChib29sZWFuIHwgdW5kZWZpbmVkKSxcbiAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIGluZm86ID8sXG4gKiB0cmlnZ2VyOiAoIURhdGFUcmlnZ2VyIHwgdW5kZWZpbmVkKSxcbiAqIGZuOiAoIUZ1bmN0aW9uIHwgdW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IERhdGFFZmZlY3Q7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5sZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBtb2RlbCBoYXMgYW4gb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gKlxuICogUHJvcGVydHkgZWZmZWN0cyBhcmUgc3RvcmVkIGFzIGFycmF5cyBvZiBlZmZlY3RzIGJ5IHByb3BlcnR5IGluIGEgbWFwLFxuICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAqXG4gKiAgIF9fY29tcHV0ZUVmZmVjdHM6IHtcbiAqICAgICBmb286IFsgLi4uIF0sXG4gKiAgICAgYmFyOiBbIC4uLiBdXG4gKiAgIH1cbiAqXG4gKiBJZiB0aGUgbW9kZWwgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IG1hcCBmb3IgdGhlIHR5cGUsIG9uZSBpcyBjcmVhdGVkXG4gKiBhbmQgcmV0dXJuZWQuICBJZiBpdCBkb2VzLCBidXQgaXQgaXMgbm90IGFuIG93biBwcm9wZXJ0eSAoaS5lLiB0aGVcbiAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gKiBzZXQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5lZCwgcmVhZHkgZm9yIG5ldyBlZmZlY3RzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFByb3BlcnR5IGVmZmVjdCB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnN1cmVPd25FZmZlY3RNYXAobW9kZWwsIHR5cGUpIHtcbiAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgaWYgKCFlZmZlY3RzKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0ge307XG4gIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShtb2RlbFt0eXBlXSk7XG4gICAgZm9yIChsZXQgcCBpbiBlZmZlY3RzKSB7XG4gICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICBsZXQgaW5zdEZ4ID0gZWZmZWN0c1twXSA9IEFycmF5KHByb3RvRngubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwcm90b0Z4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlZmZlY3RzO1xufVxuXG4vLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSdW5zIGFsbCBlZmZlY3RzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgdGhlIGdpdmVuIHNldCBvZiBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdD19IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHMoaW5zdCwgZWZmZWN0cywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGlmIChlZmZlY3RzKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgaWYgKHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSkge1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgbGlzdCBvZiBlZmZlY3RzIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZHVwZUlkIENvdW50ZXIgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSBwcm9wcyBDaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Kn0gb2xkUHJvcHMgT2xkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgZGVkdXBlSWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICBsZXQgcmFuID0gZmFsc2U7XG4gIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QkMChwcm9wKSA6IHByb3A7XG4gIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gIGlmIChmeHMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ZnhzLmxlbmd0aCwgZng7IChpPGwpICYmIChmeD1meHNbaV0pOyBpKyspIHtcbiAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgaWYgKGZ4LmluZm8pIHtcbiAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgfVxuICAgICAgICBmeC5mbihpbnN0LCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGZ4LmluZm8sIGhhc1BhdGhzLCBleHRyYUFyZ3MpO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmFuO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHByb3BlcnR5L3BhdGggdGhhdCBoYXMgY2hhbmdlZCBtYXRjaGVzIHRoZSB0cmlnZ2VyXG4gKiBjcml0ZXJpYSBmb3IgYW4gZWZmZWN0LiAgQSB0cmlnZ2VyIGlzIGEgZGVzY3JpcHRvciB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICogZS5nLiBmb3IgYGZvby5iYXIuKmA6XG4gKiBgYGBcbiAqIHRyaWdnZXI6IHtcbiAqICAgbmFtZTogJ2EuYicsXG4gKiAgIHN0cnVjdHVyZWQ6IHRydWUsXG4gKiAgIHdpbGRjYXJkOiB0cnVlXG4gKiB9XG4gKiBgYGBcbiAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIG9yIHByb3BlcnR5IHRoYXQgY2hhbmdlZFxuICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXRoIG1hdGNoZWQgdGhlIHRyaWdnZXJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgaWYgKHRyaWdnZXIpIHtcbiAgICBsZXQgdHJpZ2dlclBhdGggPSB0cmlnZ2VyLm5hbWU7XG4gICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgKHRyaWdnZXIuc3RydWN0dXJlZCAmJiBpc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICh0cmlnZ2VyLndpbGRjYXJkICYmIGlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAqXG4gKiBDYWxscyB0aGUgbWV0aG9kIHdpdGggYGluZm8ubWV0aG9kTmFtZWAgb24gdGhlIGluc3RhbmNlLCBwYXNzaW5nIHRoZVxuICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgZm4gPSBpbnN0W2luZm8ubWV0aG9kTmFtZV07XG4gIGxldCBjaGFuZ2VkUHJvcCA9IGluZm8ucHJvcGVydHk7XG4gIGlmIChmbikge1xuICAgIGZuLmNhbGwoaW5zdCwgaW5zdC5fX2RhdGFbY2hhbmdlZFByb3BdLCBvbGRQcm9wc1tjaGFuZ2VkUHJvcF0pO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgXCJub3RpZnlcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogd2lsbCBkaXNwYXRjaCBwYXRoIG5vdGlmaWNhdGlvbiBldmVudHMgaW4gdGhlIGNhc2UgdGhhdCB0aGUgcHJvcGVydHlcbiAqIGNoYW5nZWQgd2FzIGEgcGF0aCBhbmQgdGhlIHJvb3QgcHJvcGVydHkgZm9yIHRoYXQgcGF0aCBkaWRuJ3QgaGF2ZSBhXG4gKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gKiBgbm90aWZ5OiB0cnVlYCB0byBlbnN1cmUgb2JqZWN0IHN1Yi1wcm9wZXJ0eSBub3RpZmljYXRpb25zIHdlcmVcbiAqIHNlbnQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IG5vdGlmeVByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIG5vdGlmeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdHMoaW5zdCwgbm90aWZ5UHJvcHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgLy8gTm90aWZ5XG4gIGxldCBmeHMgPSBpbnN0W1RZUEVTLk5PVElGWV07XG4gIGxldCBub3RpZmllZDtcbiAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgLy8gVHJ5IG5vcm1hbCBub3RpZnkgZWZmZWN0czsgaWYgbm9uZSwgZmFsbCBiYWNrIHRvIHRyeSBwYXRoIG5vdGlmaWNhdGlvblxuICBmb3IgKGxldCBwcm9wIGluIG5vdGlmeVByb3BzKSB7XG4gICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICBpZiAoZnhzICYmIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBmeHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRmx1c2ggaG9zdCBpZiB3ZSBhY3R1YWxseSBub3RpZmllZCBhbmQgaG9zdCB3YXMgYmF0Y2hpbmdcbiAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgLy8gYW4gaXNzdWUgd2l0aCBhIGhvc3Qgb2JzZXJ2aW5nIGRhdGEgY2hhbmdlcyBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gIGxldCBob3N0O1xuICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB3aXRoIHBhdGggaW5mb3JtYXRpb24gaW4gdGhlIGRldGFpbFxuICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgbm90aWZpZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVBhdGgoaW5zdCwgcGF0aCwgcHJvcHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IHJvb3QkMChwYXRoKTtcbiAgaWYgKHJvb3RQcm9wZXJ0eSAhPT0gcGF0aCkge1xuICAgIGxldCBldmVudE5hbWUgPSBjYW1lbFRvRGFzaENhc2UkMChyb290UHJvcGVydHkpICsgJy1jaGFuZ2VkJztcbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgcHJvcHNbcGF0aF0sIHBhdGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgdG8gaW5kaWNhdGUgYSBwcm9wZXJ0eSAob3IgcGF0aClcbiAqIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHBhdGggSWYgYSBzdWItcGF0aCBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZWQsIHRoZSBwYXRoXG4gKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICogQHByaXZhdGVcbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpIHtcbiAgbGV0IGRldGFpbCA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcXVldWVQcm9wZXJ0eTogdHJ1ZVxuICB9O1xuICBpZiAocGF0aCkge1xuICAgIGRldGFpbC5wYXRoID0gcGF0aDtcbiAgfVxuICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gKlxuICogRGlzcGF0Y2hlcyBhIG5vbi1idWJibGluZyBldmVudCBuYW1lZCBgaW5mby5ldmVudE5hbWVgIG9uIHRoZSBpbnN0YW5jZVxuICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdCQwKHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICBsZXQgcGF0aCA9IHJvb3RQcm9wZXJ0eSAhPSBwcm9wZXJ0eSA/IHByb3BlcnR5IDogbnVsbDtcbiAgbGV0IHZhbHVlID0gcGF0aCA/IGdldCQwKGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAocGF0aCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBwcm9wc1twcm9wZXJ0eV07ICAvLyBzcGVjaWZpY2FsbHkgZm9yIC5zcGxpY2VzXG4gIH1cbiAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBpbmZvLmV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIDItd2F5IG5vdGlmaWNhdGlvbiBldmVudHMuIFJlY2VpdmVzIGNvbnRleHRcbiAqIGluZm9ybWF0aW9uIGNhcHR1cmVkIGluIHRoZSBgYWRkTm90aWZ5TGlzdGVuZXJgIGNsb3N1cmUgZnJvbSB0aGVcbiAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5vdGlmaWVkIHByb3BlcnR5IHRvIHRoZSBob3N0IHByb3BlcnR5IG9yIHBhdGguICBJZlxuICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gKiBzY29wZSdzIG5hbWUgZm9yIHRoYXQgcGF0aCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSBoYW5kbGluZyB0aGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbVByb3AgQ2hpbGQgZWxlbWVudCBwcm9wZXJ0eSB0aGF0IHdhcyBib3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVnYXRlIFdoZXRoZXIgdGhlIGJpbmRpbmcgd2FzIG5lZ2F0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihldmVudCwgaW5zdCwgZnJvbVByb3AsIHRvUGF0aCwgbmVnYXRlKSB7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICBsZXQgZnJvbVBhdGggPSBkZXRhaWwgJiYgZGV0YWlsLnBhdGg7XG4gIGlmIChmcm9tUGF0aCkge1xuICAgIHRvUGF0aCA9IHRyYW5zbGF0ZShmcm9tUHJvcCwgdG9QYXRoLCBmcm9tUGF0aCk7XG4gICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZXZlbnQudGFyZ2V0W2Zyb21Qcm9wXTtcbiAgfVxuICB2YWx1ZSA9IG5lZ2F0ZSA/ICF2YWx1ZSA6IHZhbHVlO1xuICBpZiAoIWluc3RbVFlQRVMuUkVBRF9PTkxZXSB8fCAhaW5zdFtUWVBFUy5SRUFEX09OTFldW3RvUGF0aF0pIHtcbiAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgJiYgKCFkZXRhaWwgfHwgIWRldGFpbC5xdWV1ZVByb3BlcnR5KSkge1xuICAgICAgaW5zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcInJlZmxlY3RcIiBlZmZlY3QuXG4gKlxuICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IHZhbHVlID0gaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgaW5mby5hdHRyTmFtZSwgJ2F0dHJpYnV0ZScsIC8qKiBAdHlwZSB7Tm9kZX0gKi8oaW5zdCkpO1xuICB9XG4gIGluc3QuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGluZm8uYXR0ck5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSdW5zIFwiY29tcHV0ZWRcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogY29udGludWVzIHRvIHJ1biBjb21wdXRlZCBlZmZlY3RzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgZWFjaCBwYXNzIHVudGlsXG4gKiB0aGVyZSBhcmUgbm8gbW9yZSBuZXdseSBjb21wdXRlZCBwcm9wZXJ0aWVzLiAgVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAqIGNvbXB1dGVkIGJlZm9yZSBvdGhlciBlZmZlY3RzIChiaW5kaW5nIHByb3BhZ2F0aW9uLCBvYnNlcnZlcnMsIGFuZCBub3RpZnkpXG4gKiBydW4uXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0cyhpbnN0LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICBsZXQgY29tcHV0ZUVmZmVjdHMgPSBpbnN0W1RZUEVTLkNPTVBVVEVdO1xuICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICBsZXQgaW5wdXRQcm9wcyA9IGNoYW5nZWRQcm9wcztcbiAgICB3aGlsZSAocnVuRWZmZWN0cyhpbnN0LCBjb21wdXRlRWZmZWN0cywgaW5wdXRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgT2JqZWN0LmFzc2lnbihjaGFuZ2VkUHJvcHMsIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICBpbnB1dFByb3BzID0gaW5zdC5fX2RhdGFQZW5kaW5nO1xuICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImNvbXB1dGVkIHByb3BlcnR5XCIgZWZmZWN0IGJ5IHJ1bm5pbmcgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICogcmV0dXJuIHZhbHVlIHRvIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCByZXN1bHQgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbyk7XG4gIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gIGlmIChpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yICYmIGluc3QuX19kYXRhSGFzQWNjZXNzb3JbY29tcHV0ZWRQcm9wXSkge1xuICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eShjb21wdXRlZFByb3AsIHJlc3VsdCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdFtjb21wdXRlZFByb3BdID0gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgcGF0aCBjaGFuZ2VzIGJhc2VkIG9uIHBhdGggbGlua3Mgc2V0IHVwIHVzaW5nIHRoZSBgbGlua1BhdGhzYFxuICogQVBJLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdob3NlIHByb3BzIGFyZSBjaGFuZ2luZ1xuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgY2hhbmdlZCBwYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTGlua2VkUGF0aHMoaW5zdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IGxpbmtzID0gaW5zdC5fX2RhdGFMaW5rZWRQYXRocztcbiAgaWYgKGxpbmtzKSB7XG4gICAgbGV0IGxpbms7XG4gICAgZm9yIChsZXQgYSBpbiBsaW5rcykge1xuICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgIGlmIChpc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZXNjZW5kYW50KGIsIHBhdGgpKSB7XG4gICAgICAgIGxpbmsgPSB0cmFuc2xhdGUoYiwgYSwgcGF0aCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIC0tIGJpbmRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICogZm9yIGFsbCBwYXJ0IGRlcGVuZGVuY2llcyB0byBgdGVtcGxhdGVJbmZvYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgQmluZGluZyBraW5kLCBlaXRoZXIgJ3Byb3BlcnR5JywgJ2F0dHJpYnV0ZScsIG9yICd0ZXh0J1xuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUYXJnZXQgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGxpdGVyYWwgTGl0ZXJhbCB0ZXh0IHN1cnJvdW5kaW5nIGJpbmRpbmcgcGFydHMgKHNwZWNpZmllZFxuICogICBvbmx5IGZvciAncHJvcGVydHknIGJpbmRpbmdzLCBzaW5jZSB0aGVzZSBtdXN0IGJlIGluaXRpYWxpemVkIGFzIHBhcnRcbiAqICAgb2YgYm9vdC11cClcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgLy8gQ3JlYXRlIGJpbmRpbmcgbWV0YWRhdGEgYW5kIGFkZCB0byBub2RlSW5mb1xuICBub2RlSW5mby5iaW5kaW5ncyA9IG5vZGVJbmZvLmJpbmRpbmdzIHx8IFtdO1xuICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgbm9kZUluZm8uYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgLy8gQWRkIGxpc3RlbmVyIGluZm8gdG8gYmluZGluZyBtZXRhZGF0YVxuICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICBsZXQge2V2ZW50LCBuZWdhdGV9ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyRXZlbnQgPSBldmVudCB8fCAoQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UodGFyZ2V0KSArICctY2hhbmdlZCcpO1xuICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gIH1cbiAgLy8gQWRkIFwicHJvcGFnYXRlXCIgcHJvcGVydHkgZWZmZWN0cyB0byB0ZW1wbGF0ZUluZm9cbiAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gIGZvciAobGV0IGk9MDsgaTxiaW5kaW5nLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzW2ldO1xuICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRoZSBnaXZlbiBgdGVtcGxhdGVJbmZvYCBmb3IgdGhlIGdpdmVuIGJpbmRpbmdcbiAqIHBhcnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICogICBydW5uaW5nIG9uXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGludG8gYG5vZGVJbmZvTGlzdGAgZm9yIHRoaXMgbm9kZVxuICovXG5mdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICBpZiAoIXBhcnQubGl0ZXJhbCkge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09ICdhdHRyaWJ1dGUnICYmIGJpbmRpbmcudGFyZ2V0WzBdID09PSAnLScpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBzdGFydGluZyBjaGFyYWN0ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgbGV0IGluZm8gPSB7IGluZGV4LCBiaW5kaW5nLCBwYXJ0LCBldmFsdWF0b3I6IGNvbnN0cnVjdG9yIH07XG4gICAgICBmb3IgKGxldCBqPTA7IGo8ZGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gcGFyc2VBcmcodHJpZ2dlcik7XG4gICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IuX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCB0cmlnZ2VyLnJvb3RQcm9wZXJ0eSwge1xuICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgIGluZm8sIHRyaWdnZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJiaW5kaW5nXCIgKHByb3BlcnR5L3BhdGggYmluZGluZykgZWZmZWN0LlxuICpcbiAqIE5vdGUgdGhhdCBiaW5kaW5nIHN5bnRheCBpcyBvdmVycmlkYWJsZSB2aWEgYF9wYXJzZUJpbmRpbmdzYCBhbmRcbiAqIGBfZXZhbHVhdGVCaW5kaW5nYC4gIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgX2V2YWx1YXRlQmluZGluZ2AgZm9yIGFueVxuICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAqIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIF9wYXRoXyBiaW5kaW5ncyB2aWEgY3VzdG9tIGJpbmRpbmcgcGFydHMsXG4gKiBhcyB0aGlzIGlzIHNwZWNpZmljIHRvIFBvbHltZXIncyBwYXRoIGJpbmRpbmcgc3ludGF4LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlTGlzdCBMaXN0IG9mIG5vZGVzIGFzc29jaWF0ZWQgd2l0aCBgbm9kZUluZm9MaXN0YCB0ZW1wbGF0ZVxuICogICBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQmluZGluZ0VmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzLCBub2RlTGlzdCkge1xuICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICBsZXQgYmluZGluZyA9IGluZm8uYmluZGluZztcbiAgbGV0IHBhcnQgPSBpbmZvLnBhcnQ7XG4gIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAvLyBlLmcuOiBmb289XCJ7e29iai5zdWJ9fVwiLCBwYXRoOiAnb2JqLnN1Yi5wcm9wJywgc2V0ICdmb28ucHJvcCc9b2JqLnN1Yi5wcm9wXG4gIGlmIChoYXNQYXRocyAmJiBwYXJ0LnNvdXJjZSAmJiAocGF0aC5sZW5ndGggPiBwYXJ0LnNvdXJjZS5sZW5ndGgpICYmXG4gICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvcltiaW5kaW5nLnRhcmdldF0pIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twYXRoXTtcbiAgICBwYXRoID0gdHJhbnNsYXRlKHBhcnQuc291cmNlLCBiaW5kaW5nLnRhcmdldCwgcGF0aCk7XG4gICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgdmFsdWUgPSBpbmZvLmV2YWx1YXRvci5fZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgIC8vIFByb3BhZ2F0ZSB2YWx1ZSB0byBjaGlsZFxuICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhbiBcImJpbmRpbmdcIiAoYmluZGluZykgZWZmZWN0IHRvIGEgbm9kZSxcbiAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSBvd25pbmcgdGhlIGJpbmRpbmcgZWZmZWN0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGFyZ2V0IG5vZGUgZm9yIGJpbmRpbmdcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpIHtcbiAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgaWYgKHNhbml0aXplRE9NVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNhbml0aXplRE9NVmFsdWUodmFsdWUsIGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLmtpbmQsIG5vZGUpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ1xuICAgIGluc3QuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8obm9kZSksIHZhbHVlLCBiaW5kaW5nLnRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvcGVydHkgYmluZGluZ1xuICAgIGxldCBwcm9wID0gYmluZGluZy50YXJnZXQ7XG4gICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgaWYgKCFub2RlW1RZUEVTLlJFQURfT05MWV0gfHwgIW5vZGVbVFlQRVMuUkVBRF9PTkxZXVtwcm9wXSkge1xuICAgICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgIHtcbiAgICAgIGluc3QuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gKiBlZmZlY3QgbWV0YWRhdGEsIGFzIHdlbGwgYXMgaGFuZGxpbmcgZm9yIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEByZXR1cm4geyp9IFRyYW5zZm9ybWVkIHZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCkge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgc3RvcmFnZVtwYXJ0LmNvbXBvdW5kSW5kZXhdID0gdmFsdWU7XG4gICAgdmFsdWUgPSBzdG9yYWdlLmpvaW4oJycpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgIT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZXJpYWxpemUgYHVuZGVmaW5lZGAgdG8gYFwidW5kZWZpbmVkXCJgXG4gICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgIChub2RlLmxvY2FsTmFtZSA9PSAnaW5wdXQnICYmIGJpbmRpbmcudGFyZ2V0ID09ICd2YWx1ZScpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBiaW5kaW5nJ3MgbWV0YWRhdGEgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgdG8gYWxsb3dcbiAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAqIGFkZGVkOlxuICogLSB1c2VkIGN1cmx5IGJyYWNlc1xuICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gKiAtIGlzIG5vdCBhIHRleHRDb250ZW50IGJpbmRpbmdcbiAqIC0gaXMgbm90IGNvbXBvdW5kXG4gKlxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIDItd2F5IGxpc3RlbmVyIHNob3VsZCBiZSBhZGRlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykge1xuICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgIGJpbmRpbmcua2luZCAhPSAnYXR0cmlidXRlJyAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICd0ZXh0JyAmJlxuICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgYmluZGluZy5wYXJ0c1swXS5tb2RlID09PSAneyc7XG59XG5cbi8qKlxuICogU2V0dXAgY29tcG91bmQgYmluZGluZyBzdG9yYWdlIHN0cnVjdHVyZXMsIG5vdGlmeSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdFxuICogcmVmZXJlbmNlcyBvbnRvIHRoZSBib3VuZCBub2RlTGlzdC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRoYXQgYmFzIGJlZW4gcHJldmlvdXNseSBib3VuZFxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBCaW5kaW5ncyhpbnN0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gIGxldCB7bm9kZUxpc3QsIG5vZGVJbmZvTGlzdH0gPSB0ZW1wbGF0ZUluZm87XG4gIGlmIChub2RlSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaW5mbyA9IG5vZGVJbmZvTGlzdFtpXTtcbiAgICAgIGxldCBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZyk7XG4gICAgICAgICAgYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuX19kYXRhSG9zdCA9IGluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYF9fZGF0YUNvbXBvdW5kU3RvcmFnZWAgbG9jYWwgc3RvcmFnZSBvbiBhIGJvdW5kIG5vZGUgd2l0aFxuICogaW5pdGlhbCBsaXRlcmFsIGRhdGEgZm9yIGNvbXBvdW5kIGJpbmRpbmdzLCBhbmQgc2V0cyB0aGUgam9pbmVkXG4gKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAqXG4gKiBXaGVuIGNoYW5nZXMgdG8gY29tcG91bmQgcGFydHMgb2NjdXIsIHRoZXkgYXJlIGZpcnN0IHNldCBpbnRvIHRoZSBjb21wb3VuZFxuICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAqIHRoZSBmaW5hbCB2YWx1ZSBzZXQgdG8gdGhlIHByb3BlcnR5L2F0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fFxuICAgICAgKG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlID0ge30pO1xuICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgLy8gQ29weSBsaXRlcmFscyBmcm9tIHBhcnRzIGludG8gc3RvcmFnZSBmb3IgdGhpcyBiaW5kaW5nXG4gICAgbGV0IGxpdGVyYWxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaXRlcmFsc1tqXSA9IHBhcnRzW2pdLmxpdGVyYWw7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBzdG9yYWdlW3RhcmdldF0gPSBsaXRlcmFscztcbiAgICAvLyBDb25maWd1cmUgcHJvcGVydGllcyB3aXRoIHRoZWlyIGxpdGVyYWwgcGFydHNcbiAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICBub2RlW3RhcmdldF0gPSBiaW5kaW5nLmxpdGVyYWw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIENoaWxkIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5saXN0ZW5lckV2ZW50KSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmxpc3RlbmVyRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihlLCBpbnN0LCBiaW5kaW5nLnRhcmdldCwgcGFydC5zb3VyY2UsIHBhcnQubmVnYXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyBmb3IgZWFjaCBhcmd1bWVudCBpbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSAoYW5kXG4gKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICogcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHByb3BlcnR5IGVmZmVjdCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAqIEBwYXJhbSB7Kj19IG1ldGhvZEluZm8gRWZmZWN0LXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluXG4gKiAgIG1ldGhvZCBlZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LiBOb3RlLFxuICogICBkZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgc3RhdGljIChzaWcuc3RhdGljIGlzIHRydWUpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRWZmZWN0KG1vZGVsLCBzaWcsIHR5cGUsIGVmZmVjdEZuLCBtZXRob2RJbmZvLCBkeW5hbWljRm4pIHtcbiAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgKHR5cGVvZiBkeW5hbWljRm4gIT09ICdvYmplY3QnIHx8IGR5bmFtaWNGbltzaWcubWV0aG9kTmFtZV0pKTtcbiAgbGV0IGluZm8gPSB7XG4gICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgYXJnczogc2lnLmFyZ3MsXG4gICAgbWV0aG9kSW5mbyxcbiAgICBkeW5hbWljRm5cbiAgfTtcbiAgZm9yIChsZXQgaT0wLCBhcmc7IChpPHNpZy5hcmdzLmxlbmd0aCkgJiYgKGFyZz1zaWcuYXJnc1tpXSk7IGkrKykge1xuICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChhcmcucm9vdFByb3BlcnR5LCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mbywgdHJpZ2dlcjogYXJnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGR5bmFtaWNGbikge1xuICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChzaWcubWV0aG9kTmFtZSwgdHlwZSwge1xuICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyBtYXJzaGFsZWQgZnJvbSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZVxuICogYmFzZWQgb24gdGhlIG1ldGhvZCBzaWduYXR1cmUgY29udGFpbmVkIGluIHRoZSBlZmZlY3QgbWV0YWRhdGEuXG4gKlxuICogTXVsdGktcHJvcGVydHkgb2JzZXJ2ZXJzLCBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICogZnVuY3Rpb25zIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBpbnZva2UgdGhlIG1ldGhvZCwgdGhlbiB1c2UgdGhlIHJldHVyblxuICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbWV0aG9kIGludm9jYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBsZXQgY29udGV4dCA9IGluc3QuX21ldGhvZEhvc3QgfHwgaW5zdDtcbiAgbGV0IGZuID0gY29udGV4dFtpbmZvLm1ldGhvZE5hbWVdO1xuICBpZiAoZm4pIHtcbiAgICBsZXQgYXJncyA9IG1hcnNoYWxBcmdzKGluc3QuX19kYXRhLCBpbmZvLmFyZ3MsIHByb3BlcnR5LCBwcm9wcyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2FybignbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5cbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgYmluZGluZ1xuY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbmNvbnN0IE5VTUJFUiA9ICcoPzonICsgJ1stK10/WzAtOV0qXFxcXC4/WzAtOV0rKD86W2VFXVstK10/WzAtOV0rKT8nICsgJyknO1xuY29uc3QgU1FVT1RFX1NUUklORyA9ICcoPzonICsgJ1xcJyg/OlteXFwnXFxcXFxcXFxdfFxcXFxcXFxcLikqXFwnJyArICcpJztcbmNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG5jb25zdCBTVFJJTkcgPSAnKD86JyArIFNRVU9URV9TVFJJTkcgKyAnfCcgKyBEUVVPVEVfU1RSSU5HICsgJyknO1xuY29uc3QgQVJHVU1FTlQgPSAnKD86KCcgKyBJREVOVCArICd8JyArIE5VTUJFUiArICd8JyArICBTVFJJTkcgKyAnKVxcXFxzKicgKyAnKSc7XG5jb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuY29uc3QgQVJHVU1FTlRfTElTVCA9ICcoPzonICsgJ1xcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIEFSR1VNRU5UUyArICc/JyArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbmNvbnN0IEJJTkRJTkcgPSAnKCcgKyBJREVOVCArICdcXFxccyonICsgQVJHVU1FTlRfTElTVCArICc/JyArICcpJzsgLy8gR3JvdXAgM1xuY29uc3QgT1BFTl9CUkFDS0VUID0gJyhcXFxcW1xcXFxbfHt7KScgKyAnXFxcXHMqJztcbmNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbmNvbnN0IE5FR0FURSA9ICcoPzooISlcXFxccyopPyc7IC8vIEdyb3VwIDJcbmNvbnN0IEVYUFJFU1NJT04gPSBPUEVOX0JSQUNLRVQgKyBORUdBVEUgKyBCSU5ESU5HICsgQ0xPU0VfQlJBQ0tFVDtcbmNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHN0cmluZyBmcm9tIGJpbmRpbmcgcGFydHMgb2YgYWxsIHRoZSBsaXRlcmFsIHBhcnRzXG4gKlxuICogQHBhcmFtIHshQXJyYXk8QmluZGluZ1BhcnQ+fSBwYXJ0cyBBbGwgcGFydHMgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBtYWRlIGZyb20gdGhlIGxpdGVyYWwgcGFydHNcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykge1xuICBsZXQgcyA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbGl0ZXJhbCA9IHBhcnRzW2ldLmxpdGVyYWw7XG4gICAgcyArPSBsaXRlcmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHN0cmluZyBmb3IgYSBtZXRob2Qgc2lnbmF0dXJlLCBhbmQgcmV0dXJucyBhIG1ldGFkYXRhXG4gKiBkZXNjcmliaW5nIHRoZSBtZXRob2QgaW4gdGVybXMgb2YgYG1ldGhvZE5hbWVgLCBgc3RhdGljYCAod2hldGhlciBhbGwgdGhlXG4gKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICogICBmb3VuZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU1ldGhvZChleHByZXNzaW9uKSB7XG4gIC8vIHRyaWVzIHRvIG1hdGNoIHZhbGlkIGphdmFzY3JpcHQgcHJvcGVydHkgbmFtZXNcbiAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgaWYgKG0pIHtcbiAgICBsZXQgbWV0aG9kTmFtZSA9IG1bMV07XG4gICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgaWYgKG1bMl0udHJpbSgpKSB7XG4gICAgICAvLyByZXBsYWNlIGVzY2FwZWQgY29tbWFzIHdpdGggY29tbWEgZW50aXR5LCBzcGxpdCBvbiB1bi1lc2NhcGVkIGNvbW1hc1xuICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgIHJldHVybiBwYXJzZUFyZ3MoYXJncywgc2lnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICogc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdC4gU2V0cyB0aGUgYHN0YXRpY2AgcHJvcGVydHkgdG8gZmFsc2UgaWYgYW55XG4gKiBhcmd1bWVudCBpcyBhIG5vbi1saXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGFyZ0xpc3QgQXJyYXkgb2YgYXJndW1lbnQgbmFtZXNcbiAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gIHNpZy5hcmdzID0gYXJnTGlzdC5tYXAoZnVuY3Rpb24ocmF3QXJnKSB7XG4gICAgbGV0IGFyZyA9IHBhcnNlQXJnKHJhd0FyZyk7XG4gICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgc2lnLnN0YXRpYyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gaW5kaXZpZHVhbCBhcmd1bWVudCwgYW5kIHJldHVybnMgYW4gYXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqICAge1xuICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAqICAgICBsaXRlcmFsOiBmYWxzZSwgICAgICAgLy8gd2hldGhlciBhcmd1bWVudCBpcyBhIGxpdGVyYWxcbiAqICAgICBzdHJ1Y3R1cmVkOiBmYWxzZSwgICAgLy8gd2hldGhlciB0aGUgcHJvcGVydHkgaXMgYSBwYXRoXG4gKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gKiAgICAgd2lsZGNhcmQ6IGZhbHNlICAgICAgIC8vIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHdhcyBhIHdpbGRjYXJkICcuKicgcGF0aFxuICogICB9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhd0FyZyBUaGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICogQHJldHVybiB7IU1ldGhvZEFyZ30gQXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZyhyYXdBcmcpIHtcbiAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICBsZXQgYXJnID0gcmF3QXJnLnRyaW0oKVxuICAgIC8vIHJlcGxhY2UgY29tbWEgZW50aXR5IHdpdGggY29tbWFcbiAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgLy8gcmVwYWlyIGV4dHJhIGVzY2FwZSBzZXF1ZW5jZXM7IG5vdGUgb25seSBjb21tYXMgc3RyaWN0bHkgbmVlZFxuICAgIC8vIGVzY2FwaW5nLCBidXQgd2UgYWxsb3cgYW55IG90aGVyIGNoYXIgdG8gYmUgZXNjYXBlZCBzaW5jZSBpdHNcbiAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgLnJlcGxhY2UoL1xcXFwoLikvZywgJ1xcJDEnKVxuICAgIDtcbiAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICBsZXQgYSA9IHtcbiAgICBuYW1lOiBhcmcsXG4gICAgdmFsdWU6ICcnLFxuICAgIGxpdGVyYWw6IGZhbHNlXG4gIH07XG4gIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gIGxldCBmYyA9IGFyZ1swXTtcbiAgaWYgKGZjID09PSAnLScpIHtcbiAgICBmYyA9IGFyZ1sxXTtcbiAgfVxuICBpZiAoZmMgPj0gJzAnICYmIGZjIDw9ICc5Jykge1xuICAgIGZjID0gJyMnO1xuICB9XG4gIHN3aXRjaChmYykge1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOlxuICAgICAgYS52YWx1ZSA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gaWYgbm90IGxpdGVyYWwsIGxvb2sgZm9yIHN0cnVjdHVyZWQgcGF0aFxuICBpZiAoIWEubGl0ZXJhbCkge1xuICAgIGEucm9vdFByb3BlcnR5ID0gcm9vdCQwKGFyZyk7XG4gICAgLy8gZGV0ZWN0IHN0cnVjdHVyZWQgcGF0aCAoaGFzIGRvdHMpXG4gICAgYS5zdHJ1Y3R1cmVkID0gaXNQYXRoJDAoYXJnKTtcbiAgICBpZiAoYS5zdHJ1Y3R1cmVkKSB7XG4gICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICBpZiAoYS53aWxkY2FyZCkge1xuICAgICAgICBhLm5hbWUgPSBhcmcuc2xpY2UoMCwgLTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICogb2YgYXJndW1lbnQgbWV0YWRhdGEuXG4gKlxuICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gKiB3aGVuIHRoZSBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIGEgcmVzdWx0IG9mIGEgcGF0aCBub3RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHshQXJyYXk8IU1ldGhvZEFyZz59IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggbmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgbWV0aG9kIGVmZmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBBcnJheSBvZiBhcmd1bWVudCB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxBcmdzKGRhdGEsIGFyZ3MsIHBhdGgsIHByb3BzKSB7XG4gIGxldCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgIGxldCBuYW1lID0gYXJnLm5hbWU7XG4gICAgbGV0IHY7XG4gICAgaWYgKGFyZy5saXRlcmFsKSB7XG4gICAgICB2ID0gYXJnLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLnN0cnVjdHVyZWQpIHtcbiAgICAgICAgdiA9IGdldCQwKGRhdGEsIG5hbWUpO1xuICAgICAgICAvLyB3aGVuIGRhdGEgaXMgbm90IHN0b3JlZCBlLmcuIGBzcGxpY2VzYFxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgLy8gT25seSBzZW5kIHRoZSBhY3R1YWwgcGF0aCBjaGFuZ2VkIGluZm8gaWYgdGhlIGNoYW5nZSB0aGF0XG4gICAgICAvLyBjYXVzZWQgdGhlIG9ic2VydmVyIHRvIHJ1biBtYXRjaGVkIHRoZSB3aWxkY2FyZFxuICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICBsZXQgbWF0Y2hlcyA9IChwYXRoLmluZGV4T2YobmFtZSkgPT09IDAgJiYgIWJhc2VDaGFuZ2VkKTtcbiAgICAgIHZhbHVlc1tpXSA9IHtcbiAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWF0Y2hlcyA/IHByb3BzW3BhdGhdIDogdixcbiAgICAgICAgYmFzZTogdlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2ldID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gZGF0YSBhcGlcblxuLyoqXG4gKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICpcbiAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBzcGxpY2VzKSB7XG4gIGxldCBzcGxpY2VzUGF0aCA9IHBhdGggKyAnLnNwbGljZXMnO1xuICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICBpbnN0Lm5vdGlmeVBhdGgocGF0aCArICcubGVuZ3RoJywgYXJyYXkubGVuZ3RoKTtcbiAgLy8gTnVsbCBoZXJlIHRvIGFsbG93IHBvdGVudGlhbGx5IGxhcmdlIHNwbGljZSByZWNvcmRzIHRvIGJlIEdDJ2VkLlxuICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAqIHRoZSBkZXNjcmliZWQgbXV0YXRpb25cbiAqXG4gKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRoZSBhcnJheSBtdXRhdGlvbiBvY2N1cnJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSByZW1vdmVkIEFycmF5IG9mIHJlbW92ZWQgaXRlbXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZShpbnN0LCBhcnJheSwgcGF0aCwgaW5kZXgsIGFkZGVkQ291bnQsIHJlbW92ZWQpIHtcbiAgbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgW3tcbiAgICBpbmRleDogaW5kZXgsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIG9iamVjdDogYXJyYXksXG4gICAgdHlwZTogJ3NwbGljZSdcbiAgfV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXItY2FzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN0cmluZyB0byB1cHBlcmNhc2VcbiAqIEByZXR1cm4ge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwcGVyKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xufVxuXG5leHBvcnQgY29uc3QgUHJvcGVydHlFZmZlY3RzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFRlbXBsYXRlU3RhbXAoUHJvcGVydHlBY2Nlc3NvcnMoc3VwZXJDbGFzcykpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqIEBleHRlbmRzIHtwcm9wZXJ0eUVmZmVjdHNCYXNlfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUVmZmVjdHMgZXh0ZW5kcyBwcm9wZXJ0eUVmZmVjdHNCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5O1xuICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgIC8qKiBAdHlwZSB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgICB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVRlbXA7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19jb21wdXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlZmxlY3RFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3Byb3BhZ2F0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19vYnNlcnZlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICByZXR1cm4gVFlQRVM7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICBob3N0U3RhY2sucmVnaXN0ZXJIb3N0KHRoaXMpO1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgIC8vIE1heSBiZSBzZXQgb24gaW5zdGFuY2UgcHJpb3IgdG8gdXBncmFkZVxuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gdGhpcy5fX2RhdGFIb3N0IHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgKiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBpbml0aWFsaXppbmcgcHJvcGVydGllcyBmcm9tXG4gICAgICogdGhlIHByb3RvdHlwZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgdGhpcy5fX2RhdGEgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIHNldHRpbmdcbiAgICAgKiBgX3NldFByb3BlcnR5YCdzIGBzaG91bGROb3RpZnk6IHRydWVgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgbGV0IHJlYWRPbmx5ID0gdGhpc1tUWVBFUy5SRUFEX09OTFldO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIXJlYWRPbmx5IHx8ICFyZWFkT25seVtwcm9wXSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHRoaXMuX19kYXRhUGVuZGluZyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BdID0gdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm90b3R5cGUgc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGFkZFByb3BlcnR5RWZmZWN0YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCB0eXBlID09IFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcHJvcGVydHkgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoZSBlZmZlY3Qgd2FzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgbGV0IGlkeCA9IGVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBwcm9wZXJ0eSBlZmZlY3RcbiAgICAgKiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3R5cGVdO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0cyAmJiBlZmZlY3RzW3Byb3BlcnR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlYWQgb25seVwiXG4gICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJub3RpZnlcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc05vdGlmeUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUmVmbGVjdEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwiY29tcHV0ZWRcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLkNPTVBVVEUpO1xuICAgIH1cblxuICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHBlbmRpbmcgcHJvcGVydHkgb3IgcGF0aC4gIElmIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoIGluXG4gICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAqIHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICogZm9yIHRoZSBwdWJsaWMgQVBJIChgc2V0YCwgYHNldFByb3BlcnRpZXNgLCBgbm90aWZ5UGF0aGAsIGFuZCBwcm9wZXJ0eVxuICAgICAqIGNoYW5nZSBsaXN0ZW5lcnMgdmlhIHt7Li4ufX0gYmluZGluZ3MpLCBzdWNoIHRoYXQgaXQgaXMgb25seSBkb25lXG4gICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAqIGFsc28gc2V0cyBhIGBfX2RhdGFIYXNQYXRoc2AgZmxhZyBvbiB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCB0b1xuICAgICAqIGZhc3QtcGF0aCBzbG93ZXIgcGF0aC1tYXRjaGluZyBjb2RlIGluIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIGhvc3QgcGF0aHMuXG4gICAgICpcbiAgICAgKiBgcGF0aGAgY2FuIGJlIGEgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2YgcGF0aCBwYXJ0cyBhcyBhY2NlcHRlZCBieSB0aGVcbiAgICAgKiBwdWJsaWMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgKiAgY2F1c2UgYSBwcm9wZXJ0eSBub3RpZmljYXRpb24gZXZlbnQgZGlzcGF0Y2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1BhdGhOb3RpZmljYXRpb24gSWYgdGhlIHBhdGggYmVpbmcgc2V0IGlzIGEgcGF0aFxuICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgKiAgIHRvIHNldCBhbmQgbm90aWZ5IHRoZSBjaGFuZ2UuICBJbiB0aGUgbGF0dGVyIGBmYWxzZWAgY2FzZSwgYSBkaXJ0eVxuICAgICAqICAgY2hlY2sgaXMgcGVyZm9ybWVkIGFuZCB0aGVuIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHBhdGggYmVmb3JlXG4gICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkvcGF0aCB3YXMgZW5xdWV1ZWQgaW5cbiAgICAgKiAgIHRoZSBwZW5kaW5nIGNoYW5nZXMgYmFnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBzaG91bGROb3RpZnksIGlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgIHJvb3QkMChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGgpICE9PSBwYXRoKSB7XG4gICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgcGF0aHMgaW50byB0aGUgc3lzdGVtOyBmcm9tIGhlcmVcbiAgICAgICAgLy8gdGhlIG9ubHkgZGlydHkgY2hlY2tzIGFyZSBhZ2FpbnN0IHRoZSBgX19kYXRhVGVtcGAgY2FjaGUgdG8gcHJldmVudFxuICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIC8vIG9mIGEgY2hhbmdlIGFscmVhZHkgc2V0IHRvIGEgcGF0aCAoaXNQYXRoTm90aWZpY2F0aW9uOiB0cnVlKSxcbiAgICAgICAgLy8gd2UgYWx3YXlzIGxldCB0aGUgY2hhbmdlIHRocm91Z2ggYW5kIHNraXAgdGhlIGBzZXRgIHNpbmNlIGl0IHdhc1xuICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmICghaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbGV0IG9sZCA9IGdldCQwKHRoaXMsIHBhdGgpO1xuICAgICAgICAgIHBhdGggPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNldCQwKHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgLy8gVXNlIHByb3BlcnR5LWFjY2Vzc29yJ3Mgc2ltcGxlciBkaXJ0eSBjaGVja1xuICAgICAgICAgIGlmICghcGF0aCB8fCAhc3VwZXIuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHBhdGgsIHZhbHVlLCBvbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSkpIHtcbiAgICAgICAgICBjb21wdXRlTGlua2VkUGF0aHModGhpcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG1ha2VzIGEgYmVzdC1lZmZvcnQgYXQgYmluZGluZyBpbnRlcm9wOlxuICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICogcmUtc2V0dGluZyB0aGUgc2FtZSB2YWx1ZSAoZS5nLiBzZXR0aW5nIGA8aW5wdXQ+LnZhbHVlYCByZXNldHMgdGhlXG4gICAgICogY3Vyc29yIHBvc2l0aW9uKSwgc28gd2UgZG8gYSBkaXJ0eS1jaGVjayBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUuXG4gICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgKiBhY2NlcHQgb2JqZWN0cywgd2UgZXhwbGljaXRseSByZS1zZXQgb2JqZWN0IGNoYW5nZXMgY29taW5nIGZyb20gdGhlXG4gICAgICogUG9seW1lciB3b3JsZCAod2hpY2ggbWF5IGluY2x1ZGUgZGVlcCBvYmplY3QgY2hhbmdlcyB3aXRob3V0IHRoZVxuICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIC8vIEl0IGlzIGEganVkZ21lbnQgY2FsbCB0aGF0IHJlc2V0dGluZyBwcmltaXRpdmVzIGlzXG4gICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgLy8gaW1wbGVtZW50IGEgd2hpdGVsaXN0IG9mIHRhZyAmIHByb3BlcnR5IHZhbHVlcyB0aGF0IHNob3VsZCBuZXZlclxuICAgICAgLy8gYmUgcmVzZXQgKGUuZy4gPGlucHV0Pi52YWx1ZSAmJiA8c2VsZWN0Pi52YWx1ZSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBpbnRyb2R1Y2Ugc3BlY2lhbFxuICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICpcbiAgICAgKiAxLiBBbnkgdmFsdWUgc2V0IHRvIGEgcGF0aCAoZS5nLiAnb2JqLnByb3AnOiA0MiBvciAnb2JqLnByb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICogMi4gT2JqZWN0IHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgIGFuZCBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0XG4gICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgKiAzLiBQcmltaXRpdmUgdmFsdWUgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IDQyKVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFgXG4gICAgICpcbiAgICAgKiBUaGUgZGlydHktY2hlY2sgaXMgaW1wb3J0YW50IHRvIHByZXZlbnQgY3ljbGVzIGR1ZSB0byB0d28td2F5XG4gICAgICogbm90aWZpY2F0aW9uLCBidXQgcGF0aHMgYW5kIG9iamVjdHMgYXJlIG9ubHkgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGFueVxuICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAqIGNsZWFyZWQgd2hlbiB0aGUgbGFzdCBgX3Byb3BlcnRpZXNDaGFnZWRgIGV4aXRzLiBUaGlzIGlzIHNvOlxuICAgICAqIGEuIGFueSBjYWNoZWQgYXJyYXkgcGF0aHMgKGUuZy4gJ2FycmF5LjMucHJvcCcpIG1heSBiZSBpbnZhbGlkYXRlZFxuICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICogICAgc2luY2UgcGF0aCBjaGFuZ2VzIGFyZSBkaXJ0eS1jaGVja2VkIGF0IHVzZXIgZW50cnkgcG9pbnRzIGxpa2UgYHNldGBcbiAgICAgKiBiLiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBvbmx5IGxhc3RzIG9uZSB0dXJuIHRvIGFsbG93IHRoZSB1c2VyXG4gICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICogICAgYW5kIGhhdmUgYWxsIHN1Yi1wcm9wZXJ0aWVzIHJlLXByb3BhZ2F0ZWQgaW4gYSBzdWJzZXF1ZW50IHR1cm4uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgKiBwYXRocywgc2luY2UgYSBzcGxpY2UgY2FuIGhhcHBlbiBkdXJpbmcgdGhlIHNhbWUgdHVybiAod2l0aCBwYXRob2xvZ2ljYWxcbiAgICAgKiB1c2VyIGNvZGUpOyB3ZSBjb3VsZCBpbnRyb2R1Y2UgYSBcImZpeHVwXCIgZm9yIHRlbXBvcmFyaWx5IGNhY2hlZCBhcnJheVxuICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgVHJ1ZSBpZiBwcm9wZXJ0eSBzaG91bGQgZmlyZSBub3RpZmljYXRpb25cbiAgICAgKiAgIGV2ZW50IChhcHBsaWVzIG9ubHkgZm9yIGBub3RpZnk6IHRydWVgIHByb3BlcnRpZXMpXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgbGV0IGlzUGF0aCA9IHRoaXMuX19kYXRhSGFzUGF0aHMgJiYgaXNQYXRoJDAocHJvcGVydHkpO1xuICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgcHJldlByb3BzW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICghKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXRocyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2YgdHVybiksXG4gICAgICAgIC8vIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nLCBhbGwgb3RoZXJzIHN0b3JlZCBpbiBfX2RhdGFcbiAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgY2hhbmdlcyBnbyBpbnRvIHBlbmRpbmcgcHJvcGVydHkgYmFnLCBwYXNzZWQgdG8gX3Byb3BlcnRpZXNDaGFuZ2VkXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgLy8gVHJhY2sgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3RpZnkgc2VwYXJhdGVseVxuICAgICAgICBpZiAoaXNQYXRoIHx8ICh0aGlzW1RZUEVTLk5PVElGWV0gJiYgdGhpc1tUWVBFUy5OT1RJRlldW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5W3Byb3BlcnR5XSA9IHNob3VsZE5vdGlmeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgYWxsIGFjY2Vzc29ycyBzZXQgYHNob3VsZE5vdGlmeWBcbiAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcmAncyBkZWZhdWx0IGFzeW5jIHF1ZXVpbmcgb2ZcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYDogaWYgYF9fZGF0YVJlYWR5YCBpcyBmYWxzZSAoaGFzIG5vdCB5ZXQgYmVlblxuICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIHN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2xpZW50IG9uIGEgbGlzdCBvZiBwZW5kaW5nIGNsaWVudHMsIHdob3NlXG4gICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgKiBgX2ZsdXNoQ2xpZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzIHx8IFtdO1xuICAgICAgaWYgKGNsaWVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFueSBjbGllbnRzIHByZXZpb3VzbHkgZW5xdWV1ZWQgdmlhIGBfZW5xdWV1ZUNsaWVudGAsIGNhdXNpbmdcbiAgICAgKiB0aGVpciBgX2ZsdXNoUHJvcGVydGllc2AgbWV0aG9kIHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCB3aGVyZSBhY2Nlc3NvcnMgYXJlIHR1cm5lZCBvbjsgaW1wb3J0YW50bHksXG4gICAgICAgIC8vIHRoaXMgaXMgYWZ0ZXIgY2xpZW50cyBoYXZlIGZ1bGx5IHJlYWRpZWQsIHByb3ZpZGluZyBhIGd1YXJhbnRlZVxuICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAvLyBoYW5kbGVzIHR3byBjb3JuZXIgY2FzZXM6XG4gICAgLy8gKDEpIGNsaWVudHMgZmx1c2ggcHJvcGVybHkgd2hlbiBjb25uZWN0ZWQvZW5hYmxlZCBiZWZvcmUgdGhlIGhvc3RcbiAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgLy8gICAoYSkgVGVtcGxhdGl6ZSBzdGFtcHMgd2l0aCBubyBwcm9wZXJ0aWVzIGFuZCBkb2VzIG5vdCBmbHVzaCBhbmRcbiAgICAvLyAgIChiKSB0aGUgaW5zdGFuY2UgaXMgaW5zZXJ0ZWQgaW50byBkb20gYW5kXG4gICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAvLyAoMikgY2xpZW50cyBlbmFibGUgcHJvcGVybHkgd2hlbiBub3QgY29ubmVjdGVkL2VuYWJsZWQgd2hlbiB0aGUgaG9zdFxuICAgIC8vIGZsdXNoZXM7IGUuZy5cbiAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgIC8vICAgKGIpIGEgaG9zdCBzZXRzIGEgcHJvcGVydHksIGNhdXNpbmcgc3RhbXBlZCBkb20gdG8gZmx1c2hcbiAgICAvLyAgIChjKSB0aGUgc3RhbXBlZCBkb20gZW5hYmxlcy5cbiAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgbGV0IGNsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgaWYgKGNsaWVudHMpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgY2xpZW50ID0gY2xpZW50c1tpXTtcbiAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICBjbGllbnQuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudC5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgKiBgX2ZsdXNoUHJvcGVydGllc2AgY2FsbCBvbiBjbGllbnQgZG9tIGFuZCBiZWZvcmUgYW55IGVsZW1lbnRcbiAgICAgKiBvYnNlcnZlcnMgYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGJhZyBvZiBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHRoaXMgaW5zdGFuY2UsIGFuZFxuICAgICAqIHN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzIGFsbCBlZmZlY3RzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIGEgYmF0Y2guXG4gICAgICpcbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtdXN0IGJlIHNpbXBsZSBwcm9wZXJ0aWVzLCBub3QgcGF0aHMuICBCYXRjaGVkXG4gICAgICogcGF0aCBwcm9wYWdhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBvbmUgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2hvc2Uga2V5IGlzXG4gICAgICogICBhIHByb3BlcnR5IGFuZCB2YWx1ZSBpcyB0aGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgKiAgIGBwcm9wc2Agd2lsbCBiZSBzZXQuIEJ5IGRlZmF1bHQsIGBzZXRQcm9wZXJ0aWVzYCB3aWxsIG5vdCBzZXRcbiAgICAgKiAgIGByZWFkT25seTogdHJ1ZWAgcm9vdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKHByb3BzLCBzZXRSZWFkT25seSkge1xuICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2V0UmVhZE9ubHkgfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldW3BhdGhdKSB7XG4gICAgICAgICAgLy9UT0RPKGtzY2hhYWYpOiBleHBsaWNpdGx5IGRpc2FsbG93IHBhdGhzIGluIHNldFByb3BlcnR5P1xuICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAvLyBpbiB0aGUgYGluZm9gIG9iamVjdCwgYW5kIHlvdSBjb3VsZCBkbyBzb21lIG9kZCB0aGluZ3MgYmF0Y2hpbmdcbiAgICAgICAgICAvLyBwYXRocywgZS5nLiB7J2Zvby5iYXInOiB7Li4ufSwgJ2Zvbyc6IG51bGx9XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICogc2lkZSBlZmZlY3RzIGFyZSBub3QgZW5hYmxlZCB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGZ1bGx5IHJlYWR5LlxuICAgICAqIEFsc28gY2FsbHMgYF9mbHVzaENsaWVudHNgIGNhbGxiYWNrIHRvIGVuc3VyZSBjbGllbnQgZG9tIGlzIGVuYWJsZWRcbiAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCBgc3VwZXIucmVhZHkoKWAgaXMgbm90IGNhbGxlZCBoZXJlIGFzIGl0XG4gICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgIC8vIHRvIGVuYWJsZSBhY2Nlc3NvcnMgdG8gcHJvdmlkZSBhIGd1YXJhbnRlZSB0aGF0IGNsaWVudHMgYXJlIHJlYWR5XG4gICAgICAvLyBiZWZvcmUgcHJvY2Vzc2luZyBhbnkgYWNjZXNzb3JzIHNpZGUgZWZmZWN0cy5cbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgLy8gSWYgbm8gZGF0YSB3YXMgcGVuZGluZywgYF9mbHVzaFByb3BlcnRpZXNgIHdpbGwgbm90IGBmbHVzaENsaWVudHNgXG4gICAgICAvLyBzbyBlbnN1cmUgdGhpcyBpcyBkb25lLlxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgIC8vIFRoZXJlZm9yZSBhIGZsdXNoIGlzIG5lY2Vzc2FyeSBoZXJlIGlmIGRhdGEgaGFzIGJlZW4gc2V0LlxuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUFjY2Vzc29yc2AncyBwcm9wZXJ0aWVzIGNoYW5nZWQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAqIGEgc3BlY2lmaWMgb3JkZXIgKGNvbXB1dGUsIHByb3BhZ2F0ZSwgcmVmbGVjdCwgb2JzZXJ2ZSwgbm90aWZ5KS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGxldCBjID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhbmdlZFByb3BzIHx8IHt9KTtcbiAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGxldCBoYXNQYXRocyA9IHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAvLyBDb21wdXRlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkNvbXB1dGVkRWZmZWN0cyh0aGlzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgLy8gYnV0IGFmdGVyIGNvbXB1dGluZyBlZmZlY3RzIGhhdmUgYSBjaGFuY2UgdG8gYWRkIHRvIHRoZW1cbiAgICAgIGxldCBub3RpZnlQcm9wcyA9IHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIC8vIFByb3BhZ2F0ZSBwcm9wZXJ0aWVzIHRvIGNsaWVudHNcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIC8vIFJlZmxlY3QgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBPYnNlcnZlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5PQlNFUlZFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgaWYgKG5vdGlmeVByb3BzKSB7XG4gICAgICAgIHJ1bk5vdGlmeUVmZmVjdHModGhpcywgbm90aWZ5UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIHRlbXBvcmFyeSBjYWNoZSBhdCBlbmQgb2YgdHVyblxuICAgICAgaWYgKHRoaXMuX19kYXRhQ291bnRlciA9PSAxKSB7XG4gICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwcm9wYWdhdGUgYW55IHByb3BlcnR5IGNoYW5nZXMgdG8gc3RhbXBlZCB0ZW1wbGF0ZSBub2Rlc1xuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgaWYgKHRoaXNbVFlQRVMuUFJPUEFHQVRFXSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUFJPUEFHQVRFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB3aGlsZSAodGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICBoYXNQYXRocywgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgKiBhcmUgcm91dGVkIHRvIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBmcm9tIFNvdXJjZSBwYXRoIHRvIGxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxpbmtQYXRocyh0bywgZnJvbSkge1xuICAgICAgdG8gPSBub3JtYWxpemUodG8pO1xuICAgICAgZnJvbSA9IG5vcm1hbGl6ZShmcm9tKTtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzIHx8IHt9O1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBwYXRoIHRvIHVubGluayBzaG91bGQgYmUgdGhlIHRhcmdldCAoYHRvYCkgdXNlZCB3aGVuXG4gICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBUYXJnZXQgcGF0aCB0byB1bmxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVubGlua1BhdGhzKHBhdGgpIHtcbiAgICAgIHBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1twYXRoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhhdCBhbiBhcnJheSBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICB0aGlzLml0ZW1zLnNwbGljZSgxLCAxLCB7bmFtZTogJ1NhbSd9KTtcbiAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVNwbGljZXMoJ2l0ZW1zJywgW1xuICAgICAqICAgICAgIHsgaW5kZXg6IDEsIHJlbW92ZWQ6IFt7bmFtZTogJ1RvZGQnfV0sIGFkZGVkQ291bnQ6IDEsIG9iZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJyB9LFxuICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIG9yZGVyZWRcbiAgICAgKiAgIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB0byB0aGUgYXJyYXkuIEVhY2ggcmVjb3JkIHNob3VsZCBoYXZlIHRoZVxuICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAgICAqIGluZGV4OiBpbmRleCBhdCB3aGljaCB0aGUgY2hhbmdlIG9jY3VycmVkXG4gICAgICogICAgKiByZW1vdmVkOiBhcnJheSBvZiBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAqICAgICogb2JqZWN0OiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgaW4gcXVlc3Rpb25cbiAgICAgKiAgICAqIHR5cGU6IHRoZSBzdHJpbmcgbGl0ZXJhbCAnc3BsaWNlJ1xuICAgICAqXG4gICAgICogICBOb3RlIHRoYXQgc3BsaWNlIHJlY29yZHMgX211c3RfIGJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZXkgYXJlXG4gICAgICogICByZXBvcnRlZCBpbiBpbmRleCBvcmRlciAocmF3IHJlc3VsdHMgZnJvbSBgT2JqZWN0Lm9ic2VydmVgIGFyZSBub3RcbiAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICogQHB1YmxpY1xuICAgICovXG4gICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBub3RpZnlTcGxpY2VzKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHNwbGljZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVhZGluZyBhIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW4gZGVyZWZlcmVuY2luZyB1bmRlZmluZWRcbiAgICAgKiBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byByZWFkLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgZm9vLmJhci5iYXpgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgdXNlcnMuMTIubmFtZWAgb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgKiAgIGlzIHVuZGVmaW5lZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIHJvb3QpIHtcbiAgICAgIHJldHVybiBnZXQkMChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAqIGVsZW1lbnRzIGJvdW5kIHRvIHRoZSBzYW1lIHBhdGguXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgKiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW5cbiAgICAgKiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZCBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byB3cml0ZS4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYCdmb28uYmFyLmJheidgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgJ3VzZXJzLjEyLm5hbWUnYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiAgIFdoZW4gc3BlY2lmaWVkLCBubyBub3RpZmljYXRpb24gd2lsbCBvY2N1ci5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBzZXQocGF0aCwgdmFsdWUsIHJvb3QpIHtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHNldCQwKHJvb3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgZW5kIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBwdXNoIG9udG8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucHVzaCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBsZW4sIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcG9wKHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucG9wKCk7XG4gICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBhcnJheS5sZW5ndGgsIDAsIFtyZXRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAqIGZyb20gdGhlIGFycmF5IGFuZCBpbnNlcnRzIDAgb3IgbW9yZSBuZXcgaXRlbXMgaW4gdGhlaXIgcGxhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgSW5kZXggZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZy9pbnNlcnRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50IE51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3BsaWNlKHBhdGgsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGggOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAvLyBOb3JtYWxpemUgZmFuY3kgbmF0aXZlIHNwbGljZSBoYW5kbGluZyBvZiBjcmF6eSBzdGFydCB2YWx1ZXNcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBhcnJheS5sZW5ndGggLSBNYXRoLmZsb29yKC1zdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzdGFydCwgaXRlbXMubGVuZ3RoLCByZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2hpZnQocGF0aCkge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5zaGlmdCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bnNoaWZ0KHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB0aGlzLml0ZW0udXNlci5uYW1lID0gJ0JvYic7XG4gICAgICogICAgIHRoaXMubm90aWZ5UGF0aCgnaXRlbS51c2VyLm5hbWUnKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgVmFsdWUgYXQgdGhlIHBhdGggKG9wdGlvbmFsKS5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBub3RpZnlQYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCBwcm9wUGF0aDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIHZhbHVlID0gZ2V0JDAodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgIHByb3BQYXRoID0gaW5mby5wYXRoO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICBwcm9wUGF0aCA9IG5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXRoID0gLyoqIEB0eXBle3N0cmluZ30gKi8ocGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3BQYXRoLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICBpZiAocHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IHByb3BlcnR5fVxuICAgICAgfSk7XG4gICAgICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KG1ldGhvZE5hbWUsIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgb2JzZXJ2ZXIgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuT0JTRVJWRSwgcnVuTWV0aG9kRWZmZWN0LCBudWxsLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgIGZuOiBydW5Ob3RpZnlFZmZlY3QsXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICBsZXQgYXR0ciA9IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KTtcbiAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSAnICsgcHJvcGVydHkgKyAnIGNhbm5vdCBiZSByZWZsZWN0ZWQgdG8gYXR0cmlidXRlICcgK1xuICAgICAgICAgIGF0dHIgKyAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgc3RhcnRpbmcgYXR0cmlidXRlIG5hbWUuIFVzZSBhIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSB0aGlzZWFkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QsIHtcbiAgICAgICAgICBmbjogcnVuUmVmbGVjdEVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBhdHRyTmFtZTogYXR0clxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgY29tcHV0ZWQgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuQ09NUFVURSwgcnVuQ29tcHV0ZWRFZmZlY3QsIHByb3BlcnR5LCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhbiBhY2Nlc3NvciBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGFuZCBhZGRzXG4gICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyBzZXQuICBFZmZlY3RzIGFyZSBncm91cGVkIGJ5IFwidHlwZVwiLCB3aGljaFxuICAgICAqIHJvdWdobHkgY29ycmVzcG9uZHMgdG8gYSBwaGFzZSBpbiBlZmZlY3QgcHJvY2Vzc2luZy4gIFRoZSBlZmZlY3RcbiAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAqXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBmbjogZWZmZWN0RnVuY3Rpb24sIC8vIFJlZmVyZW5jZSB0byBmdW5jdGlvbiB0byBjYWxsIHRvIHBlcmZvcm0gZWZmZWN0XG4gICAgICogICAgICAgaW5mbzogeyAuLi4gfSAgICAgICAvLyBFZmZlY3QgbWV0YWRhdGEgcGFzc2VkIHRvIGZ1bmN0aW9uXG4gICAgICogICAgICAgdHJpZ2dlcjogeyAgICAgICAgICAvLyBPcHRpb25hbCB0cmlnZ2VyaW5nIG1ldGFkYXRhOyBpZiBub3QgcHJvdmlkZWRcbiAgICAgKiAgICAgICAgIG5hbWU6IHN0cmluZyAgICAgIC8vIHRoZSBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIGEgd2lsZGNhcmRcbiAgICAgKiAgICAgICAgIHN0cnVjdHVyZWQ6IGJvb2xlYW5cbiAgICAgKiAgICAgICAgIHdpbGRjYXJkOiBib29sZWFuXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICogdHlwZTpcbiAgICAgKlxuICAgICAqIDEuIENPTVBVVEVcbiAgICAgKiAyLiBQUk9QQUdBVEVcbiAgICAgKiAzLiBSRUZMRUNUXG4gICAgICogNC4gT0JTRVJWRVxuICAgICAqIDUuIE5PVElGWVxuICAgICAqXG4gICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICpcbiAgICAgKiAgICAgZWZmZWN0RnVuY3Rpb24oaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICogZXhwcmVzc2lvbiwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHRcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmU6IGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYC4gIEVhY2ggYXJndW1lbnRcbiAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAqIHByb3RvdHlwZSAob3IgaW5zdGFuY2UpLCBvciBtYXkgYmUgYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAqIGV2ZW50cyB0byBub3RpZnkgb2YgY2hhbmdlcyB0byB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWQtb25seSBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyIChlLmcuIGBfc2V0TXlQcm9wKClgIGZvclxuICAgICAqIHByb3BlcnR5IGBteVByb3BgKSwgcGFzcyBgdHJ1ZWAgZm9yIGBwcm90ZWN0ZWRTZXR0ZXJgLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgdGhlIHByb3BlcnR5IHdpbGwgaGF2ZSBvdGhlciBwcm9wZXJ0eSBlZmZlY3RzLCB0aGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QsIGJlZm9yZSBhZGRpbmcgb3RoZXIgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiB0byBhIChkYXNoLWNhc2VkKSBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIGNoYW5nZXMuICBUaGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0IGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBmb3IgdGhlbSwgYW5kIHRoZW4gZW5zdXJlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIGNyZWF0ZWQgZm9yIGFueVxuICAgICAqIGRlcGVuZGVudCBwcm9wZXJ0aWVzIGluIHRoZSB0ZW1wbGF0ZS4gIEJpbmRpbmcgZWZmZWN0cyBmb3IgYm91bmRcbiAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICogdGVtcGxhdGVzIGNhbiBiZSBlZmZpY2llbnRseSBzdGFtcGVkIGFuZCB1bnN0YW1wZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAqICAgYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gYmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYmluZFRlbXBsYXRlYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIHRoZSBwcm90b3R5cGUgKGZvciBwcm90b3R5cGljYWwgdGVtcGxhdGVcbiAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgKiBhbmQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgcnVudGltZUJpbmRpbmc6IHRydWVgIGJ5IGBfc3RhbXBUZW1wbGF0ZWAgdG9cbiAgICAgKiBjcmVhdGUgYW5kIGxpbmsgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogICBiaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluc3RhbmNlQmluZGluZyBXaGVuIGZhbHNlIChkZWZhdWx0KSwgcGVyZm9ybXNcbiAgICAgKiAgIFwicHJvdG90eXBpY2FsXCIgYmluZGluZyBvZiB0aGUgdGVtcGxhdGUgYW5kIG92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHlcbiAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgKiAgIGBfc3RhbXBUZW1wbGF0ZWApLCB0aGUgdGVtcGxhdGUgaW5mbyBpcyBpbnN0YW5jZWQgYW5kIGxpbmtlZCBpbnRvXG4gICAgICogICB0aGUgbGlzdCBvZiBib3VuZCB0ZW1wbGF0ZXMuXG4gICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgKiAgIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBpbmZvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIGluc3RhbmNlQmluZGluZykge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAvLyBPcHRpbWl6YXRpb246IHNpbmNlIHRoaXMgaXMgY2FsbGVkIHR3aWNlIGZvciBwcm90by1ib3VuZCB0ZW1wbGF0ZXMsXG4gICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHJlY3JlYXRlIGFjY2Vzc29ycyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBwcmUtYm91bmRcbiAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlQmluZGluZykge1xuICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgLy8gYW5kIGxpbmsgaW50byBsaXN0IG9mIHRlbXBsYXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyhPYmplY3QuY3JlYXRlKHRlbXBsYXRlSW5mbykpO1xuICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgaWYgKCF3YXNQcmVCb3VuZCAmJiB0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCB8fCB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IGxhc3Q7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX190ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3BlcnR5IGVmZmVjdCB0byB0aGUgZ2l2ZW4gdGVtcGxhdGUgbWV0YWRhdGEsIHdoaWNoIGlzIHJ1blxuICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICogaGFzIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQgdmlhIGBfYmluZFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIHRvIGFkZCBlZmZlY3QgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgIGxldCBlZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgfHwge307XG4gICAgICBsZXQgcHJvcEVmZmVjdHMgPSBlZmZlY3RzW3Byb3BdID0gZWZmZWN0c1twcm9wXSB8fCBbXTtcbiAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAqIFBvbHltZXIgdGVtcGxhdGUgZmVhdHVyZXMsIGluY2x1ZGluZyBkYXRhIGJpbmRpbmdzLCBkZWNsYXJhdGl2ZSBldmVudFxuICAgICAqIGxpc3RlbmVycywgYW5kIHRoZSBgdGhpcy4kYCBtYXAgb2YgYGlkYCdzIHRvIG5vZGVzLiAgQSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICogRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICogYHNoYWR5Y3NzYCBwb2x5ZmlsbCBsaW1pdGF0aW9ucywgb25seSBzdHlsZXMgZnJvbSB0ZW1wbGF0ZXMgcHJlcGFyZWRcbiAgICAgKiB1c2luZyBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCB3aWxsIGJlIGNvcnJlY3RseSBwb2x5ZmlsbGVkIChzY29wZWRcbiAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAqIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBlbGVtZW50LiBBcyBzdWNoLFxuICAgICAqIGFueSBzdHlsZXMgcmVxdWlyZWQgYnkgaW4gcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlcyBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBjcmVhdGVkIGRvbSBpcyBgX2VucXVldWVDbGllbnRgJ2QgdG8gdGhpcyBlbGVtZW50IHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgIGhvc3RTdGFjay5iZWdpbkhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgZG9tID0gc3VwZXIuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyh0aGlzLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpKTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZS1pbnN0YW5jZS1zcGVjaWZpYyBkYXRhIHRvIGluc3RhbmNlZCB0ZW1wbGF0ZUluZm9cbiAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgIC8vIENhcHR1cmUgY2hpbGQgbm9kZXMgdG8gYWxsb3cgdW5zdGFtcGluZyBvZiBub24tcHJvdG90eXBpY2FsIHRlbXBsYXRlc1xuICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbj1kb20uZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgc2V0dXBCaW5kaW5ncyh0aGlzLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgLy8gRmx1c2ggcHJvcGVydGllcyBpbnRvIHRlbXBsYXRlIG5vZGVzIGlmIGFscmVhZHkgYm9vdGVkXG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIHRoaXMuX19kYXRhLCBudWxsLFxuICAgICAgICAgIGZhbHNlLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCB1bmJpbmRzIHRoZSBub2RlcyBwcmV2aW91c2x5IGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBEb2N1bWVudEZyYWdtZW50IHJldHVybmVkIGZyb20gYF9zdGFtcFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVN0YW1wZWRUZW1wbGF0ZX0gZG9tIERvY3VtZW50RnJhZ21lbnQgcHJldmlvdXNseSByZXR1cm5lZFxuICAgICAqICAgZnJvbSBgX3N0YW1wVGVtcGxhdGVgIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZXMgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlQm91bmREb20oZG9tKSB7XG4gICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IGRvbS50ZW1wbGF0ZUluZm87XG4gICAgICBpZiAodGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID09IHRlbXBsYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBzdGFtcGVkIG5vZGVzXG4gICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBgVGV4dE5vZGVgJ3MnIGB0ZXh0Q29udGVudGAuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3Mobm9kZS50ZXh0Q29udGVudCwgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGV4dENvbnRlbnQgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIC8vIE5PVEU6IGRlZmF1bHQgdG8gYSBzcGFjZSBoZXJlIHNvIHRoZSB0ZXh0Tm9kZSByZW1haW5zOyBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB8fCAnICc7XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAndGV4dCcsICd0ZXh0Q29udGVudCcsIHBhcnRzKTtcbiAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGF0dHJpYnV0ZXMuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3ModmFsdWUsIHRlbXBsYXRlSW5mbyk7XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgLy8gQXR0cmlidXRlIG9yIHByb3BlcnR5XG4gICAgICAgIGxldCBvcmlnTmFtZSA9IG5hbWU7XG4gICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gPT0gJyQnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGF0dHJpYnV0ZSBiaW5kaW5ncyB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgIGlmIChsaXRlcmFsICYmIGtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBhdHRyaWJ1dGUgYmVmb3JlIHJlbW92aW5nLCBzaW5jZSBJRSB3b24ndCBhbGxvdyByZW1vdmluZ1xuICAgICAgICAvLyBgdmFsdWVgIGF0dHJpYnV0ZSBpZiBpdCBwcmV2aW91c2x5IGhhZCBhIHZhbHVlIChjYW4ndFxuICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgIC8vIGNhbid0IGJlIHNldCB1c2luZyBzZXRBdHRyaWJ1dGUpXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiBvcmlnTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFubm90YXRpb25cbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAvLyBDYXNlIGhhY2tlcnk6IGF0dHJpYnV0ZXMgYXJlIGxvd2VyLWNhc2UsIGJ1dCBiaW5kIHRhcmdldHNcbiAgICAgICAgLy8gKHByb3BlcnRpZXMpIGFyZSBjYXNlIHNlbnNpdGl2ZS4gR2FtYml0IGlzIHRvIG1hcCBkYXNoLWNhc2UgdG9cbiAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5ncyBhcmUgZXhjZXB0ZWQuXG4gICAgICAgIGlmIChraW5kID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgbmFtZSA9IGRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIG5hbWUsIHBhcnRzLCBsaXRlcmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICogYXMgYF9ob3N0Xzxwcm9wZXJ0eT5gLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgLy8gTWVyZ2UgaG9zdCBwcm9wcyBpbnRvIG91dGVyIHRlbXBsYXRlIGFuZCBhZGQgYmluZGluZ3NcbiAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgbGV0IG1vZGUgPSAneyc7XG4gICAgICBmb3IgKGxldCBzb3VyY2UgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAncHJvcGVydHknLCAnX2hvc3RfJyArIHNvdXJjZSwgcGFydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICogdGV4dENvbnRlbnQpIGludG8gYmluZGluZyBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgKiBtZXRhZGF0YSAgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0ZXh0XG4gICAgICogYW5kIGFueSBcImxpdGVyYWxcIiB0ZXh0IGluIGJldHdlZW4uICBBbnkgbm9uLWxpdGVyYWwgcGFydHMgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICogZmllbGRzIG9mIGVhY2ggXCJwYXJ0XCIgaW4gdGhlIHJldHVybmVkIGFycmF5IGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgYmluZGluZyB0byB1cGRhdGVcbiAgICAgKiAtIGBsaXRlcmFsYCAtIFN0cmluZyBjb250YWluaW5nIHRleHQgaWYgdGhlIHBhcnQgcmVwcmVzZW50cyBhIGxpdGVyYWw7XG4gICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAqXG4gICAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBmb3IgdXNlIGJ5IGBfZXZhbHVhdGVCaW5kaW5nYCBtYXkgYmUgcHJvdmlkZWQgaW5cbiAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhhbmRsZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBiaW5kaW5nc1xuICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICogLSBQcm9wZXJ0eSBiaW5kaW5nOiBgW1twcm9wXV1gXG4gICAgICogLSBQYXRoIGJpbmRpbmc6IGBbW29iamVjdC5wcm9wXV1gXG4gICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAqIC0gVHdvLXdheSBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBge3twcm9wfX1gLCBge3tvYmplY3QucHJvcH19YCwgYHt7IXByb3B9fWAgb3IgYHt7IW9iamVjdC5wcm9wfX1gXG4gICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBgW1tjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWAsIGBbWyFjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIEN1cnJlbnQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHtBcnJheTwhQmluZGluZ1BhcnQ+fSBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZUJpbmRpbmdzKHRleHQsIHRlbXBsYXRlSW5mbykge1xuICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtO1xuICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAvLyBSZWdleCBtYXRjaGVzOlxuICAgICAgLy8gICAgICAgIEl0ZXJhdGlvbiAxOiAgSXRlcmF0aW9uIDI6XG4gICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgIC8vIG1bMl06ICcnICAgICAgICAgICAgJyEnXG4gICAgICAvLyBtWzNdOiAncHJvcCcgICAgICAgICdjb21wdXRlKGZvbyxiYXIpJ1xuICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCBsaXRlcmFsIHBhcnRcbiAgICAgICAgaWYgKG0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYmluZGluZyBwYXJ0XG4gICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IEJvb2xlYW4obVsyXSk7XG4gICAgICAgIGxldCBzb3VyY2UgPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgIGlmIChtb2RlID09ICd7JyAmJiAoY29sb24gPSBzb3VyY2UuaW5kZXhPZignOjonKSkgPiAwKSB7XG4gICAgICAgICAgbm90aWZ5RXZlbnQgPSBzb3VyY2Uuc3Vic3RyaW5nKGNvbG9uICsgMik7XG4gICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgY3VzdG9tRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICBsZXQge2FyZ3MsIG1ldGhvZE5hbWV9ID0gc2lnbmF0dXJlO1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucztcbiAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgc2lnbmF0dXJlLmR5bmFtaWNGbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFByb3BlcnR5IG9yIHBhdGhcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgZXZlbnQ6IG5vdGlmeUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIGEgZmluYWwgbGl0ZXJhbCBwYXJ0XG4gICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaXRlcmFsID0gdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGxpdGVyYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgKiBvbmUgb3IgbW9yZSBjaGFuZ2VkIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICogICBiaW5kaW5nIGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7QmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSB0aGUgYmluZGluZyBwYXJ0IGV2YWx1YXRlZCB0b1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgdmFsdWUgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBwYXJ0LnNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGggIT0gcGFydC5zb3VyY2UpIHtcbiAgICAgICAgdmFsdWUgPSBnZXQkMChpbnN0LCBwYXJ0LnNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzUGF0aHMgJiYgaXNQYXRoJDAocGF0aCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldCQwKGluc3QsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW5zdC5fX2RhdGFbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0Lm5lZ2F0ZSkge1xuICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIG1ha2UgYSB0eXBpbmcgZm9yIGNsb3N1cmUgOlBcbiAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICByZXR1cm4gUHJvcGVydHlFZmZlY3RzO1xufSk7XG5cbi8qKlxuICogSGVscGVyIGFwaSBmb3IgZW5xdWVpbmcgY2xpZW50IGRvbSBjcmVhdGVkIGJ5IGEgaG9zdCBlbGVtZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGNhbGxlZC4gRWxlbWVudHMgYXR0YWNoIHRoZWlyIGNsaWVudCBkb20gdG9cbiAqIHRoZW1zZWx2ZXMgYXQgYHJlYWR5YCB0aW1lIHdoaWNoIHJlc3VsdHMgZnJvbSB0aGlzIGZpcnN0IGZsdXNoLlxuICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gKiBjcmVhdGVzIGlzIGZsdXNoZWQgYmVmb3JlIHRoZSBlbGVtZW50IGl0c2VsZiAoaS5lLiBjbGllbnQgYHJlYWR5YFxuICogZmlyZXMgYmVmb3JlIGhvc3QgYHJlYWR5YCkuXG4gKlxuICogSG93ZXZlciwgaWYgYF9mbHVzaFByb3BlcnRpZXNgIGlzIGNhbGxlZCAqYmVmb3JlKiBhbiBlbGVtZW50IGlzIGNvbm5lY3RlZCxcbiAqIGFzIGZvciBleGFtcGxlIGBUZW1wbGF0aXplYCBkb2VzLCB0aGlzIG9yZGVyaW5nIGd1YXJhbnRlZSBjYW5ub3QgYmVcbiAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gKiByZWNlaXZlIGRhdGEgZG8gYmVjb21lIGVucXVldWVkIGNsaWVudHMgYW5kIGFyZSBwcm9wZXJseSBvcmRlcmVkIGJ1dFxuICogdW5ib3VuZCBlbGVtZW50cyBhcmUgbm90LilcbiAqXG4gKiBUbyBtYWludGFpbiB0aGUgZGVzaXJlZCBcImNsaWVudCBiZWZvcmUgaG9zdFwiIG9yZGVyaW5nIGd1YXJhbnRlZSBmb3IgdGhpc1xuICogY2FzZSB3ZSByZWx5IG9uIHRoZSBcImhvc3Qgc3RhY2suIENsaWVudCBub2RlcyByZWdpc3RlcnMgdGhlbXNlbHZlcyB3aXRoXG4gKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAqIGlzIHJlYWRpZWQgaW4gdGhlIHByb3BlciBvcmRlciwgbWFpbnRhaW5pbmcgdGhlIGRlc2lyZWQgZ3VhcmFudGVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmxldCBob3N0U3RhY2sgPSB7XG5cbiAgc3RhY2s6IFtdLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYWRkIHRvIGhvc3RTdGFja1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgcmVnaXN0ZXJIb3N0KGluc3QpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIGxldCBob3N0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtcbiAgICAgIGhvc3QuX2VucXVldWVDbGllbnQoaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goaW5zdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBlbmQgaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgZW5kSG9zdGluZyhpbnN0KSB7XG4gICAgbGV0IHN0YWNrTGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBsZXQgbmF0aXZlU2hhZG93ID0gISh3aW5kb3dbJ1NoYWR5RE9NJ10gJiYgd2luZG93WydTaGFkeURPTSddWydpblVzZSddKTtcbmV4cG9ydCBsZXQgbmF0aXZlQ3NzVmFyaWFibGVzO1xuXG4vKipcbiAqIEBwYXJhbSB7KFNoYWR5Q1NTT3B0aW9ucyB8IFNoYWR5Q1NTSW50ZXJmYWNlKT19IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIGNhbGNDc3NWYXJpYWJsZXMoc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzWydzaGltY3NzcHJvcGVydGllcyddKSB7XG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY2hyb21lIDQ5IGhhcyBzZW1pLXdvcmtpbmcgY3NzIHZhcnMsIGNoZWNrIGlmIGJveC1zaGFkb3cgd29ya3NcbiAgICAvLyBzYWZhcmkgOS4xIGhhcyBhIHJlY2FsYyBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTU3ODJcbiAgICAvLyBIb3dldmVyLCBzaGltIGNzcyBjdXN0b20gcHJvcGVydGllcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBTaGFkeURPTSBlbmFibGVkLFxuICAgIC8vIHNvIGZhbGwgYmFjayBvbiBuYXRpdmUgaWYgd2UgZG8gbm90IGRldGVjdCBTaGFkeURPTVxuICAgIC8vIEVkZ2UgMTU6IGN1c3RvbSBwcm9wZXJ0aWVzIHVzZWQgaW4gOjpiZWZvcmUgYW5kIDo6YWZ0ZXIgd2lsbCBhbHNvIGJlIHVzZWQgaW4gdGhlIHBhcmVudCBlbGVtZW50XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTI0MTQyNTcvXG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gbmF0aXZlU2hhZG93IHx8IEJvb2xlYW4oIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pICYmXG4gICAgICB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoJ2JveC1zaGFkb3cnLCAnMCAwIDAgdmFyKC0tZm9vKScpKTtcbiAgfVxufVxuXG5pZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MgIT09IHVuZGVmaW5lZCkge1xuICBuYXRpdmVDc3NWYXJpYWJsZXMgPSB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzO1xufSBlbHNlIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgY2FsY0Nzc1ZhcmlhYmxlcyh3aW5kb3cuU2hhZHlDU1MpO1xuICAvLyByZXNldCB3aW5kb3cgdmFyaWFibGUgdG8gbGV0IFNoYWR5Q1NTIEFQSSB0YWtlIGl0cyBwbGFjZVxuICB3aW5kb3cuU2hhZHlDU1MgPSB1bmRlZmluZWQ7XG59IGVsc2Uge1xuICBjYWxjQ3NzVmFyaWFibGVzKHdpbmRvd1snV2ViQ29tcG9uZW50cyddICYmIHdpbmRvd1snV2ViQ29tcG9uZW50cyddWydmbGFncyddKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS1zZXR0aW5ncy5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qXG5FeHRyZW1lbHkgc2ltcGxlIGNzcyBwYXJzZXIuIEludGVuZGVkIHRvIGJlIG5vdCBtb3JlIHRoYW4gd2hhdCB3ZSBuZWVkXG5hbmQgZGVmaW5pdGVseSBub3QgbmVjZXNzYXJpbHkgY29ycmVjdCA9KS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbmNsYXNzIFN0eWxlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3N0YXJ0J10gPSAwO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ2VuZCddID0gMDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwcmV2aW91cyddID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwYXJlbnQnXSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTdHlsZU5vZGU+fSAqL1xuICAgIHRoaXNbJ3J1bGVzJ10gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZENzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ2Nzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzWydhdFJ1bGUnXSA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3R5cGUnXSA9IDA7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1sna2V5ZnJhbWVzTmFtZSddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1snc2VsZWN0b3InXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZFNlbGVjdG9yJ10gPSAnJztcbiAgfVxufVxuXG5leHBvcnQge1N0eWxlTm9kZX1cblxuLy8gZ2l2ZW4gYSBzdHJpbmcgb2YgY3NzLCByZXR1cm4gYSBzaW1wbGUgcnVsZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gIHRleHQgPSBjbGVhbih0ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ3NzKGxleCh0ZXh0KSwgdGV4dCk7XG59XG5cbi8vIHJlbW92ZSBzdHVmZiB3ZSBkb24ndCBjYXJlIGFib3V0IHRoYXQgbWF5IGhpbmRlciBwYXJzaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuKGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5jb21tZW50cywgJycpLnJlcGxhY2UoUlgucG9ydCwgJycpO1xufVxuXG4vLyBzdXBlciBzaW1wbGUgey4uLn0gbGV4ZXIgdGhhdCByZXR1cm5zIGEgbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gIGxldCByb290ID0gbmV3IFN0eWxlTm9kZSgpO1xuICByb290WydzdGFydCddID0gMDtcbiAgcm9vdFsnZW5kJ10gPSB0ZXh0Lmxlbmd0aFxuICBsZXQgbiA9IHJvb3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGV4dFtpXSA9PT0gT1BFTl9CUkFDRSkge1xuICAgICAgaWYgKCFuWydydWxlcyddKSB7XG4gICAgICAgIG5bJ3J1bGVzJ10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGxldCBwID0gbjtcbiAgICAgIGxldCBwcmV2aW91cyA9IHBbJ3J1bGVzJ11bcFsncnVsZXMnXS5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgbiA9IG5ldyBTdHlsZU5vZGUoKTtcbiAgICAgIG5bJ3N0YXJ0J10gPSBpICsgMTtcbiAgICAgIG5bJ3BhcmVudCddID0gcDtcbiAgICAgIG5bJ3ByZXZpb3VzJ10gPSBwcmV2aW91cztcbiAgICAgIHBbJ3J1bGVzJ10ucHVzaChuKTtcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09IENMT1NFX0JSQUNFKSB7XG4gICAgICBuWydlbmQnXSA9IGkgKyAxO1xuICAgICAgbiA9IG5bJ3BhcmVudCddIHx8IHJvb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290O1xufVxuXG4vLyBhZGQgc2VsZWN0b3JzL2Nzc1RleHQgdG8gbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5mdW5jdGlvbiBwYXJzZUNzcyhub2RlLCB0ZXh0KSB7XG4gIGxldCB0ID0gdGV4dC5zdWJzdHJpbmcobm9kZVsnc3RhcnQnXSwgbm9kZVsnZW5kJ10gLSAxKTtcbiAgbm9kZVsncGFyc2VkQ3NzVGV4dCddID0gbm9kZVsnY3NzVGV4dCddID0gdC50cmltKCk7XG4gIGlmIChub2RlWydwYXJlbnQnXSkge1xuICAgIGxldCBzcyA9IG5vZGVbJ3ByZXZpb3VzJ10gPyBub2RlWydwcmV2aW91cyddWydlbmQnXSA6IG5vZGVbJ3BhcmVudCddWydzdGFydCddO1xuICAgIHQgPSB0ZXh0LnN1YnN0cmluZyhzcywgbm9kZVsnc3RhcnQnXSAtIDEpO1xuICAgIHQgPSBfZXhwYW5kVW5pY29kZUVzY2FwZXModCk7XG4gICAgdCA9IHQucmVwbGFjZShSWC5tdWx0aXBsZVNwYWNlcywgJyAnKTtcbiAgICAvLyBUT0RPKHNvcnZlbGwpOiBhZCBob2M7IG1ha2Ugc2VsZWN0b3IgaW5jbHVkZSBvbmx5IGFmdGVyIGxhc3QgO1xuICAgIC8vIGhlbHBzIHdpdGggbWl4aW4gc3ludGF4XG4gICAgdCA9IHQuc3Vic3RyaW5nKHQubGFzdEluZGV4T2YoJzsnKSArIDEpO1xuICAgIGxldCBzID0gbm9kZVsncGFyc2VkU2VsZWN0b3InXSA9IG5vZGVbJ3NlbGVjdG9yJ10gPSB0LnRyaW0oKTtcbiAgICBub2RlWydhdFJ1bGUnXSA9IChzLmluZGV4T2YoQVRfU1RBUlQpID09PSAwKTtcbiAgICAvLyBub3RlLCBzdXBwb3J0IGEgc3Vic2V0IG9mIHJ1bGUgdHlwZXMuLi5cbiAgICBpZiAobm9kZVsnYXRSdWxlJ10pIHtcbiAgICAgIGlmIChzLmluZGV4T2YoTUVESUFfU1RBUlQpID09PSAwKSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLk1FRElBX1JVTEU7XG4gICAgICB9IGVsc2UgaWYgKHMubWF0Y2goUlgua2V5ZnJhbWVzUnVsZSkpIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG4gICAgICAgIG5vZGVbJ2tleWZyYW1lc05hbWUnXSA9XG4gICAgICAgICAgbm9kZVsnc2VsZWN0b3InXS5zcGxpdChSWC5tdWx0aXBsZVNwYWNlcykucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMCkge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5NSVhJTl9SVUxFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuU1RZTEVfUlVMRTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgaWYgKHIkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSByJC5sZW5ndGgsIHI7XG4gICAgICAoaSA8IGwpICYmIChyID0gciRbaV0pOyBpKyspIHtcbiAgICAgIHBhcnNlQ3NzKHIsIHRleHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBjb252ZXJzaW9uIG9mIHNvcnQgdW5pY29kZSBlc2NhcGVzIHdpdGggc3BhY2VzIGxpa2UgYFxcMzMgYCAoYW5kIGxvbmdlcikgaW50b1xuICogZXhwYW5kZWQgZm9ybSB0aGF0IGRvZXNuJ3QgcmVxdWlyZSB0cmFpbGluZyBzcGFjZSBgXFwwMDAwMzNgXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBfZXhwYW5kVW5pY29kZUVzY2FwZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFswLTlhLWZdezEsNn0pXFxzL2dpLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29kZSA9IGFyZ3VtZW50c1sxXSxcbiAgICAgIHJlcGVhdCA9IDYgLSBjb2RlLmxlbmd0aDtcbiAgICB3aGlsZSAocmVwZWF0LS0pIHtcbiAgICAgIGNvZGUgPSAnMCcgKyBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFwnICsgY29kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogc3RyaW5naWZ5IHBhcnNlZCBjc3MuXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFuPX0gcHJlc2VydmVQcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IHRleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBwcmVzZXJ2ZVByb3BlcnRpZXMsIHRleHQgPSAnJykge1xuICAvLyBjYWxjIHJ1bGUgY3NzVGV4dFxuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBpZiAobm9kZVsnY3NzVGV4dCddIHx8IG5vZGVbJ3J1bGVzJ10pIHtcbiAgICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICAgIGlmIChyJCAmJiAhX2hhc01peGluUnVsZXMociQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjtcbiAgICAgICAgKGkgPCBsKSAmJiAociA9IHIkW2ldKTsgaSsrKSB7XG4gICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnkociwgcHJlc2VydmVQcm9wZXJ0aWVzLCBjc3NUZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3NzVGV4dCA9IHByZXNlcnZlUHJvcGVydGllcyA/IG5vZGVbJ2Nzc1RleHQnXSA6XG4gICAgICAgIHJlbW92ZUN1c3RvbVByb3BzKG5vZGVbJ2Nzc1RleHQnXSk7XG4gICAgICBjc3NUZXh0ID0gY3NzVGV4dC50cmltKCk7XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICBjc3NUZXh0ID0gJyAgJyArIGNzc1RleHQgKyAnXFxuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZW1pdCBydWxlIGlmIHRoZXJlIGlzIGNzc1RleHRcbiAgaWYgKGNzc1RleHQpIHtcbiAgICBpZiAobm9kZVsnc2VsZWN0b3InXSkge1xuICAgICAgdGV4dCArPSBub2RlWydzZWxlY3RvciddICsgJyAnICsgT1BFTl9CUkFDRSArICdcXG4nO1xuICAgIH1cbiAgICB0ZXh0ICs9IGNzc1RleHQ7XG4gICAgaWYgKG5vZGVbJ3NlbGVjdG9yJ10pIHtcbiAgICAgIHRleHQgKz0gQ0xPU0VfQlJBQ0UgKyAnXFxuXFxuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHlsZU5vZGU+fSBydWxlc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2hhc01peGluUnVsZXMocnVsZXMpIHtcbiAgbGV0IHIgPSBydWxlc1swXTtcbiAgcmV0dXJuIEJvb2xlYW4ocikgJiYgQm9vbGVhbihyWydzZWxlY3RvciddKSAmJiByWydzZWxlY3RvciddLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wcyhjc3NUZXh0KSB7XG4gIGNzc1RleHQgPSByZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudChjc3NUZXh0KTtcbiAgcmV0dXJuIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dFxuICAgIC5yZXBsYWNlKFJYLmN1c3RvbVByb3AsICcnKVxuICAgIC5yZXBsYWNlKFJYLm1peGluUHJvcCwgJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0XG4gICAgLnJlcGxhY2UoUlgubWl4aW5BcHBseSwgJycpXG4gICAgLnJlcGxhY2UoUlgudmFyQXBwbHksICcnKTtcbn1cblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgdHlwZXMgPSB7XG4gIFNUWUxFX1JVTEU6IDEsXG4gIEtFWUZSQU1FU19SVUxFOiA3LFxuICBNRURJQV9SVUxFOiA0LFxuICBNSVhJTl9SVUxFOiAxMDAwXG59XG5cbmNvbnN0IE9QRU5fQlJBQ0UgPSAneyc7XG5jb25zdCBDTE9TRV9CUkFDRSA9ICd9JztcblxuLy8gaGVscGVyIHJlZ2V4cCdzXG5jb25zdCBSWCA9IHtcbiAgY29tbWVudHM6IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sXG4gIHBvcnQ6IC9AaW1wb3J0W147XSo7L2dpbSxcbiAgY3VzdG9tUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFxuICBtaXhpblByb3A6IC8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxcbiAgbWl4aW5BcHBseTogL0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxcbiAgdmFyQXBwbHk6IC9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sXG4gIGtleWZyYW1lc1J1bGU6IC9eQFteXFxzXSprZXlmcmFtZXMvLFxuICBtdWx0aXBsZVNwYWNlczogL1xccysvZ1xufVxuXG5jb25zdCBWQVJfU1RBUlQgPSAnLS0nO1xuY29uc3QgTUVESUFfU1RBUlQgPSAnQG1lZGlhJztcbmNvbnN0IEFUX1NUQVJUID0gJ0AnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY3NzLXBhcnNlLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuZXhwb3J0IGNvbnN0IFZBUl9BU1NJR04gPSAvKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2k7XG5leHBvcnQgY29uc3QgTUlYSU5fTUFUQ0ggPSAvKD86XnxcXFcrKUBhcHBseVxccypcXCg/KFteKTtcXG5dKilcXCk/L2dpO1xuZXhwb3J0IGNvbnN0IFZBUl9DT05TVU1FRCA9IC8oLS1bXFx3LV0rKVxccyooWzosOyldfCQpL2dpO1xuZXhwb3J0IGNvbnN0IEFOSU1BVElPTl9NQVRDSCA9IC8oYW5pbWF0aW9uXFxzKjopfChhbmltYXRpb24tbmFtZVxccyo6KS87XG5leHBvcnQgY29uc3QgTUVESUFfTUFUQ0ggPSAvQG1lZGlhXFxzKC4qKS87XG5leHBvcnQgY29uc3QgSVNfVkFSID0gL14tLS87XG5leHBvcnQgY29uc3QgQlJBQ0tFVEVEID0gL1xce1tefV0qXFx9L2c7XG5leHBvcnQgY29uc3QgSE9TVF9QUkVGSVggPSAnKD86XnxbXi4jWzpdKSc7XG5leHBvcnQgY29uc3QgSE9TVF9TVUZGSVggPSAnKCR8Wy46W1xcXFxzPit+XSknO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXJlZ2V4LmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBNSVhJTl9NQVRDSCwgVkFSX0FTU0lHTiB9IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gIC8vIHJlbW92ZSBwcmV2aW91cyBwcm9wZXJ0aWVzXG4gIGZvciAobGV0IHAgaW4gcHJvcGVydGllcykge1xuICAgIC8vIE5PVEU6IGZvciBiYyB3aXRoIHNoaW0sIGRvbid0IGFwcGx5IG51bGwgdmFsdWVzLlxuICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHAsIHByb3BlcnRpZXNbcF0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgLyoqXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3QgdmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICB9XG59XG5cbi8qKlxuICogcmV0dXJuIHRydWUgaWYgYGNzc1RleHRgIGNvbnRhaW5zIGEgbWl4aW4gZGVmaW5pdGlvbiBvciBjb25zdW1wdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RNaXhpbihjc3NUZXh0KSB7XG4gIGNvbnN0IGhhcyA9IE1JWElOX01BVENILnRlc3QoY3NzVGV4dCkgfHwgVkFSX0FTU0lHTi50ZXN0KGNzc1RleHQpO1xuICAvLyByZXNldCBzdGF0ZSBvZiB0aGUgcmVnZXhlc1xuICBNSVhJTl9NQVRDSC5sYXN0SW5kZXggPSAwO1xuICBWQVJfQVNTSUdOLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiBoYXM7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tdXRpbHMuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyB0aW1lT3V0IH0gZnJvbSAnLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuL2RlYm91bmNlLmpzJztcblxuLy8gZGV0ZWN0IG5hdGl2ZSB0b3VjaCBhY3Rpb24gc3VwcG9ydFxubGV0IEhBU19OQVRJVkVfVEEgPSB0eXBlb2YgZG9jdW1lbnQuaGVhZC5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ3N0cmluZyc7XG5sZXQgR0VTVFVSRV9LRVkgPSAnX19wb2x5bWVyR2VzdHVyZXMnO1xubGV0IEhBTkRMRURfT0JKID0gJ19fcG9seW1lckdlc3R1cmVzSGFuZGxlZCc7XG5sZXQgVE9VQ0hfQUNUSU9OID0gJ19fcG9seW1lckdlc3R1cmVzVG91Y2hBY3Rpb24nO1xuLy8gcmFkaXVzIGZvciB0YXAgYW5kIHRyYWNrXG5sZXQgVEFQX0RJU1RBTkNFID0gMjU7XG5sZXQgVFJBQ0tfRElTVEFOQ0UgPSA1O1xuLy8gbnVtYmVyIG9mIGxhc3QgTiB0cmFjayBwb3NpdGlvbnMgdG8ga2VlcFxubGV0IFRSQUNLX0xFTkdUSCA9IDI7XG5cbi8vIERpc2FibGluZyBcIm1vdXNlXCIgaGFuZGxlcnMgZm9yIDI1MDBtcyBpcyBlbm91Z2hcbmxldCBNT1VTRV9USU1FT1VUID0gMjUwMDtcbmxldCBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdjbGljayddO1xuLy8gYW4gYXJyYXkgb2YgYml0bWFzayB2YWx1ZXMgZm9yIG1hcHBpbmcgTW91c2VFdmVudC53aGljaCB0byBNb3VzZUV2ZW50LmJ1dHRvbnNcbmxldCBNT1VTRV9XSElDSF9UT19CVVRUT05TID0gWzAsIDEsIDQsIDJdO1xubGV0IE1PVVNFX0hBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgTW91c2VFdmVudCgndGVzdCcsIHtidXR0b25zOiAxfSkuYnV0dG9ucyA9PT0gMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyogZXNsaW50IG5vLWVtcHR5OiBbXCJlcnJvclwiLCB7IFwiYWxsb3dFbXB0eUNhdGNoXCI6IHRydWUgfV0gKi9cbi8vIGNoZWNrIGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyc1xubGV0IFNVUFBPUlRTX1BBU1NJVkUgPSBmYWxzZTtcbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7Z2V0OiBmdW5jdGlvbigpIHtTVVBQT1JUU19QQVNTSVZFID0gdHJ1ZTt9fSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoKGUpIHt9XG59KSgpO1xuXG4vLyBDaGVjayBmb3IgdG91Y2gtb25seSBkZXZpY2VzXG5sZXQgSVNfVE9VQ0hfT05MWSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQKD86W29hXWR8aG9uZSl8QW5kcm9pZC8pO1xuXG5sZXQgR2VzdHVyZVJlY29nbml6ZXIgPSBmdW5jdGlvbigpe307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7fTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWR9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vkb3duO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlbW92ZTtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZXVwO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoc3RhcnQ7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2htb3ZlO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoZW5kO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLmNsaWNrO1xuXG4vLyB0b3VjaCB3aWxsIG1ha2Ugc3ludGhldGljIG1vdXNlIGV2ZW50c1xuLy8gYHByZXZlbnREZWZhdWx0YCBvbiB0b3VjaGVuZCB3aWxsIGNhbmNlbCB0aGVtLFxuLy8gYnV0IHRoaXMgYnJlYWtzIGA8aW5wdXQ+YCBmb2N1cyBhbmQgbGluayBjbGlja3Ncbi8vIGRpc2FibGUgbW91c2UgaGFuZGxlcnMgZm9yIE1PVVNFX1RJTUVPVVQgbXMgYWZ0ZXJcbi8vIGEgdG91Y2hlbmQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbmxldCBtb3VzZUNhbmNlbGxlciA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgLy8gQ2hlY2sgZm9yIHNvdXJjZUNhcGFiaWxpdGllcywgdXNlZCB0byBkaXN0aW5ndWlzaCBzeW50aGV0aWMgZXZlbnRzXG4gIC8vIGlmIG1vdXNlRXZlbnQgZGlkIG5vdCBjb21lIGZyb20gYSBkZXZpY2UgdGhhdCBmaXJlcyB0b3VjaCBldmVudHMsXG4gIC8vIGl0IHdhcyBtYWRlIGJ5IGEgcmVhbCBtb3VzZSBhbmQgc2hvdWxkIGJlIGNvdW50ZWRcbiAgLy8gaHR0cDovL3dpY2cuZ2l0aHViLmlvL0lucHV0RGV2aWNlQ2FwYWJpbGl0aWVzLyNkb20taW5wdXRkZXZpY2VjYXBhYmlsaXRpZXMtZmlyZXN0b3VjaGV2ZW50c1xuICBsZXQgc2MgPSBtb3VzZUV2ZW50LnNvdXJjZUNhcGFiaWxpdGllcztcbiAgaWYgKHNjICYmICFzYy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNraXAgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICBtb3VzZUV2ZW50W0hBTkRMRURfT0JKXSA9IHtza2lwOiB0cnVlfTtcbiAgLy8gZGlzYWJsZSBcImdob3N0IGNsaWNrc1wiXG4gIGlmIChtb3VzZUV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICBsZXQgcGF0aCA9IG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoICYmIG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSA9PT0gUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbW91c2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXR1cCBUcnVlIHRvIGFkZCwgZmFsc2UgdG8gcmVtb3ZlLlxuICovXG5mdW5jdGlvbiBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIoc2V0dXApIHtcbiAgbGV0IGV2ZW50cyA9IElTX1RPVUNIX09OTFkgPyBbJ2NsaWNrJ10gOiBNT1VTRV9FVkVOVFM7XG4gIGZvciAobGV0IGkgPSAwLCBlbjsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGVuID0gZXZlbnRzW2ldO1xuICAgIGlmIChzZXR1cCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZU1vdXNlKGUpIHtcbiAgaWYgKCFQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IpIHtcbiAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIodHJ1ZSk7XG4gIH1cbiAgbGV0IHVuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKCk7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IG51bGw7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gbnVsbDtcbiAgfTtcbiAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iXG4gICAgICAsIHRpbWVPdXQuYWZ0ZXIoTU9VU0VfVElNRU9VVClcbiAgICAgICwgdW5zZXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgZXZlbnQgdG8gdGVzdCBmb3IgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICogQHJldHVybiB7Ym9vbGVhbn0gaGFzIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAqL1xuZnVuY3Rpb24gaGFzTGVmdE1vdXNlQnV0dG9uKGV2KSB7XG4gIGxldCB0eXBlID0gZXYudHlwZTtcbiAgLy8gZXhpdCBlYXJseSBpZiB0aGUgZXZlbnQgaXMgbm90IGEgbW91c2UgZXZlbnRcbiAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBldi5idXR0b24gaXMgbm90IHJlbGlhYmxlIGZvciBtb3VzZW1vdmUgKDAgaXMgb3ZlcmxvYWRlZCBhcyBib3RoIGxlZnQgYnV0dG9uIGFuZCBubyBidXR0b25zKVxuICAvLyBpbnN0ZWFkIHdlIHVzZSBldi5idXR0b25zIChiaXRtYXNrIG9mIGJ1dHRvbnMpIG9yIGZhbGwgYmFjayB0byBldi53aGljaCAoZGVwcmVjYXRlZCwgMCBmb3Igbm8gYnV0dG9ucywgMSBmb3IgbGVmdCBidXR0b24pXG4gIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9ucyA9IGV2LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBldi5idXR0b25zO1xuICAgIGlmICgoZXYgaW5zdGFuY2VvZiB3aW5kb3cuTW91c2VFdmVudCkgJiYgIU1PVVNFX0hBU19CVVRUT05TKSB7XG4gICAgICBidXR0b25zID0gTU9VU0VfV0hJQ0hfVE9fQlVUVE9OU1tldi53aGljaF0gfHwgMDtcbiAgICB9XG4gICAgLy8gYnV0dG9ucyBpcyBhIGJpdG1hc2ssIGNoZWNrIHRoYXQgdGhlIGxlZnQgYnV0dG9uIGJpdCBpcyBzZXQgKDEpXG4gICAgcmV0dXJuIEJvb2xlYW4oYnV0dG9ucyAmIDEpO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9uID0gZXYuYnV0dG9uID09PSB1bmRlZmluZWQgPyAwIDogZXYuYnV0dG9uO1xuICAgIC8vIGV2LmJ1dHRvbiBpcyAwIGluIG1vdXNlZG93bi9tb3VzZXVwL2NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBhY3RpdmF0aW9uXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0NsaWNrKGV2KSB7XG4gIGlmIChldi50eXBlID09PSAnY2xpY2snKSB7XG4gICAgLy8gZXYuZGV0YWlsIGlzIDAgZm9yIEhUTUxFbGVtZW50LmNsaWNrIGluIG1vc3QgYnJvd3NlcnNcbiAgICBpZiAoZXYuZGV0YWlsID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaW4gdGhlIHdvcnN0IGNhc2UsIGNoZWNrIHRoYXQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgaXMgd2l0aGluXG4gICAgLy8gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICAgIC8vIFRoYW5rcyBJRSAxMCA+OihcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZXYpO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBhbiBlbGVtZW50IHNvIHdlIGNhbiB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuICAgIC8vIGlmIG5vdCwganVzdCBhc3N1bWUgaXQgaXMgYSBzeW50aGV0aWMgY2xpY2tcbiAgICBpZiAoIXQubm9kZVR5cGUgfHwgLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmNyID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyB1c2UgcGFnZSB4L3kgdG8gYWNjb3VudCBmb3Igc2Nyb2xsaW5nXG4gICAgbGV0IHggPSBldi5wYWdlWCwgeSA9IGV2LnBhZ2VZO1xuICAgIC8vIGV2IGlzIGEgc3ludGhldGljIGNsaWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldFxuICAgIHJldHVybiAhKCh4ID49IGJjci5sZWZ0ICYmIHggPD0gYmNyLnJpZ2h0KSAmJiAoeSA+PSBiY3IudG9wICYmIHkgPD0gYmNyLmJvdHRvbSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IFBPSU5URVJTVEFURSA9IHtcbiAgbW91c2U6IHtcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgbW91c2VJZ25vcmVKb2I6IG51bGxcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgaWQ6IC0xLFxuICAgIHNjcm9sbERlY2lkZWQ6IGZhbHNlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpcnN0VG91Y2hBY3Rpb24oZXYpIHtcbiAgbGV0IHRhID0gJ2F1dG8nO1xuICBsZXQgcGF0aCA9IGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKTtcbiAgaWYgKHBhdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBwYXRoW2ldO1xuICAgICAgaWYgKG5bVE9VQ0hfQUNUSU9OXSkge1xuICAgICAgICB0YSA9IG5bVE9VQ0hfQUNUSU9OXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YTtcbn1cblxuZnVuY3Rpb24gdHJhY2tEb2N1bWVudChzdGF0ZU9iaiwgbW92ZWZuLCB1cGZuKSB7XG4gIHN0YXRlT2JqLm1vdmVmbiA9IG1vdmVmbjtcbiAgc3RhdGVPYmoudXBmbiA9IHVwZm47XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVmbik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB1cGZuKTtcbn1cblxuZnVuY3Rpb24gdW50cmFja0RvY3VtZW50KHN0YXRlT2JqKSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0YXRlT2JqLm1vdmVmbik7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdGF0ZU9iai51cGZuKTtcbiAgc3RhdGVPYmoubW92ZWZuID0gbnVsbDtcbiAgc3RhdGVPYmoudXBmbiA9IG51bGw7XG59XG5cbi8vIHVzZSBhIGRvY3VtZW50LXdpZGUgdG91Y2hlbmQgbGlzdGVuZXIgdG8gc3RhcnQgdGhlIGdob3N0LWNsaWNrIHByZXZlbnRpb24gbWVjaGFuaXNtXG4vLyBVc2UgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGlmIHN1cHBvcnRlZCwgdG8gbm90IGFmZmVjdCBzY3JvbGxpbmcgcGVyZm9ybWFuY2VcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaWdub3JlTW91c2UsIFNVUFBPUlRTX1BBU1NJVkUgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZSk7XG5cbmV4cG9ydCBjb25zdCBnZXN0dXJlcyA9IHt9O1xuZXhwb3J0IGNvbnN0IHJlY29nbml6ZXJzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwVGFyZ2V0RmluZCh4LCB5KSB7XG4gIGxldCBub2RlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgbGV0IG5leHQgPSBub2RlO1xuICAvLyB0aGlzIGNvZGUgcGF0aCBpcyBvbmx5IHRha2VuIHdoZW4gbmF0aXZlIFNoYWRvd0RPTSBpcyB1c2VkXG4gIC8vIGlmIHRoZXJlIGlzIGEgc2hhZG93cm9vdCwgaXQgbWF5IGhhdmUgYSBub2RlIGF0IHgveVxuICAvLyBpZiB0aGVyZSBpcyBub3QgYSBzaGFkb3dyb290LCBleGl0IHRoZSBsb29wXG4gIHdoaWxlIChuZXh0ICYmIG5leHQuc2hhZG93Um9vdCAmJiAhd2luZG93LlNoYWR5RE9NKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYSBub2RlIGF0IHgveSBpbiB0aGUgc2hhZG93cm9vdCwgbG9vayBkZWVwZXJcbiAgICBsZXQgb2xkTmV4dCA9IG5leHQ7XG4gICAgbmV4dCA9IG5leHQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIC8vIG9uIFNhZmFyaSwgZWxlbWVudEZyb21Qb2ludCBtYXkgcmV0dXJuIHRoZSBzaGFkb3dSb290IGhvc3RcbiAgICBpZiAob2xkTmV4dCA9PT0gbmV4dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZE9yaWdpbmFsVGFyZ2V0KGV2KSB7XG4gIC8vIHNoYWRvd2RvbVxuICBpZiAoZXYuY29tcG9zZWRQYXRoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7RXZlbnRUYXJnZXR9ICovKGV2LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgfVxuICAvLyBzaGFkeWRvbVxuICByZXR1cm4gZXYudGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2hhbmRsZU5hdGl2ZShldikge1xuICBsZXQgaGFuZGxlZDtcbiAgbGV0IHR5cGUgPSBldi50eXBlO1xuICBsZXQgbm9kZSA9IGV2LmN1cnJlbnRUYXJnZXQ7XG4gIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gIGlmICghZ29iaikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZ3MgPSBnb2JqW3R5cGVdO1xuICBpZiAoIWdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZXZbSEFORExFRF9PQkpdKSB7XG4gICAgZXZbSEFORExFRF9PQkpdID0ge307XG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgNSkgPT09ICd0b3VjaCcpIHtcbiAgICAgIGV2ID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhldik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCBmaW5nZXJcbiAgICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLmlkID0gdC5pZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLmlkICE9PSB0LmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFIQVNfTkFUSVZFX1RBKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICBfaGFuZGxlVG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZWQgPSBldltIQU5ETEVEX09CSl07XG4gIC8vIHVzZWQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgaWYgKGhhbmRsZWQuc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyByZXNldCByZWNvZ25pemVyIHN0YXRlXG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgaWYgKHIuZmxvdyAmJiByLmZsb3cuc3RhcnQuaW5kZXhPZihldi50eXBlKSA+IC0xICYmIHIucmVzZXQpIHtcbiAgICAgICAgci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBlbmZvcmNlIGdlc3R1cmUgcmVjb2duaXplciBvcmRlclxuICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgIGhhbmRsZWRbci5uYW1lXSA9IHRydWU7XG4gICAgICByW3R5cGVdKGV2KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9oYW5kbGVUb3VjaEFjdGlvbihldikge1xuICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueCA9IHQuY2xpZW50WDtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueSA9IHQuY2xpZW50WTtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gdHJ1ZTtcbiAgICBsZXQgdGEgPSBmaXJzdFRvdWNoQWN0aW9uKGV2KTtcbiAgICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICAgIGxldCBkeCA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC54IC0gdC5jbGllbnRYKTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueSAtIHQuY2xpZW50WSk7XG4gICAgaWYgKCFldi5jYW5jZWxhYmxlKSB7XG4gICAgICAvLyBzY3JvbGxpbmcgaXMgaGFwcGVuaW5nXG4gICAgfSBlbHNlIGlmICh0YSA9PT0gJ25vbmUnKSB7XG4gICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXgnKSB7XG4gICAgICBwcmV2ZW50ID0gZHkgPiBkeDtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXknKSB7XG4gICAgICBwcmV2ZW50ID0gZHggPiBkeTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnQpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZlbnQoJ3RyYWNrJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKGdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICBfYWRkKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGlmIChnZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgX3JlbW92ZShub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9hZGQobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoIWdvYmopIHtcbiAgICBub2RlW0dFU1RVUkVfS0VZXSA9IGdvYmogPSB7fTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXAgPSBkZXBzW2ldO1xuICAgIC8vIGRvbid0IGFkZCBtb3VzZSBoYW5kbGVycyBvbiBpT1MgYmVjYXVzZSB0aGV5IGNhdXNlIGdyYXkgc2VsZWN0aW9uIG92ZXJsYXlzXG4gICAgaWYgKElTX1RPVUNIX09OTFkgJiYgTU9VU0VfRVZFTlRTLmluZGV4T2YoZGVwKSA+IC0xICYmIGRlcCAhPT0gJ2NsaWNrJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGdkID0gZ29ialtkZXBdO1xuICAgIGlmICghZ2QpIHtcbiAgICAgIGdvYmpbZGVwXSA9IGdkID0ge19jb3VudDogMH07XG4gICAgfVxuICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihkZXAsIF9oYW5kbGVOYXRpdmUpO1xuICAgIH1cbiAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAwKSArIDE7XG4gICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAwKSArIDE7XG4gIH1cbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG4gIGlmIChyZWNvZ25pemVyLnRvdWNoQWN0aW9uKSB7XG4gICAgc2V0VG91Y2hBY3Rpb24obm9kZSwgcmVjb2duaXplci50b3VjaEFjdGlvbik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoZ29iaikge1xuICAgIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgaWYgKGdkICYmIGdkW25hbWVdKSB7XG4gICAgICAgIGdkW25hbWVdID0gKGdkW25hbWVdIHx8IDEpIC0gMTtcbiAgICAgICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAxKSAtIDE7XG4gICAgICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZGVwLCBfaGFuZGxlTmF0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHJlY29nKSB7XG4gIHJlY29nbml6ZXJzLnB1c2gocmVjb2cpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29nLmVtaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ2VzdHVyZXNbcmVjb2cuZW1pdHNbaV1dID0gcmVjb2c7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKSB7XG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgZm9yIChsZXQgaiA9IDAsIG47IGogPCByLmVtaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBuID0gci5lbWl0c1tqXTtcbiAgICAgIGlmIChuID09PSBldk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VG91Y2hBY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgaWYgKEhBU19OQVRJVkVfVEEpIHtcbiAgICBub2RlLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgbm9kZVtUT1VDSF9BQ1RJT05dID0gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmlyZSh0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuICBsZXQgZXYgPSBuZXcgRXZlbnQodHlwZSwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBjb21wb3NlZDogdHJ1ZSB9KTtcbiAgZXYuZGV0YWlsID0gZGV0YWlsO1xuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG4gIC8vIGZvcndhcmQgYHByZXZlbnREZWZhdWx0YCBpbiBhIGNsZWFuIHdheVxuICBpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIGxldCBwcmV2ZW50ZXIgPSBkZXRhaWwucHJldmVudGVyIHx8IGRldGFpbC5zb3VyY2VFdmVudDtcbiAgICBpZiAocHJldmVudGVyICYmIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgcHJldmVudGVyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50KGV2TmFtZSkge1xuICBsZXQgcmVjb2duaXplciA9IF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKTtcbiAgaWYgKHJlY29nbml6ZXIuaW5mbykge1xuICAgIHJlY29nbml6ZXIuaW5mby5wcmV2ZW50ID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRNb3VzZUNhbmNlbGxlcigpIHtcbiAgaWYgKFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYi5mbHVzaCgpO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ2Rvd251cCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICB9LFxuICBlbWl0czogWydkb3duJywgJ3VwJ10sXG5cbiAgaW5mbzoge1xuICAgIG1vdmVmbjogbnVsbCxcbiAgICB1cGZuOiBudWxsXG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgIH1cbiAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgIH07XG4gICAgdHJhY2tEb2N1bWVudCh0aGlzLmluZm8sIG1vdmVmbiwgdXBmbik7XG4gICAgdGhpcy5fZmlyZSgnZG93bicsIHQsIGUpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCdkb3duJywgX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCd1cCcsIF9maW5kT3JpZ2luYWxUYXJnZXQoZSksIGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXZlbnRlclxuICAgKi9cbiAgX2ZpcmU6IGZ1bmN0aW9uKHR5cGUsIHRhcmdldCwgZXZlbnQsIHByZXZlbnRlcikge1xuICAgIF9maXJlKHRhcmdldCwgdHlwZSwge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlcixcbiAgICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWdpc3Rlcih7XG4gIG5hbWU6ICd0cmFjaycsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10sXG4gIGZsb3c6IHtcbiAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndHJhY2snXSxcblxuICBpbmZvOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0YXRlOiAnc3RhcnQnLFxuICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgIG1vdmVzOiBbXSxcbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIGFkZE1vdmU6IGZ1bmN0aW9uKG1vdmUpIHtcbiAgICAgIGlmICh0aGlzLm1vdmVzLmxlbmd0aCA+IFRSQUNLX0xFTkdUSCkge1xuICAgICAgICB0aGlzLm1vdmVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vdmVzLnB1c2gobW92ZSk7XG4gICAgfSxcbiAgICBtb3ZlZm46IG51bGwsXG4gICAgdXBmbjogbnVsbCxcbiAgICBwcmV2ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8uc3RhdGUgPSAnc3RhcnQnO1xuICAgIHRoaXMuaW5mby5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbmZvLm1vdmVzID0gW107XG4gICAgdGhpcy5pbmZvLnggPSAwO1xuICAgIHRoaXMuaW5mby55ID0gMDtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNNb3ZlZEVub3VnaDogZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgZHggPSBNYXRoLmFicyh0aGlzLmluZm8ueCAtIHgpO1xuICAgIGxldCBkeSA9IE1hdGguYWJzKHRoaXMuaW5mby55IC0geSk7XG4gICAgcmV0dXJuIChkeCA+PSBUUkFDS19ESVNUQU5DRSB8fCBkeSA+PSBUUkFDS19ESVNUQU5DRSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGxldCB4ID0gZS5jbGllbnRYLCB5ID0gZS5jbGllbnRZO1xuICAgICAgaWYgKHNlbGYuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgLy8gZmlyc3QgbW92ZSBpcyAnc3RhcnQnLCBzdWJzZXF1ZW50IG1vdmVzIGFyZSAnbW92ZScsIG1vdXNldXAgaXMgJ2VuZCdcbiAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gc2VsZi5pbmZvLnN0YXJ0ZWQgPyAoZS50eXBlID09PSAnbW91c2V1cCcgPyAnZW5kJyA6ICd0cmFjaycpIDogJ3N0YXJ0JztcbiAgICAgICAgaWYgKHNlbGYuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgIC8vIGFsd2F5cyBfZmlyZSBcImVuZFwiXG4gICAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fZmlyZSh0LCBlKTtcbiAgICAgICAgc2VsZi5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChzZWxmLmluZm8uc3RhcnRlZCkge1xuICAgICAgICBtb3ZlZm4oZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5IGxpc3RlbmVyc1xuICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgfTtcbiAgICAvLyBhZGQgdGVtcG9yYXJ5IGRvY3VtZW50IGxpc3RlbmVycyBhcyBtb3VzZSByZXRhcmdldHNcbiAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICB0aGlzLmluZm8ueCA9IGUuY2xpZW50WDtcbiAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB0aGlzLmluZm8ueCA9IGN0LmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBjdC5jbGllbnRZO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGxldCB4ID0gY3QuY2xpZW50WCwgeSA9IGN0LmNsaWVudFk7XG4gICAgaWYgKHRoaXMuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgIGlmICh0aGlzLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICB0aGlzLl9maXJlKHQsIGN0KTtcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICd0cmFjayc7XG4gICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgLy8gb25seSB0cmFja2VuZCBpZiB0cmFjayB3YXMgc3RhcnRlZCBhbmQgbm90IGFib3J0ZWRcbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIC8vIHJlc2V0IHN0YXJ0ZWQgc3RhdGUgb24gdXBcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgdGhpcy5pbmZvLmFkZE1vdmUoe3g6IGN0LmNsaWVudFgsIHk6IGN0LmNsaWVudFl9KTtcbiAgICAgIHRoaXMuX2ZpcmUodCwgY3QsIGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2hcbiAgICovXG4gIF9maXJlOiBmdW5jdGlvbih0YXJnZXQsIHRvdWNoKSB7XG4gICAgbGV0IHNlY29uZGxhc3QgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDJdO1xuICAgIGxldCBsYXN0bW92ZSA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGR4ID0gbGFzdG1vdmUueCAtIHRoaXMuaW5mby54O1xuICAgIGxldCBkeSA9IGxhc3Rtb3ZlLnkgLSB0aGlzLmluZm8ueTtcbiAgICBsZXQgZGR4LCBkZHkgPSAwO1xuICAgIGlmIChzZWNvbmRsYXN0KSB7XG4gICAgICBkZHggPSBsYXN0bW92ZS54IC0gc2Vjb25kbGFzdC54O1xuICAgICAgZGR5ID0gbGFzdG1vdmUueSAtIHNlY29uZGxhc3QueTtcbiAgICB9XG4gICAgX2ZpcmUodGFyZ2V0LCAndHJhY2snLCB7XG4gICAgICBzdGF0ZTogdGhpcy5pbmZvLnN0YXRlLFxuICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICBkeDogZHgsXG4gICAgICBkeTogZHksXG4gICAgICBkZHg6IGRkeCxcbiAgICAgIGRkeTogZGR5LFxuICAgICAgc291cmNlRXZlbnQ6IHRvdWNoLFxuICAgICAgaG92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVlcFRhcmdldEZpbmQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ3RhcCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ2NsaWNrJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ2NsaWNrJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndGFwJ10sXG4gIGluZm86IHtcbiAgICB4OiBOYU4sXG4gICAgeTogTmFOLFxuICAgIHByZXZlbnQ6IGZhbHNlXG4gIH0sXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8ueCA9IE5hTjtcbiAgICB0aGlzLmluZm8ueSA9IE5hTjtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICB9LFxuICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICBzYXZlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgdGhpcy5zYXZlKGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAqL1xuICBjbGljazogZnVuY3Rpb24oZSkge1xuICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZChlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuc2F2ZShlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuZm9yd2FyZChlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtFdmVudCB8IFRvdWNofSBlXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBwcmV2ZW50ZXJcbiAgICovXG4gIGZvcndhcmQ6IGZ1bmN0aW9uKGUsIHByZXZlbnRlcikge1xuICAgIGxldCBkeCA9IE1hdGguYWJzKGUuY2xpZW50WCAtIHRoaXMuaW5mby54KTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhlLmNsaWVudFkgLSB0aGlzLmluZm8ueSk7XG4gICAgLy8gZmluZCBvcmlnaW5hbCB0YXJnZXQgZnJvbSBgcHJldmVudGVyYCBmb3IgVG91Y2hFdmVudHMsIG9yIGBlYCBmb3IgTW91c2VFdmVudHNcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoKHByZXZlbnRlciB8fCBlKSk7XG4gICAgLy8gZHgsZHkgY2FuIGJlIE5hTiBpZiBgY2xpY2tgIGhhcyBiZWVuIHNpbXVsYXRlZCBhbmQgdGhlcmUgd2FzIG5vIGBkb3duYCBmb3IgYHN0YXJ0YFxuICAgIGlmIChpc05hTihkeCkgfHwgaXNOYU4oZHkpIHx8IChkeCA8PSBUQVBfRElTVEFOQ0UgJiYgZHkgPD0gVEFQX0RJU1RBTkNFKSB8fCBpc1N5bnRoZXRpY0NsaWNrKGUpKSB7XG4gICAgICAvLyBwcmV2ZW50IHRhcHMgZnJvbSBiZWluZyBnZW5lcmF0ZWQgaWYgYW4gZXZlbnQgaGFzIGNhbmNlbGVkIHRoZW1cbiAgICAgIGlmICghdGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgX2ZpcmUodCwgJ3RhcCcsIHtcbiAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgeTogZS5jbGllbnRZLFxuICAgICAgICAgIHNvdXJjZUV2ZW50OiBlLFxuICAgICAgICAgIHByZXZlbnRlcjogcHJldmVudGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBmaW5kT3JpZ2luYWxUYXJnZXQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0O1xuZXhwb3J0IGNvbnN0IGFkZCA9IGFkZExpc3RlbmVyO1xuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IHJlbW92ZUxpc3RlbmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxubGV0IGRlYm91bmNlclF1ZXVlID0gW107XG5cbmV4cG9ydCBjb25zdCBlbnF1ZXVlRGVib3VuY2VyID0gZnVuY3Rpb24oZGVib3VuY2VyKSB7XG4gIGRlYm91bmNlclF1ZXVlLnB1c2goZGVib3VuY2VyKTtcbn07XG5cbmZ1bmN0aW9uIGZsdXNoRGVib3VuY2VycygpIHtcbiAgY29uc3QgZGlkRmx1c2ggPSBCb29sZWFuKGRlYm91bmNlclF1ZXVlLmxlbmd0aCk7XG4gIHdoaWxlIChkZWJvdW5jZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICB0cnkge1xuICAgICAgZGVib3VuY2VyUXVldWUuc2hpZnQoKS5mbHVzaCgpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZEZsdXNoO1xufVxuXG5leHBvcnQgY29uc3QgZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgbGV0IHNoYWR5RE9NLCBkZWJvdW5jZXJzO1xuICBkbyB7XG4gICAgc2hhZHlET00gPSB3aW5kb3cuU2hhZHlET00gJiYgU2hhZHlET00uZmx1c2goKTtcbiAgICBpZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSkge1xuICAgICAgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltLmZsdXNoKCk7XG4gICAgfVxuICAgIGRlYm91bmNlcnMgPSBmbHVzaERlYm91bmNlcnMoKTtcbiAgfSB3aGlsZSAoc2hhZHlET00gfHwgZGVib3VuY2Vycyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5qcyIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IFByb3BlcnR5RWZmZWN0cyB9IGZyb20gJy4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcbmltcG9ydCB7IE11dGFibGVEYXRhIH0gZnJvbSAnLi4vbWl4aW5zL211dGFibGUtZGF0YS5qcyc7XG5cbi8vIEJhc2UgY2xhc3MgZm9yIEhUTUxUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5zaW9uIHRoYXQgaGFzIHByb3BlcnR5IGVmZmVjdHNcbi8vIG1hY2hpbmVyeSBmb3IgcHJvcGFnYXRpbmcgaG9zdCBwcm9wZXJ0aWVzIHRvIGNoaWxkcmVuLiBUaGlzIGlzIGFuIEVTNVxuLy8gY2xhc3Mgb25seSBiZWNhdXNlIEJhYmVsIChpbmNvcnJlY3RseSkgcmVxdWlyZXMgc3VwZXIoKSBpbiB0aGUgY2xhc3Ncbi8vIGNvbnN0cnVjdG9yIGV2ZW4gdGhvdWdoIG5vIGB0aGlzYCBpcyB1c2VkIGFuZCBpdCByZXR1cm5zIGFuIGluc3RhbmNlLlxubGV0IG5ld0luc3RhbmNlID0gbnVsbDtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SFRNTFRlbXBsYXRlRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbigpIHsgcmV0dXJuIG5ld0luc3RhbmNlOyB9XG5IVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHtcbiAgICB2YWx1ZTogSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbixcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9XG59KTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKiBAZXh0ZW5kcyB7SFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbn1cbiAqL1xuY29uc3QgRGF0YVRlbXBsYXRlID0gUHJvcGVydHlFZmZlY3RzKEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24pO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICogQGV4dGVuZHMge0RhdGFUZW1wbGF0ZX1cbiAqL1xuY29uc3QgTXV0YWJsZURhdGFUZW1wbGF0ZSA9IE11dGFibGVEYXRhKERhdGFUZW1wbGF0ZSk7XG5cbi8vIEFwcGxpZXMgYSBEYXRhVGVtcGxhdGUgc3ViY2xhc3MgdG8gYSA8dGVtcGxhdGU+IGluc3RhbmNlXG5mdW5jdGlvbiB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGNvbnN0cnVjdG9yKSB7XG4gIG5ld0luc3RhbmNlID0gdGVtcGxhdGU7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZih0ZW1wbGF0ZSwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgbmV3IGNvbnN0cnVjdG9yKCk7XG4gIG5ld0luc3RhbmNlID0gbnVsbDtcbn1cblxuLy8gQmFzZSBjbGFzcyBmb3IgVGVtcGxhdGVJbnN0YW5jZSdzXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICovXG5jb25zdCBiYXNlID0gUHJvcGVydHlFZmZlY3RzKGNsYXNzIHt9KTtcblxuLyoqXG4gKiBAcG9seW1lclxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuY2xhc3MgVGVtcGxhdGVJbnN0YW5jZUJhc2UgZXh0ZW5kcyBiYXNlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2NvbmZpZ3VyZVByb3BlcnRpZXMocHJvcHMpO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fX2RhdGFIb3N0KTtcbiAgICAvLyBTYXZlIGxpc3Qgb2Ygc3RhbXBlZCBjaGlsZHJlblxuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGxldCBuID0gdGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgY2hpbGRyZW4ucHVzaChuKTtcbiAgICAgIG4uX190ZW1wbGF0aXplSW5zdGFuY2UgPSB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX3RlbXBsYXRpemVPd25lci5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18pIHtcbiAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4odHJ1ZSk7XG4gICAgfVxuICAgIC8vIEZsdXNoIHByb3BzIG9ubHkgd2hlbiBwcm9wcyBhcmUgcGFzc2VkIGlmIGluc3RhbmNlIHByb3BzIGV4aXN0XG4gICAgLy8gb3Igd2hlbiB0aGVyZSBpc24ndCBpbnN0YW5jZSBwcm9wcy5cbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICBpZiAoKHByb3BzICYmIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykgfHwgIW9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBnaXZlbiBgcHJvcHNgIGJ5IGNhbGxpbmcgYF9zZXRQZW5kaW5nUHJvcGVydHlgLiBBbHNvXG4gICAqIHNldHMgYW55IHByb3BlcnRpZXMgc3RvcmVkIGluIGBfX2hvc3RQcm9wc2AuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydHkgbmFtZS12YWx1ZSBwYWlycyB0byBzZXQuXG4gICAqL1xuICBfY29uZmlndXJlUHJvcGVydGllcyhwcm9wcykge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChsZXQgaXByb3AgaW4gb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICAgIGlmIChpcHJvcCBpbiBwcm9wcykge1xuICAgICAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShpcHJvcCwgcHJvcHNbaXByb3BdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBocHJvcCBpbiB0aGlzLl9faG9zdFByb3BzKSB7XG4gICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaHByb3AsIHRoaXMuX19kYXRhSG9zdFsnX2hvc3RfJyArIGhwcm9wXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGb3J3YXJkcyBhIGhvc3QgcHJvcGVydHkgdG8gdGhpcyBpbnN0YW5jZS4gIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxuICAgKiBjYWxsZWQgb24gaW5zdGFuY2VzIGZyb20gdGhlIGBvcHRpb25zLmZvcndhcmRIb3N0UHJvcGAgY2FsbGJhY2tcbiAgICogdG8gcHJvcGFnYXRlIGNoYW5nZXMgb2YgaG9zdCBwcm9wZXJ0aWVzIHRvIGVhY2ggaW5zdGFuY2UuXG4gICAqXG4gICAqIE5vdGUgdGhpcyBtZXRob2QgZW5xdWV1ZXMgdGhlIGNoYW5nZSwgd2hpY2ggYXJlIGZsdXNoZWQgYXMgYSBiYXRjaC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgb3IgcGF0aCBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGZvcndhcmRcbiAgICovXG4gIGZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcCwgdmFsdWUsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgdGhpcy5fX2RhdGFIb3N0Ll9lbnF1ZXVlQ2xpZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5fbWV0aG9kSG9zdCAmJiB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnMucGFyZW50TW9kZWwpIHtcbiAgICAgIC8vIElmIHRoaXMgaW5zdGFuY2Ugc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBwYXJlbnQgbW9kZWwsIGRlY29yYXRlXG4gICAgICAvLyBldmVudHMgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZSBhcyBgbW9kZWxgXG4gICAgICB0aGlzLl9tZXRob2RIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgZS5tb2RlbCA9IHRoaXM7XG4gICAgICAgIGhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGRlbGVnYXRlIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3QgKHdoaWNoIGNvdWxkIGJlKVxuICAgICAgLy8gYW5vdGhlciB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgICAgbGV0IHRlbXBsYXRlSG9zdCA9IHRoaXMuX19kYXRhSG9zdC5fX2RhdGFIb3N0O1xuICAgICAgaWYgKHRlbXBsYXRlSG9zdCkge1xuICAgICAgICB0ZW1wbGF0ZUhvc3QuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIG9yIGhpZGVzIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0b3AgbGV2ZWwgY2hpbGQgZWxlbWVudHMuIEZvclxuICAgKiB0ZXh0IG5vZGVzLCBgdGV4dENvbnRlbnRgIGlzIHJlbW92ZWQgd2hpbGUgXCJoaWRkZW5cIiBhbmQgcmVwbGFjZWQgd2hlblxuICAgKiBcInNob3duLlwiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlkZSBTZXQgdG8gdHJ1ZSB0byBoaWRlIHRoZSBjaGlsZHJlbjtcbiAgICogc2V0IHRvIGZhbHNlIHRvIHNob3cgdGhlbS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZSkge1xuICAgIGxldCBjID0gdGhpcy5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpPTA7IGk8Yy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBjW2ldO1xuICAgICAgLy8gSWdub3JlIG5vbi1jaGFuZ2VzXG4gICAgICBpZiAoQm9vbGVhbihoaWRlKSAhPSBCb29sZWFuKG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSkge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgbi5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIG4udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9IG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobi5zdHlsZSkge1xuICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICBuLl9fcG9seW1lckRpc3BsYXlfXyA9IG4uc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gbi5fX3BvbHltZXJEaXNwbGF5X187XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyA9IGhpZGU7XG4gICAgICBpZiAobi5fc2hvd0hpZGVDaGlsZHJlbikge1xuICAgICAgICBuLl9zaG93SGlkZUNoaWxkcmVuKGhpZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGVzIGRlZmF1bHQgcHJvcGVydHktZWZmZWN0cyBpbXBsZW1lbnRhdGlvbiB0byBpbnRlcmNlcHRcbiAgICogdGV4dENvbnRlbnQgYmluZGluZ3Mgd2hpbGUgY2hpbGRyZW4gYXJlIFwiaGlkZGVuXCIgYW5kIGNhY2hlIGluXG4gICAqIHByaXZhdGUgc3RvcmFnZSBmb3IgbGF0ZXIgcmV0cmlldmFsLlxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChub2RlLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyAmJlxuICAgICAgICBub2RlLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFICYmIHByb3AgPT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgbm9kZS5fX3BvbHltZXJUZXh0Q29udGVudF9fID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLl9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaW5kIHRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBwYXJlbnQgbW9kZWxcbiAgICogaXMgZWl0aGVyIGFub3RoZXIgdGVtcGxhdGl6ZSBpbnN0YW5jZSB0aGF0IGhhZCBvcHRpb24gYHBhcmVudE1vZGVsOiB0cnVlYCxcbiAgICogb3IgZWxzZSB0aGUgaG9zdCBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gVGhlIHBhcmVudCBtb2RlbCBvZiB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBnZXQgcGFyZW50TW9kZWwoKSB7XG4gICAgbGV0IG1vZGVsID0gdGhpcy5fX3BhcmVudE1vZGVsO1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIGxldCBvcHRpb25zO1xuICAgICAgbW9kZWwgPSB0aGlzO1xuICAgICAgZG8ge1xuICAgICAgICAvLyBBIHRlbXBsYXRlIGluc3RhbmNlJ3MgYF9fZGF0YUhvc3RgIGlzIGEgPHRlbXBsYXRlPlxuICAgICAgICAvLyBgbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0YCBpcyB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAgICAgIG1vZGVsID0gbW9kZWwuX19kYXRhSG9zdC5fX2RhdGFIb3N0O1xuICAgICAgfSB3aGlsZSAoKG9wdGlvbnMgPSBtb2RlbC5fX3RlbXBsYXRpemVPcHRpb25zKSAmJiAhb3B0aW9ucy5wYXJlbnRNb2RlbCk7XG4gICAgICB0aGlzLl9fcGFyZW50TW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG59XG5cbi8qKiBAdHlwZSB7IURhdGFUZW1wbGF0ZX0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2RhdGFIb3N0O1xuLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3B0aW9ucztcbi8qKiBAdHlwZSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9tZXRob2RIb3N0O1xuLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyO1xuLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9faG9zdFByb3BzO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1RlbXBsYXRlSW5zdGFuY2VCYXNlfVxuICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gKi9cbmNvbnN0IE11dGFibGVUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IE11dGFibGVEYXRhKFRlbXBsYXRlSW5zdGFuY2VCYXNlKTtcblxuZnVuY3Rpb24gZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpIHtcbiAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAvLyBhcHByb3hpbWF0ZSB0aGlzIHZpYSBjb29wZXJhdGlvbiB3aXRoIG91ciBkYXRhSG9zdCBhbHdheXMgc2V0dGluZ1xuICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICBsZXQgdGVtcGxhdGVIb3N0ID0gdGVtcGxhdGUuX19kYXRhSG9zdDtcbiAgcmV0dXJuIHRlbXBsYXRlSG9zdCAmJiB0ZW1wbGF0ZUhvc3QuX21ldGhvZEhvc3QgfHwgdGVtcGxhdGVIb3N0O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuLyoqXG4gKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICAvLyBBbm9ueW1vdXMgY2xhc3MgY3JlYXRlZCBieSB0aGUgdGVtcGxhdGl6ZVxuICBsZXQgYmFzZSA9IG9wdGlvbnMubXV0YWJsZURhdGEgP1xuICAgIE11dGFibGVUZW1wbGF0ZUluc3RhbmNlQmFzZSA6IFRlbXBsYXRlSW5zdGFuY2VCYXNlO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKi9cbiAgbGV0IGtsYXNzID0gY2xhc3MgZXh0ZW5kcyBiYXNlIHsgfTtcbiAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnMgPSBvcHRpb25zO1xuICBrbGFzcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICByZXR1cm4ga2xhc3M7XG59XG5cbi8qKlxuICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICovXG5mdW5jdGlvbiBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgbGV0IHVzZXJGb3J3YXJkSG9zdFByb3AgPSBvcHRpb25zLmZvcndhcmRIb3N0UHJvcDtcbiAgaWYgKHVzZXJGb3J3YXJkSG9zdFByb3ApIHtcbiAgICAvLyBQcm92aWRlIGRhdGEgQVBJIGFuZCBwcm9wZXJ0eSBlZmZlY3RzIG9uIG1lbW9pemVkIHRlbXBsYXRlIGNsYXNzXG4gICAgbGV0IGtsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVUZW1wbGF0ZUNsYXNzO1xuICAgIGlmICgha2xhc3MpIHtcbiAgICAgIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/IE11dGFibGVEYXRhVGVtcGxhdGUgOiBEYXRhVGVtcGxhdGU7XG4gICAgICBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcyA9XG4gICAgICAgIGNsYXNzIFRlbXBsYXRpemVkVGVtcGxhdGUgZXh0ZW5kcyBiYXNlIHt9O1xuICAgICAgLy8gQWRkIHRlbXBsYXRlIC0gPmluc3RhbmNlcyBlZmZlY3RzXG4gICAgICAvLyBhbmQgaG9zdCA8LSB0ZW1wbGF0ZSBlZmZlY3RzXG4gICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICAgIGZvciAobGV0IHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoJ19ob3N0XycgKyBwcm9wLFxuICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuUFJPUEFHQVRFLFxuICAgICAgICAgIHtmbjogY3JlYXRlRm9yd2FyZEhvc3RQcm9wRWZmZWN0KHByb3AsIHVzZXJGb3J3YXJkSG9zdFByb3ApfSk7XG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkoJ19ob3N0XycgKyBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBrbGFzcyk7XG4gICAgLy8gTWl4IGFueSBwcmUtYm91bmQgZGF0YSBpbnRvIF9fZGF0YTsgbm8gbmVlZCB0byBmbHVzaCB0aGlzIHRvXG4gICAgLy8gaW5zdGFuY2VzIHNpbmNlIHRoZXkgcHVsbCBmcm9tIHRoZSB0ZW1wbGF0ZSBhdCBpbnN0YW5jZS10aW1lXG4gICAgaWYgKHRlbXBsYXRlLl9fZGF0YVByb3RvKSB7XG4gICAgICAvLyBOb3RlLCBnZW5lcmFsbHkgYF9fZGF0YVByb3RvYCBjb3VsZCBiZSBjaGFpbmVkLCBidXQgaXQncyBndWFyYW50ZWVkXG4gICAgICAvLyB0byBub3QgYmUgc2luY2UgdGhpcyBpcyBhIHZhbmlsbGEgdGVtcGxhdGUgd2UganVzdCBhZGRlZCBlZmZlY3RzIHRvXG4gICAgICBPYmplY3QuYXNzaWduKHRlbXBsYXRlLl9fZGF0YSwgdGVtcGxhdGUuX19kYXRhUHJvdG8pO1xuICAgIH1cbiAgICAvLyBDbGVhciBhbnkgcGVuZGluZyBkYXRhIGZvciBwZXJmb3JtYW5jZVxuICAgIHRlbXBsYXRlLl9fZGF0YVRlbXAgPSB7fTtcbiAgICB0ZW1wbGF0ZS5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB0ZW1wbGF0ZS5fX2RhdGFPbGQgPSBudWxsO1xuICAgIHRlbXBsYXRlLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cblxuZnVuY3Rpb24gY3JlYXRlRm9yd2FyZEhvc3RQcm9wRWZmZWN0KGhvc3RQcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb3J3YXJkSG9zdFByb3AodGVtcGxhdGUsIHByb3AsIHByb3BzKSB7XG4gICAgdXNlckZvcndhcmRIb3N0UHJvcC5jYWxsKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgcHJvcC5zdWJzdHJpbmcoJ19ob3N0XycubGVuZ3RoKSwgcHJvcHNbcHJvcF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICBkZWxldGUgaG9zdFByb3BzW2lwcm9wXTtcbiAgICBsZXQgdXNlck5vdGlmeUluc3RhbmNlUHJvcCA9IG9wdGlvbnMubm90aWZ5SW5zdGFuY2VQcm9wO1xuICAgIGlmICh1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGlwcm9wLFxuICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLk5PVElGWSxcbiAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaXByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApfSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmZvcndhcmRIb3N0UHJvcCAmJiB0ZW1wbGF0ZS5fX2RhdGFIb3N0KSB7XG4gICAgZm9yIChsZXQgaHByb3AgaW4gaG9zdFByb3BzKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KGhwcm9wLFxuICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLk5PVElGWSxcbiAgICAgICAge2ZuOiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpbnN0UHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SW5zdGFuY2VQcm9wKGluc3QsIHByb3AsIHByb3BzKSB7XG4gICAgdXNlck5vdGlmeUluc3RhbmNlUHJvcC5jYWxsKGluc3QuX190ZW1wbGF0aXplT3duZXIsXG4gICAgICBpbnN0LCBwcm9wLCBwcm9wc1twcm9wXSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGlmeUhvc3RQcm9wRWZmZWN0KCkge1xuICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5SG9zdFByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICBpbnN0Ll9fZGF0YUhvc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aCgnX2hvc3RfJyArIHByb3AsIHByb3BzW3Byb3BdLCB0cnVlLCB0cnVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlcyB0aGF0IHV0aWxpemVcbiAqIFBvbHltZXIncyBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyIGZlYXR1cmVzLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUpO1xuICogICAgIC8vIEluc3RhbmNlIHRoZSB0ZW1wbGF0ZSB3aXRoIGFuIGluaXRpYWwgZGF0YSBtb2RlbFxuICogICAgIGxldCBpbnN0YW5jZSA9IG5ldyBUZW1wbGF0ZUNsYXNzKHtteVByb3A6ICdpbml0aWFsJ30pO1xuICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGVsZW1lbnQncyBzaGFkb3cgRE9NXG4gKiAgICAgdGhpcy5zaGFkb3dSb290LmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICogICAgIC8vIENoYW5naW5nIGEgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlIHdpbGwgcHJvcGFnYXRlIHRvIGJpbmRpbmdzXG4gKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gKlxuICogVGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5IHBhc3NlZCB0byBgdGVtcGxhdGl6ZWAgYWxsb3dzIGZvciBjdXN0b21pemluZ1xuICogZmVhdHVyZXMgb2YgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBjbGFzcywgaW5jbHVkaW5nIGhvdyBvdXRlci1zY29wZSBob3N0XG4gKiBwcm9wZXJ0aWVzIHNob3VsZCBiZSBmb3J3YXJkZWQgaW50byB0ZW1wbGF0ZSBpbnN0YW5jZXMsIGhvdyBhbnkgaW5zdGFuY2VcbiAqIHByb3BlcnRpZXMgYWRkZWQgaW50byB0aGUgdGVtcGxhdGUncyBzY29wZSBzaG91bGQgYmUgbm90aWZpZWQgb3V0IHRvXG4gKiB0aGUgaG9zdCwgYW5kIHdoZXRoZXIgdGhlIGluc3RhbmNlIHNob3VsZCBiZSBkZWNvcmF0ZWQgYXMgYSBcInBhcmVudCBtb2RlbFwiXG4gKiBvZiBhbnkgZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogICAgIC8vIEN1c3RvbXplIHByb3BlcnR5IGZvcndhcmRpbmcgYW5kIGV2ZW50IG1vZGVsIGRlY29yYXRpb25cbiAqICAgICBsZXQgVGVtcGxhdGVDbGFzcyA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gKiAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAqICAgICAgIGluc3RhbmNlUHJvcHM6IHsuLi59LFxuICogICAgICAgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gKiAgICAgICBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSkgey4uLn0sXG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBNb2R1bGUgZm9yIHByZXBhcmluZyBhbmQgc3RhbXBpbmcgaW5zdGFuY2VzIG9mIHRlbXBsYXRlc1xuICogICB1dGlsaXppbmcgUG9seW1lciB0ZW1wbGF0aW5nIGZlYXR1cmVzLlxuICovXG5cbmNvbnN0IFRlbXBsYXRpemUgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgY2xhc3MgYm91bmQgdG8gdGhlXG4gICAqIGA8dGVtcGxhdGU+YCBwcm92aWRlZC4gIEluc3RhbmNpbmcgdGhlIGNsYXNzIHdpbGwgcmVzdWx0IGluIHRoZVxuICAgKiB0ZW1wbGF0ZSBiZWluZyBzdGFtcGVkIGludG8gZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGFzIHRoZSBpbnN0YW5jZSdzXG4gICAqIGByb290YCBwcm9wZXJ0eSwgYWZ0ZXIgd2hpY2ggaXQgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBET00uXG4gICAqXG4gICAqIFRlbXBsYXRlcyBtYXkgdXRpbGl6ZSBhbGwgUG9seW1lciBkYXRhLWJpbmRpbmcgZmVhdHVyZXMgYXMgd2VsbCBhc1xuICAgKiBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMuICBFdmVudCBsaXN0ZW5lcnMgYW5kIGlubGluZSBjb21wdXRpbmdcbiAgICogZnVuY3Rpb25zIGluIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgaG9zdCBvZiB0aGUgdGVtcGxhdGUuXG4gICAqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciByZXR1cm5lZCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudCBkaWN0aW9uYXJ5IG9mIGluaXRpYWxcbiAgICogcHJvcGVydHkgdmFsdWVzIHRvIHByb3BhZ2F0ZSBpbnRvIHRlbXBsYXRlIGJpbmRpbmdzLiAgQWRkaXRpb25hbGx5XG4gICAqIGhvc3QgcHJvcGVydGllcyBjYW4gYmUgZm9yd2FyZGVkIGluLCBhbmQgaW5zdGFuY2UgcHJvcGVydGllcyBjYW4gYmVcbiAgICogbm90aWZpZWQgb3V0IGJ5IHByb3ZpZGluZyBvcHRpb25hbCBjYWxsYmFja3MgaW4gdGhlIGBvcHRpb25zYCBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBWYWxpZCBjb25maWd1cmF0aW9uIGluIGBvcHRpb25zYCBhcmUgYXMgZm9sbG93czpcbiAgICpcbiAgICogLSBgZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlbiBhIHByb3BlcnR5IHJlZmVyZW5jZWRcbiAgICogICBpbiB0aGUgdGVtcGxhdGUgY2hhbmdlZCBvbiB0aGUgdGVtcGxhdGUncyBob3N0LiBBcyB0aGlzIGxpYnJhcnkgZG9lc1xuICAgKiAgIG5vdCByZXRhaW4gcmVmZXJlbmNlcyB0byB0ZW1wbGF0ZXMgaW5zdGFuY2VkIGJ5IHRoZSB1c2VyLCBpdCBpcyB0aGVcbiAgICogICB0ZW1wbGF0aXplIG93bmVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZm9yd2FyZCBob3N0IHByb3BlcnR5IGNoYW5nZXMgaW50b1xuICAgKiAgIHVzZXItc3RhbXBlZCBpbnN0YW5jZXMuICBUaGUgYGluc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpYFxuICAgKiAgICBtZXRob2Qgb24gdGhlIGdlbmVyYXRlZCBjbGFzcyBzaG91bGQgYmUgY2FsbGVkIHRvIGZvcndhcmQgaG9zdFxuICAgKiAgIHByb3BlcnRpZXMgaW50byB0aGUgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBwcm9wZXJ0eS1jaGFuZ2VkXG4gICAqICAgbm90aWZpY2F0aW9ucy4gQW55IHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUgdGhhdCBhcmUgbm90XG4gICAqICAgZGVmaW5lZCBpbiBgaW5zdGFuY2VQcm9wc2Agd2lsbCBiZSBub3RpZmllZCB1cCB0byB0aGUgdGVtcGxhdGUncyBob3N0XG4gICAqICAgYXV0b21hdGljYWxseS5cbiAgICogLSBgaW5zdGFuY2VQcm9wc2A6IERpY3Rpb25hcnkgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB3aWxsIGJlIGFkZGVkXG4gICAqICAgdG8gdGhlIGluc3RhbmNlIGJ5IHRoZSB0ZW1wbGF0aXplIG93bmVyLiAgVGhlc2UgcHJvcGVydGllcyBzaGFkb3cgYW55XG4gICAqICAgaG9zdCBwcm9wZXJ0aWVzLCBhbmQgY2hhbmdlcyB3aXRoaW4gdGhlIHRlbXBsYXRlIHRvIHRoZXNlIHByb3BlcnRpZXNcbiAgICogICB3aWxsIHJlc3VsdCBpbiBgbm90aWZ5SW5zdGFuY2VQcm9wYCBiZWluZyBjYWxsZWQuXG4gICAqIC0gYG11dGFibGVEYXRhYDogV2hlbiBgdHJ1ZWAsIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgd2lsbCBza2lwIHN0cmljdFxuICAgKiAgIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvIGJlXG4gICAqICAgXCJkaXJ0eVwiKS5cbiAgICogLSBgbm90aWZ5SW5zdGFuY2VQcm9wKGluc3RhbmNlLCBwcm9wZXJ0eSwgdmFsdWUpYDogQ2FsbGVkIHdoZW5cbiAgICogICBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBjaGFuZ2VzLiAgVXNlcnMgbWF5IGNob29zZSB0byBjYWxsIGBub3RpZnlQYXRoYFxuICAgKiAgIG9uIGUuZy4gdGhlIG93bmVyIHRvIG5vdGlmeSB0aGUgY2hhbmdlLlxuICAgKiAtIGBwYXJlbnRNb2RlbGA6IFdoZW4gYHRydWVgLCBldmVudHMgaGFuZGxlZCBieSBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnNcbiAgICogICAoYG9uLWV2ZW50PVwiaGFuZGxlclwiYCkgd2lsbCBiZSBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHkgcG9pbnRpbmdcbiAgICogICB0byB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhhdCBzdGFtcGVkIGl0LiAgSXQgd2lsbCBhbHNvIGJlIHJldHVybmVkXG4gICAqICAgZnJvbSBgaW5zdGFuY2UucGFyZW50TW9kZWxgIGluIGNhc2VzIHdoZXJlIHRlbXBsYXRlIGluc3RhbmNlIG5lc3RpbmdcbiAgICogICBjYXVzZXMgYW4gaW5uZXIgbW9kZWwgdG8gc2hhZG93IGFuIG91dGVyIG1vZGVsLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNsYXNzIHJldHVybmVkIGZyb20gYHRlbXBsYXRpemVgIGlzIGdlbmVyYXRlZCBvbmx5IG9uY2VcbiAgICogZm9yIGEgZ2l2ZW4gYDx0ZW1wbGF0ZT5gIHVzaW5nIGBvcHRpb25zYCBmcm9tIHRoZSBmaXJzdCBjYWxsIGZvciB0aGF0XG4gICAqIHRlbXBsYXRlLCBhbmQgdGhlIGNhY2hlZCBjbGFzcyBpcyByZXR1cm5lZCBmb3IgYWxsIHN1YnNlcXVlbnQgY2FsbHMgdG9cbiAgICogYHRlbXBsYXRpemVgIGZvciB0aGF0IHRlbXBsYXRlLiAgQXMgc3VjaCwgYG9wdGlvbnNgIGNhbGxiYWNrcyBzaG91bGQgbm90XG4gICAqIGNsb3NlIG92ZXIgb3duZXItc3BlY2lmaWMgcHJvcGVydGllcyBzaW5jZSBvbmx5IHRoZSBmaXJzdCBgb3B0aW9uc2AgaXNcbiAgICogdXNlZDsgcmF0aGVyLCBjYWxsYmFja3MgYXJlIGNhbGxlZCBib3VuZCB0byB0aGUgYG93bmVyYCwgYW5kIHNvIGNvbnRleHRcbiAgICogbmVlZGVkIGZyb20gdGhlIGNhbGxiYWNrcyAoc3VjaCBhcyByZWZlcmVuY2VzIHRvIGBpbnN0YW5jZXNgIHN0YW1wZWQpXG4gICAqIHNob3VsZCBiZSBzdG9yZWQgb24gdGhlIGBvd25lcmAgc3VjaCB0aGF0IHRoZXkgY2FuIGJlIHJldHJpZXZlZCB2aWEgYHRoaXNgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5UZW1wbGF0aXplXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHRlbXBsYXRpemVcbiAgICogQHBhcmFtIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IG93bmVyIE93bmVyIG9mIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZXM7XG4gICAqICAgYW55IG9wdGlvbmFsIGNhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoaXMgb3duZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIGRpY3Rpb25hcnkgKHNlZSBzdW1tYXJ5IGZvciBkZXRhaWxzKVxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UpfSBHZW5lcmF0ZWQgY2xhc3MgYm91bmQgdG8gdGhlIHRlbXBsYXRlXG4gICAqICAgcHJvdmlkZWRcbiAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAqL1xuICB0ZW1wbGF0aXplKHRlbXBsYXRlLCBvd25lciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi8ob3B0aW9ucyB8fCB7fSk7XG4gICAgaWYgKHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgPHRlbXBsYXRlPiBjYW4gb25seSBiZSB0ZW1wbGF0aXplZCBvbmNlJyk7XG4gICAgfVxuICAgIHRlbXBsYXRlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAgbGV0IHRlbXBsYXRlSW5mbyA9IG93bmVyLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAvLyBHZXQgbWVtb2l6ZWQgYmFzZSBjbGFzcyBmb3IgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSwgd2hpY2hcbiAgICAvLyBpbmNsdWRlcyBwcm9wZXJ0eSBlZmZlY3RzIGZvciBiaW5kaW5nIHRlbXBsYXRlICYgZm9yd2FyZGluZ1xuICAgIGxldCBiYXNlQ2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZUluc3RhbmNlQ2xhc3M7XG4gICAgaWYgKCFiYXNlQ2xhc3MpIHtcbiAgICAgIGJhc2VDbGFzcyA9IGNyZWF0ZVRlbXBsYXRpemVyQ2xhc3ModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgICB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZUluc3RhbmNlQ2xhc3MgPSBiYXNlQ2xhc3M7XG4gICAgfVxuICAgIC8vIEhvc3QgcHJvcGVydHkgZm9yd2FyZGluZyBtdXN0IGJlIGluc3RhbGxlZCBvbnRvIHRlbXBsYXRlIGluc3RhbmNlXG4gICAgYWRkUHJvcGFnYXRlRWZmZWN0cyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgICAvLyBTdWJjbGFzcyBiYXNlIGNsYXNzIGFuZCBhZGQgcmVmZXJlbmNlIGZvciB0aGlzIHNwZWNpZmljIHRlbXBsYXRlXG4gICAgbGV0IGtsYXNzID0gY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSBleHRlbmRzIGJhc2VDbGFzcyB7fTtcbiAgICBrbGFzcy5wcm90b3R5cGUuX21ldGhvZEhvc3QgPSBmaW5kTWV0aG9kSG9zdCh0ZW1wbGF0ZSk7XG4gICAga2xhc3MucHJvdG90eXBlLl9fZGF0YUhvc3QgPSB0ZW1wbGF0ZTtcbiAgICBrbGFzcy5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXIgPSBvd25lcjtcbiAgICBrbGFzcy5wcm90b3R5cGUuX19ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgIHJldHVybiAvKiogQHR5cGUge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9ICovKGtsYXNzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgXCJtb2RlbFwiIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGVsZW1lbnQsIHdoaWNoXG4gICAqIHNlcnZlcyBhcyB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoZSBlbGVtZW50IGlzXG4gICAqIGNvbnRhaW5lZCBpbi4gQSB0ZW1wbGF0ZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgVGVtcGxhdGVJbnN0YW5jZUJhc2VgLCBhbmQgc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgIGxldCBtb2RlbCA9IG1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5UZW1wbGF0aXplXG4gICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGhlIG1vZGVsIHdpbGwgYmUgcmV0dXJuZWQgZm9yXG4gICAqICAgZWxlbWVudHMgc3RhbXBlZCBmcm9tIHRoaXMgdGVtcGxhdGVcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gVGVtcGxhdGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZVxuICAgKiAgIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSBlbGVtZW50XG4gICAqL1xuICBtb2RlbEZvckVsZW1lbnQodGVtcGxhdGUsIG5vZGUpIHtcbiAgICBsZXQgbW9kZWw7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIC8vIEFuIGVsZW1lbnQgd2l0aCBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIG1hcmtzIHRoZSB0b3AgYm91bmRhcnlcbiAgICAgIC8vIG9mIGEgc2NvcGU7IHdhbGsgdXAgdW50aWwgd2UgZmluZCBvbmUsIGFuZCB0aGVuIGVuc3VyZSB0aGF0XG4gICAgICAvLyBpdHMgX19kYXRhSG9zdCBtYXRjaGVzIGB0aGlzYCwgbWVhbmluZyB0aGlzIGRvbS1yZXBlYXQgc3RhbXBlZCBpdFxuICAgICAgaWYgKChtb2RlbCA9IG5vZGUuX190ZW1wbGF0aXplSW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIEZvdW5kIGFuIGVsZW1lbnQgc3RhbXBlZCBieSBhbm90aGVyIHRlbXBsYXRlOyBrZWVwIHdhbGtpbmcgdXBcbiAgICAgICAgLy8gZnJvbSBpdHMgX19kYXRhSG9zdFxuICAgICAgICBpZiAobW9kZWwuX19kYXRhSG9zdCAhPSB0ZW1wbGF0ZSkge1xuICAgICAgICAgIG5vZGUgPSBtb2RlbC5fX2RhdGFIb3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RpbGwgaW4gYSB0ZW1wbGF0ZSBzY29wZSwga2VlcCBnb2luZyB1cCB1bnRpbFxuICAgICAgICAvLyBhIF9fdGVtcGxhdGl6ZUluc3RhbmNlIGlzIGZvdW5kXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5leHBvcnQgeyBUZW1wbGF0aXplIH07XG5leHBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzIiwiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uLy4uL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBhcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwLCBUZW1wbGF0aXplIH0gZnJvbSAnLi4vdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyBlbnF1ZXVlRGVib3VuY2VyLCBmbHVzaCB9IGZyb20gJy4uL3V0aWxzL2ZsdXNoLmpzJztcbmltcG9ydCB7IE9wdGlvbmFsTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcbmltcG9ydCB7IG1hdGNoZXMsIHRyYW5zbGF0ZSB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuaW1wb3J0IHsgdGltZU91dCwgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuXG5sZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAqL1xuY29uc3QgZG9tUmVwZWF0QmFzZSA9IE9wdGlvbmFsTXV0YWJsZURhdGEoRWxlbWVudCk7XG5cbi8qKlxuICogVGhlIGA8ZG9tLXJlcGVhdD5gIGVsZW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHN0YW1wIGFuZCBiaW5kcyBvbmUgaW5zdGFuY2VcbiAqIG9mIHRlbXBsYXRlIGNvbnRlbnQgdG8gZWFjaCBvYmplY3QgaW4gYSB1c2VyLXByb3ZpZGVkIGFycmF5LlxuICogYGRvbS1yZXBlYXRgIGFjY2VwdHMgYW4gYGl0ZW1zYCBwcm9wZXJ0eSwgYW5kIG9uZSBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGVcbiAqIGlzIHN0YW1wZWQgZm9yIGVhY2ggaXRlbSBpbnRvIHRoZSBET00gYXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBgZG9tLXJlcGVhdGBcbiAqIGVsZW1lbnQuICBUaGUgYGl0ZW1gIHByb3BlcnR5IHdpbGwgYmUgc2V0IG9uIGVhY2ggaW5zdGFuY2UncyBiaW5kaW5nXG4gKiBzY29wZSwgdGh1cyB0ZW1wbGF0ZXMgc2hvdWxkIGJpbmQgdG8gc3ViLXByb3BlcnRpZXMgb2YgYGl0ZW1gLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gKlxuICogICA8dGVtcGxhdGU+XG4gKlxuICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIj5cbiAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgIDwvdGVtcGxhdGU+XG4gKlxuICogICA8c2NyaXB0PlxuICogICAgIFBvbHltZXIoe1xuICogICAgICAgaXM6ICdlbXBsb3llZS1saXN0JyxcbiAqICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gKiAgICAgICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAqICAgICAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICBdO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICogICA8IC9zY3JpcHQ+XG4gKlxuICogPC9kb20tbW9kdWxlPlxuICogYGBgXG4gKlxuICogTm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byBpdGVtcyBzdWItcHJvcGVydGllcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0ZW1wbGF0ZVxuICogaW5zdGFuY2VzLCB3aGljaCB3aWxsIHVwZGF0ZSB2aWEgdGhlIG5vcm1hbCBzdHJ1Y3R1cmVkIGRhdGEgbm90aWZpY2F0aW9uIHN5c3RlbS5cbiAqXG4gKiBNdXRhdGlvbnMgdG8gdGhlIGBpdGVtc2AgYXJyYXkgaXRzZWxmIHNob3VsZCBiZSBtYWRlIHVzaW5nIHRoZSBBcnJheVxuICogbXV0YXRpb24gQVBJJ3Mgb24gYFBvbHltZXIuQmFzZWAgKGBwdXNoYCwgYHBvcGAsIGBzcGxpY2VgLCBgc2hpZnRgLFxuICogYHVuc2hpZnRgKSwgYW5kIHRlbXBsYXRlIGluc3RhbmNlcyB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBkYXRhIGluIHRoZVxuICogYXJyYXkuXG4gKlxuICogRXZlbnRzIGNhdWdodCBieSBldmVudCBoYW5kbGVycyB3aXRoaW4gdGhlIGBkb20tcmVwZWF0YCB0ZW1wbGF0ZSB3aWxsIGJlXG4gKiBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHksIHdoaWNoIHJlcHJlc2VudHMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gKiBlYWNoIHRlbXBsYXRlIGluc3RhbmNlLiAgVGhlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIFBvbHltZXIuQmFzZSwgYW5kIHNob3VsZFxuICogYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgb24gdGhlIGluc3RhbmNlLCBmb3IgZXhhbXBsZVxuICogYGV2ZW50Lm1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB0aGUgbW9kZWwgZm9yIGEgdGVtcGxhdGUgaW5zdGFuY2UgZm9yIGFuIGVsZW1lbnQgc3RhbXBlZCBieVxuICogYSBgZG9tLXJlcGVhdGAgY2FuIGJlIG9idGFpbmVkIHVzaW5nIHRoZSBgbW9kZWxGb3JFbGVtZW50YCBBUEkgb24gdGhlXG4gKiBgZG9tLXJlcGVhdGAgdGhhdCBzdGFtcGVkIGl0LCBmb3IgZXhhbXBsZVxuICogYHRoaXMuJC5kb21SZXBlYXQubW9kZWxGb3JFbGVtZW50KGV2ZW50LnRhcmdldCkuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtgLlxuICogVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBtYW5pcHVsYXRpbmcgaW5zdGFuY2UgZGF0YSBvZiBldmVudCB0YXJnZXRzIG9idGFpbmVkXG4gKiBieSBldmVudCBoYW5kbGVycyBvbiBwYXJlbnRzIG9mIHRoZSBgZG9tLXJlcGVhdGAgKGV2ZW50IGRlbGVnYXRpb24pLlxuICpcbiAqIEEgdmlldy1zcGVjaWZpYyBmaWx0ZXIvc29ydCBtYXkgYmUgYXBwbGllZCB0byBlYWNoIGBkb20tcmVwZWF0YCBieSBzdXBwbHlpbmcgYVxuICogYGZpbHRlcmAgYW5kL29yIGBzb3J0YCBwcm9wZXJ0eS4gIFRoaXMgbWF5IGJlIGEgc3RyaW5nIHRoYXQgbmFtZXMgYSBmdW5jdGlvbiBvblxuICogdGhlIGhvc3QsIG9yIGEgZnVuY3Rpb24gbWF5IGJlIGFzc2lnbmVkIHRvIHRoZSBwcm9wZXJ0eSBkaXJlY3RseS4gIFRoZSBmdW5jdGlvbnNcbiAqIHNob3VsZCBpbXBsZW1lbnRlZCBmb2xsb3dpbmcgdGhlIHN0YW5kYXJkIGBBcnJheWAgZmlsdGVyL3NvcnQgQVBJLlxuICpcbiAqIEluIG9yZGVyIHRvIHJlLXJ1biB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb25zIGJhc2VkIG9uIGNoYW5nZXMgdG8gc3ViLWZpZWxkc1xuICogb2YgYGl0ZW1zYCwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2ZcbiAqIGBpdGVtYCBzdWItZmllbGRzIHRoYXQgc2hvdWxkIGNhdXNlIGEgcmUtZmlsdGVyL3NvcnQgd2hlbiBtb2RpZmllZC4gIElmXG4gKiB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb24gZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG5vdCBjb250YWluZWQgaW4gYGl0ZW1zYCxcbiAqIHRoZSB1c2VyIHNob3VsZCBvYnNlcnZlIGNoYW5nZXMgdG8gdGhvc2UgcHJvcGVydGllcyBhbmQgY2FsbCBgcmVuZGVyYCB0byB1cGRhdGVcbiAqIHRoZSB2aWV3IGJhc2VkIG9uIHRoZSBkZXBlbmRlbmN5IGNoYW5nZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZm9yIGFuIGBkb20tcmVwZWF0YCB3aXRoIGEgZmlsdGVyIG9mIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogYGBganNcbiAqIGlzRW5naW5lZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICByZXR1cm4gaXRlbS50eXBlID09ICdlbmdpbmVlcicgfHwgaXRlbS5tYW5hZ2VyLnR5cGUgPT0gJ2VuZ2luZWVyJztcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZW4gdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBzaG91bGQgYmUgY29uZmlndXJlZCBhcyBmb2xsb3dzOlxuICpcbiAqIGBgYGh0bWxcbiAqIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIlxuICogICAgICAgICAgIGZpbHRlcj1cImlzRW5naW5lZXJcIiBvYnNlcnZlPVwidHlwZSBtYW5hZ2VyLnR5cGVcIj5cbiAqIGBgYFxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBleHRlbmRzIHtkb21SZXBlYXRCYXNlfVxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBzdGFtcGluZyBpbnN0YW5jZSBvZiBhIHRlbXBsYXRlIGJvdW5kIHRvXG4gKiAgIGl0ZW1zIGluIGFuIGFycmF5LlxuICovXG5jbGFzcyBEb21SZXBlYXQgZXh0ZW5kcyBkb21SZXBlYXRCYXNlIHtcblxuICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLXJlcGVhdCc7IH1cblxuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAqIGByZW5kZXJgLlxuICAgICAqXG4gICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgKi9cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZGV0ZXJtaW5pbmcgaG93IG1hbnkgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogdG8gc3RhbXAgYW5kIHRoYXQgdGhhdCBlYWNoIHRlbXBsYXRlIGluc3RhbmNlIHNob3VsZCBiaW5kIHRvLlxuICAgICAgICovXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgYXJyYXlcbiAgICAgICAqIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICAgKi9cbiAgICAgIGFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpdGVtJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIHdpdGggdGhlIGluZGV4XG4gICAgICAgKiBvZiB0aGUgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcy5cbiAgICAgICAqIE5vdGUsIGZvciB0aGUgaW5kZXggaW4gdGhlIGB0aGlzLml0ZW1zYCBhcnJheSwgdXNlIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAqIGBpdGVtc0luZGV4QXNgIHByb3BlcnR5LlxuICAgICAgICovXG4gICAgICBpbmRleEFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpbmRleCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXkuIE5vdGUsIGZvciB0aGUgaW5kZXggb2ZcbiAgICAgICAqIHRoaXMgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcyxcbiAgICAgICAqIHVzZSB0aGUgdmFsdWUgb2YgdGhlIGBpbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAqL1xuICAgICAgaXRlbXNJbmRleEFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpdGVtc0luZGV4J1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGRldGVybWluZSB0aGUgc29ydCBvcmRlciBvZiB0aGUgaXRlbXMuICBUaGlzXG4gICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LnNvcnRgLlxuICAgICAgICogVXNpbmcgYSBzb3J0IGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAqL1xuICAgICAgc29ydDoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX3NvcnRDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIGl0ZW1zIG91dCBvZiB0aGUgdmlldy4gIFRoaXNcbiAgICAgICAqIHByb3BlcnR5IHNob3VsZCBlaXRoZXIgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcsIGluZGljYXRpbmcgYSBtZXRob2RcbiAgICAgICAqIG5hbWUgb24gdGhlIGVsZW1lbnQncyBob3N0LCBvciBlbHNlIGJlIGFuIGFjdHVhbCBmdW5jdGlvbi4gIFRoZVxuICAgICAgICogZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBzb3J0IGZ1bmN0aW9uIHBhc3NlZCB0byBgQXJyYXkuZmlsdGVyYC5cbiAgICAgICAqIFVzaW5nIGEgZmlsdGVyIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAqL1xuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICBvYnNlcnZlcjogJ19fZmlsdGVyQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB1c2luZyBhIGBmaWx0ZXJgIG9yIGBzb3J0YCBmdW5jdGlvbiwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eVxuICAgICAgICogc2hvdWxkIGJlIHNldCB0byBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBuYW1lcyBvZiBpdGVtXG4gICAgICAgKiBzdWItZmllbGRzIHRoYXQgc2hvdWxkIHRyaWdnZXIgYSByZS1zb3J0IG9yIHJlLWZpbHRlciB3aGVuIGNoYW5nZWQuXG4gICAgICAgKiBUaGVzZSBzaG91bGQgZ2VuZXJhbGx5IGJlIGZpZWxkcyBvZiBgaXRlbWAgdGhhdCB0aGUgc29ydCBvciBmaWx0ZXJcbiAgICAgICAqIGZ1bmN0aW9uIGRlcGVuZHMgb24uXG4gICAgICAgKi9cbiAgICAgIG9ic2VydmU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19fb2JzZXJ2ZUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgZGVsYXlgIHByb3BlcnR5XG4gICAgICAgKiBkZXRlcm1pbmVzIGEgZGVib3VuY2UgdGltZSBhZnRlciBhIGNoYW5nZSB0byBvYnNlcnZlZCBpdGVtXG4gICAgICAgKiBwcm9wZXJ0aWVzIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGUgZmlsdGVyIG9yIHNvcnQgaXMgcmUtcnVuLlxuICAgICAgICogVGhpcyBpcyB1c2VmdWwgaW4gcmF0ZS1saW1pdGluZyBzaHVmZmluZyBvZiB0aGUgdmlldyB3aGVuXG4gICAgICAgKiBpdGVtIGNoYW5nZXMgbWF5IGJlIGZyZXF1ZW50LlxuICAgICAgICovXG4gICAgICBkZWxheTogTnVtYmVyLFxuXG4gICAgICAvKipcbiAgICAgICAqIENvdW50IG9mIGN1cnJlbnRseSByZW5kZXJlZCBpdGVtcyBhZnRlciBgZmlsdGVyYCAoaWYgYW55KSBoYXMgYmVlbiBhcHBsaWVkLlxuICAgICAgICogSWYgXCJjaHVua2luZyBtb2RlXCIgaXMgZW5hYmxlZCwgYHJlbmRlcmVkSXRlbUNvdW50YCBpcyB1cGRhdGVkIGVhY2ggdGltZSBhXG4gICAgICAgKiBzZXQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIGlzIHJlbmRlcmVkLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgcmVuZGVyZWRJdGVtQ291bnQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIERlZmluZXMgYW4gaW5pdGlhbCBjb3VudCBvZiB0ZW1wbGF0ZSBpbnN0YW5jZXMgdG8gcmVuZGVyIGFmdGVyIHNldHRpbmdcbiAgICAgICAqIHRoZSBgaXRlbXNgIGFycmF5LCBiZWZvcmUgdGhlIG5leHQgcGFpbnQsIGFuZCBwdXRzIHRoZSBgZG9tLXJlcGVhdGBcbiAgICAgICAqIGludG8gXCJjaHVua2luZyBtb2RlXCIuICBUaGUgcmVtYWluaW5nIGl0ZW1zIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmVuZGVyZWRcbiAgICAgICAqIGluY3JlbWVudGFsbHkgYXQgZWFjaCBhbmltYXRpb24gZnJhbWUgdGhlcm9mIHVudGlsIGFsbCBpbnN0YW5jZXMgaGF2ZVxuICAgICAgICogYmVlbiByZW5kZXJlZC5cbiAgICAgICAqL1xuICAgICAgaW5pdGlhbENvdW50OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2luaXRpYWxpemVDaHVua2luZydcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiBgaW5pdGlhbENvdW50YCBpcyB1c2VkLCB0aGlzIHByb3BlcnR5IGRlZmluZXMgYSBmcmFtZSByYXRlIHRvXG4gICAgICAgKiB0YXJnZXQgYnkgdGhyb3R0bGluZyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyByZW5kZXJlZCBlYWNoIGZyYW1lIHRvXG4gICAgICAgKiBub3QgZXhjZWVkIHRoZSBidWRnZXQgZm9yIHRoZSB0YXJnZXQgZnJhbWUgcmF0ZS4gIFNldHRpbmcgdGhpcyB0byBhXG4gICAgICAgKiBoaWdoZXIgbnVtYmVyIHdpbGwgYWxsb3cgbG93ZXIgbGF0ZW5jeSBhbmQgaGlnaGVyIHRocm91Z2hwdXQgZm9yXG4gICAgICAgKiB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgYnV0IHdpbGwgcmVzdWx0IGluIGEgbG9uZ2VyIHRpbWUgZm9yIHRoZVxuICAgICAgICogcmVtYWluaW5nIGl0ZW1zIHRvIGNvbXBsZXRlIHJlbmRlcmluZy5cbiAgICAgICAqL1xuICAgICAgdGFyZ2V0RnJhbWVyYXRlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDIwXG4gICAgICB9LFxuXG4gICAgICBfdGFyZ2V0RnJhbWVUaW1lOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVGcmFtZVRpbWUodGFyZ2V0RnJhbWVyYXRlKSdcbiAgICAgIH1cblxuICAgIH07XG5cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgIHJldHVybiBbICdfX2l0ZW1zQ2hhbmdlZChpdGVtcy4qKScgXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX2luc3RhbmNlcyA9IFtdO1xuICAgIHRoaXMuX19saW1pdCA9IEluZmluaXR5O1xuICAgIHRoaXMuX19wb29sID0gW107XG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IG51bGw7XG4gICAgdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgdGhpcy5fX2NodW5rQ291bnQgPSBudWxsO1xuICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gbnVsbDtcbiAgICB0aGlzLl9fc29ydEZuID0gbnVsbDtcbiAgICB0aGlzLl9fZmlsdGVyRm4gPSBudWxsO1xuICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSBudWxsO1xuICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IG51bGw7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMuX19pc0RldGFjaGVkID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fX2RldGFjaEluc3RhbmNlKGkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgLy8gb25seSBwZXJmb3JtIGF0dGFjaG1lbnQgaWYgdGhlIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgaWYgKHRoaXMuX19pc0RldGFjaGVkKSB7XG4gICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX19hdHRhY2hJbnN0YW5jZShpLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9fZW5zdXJlVGVtcGxhdGl6ZWQoKSB7XG4gICAgLy8gVGVtcGxhdGl6aW5nIChnZW5lcmF0aW5nIHRoZSBpbnN0YW5jZSBjb25zdHJ1Y3RvcikgbmVlZHMgdG8gd2FpdFxuICAgIC8vIHVudGlsIHJlYWR5LCBzaW5jZSB3b24ndCBoYXZlIGl0cyB0ZW1wbGF0ZSBjb250ZW50IGhhbmRlZCBiYWNrIHRvXG4gICAgLy8gaXQgdW50aWwgdGhlblxuICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIC8vIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLXJlcGVhdCByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGVtcGxhdGUgaW5zdGFuY2UgcHJvcHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSBmb3J3YXJkaW5nXG4gICAgICBsZXQgaW5zdGFuY2VQcm9wcyA9IHt9O1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmFzXSA9IHRydWU7XG4gICAgICBpbnN0YW5jZVByb3BzW3RoaXMuaW5kZXhBc10gPSB0cnVlO1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLml0ZW1zSW5kZXhBc10gPSB0cnVlO1xuICAgICAgdGhpcy5fX2N0b3IgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgbXV0YWJsZURhdGE6IHRoaXMubXV0YWJsZURhdGEsXG4gICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZVByb3BzOiBpbnN0YW5jZVByb3BzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAgICAgKi9cbiAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgIGxldCBpJCA9IHRoaXMuX19pbnN0YW5jZXM7XG4gICAgICAgICAgZm9yIChsZXQgaT0wLCBpbnN0OyAoaTxpJC5sZW5ndGgpICYmIChpbnN0PWkkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBpbnN0LmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0IEluc3RhbmNlIHRvIG5vdGlmeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBub3RpZnlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBub3RpZnlcbiAgICAgICAgICovXG4gICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyh0aGlzLmFzLCBwcm9wKSkge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGluc3RbdGhpcy5pdGVtc0luZGV4QXNdO1xuICAgICAgICAgICAgaWYgKHByb3AgPT0gdGhpcy5hcykge1xuICAgICAgICAgICAgICB0aGlzLml0ZW1zW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXRoID0gdHJhbnNsYXRlKHRoaXMuYXMsICdpdGVtcy4nICsgaWR4LCBwcm9wKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5UGF0aChwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfX2dldE1ldGhvZEhvc3QoKSB7XG4gICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gICAgLy8gSW4gc2hhZG93IGRvbSwgdGhpcyBpcyBhbHdheXMgZ2V0Um9vdE5vZGUoKS5ob3N0LCBidXQgd2UgY2FuXG4gICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAgIC8vIGluc3RhbmNlIGNhdXNpbmcgaXQgdG8gZ2V0IGEgZGF0YUhvc3QuXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhSG9zdC5fbWV0aG9kSG9zdCB8fCB0aGlzLl9fZGF0YUhvc3Q7XG4gIH1cblxuICBfX3NvcnRDaGFuZ2VkKHNvcnQpIHtcbiAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgdGhpcy5fX3NvcnRGbiA9IHNvcnQgJiYgKHR5cGVvZiBzb3J0ID09ICdmdW5jdGlvbicgPyBzb3J0IDpcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtzb3J0XS5hcHBseShtZXRob2RIb3N0LCBhcmd1bWVudHMpOyB9KTtcbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9fZmlsdGVyQ2hhbmdlZChmaWx0ZXIpIHtcbiAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgdGhpcy5fX2ZpbHRlckZuID0gZmlsdGVyICYmICh0eXBlb2YgZmlsdGVyID09ICdmdW5jdGlvbicgPyBmaWx0ZXIgOlxuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2RIb3N0W2ZpbHRlcl0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2NvbXB1dGVGcmFtZVRpbWUocmF0ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoMTAwMC9yYXRlKTtcbiAgfVxuXG4gIF9faW5pdGlhbGl6ZUNodW5raW5nKCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxDb3VudCkge1xuICAgICAgdGhpcy5fX2xpbWl0ID0gdGhpcy5pbml0aWFsQ291bnQ7XG4gICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH1cblxuICBfX3RyeVJlbmRlckNodW5rKCkge1xuICAgIC8vIERlYm91bmNlZCBzbyB0aGF0IG11bHRpcGxlIGNhbGxzIHRocm91Z2ggYF9yZW5kZXJgIGJldHdlZW4gYW5pbWF0aW9uXG4gICAgLy8gZnJhbWVzIG9ubHkgcXVldWUgb25lIG5ldyByQUYgKGUuZy4gYXJyYXkgbXV0YXRpb24gJiBjaHVua2VkIHJlbmRlcilcbiAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLl9fbGltaXQgPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZXF1ZXN0UmVuZGVyQ2h1bmspO1xuICAgIH1cbiAgfVxuXG4gIF9fcmVxdWVzdFJlbmRlckNodW5rKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5fX3JlbmRlckNodW5rKCkpO1xuICB9XG5cbiAgX19yZW5kZXJDaHVuaygpIHtcbiAgICAvLyBTaW1wbGUgYXV0byBjaHVua1NpemUgdGhyb3R0bGluZyBhbGdvcml0aG0gYmFzZWQgb24gZmVlZGJhY2sgbG9vcDpcbiAgICAvLyBtZWFzdXJlIGFjdHVhbCB0aW1lIGJldHdlZW4gZnJhbWVzIGFuZCBzY2FsZSBjaHVuayBjb3VudCBieSByYXRpb1xuICAgIC8vIG9mIHRhcmdldC9hY3R1YWwgZnJhbWUgdGltZVxuICAgIGxldCBjdXJyQ2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgbGV0IHJhdGlvID0gdGhpcy5fdGFyZ2V0RnJhbWVUaW1lIC8gKGN1cnJDaHVua1RpbWUgLSB0aGlzLl9fbGFzdENodW5rVGltZSk7XG4gICAgdGhpcy5fX2NodW5rQ291bnQgPSBNYXRoLnJvdW5kKHRoaXMuX19jaHVua0NvdW50ICogcmF0aW8pIHx8IDE7XG4gICAgdGhpcy5fX2xpbWl0ICs9IHRoaXMuX19jaHVua0NvdW50O1xuICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gY3VyckNodW5rVGltZTtcbiAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gIH1cblxuICBfX29ic2VydmVDaGFuZ2VkKCkge1xuICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSB0aGlzLm9ic2VydmUgJiZcbiAgICAgIHRoaXMub2JzZXJ2ZS5yZXBsYWNlKCcuKicsICcuJykuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIF9faXRlbXNDaGFuZ2VkKGNoYW5nZSkge1xuICAgIGlmICh0aGlzLml0ZW1zICYmICFBcnJheS5pc0FycmF5KHRoaXMuaXRlbXMpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2RvbS1yZXBlYXQgZXhwZWN0ZWQgYXJyYXkgZm9yIGBpdGVtc2AsIGZvdW5kJywgdGhpcy5pdGVtcyk7XG4gICAgfVxuICAgIC8vIElmIHBhdGggd2FzIHRvIGFuIGl0ZW0gKGUuZy4gJ2l0ZW1zLjMnIG9yICdpdGVtcy4zLmZvbycpLCBmb3J3YXJkIHRoZVxuICAgIC8vIHBhdGggdG8gdGhhdCBpbnN0YW5jZSBzeW5jaHJvbm91c2x5IChyZXR1bnMgZmFsc2UgZm9yIG5vbi1pdGVtIHBhdGhzKVxuICAgIGlmICghdGhpcy5fX2hhbmRsZUl0ZW1QYXRoKGNoYW5nZS5wYXRoLCBjaGFuZ2UudmFsdWUpKSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBhcnJheSB3YXMgcmVzZXQgKCdpdGVtcycpIG9yIHNwbGljZWQgKCdpdGVtcy5zcGxpY2VzJyksXG4gICAgICAvLyBzbyBxdWV1ZSBhIGZ1bGwgcmVmcmVzaFxuICAgICAgdGhpcy5fX2luaXRpYWxpemVDaHVua2luZygpO1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9faGFuZGxlT2JzZXJ2ZWRQYXRocyhwYXRoKSB7XG4gICAgaWYgKHRoaXMuX19vYnNlcnZlUGF0aHMpIHtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhwYXRoLmluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgbGV0IHBhdGhzID0gdGhpcy5fX29ic2VydmVQYXRocztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKHBhdGhzW2ldKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyLCB0aGlzLmRlbGF5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6RG9tUmVwZWF0KX0gZm4gRnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gZGVsYXkgRGVsYXkgaW4gbXMgdG8gZGVib3VuY2UgYnkuXG4gICAqL1xuICBfX2RlYm91bmNlUmVuZGVyKGZuLCBkZWxheSA9IDApIHtcbiAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgLCBkZWxheSA+IDAgPyB0aW1lT3V0LmFmdGVyKGRlbGF5KSA6IG1pY3JvVGFza1xuICAgICAgICAsIGZuLmJpbmQodGhpcykpO1xuICAgIGVucXVldWVEZWJvdW5jZXIodGhpcy5fX3JlbmRlckRlYm91bmNlcik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICAvLyBRdWV1ZSB0aGlzIHJlcGVhdGVyLCB0aGVuIGZsdXNoIGFsbCBpbiBvcmRlclxuICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICBmbHVzaCgpO1xuICB9XG5cbiAgX19yZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9fZW5zdXJlVGVtcGxhdGl6ZWQoKSkge1xuICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19hcHBseUZ1bGxSZWZyZXNoKCk7XG4gICAgLy8gUmVzZXQgdGhlIHBvb2xcbiAgICAvLyBUT0RPKGtzY2hhYWYpOiBSZXVzZSBwb29sIGFjcm9zcyB0dXJucyBhbmQgbmVzdGVkIHRlbXBsYXRlc1xuICAgIC8vIE5vdyB0aGF0IG9iamVjdHMvYXJyYXlzIGFyZSByZS1ldmFsdWF0ZWQgd2hlbiBzZXQsIHdlIGNhbiBzYWZlbHlcbiAgICAvLyByZXVzZSBwb29sZWQgaW5zdGFuY2VzIGFjcm9zcyB0dXJucywgaG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGRlY2lkZVxuICAgIC8vIHNlbWFudGljcyByZWdhcmRpbmcgaG93IGxvbmcgdG8gaG9sZCwgaG93IG1hbnkgdG8gaG9sZCwgZXRjLlxuICAgIHRoaXMuX19wb29sLmxlbmd0aCA9IDA7XG4gICAgLy8gU2V0IHJlbmRlcmVkIGl0ZW0gY291bnRcbiAgICB0aGlzLl9zZXRSZW5kZXJlZEl0ZW1Db3VudCh0aGlzLl9faW5zdGFuY2VzLmxlbmd0aCk7XG4gICAgLy8gTm90aWZ5IHVzZXJzXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH0pKTtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgbW9yZSBpdGVtc1xuICAgIHRoaXMuX190cnlSZW5kZXJDaHVuaygpO1xuICB9XG5cbiAgX19hcHBseUZ1bGxSZWZyZXNoKCkge1xuICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG4gICAgbGV0IGlzbnRJZHhUb0l0ZW1zSWR4ID0gbmV3IEFycmF5KGl0ZW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpc250SWR4VG9JdGVtc0lkeFtpXSA9IGk7XG4gICAgfVxuICAgIC8vIEFwcGx5IHVzZXIgZmlsdGVyXG4gICAgaWYgKHRoaXMuX19maWx0ZXJGbikge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHggPSBpc250SWR4VG9JdGVtc0lkeC5maWx0ZXIoKGksIGlkeCwgYXJyYXkpID0+XG4gICAgICAgIHRoaXMuX19maWx0ZXJGbihpdGVtc1tpXSwgaWR4LCBhcnJheSkpO1xuICAgIH1cbiAgICAvLyBBcHBseSB1c2VyIHNvcnRcbiAgICBpZiAodGhpcy5fX3NvcnRGbikge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHguc29ydCgoYSwgYikgPT4gdGhpcy5fX3NvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pKTtcbiAgICB9XG4gICAgLy8gaXRlbXMtPmluc3QgbWFwIGtlcHQgZm9yIGl0ZW0gcGF0aCBmb3J3YXJkaW5nXG4gICAgY29uc3QgaXRlbXNJZHhUb0luc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHggPSB7fTtcbiAgICBsZXQgaW5zdElkeCA9IDA7XG4gICAgLy8gR2VuZXJhdGUgaW5zdGFuY2VzIGFuZCBhc3NpZ24gaXRlbXNcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKGlzbnRJZHhUb0l0ZW1zSWR4Lmxlbmd0aCwgdGhpcy5fX2xpbWl0KTtcbiAgICBmb3IgKDsgaW5zdElkeDxsaW1pdDsgaW5zdElkeCsrKSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICBsZXQgaXRlbUlkeCA9IGlzbnRJZHhUb0l0ZW1zSWR4W2luc3RJZHhdO1xuICAgICAgbGV0IGl0ZW0gPSBpdGVtc1tpdGVtSWR4XTtcbiAgICAgIGl0ZW1zSWR4VG9JbnN0SWR4W2l0ZW1JZHhdID0gaW5zdElkeDtcbiAgICAgIGlmIChpbnN0ICYmIGluc3RJZHggPCB0aGlzLl9fbGltaXQpIHtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuYXMsIGl0ZW0pO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgaW5zdGFuY2VzIGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICBmb3IgKGxldCBpPXRoaXMuX19pbnN0YW5jZXMubGVuZ3RoLTE7IGk+PWluc3RJZHg7IGktLSkge1xuICAgICAgdGhpcy5fX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGkpO1xuICAgIH1cbiAgfVxuXG4gIF9fZGV0YWNoSW5zdGFuY2UoaWR4KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgZm9yIChsZXQgaT0wOyBpPGluc3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBlbCA9IGluc3QuY2hpbGRyZW5baV07XG4gICAgICBpbnN0LnJvb3QuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIF9fYXR0YWNoSW5zdGFuY2UoaWR4LCBwYXJlbnQpIHtcbiAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaWR4XTtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc3Qucm9vdCwgdGhpcyk7XG4gIH1cblxuICBfX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX2RldGFjaEluc3RhbmNlKGlkeCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIHRoaXMuX19wb29sLnB1c2goaW5zdCk7XG4gICAgfVxuICAgIHRoaXMuX19pbnN0YW5jZXMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cblxuICBfX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgIGxldCBtb2RlbCA9IHt9O1xuICAgIG1vZGVsW3RoaXMuYXNdID0gaXRlbTtcbiAgICBtb2RlbFt0aGlzLmluZGV4QXNdID0gaW5zdElkeDtcbiAgICBtb2RlbFt0aGlzLml0ZW1zSW5kZXhBc10gPSBpdGVtSWR4O1xuICAgIHJldHVybiBuZXcgdGhpcy5fX2N0b3IobW9kZWwpO1xuICB9XG5cbiAgX19pbnNlcnRJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9fcG9vbC5wb3AoKTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgLy8gVE9ETyhrc2NoYWFmKTogSWYgdGhlIHBvb2wgaXMgc2hhcmVkIGFjcm9zcyB0dXJucywgaG9zdFByb3BzXG4gICAgICAvLyBuZWVkIHRvIGJlIHJlLXNldCB0byByZXVzZWQgaW5zdGFuY2VzIGluIGFkZGl0aW9uIHRvIGl0ZW1cbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmluZGV4QXMsIGluc3RJZHgpO1xuICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0ID0gdGhpcy5fX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgfVxuICAgIGxldCBiZWZvcmVSb3cgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHggKyAxXTtcbiAgICBsZXQgYmVmb3JlTm9kZSA9IGJlZm9yZVJvdyA/IGJlZm9yZVJvdy5jaGlsZHJlblswXSA6IHRoaXM7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnN0LnJvb3QsIGJlZm9yZU5vZGUpO1xuICAgIHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF0gPSBpbnN0O1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLy8gSW1wbGVtZW50cyBleHRlbnNpb24gcG9pbnQgZnJvbSBUZW1wbGF0aXplIG1peGluXG4gIF9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbikge1xuICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9faW5zdGFuY2VzW2ldLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGFzIGEgc2lkZSBlZmZlY3Qgb2YgYSBob3N0IGl0ZW1zLjxrZXk+LjxwYXRoPiBwYXRoIGNoYW5nZSxcbiAgLy8gcmVzcG9uc2libGUgZm9yIG5vdGlmeWluZyBpdGVtLjxwYXRoPiBjaGFuZ2VzIHRvIGluc3QgZm9yIGtleVxuICBfX2hhbmRsZUl0ZW1QYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgbGV0IGl0ZW1zUGF0aCA9IHBhdGguc2xpY2UoNik7IC8vICdpdGVtcy4nLmxlbmd0aCA9PSA2XG4gICAgbGV0IGRvdCA9IGl0ZW1zUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgbGV0IGl0ZW1zSWR4ID0gZG90IDwgMCA/IGl0ZW1zUGF0aCA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoMCwgZG90KTtcbiAgICAvLyBJZiBwYXRoIHdhcyBpbmRleCBpbnRvIGFycmF5Li4uXG4gICAgaWYgKGl0ZW1zSWR4ID09IHBhcnNlSW50KGl0ZW1zSWR4LCAxMCkpIHtcbiAgICAgIGxldCBpdGVtU3ViUGF0aCA9IGRvdCA8IDAgPyAnJyA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoZG90KzEpO1xuICAgICAgLy8gSWYgdGhlIHBhdGggaXMgb2JzZXJ2ZWQsIGl0IHdpbGwgdHJpZ2dlciBhIGZ1bGwgcmVmcmVzaFxuICAgICAgdGhpcy5fX2hhbmRsZU9ic2VydmVkUGF0aHMoaXRlbVN1YlBhdGgpO1xuICAgICAgLy8gTm90ZSwgZXZlbiBpZiBhIHJ1bGwgcmVmcmVzaCBpcyB0cmlnZ2VyZWQsIGFsd2F5cyBkbyB0aGUgcGF0aFxuICAgICAgLy8gbm90aWZpY2F0aW9uIGJlY2F1c2UgdW5sZXNzIG11dGFibGVEYXRhIGlzIHVzZWQgZm9yIGRvbS1yZXBlYXRcbiAgICAgIC8vIGFuZCBhbGwgZWxlbWVudHMgaW4gdGhlIGluc3RhbmNlIHN1YnRyZWUsIGEgZnVsbCByZWZyZXNoIG1heVxuICAgICAgLy8gbm90IHRyaWdnZXIgdGhlIHByb3BlciB1cGRhdGUuXG4gICAgICBsZXQgaW5zdElkeCA9IHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeFtpdGVtc0lkeF07XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICBsZXQgaXRlbVBhdGggPSB0aGlzLmFzICsgKGl0ZW1TdWJQYXRoID8gJy4nICsgaXRlbVN1YlBhdGggOiAnJyk7XG4gICAgICAgIC8vIFRoaXMgaXMgZWZmZWN0aXZlbHkgYG5vdGlmeVBhdGhgLCBidXQgYXZvaWRzIHNvbWUgb2YgdGhlIG92ZXJoZWFkXG4gICAgICAgIC8vIG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChpdGVtUGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAgICogdGhpcyBgZG9tLXJlcGVhdGAuXG4gICAqXG4gICAqIE5vdGUsIHRvIG1vZGlmeSBzdWItcHJvcGVydGllcyBvZiB0aGUgaXRlbSxcbiAgICogYG1vZGVsRm9yRWxlbWVudChlbCkuc2V0KCdpdGVtLjxzdWItcHJvcD4nLCB2YWx1ZSlgXG4gICAqIHNob3VsZCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gdGhlIGl0ZW0uXG4gICAqIEByZXR1cm4geyp9IEl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgaXRlbUZvckVsZW1lbnQoZWwpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLm1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW3RoaXMuYXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluc3QgaW5kZXggZm9yIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5IHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgKiBJZiBgc29ydGAgaXMgcHJvdmlkZWQsIHRoZSBpbmRleCB3aWxsIHJlZmxlY3QgdGhlIHNvcnRlZCBvcmRlciAocmF0aGVyXG4gICAqIHRoYW4gdGhlIG9yaWdpbmFsIGFycmF5IG9yZGVyKS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpbmRleC5cbiAgICogQHJldHVybiB7Kn0gUm93IGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudCAobm90ZSB0aGlzIG1heVxuICAgKiAgIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBhcnJheSBpbmRleCBpZiBhIHVzZXIgYHNvcnRgIGlzIGFwcGxpZWQpLlxuICAgKi9cbiAgaW5kZXhGb3JFbGVtZW50KGVsKSB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmluZGV4QXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2YgYFBvbHltZXIuQmFzZWAsIGFuZFxuICAgKiBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgKiAgIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIFRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMudGVtcGxhdGUsIGVsKTtcbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21SZXBlYXQuaXMsIERvbVJlcGVhdCk7XG5cbmV4cG9ydCB7IERvbVJlcGVhdCB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmpzJztcbmltcG9ydCB7IElyb25CdXR0b25TdGF0ZUltcGwgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJSaXBwbGVCZWhhdmlvciA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IHdpbGwgbm90IHByb2R1Y2UgYSByaXBwbGUgZWZmZWN0IHdoZW4gaW50ZXJhY3RlZFxuICAgICAqIHdpdGggdmlhIHRoZSBwb2ludGVyLlxuICAgICAqL1xuICAgIG5vaW5rOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgb2JzZXJ2ZXI6ICdfbm9pbmtDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgX3JpcHBsZUNvbnRhaW5lcjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZWxlbWVudCBpc1xuICAgKiBmb2N1c2VkLlxuICAgKi9cbiAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNlZCkge1xuICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGluIGBJcm9uQnV0dG9uU3RhdGVgLCBlbnN1cmVzXG4gICAqIGEgcmlwcGxlIGVmZmVjdCBpcyBjcmVhdGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgaW4gYSBgcHJlc3NlZGAgc3RhdGUuXG4gICAqL1xuICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgSXJvbkJ1dHRvblN0YXRlSW1wbC5fZG93bkhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgdGhpcy5lbnN1cmVSaXBwbGUoZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyB0aGlzIGVsZW1lbnQgY29udGFpbnMgYSByaXBwbGUgZWZmZWN0LiBGb3Igc3RhcnR1cCBlZmZpY2llbmN5XG4gICAqIHRoZSByaXBwbGUgZWZmZWN0IGlzIGR5bmFtaWNhbGx5IG9uIGRlbWFuZCB3aGVuIG5lZWRlZC5cbiAgICogQHBhcmFtIHshRXZlbnQ9fSBvcHRUcmlnZ2VyaW5nRXZlbnQgKG9wdGlvbmFsKSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAgICogcmlwcGxlLlxuICAgKi9cbiAgZW5zdXJlUmlwcGxlOiBmdW5jdGlvbihvcHRUcmlnZ2VyaW5nRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIHRoaXMuX3JpcHBsZSA9IHRoaXMuX2NyZWF0ZVJpcHBsZSgpO1xuICAgICAgdGhpcy5fcmlwcGxlLm5vaW5rID0gdGhpcy5ub2luaztcbiAgICAgIHZhciByaXBwbGVDb250YWluZXIgPSB0aGlzLl9yaXBwbGVDb250YWluZXIgfHwgdGhpcy5yb290O1xuICAgICAgaWYgKHJpcHBsZUNvbnRhaW5lcikge1xuICAgICAgICBkb20ocmlwcGxlQ29udGFpbmVyKS5hcHBlbmRDaGlsZCh0aGlzLl9yaXBwbGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSByaXBwbGUgY29udGFpbmVyXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBob3N0IGluc3RlYWQgb2YgdGhlIHJvb3QgYmVjYXVzZSBkaXN0cmlidXRlZCB0ZXh0XG4gICAgICAgIC8vIG5vZGVzIGFyZSBub3QgdmFsaWQgZXZlbnQgdGFyZ2V0c1xuICAgICAgICB2YXIgZG9tQ29udGFpbmVyID0gZG9tKHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IGRvbShvcHRUcmlnZ2VyaW5nRXZlbnQpLnJvb3RUYXJnZXQ7XG4gICAgICAgIGlmIChkb21Db250YWluZXIuZGVlcENvbnRhaW5zKCAvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKSB7XG4gICAgICAgICAgdGhpcy5fcmlwcGxlLnVpRG93bkFjdGlvbihvcHRUcmlnZ2VyaW5nRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQgdXNlZCBieSB0aGlzIGVsZW1lbnQgdG8gY3JlYXRlXG4gICAqIHJpcHBsZSBlZmZlY3RzLiBUaGUgZWxlbWVudCdzIHJpcHBsZSBpcyBjcmVhdGVkIG9uIGRlbWFuZCwgd2hlblxuICAgKiBuZWNlc3NhcnksIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgZm9yY2UgdGhlXG4gICAqIHJpcHBsZSB0byBiZSBjcmVhdGVkLlxuICAgKi9cbiAgZ2V0UmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgIHJldHVybiB0aGlzLl9yaXBwbGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGVsZW1lbnQgY3VycmVudGx5IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1JpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fcmlwcGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBlbGVtZW50J3MgcmlwcGxlIGVmZmVjdCB2aWEgY3JlYXRpbmcgYSBgPHBhcGVyLXJpcHBsZT5gLlxuICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjdXN0b21pemUgdGhlIHJpcHBsZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshUGFwZXJSaXBwbGVFbGVtZW50fSBSZXR1cm5zIGEgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50LlxuICAgKi9cbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IVBhcGVyUmlwcGxlRWxlbWVudH0gKi8gKFxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1yaXBwbGUnKSk7XG4gIH0sXG5cbiAgX25vaW5rQ2hhbmdlZDogZnVuY3Rpb24obm9pbmspIHtcbiAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgdGhpcy5fcmlwcGxlLm5vaW5rID0gbm9pbms7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllciwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnZva2UobWV0aG9kTmFtZTogU3RyaW5nLCDigKYpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYG1ldGhvZE5hbWVgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIGFueVxyXG5cdC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVycy4gSGFzIG5vIGVmZmVjdCBpZiB0aGUgbGF5ZXJzIGNvbnRhaW5lZCBkbyBub3RcclxuXHQvLyBpbXBsZW1lbnQgYG1ldGhvZE5hbWVgLlxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihsYXllcnMucHVzaCwgbGF5ZXJzKTtcclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgbGF5ZXIgZ3JvdXAsIG9wdGlvbmFsbHkgZ2l2ZW4gYW4gaW5pdGlhbCBzZXQgb2YgbGF5ZXJzIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgdmFyIGxheWVyR3JvdXAgPSBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllckdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXJHcm91cC5qcyIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcmRpbmF0ZV9yZWZlcmVuY2Vfc3lzdGVtKS5cclxuICpcclxuICogTGVhZmxldCBkZWZpbmVzIHRoZSBtb3N0IHVzdWFsIENSU3MgYnkgZGVmYXVsdC4gSWYgeW91IHdhbnQgdG8gdXNlIGFcclxuICogQ1JTIG5vdCBkZWZpbmVkIGJ5IGRlZmF1bHQsIHRha2UgYSBsb29rIGF0IHRoZVxyXG4gKiBbUHJvajRMZWFmbGV0XShodHRwczovL2dpdGh1Yi5jb20va2FydGVuYS9Qcm9qNExlYWZsZXQpIHBsdWdpbi5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBDUlMgaW5zdGFuY2VzIGRvIG5vdCBpbmhlcml0IGZyb20gTGVhZmV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxyXG4gKiBhbmQgbWV0aG9kcyBjYW4ndCBiZSBhZGRlZCB0byB0aGVtIHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIENSUyA9IHtcclxuXHQvLyBAbWV0aG9kIGxhdExuZ1RvUG9pbnQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgZ2l2ZW4gem9vbS5cclxuXHRsYXRMbmdUb1BvaW50OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpLFxyXG5cdFx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKHByb2plY3RlZFBvaW50LCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYGxhdExuZ1RvUG9pbnRgLiBQcm9qZWN0cyBwaXhlbCBjb29yZGluYXRlcyBvbiBhIGdpdmVuXHJcblx0Ly8gem9vbSBpbnRvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHRwb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwcm9qZWN0KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBjb29yZGluYXRlcyBpbiB1bml0cyBhY2NlcHRlZCBmb3JcclxuXHQvLyB0aGlzIENSUyAoZS5nLiBtZXRlcnMgZm9yIEVQU0c6Mzg1NywgZm9yIHBhc3NpbmcgaXQgdG8gV01TIHNlcnZpY2VzKS5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVucHJvamVjdChwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHByb2plY3RlZCBjb29yZGluYXRlIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgTGF0TG5nLlxyXG5cdC8vIFRoZSBpbnZlcnNlIG9mIGBwcm9qZWN0YC5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QocG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGUoem9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgdXNlZCB3aGVuIHRyYW5zZm9ybWluZyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgaW50b1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGVzIGZvciBhIHBhcnRpY3VsYXIgem9vbS4gRm9yIGV4YW1wbGUsIGl0IHJldHVybnNcclxuXHQvLyBgMjU2ICogMl56b29tYCBmb3IgTWVyY2F0b3ItYmFzZWQgQ1JTLlxyXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0cmV0dXJuIDI1NiAqIE1hdGgucG93KDIsIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbShzY2FsZTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGUoKWAsIHJldHVybnMgdGhlIHpvb20gbGV2ZWwgY29ycmVzcG9uZGluZyB0byBhIHNjYWxlXHJcblx0Ly8gZmFjdG9yIG9mIGBzY2FsZWAuXHJcblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5MTjI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQcm9qZWN0ZWRCb3VuZHMoem9vbTogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGlvbidzIGJvdW5kcyBzY2FsZWQgYW5kIHRyYW5zZm9ybWVkIGZvciB0aGUgcHJvdmlkZWQgYHpvb21gLlxyXG5cdGdldFByb2plY3RlZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG5cdFx0dmFyIGIgPSB0aGlzLnByb2plY3Rpb24uYm91bmRzLFxyXG5cdFx0ICAgIHMgPSB0aGlzLnNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG1pbiA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWluLCBzKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShiLm1heCwgcyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxuZywgdGhpcy53cmFwTG5nLCB0cnVlKSA6IGxhdGxuZy5sbmcsXHJcblx0XHQgICAgbGF0ID0gdGhpcy53cmFwTGF0ID8gVXRpbC53cmFwTnVtKGxhdGxuZy5sYXQsIHRoaXMud3JhcExhdCwgdHJ1ZSkgOiBsYXRsbmcubGF0LFxyXG5cdFx0ICAgIGFsdCA9IGxhdGxuZy5hbHQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcobGF0LCBsbmcsIGFsdCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZ1xyXG5cdC8vIHRoYXQgaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLkxhdExuZ0JvdW5kc2AgaW5zdGFuY2VzLCBub3QgYXJyYXlzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy53cmFwTGF0TG5nKGNlbnRlciksXHJcblx0XHQgICAgbGF0U2hpZnQgPSBjZW50ZXIubGF0IC0gbmV3Q2VudGVyLmxhdCxcclxuXHRcdCAgICBsbmdTaGlmdCA9IGNlbnRlci5sbmcgLSBuZXdDZW50ZXIubG5nO1xyXG5cclxuXHRcdGlmIChsYXRTaGlmdCA9PT0gMCAmJiBsbmdTaGlmdCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHRcdCAgICBuZXdTdyA9IG5ldyBMYXRMbmcoc3cubGF0IC0gbGF0U2hpZnQsIHN3LmxuZyAtIGxuZ1NoaWZ0KSxcclxuXHRcdCAgICBuZXdOZSA9IG5ldyBMYXRMbmcobmUubGF0IC0gbGF0U2hpZnQsIG5lLmxuZyAtIGxuZ1NoaWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhuZXdTdywgbmV3TmUpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcclxuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcgYXMgbGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyRHJhZ30gZnJvbSAnLi9NYXJrZXIuRHJhZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTWFya2VyXHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuTWFya2VyXHJcbiAqIEwuTWFya2VyIGlzIHVzZWQgdG8gZGlzcGxheSBjbGlja2FibGUvZHJhZ2dhYmxlIGljb25zIG9uIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5tYXJrZXIoWzUwLjUsIDMwLjVdKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1hcmtlciA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuXHRcdC8vIEljb24gaW5zdGFuY2UgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci5cclxuXHRcdC8vIFNlZSBbSWNvbiBkb2N1bWVudGF0aW9uXSgjTC5JY29uKSBmb3IgZGV0YWlscyBvbiBob3cgdG8gY3VzdG9taXplIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQsIGEgY29tbW9uIGluc3RhbmNlIG9mIGBMLkljb24uRGVmYXVsdGAgaXMgdXNlZC5cclxuXHRcdGljb246IG5ldyBJY29uRGVmYXVsdCgpLFxyXG5cclxuXHRcdC8vIE9wdGlvbiBpbmhlcml0ZWQgZnJvbSBcIkludGVyYWN0aXZlIGxheWVyXCIgYWJzdHJhY3QgY2xhc3NcclxuXHRcdGludGVyYWN0aXZlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZHJhZ2dhYmxlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgd2l0aCBtb3VzZS90b3VjaCBvciBub3QuXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRoZSBtYXAgdG8gZG8gcGFubmluZyBhbmltYXRpb24gd2hlbiBtYXJrZXIgaGl0cyB0aGUgZWRnZXMuXHJcblx0XHRhdXRvUGFuOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW5QYWRkaW5nOiBQb2ludCA9IFBvaW50KDUwLCA1MClcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBtb3ZlIGJ5LlxyXG5cdFx0YXV0b1BhblNwZWVkOiAxMCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBidWJibGluZ01vdXNlRXZlbnRzOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZW4gYHRydWVgLCBhIG1vdXNlIGV2ZW50IG9uIHRoaXMgbWFya2VyIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXHJcblx0XHQvLyAodW5sZXNzIFtgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb25gXSgjZG9tZXZlbnQtc3RvcHByb3BhZ2F0aW9uKSBpcyB1c2VkKS5cclxuXHRcdGJ1YmJsaW5nTW91c2VFdmVudHM6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24gJiYgdGhpcy5fbWFwKSB7XHJcblx0XHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZykucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fc2V0UG9zKHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gJ2xlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHQgICAgYWRkSWNvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmIHdlJ3JlIG5vdCByZXVzaW5nIHRoZSBpY29uLCByZW1vdmUgdGhlIG9sZCBvbmUgYW5kIGluaXQgbmV3IG9uZVxyXG5cdFx0aWYgKGljb24gIT09IHRoaXMuX2ljb24pIHtcclxuXHRcdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YWRkSWNvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy50aXRsZSkge1xyXG5cdFx0XHRcdGljb24udGl0bGUgPSBvcHRpb25zLnRpdGxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaWNvbi50YWdOYW1lID09PSAnSU1HJykge1xyXG5cdFx0XHRcdGljb24uYWx0ID0gb3B0aW9ucy5hbHQgfHwgJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sIGNsYXNzVG9BZGQpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmtleWJvYXJkKSB7XHJcblx0XHRcdGljb24udGFiSW5kZXggPSAnMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHQgICAgYWRkU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdyAhPT0gdGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdFx0XHRhZGRTaGFkb3cgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0XHRuZXdTaGFkb3cuYWx0ID0gJyc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBuZXdTaGFkb3c7XHJcblxyXG5cclxuXHRcdGlmIChvcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9pbml0SW50ZXJhY3Rpb24oKTtcclxuXHRcdGlmIChuZXdTaGFkb3cgJiYgYWRkU2hhZG93KSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgnc2hhZG93UGFuZScpLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vZmYoe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfc2V0UG9zOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb29sdGlwQW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy50b29sdGlwQW5jaG9yO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gbWFya2VyKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvTWFya2VyLmpzIiwiaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuLi9jb3JlL0V2ZW50cyc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG52YXIgRU5EID0ge1xyXG5cdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaGVuZCcsXHJcblx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG59O1xyXG52YXIgTU9WRSA9IHtcclxuXHRtb3VzZWRvd246ICdtb3VzZW1vdmUnLFxyXG5cdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRNU1BvaW50ZXJEb3duOiAndG91Y2htb3ZlJ1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvblxyXG5cdFx0Ly8gQGFrYSBEcmFnZ2FibGUgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjbGlja1RvbGVyYW5jZTogTnVtYmVyID0gM1xyXG5cdFx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgY2xpY2tcclxuXHRcdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgY2xpY2sgKGFzIG9wcG9zZWQgdG8gYSBtb3VzZSBkcmFnKS5cclxuXHRcdGNsaWNrVG9sZXJhbmNlOiAzXHJcblx0fSxcclxuXHJcblx0Ly8gQGNvbnN0cnVjdG9yIEwuRHJhZ2dhYmxlKGVsOiBIVE1MRWxlbWVudCwgZHJhZ0hhbmRsZT86IEhUTUxFbGVtZW50LCBwcmV2ZW50T3V0bGluZT86IEJvb2xlYW4sIG9wdGlvbnM/OiBEcmFnZ2FibGUgb3B0aW9ucylcclxuXHQvLyBDcmVhdGVzIGEgYERyYWdnYWJsZWAgb2JqZWN0IGZvciBtb3ZpbmcgYGVsYCB3aGVuIHlvdSBzdGFydCBkcmFnZ2luZyB0aGUgYGRyYWdIYW5kbGVgIGVsZW1lbnQgKGVxdWFscyBgZWxgIGl0c2VsZiBieSBkZWZhdWx0KS5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZWxlbWVudCwgZHJhZ1N0YXJ0VGFyZ2V0LCBwcmV2ZW50T3V0bGluZSwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0ID0gZHJhZ1N0YXJ0VGFyZ2V0IHx8IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9wcmV2ZW50T3V0bGluZSA9IHByZXZlbnRPdXRsaW5lO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZW5hYmxlKClcclxuXHQvLyBFbmFibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIFNUQVJULCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzYWJsZSgpXHJcblx0Ly8gRGlzYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gSWYgd2UncmUgY3VycmVudGx5IGRyYWdnaW5nIHRoaXMgZHJhZ2dhYmxlLFxyXG5cdFx0Ly8gZGlzYWJsaW5nIGl0IGNvdW50cyBhcyBmaXJzdCBlbmRpbmcgdGhlIGRyYWcuXHJcblx0XHRpZiAoRHJhZ2dhYmxlLl9kcmFnZ2luZyA9PT0gdGhpcykge1xyXG5cdFx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKERvbVV0aWwuaGFzQ2xhc3ModGhpcy5fZWxlbWVudCwgJ2xlYWZsZXQtem9vbS1hbmltJykpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKERyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykpIHsgcmV0dXJuOyB9XHJcblx0XHREcmFnZ2FibGUuX2RyYWdnaW5nID0gdGhpczsgIC8vIFByZXZlbnQgZHJhZ2dpbmcgbXVsdGlwbGUgb2JqZWN0cyBhdCBvbmNlLlxyXG5cclxuXHRcdGlmICh0aGlzLl9wcmV2ZW50T3V0bGluZSkge1xyXG5cdFx0XHREb21VdGlsLnByZXZlbnRPdXRsaW5lKHRoaXMuX2VsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRvd246IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBpcyBhYm91dCB0byBzdGFydC5cclxuXHRcdHRoaXMuZmlyZSgnZG93bicpO1xyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHJcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgTU9WRVtlLnR5cGVdLCB0aGlzLl9vbk1vdmUsIHRoaXMpO1xyXG5cdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsIEVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG5ld1BvaW50ID0gbmV3IFBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ld1BvaW50LnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKE1hdGguYWJzKG9mZnNldC54KSArIE1hdGguYWJzKG9mZnNldC55KSA8IHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7XHJcblx0XHRcdC8vIEBldmVudCBkcmFnc3RhcnQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKCh3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlKSAmJiAodGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSkpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVQb3NpdGlvbiwgdGhpcywgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZSA9IHtvcmlnaW5hbEV2ZW50OiB0aGlzLl9sYXN0RXZlbnR9O1xyXG5cclxuXHRcdC8vIEBldmVudCBwcmVkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZyAqYmVmb3JlKiBlYWNoIGNvcnJlc3BvbmRpbmdcclxuXHRcdC8vIHVwZGF0ZSBvZiB0aGUgZWxlbWVudCdzIHBvc2l0aW9uLlxyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJywgZSk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuX25ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nLlxyXG5cdFx0dGhpcy5maXJlKCdkcmFnJywgZSk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgc2ltdWxhdGVkIGV2ZW50cywgc2luY2Ugd2UgaGFuZGxlIGJvdGggdG91Y2ggYW5kXHJcblx0XHQvLyBtb3VzZSBleHBsaWNpdGx5OyBvdGhlcndpc2Ugd2UgcmlzayBnZXR0aW5nIGR1cGxpY2F0ZXMgb2ZcclxuXHRcdC8vIHRvdWNoIGV2ZW50cywgc2VlICM0MzE1LlxyXG5cdFx0Ly8gQWxzbyBpZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoZS5fc2ltdWxhdGVkIHx8ICF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0fSxcclxuXHJcblx0ZmluaXNoRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0VGFyZ2V0KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBNT1ZFKSB7XHJcblx0XHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgTU9WRVtpXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCBFTkRbaV0sIHRoaXMuX29uVXAsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHJcblx0XHRcdC8vIEBldmVudCBkcmFnZW5kOiBEcmFnRW5kRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZHJhZyBlbmRzLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdlbmQnLCB7XHJcblx0XHRcdFx0ZGlzdGFuY2U6IHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdERyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcblxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRHJhZ2dhYmxlLmpzIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHA6Ly93d3cubGliLnV0ZXhhcy5lZHUvbWFwcy9oaXN0b3JpY2FsL25ld2Fya19ual8xOTIyLmpwZycsXHJcbiAqIFx0aW1hZ2VCb3VuZHMgPSBbWzQwLjcxMjIxNiwgLTc0LjIyNjU1XSwgWzQwLjc3Mzk0MSwgLTc0LjEyNTQ0XV07XHJcbiAqIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBpbWFnZUJvdW5kcykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBJbWFnZU92ZXJsYXkgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgSW1hZ2VPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxyXG5cdFx0Ly8gVGhlIG9wYWNpdHkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaW1hZ2UgKHVzZWZ1bCBmb3IgYWNjZXNzaWJpbGl0eSkuXHJcblx0XHRhbHQ6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgaW1hZ2Ugb3ZlcmxheSB3aWxsIGVtaXQgW21vdXNlIGV2ZW50c10oI2ludGVyYWN0aXZlLWxheWVyKSB3aGVuIGNsaWNrZWQgb3IgaG92ZXJlZC5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gJycuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZXJyb3JPdmVybGF5VXJsOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVVJMIHRvIHRoZSBvdmVybGF5IGltYWdlIHRvIHNob3cgaW4gcGxhY2Ugb2YgdGhlIG92ZXJsYXkgdGhhdCBmYWlsZWQgdG8gbG9hZC5cclxuXHRcdGVycm9yT3ZlcmxheVVybDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcclxuXHRcdC8vIFRoZSBleHBsaWNpdCBbekluZGV4XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleCkgb2YgdGhlIHRpbGUgbGF5ZXIuXHJcblx0XHR6SW5kZXg6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgaW1hZ2UuIEVtcHR5IGJ5IGRlZmF1bHQuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Q6IHNldFpJbmRleCh2YWx1ZTogTnVtYmVyKSA6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjaW1hZ2VvdmVybGF5LXppbmRleCkgb2YgdGhlIGltYWdlIG92ZXJsYXkuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB2YWx1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gR2V0IHRoZSBib3VuZHMgdGhhdCB0aGlzIEltYWdlT3ZlcmxheSBjb3ZlcnNcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgW2BIVE1MSW1hZ2VFbGVtZW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQpXHJcblx0Ly8gdXNlZCBieSB0aGlzIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB3YXNFbGVtZW50U3VwcGxpZWQgPSB0aGlzLl91cmwudGFnTmFtZSA9PT0gJ0lNRyc7XHJcblx0XHR2YXIgaW1nID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgnaW1nJyk7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhpbWcsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7IERvbVV0aWwuYWRkQ2xhc3MoaW1nLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxyXG5cclxuXHRcdGltZy5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0aW1nLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgSW1hZ2VPdmVybGF5IGxheWVyIGhhcyBsb2FkZWQgaXRzIGltYWdlXHJcblx0XHRpbWcub25sb2FkID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHRcdGltZy5vbmVycm9yID0gVXRpbC5iaW5kKHRoaXMuX292ZXJsYXlPbkVycm9yLCB0aGlzLCAnZXJyb3InKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgaGFzIGxvYWRlZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAZmFjdG9yeSBMLmltYWdlT3ZlcmxheShpbWFnZVVybDogU3RyaW5nLCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IEltYWdlT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgaW1hZ2UgYW5kIHRoZVxyXG4vLyBnZW9ncmFwaGljYWwgYm91bmRzIGl0IGlzIHRpZWQgdG8uXHJcbmV4cG9ydCB2YXIgaW1hZ2VPdmVybGF5ID0gZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRGl2T3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICogQGFrYSBMLkRpdk92ZXJsYXlcclxuICogQmFzZSBtb2RlbCBmb3IgTC5Qb3B1cCBhbmQgTC5Ub29sdGlwLiBJbmhlcml0IGZyb20gaXQgZm9yIGN1c3RvbSBwb3B1cCBsaWtlIHBsdWdpbnMuXHJcbiAqL1xyXG5cclxuLy8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcbmV4cG9ydCB2YXIgRGl2T3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBEaXZPdmVybGF5IG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uIFVzZWZ1bCB0byBjb250cm9sIHRoZSBhbmNob3JcclxuXHRcdC8vIG9mIHRoZSBwb3B1cCB3aGVuIG9wZW5pbmcgaXQgb24gc29tZSBvdmVybGF5cy5cclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAncG9wdXBQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdwb3B1cFBhbmUnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gbWFwLl96b29tQW5pbWF0ZWQ7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXAuX2ZhZGVBbmltYXRlZCkge1xyXG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5icmluZ1RvRnJvbnQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoRG9tVXRpbC5yZW1vdmUsIHVuZGVmaW5lZCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgcG9pbnQgb2YgcG9wdXAuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBvcGVuLlxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHRcdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwLlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgcG9wdXAuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBTdHJpbmdgIG9yIGBIVE1MRWxlbWVudGAgdG8gYmUgdXNlZCBpbiB0aGUgcG9wdXAuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gQWxpYXMgZm9yIFtnZXRDb250ZW50KCldKCNwb3B1cC1nZXRjb250ZW50KVxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1cGRhdGU6IG51bGxcclxuXHQvLyBVcGRhdGVzIHRoZSBwb3B1cCBjb250ZW50LCBsYXlvdXQgYW5kIHBvc2l0aW9uLiBVc2VmdWwgZm9yIHVwZGF0aW5nIHRoZSBwb3B1cCBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgcG9wdXAgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLlxyXG5cdGlzT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICEhdGhpcy5fbWFwICYmIHRoaXMuX21hcC5oYXNMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGlzIHBvcHVwIGluIGZyb250IG9mIG90aGVyIHBvcHVwcyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBwb3B1cCB0byB0aGUgYmFjayBvZiBvdGhlciBwb3B1cHMgKGluIHRoZSBzYW1lIG1hcCBwYW5lKS5cclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0LmFkZChwb3MpLmFkZChhbmNob3IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnksXHJcblx0XHQgICAgbGVmdCA9IHRoaXMuX2NvbnRhaW5lckxlZnQgPSAtTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aCAvIDIpICsgb2Zmc2V0Lng7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0Rpdk92ZXJsYXkuanMiLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nP3tmb299Jywge2ZvbzogJ2Jhcid9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogQHNlY3Rpb24gVVJMIHRlbXBsYXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIEEgc3RyaW5nIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcclxuICpcclxuICogYGBgXHJcbiAqICdodHRwOi8ve3N9LnNvbWVkb21haW4uY29tL2JsYWJsYS97en0ve3h9L3t5fXtyfS5wbmcnXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBge3N9YCBtZWFucyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBzdWJkb21haW5zICh1c2VkIHNlcXVlbnRpYWxseSB0byBoZWxwIHdpdGggYnJvd3NlciBwYXJhbGxlbCByZXF1ZXN0cyBwZXIgZG9tYWluIGxpbWl0YXRpb247IHN1YmRvbWFpbiB2YWx1ZXMgYXJlIHNwZWNpZmllZCBpbiBvcHRpb25zOyBgYWAsIGBiYCBvciBgY2AgYnkgZGVmYXVsdCwgY2FuIGJlIG9taXR0ZWQpLCBge3p9YCDigJQgem9vbSBsZXZlbCwgYHt4fWAgYW5kIGB7eX1gIOKAlCB0aWxlIGNvb3JkaW5hdGVzLiBge3J9YCBjYW4gYmUgdXNlZCB0byBhZGQgXCImY29tbWF0OzJ4XCIgdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIGFsbCB0aWxlcyB3aWxsIGhhdmUgdGhlaXIgY3Jvc3NPcmlnaW4gYXR0cmlidXRlIHNldCB0byAnJy4gVGhpcyBpcyBuZWVkZWQgaWYgeW91IHdhbnQgdG8gYWNjZXNzIHRpbGUgcGl4ZWwgZGF0YS5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsLCBub1JlZHJhdykge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBvdmVycmlkZXMgR3JpZExheWVyJ3MgW2BjcmVhdGVUaWxlKClgXSgjZ3JpZGxheWVyLWNyZWF0ZXRpbGUpXHJcblx0Ly8gdG8gcmV0dXJuIGFuIGA8aW1nPmAgSFRNTCBlbGVtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGltYWdlIFVSTCBnaXZlbiBgY29vcmRzYC4gVGhlIGBkb25lYFxyXG5cdC8vIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBiZWVuIGxvYWRlZC5cclxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBkb25lKSB7XHJcblx0XHR2YXIgdGlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdsb2FkJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHRcdERvbUV2ZW50Lm9uKHRpbGUsICdlcnJvcicsIFV0aWwuYmluZCh0aGlzLl90aWxlT25FcnJvciwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcclxuXHRcdFx0dGlsZS5jcm9zc09yaWdpbiA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qXHJcblx0XHQgQWx0IHRhZyBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIHRvIGtlZXAgc2NyZWVuIHJlYWRlcnMgZnJvbSByZWFkaW5nIFVSTCBhbmQgZm9yIGNvbXBsaWFuY2UgcmVhc29uc1xyXG5cdFx0IGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9INjdcclxuXHRcdCovXHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgU2V0IHJvbGU9XCJwcmVzZW50YXRpb25cIiB0byBmb3JjZSBzY3JlZW4gcmVhZGVycyB0byBpZ25vcmUgdGhpc1xyXG5cdFx0IGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS9yb2xlcyN0ZXh0YWx0ZXJuYXRpdmVjb21wdXRhdGlvblxyXG5cdFx0Ki9cclxuXHRcdHRpbGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBVdGlsLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBVdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aWxlKTtcclxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl90aWxlc1tpXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwudGlsZWxheWVyKHVybFRlbXBsYXRlOiBTdHJpbmcsIG9wdGlvbnM/OiBUaWxlTGF5ZXIgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBgVVJMIHRlbXBsYXRlYCBhbmQgb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXIodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXIodXJsLCBvcHRpb25zKTtcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3JldGluYX0gZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi4vLi4vZ2VvL2Nycy9DUlMuRVBTRzQzMjYnO1xyXG5pbXBvcnQge3RvQm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXJXTVMgPSBUaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIHJldGluYSA/IDIgOiAxO1xyXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gdGlsZVNpemUueCAqIHJlYWxSZXRpbmE7XHJcblx0XHR3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUueSAqIHJlYWxSZXRpbmE7XHJcblxyXG5cdFx0dGhpcy53bXNQYXJhbXMgPSB3bXNQYXJhbXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHRcdHRoaXMuX3dtc1ZlcnNpb24gPSBwYXJzZUZsb2F0KHRoaXMud21zUGFyYW1zLnZlcnNpb24pO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0aW9uS2V5ID0gdGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgPyAnY3JzJyA6ICdzcnMnO1xyXG5cdFx0dGhpcy53bXNQYXJhbXNbcHJvamVjdGlvbktleV0gPSB0aGlzLl9jcnMuY29kZTtcclxuXHJcblx0XHRUaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcblxyXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Od1NlKGNvb3JkcyksXHJcblx0XHQgICAgY3JzID0gdGhpcy5fY3JzLFxyXG5cdFx0ICAgIGJvdW5kcyA9IHRvQm91bmRzKGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMF0pLCBjcnMucHJvamVjdCh0aWxlQm91bmRzWzFdKSksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIGJib3ggPSAodGhpcy5fd21zVmVyc2lvbiA+PSAxLjMgJiYgdGhpcy5fY3JzID09PSBFUFNHNDMyNiA/XHJcblx0XHQgICAgW21pbi55LCBtaW4ueCwgbWF4LnksIG1heC54XSA6XHJcblx0XHQgICAgW21pbi54LCBtaW4ueSwgbWF4LngsIG1heC55XSkuam9pbignLCcpLFxyXG5cdFx0dXJsID0gTC5UaWxlTGF5ZXIucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLCBjb29yZHMpO1xyXG5cdFx0cmV0dXJuIHVybCArXHJcblx0XHRcdGdldFBhcmFtU3RyaW5nKHRoaXMud21zUGFyYW1zLCB1cmwsIHRoaXMub3B0aW9ucy51cHBlcmNhc2UpICtcclxuXHRcdFx0KHRoaXMub3B0aW9ucy51cHBlcmNhc2UgPyAnJkJCT1g9JyA6ICcmYmJveD0nKSArIGJib3g7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQYXJhbXMocGFyYW1zOiBPYmplY3QsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBNZXJnZXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBwYXJhbWV0ZXJzIGFuZCByZS1yZXF1ZXN0cyB0aWxlcyBvbiB0aGUgY3VycmVudCBzY3JlZW4gKHVubGVzcyBgbm9SZWRyYXdgIHdhcyBzZXQgdG8gdHJ1ZSkuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdGV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFRpbGVMYXllcldNUyh1cmwsIG9wdGlvbnMpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKlxyXG4gKiBMZWFmbGV0IDEuMC54IGNvbXBsaWVzIHdpdGggdGhlIFtUTVMgY29vcmRpbmF0ZSBzY2hlbWUgZm9yIEVQU0c6NDMyNl0oaHR0cHM6Ly93aWtpLm9zZ2VvLm9yZy93aWtpL1RpbGVfTWFwX1NlcnZpY2VfU3BlY2lmaWNhdGlvbiNnbG9iYWwtZ2VvZGV0aWMpLFxyXG4gKiB3aGljaCBpcyBhIGJyZWFraW5nIGNoYW5nZSBmcm9tIDAuNy54IGJlaGF2aW91ci4gIElmIHlvdSBhcmUgdXNpbmcgYSBgVGlsZUxheWVyYFxyXG4gKiB3aXRoIHRoaXMgQ1JTLCBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgdHdvIDI1NngyNTYgcGl4ZWwgdGlsZXMgY292ZXJpbmcgdGhlXHJcbiAqIHdob2xlIGVhcnRoIGF0IHpvb20gbGV2ZWwgemVybywgYW5kIHRoYXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBvcmlnaW4gaXMgKC0xODAsKzkwKSxcclxuICogb3IgKC0xODAsLTkwKSBmb3IgYFRpbGVMYXllcmBzIHdpdGggW3RoZSBgdG1zYCBvcHRpb25dKCN0aWxlbGF5ZXItdG1zKSBzZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHNDMyNiA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cdHByb2plY3Rpb246IExvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogdG9UcmFuc2Zvcm1hdGlvbigxIC8gMTgwLCAxLCAtMSAvIDE4MCwgMC41KVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHNDMyNi5qcyIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQuanMiLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9MaW5lVXRpbCc7XG5pbXBvcnQge0xhdExuZywgdG9MYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0IHtMYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWxpbmVcbiAqIEBha2EgTC5Qb2x5bGluZVxuICogQGluaGVyaXRzIFBhdGhcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHBvbHlsaW5lIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQYXRoYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0WzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0WzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0WzM0LjA0LCAtMTE4LjJdXG4gKiBdO1xuICpcbiAqIHZhciBwb2x5bGluZSA9IEwucG9seWxpbmUobGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5bGluZVxuICogbWFwLmZpdEJvdW5kcyhwb2x5bGluZS5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIGBNdWx0aVBvbHlsaW5lYCBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbWzQ1LjUxLCAtMTIyLjY4XSxcbiAqIFx0IFszNy43NywgLTEyMi40M10sXG4gKiBcdCBbMzQuMDQsIC0xMTguMl1dLFxuICogXHRbWzQwLjc4LCAtNzMuOTFdLFxuICogXHQgWzQxLjgzLCAtODcuNjJdLFxuICogXHQgWzMyLjc2LCAtOTYuNzJdXVxuICogXTtcbiAqIGBgYFxuICovXG5cblxuZXhwb3J0IHZhciBQb2x5bGluZSA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBvbHlsaW5lIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gc21vb3RoRmFjdG9yOiBOdW1iZXIgPSAxLjBcblx0XHQvLyBIb3cgbXVjaCB0byBzaW1wbGlmeSB0aGUgcG9seWxpbmUgb24gZWFjaCB6b29tIGxldmVsLiBNb3JlIG1lYW5zXG5cdFx0Ly8gYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBzbW9vdGhlciBsb29rLCBhbmQgbGVzcyBtZWFucyBtb3JlIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uLlxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxuXG5cdFx0Ly8gQG9wdGlvbiBub0NsaXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIERpc2FibGUgcG9seWxpbmUgY2xpcHBpbmcuXG5cdFx0bm9DbGlwOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmdzKCk6IExhdExuZ1tdXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50cyBpbiB0aGUgcGF0aCwgb3IgbmVzdGVkIGFycmF5cyBvZiBwb2ludHMgaW4gY2FzZSBvZiBtdWx0aS1wb2x5bGluZS5cblx0Z2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5ncyhsYXRsbmdzOiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gUmVwbGFjZXMgYWxsIHRoZSBwb2ludHMgaW4gdGhlIHBvbHlsaW5lIHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMuXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzRW1wdHkoKTogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgUG9seWxpbmUgaGFzIG5vIExhdExuZ3MuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VzdExheWVyUG9pbnQ6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcG9seWxpbmUuXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHRocm93cyBlcnJvciB3aGVuIG5vdCB5ZXQgYWRkZWQgdG8gbWFwIGFzIHRoaXMgY2VudGVyIGNhbGN1bGF0aW9uIHJlcXVpcmVzIHByb2plY3RlZCBjb29yZGluYXRlc1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKCknKTtcblx0XHR9XG5cblx0XHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sXG5cdFx0ICAgIHBvaW50cyA9IHRoaXMuX3JpbmdzWzBdLFxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0aWYgKCFsZW4pIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdC8vIHBvbHlsaW5lIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0Zm9yIChpID0gMCwgaGFsZkRpc3QgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG5cdFx0XHRoYWxmRGlzdCArPSBwb2ludHNbaV0uZGlzdGFuY2VUbyhwb2ludHNbaSArIDFdKSAvIDI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGxpbmUgaXMgc28gc21hbGwgaW4gdGhlIGN1cnJlbnQgdmlldyB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHRoZSBzYW1lIHBpeGVsLlxuXHRcdGlmIChoYWxmRGlzdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBkaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tpICsgMV07XG5cdFx0XHRzZWdEaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XG5cblx0XHRcdGlmIChkaXN0ID4gaGFsZkRpc3QpIHtcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtcblx0XHRcdFx0XHRwMi54IC0gcmF0aW8gKiAocDIueCAtIHAxLngpLFxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGFkZExhdExuZyhsYXRsbmc6IExhdExuZywgbGF0bG5ncz8gTGF0TG5nW10pOiB0aGlzXG5cdC8vIEFkZHMgYSBnaXZlbiBwb2ludCB0byB0aGUgcG9seWxpbmUuIEJ5IGRlZmF1bHQsIGFkZHMgdG8gdGhlIGZpcnN0IHJpbmcgb2Zcblx0Ly8gdGhlIHBvbHlsaW5lIGluIGNhc2Ugb2YgYSBtdWx0aS1wb2x5bGluZSwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3Npbmdcblx0Ly8gYSBzcGVjaWZpYyByaW5nIGFzIGEgTGF0TG5nIGFycmF5ICh0aGF0IHlvdSBjYW4gZWFybGllciBhY2Nlc3Mgd2l0aCBbYGdldExhdExuZ3NgXSgjcG9seWxpbmUtZ2V0bGF0bG5ncykpLlxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcblx0XHRsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9kZWZhdWx0U2hhcGUoKTtcblx0XHRsYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xuXHRcdHRoaXMuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpID8gdGhpcy5fbGF0bG5ncyA6IHRoaXMuX2xhdGxuZ3NbMF07XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgY29udmVydCBsYXRsbmdzIGlucHV0IGludG8gYWN0dWFsIExhdExuZyBpbnN0YW5jZXM7IGNhbGN1bGF0ZSBib3VuZHMgYWxvbmcgdGhlIHdheVxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdCAgICBmbGF0ID0gTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChmbGF0KSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Qm91bmRzID0gbmV3IEJvdW5kcygpO1xuXHRcdHRoaXMuX3JpbmdzID0gW107XG5cdFx0dGhpcy5fcHJvamVjdExhdGxuZ3ModGhpcy5fbGF0bG5ncywgdGhpcy5fcmluZ3MsIHB4Qm91bmRzKTtcblxuXHRcdHZhciB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0cHhCb3VuZHMubWluLl9zdWJ0cmFjdChwKTtcblx0XHRcdHB4Qm91bmRzLm1heC5fYWRkKHApO1xuXHRcdFx0dGhpcy5fcHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTGF0TG5nLFxuXHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aCxcblx0XHQgICAgaSwgcmluZztcblxuXHRcdGlmIChmbGF0KSB7XG5cdFx0XHRyaW5nID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmluZ1tpXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHByb2plY3RlZEJvdW5kcy5leHRlbmQocmluZ1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChyaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3NbaV0sIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gY2xpcCBwb2x5bGluZSBieSByZW5kZXJlciBib3VuZHMgc28gdGhhdCB3ZSBoYXZlIGxlc3MgdG8gcmVuZGVyIGZvciBwZXJmb3JtYW5jZVxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzO1xuXG5cdFx0dGhpcy5fcGFydHMgPSBbXTtcblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm5vQ2xpcCkge1xuXHRcdFx0dGhpcy5fcGFydHMgPSB0aGlzLl9yaW5ncztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgaSwgaiwgaywgbGVuLCBsZW4yLCBzZWdtZW50LCBwb2ludHM7XG5cblx0XHRmb3IgKGkgPSAwLCBrID0gMCwgbGVuID0gdGhpcy5fcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBvaW50cyA9IHRoaXMuX3JpbmdzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcG9pbnRzLmxlbmd0aDsgaiA8IGxlbjIgLSAxOyBqKyspIHtcblx0XHRcdFx0c2VnbWVudCA9IExpbmVVdGlsLmNsaXBTZWdtZW50KHBvaW50c1tqXSwgcG9pbnRzW2ogKyAxXSwgYm91bmRzLCBqLCB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIXNlZ21lbnQpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRwYXJ0c1trXSA9IHBhcnRzW2tdIHx8IFtdO1xuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMF0pO1xuXG5cdFx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcblx0XHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaiArIDFdKSB8fCAoaiA9PT0gbGVuMiAtIDIpKSB7XG5cdFx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzFdKTtcblx0XHRcdFx0XHRrKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gc2ltcGxpZnkgZWFjaCBjbGlwcGVkIHBhcnQgb2YgdGhlIHBvbHlsaW5lIGZvciBwZXJmb3JtYW5jZVxuXHRfc2ltcGxpZnlQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLl9wYXJ0cyxcblx0XHQgICAgdG9sZXJhbmNlID0gdGhpcy5vcHRpb25zLnNtb290aEZhY3RvcjtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydHNbaV0gPSBMaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHRcdHZhciBpLCBqLCBrLCBsZW4sIGxlbjIsIHBhcnQsXG5cdFx0ICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cGFydCA9IHRoaXMuX3BhcnRzW2ldO1xuXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0aWYgKExpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSkgPD0gdykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwucG9seWxpbmUobGF0bG5nczogTGF0TG5nW10sIG9wdGlvbnM/OiBQb2x5bGluZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgcG9seWxpbmUgb2JqZWN0IGdpdmVuIGFuIGFycmF5IG9mIGdlb2dyYXBoaWNhbCBwb2ludHMgYW5kXG4vLyBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBhIGBQb2x5bGluZWAgb2JqZWN0IHdpdGhcbi8vIG11bHRpcGxlIHNlcGFyYXRlIGxpbmVzIChgTXVsdGlQb2x5bGluZWApIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgYXJyYXlzXG4vLyBvZiBnZW9ncmFwaGljIHBvaW50cy5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XG59XG5cbi8vIFJldHJvY29tcGF0LiBBbGxvdyBwbHVnaW5zIHRvIHN1cHBvcnQgTGVhZmxldCB2ZXJzaW9ucyBiZWZvcmUgYW5kIGFmdGVyIDEuMS5cblBvbHlsaW5lLl9mbGF0ID0gTGluZVV0aWwuX2ZsYXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsImltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2x5VXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqICAgXSxcbiAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGosIHAxLCBwMiwgZiwgYXJlYSwgeCwgeSwgY2VudGVyLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5Z29uIGNlbnRyb2lkIGFsZ29yaXRobTsgb25seSB1c2VzIHRoZSBmaXJzdCByaW5nIGlmIHRoZXJlIGFyZSBtdWx0aXBsZVxuXG5cdFx0YXJlYSA9IHggPSB5ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG5cdFx0XHRwMSA9IHBvaW50c1tpXTtcblx0XHRcdHAyID0gcG9pbnRzW2pdO1xuXG5cdFx0XHRmID0gcDEueSAqIHAyLnggLSBwMi55ICogcDEueDtcblx0XHRcdHggKz0gKHAxLnggKyBwMi54KSAqIGY7XG5cdFx0XHR5ICs9IChwMS55ICsgcDIueSkgKiBmO1xuXHRcdFx0YXJlYSArPSBmICogMztcblx0XHR9XG5cblx0XHRpZiAoYXJlYSA9PT0gMCkge1xuXHRcdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXG5cdFx0XHRjZW50ZXIgPSBwb2ludHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhjZW50ZXIpO1xuXHR9LFxuXG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG5cdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMYXRMbmcgJiYgcmVzdWx0WzBdLmVxdWFscyhyZXN1bHRbbGVuIC0gMV0pKSB7XG5cdFx0XHRyZXN1bHQucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0UG9seWxpbmUucHJvdG90eXBlLl9zZXRMYXRMbmdzLmNhbGwodGhpcywgbGF0bG5ncyk7XG5cdFx0aWYgKExpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzKSkge1xuXHRcdFx0dGhpcy5fbGF0bG5ncyA9IFt0aGlzLl9sYXRsbmdzXTtcblx0XHR9XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcblx0fSxcblxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcblx0XHQgICAgcCA9IG5ldyBQb2ludCh3LCB3KTtcblxuXHRcdC8vIGluY3JlYXNlIGNsaXAgcGFkZGluZyBieSBzdHJva2Ugd2lkdGggdG8gYXZvaWQgc3Ryb2tlIG9uIGNsaXAgZWRnZXNcblx0XHRib3VuZHMgPSBuZXcgQm91bmRzKGJvdW5kcy5taW4uc3VidHJhY3QocCksIGJvdW5kcy5tYXguYWRkKHApKTtcblxuXHRcdHRoaXMuX3BhcnRzID0gW107XG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcblx0XHRcdHRoaXMuX3BhcnRzID0gdGhpcy5fcmluZ3M7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3JpbmdzLmxlbmd0aCwgY2xpcHBlZDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjbGlwcGVkID0gUG9seVV0aWwuY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xuXHRcdHZhciBpbnNpZGUgPSBmYWxzZSxcblx0XHQgICAgcGFydCwgcDEsIHAyLCBpLCBqLCBrLCBsZW4sIGxlbjI7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gcmF5IGNhc3RpbmcgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgaWYgcG9pbnQgaXMgaW4gcG9seWdvblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRwMSA9IHBhcnRbal07XG5cdFx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJiAocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xuXHRcdFx0XHRcdGluc2lkZSA9ICFpbnNpZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0XHRyZXR1cm4gaW5zaWRlIHx8IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xuXHR9XG5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucG9seWdvbihsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbihsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1BvbHlnb24uanMiLCJpbXBvcnQgeyByZXNvbHZlQ3NzIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5cbmNvbnN0IE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SID0gJ2xpbmtbcmVsPWltcG9ydF1bdHlwZX49Y3NzXSc7XG5jb25zdCBJTkNMVURFX0FUVFIgPSAnaW5jbHVkZSc7XG5cbmZ1bmN0aW9uIGltcG9ydE1vZHVsZShtb2R1bGVJZCkge1xuICBjb25zdCAvKiogUG9seW1lci5Eb21Nb2R1bGUgKi8gUG9seW1lckRvbU1vZHVsZSA9IGN1c3RvbUVsZW1lbnRzLmdldCgnZG9tLW1vZHVsZScpO1xuICBpZiAoIVBvbHltZXJEb21Nb2R1bGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gUG9seW1lckRvbU1vZHVsZS5pbXBvcnQobW9kdWxlSWQpO1xufVxuXG4vKiogQHR5cGVkZWYge3thc3NldHBhdGg6IHN0cmluZ319ICovXG5sZXQgdGVtcGxhdGVXaXRoQXNzZXRQYXRoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlcyhtb2R1bGVJZHMpIHtcbiAgbGV0IG1vZHVsZXMgPSBtb2R1bGVJZHMudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIGZvciAobGV0IGk9MDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjc3NUZXh0ICs9IGNzc0Zyb21Nb2R1bGUobW9kdWxlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlKG1vZHVsZUlkKSB7XG4gIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgaWYgKG0gJiYgbS5fY3NzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW9kdWxlIGltcG9ydHM6IDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5cbiAgICBsZXQgY3NzVGV4dCA9IF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtKTtcbiAgICAvLyBpbmNsdWRlIGNzcyBmcm9tIHRoZSBmaXJzdCB0ZW1wbGF0ZSBpbiB0aGUgbW9kdWxlXG4gICAgbGV0IHQgPSBtLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNzc1RleHQgKz0gY3NzRnJvbVRlbXBsYXRlKHQsIC8qKiBAdHlwZSB7dGVtcGxhdGVXaXRoQXNzZXRQYXRofSAqLyhtKS5hc3NldHBhdGgpO1xuICAgIH1cbiAgICBtLl9jc3NUZXh0ID0gY3NzVGV4dCB8fCBudWxsO1xuICB9XG4gIGlmICghbSkge1xuICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgc3R5bGUgZGF0YSBpbiBtb2R1bGUgbmFtZWQnLCBtb2R1bGVJZCk7XG4gIH1cbiAgcmV0dXJuIG0gJiYgbS5fY3NzVGV4dCB8fCAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkge1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICAvLyBpZiBlbGVtZW50IGlzIGEgdGVtcGxhdGUsIGdldCBjb250ZW50IGZyb20gaXRzIC5jb250ZW50XG4gIGxldCBlJCA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKTtcbiAgZm9yIChsZXQgaT0wOyBpIDwgZSQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZSA9IGUkW2ldO1xuICAgIC8vIHN1cHBvcnQgc3R5bGUgc2hhcmluZyBieSBhbGxvd2luZyBzdHlsZXMgdG8gXCJpbmNsdWRlXCJcbiAgICAvLyBvdGhlciBkb20tbW9kdWxlcyB0aGF0IGNvbnRhaW4gc3R5bGluZ1xuICAgIGxldCBpbmNsdWRlID0gZS5nZXRBdHRyaWJ1dGUoSU5DTFVERV9BVFRSKTtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgY3NzVGV4dCArPSBjc3NGcm9tTW9kdWxlcyhpbmNsdWRlKTtcbiAgICB9XG4gICAgZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpO1xuICAgIGNzc1RleHQgKz0gYmFzZVVSSSA/XG4gICAgICByZXNvbHZlQ3NzKGUudGV4dENvbnRlbnQsIGJhc2VVUkkpIDogZS50ZXh0Q29udGVudDtcbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21Nb2R1bGVJbXBvcnRzKG1vZHVsZUlkKSB7XG4gIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgcmV0dXJuIG0gPyBfY3NzRnJvbU1vZHVsZUltcG9ydHMobSkgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGUpIHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgbGV0IHAkID0gbW9kdWxlLnF1ZXJ5U2VsZWN0b3JBbGwoTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IpO1xuICBmb3IgKGxldCBpPTA7IGkgPCBwJC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwID0gcCRbaV07XG4gICAgaWYgKHAuaW1wb3J0KSB7XG4gICAgICBsZXQgaW1wb3J0RG9jID0gcC5pbXBvcnQ7XG4gICAgICAvLyBOT1RFOiBwb2x5ZmlsbCBhZmZvcmRhbmNlLlxuICAgICAgLy8gdW5kZXIgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsLCB0aGVyZSB3aWxsIGJlIG5vICdib2R5JyxcbiAgICAgIC8vIGJ1dCB0aGUgaW1wb3J0IHBzZXVkby1kb2MgY2FuIGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICBsZXQgY29udGFpbmVyID0gaW1wb3J0RG9jLmJvZHkgPyBpbXBvcnREb2MuYm9keSA6IGltcG9ydERvYztcbiAgICAgIGNzc1RleHQgKz1cbiAgICAgICAgcmVzb2x2ZUNzcyhjb250YWluZXIudGV4dENvbnRlbnQsXG4gICAgICAgICAgaW1wb3J0RG9jLmJhc2VVUkkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IHJlc29sdmVVcmwsIHBhdGhGcm9tVXJsIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuXG5sZXQgbW9kdWxlcyA9IHt9O1xubGV0IGxjTW9kdWxlcyA9IHt9O1xuZnVuY3Rpb24gZmluZE1vZHVsZShpZCkge1xuICByZXR1cm4gbW9kdWxlc1tpZF0gfHwgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiBzdHlsZU91dHNpZGVUZW1wbGF0ZUNoZWNrKGluc3QpIHtcbiAgaWYgKGluc3QucXVlcnlTZWxlY3Rvcignc3R5bGUnKSkge1xuICAgIGNvbnNvbGUud2FybignZG9tLW1vZHVsZSAlcyBoYXMgc3R5bGUgb3V0c2lkZSB0ZW1wbGF0ZScsIGluc3QuaWQpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGBkb20tbW9kdWxlYCBlbGVtZW50IHJlZ2lzdGVycyB0aGUgZG9tIGl0IGNvbnRhaW5zIHRvIHRoZSBuYW1lIGdpdmVuXG4gKiBieSB0aGUgbW9kdWxlJ3MgaWQgYXR0cmlidXRlLiBJdCBwcm92aWRlcyBhIHVuaWZpZWQgZGF0YWJhc2Ugb2YgZG9tXG4gKiBhY2Nlc3NpYmxlIHZpYSBpdHMgc3RhdGljIGBpbXBvcnRgIEFQSS5cbiAqXG4gKiBBIGtleSB1c2UgY2FzZSBvZiBgZG9tLW1vZHVsZWAgaXMgZm9yIHByb3ZpZGluZyBjdXN0b20gZWxlbWVudCBgPHRlbXBsYXRlPmBzXG4gKiB2aWEgSFRNTCBpbXBvcnRzIHRoYXQgYXJlIHBhcnNlZCBieSB0aGUgbmF0aXZlIEhUTUwgcGFyc2VyLCB0aGF0IGNhbiBiZVxuICogcmVsb2NhdGVkIGR1cmluZyBhIGJ1bmRsaW5nIHBhc3MgYW5kIHN0aWxsIGxvb2tlZCB1cCBieSBgaWRgLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDxkb20tbW9kdWxlIGlkPVwiZm9vXCI+XG4gKiAgICAgICA8aW1nIHNyYz1cInN0dWZmLnBuZ1wiPlxuICogICAgIDwvZG9tLW1vZHVsZT5cbiAqXG4gKiBUaGVuIGluIGNvZGUgaW4gc29tZSBvdGhlciBsb2NhdGlvbiB0aGF0IGNhbm5vdCBhY2Nlc3MgdGhlIGRvbS1tb2R1bGUgYWJvdmVcbiAqXG4gKiAgICAgbGV0IGltZyA9IGN1c3RvbUVsZW1lbnRzLmdldCgnZG9tLW1vZHVsZScpLmltcG9ydCgnZm9vJywgJ2ltZycpO1xuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgcHJvdmlkZXMgYSByZWdpc3RyeSBvZiByZWxvY2F0YWJsZSBET00gY29udGVudFxuICogICBieSBgaWRgIHRoYXQgaXMgYWdub3N0aWMgdG8gYnVuZGxpbmcuXG4gKiBAdW5yZXN0cmljdGVkXG4gKi9cbmNsYXNzIERvbU1vZHVsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnaWQnXTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBjc3MgYHNlbGVjdG9yYCBpbiB0aGUgbW9kdWxlXG4gICAqIHJlZ2lzdGVyZWQgYnkgYGlkYC4gRm9yIGV4YW1wbGUsIHRoaXMuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGRvbS1tb2R1bGUgaW4gd2hpY2ggdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdG9yIFRoZSBjc3Mgc2VsZWN0b3IgYnkgd2hpY2ggdG8gZmluZCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgZWxlbWVudCB3aGljaCBtYXRjaGVzIGBzZWxlY3RvcmAgaW4gdGhlXG4gICAqIG1vZHVsZSByZWdpc3RlcmVkIGF0IHRoZSBzcGVjaWZpZWQgYGlkYC5cbiAgICovXG4gIHN0YXRpYyBpbXBvcnQoaWQsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBsZXQgbSA9IGZpbmRNb2R1bGUoaWQpO1xuICAgICAgaWYgKG0gJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG0ucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoaXMgYGRvbS1tb2R1bGVgLlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIHdpbGwgZGlmZmVyIGZyb20gdGhpcyBlbGVtZW50J3MgYG93bmVyRG9jdW1lbnRgIGluIHRoZVxuICAgKiBmb2xsb3dpbmcgd2F5czpcbiAgICogLSBUYWtlcyBpbnRvIGFjY291bnQgYW55IGBhc3NldHBhdGhgIGF0dHJpYnV0ZSBhZGRlZCBkdXJpbmcgYnVuZGxpbmdcbiAgICogICB0byBpbmRpY2F0ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGJ1bmRsZWQgbG9jYXRpb25cbiAgICogLSBVc2VzIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbCdzIGBpbXBvcnRGb3JFbGVtZW50YCBBUEkgdG8gZW5zdXJlXG4gICAqICAgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIGltcG9ydCBkb2N1bWVudCdzIGxvY2F0aW9uIHNpbmNlXG4gICAqICAgYG93bmVyRG9jdW1lbnRgIGlzIG5vdCBjdXJyZW50bHkgcG9seWZpbGxlZFxuICAgKi9cbiAgZ2V0IGFzc2V0cGF0aCgpIHtcbiAgICAvLyBEb24ndCBvdmVycmlkZSBleGlzdGluZyBhc3NldHBhdGguXG4gICAgaWYgKCF0aGlzLl9fYXNzZXRwYXRoKSB7XG4gICAgICAvLyBub3RlOiBhc3NldHBhdGggc2V0IHZpYSBhbiBhdHRyaWJ1dGUgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGlzXG4gICAgICAvLyBlbGVtZW50J3MgbG9jYXRpb247IGFjY29tb2RhdGUgcG9seWZpbGxlZCBIVE1MSW1wb3J0c1xuICAgICAgY29uc3Qgb3duZXIgPSB3aW5kb3cuSFRNTEltcG9ydHMgJiYgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCA/XG4gICAgICAgIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQodGhpcykgfHwgZG9jdW1lbnQgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG4gICAgICBjb25zdCB1cmwgPSByZXNvbHZlVXJsKFxuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnYXNzZXRwYXRoJykgfHwgJycsIG93bmVyLmJhc2VVUkkpO1xuICAgICAgdGhpcy5fX2Fzc2V0cGF0aCA9IHBhdGhGcm9tVXJsKHVybCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fYXNzZXRwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZG9tLW1vZHVsZSBhdCBhIGdpdmVuIGlkLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAgICogd2hlbiBhIGRvbS1tb2R1bGUgaXMgaW1wZXJhdGl2ZWx5IGNyZWF0ZWQuIEZvclxuICAgKiBleGFtcGxlLCBgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZG9tLW1vZHVsZScpLnJlZ2lzdGVyKCdmb28nKWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgVGhlIGlkIGF0IHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBkb20tbW9kdWxlLlxuICAgKi9cbiAgcmVnaXN0ZXIoaWQpIHtcbiAgICBpZCA9IGlkIHx8IHRoaXMuaWQ7XG4gICAgaWYgKGlkKSB7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAvLyBzdG9yZSBpZCBzZXBhcmF0ZSBmcm9tIGxvd2VyY2FzZWQgaWQgc28gdGhhdFxuICAgICAgLy8gaW4gYWxsIGNhc2VzIG1peGVkQ2FzZSBpZCB3aWxsIHN0b3JlZCBkaXN0aW5jdGx5XG4gICAgICAvLyBhbmQgbG93ZXJjYXNlIHZlcnNpb24gaXMgYSBmYWxsYmFja1xuICAgICAgbW9kdWxlc1tpZF0gPSB0aGlzO1xuICAgICAgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldID0gdGhpcztcbiAgICAgIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2sodGhpcyk7XG4gICAgfVxuICB9XG59XG5cbkRvbU1vZHVsZS5wcm90b3R5cGVbJ21vZHVsZXMnXSA9IG1vZHVsZXM7XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLW1vZHVsZScsIERvbU1vZHVsZSk7XG5cbmV4cG9ydCB7IERvbU1vZHVsZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmpzIiwiaW1wb3J0ICcuLi8uLi8uLi8uLi9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9hcHBseS1zaGltLmpzJztcbmltcG9ydCB7IEVsZW1lbnRNaXhpbiB9IGZyb20gJy4uL21peGlucy9lbGVtZW50LW1peGluLmpzJztcbmltcG9ydCB7IEdlc3R1cmVFdmVudExpc3RlbmVycyB9IGZyb20gJy4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgaW1wb3J0SHJlZiBhcyBpbXBvcnRIcmVmJDAgfSBmcm9tICcuLi91dGlscy9pbXBvcnQtaHJlZi5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL3JlbmRlci1zdGF0dXMuanMnO1xuaW1wb3J0ICcuLi91dGlscy91bnJlc29sdmVkLmpzJztcbmltcG9ydCB7IGRvbSBhcyBkb20kMCwgbWF0Y2hlc1NlbGVjdG9yIH0gZnJvbSAnLi9wb2x5bWVyLmRvbS5qcyc7XG5pbXBvcnQgeyBzZXRUb3VjaEFjdGlvbiB9IGZyb20gJy4uL3V0aWxzL2dlc3R1cmVzLmpzJztcbmltcG9ydCB7IERlYm91bmNlciB9IGZyb20gJy4uL3V0aWxzL2RlYm91bmNlLmpzJztcbmltcG9ydCB7IHRpbWVPdXQsIG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcbmltcG9ydCB7IGdldCBhcyBnZXQkMCB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuXG5sZXQgc3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1M7XG5cbmV4cG9ydCBjb25zdCBMZWdhY3lFbGVtZW50TWl4aW4gPSBkZWR1cGluZ01peGluKChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gICAqL1xuICBjb25zdCBsZWdhY3lFbGVtZW50QmFzZSA9IEdlc3R1cmVFdmVudExpc3RlbmVycyhFbGVtZW50TWl4aW4oYmFzZSkpO1xuXG4gIC8qKlxuICAgKiBNYXAgb2Ygc2ltcGxlIG5hbWVzIHRvIHRvdWNoIGFjdGlvbiBuYW1lc1xuICAgKiBAZGljdFxuICAgKi9cbiAgY29uc3QgRElSRUNUSU9OX01BUCA9IHtcbiAgICAneCc6ICdwYW4teCcsXG4gICAgJ3knOiAncGFuLXknLFxuICAgICdub25lJzogJ25vbmUnLFxuICAgICdhbGwnOiAnYXV0bydcbiAgfTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGV4dGVuZHMge2xlZ2FjeUVsZW1lbnRCYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9MZWdhY3lFbGVtZW50TWl4aW59XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNsYXNzIExlZ2FjeUVsZW1lbnQgZXh0ZW5kcyBsZWdhY3lFbGVtZW50QmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5pc0F0dGFjaGVkO1xuICAgICAgLyoqIEB0eXBlIHtXZWFrTWFwPCFFbGVtZW50LCAhT2JqZWN0PHN0cmluZywgIUZ1bmN0aW9uPj59ICovXG4gICAgICB0aGlzLl9fYm91bmRMaXN0ZW5lcnM7XG4gICAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIEZ1bmN0aW9uPn0gKi9cbiAgICAgIHRoaXMuX2RlYm91bmNlcnM7XG4gICAgICB0aGlzLmNyZWF0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyB0aGUgYGNvbnN0cnVjdG9yYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBjcmVhdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGBjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgKiB3aGljaCBhZGRzIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRhY2hlZGAgbWV0aG9kLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLmF0dGFjaGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGNvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBhdHRhY2hlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgZGV0YWNoZWRgIG1ldGhvZC5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLmlzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGV0YWNoZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGRldGFjaGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIG92ZXJyaWRlIGltcGxlbWVudGF0aW9uIG9mIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgXG4gICAgICogd2hpY2ggYWRkcyB0aGUgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGF0dHJpYnV0ZUNoYW5nZWRgIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBhdHRyaWJ1dGVDaGFuZ2VkQ2hhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBpbXBsZW1lbnRhdGlvbiB0b1xuICAgICAqIGFkZCBzdXBwb3J0IGZvciBjbGFzcyBpbml0aWFsaXphdGlvbiB2aWEgdGhlIGBfcmVnaXN0ZXJlZGAgY2FsbGJhY2suXG4gICAgICogVGhpcyBpcyBjYWxsZWQgb25seSB3aGVuIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnX19oYXNSZWdpc3RlckZpbmlzaGVkJykpIHtcbiAgICAgICAgcHJvdG8uX19oYXNSZWdpc3RlckZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCgpO1xuICAgICAgfVxuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBlbGVtZW50IGlzIGluaXRpYWxpemluZy5cbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBjbGFzcyByZWdpc3RyYXRpb24gdGltZVxuICAgICAqIHdvcmsuIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgZW5zdXJlIHRoZSB3b3JrIGlzIHBlcmZvcm1lZFxuICAgICAqIG9ubHkgb25jZSBmb3IgdGhlIGNsYXNzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBpbXBsZW1lbnRhdGlvbiB0b1xuICAgICAqIGFkZCBzdXBwb3J0IGZvciBpbnN0YWxsaW5nIGBob3N0QXR0cmlidXRlc2AgYW5kIGBsaXN0ZW5lcnNgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICB0aGlzLl9lbnN1cmVBdHRyaWJ1dGVzKCk7XG4gICAgICB0aGlzLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGFuIGVsZW1lbnQgaGFzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICogaXMgYmVpbmcgcmVhZGllZCB2aWEgYHJlYWR5YC4gVXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRvIHNldCB0aGVcbiAgICAgKiBlbGVtZW50J3MgcmVxdWlyZWQgYXR0cmlidXRlcy4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZSBzdXJlXG4gICAgICogdG8gY2hlY2sgYW5kIG5vdCBvdmVycmlkZSBleGlzdGluZyBhdHRyaWJ1dGVzIGFkZGVkIGJ5XG4gICAgICogdGhlIHVzZXIgb2YgdGhlIGVsZW1lbnQuIFR5cGljYWxseSwgc2V0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsZWZ0XG4gICAgICogdG8gdGhlIGVsZW1lbnQgdXNlciBhbmQgbm90IGRvbmUgaGVyZTsgcmVhc29uYWJsZSBleGNlcHRpb25zIGluY2x1ZGVcbiAgICAgKiBzZXR0aW5nIGFyaWEgcm9sZXMgYW5kIGZvY3VzYWJpbGl0eS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG9cbiAgICAgKiBhZGQgYW55IHJlcXVpcmVkIGVsZW1lbnQgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEluIHBlcmZvcm1hbmNlIGNyaXRpY2FsIGVsZW1lbnRzLCB0aGUgd29yayBkb25lIGhlcmUgc2hvdWxkIGJlIGtlcHRcbiAgICAgKiB0byBhIG1pbmltdW0gc2luY2UgaXQgaXMgZG9uZSBiZWZvcmUgdGhlIGVsZW1lbnQgaXMgcmVuZGVyZWQuIEluXG4gICAgICogdGhlc2UgZWxlbWVudHMsIGNvbnNpZGVyIGFkZGluZyBsaXN0ZW5lcnMgYXN5Y2hyb25vdXNseSBzbyBhcyBub3QgdG9cbiAgICAgKiBibG9jayByZW5kZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hcHBseUxpc3RlbmVycygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLiBUbyBjdXN0b21pemVcbiAgICAgKiBob3cgcHJvcGVydGllcyBhcmUgc2VyaWFsaXplZCB0byBhdHRyaWJ1dGVzIGZvciBhdHRyaWJ1dGUgYmluZGluZ3MgYW5kXG4gICAgICogYHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZWAgcHJvcGVydGllcyBhcyB3ZWxsIGFzIHRoaXMgbWV0aG9kLCBvdmVycmlkZVxuICAgICAqIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcHJvdmlkZWQgYnkgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBkZXNlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU2VyaWFsaXplZCB2YWx1ZVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLiAgVG8gY3VzdG9taXplXG4gICAgICogaG93IGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsaXplZCB0byBwcm9wZXJ0aWVzIGZvciBpblxuICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvdmVycmlkZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZFxuICAgICAqIHByb3ZpZGVkIGJ5IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBTdHJpbmcgdG8gZGVzZXJpYWxpemVcbiAgICAgKiBAcGFyYW0geyp9IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvXG4gICAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgZGVzZXJpYWxpemVkIHZhbHVlIGluIHRoZSBgdHlwZWAgZ2l2ZW4uXG4gICAgICovXG4gICAgZGVzZXJpYWxpemUodmFsdWUsIHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgcHJvcGVydHkgdG8gaXRzIGFzc29jaWF0ZWQgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICovXG4gICAgcmVmbGVjdFByb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgKi9cbiAgICBzZXJpYWxpemVWYWx1ZVRvQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGUsIG5vZGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyksIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gcHJvcGVydGllcyAoaW5jbHVkaW5nIGFjY2Vzc29yIGRlc2NyaXB0b3JzKSBmcm9tIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFwaSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvdG90eXBlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICovXG4gICAgZXh0ZW5kKHByb3RvdHlwZSwgYXBpKSB7XG4gICAgICBpZiAoIShwcm90b3R5cGUgJiYgYXBpKSkge1xuICAgICAgICByZXR1cm4gcHJvdG90eXBlIHx8IGFwaTtcbiAgICAgIH1cbiAgICAgIGxldCBuJCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFwaSk7XG4gICAgICBmb3IgKGxldCBpPTAsIG47IChpPG4kLmxlbmd0aCkgJiYgKG49biRbaV0pOyBpKyspIHtcbiAgICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcGksIG4pO1xuICAgICAgICBpZiAocGQpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuLCBwZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm90b3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BzIGZyb20gYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoaXMgbWV0aG9kIHVzZXMgYSBzaW1wbGUgYGZvci4uLmluYCBzdHJhdGVneSBmb3IgZW51bWVyYXRpbmdcbiAgICAgKiBwcm9wZXJ0aWVzLiAgVG8gZW5zdXJlIG9ubHkgYG93blByb3BlcnRpZXNgIGFyZSBjb3BpZWQgZnJvbSBzb3VyY2VcbiAgICAgKiB0byB0YXJnZXQgYW5kIHRoYXQgYWNjZXNzb3IgaW1wbGVtZW50YXRpb25zIGFyZSBjb3BpZWQsIHVzZSBgZXh0ZW5kYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGFyZ2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICovXG4gICAgbWl4aW4odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGZvciAobGV0IGkgaW4gc291cmNlKSB7XG4gICAgICAgIHRhcmdldFtpXSA9IHNvdXJjZVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIHNldCB0aGUgcHJvdG90eXBlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIHByb3RvdHlwZSB0aGF0IHdpbGwgYmUgc2V0IG9uIHRoZSBnaXZlblxuICAgICAqIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgZ2l2ZW4gYG9iamVjdGAgd2l0aCBpdHMgcHJvdG90eXBlIHNldFxuICAgICAqIHRvIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuXG4gICAgICovXG4gICAgY2hhaW5PYmplY3Qob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgICAgIGlmIChvYmplY3QgJiYgcHJvdG90eXBlICYmIG9iamVjdCAhPT0gcHJvdG90eXBlKSB7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qICoqKiogQmVnaW4gVGVtcGxhdGUgKioqKiAqL1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYGltcG9ydE5vZGVgIG9uIHRoZSBgY29udGVudGAgb2YgdGhlIGB0ZW1wbGF0ZWAgc3BlY2lmaWVkIGFuZFxuICAgICAqIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBpbXBvcnRlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBIVE1MIHRlbXBsYXRlIGVsZW1lbnQgdG8gaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH0gRG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgaW1wb3J0ZWRcbiAgICAgKiAgIHRlbXBsYXRlIGNvbnRlbnQuXG4gICAgKi9cbiAgICBpbnN0YW5jZVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICBsZXQgY29udGVudCA9IHRoaXMuY29uc3RydWN0b3IuX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqL1xuICAgICAgICAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cblxuICAgIC8qICoqKiogQmVnaW4gRXZlbnRzICoqKiogKi9cblxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgZGV0YWlsIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgTmFtZSBvZiBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7Kj19IGRldGFpbCBEZXRhaWwgdmFsdWUgY29udGFpbmluZyBldmVudC1zcGVjaWZpY1xuICAgICAqICAgcGF5bG9hZC5cbiAgICAgKiBAcGFyYW0ge3sgYnViYmxlczogKGJvb2xlYW58dW5kZWZpbmVkKSwgY2FuY2VsYWJsZTogKGJvb2xlYW58dW5kZWZpbmVkKSwgY29tcG9zZWQ6IChib29sZWFufHVuZGVmaW5lZCkgfT19XG4gICAgICogIG9wdGlvbnMgT2JqZWN0IHNwZWNpZnlpbmcgb3B0aW9ucy4gIFRoZXNlIG1heSBpbmNsdWRlOlxuICAgICAqICBgYnViYmxlc2AgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGB0cnVlYCksXG4gICAgICogIGBjYW5jZWxhYmxlYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gZmFsc2UpLCBhbmRcbiAgICAgKiAgYG5vZGVgIG9uIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50IChIVE1MRWxlbWVudCwgZGVmYXVsdHMgdG8gYHRoaXNgKS5cbiAgICAgKiBAcmV0dXJuIHtFdmVudH0gVGhlIG5ldyBldmVudCB0aGF0IHdhcyBmaXJlZC5cbiAgICAgKi9cbiAgICBmaXJlKHR5cGUsIGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBkZXRhaWwgPSAoZGV0YWlsID09PSBudWxsIHx8IGRldGFpbCA9PT0gdW5kZWZpbmVkKSA/IHt9IDogZGV0YWlsO1xuICAgICAgbGV0IGV2ZW50ID0gbmV3IEV2ZW50KHR5cGUsIHtcbiAgICAgICAgYnViYmxlczogb3B0aW9ucy5idWJibGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBCb29sZWFuKG9wdGlvbnMuY2FuY2VsYWJsZSksXG4gICAgICAgIGNvbXBvc2VkOiBvcHRpb25zLmNvbXBvc2VkID09PSB1bmRlZmluZWQgPyB0cnVlOiBvcHRpb25zLmNvbXBvc2VkXG4gICAgICB9KTtcbiAgICAgIGV2ZW50LmRldGFpbCA9IGRldGFpbDtcbiAgICAgIGxldCBub2RlID0gb3B0aW9ucy5ub2RlIHx8IHRoaXM7XG4gICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgb24gYSBnaXZlbiBlbGVtZW50LFxuICAgICAqIGxhdGUgYm91bmQgdG8gYSBuYW1lZCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgaGFuZGxlciBtZXRob2Qgb24gYHRoaXNgIHRvIGNhbGwuXG4gICAgICovXG4gICAgbGlzdGVuKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgbGV0IGhibCA9IHRoaXMuX19ib3VuZExpc3RlbmVycyB8fFxuICAgICAgICAodGhpcy5fX2JvdW5kTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgICBsZXQgYmwgPSBoYmwuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFibCkge1xuICAgICAgICBibCA9IHt9O1xuICAgICAgICBoYmwuc2V0KG5vZGUsIGJsKTtcbiAgICAgIH1cbiAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgaWYgKCFibFtrZXldKSB7XG4gICAgICAgIGJsW2tleV0gPSB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKFxuICAgICAgICAgIG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgZ2l2ZW4gZWxlbWVudCxcbiAgICAgKiBsYXRlIGJvdW5kIHRvIGEgbmFtZWQgbWV0aG9kIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBub3QgY2FsbFxuICAgICBhbnltb3JlLlxuICAgICAqL1xuICAgIHVubGlzdGVuKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgbGV0IGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzICYmIHRoaXMuX19ib3VuZExpc3RlbmVycy5nZXQobm9kZSk7XG4gICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgIGxldCBoYW5kbGVyID0gYmwgJiYgYmxba2V5XTtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICBibFtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzY3JvbGxpbmcgYmVoYXZpb3IgdG8gYWxsIGRpcmVjdGlvbiwgb25lIGRpcmVjdGlvbiwgb3Igbm9uZS5cbiAgICAgKlxuICAgICAqIFZhbGlkIHNjcm9sbCBkaXJlY3Rpb25zOlxuICAgICAqICAgLSAnYWxsJzogc2Nyb2xsIGluIGFueSBkaXJlY3Rpb25cbiAgICAgKiAgIC0gJ3gnOiBzY3JvbGwgb25seSBpbiB0aGUgJ3gnIGRpcmVjdGlvblxuICAgICAqICAgLSAneSc6IHNjcm9sbCBvbmx5IGluIHRoZSAneScgZGlyZWN0aW9uXG4gICAgICogICAtICdub25lJzogZGlzYWJsZSBzY3JvbGxpbmcgZm9yIHRoaXMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBkaXJlY3Rpb24gRGlyZWN0aW9uIHRvIGFsbG93IHNjcm9sbGluZ1xuICAgICAqIERlZmF1bHRzIHRvIGBhbGxgLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSBzY3JvbGwgZGlyZWN0aW9uIHNldHRpbmcuXG4gICAgICogRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHNldFNjcm9sbERpcmVjdGlvbihkaXJlY3Rpb24sIG5vZGUpIHtcbiAgICAgIHNldFRvdWNoQWN0aW9uKCAobm9kZSB8fCB0aGlzKSwgRElSRUNUSU9OX01BUFtkaXJlY3Rpb25dIHx8ICdhdXRvJyk7XG4gICAgfVxuICAgIC8qICoqKiogRW5kIEV2ZW50cyAqKioqICovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcnVuIGBxdWVyeVNlbGVjdG9yYCBvbiB0aGlzIGxvY2FsIERPTSBzY29wZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYFBvbHltZXIuZG9tKHRoaXMucm9vdCkucXVlcnlTZWxlY3RvcihzbGN0cilgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNsY3RyIFNlbGVjdG9yIHRvIHJ1biBvbiB0aGlzIGxvY2FsIERPTSBzY29wZVxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IEVsZW1lbnQgZm91bmQgYnkgdGhlIHNlbGVjdG9yLCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICAkJChzbGN0cikge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNsY3RyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVsZW1lbnQgd2hvc2UgbG9jYWwgZG9tIHdpdGhpbiB3aGljaCB0aGlzIGVsZW1lbnRcbiAgICAgKiBpcyBjb250YWluZWQuIFRoaXMgaXMgYSBzaG9ydGhhbmQgZm9yXG4gICAgICogYHRoaXMuZ2V0Um9vdE5vZGUoKS5ob3N0YC5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgZG9tSG9zdCgpIHtcbiAgICAgIGxldCByb290ID0gdGhpcy5nZXRSb290Tm9kZSgpO1xuICAgICAgcmV0dXJuIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkgPyAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KS5ob3N0IDogcm9vdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSB0aGlzIGVsZW1lbnQgdG8gZGlzdHJpYnV0ZSBpdHMgY2hpbGRyZW4gdG8gaXRzIGxvY2FsIGRvbS5cbiAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IGFzIG9mIFBvbHltZXIgMi4wLjIgYW5kIGlzIHByb3ZpZGVkIG9ubHlcbiAgICAgKiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgZGlzdHJpYnV0ZUNvbnRlbnQoKSB7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRoZSBlZmZlY3RpdmUgY2hpbGROb2Rlcy4gVGhlIGVmZmVjdGl2ZVxuICAgICAqIGNoaWxkTm9kZXMgbGlzdCBpcyB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCdzIGNoaWxkTm9kZXMgZXhjZXB0IHRoYXRcbiAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWRcbiAgICAgKiB0byB0aGUgYDxjb250ZW50PmAsIHRoZSByZXN1bHQgb2YgaXRzIGBnZXREaXN0cmlidXRlZE5vZGVzYCBtZXRob2QuXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovIChkb20kMCh0aGlzKSkuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdCBtYXRjaFxuICAgICAqIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGRyZW4gb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWQgdG9cbiAgICAgKiBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgZWxlbWVudHMgdGhhdCBtYXRjaCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBxdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovIChkb20kMCh0aGlzKSkucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGFyZSB0aGUgZWZmZWN0aXZlIGNoaWxkcmVuLiBUaGUgZWZmZWN0aXZlXG4gICAgICogY2hpbGRyZW4gbGlzdCBpcyB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCdzIGNoaWxkcmVuIGV4Y2VwdCB0aGF0XG4gICAgICogYW55IGA8Y29udGVudD5gIGVsZW1lbnRzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgICogZGlzdHJpYnV0ZWQgdG8gdGhlIGA8Y29udGVudD5gLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlQ2hpbGRyZW4oKSB7XG4gICAgICBsZXQgbGlzdCA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uKC8qKiBAdHlwZSB7Tm9kZX0gKi8gbikge1xuICAgICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgdGV4dCBjb250ZW50IHRoYXQgaXMgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gICAgICogdGV4dCBjb250ZW50J3Mgb2YgdGhlIGVsZW1lbnQncyBlZmZlY3RpdmUgY2hpbGROb2RlcyAodGhlIGVsZW1lbnRzXG4gICAgICogcmV0dXJuZWQgYnkgPGEgaHJlZj1cIiNnZXRFZmZlY3RpdmVDaGlsZE5vZGVzPmdldEVmZmVjdGl2ZUNoaWxkTm9kZXM8L2E+LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZVRleHRDb250ZW50KCkge1xuICAgICAgbGV0IGNuID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICBsZXQgdGMgPSBbXTtcbiAgICAgIGZvciAobGV0IGk9MCwgYzsgKGMgPSBjbltpXSk7IGkrKykge1xuICAgICAgICBpZiAoYy5ub2RlVHlwZSAhPT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICB0Yy5wdXNoKGMudGV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGMuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZWZmZWN0aXZlIGNoaWxkTm9kZSB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgKiBtYXRjaCBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkIG5vZGVzIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkXG4gICAgICogdG8gY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAqIEByZXR1cm4ge09iamVjdDxOb2RlPn0gRmlyc3QgZWZmZWN0aXZlIGNoaWxkIG5vZGUgdGhhdCBtYXRjaGVzIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIHF1ZXJ5RWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIGxldCBlJCA9IHRoaXMucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIHJldHVybiBlJCAmJiBlJFswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlZmZlY3RpdmUgY2hpbGROb2RlcyB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgKiBtYXRjaCBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkIG5vZGVzIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkXG4gICAgICogdG8gY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmVjdGl2ZSBjaGlsZCBub2RlcyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIHF1ZXJ5QWxsRWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3MgYDxzbG90PmAuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHMgbG9jYWwgRE9NLFxuICAgICAqIGFuIG9wdGlvbmFsIHNlbGVjdG9yIG1heSBiZSBwYXNzZWQgdG8gY2hvb3NlIHRoZSBkZXNpcmVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgKiAgIGA8c2xvdD5gLiAgRGVmYXVsdHMgdG8gYGNvbnRlbnRgLlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIG5vZGVzIGZvciB0aGUgYDxzbG90PmAuXG4gICAgICovXG4gICAgZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpIHtcbiAgICAgIGxldCBjb250ZW50ID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2xjdHIgfHwgJ3Nsb3QnKTtcbiAgICAgIHJldHVybiBjb250ZW50ID8gLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8oZG9tJDAoY29udGVudCkpLmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnQgY2hpbGRyZW4gZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3NcbiAgICAgKiBgPHNsb3Q+YC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBtb3JlIHRoYW4gb25lIGA8c2xvdD5gIGluIGl0c1xuICAgICAqIGxvY2FsIERPTSwgYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgKiBjb250ZW50LiAgVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBnZXRDb250ZW50Q2hpbGROb2Rlc2AgaW4gdGhhdCBvbmx5XG4gICAgICogZWxlbWVudHMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBzbGN0ciBDU1Mgc2VsZWN0b3IgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICogICBgPGNvbnRlbnQ+YC4gIERlZmF1bHRzIHRvIGBjb250ZW50YC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZVxuICAgICAqICAgYDxzbG90PmAuXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICovXG4gICAgZ2V0Q29udGVudENoaWxkcmVuKHNsY3RyKSB7XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59ICovKHRoaXMuZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhpcyBlbGVtZW50J3MgbGlnaHQgRE9NIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBub2RlIFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAqL1xuICAgIGlzTGlnaHREZXNjZW5kYW50KG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzICE9PSBub2RlICYmIHRoaXMuY29udGFpbnMobm9kZSkgJiZcbiAgICAgICAgICB0aGlzLmdldFJvb3ROb2RlKCkgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsb2NhbCBET00gdHJlZS5cbiAgICAgKi9cbiAgICBpc0xvY2FsRGVzY2VuZGFudChub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290ID09PSBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgfVxuXG4gICAgLy8gTk9URTogc2hvdWxkIG5vdyBiZSBoYW5kbGVkIGJ5IFNoYWR5Q3NzIGxpYnJhcnkuXG4gICAgc2NvcGVTdWJ0cmVlKGNvbnRhaW5lciwgc2hvdWxkT2JzZXJ2ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIGNzcyBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgY29tcHV0ZWQgY3NzIHByb3BlcnR5IHZhbHVlIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiBgcHJvcGVydHlgLlxuICAgICAqL1xuICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZShwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHN0eWxlSW50ZXJmYWNlLmdldENvbXB1dGVkU3R5bGVWYWx1ZSh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gZGVib3VuY2VcblxuICAgIC8qKlxuICAgICAqIENhbGwgYGRlYm91bmNlYCB0byBjb2xsYXBzZSBtdWx0aXBsZSByZXF1ZXN0cyBmb3IgYSBuYW1lZCB0YXNrIGludG9cbiAgICAgKiBvbmUgaW52b2NhdGlvbiB3aGljaCBpcyBtYWRlIGFmdGVyIHRoZSB3YWl0IHRpbWUgaGFzIGVsYXBzZWQgd2l0aFxuICAgICAqIG5vIG5ldyByZXF1ZXN0LiAgSWYgbm8gd2FpdCB0aW1lIGlzIGdpdmVuLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhdCBtaWNyb3Rhc2sgdGltaW5nIChndWFyYW50ZWVkIGJlZm9yZSBwYWludCkuXG4gICAgICpcbiAgICAgKiAgICAgZGVib3VuY2VkQ2xpY2tBY3Rpb24oZSkge1xuICAgICAqICAgICAgIC8vIHdpbGwgbm90IGNhbGwgYHByb2Nlc3NDbGlja2AgbW9yZSB0aGFuIG9uY2UgcGVyIDEwMG1zXG4gICAgICogICAgICAgdGhpcy5kZWJvdW5jZSgnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgdGhpcy5wcm9jZXNzQ2xpY2soKTtcbiAgICAgKiAgICAgICB9IDEwMCk7XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFN0cmluZyB0byBpbmRlbnRpZnkgdGhlIGRlYm91bmNlIGpvYi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkICh3aXRoIGB0aGlzYFxuICAgICAqICAgY29udGV4dCkgd2hlbiB0aGUgd2FpdCB0aW1lIGVsYXBzZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgT3B0aW9uYWwgd2FpdCB0aW1lIGluIG1pbGxpc2Vjb25kcyAobXMpIGFmdGVyIHRoZVxuICAgICAqICAgbGFzdCBzaWduYWwgdGhhdCBtdXN0IGVsYXBzZSBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3Qgb24gd2hpY2ggZXhpc3RzIHRoZVxuICAgICAqIGZvbGxvd2luZyBtZXRob2RzOiBgaXNBY3RpdmUoKWAgcmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXNcbiAgICAgKiBhY3RpdmU7IGBjYW5jZWwoKWAgY2FuY2VscyB0aGUgZGVib3VuY2VyIGlmIGl0IGlzIGFjdGl2ZTtcbiAgICAgKiBgZmx1c2goKWAgaW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgZGVib3VuY2VkIGNhbGxiYWNrIGlmIHRoZSBkZWJvdW5jZXJcbiAgICAgKiBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgZGVib3VuY2Uoam9iTmFtZSwgY2FsbGJhY2ssIHdhaXQpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV0gPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdXG4gICAgICAgICAgLCB3YWl0ID4gMCA/IHRpbWVPdXQuYWZ0ZXIod2FpdCkgOiBtaWNyb1Rhc2tcbiAgICAgICAgICAsIGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBhIG5hbWVkIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZGVib3VuY2VyIGlzIGFjdGl2ZSAoaGFzIG5vdCB5ZXQgZmlyZWQpLlxuICAgICAqL1xuICAgIGlzRGVib3VuY2VyQWN0aXZlKGpvYk5hbWUpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICByZXR1cm4gISEoZGVib3VuY2VyICYmIGRlYm91bmNlci5pc0FjdGl2ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBjYWxscyB0aGUgZGVib3VuY2VyIGBjYWxsYmFja2AgYW5kIGluYWN0aXZhdGVzIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAqL1xuICAgIGZsdXNoRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICBpZiAoZGVib3VuY2VyKSB7XG4gICAgICAgIGRlYm91bmNlci5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gYWN0aXZlIGRlYm91bmNlci4gIFRoZSBgY2FsbGJhY2tgIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgKi9cbiAgICBjYW5jZWxEZWJvdW5jZXIoam9iTmFtZSkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgIGlmIChkZWJvdW5jZXIpIHtcbiAgICAgICAgZGVib3VuY2VyLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiBhc3luY3Jvbm91c2x5LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCAoaWYgbm8gd2FpdFRpbWUgaXMgc3BlY2lmaWVkKSwgYXN5bmMgY2FsbGJhY2tzIGFyZSBydW4gYXRcbiAgICAgKiBtaWNyb3Rhc2sgdGltaW5nLCB3aGljaCB3aWxsIG9jY3VyIGJlZm9yZSBwYWludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4sIGJvdW5kIHRvIGB0aGlzYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHdhaXRUaW1lIFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyB0aGVcbiAgICAgKiAgIGBjYWxsYmFja2AuICBJZiB1bnNwZWNpZmllZCBvciAwLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBydW4gYXQgbWljcm90YXNrXG4gICAgICogICB0aW1pbmcgKGJlZm9yZSBwYWludCkuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdGhhdCBtYXkgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGFzeW5jIGpvYi5cbiAgICAgKi9cbiAgICBhc3luYyhjYWxsYmFjaywgd2FpdFRpbWUpIHtcbiAgICAgIHJldHVybiB3YWl0VGltZSA+IDAgPyB0aW1lT3V0LnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpLCB3YWl0VGltZSkgOlxuICAgICAgICAgIH5taWNyb1Rhc2sucnVuKGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgd2l0aCBgYXN5bmNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBvcmlnaW5hbCBgYXN5bmNgIGNhbGwgdG9cbiAgICAgKiAgIGNhbmNlbC5cbiAgICAgKi9cbiAgICBjYW5jZWxBc3luYyhoYW5kbGUpIHtcbiAgICAgIGhhbmRsZSA8IDAgPyBtaWNyb1Rhc2suY2FuY2VsKH5oYW5kbGUpIDpcbiAgICAgICAgICB0aW1lT3V0LmNhbmNlbChoYW5kbGUpO1xuICAgIH1cblxuICAgIC8vIG90aGVyXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGVsZW1lbnQgYW5kIGNvbmZpZ3VyaW5nIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBIVE1MIGVsZW1lbnQgdGFnIHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IG9mIHByb3BlcnRpZXMgdG8gY29uZmlndXJlIG9uIHRoZVxuICAgICAqICAgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgYW5kIGNvbmZpZ3VyZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGUodGFnLCBwcm9wcykge1xuICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoZWx0LnNldFByb3BlcnRpZXMpIHtcbiAgICAgICAgICBlbHQuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgbiBpbiBwcm9wcykge1xuICAgICAgICAgICAgZWx0W25dID0gcHJvcHNbbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW1wb3J0aW5nIGFuIEhUTUwgZG9jdW1lbnQgaW1wZXJhdGl2ZWx5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBgPGxpbmsgcmVsPVwiaW1wb3J0XCI+YCBlbGVtZW50IHdpdGhcbiAgICAgKiB0aGUgcHJvdmlkZWQgVVJMIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBkb2N1bWVudCB0byBzdGFydCBsb2FkaW5nLlxuICAgICAqIEluIHRoZSBgb25sb2FkYCBjYWxsYmFjaywgdGhlIGBpbXBvcnRgIHByb3BlcnR5IG9mIHRoZSBgbGlua2BcbiAgICAgKiBlbGVtZW50IHdpbGwgY29udGFpbiB0aGUgaW1wb3J0ZWQgZG9jdW1lbnQgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiBVUkwgdG8gZG9jdW1lbnQgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0IHN1Y2Nlc3NmdWxseVxuICAgICAqICAgbG9hZGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uZXJyb3IgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0XG4gICAgICogICB1bnN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRBc3luYyBUcnVlIGlmIHRoZSBpbXBvcnQgc2hvdWxkIGJlIGxvYWRlZCBgYXN5bmNgLlxuICAgICAqICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgKiBAcmV0dXJuIHtIVE1MTGlua0VsZW1lbnR9IFRoZSBsaW5rIGVsZW1lbnQgZm9yIHRoZSBVUkwgdG8gYmUgbG9hZGVkLlxuICAgICAqL1xuICAgIGltcG9ydEhyZWYoaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBsZXQgbG9hZEZuID0gb25sb2FkID8gb25sb2FkLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgbGV0IGVycm9yRm4gPSBvbmVycm9yID8gb25lcnJvci5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgIHJldHVybiBpbXBvcnRIcmVmJDAoaHJlZiwgbG9hZEZuLCBlcnJvckZuLCBvcHRBc3luYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZm9yIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMsIHdoaWNoIGlzIHNvbWV0aW1lcyBzdGlsbFxuICAgICAqIHByZWZpeGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHRlc3QuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIHRlc3QgdGhlIHNlbGVjdG9yIGFnYWluc3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZWxlbWVudCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBlbGVtZW50TWF0Y2hlcyhzZWxlY3Rvciwgbm9kZSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXNTZWxlY3RvciggKG5vZGUgfHwgdGhpcyksIHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFuIEhUTUwgYXR0cmlidXRlIG9uIG9yIG9mZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEhUTUwgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBib29sIEJvb2xlYW4gdG8gZm9yY2UgdGhlIGF0dHJpYnV0ZSBvbiBvciBvZmYuXG4gICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIE5vZGUgdG8gdGFyZ2V0LiAgRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHRvZ2dsZUF0dHJpYnV0ZShuYW1lLCBib29sLCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgYm9vbCA9ICFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChib29sKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhIENTUyBjbGFzcyBvbiBvciBvZmYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgY2xhc3MgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgY2xhc3Mgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIE5vZGUgdG8gdGFyZ2V0LiAgRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHRvZ2dsZUNsYXNzKG5hbWUsIGJvb2wsIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBib29sID0gIW5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2Zvcm1gIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybVRleHQgVHJhbnNmb3JtIHNldHRpbmcuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICogRGVmYXVsdHMgdG8gYHRoaXNgXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybVRleHQsIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2xhdGUzZGBcbiAgICAgKiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFggb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6IFogb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHRvLlxuICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGUzZCh4LCB5LCB6LCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgnICsgeCArICcsJyArIHkgKyAnLCcgKyB6ICsgJyknLCBub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSwgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogSWYgdGhlIGFycmF5IGlzIHNwZWNpZmllZCBieSBwYXRoLCBhIGNoYW5nZSBub3RpZmljYXRpb24gaXNcbiAgICAgKiBnZW5lcmF0ZWQsIHNvIHRoYXQgb2JzZXJ2ZXJzLCBkYXRhIGJpbmRpbmdzIGFuZCBjb21wdXRlZFxuICAgICAqIHByb3BlcnRpZXMgd2F0Y2hpbmcgdGhhdCBwYXRoIGNhbiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYXJyYXkgaXMgcGFzc2VkIGRpcmVjdGx5LCAqKm5vIGNoYW5nZVxuICAgICAqIG5vdGlmaWNhdGlvbiBpcyBnZW5lcmF0ZWQqKi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PG51bWJlcnxzdHJpbmc+fSBhcnJheU9yUGF0aCBQYXRoIHRvIGFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBpdGVtXG4gICAgICogICAob3IgdGhlIGFycmF5IGl0c2VsZikuXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIGl0ZW0gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBhcnJheURlbGV0ZShhcnJheU9yUGF0aCwgaXRlbSkge1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlPclBhdGgpKSB7XG4gICAgICAgIGluZGV4ID0gYXJyYXlPclBhdGguaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlPclBhdGguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGFyciA9IGdldCQwKHRoaXMsIGFycmF5T3JQYXRoKTtcbiAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoYXJyYXlPclBhdGgsIGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gbG9nZ2luZ1xuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS5sb2dgL2B3YXJuYC9gZXJyb3JgIGFzIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxldmVsIE9uZSBvZiAnbG9nJywgJ3dhcm4nLCAnZXJyb3InXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX2xvZ2dlcihsZXZlbCwgYXJncykge1xuICAgICAgLy8gYWNjZXB0IFsnZm9vJywgJ2JhciddIGFuZCBbWydmb28nLCAnYmFyJ11dXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaChsZXZlbCkge1xuICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIGNvbnNvbGVbbGV2ZWxdKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX2xvZyguLi5hcmdzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIoJ2xvZycsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUud2FybmAgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF93YXJuKC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMuX2xvZ2dlcignd2FybicsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUuZXJyb3JgIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfZXJyb3IoLi4uYXJncykge1xuICAgICAgdGhpcy5fbG9nZ2VyKCdlcnJvcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBtZXNzYWdlIHVzaW5nIHRoZSBlbGVtZW50IHR5cGUgYW4gYSBtZXRob2QgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gZm9yIGBjb25zb2xlYFxuICAgICAqICAgbG9nZ2luZy5cbiAgICAgKi9cbiAgICBfbG9nZihtZXRob2ROYW1lLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gWydbJXM6OiVzXScsIHRoaXMuaXMsIG1ldGhvZE5hbWUsIC4uLmFyZ3NdO1xuICAgIH1cblxuICB9XG5cbiAgTGVnYWN5RWxlbWVudC5wcm90b3R5cGUuaXMgPSAnJztcblxuICByZXR1cm4gTGVnYWN5RWxlbWVudDtcblxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtuYXRpdmVTaGFkb3csIG5hdGl2ZUNzc1ZhcmlhYmxlc30gZnJvbSAnLi9zdHlsZS1zZXR0aW5ncy5qcyc7XG5pbXBvcnQge3BhcnNlLCBzdHJpbmdpZnksIHR5cGVzLCBTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHtNRURJQV9NQVRDSH0gZnJvbSAnLi9jb21tb24tcmVnZXguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFN0eWxlTm9kZX0gcnVsZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oU3R5bGVOb2RlKT19IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Nzc1RleHQgKHJ1bGVzLCBjYWxsYmFjaykge1xuICBpZiAoIXJ1bGVzKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0eXBlb2YgcnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcnVsZXMgPSBwYXJzZShydWxlcyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZm9yRWFjaFJ1bGUocnVsZXMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gc3RyaW5naWZ5KHJ1bGVzLCBuYXRpdmVDc3NWYXJpYWJsZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVzRm9yU3R5bGUoc3R5bGUpIHtcbiAgaWYgKCFzdHlsZVsnX19jc3NSdWxlcyddICYmIHN0eWxlLnRleHRDb250ZW50KSB7XG4gICAgc3R5bGVbJ19fY3NzUnVsZXMnXSA9IHBhcnNlKHN0eWxlLnRleHRDb250ZW50KTtcbiAgfVxuICByZXR1cm4gc3R5bGVbJ19fY3NzUnVsZXMnXSB8fCBudWxsO1xufVxuXG4vLyBUZXN0cyBpZiBhIHJ1bGUgaXMgYSBrZXlmcmFtZXMgc2VsZWN0b3IsIHdoaWNoIGxvb2tzIGFsbW9zdCBleGFjdGx5XG4vLyBsaWtlIGEgbm9ybWFsIHNlbGVjdG9yIGJ1dCBpcyBub3QgKGl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggc2NvcGluZ1xuLy8gZm9yIGV4YW1wbGUpLlxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5ZnJhbWVzU2VsZWN0b3IocnVsZSkge1xuICByZXR1cm4gQm9vbGVhbihydWxlWydwYXJlbnQnXSkgJiZcbiAgcnVsZVsncGFyZW50J11bJ3R5cGUnXSA9PT0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBzdHlsZVJ1bGVDYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbj19IGtleWZyYW1lc1J1bGVDYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFuPX0gb25seUFjdGl2ZVJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoUnVsZShub2RlLCBzdHlsZVJ1bGVDYWxsYmFjaywga2V5ZnJhbWVzUnVsZUNhbGxiYWNrLCBvbmx5QWN0aXZlUnVsZXMpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBza2lwUnVsZXMgPSBmYWxzZTtcbiAgbGV0IHR5cGUgPSBub2RlWyd0eXBlJ107XG4gIGlmIChvbmx5QWN0aXZlUnVsZXMpIHtcbiAgICBpZiAodHlwZSA9PT0gdHlwZXMuTUVESUFfUlVMRSkge1xuICAgICAgbGV0IG1hdGNoTWVkaWEgPSBub2RlWydzZWxlY3RvciddLm1hdGNoKE1FRElBX01BVENIKTtcbiAgICAgIGlmIChtYXRjaE1lZGlhKSB7XG4gICAgICAgIC8vIGlmIHJ1bGUgaXMgYSBub24gbWF0Y2hpbmcgQG1lZGlhIHJ1bGUsIHNraXAgc3VicnVsZXNcbiAgICAgICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShtYXRjaE1lZGlhWzFdKS5tYXRjaGVzKSB7XG4gICAgICAgICAgc2tpcFJ1bGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodHlwZSA9PT0gdHlwZXMuU1RZTEVfUlVMRSkge1xuICAgIHN0eWxlUnVsZUNhbGxiYWNrKG5vZGUpO1xuICB9IGVsc2UgaWYgKGtleWZyYW1lc1J1bGVDYWxsYmFjayAmJlxuICAgIHR5cGUgPT09IHR5cGVzLktFWUZSQU1FU19SVUxFKSB7XG4gICAga2V5ZnJhbWVzUnVsZUNhbGxiYWNrKG5vZGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IHR5cGVzLk1JWElOX1JVTEUpIHtcbiAgICBza2lwUnVsZXMgPSB0cnVlO1xuICB9XG4gIGxldCByJCA9IG5vZGVbJ3J1bGVzJ107XG4gIGlmIChyJCAmJiAhc2tpcFJ1bGVzKSB7XG4gICAgZm9yIChsZXQgaT0wLCBsPXIkLmxlbmd0aCwgcjsgKGk8bCkgJiYgKHI9ciRbaV0pOyBpKyspIHtcbiAgICAgIGZvckVhY2hSdWxlKHIsIHN0eWxlUnVsZUNhbGxiYWNrLCBrZXlmcmFtZXNSdWxlQ2FsbGJhY2ssIG9ubHlBY3RpdmVSdWxlcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIGFkZCBhIHN0cmluZyBvZiBjc3NUZXh0IHRvIHRoZSBkb2N1bWVudC5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBjb250ZXh0Tm9kZVxuICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Q3NzKGNzc1RleHQsIG1vbmlrZXIsIHRhcmdldCwgY29udGV4dE5vZGUpIHtcbiAgbGV0IHN0eWxlID0gY3JlYXRlU2NvcGVTdHlsZShjc3NUZXh0LCBtb25pa2VyKTtcbiAgYXBwbHlTdHlsZShzdHlsZSwgdGFyZ2V0LCBjb250ZXh0Tm9kZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IG1vbmlrZXJcbiAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY29wZVN0eWxlKGNzc1RleHQsIG1vbmlrZXIpIHtcbiAgbGV0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpKTtcbiAgaWYgKG1vbmlrZXIpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgbW9uaWtlcik7XG4gIH1cbiAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogVHJhY2sgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IGFkZGVkIHN0eWxlIGZvciBwbGFjaW5nIHBsYWNlaG9sZGVyc1xuICogQHR5cGUge05vZGV9XG4gKi9cbmxldCBsYXN0SGVhZEFwcGx5Tm9kZSA9IG51bGw7XG5cbi8vIGluc2VydCBhIGNvbW1lbnQgbm9kZSBhcyBhIHN0eWxpbmcgcG9zaXRpb24gcGxhY2Vob2xkZXIuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcmV0dXJuIHshQ29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGVQbGFjZUhvbGRlcihtb25pa2VyKSB7XG4gIGxldCBwbGFjZUhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJyBTaGFkeSBET00gc3R5bGVzIGZvciAnICtcbiAgICBtb25pa2VyICsgJyAnKTtcbiAgbGV0IGFmdGVyID0gbGFzdEhlYWRBcHBseU5vZGUgP1xuICAgIGxhc3RIZWFkQXBwbHlOb2RlWyduZXh0U2libGluZyddIDogbnVsbDtcbiAgbGV0IHNjb3BlID0gZG9jdW1lbnQuaGVhZDtcbiAgc2NvcGUuaW5zZXJ0QmVmb3JlKHBsYWNlSG9sZGVyLCBhZnRlciB8fCBzY29wZS5maXJzdENoaWxkKTtcbiAgbGFzdEhlYWRBcHBseU5vZGUgPSBwbGFjZUhvbGRlcjtcbiAgcmV0dXJuIHBsYWNlSG9sZGVyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEBwYXJhbSB7P05vZGV9IHRhcmdldFxuICogQHBhcmFtIHs/Tm9kZX0gY29udGV4dE5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGUoc3R5bGUsIHRhcmdldCwgY29udGV4dE5vZGUpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGRvY3VtZW50LmhlYWQ7XG4gIGxldCBhZnRlciA9IChjb250ZXh0Tm9kZSAmJiBjb250ZXh0Tm9kZS5uZXh0U2libGluZykgfHxcbiAgICB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgdGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgYWZ0ZXIpO1xuICBpZiAoIWxhc3RIZWFkQXBwbHlOb2RlKSB7XG4gICAgbGFzdEhlYWRBcHBseU5vZGUgPSBzdHlsZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvbmx5IHVwZGF0ZSBsYXN0SGVhZEFwcGx5Tm9kZSBpZiB0aGUgbmV3IHN0eWxlIGlzIGluc2VydGVkIGFmdGVyIHRoZSBvbGQgbGFzdEhlYWRBcHBseU5vZGVcbiAgICBsZXQgcG9zaXRpb24gPSBzdHlsZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihsYXN0SGVhZEFwcGx5Tm9kZSk7XG4gICAgaWYgKHBvc2l0aW9uID09PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgbGFzdEhlYWRBcHBseU5vZGUgPSBzdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVpbGRUeXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUYXJnZXRlZEJ1aWxkKGJ1aWxkVHlwZSkge1xuICByZXR1cm4gbmF0aXZlU2hhZG93ID8gYnVpbGRUeXBlID09PSAnc2hhZG93JyA6IGJ1aWxkVHlwZSA9PT0gJ3NoYWR5Jztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDc3NCdWlsZFR5cGUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Nzcy1idWlsZCcpO1xufVxuXG4vKipcbiAqIFdhbGsgZnJvbSB0ZXh0W3N0YXJ0XSBtYXRjaGluZyBwYXJlbnMgYW5kXG4gKiByZXR1cm5zIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBlbmQgcGFyZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmluZE1hdGNoaW5nUGFyZW4odGV4dCwgc3RhcnQpIHtcbiAgbGV0IGxldmVsID0gMDtcbiAgZm9yIChsZXQgaT1zdGFydCwgbD10ZXh0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh0ZXh0W2ldID09PSAnKCcpIHtcbiAgICAgIGxldmVsKys7XG4gICAgfSBlbHNlIGlmICh0ZXh0W2ldID09PSAnKScpIHtcbiAgICAgIGlmICgtLWxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcpfSBjYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2soc3RyLCBjYWxsYmFjaykge1xuICAvLyBmaW5kICd2YXIoJ1xuICBsZXQgc3RhcnQgPSBzdHIuaW5kZXhPZigndmFyKCcpO1xuICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgLy8gbm8gdmFyPywgZXZlcnl0aGluZyBpcyBwcmVmaXhcbiAgICByZXR1cm4gY2FsbGJhY2soc3RyLCAnJywgJycsICcnKTtcbiAgfVxuICAvLyR7cHJlZml4fXZhcigke2lubmVyfSkke3N1ZmZpeH1cbiAgbGV0IGVuZCA9IGZpbmRNYXRjaGluZ1BhcmVuKHN0ciwgc3RhcnQgKyAzKTtcbiAgbGV0IGlubmVyID0gc3RyLnN1YnN0cmluZyhzdGFydCArIDQsIGVuZCk7XG4gIGxldCBwcmVmaXggPSBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KTtcbiAgLy8gc3VmZml4IG1heSBoYXZlIG90aGVyIHZhcmlhYmxlc1xuICBsZXQgc3VmZml4ID0gcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2soc3RyLnN1YnN0cmluZyhlbmQgKyAxKSwgY2FsbGJhY2spO1xuICBsZXQgY29tbWEgPSBpbm5lci5pbmRleE9mKCcsJyk7XG4gIC8vIHZhbHVlIGFuZCBmYWxsYmFjayBhcmdzIHNob3VsZCBiZSB0cmltbWVkIHRvIG1hdGNoIGluIHByb3BlcnR5IGxvb2t1cFxuICBpZiAoY29tbWEgPT09IC0xKSB7XG4gICAgLy8gdmFyaWFibGUsIG5vIGZhbGxiYWNrXG4gICAgcmV0dXJuIGNhbGxiYWNrKHByZWZpeCwgaW5uZXIudHJpbSgpLCAnJywgc3VmZml4KTtcbiAgfVxuICAvLyB2YXIoJHt2YWx1ZX0sJHtmYWxsYmFja30pXG4gIGxldCB2YWx1ZSA9IGlubmVyLnN1YnN0cmluZygwLCBjb21tYSkudHJpbSgpO1xuICBsZXQgZmFsbGJhY2sgPSBpbm5lci5zdWJzdHJpbmcoY29tbWEgKyAxKS50cmltKCk7XG4gIHJldHVybiBjYWxsYmFjayhwcmVmaXgsIHZhbHVlLCBmYWxsYmFjaywgc3VmZml4KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RWxlbWVudENsYXNzUmF3KGVsZW1lbnQsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgc2V0QXR0cmlidXRlIHByb3ZpZGVkIGJ5IFNoYWR5RE9NIHdoZW4gc2V0QXR0cmlidXRlIGlzIHBhdGNoZWRcbiAgaWYgKG5hdGl2ZVNoYWRvdykge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3dbJ1NoYWR5RE9NJ11bJ25hdGl2ZU1ldGhvZHMnXVsnc2V0QXR0cmlidXRlJ10uY2FsbChlbGVtZW50LCAnY2xhc3MnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCB7aXM6IHN0cmluZywgZXh0ZW5kczogc3RyaW5nfX0gZWxlbWVudFxuICogQHJldHVybiB7e2lzOiBzdHJpbmcsIHR5cGVFeHRlbnNpb246IHN0cmluZ319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc0V4dGVuZHMoZWxlbWVudCkge1xuICBsZXQgbG9jYWxOYW1lID0gZWxlbWVudFsnbG9jYWxOYW1lJ107XG4gIGxldCBpcyA9ICcnLCB0eXBlRXh0ZW5zaW9uID0gJyc7XG4gIC8qXG4gIE5PVEU6IHRlY2huaWNhbGx5LCB0aGlzIGNhbiBiZSB3cm9uZyBmb3IgY2VydGFpbiBzdmcgZWxlbWVudHNcbiAgd2l0aCBgLWAgaW4gdGhlIG5hbWUgbGlrZSBgPGZvbnQtZmFjZT5gXG4gICovXG4gIGlmIChsb2NhbE5hbWUpIHtcbiAgICBpZiAobG9jYWxOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICBpcyA9IGxvY2FsTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZUV4dGVuc2lvbiA9IGxvY2FsTmFtZTtcbiAgICAgIGlzID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpcycpKSB8fCAnJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXMgPSAvKiogQHR5cGUgez99ICovKGVsZW1lbnQpLmlzO1xuICAgIHR5cGVFeHRlbnNpb24gPSAvKiogQHR5cGUgez99ICovKGVsZW1lbnQpLmV4dGVuZHM7XG4gIH1cbiAgcmV0dXJuIHtpcywgdHlwZUV4dGVuc2lvbn07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS11dGlsLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICFIVE1MVGVtcGxhdGVFbGVtZW50Pn1cbiAqL1xuY29uc3QgdGVtcGxhdGVNYXAgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlTWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdGVtcGxhdGUtbWFwLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovXG5sZXQgcmVhZHlQcm9taXNlID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oP2Z1bmN0aW9uKCkpfSAqL1xubGV0IHdoZW5SZWFkeSA9IHdpbmRvd1snSFRNTEltcG9ydHMnXSAmJiB3aW5kb3dbJ0hUTUxJbXBvcnRzJ11bJ3doZW5SZWFkeSddIHx8IG51bGw7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbmxldCByZXNvbHZlRm47XG5cbi8qKlxuICogQHBhcmFtIHs/ZnVuY3Rpb24oKX0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZG9jdW1lbnRXYWl0KGNhbGxiYWNrKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBpZiAod2hlblJlYWR5KSB7XG4gICAgICB3aGVuUmVhZHkoY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVhZHlQcm9taXNlKSB7XG4gICAgICAgIHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7cmVzb2x2ZUZuID0gcmVzb2x2ZX0pO1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIHJlc29sdmVGbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICByZXNvbHZlRm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24oKXsgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTsgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2RvY3VtZW50LXdhaXQuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBkb2N1bWVudFdhaXQgZnJvbSAnLi9kb2N1bWVudC13YWl0LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7SFRNTFN0eWxlRWxlbWVudCB8IHtnZXRTdHlsZTogZnVuY3Rpb24oKTpIVE1MU3R5bGVFbGVtZW50fX1cbiAqL1xuZXhwb3J0IGxldCBDdXN0b21TdHlsZVByb3ZpZGVyO1xuXG5jb25zdCBTRUVOX01BUktFUiA9ICdfX3NlZW5CeVNoYWR5Q1NTJztcbmNvbnN0IENBQ0hFRF9TVFlMRSA9ICdfX3NoYWR5Q1NTQ2FjaGVkU3R5bGUnO1xuXG4vKiogQHR5cGUgez9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCl9ICovXG5sZXQgdHJhbnNmb3JtRm4gPSBudWxsO1xuXG4vKiogQHR5cGUgez9mdW5jdGlvbigpfSAqL1xubGV0IHZhbGlkYXRlRm4gPSBudWxsO1xuXG4vKipcblRoaXMgaW50ZXJmYWNlIGlzIHByb3ZpZGVkIHRvIGFkZCBkb2N1bWVudC1sZXZlbCA8c3R5bGU+IGVsZW1lbnRzIHRvIFNoYWR5Q1NTIGZvciBwcm9jZXNzaW5nLlxuVGhlc2Ugc3R5bGVzIG11c3QgYmUgcHJvY2Vzc2VkIGJ5IFNoYWR5Q1NTIHRvIHNpbXVsYXRlIFNoYWRvd1Jvb3QgdXBwZXItYm91bmQgZW5jYXBzdWxhdGlvbiBmcm9tIG91dHNpZGUgc3R5bGVzXG5JbiBhZGRpdGlvbiwgdGhlc2Ugc3R5bGVzIG1heSBhbHNvIG5lZWQgdG8gYmUgcHJvY2Vzc2VkIGZvciBAYXBwbHkgcnVsZXMgYW5kIENTUyBDdXN0b20gUHJvcGVydGllc1xuXG5UbyBhZGQgZG9jdW1lbnQtbGV2ZWwgc3R5bGVzIHRvIFNoYWR5Q1NTLCBvbmUgY2FuIGNhbGwgYFNoYWR5Q1NTLmFkZERvY3VtZW50U3R5bGUoc3R5bGVFbGVtZW50KWAgb3IgYFNoYWR5Q1NTLmFkZERvY3VtZW50U3R5bGUoe2dldFN0eWxlOiAoKSA9PiBzdHlsZUVsZW1lbnR9KWBcblxuSW4gYWRkaXRpb24sIGlmIHRoZSBwcm9jZXNzIHVzZWQgdG8gZGlzY292ZXIgZG9jdW1lbnQtbGV2ZWwgc3R5bGVzIGNhbiBiZSBzeW5jaHJvbm91c2x5IGZsdXNoZWQsIG9uZSBzaG91bGQgc2V0IGBTaGFkeUNTUy5kb2N1bWVudFN0eWxlRmx1c2hgLlxuVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIGNhbGN1bGF0aW5nIHN0eWxlcy5cblxuQW4gZXhhbXBsZSB1c2FnZSBvZiB0aGUgZG9jdW1lbnQtbGV2ZWwgc3R5bGluZyBhcGkgY2FuIGJlIGZvdW5kIGluIGBleGFtcGxlcy9kb2N1bWVudC1zdHlsZS1saWIuanNgXG5cbkB1bnJlc3RyaWN0ZWRcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21TdHlsZUludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7IUFycmF5PCFDdXN0b21TdHlsZVByb3ZpZGVyPn0gKi9cbiAgICB0aGlzWydjdXN0b21TdHlsZXMnXSA9IFtdO1xuICAgIHRoaXNbJ2VucXVldWVkJ10gPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUXVldWUgYSB2YWxpZGF0aW9uIGZvciBuZXcgY3VzdG9tIHN0eWxlcyB0byBiYXRjaCBzdHlsZSByZWNhbGN1bGF0aW9uc1xuICAgKi9cbiAgZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpIHtcbiAgICBpZiAodGhpc1snZW5xdWV1ZWQnXSB8fCAhdmFsaWRhdGVGbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzWydlbnF1ZXVlZCddID0gdHJ1ZTtcbiAgICBkb2N1bWVudFdhaXQodmFsaWRhdGVGbik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gICAqL1xuICBhZGRDdXN0b21TdHlsZShzdHlsZSkge1xuICAgIGlmICghc3R5bGVbU0VFTl9NQVJLRVJdKSB7XG4gICAgICBzdHlsZVtTRUVOX01BUktFUl0gPSB0cnVlO1xuICAgICAgdGhpc1snY3VzdG9tU3R5bGVzJ10ucHVzaChzdHlsZSk7XG4gICAgICB0aGlzLmVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUN1c3RvbVN0eWxlUHJvdmlkZXJ9IGN1c3RvbVN0eWxlXG4gICAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gICAqL1xuICBnZXRTdHlsZUZvckN1c3RvbVN0eWxlKGN1c3RvbVN0eWxlKSB7XG4gICAgaWYgKGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0pIHtcbiAgICAgIHJldHVybiBjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdO1xuICAgIH1cbiAgICBsZXQgc3R5bGU7XG4gICAgaWYgKGN1c3RvbVN0eWxlWydnZXRTdHlsZSddKSB7XG4gICAgICBzdHlsZSA9IGN1c3RvbVN0eWxlWydnZXRTdHlsZSddKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlID0gY3VzdG9tU3R5bGU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybiB7IUFycmF5PCFDdXN0b21TdHlsZVByb3ZpZGVyPn1cbiAgICovXG4gIHByb2Nlc3NTdHlsZXMoKSB7XG4gICAgY29uc3QgY3MgPSB0aGlzWydjdXN0b21TdHlsZXMnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXN0b21TdHlsZSA9IGNzW2ldO1xuICAgICAgaWYgKGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShjdXN0b21TdHlsZSk7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgLy8gSFRNTEltcG9ydHMgcG9seWZpbGwgbWF5IGhhdmUgY2xvbmVkIHRoZSBzdHlsZSBpbnRvIHRoZSBtYWluIGRvY3VtZW50LFxuICAgICAgICAvLyB3aGljaCBpcyByZWZlcmVuY2VkIHdpdGggX19hcHBsaWVkRWxlbWVudC5cbiAgICAgICAgY29uc3Qgc3R5bGVUb1RyYW5zZm9ybSA9IC8qKiBAdHlwZSB7IUhUTUxTdHlsZUVsZW1lbnR9ICovKHN0eWxlWydfX2FwcGxpZWRFbGVtZW50J10gfHwgc3R5bGUpO1xuICAgICAgICBpZiAodHJhbnNmb3JtRm4pIHtcbiAgICAgICAgICB0cmFuc2Zvcm1GbihzdHlsZVRvVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdID0gc3R5bGVUb1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNzO1xuICB9XG59XG5cbkN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZVsnYWRkQ3VzdG9tU3R5bGUnXSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZS5hZGRDdXN0b21TdHlsZTtcbkN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZVsnZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSddID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGU7XG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ3Byb2Nlc3NTdHlsZXMnXSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZS5wcm9jZXNzU3R5bGVzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUsIHtcbiAgJ3RyYW5zZm9ybUNhbGxiYWNrJzoge1xuICAgIC8qKiBAcmV0dXJuIHs/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSAqL1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1GbjtcbiAgICB9LFxuICAgIC8qKiBAcGFyYW0gez9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCl9IGZuICovXG4gICAgc2V0KGZuKSB7XG4gICAgICB0cmFuc2Zvcm1GbiA9IGZuO1xuICAgIH1cbiAgfSxcbiAgJ3ZhbGlkYXRlQ2FsbGJhY2snOiB7XG4gICAgLyoqIEByZXR1cm4gez9mdW5jdGlvbigpfSAqL1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUZuO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oKX0gZm5cbiAgICAgKiBAdGhpcyB7Q3VzdG9tU3R5bGVJbnRlcmZhY2V9XG4gICAgICovXG4gICAgc2V0KGZuKSB7XG4gICAgICBsZXQgbmVlZHNFbnF1ZXVlID0gZmFsc2U7XG4gICAgICBpZiAoIXZhbGlkYXRlRm4pIHtcbiAgICAgICAgbmVlZHNFbnF1ZXVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlRm4gPSBmbjtcbiAgICAgIGlmIChuZWVkc0VucXVldWUpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfVxufSlcblxuLyoqIEB0eXBlZGVmIHt7XG4gKiBjdXN0b21TdHlsZXM6ICFBcnJheTwhQ3VzdG9tU3R5bGVQcm92aWRlcj4sXG4gKiBhZGRDdXN0b21TdHlsZTogZnVuY3Rpb24oIUN1c3RvbVN0eWxlUHJvdmlkZXIpLFxuICogZ2V0U3R5bGVGb3JDdXN0b21TdHlsZTogZnVuY3Rpb24oIUN1c3RvbVN0eWxlUHJvdmlkZXIpOiBIVE1MU3R5bGVFbGVtZW50LFxuICogZmluZFN0eWxlczogZnVuY3Rpb24oKSxcbiAqIHRyYW5zZm9ybUNhbGxiYWNrOiA/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpLFxuICogdmFsaWRhdGVDYWxsYmFjazogP2Z1bmN0aW9uKClcbiAqIH19XG4gKi9cbmV4cG9ydCBsZXQgQ3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBnZXN0dXJlcyQwIGZyb20gJy4uL3V0aWxzL2dlc3R1cmVzLmpzJztcblxuLyoqXG4gKiBAY29uc3Qge1BvbHltZXIuR2VzdHVyZXN9XG4gKi9cbmNvbnN0IGdlc3R1cmVzID0gZ2VzdHVyZXMkMDtcblxuZXhwb3J0IGNvbnN0IEdlc3R1cmVFdmVudExpc3RlbmVycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICovXG4gIGNsYXNzIEdlc3R1cmVFdmVudExpc3RlbmVycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWdlc3R1cmVzLmFkZExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFnZXN0dXJlcy5yZW1vdmVMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgIHN1cGVyLl9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBHZXN0dXJlRXZlbnRMaXN0ZW5lcnM7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBzY2hlZHVsZWQgPSBmYWxzZTtcbmxldCBiZWZvcmVSZW5kZXJRdWV1ZSA9IFtdO1xubGV0IGFmdGVyUmVuZGVyUXVldWUgPSBbXTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gIHNjaGVkdWxlZCA9IHRydWU7XG4gIC8vIGJlZm9yZSBuZXh0IHJlbmRlclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgLy8gYWZ0ZXIgdGhlIHJlbmRlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBydW5RdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUXVldWUocXVldWUpIHtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuUXVldWUocXVldWUpIHtcbiAgZm9yIChsZXQgaT0wLCBsPXF1ZXVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbE1ldGhvZChpbmZvKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBpbmZvWzBdO1xuICBjb25zdCBjYWxsYmFjayA9IGluZm9bMV07XG4gIGNvbnN0IGFyZ3MgPSBpbmZvWzJdO1xuICB0cnkge1xuICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIHdoaWxlIChiZWZvcmVSZW5kZXJRdWV1ZS5sZW5ndGggfHwgYWZ0ZXJSZW5kZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICBmbHVzaFF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICB9XG4gIHNjaGVkdWxlZCA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYmVmb3JlUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYWZ0ZXJSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xufVxuXG5leHBvcnQgeyBmbHVzaCB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlU3BsaWNlcyB9IGZyb20gJy4vYXJyYXktc3BsaWNlLmpzJztcbmltcG9ydCB7IG1pY3JvVGFzayB9IGZyb20gJy4vYXN5bmMuanMnO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZWAgaXMgYSBzbG90IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgTm9kZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgYSBzbG90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1Nsb3Qobm9kZSkge1xuICByZXR1cm4gKG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpO1xufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC4gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGNvbnNpc3RzXG4gKiBvZiBhIG5vZGUncyBjaGlsZHJlbiBhbmQsIGZvciBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsXG4gKiB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICogYW5kIHRoZSBgPHNsb3Q+YCBoYXMgb25lIGA8ZGl2PmAgYXNzaWduZWQgdG8gaXQsIHRoZW4gdGhlIGZsYXR0ZW5lZFxuICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gKlxuICogVGhlIHByb3ZpZGVkIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdoZW5ldmVyIGFueSBjaGFuZ2UgdG8gdGhpcyBsaXN0XG4gKiBvZiBmbGF0dGVuZWQgbm9kZXMgb2NjdXJzLCB3aGVyZSBhbiBhZGRpdGlvbiBvciByZW1vdmFsIG9mIGEgbm9kZSBpc1xuICogY29uc2lkZXJlZCBhIGNoYW5nZS4gVGhlIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCBhbiBvYmplY3RcbiAqIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgYW55IGBhZGRlZE5vZGVzYCBhbmQgYHJlbW92ZWROb2Rlc2AuXG4gKlxuICogTm90ZTogdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBhc3luY2hyb25vdXMgdG8gYW55IGNoYW5nZXNcbiAqIGF0IGEgbWljcm90YXNrIGNoZWNrcG9pbnQuIFRoaXMgaXMgYmVjYXVzZSBvYnNlcnZhdGlvbiBpcyBwZXJmb3JtZWQgdXNpbmdcbiAqIGBNdXRhdGlvbk9ic2VydmVyYCBhbmQgdGhlIGA8c2xvdD5gIGVsZW1lbnQncyBgc2xvdGNoYW5nZWAgZXZlbnQgd2hpY2hcbiAqIGFyZSBhc3luY2hyb25vdXMuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC5cbiAqL1xuY2xhc3MgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAgKiBUaGlzIGxpc3QgY29uc2lzdHMgb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuXG4gICAqIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLCB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9ic2VydmVkIG5vZGUgaGFzIGNoaWxkcmVuIGA8YT48L2E+PHNsb3Q+PC9zbG90PjxiPjwvYj5gXG4gICAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAgICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAgICogYDxzbG90PmAgZWxlbWVudHMgYXNzaWduZWQgdG8gaXQsIHRoZXNlIGFyZSBmbGF0dGVuZWQgYXMgd2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MU2xvdEVsZW1lbnR9IG5vZGUgVGhlIG5vZGUgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgZm9yIHRoZSBnaXZlbiBgbm9kZWAuXG4gICovXG4gIHN0YXRpYyBnZXRGbGF0dGVuZWROb2Rlcyhub2RlKSB7XG4gICAgaWYgKGlzU2xvdChub2RlKSkge1xuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqLyAobm9kZSkuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLm1hcChub2RlID0+IHtcbiAgICAgICAgaWYgKGlzU2xvdChub2RlKSkge1xuICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICB9XG4gICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IE5vZGUgb24gd2hpY2ggdG8gbGlzdGVuIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgYWRkaXRpb25zXG4gICAqIG9yIHJlbW92YWxzIGZyb20gdGhlIHRhcmdldCdzIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzLlxuICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgLyoqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBbXTtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbigpfSAqL1xuICAgIHRoaXMuX2JvdW5kU2NoZWR1bGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25uZWN0KCk7XG4gICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgYW4gb2JzZXJ2ZXIuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW5cbiAgICogYSBgRmxhdHRlbmVkTm9kZXNPYnNlcnZlcmAgaXMgY3JlYXRlZC4gSXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHRvXG4gICAqIHJlLWFjdGl2YXRlIGFuIG9ic2VydmVyIHRoYXQgaGFzIGJlZW4gZGVhY3RpdmF0ZWQgdmlhIHRoZSBgZGlzY29ubmVjdGAgbWV0aG9kLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgIHRoaXMuX2xpc3RlblNsb3RzKFt0aGlzLl90YXJnZXRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuU2xvdHModGhpcy5fdGFyZ2V0LmNoaWxkcmVuKTtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICBTaGFkeURPTS5vYnNlcnZlQ2hpbGRyZW4odGhpcy5fdGFyZ2V0LCAobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl90YXJnZXQsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgZmxhdHRlbmVkIG5vZGVzIG9ic2VydmVyLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIHRoZSBvYnNlcnZlciBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIGZsYXR0ZW5lZCBub2Rlc1xuICAgKiBvY2N1ci4gVGhlIGBjb25uZWN0YCBtZXRob2QgbWF5IGJlIHN1YnNlcXVlbnRseSBjYWxsZWQgdG8gcmVhY3RpdmF0ZVxuICAgKiB0aGUgb2JzZXJ2ZXIuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmIChpc1Nsb3QodGhpcy5fdGFyZ2V0KSkge1xuICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHModGhpcy5fdGFyZ2V0LmNoaWxkcmVuKTtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00gJiYgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIFNoYWR5RE9NLnVub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9zY2hlZHVsZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIG1pY3JvVGFzay5ydW4oKCkgPT4gdGhpcy5mbHVzaCgpKTtcbiAgICB9XG4gIH1cblxuICBfcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxuXG4gIF9wcm9jZXNzU2xvdE11dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICBpZiAobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG11dGF0aW9uID0gbXV0YXRpb25zW2ldO1xuICAgICAgICBpZiAobXV0YXRpb24uYWRkZWROb2Rlcykge1xuICAgICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICB0aGlzLl91bmxpc3RlblNsb3RzKG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyB0aGUgb2JzZXJ2ZXIgY2F1c2luZyBhbnkgcGVuZGluZyBjaGFuZ2VzIHRvIGJlIGltbWVkaWF0ZWx5XG4gICAqIGRlbGl2ZXJlZCB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2suIEJ5IGRlZmF1bHQgdGhlc2UgY2hhbmdlcyBhcmUgZGVsaXZlcmVkXG4gICAqIGFzeW5jaHJvbm91c2x5IGF0IHRoZSBuZXh0IG1pY3JvdGFzayBjaGVja3BvaW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBlbmRpbmcgY2hhbmdlcyBjYXVzZWQgdGhlIG9ic2VydmVyXG4gICAqIGNhbGxiYWNrIHRvIHJ1bi5cbiAgICovXG4gIGZsdXNoKCkge1xuICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgfVxuICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGxldCBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsXG4gICAgICBhZGRlZE5vZGVzOiBbXSxcbiAgICAgIHJlbW92ZWROb2RlczogW11cbiAgICB9O1xuICAgIGxldCBuZXdOb2RlcyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0RmxhdHRlbmVkTm9kZXModGhpcy5fdGFyZ2V0KTtcbiAgICBsZXQgc3BsaWNlcyA9IGNhbGN1bGF0ZVNwbGljZXMobmV3Tm9kZXMsXG4gICAgICB0aGlzLl9lZmZlY3RpdmVOb2Rlcyk7XG4gICAgLy8gcHJvY2VzcyByZW1vdmFsc1xuICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGo9MCwgbjsgKGogPCBzLnJlbW92ZWQubGVuZ3RoKSAmJiAobj1zLnJlbW92ZWRbal0pOyBqKyspIHtcbiAgICAgICAgaW5mby5yZW1vdmVkTm9kZXMucHVzaChuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJvY2VzcyBhZGRzXG4gICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgZm9yIChsZXQgaj1zLmluZGV4OyBqIDwgcy5pbmRleCArIHMuYWRkZWRDb3VudDsgaisrKSB7XG4gICAgICAgIGluZm8uYWRkZWROb2Rlcy5wdXNoKG5ld05vZGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIGNhY2hlXG4gICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBuZXdOb2RlcztcbiAgICBsZXQgZGlkRmx1c2ggPSBmYWxzZTtcbiAgICBpZiAoaW5mby5hZGRlZE5vZGVzLmxlbmd0aCB8fCBpbmZvLnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIGRpZEZsdXNoID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLl90YXJnZXQsIGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZGlkRmx1c2g7XG4gIH1cblxuICBfbGlzdGVuU2xvdHMobm9kZUxpc3QpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBub2RlTGlzdFtpXTtcbiAgICAgIGlmIChpc1Nsb3QobikpIHtcbiAgICAgICAgbi5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VubGlzdGVuU2xvdHMobm9kZUxpc3QpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBub2RlTGlzdFtpXTtcbiAgICAgIGlmIChpc1Nsb3QobikpIHtcbiAgICAgICAgbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IHsgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmZ1bmN0aW9uIG5ld1NwbGljZShpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudCkge1xuICByZXR1cm4ge1xuICAgIGluZGV4OiBpbmRleCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnRcbiAgfTtcbn1cblxuY29uc3QgRURJVF9MRUFWRSA9IDA7XG5jb25zdCBFRElUX1VQREFURSA9IDE7XG5jb25zdCBFRElUX0FERCA9IDI7XG5jb25zdCBFRElUX0RFTEVURSA9IDM7XG5cbi8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgKmJhc2VkKiBvbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIExldmVuc2h0ZWluXG4vLyBcImVkaXRcIiBkaXN0YW5jZS4gVGhlIG9uZSBjaGFuZ2UgaXMgdGhhdCBcInVwZGF0ZXNcIiBhcmUgdHJlYXRlZCBhcyB0d29cbi8vIGVkaXRzIC0gbm90IG9uZS4gV2l0aCBBcnJheSBzcGxpY2VzLCBhbiB1cGRhdGUgaXMgcmVhbGx5IGEgZGVsZXRlXG4vLyBmb2xsb3dlZCBieSBhbiBhZGQuIEJ5IHJldGFpbmluZyB0aGlzLCB3ZSBvcHRpbWl6ZSBmb3IgXCJrZWVwaW5nXCIgdGhlXG4vLyBtYXhpbXVtIGFycmF5IGl0ZW1zIGluIHRoZSBvcmlnaW5hbCBhcnJheS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICAneHh4eDEyMycgLT4gJzEyM3l5eXknXG4vL1xuLy8gV2l0aCAxLWVkaXQgdXBkYXRlcywgdGhlIHNob3J0ZXN0IHBhdGggd291bGQgYmUganVzdCB0byB1cGRhdGUgYWxsIHNldmVuXG4vLyBjaGFyYWN0ZXJzLiBXaXRoIDItZWRpdCB1cGRhdGVzLCB3ZSBkZWxldGUgNCwgbGVhdmUgMywgYW5kIGFkZCA0LiBUaGlzXG4vLyBsZWF2ZXMgdGhlIHN1YnN0cmluZyAnMTIzJyBpbnRhY3QuXG5mdW5jdGlvbiBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gIC8vIFwiRGVsZXRpb25cIiBjb2x1bW5zXG4gIGxldCByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcbiAgbGV0IGNvbHVtbkNvdW50ID0gY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCArIDE7XG4gIGxldCBkaXN0YW5jZXMgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuXG4gIC8vIFwiQWRkaXRpb25cIiByb3dzLiBJbml0aWFsaXplIG51bGwgY29sdW1uLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBkaXN0YW5jZXNbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICAgIGRpc3RhbmNlc1tpXVswXSA9IGk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIG51bGwgcm93XG4gIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uQ291bnQ7IGorKylcbiAgICBkaXN0YW5jZXNbMF1bal0gPSBqO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDwgY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgaWYgKGVxdWFscyhjdXJyZW50W2N1cnJlbnRTdGFydCArIGogLSAxXSwgb2xkW29sZFN0YXJ0ICsgaSAtIDFdKSlcbiAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2kgLSAxXVtqXSArIDE7XG4gICAgICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2ldW2ogLSAxXSArIDE7XG4gICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IG5vcnRoIDwgd2VzdCA/IG5vcnRoIDogd2VzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2VzO1xufVxuXG4vLyBUaGlzIHN0YXJ0cyBhdCB0aGUgZmluYWwgd2VpZ2h0LCBhbmQgd2Fsa3MgXCJiYWNrd2FyZFwiIGJ5IGZpbmRpbmdcbi8vIHRoZSBtaW5pbXVtIHByZXZpb3VzIHdlaWdodCByZWN1cnNpdmVseSB1bnRpbCB0aGUgb3JpZ2luIG9mIHRoZSB3ZWlnaHRcbi8vIG1hdHJpeC5cbmZ1bmN0aW9uIHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhkaXN0YW5jZXMpIHtcbiAgbGV0IGkgPSBkaXN0YW5jZXMubGVuZ3RoIC0gMTtcbiAgbGV0IGogPSBkaXN0YW5jZXNbMF0ubGVuZ3RoIC0gMTtcbiAgbGV0IGN1cnJlbnQgPSBkaXN0YW5jZXNbaV1bal07XG4gIGxldCBlZGl0cyA9IFtdO1xuICB3aGlsZSAoaSA+IDAgfHwgaiA+IDApIHtcbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgIGotLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaiA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgIGktLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgbm9ydGhXZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2pdO1xuICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpXVtqIC0gMV07XG5cbiAgICBsZXQgbWluO1xuICAgIGlmICh3ZXN0IDwgbm9ydGgpXG4gICAgICBtaW4gPSB3ZXN0IDwgbm9ydGhXZXN0ID8gd2VzdCA6IG5vcnRoV2VzdDtcbiAgICBlbHNlXG4gICAgICBtaW4gPSBub3J0aCA8IG5vcnRoV2VzdCA/IG5vcnRoIDogbm9ydGhXZXN0O1xuXG4gICAgaWYgKG1pbiA9PSBub3J0aFdlc3QpIHtcbiAgICAgIGlmIChub3J0aFdlc3QgPT0gY3VycmVudCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfTEVBVkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX1VQREFURSk7XG4gICAgICAgIGN1cnJlbnQgPSBub3J0aFdlc3Q7XG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBqLS07XG4gICAgfSBlbHNlIGlmIChtaW4gPT0gd2VzdCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICBpLS07XG4gICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICBqLS07XG4gICAgICBjdXJyZW50ID0gbm9ydGg7XG4gICAgfVxuICB9XG5cbiAgZWRpdHMucmV2ZXJzZSgpO1xuICByZXR1cm4gZWRpdHM7XG59XG5cbi8qKlxuICogU3BsaWNlIFByb2plY3Rpb24gZnVuY3Rpb25zOlxuICpcbiAqIEEgc3BsaWNlIG1hcCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIGhvdyBhIHByZXZpb3VzIGFycmF5IG9mIGl0ZW1zXG4gKiB3YXMgdHJhbnNmb3JtZWQgaW50byBhIG5ldyBhcnJheSBvZiBpdGVtcy4gQ29uY2VwdHVhbGx5IGl0IGlzIGEgbGlzdCBvZlxuICogdHVwbGVzIG9mXG4gKlxuICogICA8aW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQ+XG4gKlxuICogd2hpY2ggYXJlIGtlcHQgaW4gYXNjZW5kaW5nIGluZGV4IG9yZGVyIG9mLiBUaGUgdHVwbGUgcmVwcmVzZW50cyB0aGF0IGF0XG4gKiB0aGUgfGluZGV4fCwgfHJlbW92ZWR8IHNlcXVlbmNlIG9mIGl0ZW1zIHdlcmUgcmVtb3ZlZCwgYW5kIGNvdW50aW5nIGZvcndhcmRcbiAqIGZyb20gfGluZGV4fCwgfGFkZGVkQ291bnR8IGl0ZW1zIHdlcmUgYWRkZWQuXG4gKi9cblxuLyoqXG4gKiBMYWNraW5nIGluZGl2aWR1YWwgc3BsaWNlIG11dGF0aW9uIGluZm9ybWF0aW9uLCB0aGUgbWluaW1hbCBzZXQgb2ZcbiAqIHNwbGljZXMgY2FuIGJlIHN5bnRoZXNpemVkIGdpdmVuIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgZmluYWwgc3RhdGUgb2YgYW5cbiAqIGFycmF5LiBUaGUgYmFzaWMgYXBwcm9hY2ggaXMgdG8gY2FsY3VsYXRlIHRoZSBlZGl0IGRpc3RhbmNlIG1hdHJpeCBhbmRcbiAqIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aCB0aHJvdWdoIGl0LlxuICpcbiAqIENvbXBsZXhpdHk6IE8obCAqIHApXG4gKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgb2xkIGFycmF5XG4gKlxuICogQHBhcmFtIHtBcnJheX0gY3VycmVudCBUaGUgY3VycmVudCBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggdG9cbiAqIGNhbGN1bGF0ZSBzcGxpY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50RW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IG9sZCBUaGUgb3JpZ2luYWwgXCJ1bmNoYW5nZWRcIiBhcnJheSB0byBjb21wYXJlIGBjdXJyZW50YFxuICogYWdhaW5zdCB0byBkZXRlcm1pbmUgc3BsaWNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvbGRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG9sZEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmQgb2JqZWN0cy4gRWFjaCBvZiB0aGVzZVxuICogY29udGFpbnM6IGBpbmRleGAgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBzcGxpY2Ugb2NjdXJyZWQ7IGByZW1vdmVkYFxuICogdGhlIGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgZnJvbSB0aGlzIGxvY2F0aW9uOyBgYWRkZWRDb3VudGAgdGhlIG51bWJlclxuICogb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBsb2NhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FsY1NwbGljZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICBsZXQgcHJlZml4Q291bnQgPSAwO1xuICBsZXQgc3VmZml4Q291bnQgPSAwO1xuICBsZXQgc3BsaWNlO1xuXG4gIGxldCBtaW5MZW5ndGggPSBNYXRoLm1pbihjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0LCBvbGRFbmQgLSBvbGRTdGFydCk7XG4gIGlmIChjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRTdGFydCA9PSAwKVxuICAgIHByZWZpeENvdW50ID0gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoKTtcblxuICBpZiAoY3VycmVudEVuZCA9PSBjdXJyZW50Lmxlbmd0aCAmJiBvbGRFbmQgPT0gb2xkLmxlbmd0aClcbiAgICBzdWZmaXhDb3VudCA9IHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCAtIHByZWZpeENvdW50KTtcblxuICBjdXJyZW50U3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gIG9sZFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICBjdXJyZW50RW5kIC09IHN1ZmZpeENvdW50O1xuICBvbGRFbmQgLT0gc3VmZml4Q291bnQ7XG5cbiAgaWYgKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRFbmQgLSBvbGRTdGFydCA9PSAwKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAoY3VycmVudFN0YXJ0ID09IGN1cnJlbnRFbmQpIHtcbiAgICBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG4gICAgd2hpbGUgKG9sZFN0YXJ0IDwgb2xkRW5kKVxuICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkU3RhcnQrK10pO1xuXG4gICAgcmV0dXJuIFsgc3BsaWNlIF07XG4gIH0gZWxzZSBpZiAob2xkU3RhcnQgPT0gb2xkRW5kKVxuICAgIHJldHVybiBbIG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0KSBdO1xuXG4gIGxldCBvcHMgPSBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoXG4gICAgICBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkpO1xuXG4gIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgbGV0IHNwbGljZXMgPSBbXTtcbiAgbGV0IGluZGV4ID0gY3VycmVudFN0YXJ0O1xuICBsZXQgb2xkSW5kZXggPSBvbGRTdGFydDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2gob3BzW2ldKSB7XG4gICAgICBjYXNlIEVESVRfTEVBVkU6XG4gICAgICAgIGlmIChzcGxpY2UpIHtcbiAgICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICAgICAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9VUERBVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfQUREOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9ERUxFVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzcGxpY2UpIHtcbiAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgfVxuICByZXR1cm4gc3BsaWNlcztcbn1cblxuZnVuY3Rpb24gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoTGVuZ3RoOyBpKyspXG4gICAgaWYgKCFlcXVhbHMoY3VycmVudFtpXSwgb2xkW2ldKSlcbiAgICAgIHJldHVybiBpO1xuICByZXR1cm4gc2VhcmNoTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgbGV0IGluZGV4MSA9IGN1cnJlbnQubGVuZ3RoO1xuICBsZXQgaW5kZXgyID0gb2xkLmxlbmd0aDtcbiAgbGV0IGNvdW50ID0gMDtcbiAgd2hpbGUgKGNvdW50IDwgc2VhcmNoTGVuZ3RoICYmIGVxdWFscyhjdXJyZW50Wy0taW5kZXgxXSwgb2xkWy0taW5kZXgyXSkpXG4gICAgY291bnQrKztcblxuICByZXR1cm4gY291bnQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwbGljZXMoY3VycmVudCwgcHJldmlvdXMpIHtcbiAgcmV0dXJuIGNhbGNTcGxpY2VzKGN1cnJlbnQsIDAsIGN1cnJlbnQubGVuZ3RoLCBwcmV2aW91cywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gZXF1YWxzKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuICByZXR1cm4gY3VycmVudFZhbHVlID09PSBwcmV2aW91c1ZhbHVlO1xufVxuXG5leHBvcnQgeyBjYWxjdWxhdGVTcGxpY2VzIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FycmF5LXNwbGljZS5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcblxuICAgICAgLyogTWF0ZXJpYWwgRGVzaWduIGNvbG9yIHBhbGV0dGUgZm9yIEdvb2dsZSBwcm9kdWN0cyAqL1xuXG4gICAgICAtLWdvb2dsZS1yZWQtMTAwOiAjZjRjN2MzO1xuICAgICAgLS1nb29nbGUtcmVkLTMwMDogI2U2N2M3MztcbiAgICAgIC0tZ29vZ2xlLXJlZC01MDA6ICNkYjQ0Mzc7XG4gICAgICAtLWdvb2dsZS1yZWQtNzAwOiAjYzUzOTI5O1xuXG4gICAgICAtLWdvb2dsZS1ibHVlLTEwMDogI2M2ZGFmYztcbiAgICAgIC0tZ29vZ2xlLWJsdWUtMzAwOiAjN2JhYWY3O1xuICAgICAgLS1nb29nbGUtYmx1ZS01MDA6ICM0Mjg1ZjQ7XG4gICAgICAtLWdvb2dsZS1ibHVlLTcwMDogIzMzNjdkNjtcblxuICAgICAgLS1nb29nbGUtZ3JlZW4tMTAwOiAjYjdlMWNkO1xuICAgICAgLS1nb29nbGUtZ3JlZW4tMzAwOiAjNTdiYjhhO1xuICAgICAgLS1nb29nbGUtZ3JlZW4tNTAwOiAjMGY5ZDU4O1xuICAgICAgLS1nb29nbGUtZ3JlZW4tNzAwOiAjMGI4MDQzO1xuXG4gICAgICAtLWdvb2dsZS15ZWxsb3ctMTAwOiAjZmNlOGIyO1xuICAgICAgLS1nb29nbGUteWVsbG93LTMwMDogI2Y3Y2I0ZDtcbiAgICAgIC0tZ29vZ2xlLXllbGxvdy01MDA6ICNmNGI0MDA7XG4gICAgICAtLWdvb2dsZS15ZWxsb3ctNzAwOiAjZjA5MzAwO1xuXG4gICAgICAtLWdvb2dsZS1ncmV5LTEwMDogI2Y1ZjVmNTtcbiAgICAgIC0tZ29vZ2xlLWdyZXktMzAwOiAjZTBlMGUwO1xuICAgICAgLS1nb29nbGUtZ3JleS01MDA6ICM5ZTllOWU7XG4gICAgICAtLWdvb2dsZS1ncmV5LTcwMDogIzYxNjE2MTtcblxuICAgICAgLyogTWF0ZXJpYWwgRGVzaWduIGNvbG9yIHBhbGV0dGUgZnJvbSBvbmxpbmUgc3BlYyBkb2N1bWVudCAqL1xuXG4gICAgICAtLXBhcGVyLXJlZC01MDogI2ZmZWJlZTtcbiAgICAgIC0tcGFwZXItcmVkLTEwMDogI2ZmY2RkMjtcbiAgICAgIC0tcGFwZXItcmVkLTIwMDogI2VmOWE5YTtcbiAgICAgIC0tcGFwZXItcmVkLTMwMDogI2U1NzM3MztcbiAgICAgIC0tcGFwZXItcmVkLTQwMDogI2VmNTM1MDtcbiAgICAgIC0tcGFwZXItcmVkLTUwMDogI2Y0NDMzNjtcbiAgICAgIC0tcGFwZXItcmVkLTYwMDogI2U1MzkzNTtcbiAgICAgIC0tcGFwZXItcmVkLTcwMDogI2QzMmYyZjtcbiAgICAgIC0tcGFwZXItcmVkLTgwMDogI2M2MjgyODtcbiAgICAgIC0tcGFwZXItcmVkLTkwMDogI2I3MWMxYztcbiAgICAgIC0tcGFwZXItcmVkLWExMDA6ICNmZjhhODA7XG4gICAgICAtLXBhcGVyLXJlZC1hMjAwOiAjZmY1MjUyO1xuICAgICAgLS1wYXBlci1yZWQtYTQwMDogI2ZmMTc0NDtcbiAgICAgIC0tcGFwZXItcmVkLWE3MDA6ICNkNTAwMDA7XG5cbiAgICAgIC0tcGFwZXItcGluay01MDogI2ZjZTRlYztcbiAgICAgIC0tcGFwZXItcGluay0xMDA6ICNmOGJiZDA7XG4gICAgICAtLXBhcGVyLXBpbmstMjAwOiAjZjQ4ZmIxO1xuICAgICAgLS1wYXBlci1waW5rLTMwMDogI2YwNjI5MjtcbiAgICAgIC0tcGFwZXItcGluay00MDA6ICNlYzQwN2E7XG4gICAgICAtLXBhcGVyLXBpbmstNTAwOiAjZTkxZTYzO1xuICAgICAgLS1wYXBlci1waW5rLTYwMDogI2Q4MWI2MDtcbiAgICAgIC0tcGFwZXItcGluay03MDA6ICNjMjE4NWI7XG4gICAgICAtLXBhcGVyLXBpbmstODAwOiAjYWQxNDU3O1xuICAgICAgLS1wYXBlci1waW5rLTkwMDogIzg4MGU0ZjtcbiAgICAgIC0tcGFwZXItcGluay1hMTAwOiAjZmY4MGFiO1xuICAgICAgLS1wYXBlci1waW5rLWEyMDA6ICNmZjQwODE7XG4gICAgICAtLXBhcGVyLXBpbmstYTQwMDogI2Y1MDA1NztcbiAgICAgIC0tcGFwZXItcGluay1hNzAwOiAjYzUxMTYyO1xuXG4gICAgICAtLXBhcGVyLXB1cnBsZS01MDogI2YzZTVmNTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTEwMDogI2UxYmVlNztcbiAgICAgIC0tcGFwZXItcHVycGxlLTIwMDogI2NlOTNkODtcbiAgICAgIC0tcGFwZXItcHVycGxlLTMwMDogI2JhNjhjODtcbiAgICAgIC0tcGFwZXItcHVycGxlLTQwMDogI2FiNDdiYztcbiAgICAgIC0tcGFwZXItcHVycGxlLTUwMDogIzljMjdiMDtcbiAgICAgIC0tcGFwZXItcHVycGxlLTYwMDogIzhlMjRhYTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTcwMDogIzdiMWZhMjtcbiAgICAgIC0tcGFwZXItcHVycGxlLTgwMDogIzZhMWI5YTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTkwMDogIzRhMTQ4YztcbiAgICAgIC0tcGFwZXItcHVycGxlLWExMDA6ICNlYTgwZmM7XG4gICAgICAtLXBhcGVyLXB1cnBsZS1hMjAwOiAjZTA0MGZiO1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTQwMDogI2Q1MDBmOTtcbiAgICAgIC0tcGFwZXItcHVycGxlLWE3MDA6ICNhYTAwZmY7XG5cbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNTA6ICNlZGU3ZjY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTEwMDogI2QxYzRlOTtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtMjAwOiAjYjM5ZGRiO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS0zMDA6ICM5NTc1Y2Q7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTQwMDogIzdlNTdjMjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNTAwOiAjNjczYWI3O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS02MDA6ICM1ZTM1YjE7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTcwMDogIzUxMmRhODtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtODAwOiAjNDUyN2EwO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS05MDA6ICMzMTFiOTI7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWExMDA6ICNiMzg4ZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWEyMDA6ICM3YzRkZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWE0MDA6ICM2NTFmZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWE3MDA6ICM2MjAwZWE7XG5cbiAgICAgIC0tcGFwZXItaW5kaWdvLTUwOiAjZThlYWY2O1xuICAgICAgLS1wYXBlci1pbmRpZ28tMTAwOiAjYzVjYWU5O1xuICAgICAgLS1wYXBlci1pbmRpZ28tMjAwOiAjOWZhOGRhO1xuICAgICAgLS1wYXBlci1pbmRpZ28tMzAwOiAjNzk4NmNiO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNDAwOiAjNWM2YmMwO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNTAwOiAjM2Y1MWI1O1xuICAgICAgLS1wYXBlci1pbmRpZ28tNjAwOiAjMzk0OWFiO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNzAwOiAjMzAzZjlmO1xuICAgICAgLS1wYXBlci1pbmRpZ28tODAwOiAjMjgzNTkzO1xuICAgICAgLS1wYXBlci1pbmRpZ28tOTAwOiAjMWEyMzdlO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTEwMDogIzhjOWVmZjtcbiAgICAgIC0tcGFwZXItaW5kaWdvLWEyMDA6ICM1MzZkZmU7XG4gICAgICAtLXBhcGVyLWluZGlnby1hNDAwOiAjM2Q1YWZlO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTcwMDogIzMwNGZmZTtcblxuICAgICAgLS1wYXBlci1ibHVlLTUwOiAjZTNmMmZkO1xuICAgICAgLS1wYXBlci1ibHVlLTEwMDogI2JiZGVmYjtcbiAgICAgIC0tcGFwZXItYmx1ZS0yMDA6ICM5MGNhZjk7XG4gICAgICAtLXBhcGVyLWJsdWUtMzAwOiAjNjRiNWY2O1xuICAgICAgLS1wYXBlci1ibHVlLTQwMDogIzQyYTVmNTtcbiAgICAgIC0tcGFwZXItYmx1ZS01MDA6ICMyMTk2ZjM7XG4gICAgICAtLXBhcGVyLWJsdWUtNjAwOiAjMWU4OGU1O1xuICAgICAgLS1wYXBlci1ibHVlLTcwMDogIzE5NzZkMjtcbiAgICAgIC0tcGFwZXItYmx1ZS04MDA6ICMxNTY1YzA7XG4gICAgICAtLXBhcGVyLWJsdWUtOTAwOiAjMGQ0N2ExO1xuICAgICAgLS1wYXBlci1ibHVlLWExMDA6ICM4MmIxZmY7XG4gICAgICAtLXBhcGVyLWJsdWUtYTIwMDogIzQ0OGFmZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1hNDAwOiAjMjk3OWZmO1xuICAgICAgLS1wYXBlci1ibHVlLWE3MDA6ICMyOTYyZmY7XG5cbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS01MDogI2UxZjVmZTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS0xMDA6ICNiM2U1ZmM7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtMjAwOiAjODFkNGZhO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTMwMDogIzRmYzNmNztcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS00MDA6ICMyOWI2ZjY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNTAwOiAjMDNhOWY0O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTYwMDogIzAzOWJlNTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS03MDA6ICMwMjg4ZDE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtODAwOiAjMDI3N2JkO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTkwMDogIzAxNTc5YjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hMTAwOiAjODBkOGZmO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWEyMDA6ICM0MGM0ZmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtYTQwMDogIzAwYjBmZjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hNzAwOiAjMDA5MWVhO1xuXG4gICAgICAtLXBhcGVyLWN5YW4tNTA6ICNlMGY3ZmE7XG4gICAgICAtLXBhcGVyLWN5YW4tMTAwOiAjYjJlYmYyO1xuICAgICAgLS1wYXBlci1jeWFuLTIwMDogIzgwZGVlYTtcbiAgICAgIC0tcGFwZXItY3lhbi0zMDA6ICM0ZGQwZTE7XG4gICAgICAtLXBhcGVyLWN5YW4tNDAwOiAjMjZjNmRhO1xuICAgICAgLS1wYXBlci1jeWFuLTUwMDogIzAwYmNkNDtcbiAgICAgIC0tcGFwZXItY3lhbi02MDA6ICMwMGFjYzE7XG4gICAgICAtLXBhcGVyLWN5YW4tNzAwOiAjMDA5N2E3O1xuICAgICAgLS1wYXBlci1jeWFuLTgwMDogIzAwODM4ZjtcbiAgICAgIC0tcGFwZXItY3lhbi05MDA6ICMwMDYwNjQ7XG4gICAgICAtLXBhcGVyLWN5YW4tYTEwMDogIzg0ZmZmZjtcbiAgICAgIC0tcGFwZXItY3lhbi1hMjAwOiAjMThmZmZmO1xuICAgICAgLS1wYXBlci1jeWFuLWE0MDA6ICMwMGU1ZmY7XG4gICAgICAtLXBhcGVyLWN5YW4tYTcwMDogIzAwYjhkNDtcblxuICAgICAgLS1wYXBlci10ZWFsLTUwOiAjZTBmMmYxO1xuICAgICAgLS1wYXBlci10ZWFsLTEwMDogI2IyZGZkYjtcbiAgICAgIC0tcGFwZXItdGVhbC0yMDA6ICM4MGNiYzQ7XG4gICAgICAtLXBhcGVyLXRlYWwtMzAwOiAjNGRiNmFjO1xuICAgICAgLS1wYXBlci10ZWFsLTQwMDogIzI2YTY5YTtcbiAgICAgIC0tcGFwZXItdGVhbC01MDA6ICMwMDk2ODg7XG4gICAgICAtLXBhcGVyLXRlYWwtNjAwOiAjMDA4OTdiO1xuICAgICAgLS1wYXBlci10ZWFsLTcwMDogIzAwNzk2YjtcbiAgICAgIC0tcGFwZXItdGVhbC04MDA6ICMwMDY5NWM7XG4gICAgICAtLXBhcGVyLXRlYWwtOTAwOiAjMDA0ZDQwO1xuICAgICAgLS1wYXBlci10ZWFsLWExMDA6ICNhN2ZmZWI7XG4gICAgICAtLXBhcGVyLXRlYWwtYTIwMDogIzY0ZmZkYTtcbiAgICAgIC0tcGFwZXItdGVhbC1hNDAwOiAjMWRlOWI2O1xuICAgICAgLS1wYXBlci10ZWFsLWE3MDA6ICMwMGJmYTU7XG5cbiAgICAgIC0tcGFwZXItZ3JlZW4tNTA6ICNlOGY1ZTk7XG4gICAgICAtLXBhcGVyLWdyZWVuLTEwMDogI2M4ZTZjOTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tMjAwOiAjYTVkNmE3O1xuICAgICAgLS1wYXBlci1ncmVlbi0zMDA6ICM4MWM3ODQ7XG4gICAgICAtLXBhcGVyLWdyZWVuLTQwMDogIzY2YmI2YTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tNTAwOiAjNGNhZjUwO1xuICAgICAgLS1wYXBlci1ncmVlbi02MDA6ICM0M2EwNDc7XG4gICAgICAtLXBhcGVyLWdyZWVuLTcwMDogIzM4OGUzYztcbiAgICAgIC0tcGFwZXItZ3JlZW4tODAwOiAjMmU3ZDMyO1xuICAgICAgLS1wYXBlci1ncmVlbi05MDA6ICMxYjVlMjA7XG4gICAgICAtLXBhcGVyLWdyZWVuLWExMDA6ICNiOWY2Y2E7XG4gICAgICAtLXBhcGVyLWdyZWVuLWEyMDA6ICM2OWYwYWU7XG4gICAgICAtLXBhcGVyLWdyZWVuLWE0MDA6ICMwMGU2NzY7XG4gICAgICAtLXBhcGVyLWdyZWVuLWE3MDA6ICMwMGM4NTM7XG5cbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNTA6ICNmMWY4ZTk7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTEwMDogI2RjZWRjODtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tMjAwOiAjYzVlMWE1O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi0zMDA6ICNhZWQ1ODE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTQwMDogIzljY2M2NTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNTAwOiAjOGJjMzRhO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi02MDA6ICM3Y2IzNDI7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTcwMDogIzY4OWYzODtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tODAwOiAjNTU4YjJmO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi05MDA6ICMzMzY5MWU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWExMDA6ICNjY2ZmOTA7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWEyMDA6ICNiMmZmNTk7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWE0MDA6ICM3NmZmMDM7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWE3MDA6ICM2NGRkMTc7XG5cbiAgICAgIC0tcGFwZXItbGltZS01MDogI2Y5ZmJlNztcbiAgICAgIC0tcGFwZXItbGltZS0xMDA6ICNmMGY0YzM7XG4gICAgICAtLXBhcGVyLWxpbWUtMjAwOiAjZTZlZTljO1xuICAgICAgLS1wYXBlci1saW1lLTMwMDogI2RjZTc3NTtcbiAgICAgIC0tcGFwZXItbGltZS00MDA6ICNkNGUxNTc7XG4gICAgICAtLXBhcGVyLWxpbWUtNTAwOiAjY2RkYzM5O1xuICAgICAgLS1wYXBlci1saW1lLTYwMDogI2MwY2EzMztcbiAgICAgIC0tcGFwZXItbGltZS03MDA6ICNhZmI0MmI7XG4gICAgICAtLXBhcGVyLWxpbWUtODAwOiAjOWU5ZDI0O1xuICAgICAgLS1wYXBlci1saW1lLTkwMDogIzgyNzcxNztcbiAgICAgIC0tcGFwZXItbGltZS1hMTAwOiAjZjRmZjgxO1xuICAgICAgLS1wYXBlci1saW1lLWEyMDA6ICNlZWZmNDE7XG4gICAgICAtLXBhcGVyLWxpbWUtYTQwMDogI2M2ZmYwMDtcbiAgICAgIC0tcGFwZXItbGltZS1hNzAwOiAjYWVlYTAwO1xuXG4gICAgICAtLXBhcGVyLXllbGxvdy01MDogI2ZmZmRlNztcbiAgICAgIC0tcGFwZXIteWVsbG93LTEwMDogI2ZmZjljNDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTIwMDogI2ZmZjU5ZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTMwMDogI2ZmZjE3NjtcbiAgICAgIC0tcGFwZXIteWVsbG93LTQwMDogI2ZmZWU1ODtcbiAgICAgIC0tcGFwZXIteWVsbG93LTUwMDogI2ZmZWIzYjtcbiAgICAgIC0tcGFwZXIteWVsbG93LTYwMDogI2ZkZDgzNTtcbiAgICAgIC0tcGFwZXIteWVsbG93LTcwMDogI2ZiYzAyZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTgwMDogI2Y5YTgyNTtcbiAgICAgIC0tcGFwZXIteWVsbG93LTkwMDogI2Y1N2YxNztcbiAgICAgIC0tcGFwZXIteWVsbG93LWExMDA6ICNmZmZmOGQ7XG4gICAgICAtLXBhcGVyLXllbGxvdy1hMjAwOiAjZmZmZjAwO1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTQwMDogI2ZmZWEwMDtcbiAgICAgIC0tcGFwZXIteWVsbG93LWE3MDA6ICNmZmQ2MDA7XG5cbiAgICAgIC0tcGFwZXItYW1iZXItNTA6ICNmZmY4ZTE7XG4gICAgICAtLXBhcGVyLWFtYmVyLTEwMDogI2ZmZWNiMztcbiAgICAgIC0tcGFwZXItYW1iZXItMjAwOiAjZmZlMDgyO1xuICAgICAgLS1wYXBlci1hbWJlci0zMDA6ICNmZmQ1NGY7XG4gICAgICAtLXBhcGVyLWFtYmVyLTQwMDogI2ZmY2EyODtcbiAgICAgIC0tcGFwZXItYW1iZXItNTAwOiAjZmZjMTA3O1xuICAgICAgLS1wYXBlci1hbWJlci02MDA6ICNmZmIzMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLTcwMDogI2ZmYTAwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItODAwOiAjZmY4ZjAwO1xuICAgICAgLS1wYXBlci1hbWJlci05MDA6ICNmZjZmMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWExMDA6ICNmZmU1N2Y7XG4gICAgICAtLXBhcGVyLWFtYmVyLWEyMDA6ICNmZmQ3NDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWE0MDA6ICNmZmM0MDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWE3MDA6ICNmZmFiMDA7XG5cbiAgICAgIC0tcGFwZXItb3JhbmdlLTUwOiAjZmZmM2UwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMTAwOiAjZmZlMGIyO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMjAwOiAjZmZjYzgwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMzAwOiAjZmZiNzRkO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNDAwOiAjZmZhNzI2O1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNTAwOiAjZmY5ODAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNjAwOiAjZmI4YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNzAwOiAjZjU3YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtODAwOiAjZWY2YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtOTAwOiAjZTY1MTAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTEwMDogI2ZmZDE4MDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLWEyMDA6ICNmZmFiNDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hNDAwOiAjZmY5MTAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTcwMDogI2ZmNjUwMDtcblxuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS01MDogI2ZiZTllNztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtMTAwOiAjZmZjY2JjO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS0yMDA6ICNmZmFiOTE7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTMwMDogI2ZmOGE2NTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNDAwOiAjZmY3MDQzO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS01MDA6ICNmZjU3MjI7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTYwMDogI2Y0NTExZTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNzAwOiAjZTY0YTE5O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS04MDA6ICNkODQzMTU7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTkwMDogI2JmMzYwYztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTEwMDogI2ZmOWU4MDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTIwMDogI2ZmNmU0MDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTQwMDogI2ZmM2QwMDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTcwMDogI2RkMmMwMDtcblxuICAgICAgLS1wYXBlci1icm93bi01MDogI2VmZWJlOTtcbiAgICAgIC0tcGFwZXItYnJvd24tMTAwOiAjZDdjY2M4O1xuICAgICAgLS1wYXBlci1icm93bi0yMDA6ICNiY2FhYTQ7XG4gICAgICAtLXBhcGVyLWJyb3duLTMwMDogI2ExODg3ZjtcbiAgICAgIC0tcGFwZXItYnJvd24tNDAwOiAjOGQ2ZTYzO1xuICAgICAgLS1wYXBlci1icm93bi01MDA6ICM3OTU1NDg7XG4gICAgICAtLXBhcGVyLWJyb3duLTYwMDogIzZkNGM0MTtcbiAgICAgIC0tcGFwZXItYnJvd24tNzAwOiAjNWQ0MDM3O1xuICAgICAgLS1wYXBlci1icm93bi04MDA6ICM0ZTM0MmU7XG4gICAgICAtLXBhcGVyLWJyb3duLTkwMDogIzNlMjcyMztcblxuICAgICAgLS1wYXBlci1ncmV5LTUwOiAjZmFmYWZhO1xuICAgICAgLS1wYXBlci1ncmV5LTEwMDogI2Y1ZjVmNTtcbiAgICAgIC0tcGFwZXItZ3JleS0yMDA6ICNlZWVlZWU7XG4gICAgICAtLXBhcGVyLWdyZXktMzAwOiAjZTBlMGUwO1xuICAgICAgLS1wYXBlci1ncmV5LTQwMDogI2JkYmRiZDtcbiAgICAgIC0tcGFwZXItZ3JleS01MDA6ICM5ZTllOWU7XG4gICAgICAtLXBhcGVyLWdyZXktNjAwOiAjNzU3NTc1O1xuICAgICAgLS1wYXBlci1ncmV5LTcwMDogIzYxNjE2MTtcbiAgICAgIC0tcGFwZXItZ3JleS04MDA6ICM0MjQyNDI7XG4gICAgICAtLXBhcGVyLWdyZXktOTAwOiAjMjEyMTIxO1xuXG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS01MDogI2VjZWZmMTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTEwMDogI2NmZDhkYztcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTIwMDogI2IwYmVjNTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTMwMDogIzkwYTRhZTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTQwMDogIzc4OTA5YztcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTUwMDogIzYwN2Q4YjtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTYwMDogIzU0NmU3YTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTcwMDogIzQ1NWE2NDtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTgwMDogIzM3NDc0ZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTkwMDogIzI2MzIzODtcblxuICAgICAgLyogb3BhY2l0eSBmb3IgZGFyayB0ZXh0IG9uIGEgbGlnaHQgYmFja2dyb3VuZCAqL1xuICAgICAgLS1kYXJrLWRpdmlkZXItb3BhY2l0eTogMC4xMjtcbiAgICAgIC0tZGFyay1kaXNhYmxlZC1vcGFjaXR5OiAwLjM4OyAvKiBvciBoaW50IHRleHQgb3IgaWNvbiAqL1xuICAgICAgLS1kYXJrLXNlY29uZGFyeS1vcGFjaXR5OiAwLjU0O1xuICAgICAgLS1kYXJrLXByaW1hcnktb3BhY2l0eTogMC44NztcblxuICAgICAgLyogb3BhY2l0eSBmb3IgbGlnaHQgdGV4dCBvbiBhIGRhcmsgYmFja2dyb3VuZCAqL1xuICAgICAgLS1saWdodC1kaXZpZGVyLW9wYWNpdHk6IDAuMTI7XG4gICAgICAtLWxpZ2h0LWRpc2FibGVkLW9wYWNpdHk6IDAuMzsgLyogb3IgaGludCB0ZXh0IG9yIGljb24gKi9cbiAgICAgIC0tbGlnaHQtc2Vjb25kYXJ5LW9wYWNpdHk6IDAuNztcbiAgICAgIC0tbGlnaHQtcHJpbWFyeS1vcGFjaXR5OiAxLjA7XG5cbiAgICB9XG5cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9jb2xvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25BMTF5S2V5c0JlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuL2lyb24tY29udHJvbC1zdGF0ZS5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkJ1dHRvblN0YXRlSW1wbCA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgdXNlciBpcyBjdXJyZW50bHkgaG9sZGluZyBkb3duIHRoZSBidXR0b24uXG4gICAgICovXG4gICAgcHJlc3NlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgb2JzZXJ2ZXI6ICdfcHJlc3NlZENoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gdG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIHdpdGggZWFjaCB0YXAgb3IgcHJlc3NcbiAgICAgKiBvZiB0aGUgc3BhY2ViYXIuXG4gICAgICovXG4gICAgdG9nZ2xlczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpcyBjdXJyZW50bHkgaW4gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBhY3RpdmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBieSBhIFwicG9pbnRlcixcIiB3aGljaFxuICAgICAqIGlzIGxvb3NlbHkgZGVmaW5lZCBhcyBtb3VzZSBvciB0b3VjaCBpbnB1dCAoYnV0IHNwZWNpZmljYWxseSBleGNsdWRpbmdcbiAgICAgKiBrZXlib2FyZCBpbnB1dCkuXG4gICAgICovXG4gICAgcG9pbnRlckRvd246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBpbnB1dCBkZXZpY2UgdGhhdCBjYXVzZWQgdGhlIGVsZW1lbnQgdG8gcmVjZWl2ZSBmb2N1c1xuICAgICAqIHdhcyBhIGtleWJvYXJkLlxuICAgICAqL1xuICAgIHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJpYSBhdHRyaWJ1dGUgdG8gYmUgc2V0IGlmIHRoZSBidXR0b24gaXMgYSB0b2dnbGUgYW5kIGluIHRoZVxuICAgICAqIGFjdGl2ZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBhcmlhQWN0aXZlQXR0cmlidXRlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2FyaWEtcHJlc3NlZCcsXG4gICAgICBvYnNlcnZlcjogJ19hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZCdcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgZG93bjogJ19kb3duSGFuZGxlcicsXG4gICAgdXA6ICdfdXBIYW5kbGVyJyxcbiAgICB0YXA6ICdfdGFwSGFuZGxlcidcbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX2ZvY3VzQ2hhbmdlZChmb2N1c2VkKScsXG4gICAgJ19hY3RpdmVDaGFuZ2VkKGFjdGl2ZSwgYXJpYUFjdGl2ZUF0dHJpYnV0ZSknXG4gIF0sXG5cbiAga2V5QmluZGluZ3M6IHtcbiAgICAnZW50ZXI6a2V5ZG93bic6ICdfYXN5bmNDbGljaycsXG4gICAgJ3NwYWNlOmtleWRvd24nOiAnX3NwYWNlS2V5RG93bkhhbmRsZXInLFxuICAgICdzcGFjZTprZXl1cCc6ICdfc3BhY2VLZXlVcEhhbmRsZXInLFxuICB9LFxuXG4gIF9tb3VzZUV2ZW50UmU6IC9ebW91c2UvLFxuXG4gIF90YXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgIC8vIGEgdGFwIGlzIG5lZWRlZCB0byB0b2dnbGUgdGhlIGFjdGl2ZSBzdGF0ZVxuICAgICAgdGhpcy5fdXNlckFjdGl2YXRlKCF0aGlzLmFjdGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIF9mb2N1c0NoYW5nZWQ6IGZ1bmN0aW9uKGZvY3VzZWQpIHtcbiAgICB0aGlzLl9kZXRlY3RLZXlib2FyZEZvY3VzKGZvY3VzZWQpO1xuXG4gICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2RldGVjdEtleWJvYXJkRm9jdXM6IGZ1bmN0aW9uKGZvY3VzZWQpIHtcbiAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKCF0aGlzLnBvaW50ZXJEb3duICYmIGZvY3VzZWQpO1xuICB9LFxuXG4gIC8vIHRvIGVtdWxhdGUgbmF0aXZlIGNoZWNrYm94LCAoZGUtKWFjdGl2YXRpb25zIGZyb20gYSB1c2VyIGludGVyYWN0aW9uIGZpcmVcbiAgLy8gJ2NoYW5nZScgZXZlbnRzXG4gIF91c2VyQWN0aXZhdGU6IGZ1bmN0aW9uKGFjdGl2ZSkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgfVxuICB9LFxuXG4gIF9kb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLl9zZXRQb2ludGVyRG93bih0cnVlKTtcbiAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICAgIHRoaXMuX3NldFJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQoZmFsc2UpO1xuICB9LFxuXG4gIF91cEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldFBvaW50ZXJEb3duKGZhbHNlKTtcbiAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgKi9cbiAgX3NwYWNlS2V5RG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgIHJldHVybjtcblxuICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBrZXlib2FyZEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuX3NldFByZXNzZWQodHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICovXG4gIF9zcGFjZUtleVVwSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIga2V5Ym9hcmRFdmVudCA9IGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50O1xuICAgIHZhciB0YXJnZXQgPSBkb20oa2V5Ym9hcmRFdmVudCkubG9jYWxUYXJnZXQ7XG5cbiAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIHRoaXMgaXMgY29taW5nIGZyb20gYSBmb2N1c2VkIGxpZ2h0IGNoaWxkLCBzaW5jZSB0aGF0XG4gICAgLy8gZWxlbWVudCB3aWxsIGRlYWwgd2l0aCBpdC5cbiAgICBpZiAodGhpcy5pc0xpZ2h0RGVzY2VuZGFudCgvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgdGhpcy5fYXN5bmNDbGljaygpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgfSxcblxuICAvLyB0cmlnZ2VyIGNsaWNrIGFzeW5jaHJvbm91c2x5LCB0aGUgYXN5bmNocm9ueSBpcyB1c2VmdWwgdG8gYWxsb3cgb25lXG4gIC8vIGV2ZW50IGhhbmRsZXIgdG8gdW53aW5kIGJlZm9yZSB0cmlnZ2VyaW5nIGFub3RoZXIgZXZlbnRcbiAgX2FzeW5jQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNsaWNrKCk7XG4gICAgfSwgMSk7XG4gIH0sXG5cbiAgLy8gYW55IG9mIHRoZXNlIGNoYW5nZXMgYXJlIGNvbnNpZGVyZWQgYSBjaGFuZ2UgdG8gYnV0dG9uIHN0YXRlXG5cbiAgX3ByZXNzZWRDaGFuZ2VkOiBmdW5jdGlvbihwcmVzc2VkKSB7XG4gICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gIH0sXG5cbiAgX2FyaWFBY3RpdmVBdHRyaWJ1dGVDaGFuZ2VkOiBmdW5jdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAob2xkVmFsdWUgJiYgb2xkVmFsdWUgIT0gdmFsdWUgJiYgdGhpcy5oYXNBdHRyaWJ1dGUob2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShvbGRWYWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9hY3RpdmVDaGFuZ2VkOiBmdW5jdGlvbihhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpIHtcbiAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSh0aGlzLmFyaWFBY3RpdmVBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlKTtcbiAgICB9XG4gICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gIH0sXG5cbiAgX2NvbnRyb2xTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHByb3ZpZGUgaG9vayBmb3IgZm9sbG93LW9uIGJlaGF2aW9ycyB0byByZWFjdCB0byBidXR0b24tc3RhdGVcblxuICBfY2hhbmdlZEJ1dHRvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9idXR0b25TdGF0ZUNoYW5nZWQoKTsgLy8gYWJzdHJhY3RcbiAgICB9XG4gIH1cblxufTtcblxuZXhwb3J0IGNvbnN0IElyb25CdXR0b25TdGF0ZSA9IFtcbiAgSXJvbkExMXlLZXlzQmVoYXZpb3IsXG4gIElyb25CdXR0b25TdGF0ZUltcGxcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuXG4vKipcbiAqIENocm9tZSB1c2VzIGFuIG9sZGVyIHZlcnNpb24gb2YgRE9NIExldmVsIDMgS2V5Ym9hcmQgRXZlbnRzXG4gKlxuICogTW9zdCBrZXlzIGFyZSBsYWJlbGVkIGFzIHRleHQsIGJ1dCBzb21lIGFyZSBVbmljb2RlIGNvZGVwb2ludHMuXG4gKiBWYWx1ZXMgdGFrZW4gZnJvbTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwNzEyMjEva2V5c2V0Lmh0bWwjS2V5U2V0LVNldFxuICovXG52YXIgS0VZX0lERU5USUZJRVIgPSB7XG4gICdVKzAwMDgnOiAnYmFja3NwYWNlJyxcbiAgJ1UrMDAwOSc6ICd0YWInLFxuICAnVSswMDFCJzogJ2VzYycsXG4gICdVKzAwMjAnOiAnc3BhY2UnLFxuICAnVSswMDdGJzogJ2RlbCdcbn07XG5cbi8qKlxuICogU3BlY2lhbCB0YWJsZSBmb3IgS2V5Ym9hcmRFdmVudC5rZXlDb2RlLlxuICogS2V5Ym9hcmRFdmVudC5rZXlJZGVudGlmaWVyIGlzIGJldHRlciwgYW5kIEtleUJvYXJkRXZlbnQua2V5IGlzIGV2ZW4gYmV0dGVyXG4gKiB0aGFuIHRoYXQuXG4gKlxuICogVmFsdWVzIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50LmtleUNvZGUjVmFsdWVfb2Zfa2V5Q29kZVxuICovXG52YXIgS0VZX0NPREUgPSB7XG4gIDg6ICdiYWNrc3BhY2UnLFxuICA5OiAndGFiJyxcbiAgMTM6ICdlbnRlcicsXG4gIDI3OiAnZXNjJyxcbiAgMzM6ICdwYWdldXAnLFxuICAzNDogJ3BhZ2Vkb3duJyxcbiAgMzU6ICdlbmQnLFxuICAzNjogJ2hvbWUnLFxuICAzMjogJ3NwYWNlJyxcbiAgMzc6ICdsZWZ0JyxcbiAgMzg6ICd1cCcsXG4gIDM5OiAncmlnaHQnLFxuICA0MDogJ2Rvd24nLFxuICA0NjogJ2RlbCcsXG4gIDEwNjogJyonXG59O1xuXG4vKipcbiAqIE1PRElGSUVSX0tFWVMgbWFwcyB0aGUgc2hvcnQgbmFtZSBmb3IgbW9kaWZpZXIga2V5cyB1c2VkIGluIGEga2V5XG4gKiBjb21ibyBzdHJpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWUgdGhhdCByZWZlcmVuY2VzIHRob3NlIHNhbWUga2V5c1xuICogaW4gYSBLZXlib2FyZEV2ZW50IGluc3RhbmNlLlxuICovXG52YXIgTU9ESUZJRVJfS0VZUyA9IHtcbiAgJ3NoaWZ0JzogJ3NoaWZ0S2V5JyxcbiAgJ2N0cmwnOiAnY3RybEtleScsXG4gICdhbHQnOiAnYWx0S2V5JyxcbiAgJ21ldGEnOiAnbWV0YUtleSdcbn07XG5cbi8qKlxuICogS2V5Ym9hcmRFdmVudC5rZXkgaXMgbW9zdGx5IHJlcHJlc2VudGVkIGJ5IHByaW50YWJsZSBjaGFyYWN0ZXIgbWFkZSBieVxuICogdGhlIGtleWJvYXJkLCB3aXRoIHVucHJpbnRhYmxlIGtleXMgbGFiZWxlZCBuaWNlbHkuXG4gKlxuICogSG93ZXZlciwgb24gT1MgWCwgQWx0K2NoYXIgY2FuIG1ha2UgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGZvbGxvd3MgYW5cbiAqIEFwcGxlLXNwZWNpZmljIG1hcHBpbmcuIEluIHRoaXMgY2FzZSwgd2UgZmFsbCBiYWNrIHRvIC5rZXlDb2RlLlxuICovXG52YXIgS0VZX0NIQVIgPSAvW2EtejAtOSpdLztcblxuLyoqXG4gKiBNYXRjaGVzIGEga2V5SWRlbnRpZmllciBzdHJpbmcuXG4gKi9cbnZhciBJREVOVF9DSEFSID0gL1VcXCsvO1xuXG4vKipcbiAqIE1hdGNoZXMgYXJyb3cga2V5cyBpbiBHZWNrbyAyNy4wK1xuICovXG52YXIgQVJST1dfS0VZID0gL15hcnJvdy87XG5cbi8qKlxuICogTWF0Y2hlcyBzcGFjZSBrZXlzIGV2ZXJ5d2hlcmUgKG5vdGFibHkgaW5jbHVkaW5nIElFMTAncyBleGNlcHRpb25hbCBuYW1lXG4gKiBgc3BhY2ViYXJgKS5cbiAqL1xudmFyIFNQQUNFX0tFWSA9IC9ec3BhY2UoYmFyKT8vO1xuXG4vKipcbiAqIE1hdGNoZXMgRVNDIGtleS5cbiAqXG4gKiBWYWx1ZSBmcm9tOiBodHRwOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy1rZXkvI2tleS1Fc2NhcGVcbiAqL1xudmFyIEVTQ19LRVkgPSAvXmVzY2FwZSQvO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIEtleUJvYXJkRXZlbnQua2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtub1NwZWNpYWxDaGFyc10gTGltaXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiB0b1xuICogYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXkoa2V5LCBub1NwZWNpYWxDaGFycykge1xuICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgaWYgKGtleSkge1xuICAgIHZhciBsS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxLZXkgPT09ICcgJyB8fCBTUEFDRV9LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSAnc3BhY2UnO1xuICAgIH0gZWxzZSBpZiAoRVNDX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICB2YWxpZEtleSA9ICdlc2MnO1xuICAgIH0gZWxzZSBpZiAobEtleS5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKCFub1NwZWNpYWxDaGFycyB8fCBLRVlfQ0hBUi50ZXN0KGxLZXkpKSB7XG4gICAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFSUk9XX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICB2YWxpZEtleSA9IGxLZXkucmVwbGFjZSgnYXJyb3cnLCAnJyk7XG4gICAgfSBlbHNlIGlmIChsS2V5ID09ICdtdWx0aXBseScpIHtcbiAgICAgIC8vIG51bXBhZCAnKicgY2FuIG1hcCB0byBNdWx0aXBseSBvbiBJRS9XaW5kb3dzXG4gICAgICB2YWxpZEtleSA9ICcqJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRLZXkgPSBsS2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsaWRLZXk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUtleUlkZW50aWZpZXIoa2V5SWRlbnQpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChrZXlJZGVudCkge1xuICAgIGlmIChrZXlJZGVudCBpbiBLRVlfSURFTlRJRklFUikge1xuICAgICAgdmFsaWRLZXkgPSBLRVlfSURFTlRJRklFUltrZXlJZGVudF07XG4gICAgfSBlbHNlIGlmIChJREVOVF9DSEFSLnRlc3Qoa2V5SWRlbnQpKSB7XG4gICAgICBrZXlJZGVudCA9IHBhcnNlSW50KGtleUlkZW50LnJlcGxhY2UoJ1UrJywgJzB4JyksIDE2KTtcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlJZGVudCkudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRLZXkgPSBrZXlJZGVudC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsaWRLZXk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUtleUNvZGUoa2V5Q29kZSkge1xuICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgaWYgKE51bWJlcihrZXlDb2RlKSkge1xuICAgIGlmIChrZXlDb2RlID49IDY1ICYmIGtleUNvZGUgPD0gOTApIHtcbiAgICAgIC8vIGFzY2lpIGEtelxuICAgICAgLy8gbG93ZXJjYXNlIGlzIDMyIG9mZnNldCBmcm9tIHVwcGVyY2FzZVxuICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsga2V5Q29kZSk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDExMiAmJiBrZXlDb2RlIDw9IDEyMykge1xuICAgICAgLy8gZnVuY3Rpb24ga2V5cyBmMS1mMTJcbiAgICAgIHZhbGlkS2V5ID0gJ2YnICsgKGtleUNvZGUgLSAxMTIgKyAxKTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1Nykge1xuICAgICAgLy8gdG9wIDAtOSBrZXlzXG4gICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gNDgpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSA5NiAmJiBrZXlDb2RlIDw9IDEwNSkge1xuICAgICAgLy8gbnVtIHBhZCAwLTlcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nKGtleUNvZGUgLSA5Nik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0gS0VZX0NPREVba2V5Q29kZV07XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxpZEtleTtcbn1cblxuLyoqXG4gICogQ2FsY3VsYXRlcyB0aGUgbm9ybWFsaXplZCBrZXkgZm9yIGEgS2V5Ym9hcmRFdmVudC5cbiAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGtleUV2ZW50XG4gICogQHBhcmFtIHtCb29sZWFufSBbbm9TcGVjaWFsQ2hhcnNdIFNldCB0byB0cnVlIHRvIGxpbWl0IGtleUV2ZW50LmtleVxuICAqIHRyYW5zZm9ybWF0aW9uIHRvIGFscGhhLW51bWVyaWMgY2hhcnMuIFRoaXMgaXMgdXNlZnVsIHdpdGgga2V5XG4gICogY29tYmluYXRpb25zIGxpa2Ugc2hpZnQgKyAyLCB3aGljaCBvbiBGRiBmb3IgTWFjT1MgcHJvZHVjZXNcbiAgKiBrZXlFdmVudC5rZXkgPSBAXG4gICogVG8gZ2V0IDIgcmV0dXJuZWQsIHNldCBub1NwZWNpYWxDaGFycyA9IHRydWVcbiAgKiBUbyBnZXQgQCByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gZmFsc2VcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplZEtleUZvckV2ZW50KGtleUV2ZW50LCBub1NwZWNpYWxDaGFycykge1xuICAvLyBGYWxsIGJhY2sgZnJvbSAua2V5LCB0byAuZGV0YWlsLmtleSBmb3IgYXJ0aWZpY2FsIGtleWJvYXJkIGV2ZW50cyxcbiAgLy8gYW5kIHRoZW4gdG8gZGVwcmVjYXRlZCAua2V5SWRlbnRpZmllciBhbmQgLmtleUNvZGUuXG4gIGlmIChrZXlFdmVudC5rZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICB9XG4gIGlmIChrZXlFdmVudC5kZXRhaWwgJiYga2V5RXZlbnQuZGV0YWlsLmtleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1LZXkoa2V5RXZlbnQuZGV0YWlsLmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUV2ZW50LmtleUlkZW50aWZpZXIpIHx8XG4gICAgdHJhbnNmb3JtS2V5Q29kZShrZXlFdmVudC5rZXlDb2RlKSB8fCAnJztcbn1cblxuZnVuY3Rpb24ga2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm8sIGV2ZW50KSB7XG4gIC8vIEZvciBjb21ib3Mgd2l0aCBtb2RpZmllcnMgd2Ugc3VwcG9ydCBvbmx5IGFscGhhLW51bWVyaWMga2V5c1xuICB2YXIga2V5RXZlbnQgPSBub3JtYWxpemVkS2V5Rm9yRXZlbnQoZXZlbnQsIGtleUNvbWJvLmhhc01vZGlmaWVycyk7XG4gIHJldHVybiBrZXlFdmVudCA9PT0ga2V5Q29tYm8ua2V5ICYmXG4gICAgKCFrZXlDb21iby5oYXNNb2RpZmllcnMgfHwgKFxuICAgICAgISFldmVudC5zaGlmdEtleSA9PT0gISFrZXlDb21iby5zaGlmdEtleSAmJlxuICAgICAgISFldmVudC5jdHJsS2V5ID09PSAhIWtleUNvbWJvLmN0cmxLZXkgJiZcbiAgICAgICEhZXZlbnQuYWx0S2V5ID09PSAhIWtleUNvbWJvLmFsdEtleSAmJlxuICAgICAgISFldmVudC5tZXRhS2V5ID09PSAhIWtleUNvbWJvLm1ldGFLZXkpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VLZXlDb21ib1N0cmluZyhrZXlDb21ib1N0cmluZykge1xuICBpZiAoa2V5Q29tYm9TdHJpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZyxcbiAgICAgIGtleToga2V5Q29tYm9TdHJpbmcsXG4gICAgICBldmVudDogJ2tleWRvd24nXG4gICAgfTtcbiAgfVxuICByZXR1cm4ga2V5Q29tYm9TdHJpbmcuc3BsaXQoJysnKS5yZWR1Y2UoZnVuY3Rpb24ocGFyc2VkS2V5Q29tYm8sIGtleUNvbWJvUGFydCkge1xuICAgIHZhciBldmVudFBhcnRzID0ga2V5Q29tYm9QYXJ0LnNwbGl0KCc6Jyk7XG4gICAgdmFyIGtleU5hbWUgPSBldmVudFBhcnRzWzBdO1xuICAgIHZhciBldmVudCA9IGV2ZW50UGFydHNbMV07XG5cbiAgICBpZiAoa2V5TmFtZSBpbiBNT0RJRklFUl9LRVlTKSB7XG4gICAgICBwYXJzZWRLZXlDb21ib1tNT0RJRklFUl9LRVlTW2tleU5hbWVdXSA9IHRydWU7XG4gICAgICBwYXJzZWRLZXlDb21iby5oYXNNb2RpZmllcnMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRLZXlDb21iby5rZXkgPSBrZXlOYW1lO1xuICAgICAgcGFyc2VkS2V5Q29tYm8uZXZlbnQgPSBldmVudCB8fCAna2V5ZG93bic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZEtleUNvbWJvO1xuICB9LCB7XG4gICAgY29tYm86IGtleUNvbWJvU3RyaW5nLnNwbGl0KCc6Jykuc2hpZnQoKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFdmVudFN0cmluZyhldmVudFN0cmluZykge1xuICByZXR1cm4gZXZlbnRTdHJpbmcudHJpbSgpLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKGtleUNvbWJvU3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpO1xuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IElyb25BMTF5S2V5c0JlaGF2aW9yID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIEV2ZW50VGFyZ2V0IHRoYXQgd2lsbCBiZSBmaXJpbmcgcmVsZXZhbnQgS2V5Ym9hcmRFdmVudHMuIFNldCBpdCB0b1xuICAgICAqIGBudWxsYCB0byBkaXNhYmxlIHRoZSBsaXN0ZW5lcnMuXG4gICAgICogQHR5cGUgez9FdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBrZXlFdmVudFRhcmdldDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGNhdXNlIHRoZSBpbXBsZW1lbnRpbmcgZWxlbWVudCB0b1xuICAgICAqIGF1dG9tYXRpY2FsbHkgc3RvcCBwcm9wYWdhdGlvbiBvbiBhbnkgaGFuZGxlZCBLZXlib2FyZEV2ZW50cy5cbiAgICAgKi9cbiAgICBzdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIF9ib3VuZEtleUhhbmRsZXJzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBXZSB1c2UgdGhpcyBkdWUgdG8gYSBsaW1pdGF0aW9uIGluIElFMTAgd2hlcmUgaW5zdGFuY2VzIHdpbGwgaGF2ZVxuICAgIC8vIG93biBwcm9wZXJ0aWVzIG9mIGV2ZXJ5dGhpbmcgb24gdGhlIFwicHJvdG90eXBlXCIuXG4gICAgX2ltcGVyYXRpdmVLZXlCaW5kaW5nczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfcmVzZXRLZXlFdmVudExpc3RlbmVycyhrZXlFdmVudFRhcmdldCwgX2JvdW5kS2V5SGFuZGxlcnMpJ1xuICBdLFxuXG5cbiAgLyoqXG4gICAqIFRvIGJlIHVzZWQgdG8gZXhwcmVzcyB3aGF0IGNvbWJpbmF0aW9uIG9mIGtleXMgIHdpbGwgdHJpZ2dlciB0aGUgcmVsYXRpdmVcbiAgICogY2FsbGJhY2suIGUuZy4gYGtleUJpbmRpbmdzOiB7ICdlc2MnOiAnX29uRXNjUHJlc3NlZCd9YFxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICovXG4gIGtleUJpbmRpbmdzOiB7fSxcblxuICByZWdpc3RlcmVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYW4gYmUgdXNlZCB0byBpbXBlcmF0aXZlbHkgYWRkIGEga2V5IGJpbmRpbmcgdG8gdGhlIGltcGxlbWVudGluZ1xuICAgKiBlbGVtZW50LiBUaGlzIGlzIHRoZSBpbXBlcmF0aXZlIGVxdWl2YWxlbnQgb2YgZGVjbGFyaW5nIGEga2V5YmluZGluZ1xuICAgKiBpbiB0aGUgYGtleUJpbmRpbmdzYCBwcm90b3R5cGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlck5hbWVcbiAgICovXG4gIGFkZE93bktleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5nc1tldmVudFN0cmluZ10gPSBoYW5kbGVyTmFtZTtcbiAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gY2FsbGVkLCB3aWxsIHJlbW92ZSBhbGwgaW1wZXJhdGl2ZWx5LWFkZGVkIGtleSBiaW5kaW5ncy5cbiAgICovXG4gIHJlbW92ZU93bktleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MgPSB7fTtcbiAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGtleWJvYXJkIGV2ZW50IG1hdGNoZXMgYGV2ZW50U3RyaW5nYC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRTdHJpbmdcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGtleWJvYXJkRXZlbnRNYXRjaGVzS2V5czogZnVuY3Rpb24oZXZlbnQsIGV2ZW50U3RyaW5nKSB7XG4gICAgdmFyIGtleUNvbWJvcyA9IHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Q29tYm9zLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoa2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm9zW2ldLCBldmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBfY29sbGVjdEtleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLmJlaGF2aW9ycy5tYXAoZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICAgIHJldHVybiBiZWhhdmlvci5rZXlCaW5kaW5ncztcbiAgICB9KTtcblxuICAgIGlmIChrZXlCaW5kaW5ncy5pbmRleE9mKHRoaXMua2V5QmluZGluZ3MpID09PSAtMSkge1xuICAgICAga2V5QmluZGluZ3MucHVzaCh0aGlzLmtleUJpbmRpbmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5QmluZGluZ3M7XG4gIH0sXG5cbiAgX3ByZXBLZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fa2V5QmluZGluZ3MgPSB7fTtcblxuICAgIHRoaXMuX2NvbGxlY3RLZXlCaW5kaW5ncygpLmZvckVhY2goZnVuY3Rpb24oa2V5QmluZGluZ3MpIHtcbiAgICAgIGZvciAodmFyIGV2ZW50U3RyaW5nIGluIGtleUJpbmRpbmdzKSB7XG4gICAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIGtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MpIHtcbiAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5nc1tldmVudFN0cmluZ10pO1xuICAgIH1cblxuICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBjb21ib3Mgd2l0aCBtb2RpZmllcnMgdG8gYmUgY2hlY2tlZCBmaXJzdC5cbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gdGhpcy5fa2V5QmluZGluZ3MpIHtcbiAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV0uc29ydChmdW5jdGlvbiAoa2IxLCBrYjIpIHtcbiAgICAgICAgdmFyIGIxID0ga2IxWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgdmFyIGIyID0ga2IyWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgcmV0dXJuIChiMSA9PT0gYjIpID8gMCA6IGIxID8gLTEgOiAxO1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgX2FkZEtleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpLmZvckVhY2goZnVuY3Rpb24oa2V5Q29tYm8pIHtcbiAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSA9XG4gICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSB8fCBbXTtcblxuICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdLnB1c2goW1xuICAgICAgICBrZXlDb21ibyxcbiAgICAgICAgaGFuZGxlck5hbWVcbiAgICAgIF0pO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF9yZXNldEtleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgfSxcblxuICBfbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5rZXlFdmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9rZXlCaW5kaW5ncykuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIHZhciBrZXlCaW5kaW5ncyA9IHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV07XG4gICAgICB2YXIgYm91bmRLZXlIYW5kbGVyID0gdGhpcy5fb25LZXlCaW5kaW5nRXZlbnQuYmluZCh0aGlzLCBrZXlCaW5kaW5ncyk7XG5cbiAgICAgIHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucHVzaChbdGhpcy5rZXlFdmVudFRhcmdldCwgZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXJdKTtcblxuICAgICAgdGhpcy5rZXlFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfdW5saXN0ZW5LZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleUhhbmRsZXJUdXBsZTtcbiAgICB2YXIga2V5RXZlbnRUYXJnZXQ7XG4gICAgdmFyIGV2ZW50TmFtZTtcbiAgICB2YXIgYm91bmRLZXlIYW5kbGVyO1xuXG4gICAgd2hpbGUgKHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAvLyBNeSBraW5nZG9tIGZvciBibG9jay1zY29wZSBiaW5kaW5nIGFuZCBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQuLlxuICAgICAga2V5SGFuZGxlclR1cGxlID0gdGhpcy5fYm91bmRLZXlIYW5kbGVycy5wb3AoKTtcbiAgICAgIGtleUV2ZW50VGFyZ2V0ID0ga2V5SGFuZGxlclR1cGxlWzBdO1xuICAgICAgZXZlbnROYW1lID0ga2V5SGFuZGxlclR1cGxlWzFdO1xuICAgICAgYm91bmRLZXlIYW5kbGVyID0ga2V5SGFuZGxlclR1cGxlWzJdO1xuXG4gICAgICBrZXlFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uS2V5QmluZGluZ0V2ZW50OiBmdW5jdGlvbihrZXlCaW5kaW5ncywgZXZlbnQpIHtcbiAgICBpZiAodGhpcy5zdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBldmVudCBoYXMgYmVlbiBhbHJlYWR5IHByZXZlbnRlZCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXlDb21ibyA9IGtleUJpbmRpbmdzW2ldWzBdO1xuICAgICAgdmFyIGhhbmRsZXJOYW1lID0ga2V5QmluZGluZ3NbaV1bMV07XG4gICAgICBpZiAoa2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm8sIGV2ZW50KSkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyS2V5SGFuZGxlcihrZXlDb21ibywgaGFuZGxlck5hbWUsIGV2ZW50KTtcbiAgICAgICAgLy8gZXhpdCB0aGUgbG9vcCBpZiBldmVudERlZmF1bHQgd2FzIHByZXZlbnRlZFxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfdHJpZ2dlcktleUhhbmRsZXI6IGZ1bmN0aW9uKGtleUNvbWJvLCBoYW5kbGVyTmFtZSwga2V5Ym9hcmRFdmVudCkge1xuICAgIHZhciBkZXRhaWwgPSBPYmplY3QuY3JlYXRlKGtleUNvbWJvKTtcbiAgICBkZXRhaWwua2V5Ym9hcmRFdmVudCA9IGtleWJvYXJkRXZlbnQ7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGtleUNvbWJvLmV2ZW50LCB7XG4gICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzW2hhbmRsZXJOYW1lXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25Db250cm9sU3RhdGUgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGVsZW1lbnQgY3VycmVudGx5IGhhcyBmb2N1cy5cbiAgICAgKi9cbiAgICBmb2N1c2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgb2JzZXJ2ZXI6ICdfZGlzYWJsZWRDaGFuZ2VkJyxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBfb2xkVGFiSW5kZXg6IHtcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG5cbiAgICBfYm91bmRGb2N1c0JsdXJIYW5kbGVyOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzQmx1ckhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX19oYW5kbGVFdmVudFJldGFyZ2V0aW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2hhZG93Um9vdCAmJiAhRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19jaGFuZ2VkQ29udHJvbFN0YXRlKGZvY3VzZWQsIGRpc2FibGVkKSdcbiAgXSxcblxuICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRm9jdXNCbHVySGFuZGxlciwgdHJ1ZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmRGb2N1c0JsdXJIYW5kbGVyLCB0cnVlKTtcbiAgfSxcblxuICBfZm9jdXNCbHVySGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBJbiBQb2x5bWVyIDIuMCwgdGhlIGxpYnJhcnkgdGFrZXMgY2FyZSBvZiByZXRhcmdldGluZyBldmVudHMuXG4gICAgaWYgKEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTk9URShjZGF0YSk6ICBpZiB3ZSBhcmUgaW4gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGxcbiAgICAvLyBldmVudHVhbGx5IGJlY29tZSBgdGhpc2AgZHVlIHRvIHJldGFyZ2V0aW5nOyBpZiB3ZSBhcmUgbm90IGluXG4gICAgLy8gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGwgZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZVxuICAgIC8vIHRvIHRoZSBzZWNvbmQgY29uZGl0aW9uYWwgd2hpY2ggZmlyZXMgYSBzeW50aGV0aWMgZXZlbnQgKHRoYXQgaXMgYWxzb1xuICAgIC8vIGhhbmRsZWQpLiBJbiBlaXRoZXIgY2FzZSwgd2UgY2FuIGRpc3JlZ2FyZCBgZXZlbnQucGF0aGAuXG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX19oYW5kbGVFdmVudFJldGFyZ2V0aW5nKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyhkb20oZXZlbnQpLmxvY2FsVGFyZ2V0KTtcbiAgICAgIGlmICghdGhpcy5pc0xpZ2h0RGVzY2VuZGFudCh0YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuZmlyZShldmVudC50eXBlLCB7c291cmNlRXZlbnQ6IGV2ZW50fSwge1xuICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgYnViYmxlczogZXZlbnQuYnViYmxlcyxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfZGlzYWJsZWRDaGFuZ2VkOiBmdW5jdGlvbihkaXNhYmxlZCwgb2xkKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCBkaXNhYmxlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIHRoaXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRpc2FibGVkID8gJ25vbmUnIDogJyc7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLl9vbGRUYWJJbmRleCA9IHRoaXMudGFiSW5kZXg7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgIHRoaXMudGFiSW5kZXggPSAtMTtcbiAgICAgIHRoaXMuYmx1cigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb2xkVGFiSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50YWJJbmRleCA9IHRoaXMuX29sZFRhYkluZGV4O1xuICAgIH1cbiAgfSxcblxuICBfY2hhbmdlZENvbnRyb2xTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gX2NvbnRyb2xTdGF0ZUNoYW5nZWQgaXMgYWJzdHJhY3QsIGZvbGxvdy1vbiBiZWhhdmlvcnMgbWF5IGltcGxlbWVudCBpdFxuICAgIGlmICh0aGlzLl9jb250cm9sU3RhdGVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9jb250cm9sU3RhdGVDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFUFNHMzg1NyA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cdHByb2plY3Rpb246IFNwaGVyaWNhbE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgRVBTRzkwMDkxMyA9IFV0aWwuZXh0ZW5kKHt9LCBFUFNHMzg1Nywge1xyXG5cdGNvZGU6ICdFUFNHOjkwMDkxMydcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzM4NTcuanMiLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3JcclxuICpcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIHRoZSBtb3N0IGNvbW1vbiBwcm9qZWN0aW9uIGZvciBvbmxpbmUgbWFwcyxcclxuICogdXNlZCBieSBhbG1vc3QgYWxsIGZyZWUgYW5kIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIEFzc3VtZXMgdGhhdCBFYXJ0aCBpc1xyXG4gKiBhIHNwaGVyZS4gVXNlZCBieSB0aGUgYEVQU0c6Mzg1N2AgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IDYzNzgxMzcsXHJcblx0TUFYX0xBVElUVURFOiA4NS4wNTExMjg3Nzk4LFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgbWF4ID0gdGhpcy5NQVhfTEFUSVRVREUsXHJcblx0XHQgICAgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4obWF4LCBsYXRsbmcubGF0KSwgLW1heCksXHJcblx0XHQgICAgc2luID0gTWF0aC5zaW4obGF0ICogZCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdFx0dGhpcy5SICogbGF0bG5nLmxuZyAqIGQsXHJcblx0XHRcdHRoaXMuUiAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyAyKTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IDYzNzgxMzcgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoWy1kLCAtZF0sIFtkLCBkXSk7XHJcblx0fSkoKVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2dlby9wcm9qZWN0aW9uL1Byb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IuanMiLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8vIEBuYW1lc3BhY2UgU1ZHOyBAc2VjdGlvblxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLlNWRzpcblxuLy8gQGZ1bmN0aW9uIGNyZWF0ZShuYW1lOiBTdHJpbmcpOiBTVkdFbGVtZW50XG4vLyBSZXR1cm5zIGEgaW5zdGFuY2Ugb2YgW1NWR0VsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KSxcbi8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG4vLyBhbiBpbnN0YW5jZSBvZiBbU1ZHTGluZUVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdMaW5lRWxlbWVudCkuXG5leHBvcnQgZnVuY3Rpb24gc3ZnQ3JlYXRlKG5hbWUpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBuYW1lKTtcbn1cblxuLy8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG4vLyBHZW5lcmF0ZXMgYSBTVkcgcGF0aCBzdHJpbmcgZm9yIG11bHRpcGxlIHJpbmdzLCB3aXRoIGVhY2ggcmluZyB0dXJuaW5nXG4vLyBpbnRvIFwiTS4uTC4uTC4uXCIgaW5zdHJ1Y3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzVG9QYXRoKHJpbmdzLCBjbG9zZWQpIHtcblx0dmFyIHN0ciA9ICcnLFxuXHRpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRmb3IgKGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHBvaW50cyA9IHJpbmdzW2ldO1xuXG5cdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdHAgPSBwb2ludHNbal07XG5cdFx0XHRzdHIgKz0gKGogPyAnTCcgOiAnTScpICsgcC54ICsgJyAnICsgcC55O1xuXHRcdH1cblxuXHRcdC8vIGNsb3NlcyB0aGUgcmluZyBmb3IgcG9seWdvbnM7IFwieFwiIGlzIFZNTCBzeW50YXhcblx0XHRzdHIgKz0gY2xvc2VkID8gKEJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHR9XG5cblx0Ly8gU1ZHIGNvbXBsYWlucyBhYm91dCBlbXB0eSBwYXRoIHN0cmluZ3Ncblx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG59XG5cblxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL1NWRy5VdGlsLmpzIiwiaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5cbi8qXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxuICovXG5cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbnZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgVEFHX1dISVRFX0xJU1QgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdPUFRJT04nXTtcblxudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gRG9tRXZlbnQuRG91YmxlVGFwIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhpc1xuZXhwb3J0IHZhciBfcG9pbnRlcnNDb3VudCA9IDA7XG5cbi8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cbi8vIHJlZiBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xuXHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0X2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG5cdFx0X2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdF9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBpZCkge1xuXHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0aWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHR9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaGVuZCcpIHtcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihQT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIGhhbmRsZXIsIGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlclN0YXJ0KG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uRG93biA9IFV0aWwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnICYmIGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgJiYgZS5wb2ludGVyVHlwZSAhPT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSkge1xuXHRcdFx0Ly8gSW4gSUUxMSwgc29tZSB0b3VjaCBldmVudHMgbmVlZHMgdG8gZmlyZSBmb3IgZm9ybSBjb250cm9scywgb3Jcblx0XHRcdC8vIHRoZSBjb250cm9scyB3aWxsIHN0b3Agd29ya2luZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBvZiB0YWcgbmFtZXMgdGhhdFxuXHRcdFx0Ly8gbmVlZCB0aGVzZSBldmVudHMuIEZvciBvdGhlciB0YXJnZXQgdGFncywgd2UgcHJldmVudCBkZWZhdWx0IG9uIHRoZSBldmVudC5cblx0XHRcdGlmIChUQUdfV0hJVEVfTElTVC5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIDwgMCkge1xuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fSk7XG5cblx0b2JqWydfbGVhZmxldF90b3VjaHN0YXJ0JyArIGlkXSA9IG9uRG93bjtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHQvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCBwb2ludGVycyBhbmQgaG93IG1hbnkgYXJlIGFjdGl2ZSB0byBwcm92aWRlIGUudG91Y2hlcyBlbXVsYXRpb25cblx0aWYgKCFfcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0Ly8gd2UgbGlzdGVuIGRvY3VtZW50RWxlbWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX0RPV04sIF9nbG9iYWxQb2ludGVyRG93biwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9NT1ZFLCBfZ2xvYmFsUG9pbnRlck1vdmUsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfQ0FOQ0VMLCBfZ2xvYmFsUG9pbnRlclVwLCB0cnVlKTtcblxuXHRcdF9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHRfcG9pbnRlcnNDb3VudCsrO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcblx0X3BvaW50ZXJzQ291bnQtLTtcbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcikge1xuXHRlLnRvdWNoZXMgPSBbXTtcblx0Zm9yICh2YXIgaSBpbiBfcG9pbnRlcnMpIHtcblx0XHRlLnRvdWNoZXMucHVzaChfcG9pbnRlcnNbaV0pO1xuXHR9XG5cdGUuY2hhbmdlZFRvdWNoZXMgPSBbZV07XG5cblx0aGFuZGxlcihlKTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0dmFyIG9uTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gZG9uJ3QgZmlyZSB0b3VjaCBtb3ZlcyB3aGVuIG1vdXNlIGlzbid0IGRvd25cblx0XHRpZiAoKGUucG9pbnRlclR5cGUgPT09IGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgJiYgZS5idXR0b25zID09PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0X2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdH07XG5cblx0b2JqWydfbGVhZmxldF90b3VjaG1vdmUnICsgaWRdID0gb25Nb3ZlO1xuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihQT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfYWRkUG9pbnRlckVuZChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdHZhciBvblVwID0gZnVuY3Rpb24gKGUpIHtcblx0XHRfaGFuZGxlUG9pbnRlcihlLCBoYW5kbGVyKTtcblx0fTtcblxuXHRvYmpbJ19sZWFmbGV0X3RvdWNoZW5kJyArIGlkXSA9IG9uVXA7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIG9uVXAsIGZhbHNlKTtcblx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIG9uVXAsIGZhbHNlKTtcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9kb20vRG9tRXZlbnQuUG9pbnRlci5qcyIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgZnggPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcbiAqIGZ4LnJ1bihlbCwgWzMwMCwgNTAwXSwgMC41KTtcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cDovL2N1YmljLWJlemllci5jb20vIzAsMCwuNSwxKSxcblx0Ly8gYDAuNWAgYnkgZGVmYXVsdCkuXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7XG5cdFx0dGhpcy5zdG9wKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsO1xuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdHRoaXMuX2R1cmF0aW9uID0gZHVyYXRpb24gfHwgMC4yNTtcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XG5cblx0XHR0aGlzLl9zdGFydFBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcblx0XHR0aGlzLl9zdGVwKCk7XG5cdH0sXG5cblx0X3N0ZXA6IGZ1bmN0aW9uIChyb3VuZCkge1xuXHRcdHZhciBlbGFwc2VkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMuX3N0YXJ0VGltZSxcblx0XHQgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiAqIDEwMDA7XG5cblx0XHRpZiAoZWxhcHNlZCA8IGR1cmF0aW9uKSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSh0aGlzLl9lYXNlT3V0KGVsYXBzZWQgLyBkdXJhdGlvbiksIHJvdW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUoMSk7XG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcnVuRnJhbWU6IGZ1bmN0aW9uIChwcm9ncmVzcywgcm91bmQpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XG5cdFx0aWYgKHJvdW5kKSB7XG5cdFx0XHRwb3MuX3JvdW5kKCk7XG5cdFx0fVxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XG5cblx0XHQvLyBAZXZlbnQgc3RlcDogRXZlbnRcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIHRoZSBhbmltYXRpb24uXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XG5cdH0sXG5cblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Qb3NBbmltYXRpb24uanMiLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBtaW5pY2xhc3MgSWNvbi5EZWZhdWx0IChJY29uKVxuICogQGFrYSBMLkljb24uRGVmYXVsdFxuICogQHNlY3Rpb25cbiAqXG4gKiBBIHRyaXZpYWwgc3ViY2xhc3Mgb2YgYEljb25gLCByZXByZXNlbnRzIHRoZSBpY29uIHRvIHVzZSBpbiBgTWFya2VyYHMgd2hlblxuICogbm8gaWNvbiBpcyBzcGVjaWZpZWQuIFBvaW50cyB0byB0aGUgYmx1ZSBtYXJrZXIgaW1hZ2UgZGlzdHJpYnV0ZWQgd2l0aCBMZWFmbGV0XG4gKiByZWxlYXNlcy5cbiAqXG4gKiBJbiBvcmRlciB0byBjdXN0b21pemUgdGhlIGRlZmF1bHQgaWNvbiwganVzdCBjaGFuZ2UgdGhlIHByb3BlcnRpZXMgb2YgYEwuSWNvbi5EZWZhdWx0LnByb3RvdHlwZS5vcHRpb25zYFxuICogKHdoaWNoIGlzIGEgc2V0IG9mIGBJY29uIG9wdGlvbnNgKS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBfY29tcGxldGVseV8gcmVwbGFjZSB0aGUgZGVmYXVsdCBpY29uLCBvdmVycmlkZSB0aGVcbiAqIGBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5pY29uYCB3aXRoIHlvdXIgb3duIGljb24gaW5zdGVhZC5cbiAqL1xuXG5leHBvcnQgdmFyIEljb25EZWZhdWx0ID0gSWNvbi5leHRlbmQoe1xuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uVXJsOiAgICAgICAnbWFya2VyLWljb24ucG5nJyxcblx0XHRpY29uUmV0aW5hVXJsOiAnbWFya2VyLWljb24tMngucG5nJyxcblx0XHRzaGFkb3dVcmw6ICAgICAnbWFya2VyLXNoYWRvdy5wbmcnLFxuXHRcdGljb25TaXplOiAgICBbMjUsIDQxXSxcblx0XHRpY29uQW5jaG9yOiAgWzEyLCA0MV0sXG5cdFx0cG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuXHRcdHRvb2x0aXBBbmNob3I6IFsxNiwgLTI4XSxcblx0XHRzaGFkb3dTaXplOiAgWzQxLCA0MV1cblx0fSxcblxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoIUljb25EZWZhdWx0LmltYWdlUGF0aCkge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuXHRcdGlmIChwYXRoID09PSBudWxsIHx8IHBhdGguaW5kZXhPZigndXJsJykgIT09IDApIHtcblx0XHRcdHBhdGggPSAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXnVybFxcKFtcIiddPy8sICcnKS5yZXBsYWNlKC9tYXJrZXItaWNvblxcLnBuZ1tcIiddP1xcKSQvLCAnJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvSWNvbi5EZWZhdWx0LmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4vTWFwJztcbmltcG9ydCB7Qm94Wm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Cb3hab29tJztcbk1hcC5Cb3hab29tID0gQm94Wm9vbTtcbmltcG9ydCB7RG91YmxlQ2xpY2tab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRvdWJsZUNsaWNrWm9vbSc7XG5NYXAuRG91YmxlQ2xpY2tab29tID0gRG91YmxlQ2xpY2tab29tO1xuaW1wb3J0IHtEcmFnfSBmcm9tICcuL2hhbmRsZXIvTWFwLkRyYWcnO1xuTWFwLkRyYWcgPSBEcmFnO1xuaW1wb3J0IHtLZXlib2FyZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5LZXlib2FyZCc7XG5NYXAuS2V5Ym9hcmQgPSBLZXlib2FyZDtcbmltcG9ydCB7U2Nyb2xsV2hlZWxab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbSc7XG5NYXAuU2Nyb2xsV2hlZWxab29tID0gU2Nyb2xsV2hlZWxab29tO1xuaW1wb3J0IHtUYXB9IGZyb20gJy4vaGFuZGxlci9NYXAuVGFwJztcbk1hcC5UYXAgPSBUYXA7XG5pbXBvcnQge1RvdWNoWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Ub3VjaFpvb20nO1xuTWFwLlRvdWNoWm9vbSA9IFRvdWNoWm9vbTtcblxuZXhwb3J0IHtNYXAsIGNyZWF0ZU1hcCBhcyBtYXB9IGZyb20gJy4vTWFwJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2luZGV4LmpzIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGFrYSBMLkNvbnRyb2wuQXR0cmlidXRpb25cclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRyb2wgYWxsb3dzIHlvdSB0byBkaXNwbGF5IGF0dHJpYnV0aW9uIGRhdGEgaW4gYSBzbWFsbCB0ZXh0IGJveCBvbiBhIG1hcC4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2BhdHRyaWJ1dGlvbkNvbnRyb2xgIG9wdGlvbl0oI21hcC1hdHRyaWJ1dGlvbmNvbnRyb2wpIHRvIGBmYWxzZWAsIGFuZCBpdCBmZXRjaGVzIGF0dHJpYnV0aW9uIHRleHRzIGZyb20gbGF5ZXJzIHdpdGggdGhlIFtgZ2V0QXR0cmlidXRpb25gIG1ldGhvZF0oI2xheWVyLWdldGF0dHJpYnV0aW9uKSBhdXRvbWF0aWNhbGx5LiBFeHRlbmRzIENvbnRyb2wuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBBdHRyaWJ1dGlvbiA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICdib3R0b21yaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBwcmVmaXg6IFN0cmluZyA9ICdMZWFmbGV0J1xyXG5cdFx0Ly8gVGhlIEhUTUwgdGV4dCBzaG93biBiZWZvcmUgdGhlIGF0dHJpYnV0aW9ucy4gUGFzcyBgZmFsc2VgIHRvIGRpc2FibGUuXHJcblx0XHRwcmVmaXg6ICc8YSBocmVmPVwiaHR0cDovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSlMgbGlicmFyeSBmb3IgaW50ZXJhY3RpdmUgbWFwc1wiPkxlYWZsZXQ8L2E+J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRpb25zID0ge307XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hdHRyaWJ1dGlvbkNvbnRyb2wgPSB0aGlzO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24nKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB0ZXh0IGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5BdHRyaWJ1dGlvbi5qcyIsImltcG9ydCB7Q29udHJvbCwgY29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCB7TGF5ZXJzLCBsYXllcnN9IGZyb20gJy4vQ29udHJvbC5MYXllcnMnO1xuaW1wb3J0IHtab29tLCB6b29tfSBmcm9tICcuL0NvbnRyb2wuWm9vbSc7XG5pbXBvcnQge1NjYWxlLCBzY2FsZX0gZnJvbSAnLi9Db250cm9sLlNjYWxlJztcbmltcG9ydCB7QXR0cmlidXRpb24sIGF0dHJpYnV0aW9ufSBmcm9tICcuL0NvbnRyb2wuQXR0cmlidXRpb24nO1xuXG5Db250cm9sLkxheWVycyA9IExheWVycztcbkNvbnRyb2wuWm9vbSA9IFpvb207XG5Db250cm9sLlNjYWxlID0gU2NhbGU7XG5Db250cm9sLkF0dHJpYnV0aW9uID0gQXR0cmlidXRpb247XG5cbmNvbnRyb2wubGF5ZXJzID0gbGF5ZXJzO1xuY29udHJvbC56b29tID0gem9vbTtcbmNvbnRyb2wuc2NhbGUgPSBzY2FsZTtcbmNvbnRyb2wuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvbjtcblxuZXhwb3J0IHtDb250cm9sLCBjb250cm9sfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9pbmRleC5qcyIsImV4cG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuZXhwb3J0IHtMYXllckdyb3VwLCBsYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xuZXhwb3J0IHtGZWF0dXJlR3JvdXAsIGZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuaW1wb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29uLCBnZW9tZXRyeVRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCBjb29yZHNUb0xhdExuZ3MsIGxhdExuZ1RvQ29vcmRzLCBsYXRMbmdzVG9Db29yZHMsIGdldEZlYXR1cmUsIGFzRmVhdHVyZX0gZnJvbSAnLi9HZW9KU09OJztcbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcbmV4cG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbn07XG5cbmV4cG9ydCB7SW1hZ2VPdmVybGF5LCBpbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmV4cG9ydCB7VmlkZW9PdmVybGF5LCB2aWRlb092ZXJsYXl9IGZyb20gJy4vVmlkZW9PdmVybGF5JztcblxuZXhwb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuZXhwb3J0IHtQb3B1cCwgcG9wdXB9IGZyb20gJy4vUG9wdXAnO1xuZXhwb3J0IHtUb29sdGlwLCB0b29sdGlwfSBmcm9tICcuL1Rvb2x0aXAnO1xuXG5leHBvcnQgKiBmcm9tICcuL21hcmtlci9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3RpbGUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi92ZWN0b3IvaW5kZXgnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9pbmRleC5qcyIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kcywgdG9MYXRMbmdCb3VuZHMgYXMgbGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuZXhwb3J0IHZhciBHcmlkTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgR3JpZExheWVyIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gdGlsZVNpemU6IE51bWJlcnxQb2ludCA9IDI1NlxuXHRcdC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGlsZXMgaW4gdGhlIGdyaWQuIFVzZSBhIG51bWJlciBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBlcXVhbCwgb3IgYEwucG9pbnQod2lkdGgsIGhlaWdodClgIG90aGVyd2lzZS5cblx0XHR0aWxlU2l6ZTogMjU2LFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcblx0XHQvLyBPcGFjaXR5IG9mIHRoZSB0aWxlcy4gQ2FuIGJlIHVzZWQgaW4gdGhlIGBjcmVhdGVUaWxlKClgIGZ1bmN0aW9uLlxuXHRcdG9wYWNpdHk6IDEsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gKGRlcGVuZHMpXG5cdFx0Ly8gTG9hZCBuZXcgdGlsZXMgb25seSB3aGVuIHBhbm5pbmcgZW5kcy5cblx0XHQvLyBgdHJ1ZWAgYnkgZGVmYXVsdCBvbiBtb2JpbGUgYnJvd3NlcnMsIGluIG9yZGVyIHRvIGF2b2lkIHRvbyBtYW55IHJlcXVlc3RzIGFuZCBrZWVwIHNtb290aCBuYXZpZ2F0aW9uLlxuXHRcdC8vIGBmYWxzZWAgb3RoZXJ3aXNlIGluIG9yZGVyIHRvIGRpc3BsYXkgbmV3IHRpbGVzIF9kdXJpbmdfIHBhbm5pbmcsIHNpbmNlIGl0IGlzIGVhc3kgdG8gcGFuIG91dHNpZGUgdGhlXG5cdFx0Ly8gW2BrZWVwQnVmZmVyYF0oI2dyaWRsYXllci1rZWVwYnVmZmVyKSBvcHRpb24gaW4gZGVza3RvcCBicm93c2Vycy5cblx0XHR1cGRhdGVXaGVuSWRsZTogQnJvd3Nlci5tb2JpbGUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5ab29taW5nOiBCb29sZWFuID0gdHJ1ZVxuXHRcdC8vIEJ5IGRlZmF1bHQsIGEgc21vb3RoIHpvb20gYW5pbWF0aW9uIChkdXJpbmcgYSBbdG91Y2ggem9vbV0oI21hcC10b3VjaHpvb20pIG9yIGEgW2BmbHlUbygpYF0oI21hcC1mbHl0bykpIHdpbGwgdXBkYXRlIGdyaWQgbGF5ZXJzIGV2ZXJ5IGludGVnZXIgem9vbSBsZXZlbC4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHdpbGwgdXBkYXRlIHRoZSBncmlkIGxheWVyIG9ubHkgd2hlbiB0aGUgc21vb3RoIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHVwZGF0ZVdoZW5ab29taW5nOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiB1cGRhdGVJbnRlcnZhbDogTnVtYmVyID0gMjAwXG5cdFx0Ly8gVGlsZXMgd2lsbCBub3QgdXBkYXRlIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGB1cGRhdGVJbnRlcnZhbGAgbWlsbGlzZWNvbmRzIHdoZW4gcGFubmluZy5cblx0XHR1cGRhdGVJbnRlcnZhbDogMjAwLFxuXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXg6IE51bWJlciA9IDFcblx0XHQvLyBUaGUgZXhwbGljaXQgekluZGV4IG9mIHRoZSB0aWxlIGxheWVyLlxuXHRcdHpJbmRleDogMSxcblxuXHRcdC8vIEBvcHRpb24gYm91bmRzOiBMYXRMbmdCb3VuZHMgPSB1bmRlZmluZWRcblx0XHQvLyBJZiBzZXQsIHRpbGVzIHdpbGwgb25seSBiZSBsb2FkZWQgaW5zaWRlIHRoZSBzZXQgYExhdExuZ0JvdW5kc2AuXG5cdFx0Ym91bmRzOiBudWxsLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXG5cdFx0Ly8gVGhlIG1pbmltdW0gem9vbSBsZXZlbCBkb3duIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWluWm9vbTogMCxcblxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWF4TmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWF4aW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXG5cdFx0Ly8gZnJvbSBgbWF4TmF0aXZlWm9vbWAgbGV2ZWwgYW5kIGF1dG8tc2NhbGVkLlxuXHRcdG1heE5hdGl2ZVpvb206IHVuZGVmaW5lZCxcblxuXHRcdC8vIEBvcHRpb24gbWluTmF0aXZlWm9vbTogTnVtYmVyID0gdW5kZWZpbmVkXG5cdFx0Ly8gTWluaW11bSB6b29tIG51bWJlciB0aGUgdGlsZSBzb3VyY2UgaGFzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc3BlY2lmaWVkLFxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgbG93ZXIgdGhhbiBgbWluTmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtaW5OYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWluTmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuIENhbiBiZSB1c2VkXG5cdFx0Ly8gaW4gY29tYmluYXRpb24gd2l0aCBbYGJvdW5kc2BdKCNncmlkbGF5ZXItYm91bmRzKSB0byBwcmV2ZW50IHJlcXVlc3Rpbmdcblx0XHQvLyB0aWxlcyBvdXRzaWRlIHRoZSBDUlMgbGltaXRzLlxuXHRcdG5vV3JhcDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICd0aWxlUGFuZSdcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBncmlkIGxheWVyIHdpbGwgYmUgYWRkZWQuXG5cdFx0cGFuZTogJ3RpbGVQYW5lJyxcblxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSB0aWxlIGxheWVyLiBFbXB0eSBieSBkZWZhdWx0LlxuXHRcdGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBAb3B0aW9uIGtlZXBCdWZmZXI6IE51bWJlciA9IDJcblx0XHQvLyBXaGVuIHBhbm5pbmcgdGhlIG1hcCwga2VlcCB0aGlzIG1hbnkgcm93cyBhbmQgY29sdW1ucyBvZiB0aWxlcyBiZWZvcmUgdW5sb2FkaW5nIHRoZW0uXG5cdFx0a2VlcEJ1ZmZlcjogMlxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xuXG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcblxuXHRcdHRoaXMuX3Jlc2V0VmlldygpO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5fYWRkWm9vbUxpbWl0KHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdG1hcC5fcmVtb3ZlWm9vbUxpbWl0KHRoaXMpO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdFx0dGhpcy5fdGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQ6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSB0b3Agb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgoTWF0aC5tYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgdGlsZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCB0aWxlIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHREb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW29wYWNpdHldKCNncmlkbGF5ZXItb3BhY2l0eSkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFpJbmRleCh6SW5kZXg6IE51bWJlcik6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2dyaWRsYXllci16aW5kZXgpIG9mIHRoZSBncmlkIGxheWVyLlxuXHRzZXRaSW5kZXg6IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gekluZGV4O1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0xvYWRpbmc6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IHRpbGUgaW4gdGhlIGdyaWQgbGF5ZXIgaGFzIG5vdCBmaW5pc2hlZCBsb2FkaW5nLlxuXHRpc0xvYWRpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGluZztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlZHJhdzogdGhpc1xuXHQvLyBDYXVzZXMgdGhlIGxheWVyIHRvIGNsZWFyIGFsbCB0aGUgdGlsZXMgYW5kIHJlcXVlc3QgdGhlbSBhZ2Fpbi5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBVdGlsLmZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGVMZXZlbCh6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGVzQXRab29tKHopO1xuXHRcdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGV2ZWxzW3pdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKCFsZXZlbCkge1xuXHRcdFx0bGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0gPSB7fTtcblxuXHRcdFx0bGV2ZWwuZWwgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdGlsZS1jb250YWluZXIgbGVhZmxldC16b29tLWFuaW1hdGVkJywgdGhpcy5fY29udGFpbmVyKTtcblx0XHRcdGxldmVsLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb207XG5cblx0XHRcdGxldmVsLm9yaWdpbiA9IG1hcC5wcm9qZWN0KG1hcC51bnByb2plY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpLCB6b29tKS5yb3VuZCgpO1xuXHRcdFx0bGV2ZWwuem9vbSA9IHpvb207XG5cblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obGV2ZWwsIG1hcC5nZXRDZW50ZXIoKSwgbWFwLmdldFpvb20oKSk7XG5cblx0XHRcdC8vIGZvcmNlIHRoZSBicm93c2VyIHRvIGNvbnNpZGVyIHRoZSBuZXdseSBhZGRlZCBlbGVtZW50IGZvciB0cmFuc2l0aW9uXG5cdFx0XHRVdGlsLmZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXG5cdFx0XHR0aGlzLl9vbkNyZWF0ZUxldmVsKGxldmVsKTtcblx0XHR9XG5cblx0XHR0aGlzLl9sZXZlbCA9IGxldmVsO1xuXG5cdFx0cmV0dXJuIGxldmVsO1xuXHR9LFxuXG5cdF9vblVwZGF0ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uUmVtb3ZlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfb25DcmVhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9wcnVuZVRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIga2V5LCB0aWxlO1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuXHRcdGlmICh6b29tID4gdGhpcy5vcHRpb25zLm1heFpvb20gfHxcblx0XHRcdHpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRpbGUuY3VycmVudDtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAodGlsZS5jdXJyZW50ICYmICF0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gdGlsZS5jb29yZHM7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV0YWluUGFyZW50KGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56IC0gNSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiArIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5yZXRhaW4pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlVGlsZXNBdFpvb206IGZ1bmN0aW9uICh6b29tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fdGlsZXNba2V5XS5jb29yZHMueiAhPT0gem9vbSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZUFsbFRpbGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbnZhbGlkYXRlQWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgeiBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2xldmVsc1t6XS5lbCk7XG5cdFx0XHR0aGlzLl9vblJlbW92ZUxldmVsKHopO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKE1hdGgucm91bmQoem9vbSkpO1xuXHRcdGlmICgodGhpcy5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSB8fFxuXHRcdCAgICAodGhpcy5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB0aWxlWm9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSkge1xuXHRcdFx0dGlsZVpvb20gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXG5cdFx0Ly8gdW5sZXNzIHdlJ3JlIG9uIEFuZHJvaWQncyBzdG9jayBicm93c2VyLFxuXHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xMzdcblx0XHRpZiAoIUJyb3dzZXIuYW5kcm9pZFN0b2NrKSB7XG5cdFx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcblx0XHR9XG5cdFx0RG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZSwgJ2xlYWZsZXQtdGlsZScpO1xuXG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlU2l6ZS54ICsgJ3B4Jztcblx0XHR0aWxlLnN0eWxlLmhlaWdodCA9IHRpbGVTaXplLnkgKyAncHgnO1xuXG5cdFx0dGlsZS5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xuXHRcdHRpbGUub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChCcm93c2VyLmllbHQ5ICYmIHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHQvLyB3aXRob3V0IHRoaXMgaGFjaywgdGlsZXMgZGlzYXBwZWFyIGFmdGVyIHpvb20gb24gQ2hyb21lIGZvciBBbmRyb2lkXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjA3OFxuXHRcdGlmIChCcm93c2VyLmFuZHJvaWQgJiYgIUJyb3dzZXIuYW5kcm9pZDIzKSB7XG5cdFx0XHR0aWxlLnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgMCk7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGlsZS5lbCwgJ2xlYWZsZXQtdGlsZS1sb2FkZWQnKTtcblxuXHRcdFx0Ly8gQGV2ZW50IHRpbGVsb2FkOiBUaWxlRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGxvYWRzLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlbG9hZCcsIHtcblx0XHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub1RpbGVzVG9Mb2FkKCkpIHtcblx0XHRcdHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBsb2FkZWQgYWxsIHZpc2libGUgdGlsZXMuXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcblxuXHRcdFx0aWYgKEJyb3dzZXIuaWVsdDkgfHwgIXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoVXRpbC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IFBvaW50KFxuXHRcdFx0dGhpcy5fd3JhcFggPyBVdGlsLndyYXBOdW0oY29vcmRzLngsIHRoaXMuX3dyYXBYKSA6IGNvb3Jkcy54LFxuXHRcdFx0dGhpcy5fd3JhcFkgPyBVdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMoXG5cdFx0XHRib3VuZHMubWluLnVuc2NhbGVCeSh0aWxlU2l6ZSkuZmxvb3IoKSxcblx0XHRcdGJvdW5kcy5tYXgudW5zY2FsZUJ5KHRpbGVTaXplKS5jZWlsKCkuc3VidHJhY3QoWzEsIDFdKSk7XG5cdH0sXG5cblx0X25vVGlsZXNUb0xvYWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICghdGhpcy5fdGlsZXNba2V5XS5sb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5ncmlkTGF5ZXIob3B0aW9ucz86IEdyaWRMYXllciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBHcmlkTGF5ZXIgd2l0aCB0aGUgc3VwcGxpZWQgb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBncmlkTGF5ZXIob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEdyaWRMYXllcihvcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9HcmlkTGF5ZXIuanMiLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIENhbnZhc1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuQ2FudmFzXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW2A8Y2FudmFzPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNfQVBJKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCBVdGlsLnRocm90dGxlKHRoaXMuX29uTW91c2VNb3ZlLCAzMiwgdGhpcyksIHRoaXMpO1xuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIGNvbnRleHRtZW51JywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9oYW5kbGVNb3VzZU91dCwgdGhpcyk7XG5cblx0XHR0aGlzLl9jdHggPSBjb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9jdHg7XG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHREb21FdmVudC5vZmYodGhpcy5fY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fY29udGFpbmVyO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3N0cG9uZVVwZGF0ZVBhdGhzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGxheWVyO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRsYXllci5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHRoaXMuX3JlZHJhdygpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzID0ge307XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbTC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KCcsJyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChOdW1iZXIocGFydHNbaV0pKTtcblx0XHRcdH1cblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKGxheWVyKTtcblx0XHR0aGlzLl9yZWRyYXdSZXF1ZXN0ID0gdGhpcy5fcmVkcmF3UmVxdWVzdCB8fCBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcmVkcmF3LCB0aGlzKTtcblx0fSxcblxuXHRfZXh0ZW5kUmVkcmF3Qm91bmRzOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3B4Qm91bmRzKSB7XG5cdFx0XHR2YXIgcGFkZGluZyA9IChsYXllci5vcHRpb25zLndlaWdodCB8fCAwKSArIDE7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSB0aGlzLl9yZWRyYXdCb3VuZHMgfHwgbmV3IEJvdW5kcygpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWluLnN1YnRyYWN0KFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYgKHRoaXMuX3JlZHJhd0JvdW5kcykge1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1pbi5fZmxvb3IoKTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jbGVhcigpOyAvLyBjbGVhciBsYXllcnMgaW4gcmVkcmF3IGJvdW5kc1xuXHRcdHRoaXMuX2RyYXcoKTsgLy8gZHJhdyBsYXllcnNcblxuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IG51bGw7XG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY29udGFpbmVyLndpZHRoLCB0aGlzLl9jb250YWluZXIuaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXIsIGJvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcztcblx0XHR0aGlzLl9jdHguc2F2ZSgpO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuX2N0eC5yZWN0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBzaXplLngsIHNpemUueSk7XG5cdFx0XHR0aGlzLl9jdHguY2xpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYXdpbmcgPSB0cnVlO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXHRcdGlmICghdGhpcy5fZHJhd2luZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBpLCBqLCBsZW4yLCBwLFxuXHRcdCAgICBwYXJ0cyA9IGxheWVyLl9wYXJ0cyxcblx0XHQgICAgbGVuID0gcGFydHMubGVuZ3RoLFxuXHRcdCAgICBjdHggPSB0aGlzLl9jdHg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXSA9IGxheWVyO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdHRoaXMuX2RyYXduTGF5ZXJzW2xheWVyLl9sZWFmbGV0X2lkXSA9IGxheWVyO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc2NhbGUoMSwgcyk7XG5cdFx0fVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmMocC54LCBwLnkgLyBzLCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXG5cdFx0aWYgKHMgIT09IDEpIHtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblx0fSxcblxuXHRfZmlsbFN0cm9rZTogZnVuY3Rpb24gKGN0eCwgbGF5ZXIpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRjdHguZmlsbChvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlICYmIG9wdGlvbnMud2VpZ2h0ICE9PSAwKSB7XG5cdFx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChsYXllci5vcHRpb25zICYmIGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSB8fCBbXSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmxpbmVDYXAgPSBvcHRpb25zLmxpbmVDYXA7XG5cdFx0XHRjdHgubGluZUpvaW4gPSBvcHRpb25zLmxpbmVKb2luO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDYW52YXMgb2J2aW91c2x5IGRvZXNuJ3QgaGF2ZSBtb3VzZSBldmVudHMgZm9yIGluZGl2aWR1YWwgZHJhd24gb2JqZWN0cyxcblx0Ly8gc28gd2UgZW11bGF0ZSB0aGF0IGJ5IGNhbGN1bGF0aW5nIHdoYXQncyB1bmRlciB0aGUgbW91c2Ugb24gbW91c2Vtb3ZlL2NsaWNrIG1hbnVhbGx5XG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksIGxheWVyLCBjbGlja2VkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSAmJiAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbGlja2VkTGF5ZXIpICB7XG5cdFx0XHREb21FdmVudC5mYWtlU3RvcChlKTtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2xpY2tlZExheWVyXSwgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdHZhciBsYXllciwgY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0Y2FuZGlkYXRlSG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllciAhPT0gdGhpcy5faG92ZXJlZExheWVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlKTtcblxuXHRcdFx0aWYgKGNhbmRpZGF0ZUhvdmVyZWRMYXllcikge1xuXHRcdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTsgLy8gY2hhbmdlIGN1cnNvclxuXHRcdFx0XHR0aGlzLl9maXJlRXZlbnQoW2NhbmRpZGF0ZUhvdmVyZWRMYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gY2FuZGlkYXRlSG92ZXJlZExheWVyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZpcmVFdmVudChbdGhpcy5faG92ZXJlZExheWVyXSwgZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uIChsYXllcnMsIGUsIHR5cGUpIHtcblx0XHR0aGlzLl9tYXAuX2ZpcmVET01FdmVudChlLCB0eXBlIHx8IGUudHlwZSwgbGF5ZXJzKTtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXI7XG5cdFx0dmFyIG5leHQgPSBvcmRlci5uZXh0O1xuXHRcdHZhciBwcmV2ID0gb3JkZXIucHJldjtcblxuXHRcdGlmIChuZXh0KSB7XG5cdFx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBbHJlYWR5IGxhc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHQvLyBVcGRhdGUgZmlyc3QgZW50cnkgdW5sZXNzIHRoaXMgaXMgdGhlXG5cdFx0XHQvLyBzaW5nbGUgZW50cnlcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IHRoaXMuX2RyYXdMYXN0O1xuXHRcdHRoaXMuX2RyYXdMYXN0Lm5leHQgPSBvcmRlcjtcblxuXHRcdG9yZGVyLm5leHQgPSBudWxsO1xuXHRcdHRoaXMuX2RyYXdMYXN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgZmlyc3Rcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIGlmIChwcmV2KSB7XG5cdFx0XHQvLyBVcGRhdGUgbGFzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0xhc3QgPSBwcmV2O1xuXHRcdH1cblxuXHRcdG9yZGVyLnByZXYgPSBudWxsO1xuXG5cdFx0b3JkZXIubmV4dCA9IHRoaXMuX2RyYXdGaXJzdDtcblx0XHR0aGlzLl9kcmF3Rmlyc3QucHJldiA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IG9yZGVyO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNhbnZhcyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBjYW52YXMob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5jYW52YXMgPyBuZXcgQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NhbnZhcy5qcyIsImltcG9ydCB7Q2lyY2xlTWFya2VyfSBmcm9tICcuL0NpcmNsZU1hcmtlcic7XG5pbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcbmltcG9ydCB7RWFydGh9IGZyb20gJy4uLy4uL2dlby9jcnMvQ1JTLkVhcnRoJztcblxuXG4vKlxuICogQGNsYXNzIENpcmNsZVxuICogQGFrYSBMLkNpcmNsZVxuICogQGluaGVyaXRzIENpcmNsZU1hcmtlclxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgY2lyY2xlIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBDaXJjbGVNYXJrZXJgLlxuICpcbiAqIEl0J3MgYW4gYXBwcm94aW1hdGlvbiBhbmQgc3RhcnRzIHRvIGRpdmVyZ2UgZnJvbSBhIHJlYWwgY2lyY2xlIGNsb3NlciB0byBwb2xlcyAoZHVlIHRvIHByb2plY3Rpb24gZGlzdG9ydGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jaXJjbGUoWzUwLjUsIDMwLjVdLCB7cmFkaXVzOiAyMDB9KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBDaXJjbGUgPSBDaXJjbGVNYXJrZXIuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuXHRcdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBmYWN0b3J5IChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucz8pXG5cdFx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxlZ2FjeU9wdGlvbnMsIHtyYWRpdXM6IG9wdGlvbnN9KTtcblx0XHR9XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cblx0XHRpZiAoaXNOYU4odGhpcy5vcHRpb25zLnJhZGl1cykpIHsgdGhyb3cgbmV3IEVycm9yKCdDaXJjbGUgcmFkaXVzIGNhbm5vdCBiZSBOYU4nKTsgfVxuXG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIENpcmNsZSBvcHRpb25zXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlcjsgUmFkaXVzIG9mIHRoZSBjaXJjbGUsIGluIG1ldGVycy5cblx0XHR0aGlzLl9tUmFkaXVzID0gdGhpcy5vcHRpb25zLnJhZGl1cztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldFJhZGl1cyhyYWRpdXM6IE51bWJlcik6IHRoaXNcblx0Ly8gU2V0cyB0aGUgcmFkaXVzIG9mIGEgY2lyY2xlLiBVbml0cyBhcmUgaW4gbWV0ZXJzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLl9tUmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21SYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzXG5cdC8vIFJldHVybnMgdGhlIGBMYXRMbmdCb3VuZHNgIG9mIHRoZSBwYXRoLlxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaGFsZiA9IFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzXTtcblxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBQYXRoLnByb3RvdHlwZS5zZXRTdHlsZSxcblxuXHRfcHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGxuZyA9IHRoaXMuX2xhdGxuZy5sbmcsXG5cdFx0ICAgIGxhdCA9IHRoaXMuX2xhdGxuZy5sYXQsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKGNycy5kaXN0YW5jZSA9PT0gRWFydGguZGlzdGFuY2UpIHtcblx0XHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdCAgICBsYXRSID0gKHRoaXMuX21SYWRpdXMgLyBFYXJ0aC5SKSAvIGQsXG5cdFx0XHQgICAgdG9wID0gbWFwLnByb2plY3QoW2xhdCArIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIGJvdHRvbSA9IG1hcC5wcm9qZWN0KFtsYXQgLSBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBwID0gdG9wLmFkZChib3R0b20pLmRpdmlkZUJ5KDIpLFxuXHRcdFx0ICAgIGxhdDIgPSBtYXAudW5wcm9qZWN0KHApLmxhdCxcblx0XHRcdCAgICBsbmdSID0gTWF0aC5hY29zKChNYXRoLmNvcyhsYXRSICogZCkgLSBNYXRoLnNpbihsYXQgKiBkKSAqIE1hdGguc2luKGxhdDIgKiBkKSkgL1xuXHRcdFx0ICAgICAgICAgICAgKE1hdGguY29zKGxhdCAqIGQpICogTWF0aC5jb3MobGF0MiAqIGQpKSkgLyBkO1xuXG5cdFx0XHRpZiAoaXNOYU4obG5nUikgfHwgbG5nUiA9PT0gMCkge1xuXHRcdFx0XHRsbmdSID0gbGF0UiAvIE1hdGguY29zKE1hdGguUEkgLyAxODAgKiBsYXQpOyAvLyBGYWxsYmFjayBmb3IgZWRnZSBjYXNlLCAjMjQyNVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9wb2ludCA9IHAuc3VidHJhY3QobWFwLmdldFBpeGVsT3JpZ2luKCkpO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gaXNOYU4obG5nUikgPyAwIDogcC54IC0gbWFwLnByb2plY3QoW2xhdDIsIGxuZyAtIGxuZ1JdKS54O1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IHAueSAtIHRvcC55O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsYXRsbmcyID0gY3JzLnVucHJvamVjdChjcnMucHJvamVjdCh0aGlzLl9sYXRsbmcpLnN1YnRyYWN0KFt0aGlzLl9tUmFkaXVzLCAwXSkpO1xuXG5cdFx0XHR0aGlzLl9wb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMuX3BvaW50LnggLSBtYXAubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzIpLng7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZShsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbnMgb2JqZWN0XG4vLyB3aGljaCBjb250YWlucyB0aGUgY2lyY2xlIHJhZGl1cy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIHJhZGl1czogTnVtYmVyLCBvcHRpb25zPzogQ2lyY2xlIG9wdGlvbnMpXG4vLyBPYnNvbGV0ZSB3YXkgb2YgaW5zdGFudGlhdGluZyBhIGNpcmNsZSwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAwLjcueCBjb2RlLlxuLy8gRG8gbm90IHVzZSBpbiBuZXcgYXBwbGljYXRpb25zIG9yIHBsdWdpbnMuXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IENpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzIiwiaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi9MaW5lVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIFBvbHlVdGlsXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHBvbHlnb24gZ2VvbWV0cmllcy5cclxuICovXHJcblxyXG4vKiBAZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzOiBQb2ludFtdLCBib3VuZHM6IEJvdW5kcywgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXVxyXG4gKiBDbGlwcyB0aGUgcG9seWdvbiBnZW9tZXRyeSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBgcG9pbnRzYCBieSB0aGUgZ2l2ZW4gYm91bmRzICh1c2luZyB0aGUgW1N1dGhlcmxhbmQtSG9kZ21hbiBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobSkpLlxyXG4gKiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlnb24gcG9pbnRzIHRoYXQgYXJlIG9uIHRoZSBzY3JlZW4gb3IgbmVhciwgaW5jcmVhc2luZ1xyXG4gKiBwZXJmb3JtYW5jZS4gTm90ZSB0aGF0IHBvbHlnb24gcG9pbnRzIG5lZWRzIGRpZmZlcmVudCBhbGdvcml0aG0gZm9yIGNsaXBwaW5nXHJcbiAqIHRoYW4gcG9seWxpbmUsIHNvIHRoZXJlJ3MgYSBzZXBhcmF0ZSBtZXRob2QgZm9yIGl0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHBvaW50c1tpXS5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHBvaW50c1tpXSwgYm91bmRzKTtcclxuXHR9XHJcblxyXG5cdC8vIGZvciBlYWNoIGVkZ2UgKGxlZnQsIGJvdHRvbSwgcmlnaHQsIHRvcClcclxuXHRmb3IgKGsgPSAwOyBrIDwgNDsgaysrKSB7XHJcblx0XHRlZGdlID0gZWRnZXNba107XHJcblx0XHRjbGlwcGVkUG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdFx0YSA9IHBvaW50c1tpXTtcclxuXHRcdFx0YiA9IHBvaW50c1tqXTtcclxuXHJcblx0XHRcdC8vIGlmIGEgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvd1xyXG5cdFx0XHRpZiAoIShhLl9jb2RlICYgZWRnZSkpIHtcclxuXHRcdFx0XHQvLyBpZiBiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGdvZXMgb3V0IG9mIHNjcmVlbilcclxuXHRcdFx0XHRpZiAoYi5fY29kZSAmIGVkZ2UpIHtcclxuXHRcdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBMaW5lVXRpbC5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0XHRwLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHBvaW50cyA9IGNsaXBwZWRQb2ludHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvbWV0cnkvUG9seVV0aWwuanMiLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7c3RhbXB9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3N2Z0NyZWF0ZSwgcG9pbnRzVG9QYXRofSBmcm9tICcuL1NWRy5VdGlsJztcbmV4cG9ydCB7cG9pbnRzVG9QYXRofTtcbmltcG9ydCB7dm1sTWl4aW4sIHZtbENyZWF0ZX0gZnJvbSAnLi9TVkcuVk1MJztcblxuZXhwb3J0IHZhciBjcmVhdGUgPSBCcm93c2VyLnZtbCA/IHZtbENyZWF0ZSA6IHN2Z0NyZWF0ZTtcblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLlNWR1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zdmcpLCBTVkcgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBBbmRyb2lkIDIueCBhbmQgMy54LlxuICpcbiAqIEFsdGhvdWdoIFNWRyBpcyBub3QgYXZhaWxhYmxlIG9uIElFNyBhbmQgSUU4LCB0aGVzZSBicm93c2VycyBzdXBwb3J0XG4gKiBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKVxuICogKGEgbm93IGRlcHJlY2F0ZWQgdGVjaG5vbG9neSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpblxuICogdGhpcyBjYXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogVXNlIFNWRyBieSBkZWZhdWx0IGZvciBhbGwgcGF0aHMgaW4gdGhlIG1hcDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gKiBcdHJlbmRlcmVyOiBMLnN2ZygpXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFVzZSBhIFNWRyByZW5kZXJlciB3aXRoIGV4dHJhIHBhZGRpbmcgZm9yIHNwZWNpZmljIHZlY3RvciBnZW9tZXRyaWVzOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcpO1xuICogdmFyIG15UmVuZGVyZXIgPSBMLnN2Zyh7IHBhZGRpbmc6IDAuNSB9KTtcbiAqIHZhciBsaW5lID0gTC5wb2x5bGluZSggY29vcmRpbmF0ZXMsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogdmFyIGNpcmNsZSA9IEwuY2lyY2xlKCBjZW50ZXIsIHsgcmVuZGVyZXI6IG15UmVuZGVyZXIgfSApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkcgPSBSZW5kZXJlci5leHRlbmQoe1xuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBSZW5kZXJlci5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cdFx0ZXZlbnRzLnpvb21zdGFydCA9IHRoaXMuX29uWm9vbVN0YXJ0O1xuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjcmVhdGUoJ3N2ZycpO1xuXG5cdFx0Ly8gbWFrZXMgaXQgcG9zc2libGUgdG8gY2xpY2sgdGhyb3VnaCBzdmcgcm9vdDsgd2UnbGwgcmVzZXQgaXQgYmFjayBpbiBpbmRpdmlkdWFsIHBhdGhzXG5cdFx0dGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG5cdFx0dGhpcy5fcm9vdEdyb3VwID0gY3JlYXRlKCdnJyk7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG5cdFx0ZGVsZXRlIHRoaXMuX3Jvb3RHcm91cDtcblx0XHRkZWxldGUgdGhpcy5fc3ZnU2l6ZTtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBzaXplID0gYi5nZXRTaXplKCksXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblxuXHRcdC8vIHNldCBzaXplIG9mIHN2Zy1jb250YWluZXIgaWYgY2hhbmdlZFxuXHRcdGlmICghdGhpcy5fc3ZnU2l6ZSB8fCAhdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHRoaXMuX3N2Z1NpemUgPSBzaXplO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLngpO1xuXHRcdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS55KTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlbWVudDogdXBkYXRlIGNvbnRhaW5lciB2aWV3Qm94IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgaW5kaXZpZHVhbCBsYXllcnNcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgYi5taW4pO1xuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbYi5taW4ueCwgYi5taW4ueSwgc2l6ZS54LCBzaXplLnldLmpvaW4oJyAnKSk7XG5cblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdC8vIG1ldGhvZHMgYmVsb3cgYXJlIGNhbGxlZCBieSB2ZWN0b3IgbGF5ZXJzIGltcGxlbWVudGF0aW9uc1xuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHBhdGggPSBsYXllci5fcGF0aCA9IGNyZWF0ZSgncGF0aCcpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9IG51bGxcblx0XHQvLyBDdXN0b20gY2xhc3MgbmFtZSBzZXQgb24gYW4gZWxlbWVudC4gT25seSBmb3IgU1ZHIHJlbmRlcmVyLlxuXHRcdGlmIChsYXllci5vcHRpb25zLmNsYXNzTmFtZSkge1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdFx0dGhpcy5fbGF5ZXJzW3N0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9yb290R3JvdXApIHsgdGhpcy5faW5pdENvbnRhaW5lcigpOyB9XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwucmVtb3ZlKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcHJvamVjdCgpO1xuXHRcdGxheWVyLl91cGRhdGUoKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGgsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKCFwYXRoKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG9wdGlvbnMuc3Ryb2tlKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgb3B0aW9ucy5jb2xvcik7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBvcHRpb25zLm9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG9wdGlvbnMud2VpZ2h0KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIG9wdGlvbnMubGluZUNhcCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgb3B0aW9ucy5saW5lSm9pbik7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG9wdGlvbnMuZGFzaEFycmF5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hPZmZzZXQpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jywgb3B0aW9ucy5kYXNoT2Zmc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgucmVtb3ZlQXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIG9wdGlvbnMuZmlsbE9wYWNpdHkpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtcnVsZScsIG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUG9seTogZnVuY3Rpb24gKGxheWVyLCBjbG9zZWQpIHtcblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBwb2ludHNUb1BhdGgobGF5ZXIuX3BhcnRzLCBjbG9zZWQpKTtcblx0fSxcblxuXHRfdXBkYXRlQ2lyY2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgciA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksIDEpLFxuXHRcdCAgICByMiA9IE1hdGgubWF4KE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kpLCAxKSB8fCByLFxuXHRcdCAgICBhcmMgPSAnYScgKyByICsgJywnICsgcjIgKyAnIDAgMSwwICc7XG5cblx0XHQvLyBkcmF3aW5nIGEgY2lyY2xlIHdpdGggdHdvIGhhbGYtYXJjc1xuXHRcdHZhciBkID0gbGF5ZXIuX2VtcHR5KCkgPyAnTTAgMCcgOlxuXHRcdFx0J00nICsgKHAueCAtIHIpICsgJywnICsgcC55ICtcblx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRhcmMgKyAoLXIgKiAyKSArICcsMCAnO1xuXG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgZCk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGgpO1xuXHR9LFxuXG5cdC8vIFNWRyBkb2VzIG5vdCBoYXZlIHRoZSBjb25jZXB0IG9mIHpJbmRleCBzbyB3ZSByZXNvcnQgdG8gY2hhbmdpbmcgdGhlIERPTSBvcmRlciBvZiBlbGVtZW50c1xuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnRvRnJvbnQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuaWYgKEJyb3dzZXIudm1sKSB7XG5cdFNWRy5pbmNsdWRlKHZtbE1peGluKTtcbn1cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLnN2ZyB8fCBCcm93c2VyLnZtbCA/IG5ldyBTVkcob3B0aW9ucykgOiBudWxsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLmpzIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcblxyXG5cclxuLypcclxuICogQGNsYXNzIEdlb0pTT05cclxuICogQGFrYSBMLkdlb0pTT05cclxuICogQGluaGVyaXRzIEZlYXR1cmVHcm91cFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgR2VvSlNPTiBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgR2VvSlNPTiBvYmplY3RzLiBBbGxvd3MgeW91IHRvIHBhcnNlXHJcbiAqIEdlb0pTT04gZGF0YSBhbmQgZGlzcGxheSBpdCBvbiB0aGUgbWFwLiBFeHRlbmRzIGBGZWF0dXJlR3JvdXBgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmdlb0pTT04oZGF0YSwge1xyXG4gKiBcdHN0eWxlOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG4gKiBcdFx0cmV0dXJuIHtjb2xvcjogZmVhdHVyZS5wcm9wZXJ0aWVzLmNvbG9yfTtcclxuICogXHR9XHJcbiAqIH0pLmJpbmRQb3B1cChmdW5jdGlvbiAobGF5ZXIpIHtcclxuICogXHRyZXR1cm4gbGF5ZXIuZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uO1xyXG4gKiB9KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEdlb0pTT04gPSBGZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiB0aGlzXHJcblx0Ly8gQWRkcyBhIEdlb0pTT04gb2JqZWN0IHRvIHRoZSBsYXllci5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBnZW9tZXRyeVRvTGF5ZXIoZ2VvanNvbiwgb3B0aW9ucyk7XHJcblx0XHRpZiAoIWxheWVyKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0bGF5ZXIuZmVhdHVyZSA9IGFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZXNldFN0eWxlKCA8UGF0aD4gbGF5ZXIgKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IE1hcmtlcihsYXRsbmcpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2gocG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTWFya2VyKGxhdGxuZykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChsYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcbi8vIG9yIDMgbnVtYmVycyAobG9uZ2l0dWRlLCBsYXRpdHVkZSwgYWx0aXR1ZGUpIHVzZWQgaW4gR2VvSlNPTiBmb3IgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzKSB7XHJcblx0cmV0dXJuIG5ldyBMYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY29vcmRzVG9MYXRMbmc/OiBGdW5jdGlvbik6IEFycmF5XHJcbi8vIENyZWF0ZXMgYSBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IG9mIGBMYXRMbmdgcyBmcm9tIGEgR2VvSlNPTiBjb29yZGluYXRlcyBhcnJheS5cclxuLy8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG4vLyBDYW4gdXNlIGEgY3VzdG9tIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZykgZnVuY3Rpb24uXHJcbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBsZXZlbHNEZWVwLCBfY29vcmRzVG9MYXRMbmcpIHtcclxuXHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gY29vcmRzLmxlbmd0aCwgbGF0bG5nOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGxhdGxuZyA9IGxldmVsc0RlZXAgP1xyXG5cdFx0XHRjb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgX2Nvb3Jkc1RvTGF0TG5nKSA6XHJcblx0XHRcdChfY29vcmRzVG9MYXRMbmcgfHwgY29vcmRzVG9MYXRMbmcpKGNvb3Jkc1tpXSk7XHJcblxyXG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGF0bG5ncztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nLCBwcmVjaXNpb24/OiBOdW1iZXIpOiBBcnJheVxyXG4vLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0cHJlY2lzaW9uID0gdHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicgPyBwcmVjaXNpb24gOiA2O1xyXG5cdHJldHVybiBsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0W1V0aWwuZm9ybWF0TnVtKGxhdGxuZy5sbmcsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5sYXQsIHByZWNpc2lvbiksIFV0aWwuZm9ybWF0TnVtKGxhdGxuZy5hbHQsIHByZWNpc2lvbildIDpcclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pXTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzLCBsZXZlbHNEZWVwLCBjbG9zZWQsIHByZWNpc2lvbikge1xyXG5cdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIGNsb3NlZCwgcHJlY2lzaW9uKSA6XHJcblx0XHRcdGxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0sIHByZWNpc2lvbikpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFsZXZlbHNEZWVwICYmIGNsb3NlZCkge1xyXG5cdFx0Y29vcmRzLnB1c2goY29vcmRzWzBdKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ2lyY2xlTWFya2VyXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuUG9seWxpbmUuaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgbXVsdGkgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAxIDogMCwgZmFsc2UsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAobXVsdGkgPyAnTXVsdGknIDogJycpICsgJ0xpbmVTdHJpbmcnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb2x5Z29uXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9seWdvbiAoYXMgYSBHZW9KU09OIGBQb2x5Z29uYCBvciBgTXVsdGlQb2x5Z29uYCBGZWF0dXJlKS5cclxuUG9seWdvbi5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBob2xlcyA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyksXHJcblx0XHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pO1xyXG5cclxuXHRcdHZhciBjb29yZHMgPSBsYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRpZiAoIWhvbGVzKSB7XHJcblx0XHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogKG11bHRpID8gJ011bHRpJyA6ICcnKSArICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIExheWVyR3JvdXBcclxuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnTXVsdGlQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9HZW9KU09OKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBncm91cCAoYXMgYSBHZW9KU09OIGBGZWF0dXJlQ29sbGVjdGlvbmAsIGBHZW9tZXRyeUNvbGxlY3Rpb25gLCBvciBgTXVsdGlQb2ludGApLlxyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cclxuXHRcdHZhciB0eXBlID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSAmJiB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvTXVsdGlQb2ludChwcmVjaXNpb24pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxyXG5cdFx0ICAgIGpzb25zID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGlmIChsYXllci50b0dlb0pTT04pIHtcclxuXHRcdFx0XHR2YXIganNvbiA9IGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pO1xyXG5cdFx0XHRcdGlmIChpc0dlb21ldHJ5Q29sbGVjdGlvbikge1xyXG5cdFx0XHRcdFx0anNvbnMucHVzaChqc29uLmdlb21ldHJ5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGZlYXR1cmUgPSBhc0ZlYXR1cmUoanNvbik7XHJcblx0XHRcdFx0XHQvLyBTcXVhc2ggbmVzdGVkIGZlYXR1cmUgY29sbGVjdGlvbnNcclxuXHRcdFx0XHRcdGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0anNvbnMucHVzaC5hcHBseShqc29ucywgZmVhdHVyZS5mZWF0dXJlcyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoKGZlYXR1cmUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiBqc29ucyxcclxuXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG5cdFx0XHRmZWF0dXJlczoganNvbnNcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgR2VvSlNPTlxyXG4vLyBAZmFjdG9yeSBMLmdlb0pTT04oZ2VvanNvbj86IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIEdlb0pTT04gbGF5ZXIuIE9wdGlvbmFsbHkgYWNjZXB0cyBhbiBvYmplY3QgaW5cclxuLy8gW0dlb0pTT04gZm9ybWF0XShodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWwpIHRvIGRpc3BsYXkgb24gdGhlIG1hcFxyXG4vLyAoeW91IGNhbiBhbHRlcm5hdGl2ZWx5IGFkZCBpdCBsYXRlciB3aXRoIGBhZGREYXRhYCBtZXRob2QpIGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gZ2VvSlNPTihnZW9qc29uLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBHZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxyXG5leHBvcnQgdmFyIGdlb0pzb24gPSBnZW9KU09OO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL0dlb0pTT04uanMiLCJpbXBvcnQge0xhdExuZ30gZnJvbSAnLi4vTGF0TG5nJztcclxuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUHJvamVjdGlvblxyXG4gKiBAcHJvamVjdGlvbiBMLlByb2plY3Rpb24uTWVyY2F0b3JcclxuICpcclxuICogRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uIOKAlCBtb3JlIGNvbXBsZXggdGhhbiBTcGhlcmljYWwgTWVyY2F0b3IuIFRha2VzIGludG8gYWNjb3VudCB0aGF0IEVhcnRoIGlzIGEgZ2VvaWQsIG5vdCBhIHBlcmZlY3Qgc3BoZXJlLiBVc2VkIGJ5IHRoZSBFUFNHOjMzOTUgQ1JTLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWVyY2F0b3IgPSB7XHJcblx0UjogNjM3ODEzNyxcclxuXHRSX01JTk9SOiA2MzU2NzUyLjMxNDI0NTE3OSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMjAwMzc1MDguMzQyNzksIC0xNTQ5NjU3MC43Mzk3Ml0sIFsyMDAzNzUwOC4zNDI3OSwgMTg3NjQ2NTYuMjMxMzhdKSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgeSA9IGxhdGxuZy5sYXQgKiBkLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICBjb24gPSBlICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0dmFyIHRzID0gTWF0aC50YW4oTWF0aC5QSSAvIDQgLSB5IC8gMikgLyBNYXRoLnBvdygoMSAtIGNvbikgLyAoMSArIGNvbiksIGUgLyAyKTtcclxuXHRcdHkgPSAtciAqIE1hdGgubG9nKE1hdGgubWF4KHRzLCAxRS0xMCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQobGF0bG5nLmxuZyAqIGQgKiByLCB5KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIGQgPSAxODAgLyBNYXRoLlBJLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlIsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLXBvaW50LnkgLyByKSxcclxuXHRcdCAgICBwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBkcGhpID0gMC4xLCBjb247IGkgPCAxNSAmJiBNYXRoLmFicyhkcGhpKSA+IDFlLTc7IGkrKykge1xyXG5cdFx0XHRjb24gPSBlICogTWF0aC5zaW4ocGhpKTtcclxuXHRcdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHRcdGRwaGkgPSBNYXRoLlBJIC8gMiAtIDIgKiBNYXRoLmF0YW4odHMgKiBjb24pIC0gcGhpO1xyXG5cdFx0XHRwaGkgKz0gZHBoaTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yLmpzIiwiaW1wb3J0IHsgRWxlbWVudCBhcyBQb2x5bWVyRWxlbWVudCB9IGZyb20gJy4uLy4uL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCAnLi4vLi4vQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uLmpzJztcblxuaW1wb3J0IHsgRmVhdHVyZUdyb3VwIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvRmVhdHVyZUdyb3VwLmpzJztcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMnO1xuaW1wb3J0IHsgSWNvbiB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyL21hcmtlci9JY29uLmpzJztcbmltcG9ydCBpY29uIGZyb20gJy4uLy4uL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLWljb24ucG5nJztcbmltcG9ydCBpY29uU2hhZG93IGZyb20gJy4uLy4uL2xlYWZsZXQvZGlzdC9pbWFnZXMvbWFya2VyLXNoYWRvdy5wbmcnO1xuXG5pbXBvcnQgeyBMZWFmbGV0TWFwIH0gZnJvbSAnLi4vLi4vQGdnY2l0eS9sZWFmbGV0LW1hcC9sZWFmbGV0LW1hcC5qcyc7XG5pbXBvcnQgeyBMZWFmbGV0V01TR3JvdXAgfSBmcm9tICcuLi8uLi9AZ2djaXR5L2xlYWZsZXQtd21zL2xlYWZsZXQtd21zLWdyb3VwLmpzJztcbmltcG9ydCB7IExlYWZsZXRUaWxlTGF5ZXIgfSBmcm9tICcuLi8uLi9AZ2djaXR5L2xlYWZsZXQtdGlsZS1sYXllci9sZWFmbGV0LXRpbGUtbGF5ZXIuanMnO1xuaW1wb3J0IHsgTGVhZmxldEdlb0pTT04gfSBmcm9tICcuLi8uLi9AZ2djaXR5L2xlYWZsZXQtZ2VvanNvbi9sZWFmbGV0LWdlb2pzb24tcG9pbnRzLmpzJztcblxudmFyIHlhbWwgPSByZXF1aXJlKCcuLi8uLi9qcy15YW1sL2Rpc3QvanMteWFtbC5taW4uanMnKTtcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuL2FwcC50ZW1wbGF0ZS5odG1sJztcblxuZXhwb3J0IGNsYXNzIEdHTWFwVmlld2VyIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1hcFRpdGxlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdDaXR5IG9mIEdhcmRlbiBHcm92ZSBQdWJsaWMgTWFwcydcbiAgICAgIH0sXG4gICAgICBmbGF0OiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBtYXA6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICB9LFxuICAgICAgYmFzZVNvdXJjZToge1xuICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICBiYXNlRm9ybWF0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkT3ZlcmxheToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiAnX292ZXJsYXlDaGFuZ2VkJ1xuICAgICAgfSxcbiAgICAgIHdtc0dyb3Vwczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgdmFsdWU6IFtdXG4gICAgICB9LFxuICAgICAgZ2VvanNvbkxheWVyczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgdmFsdWU6IFtdXG4gICAgICB9LFxuICAgICAgYmFzZU1hcHM6IHtcbiAgICAgICAgdHlwZTogQXJyYXlcbiAgICAgIH0sXG4gICAgICBvdmVybGF5TWFwczoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcbiAgICAgIHNlYXJjaE1hcmtlcnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHZhbHVlOiBbXSxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfbWFya01hcCdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fbWFya2Vyc0dyb3VwID0gbmV3IEZlYXR1cmVHcm91cChbXSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgZmV0Y2godGhpcy5jb25maWcpLnRoZW4ociA9PiByLnRleHQoKSlcbiAgICAgIC50aGVuKHRoaXMuaW5pdGlhbGl6ZU1hcC5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVNlYXJjaCgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZU1hcChyZXNwb25zZSkge1xuICAgIGxldCByanNvbiA9IHlhbWwuc2FmZUxvYWQocmVzcG9uc2UpO1xuXG4gICAgdGhpcy5iYXNlTWFwcyA9IHJqc29uLmJhc2VNYXBzO1xuICAgIHRoaXMub3ZlcmxheU1hcHMgPSByanNvbi5vdmVybGF5TWFwcztcblxuICAgIGlmICh0aGlzLmZsYXQgJiYgdGhpcy5vdmVybGF5TWFwcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdZb3UgY2Fubm90IGVuYWJsZSBmbGF0IG1vZGUgd2l0aCBtdWx0aXBsZSBvdmVybGF5cyBhdCB0aGlzIHRpbWUuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3ZlcmxheU1hcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmZsYXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyanNvbi5tYXBUaXRsZSkge1xuICAgICAgdGhpcy5tYXBUaXRsZSA9IHJqc29uLm1hcFRpdGxlO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBncm91cHMgb2YgbGF5ZXJzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm92ZXJsYXlNYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbCA9IHRoaXMub3ZlcmxheU1hcHNbaV0ubGF5ZXJzO1xuICAgICAgdGhpcy5vdmVybGF5TWFwc1tpXS5mbGF0dGVuZWRMYXllcnMgPSBbXTtcblxuICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGxheWVyIGludGVyYWN0aW9uIHR5cGVzIChhbHdheXMgb24sIGV4Y2x1c2l2ZXMsIG9wdGlvbmFscylcbiAgICAgIGZvciAobGV0IHQgaW4gbCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlNYXBzW2ldLmZsYXR0ZW5lZExheWVycyA9IHRoaXMub3ZlcmxheU1hcHNbaV0uZmxhdHRlbmVkTGF5ZXJzLmNvbmNhdChsW3RdKTtcblxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIGxheWVyc1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxbdF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsW3RdW2pdLmludGVyYWN0aW9uID0gdDtcblxuICAgICAgICAgIC8vIGFsd2F5cyBvbiBsYXllcnMgc2hvdWxkIGFsd2F5cyBiZSB2aXNpYmxlXG4gICAgICAgICAgaWYgKHQgPT09ICdhbHdheXNPbicpIHtcbiAgICAgICAgICAgIGxbdF1bal0udmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbi5oYXNoICE9PSAnJykge1xuICAgICAgICAgICAgICBpZiAobFt0XVtqXS5tYWNoaW5lTmFtZSA9PT0gbG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSkpIHtcbiAgICAgICAgICAgICAgICBsW3RdW2pdLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxbdF1bal0udmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRm9yIGNvbnZlbmllbmNlLCBhbGxvdyBzb3VyY2UgdG8gYmUgZ2xvYmFsbHkgZGVmaW5lZCwgYnV0IHByb3BhZ2F0ZSBpdCBoZXJlLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChsW3RdW2pdLnR5cGUgPT09ICd3bXMnIHx8IGxbdF1bal0udHlwZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgJiYgbFt0XVtqXS5zb3VyY2UgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbFt0XVtqXS50eXBlID0gJ3dtcyc7XG4gICAgICAgICAgICBsW3RdW2pdLnNvdXJjZSA9IHJqc29uLndtc0RlZmF1bHRTb3VyY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IGhhY2t5IGhhcmRjb2RlZCBpbml0aWFsIHZpZXdcbiAgICB0aGlzLl9zZWxlY3RlZEJhc2VtYXAgPSAwO1xuICAgIGlmICh0aGlzLmJhc2VNYXBzICYmIHRoaXMuYmFzZU1hcHNbMF0pIHtcbiAgICAgIHRoaXMuYmFzZVNvdXJjZSA9IHRoaXMuYmFzZU1hcHNbMF0uc291cmNlO1xuICAgICAgdGhpcy5iYXNlRm9ybWF0ID0gdGhpcy5iYXNlTWFwc1swXS5mb3JtYXQ7XG4gICAgICB0aGlzLmJhc2VMYXllcnMgPSB0aGlzLmJhc2VNYXBzWzBdLmxheWVycztcbiAgICB9XG5cbiAgICB0aGlzLm92ZXJsYXlTZWxlY3QoKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTZWFyY2goKSB7XG4gICAgdGhpcy5fbWFya2Vyc0dyb3VwLmFkZFRvKHRoaXMubWFwKTtcblxuICAgIGpRdWVyeSgnI3NlYXJjaCcsIHRoaXMuc2hhZG93Um9vdCkuYXV0b2NvbXBsZXRlKHtcbiAgICAgIHByZXZlbnRCYWRRdWVyaWVzOiBmYWxzZSxcbiAgICAgIGRlZmVyUmVxdWVzdEJ5OiAyMDAsXG4gICAgICBtaW5DaGFyczogMyxcbiAgICAgIHNlcnZpY2VVcmw6ICcvL3d3dy5jaS5nYXJkZW4tZ3JvdmUuY2EudXMvbWFwcy9hcGkvYWRkcmVzc2VzL3NlYXJjaCcsXG4gICAgICBwYXJhbU5hbWU6ICdxJyxcbiAgICAgIC8vIHBhcmFtczogeyBsaW1pdDogMTAgfSxcbiAgICAgIHRyYW5zZm9ybVJlc3VsdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBhZGRyZXNzZXMgPSBKU09OLnBhcnNlKHJlc3BvbnNlKS5hZGRyZXNzZXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VnZ2VzdGlvbnM6IGFkZHJlc3Nlcy5tYXAoZCA9PiAoeyB2YWx1ZTogZC5hZGRyZXNzLCBkYXRhOiBkIH0pKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25TZWFyY2hTdGFydDogKCkgPT4gdGhpcy5zZXQoJ3NlYXJjaE1ha2VycycsIFtdKSxcbiAgICAgIG9uU2VhcmNoQ29tcGxldGU6IChxLCBzKSA9PiB0aGlzLnNldCgnc2VhcmNoTWFya2VycycsIHMubWFwKG9iaiA9PiAoXG4gICAgICAgIHsgY29vcmRzOiBbb2JqLmRhdGEubGF0aXR1ZGUsIG9iai5kYXRhLmxvbmdpdHVkZV0sIGFkZHJlc3M6IG9iai5kYXRhLmFkZHJlc3MgfVxuICAgICAgKSkpLFxuICAgICAgb25TZWxlY3Q6IG9iaiA9PiB0aGlzLnNldCgnc2VhcmNoTWFya2VycycsIFt7IGNvb3JkczogW29iai5kYXRhLmxhdGl0dWRlLCBvYmouZGF0YS5sb25naXR1ZGVdLCBhZGRyZXNzOiBvYmouZGF0YS5hZGRyZXNzIH1dKVxuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlTGF5ZXIoZXZlbnQpIHtcbiAgICAvLyBGaXJzdCBzYXZlIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgbGV0IGN1cnJWaXNpYmxlID0gZXZlbnQubW9kZWwubGF5ZXIudmlzaWJsZTtcblxuICAgIGlmIChldmVudC5tb2RlbC5sYXllci5pbnRlcmFjdGlvbiA9PT0gJ2V4Y2x1c2l2ZXMnKSB7XG4gICAgICAvLyBUdXJuIGFsbCBleGNsdXNpdmUgbGF5ZXJzIG9mZlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkT3ZlcmxheS5sYXllcnMuZXhjbHVzaXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNldCgnc2VsZWN0ZWRPdmVybGF5LmxheWVycy5leGNsdXNpdmVzLicgKyBpICsgJy52aXNpYmxlJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdG9nZ2xlIG9uIG9yaWdpbmFsIHN0YXRlXG4gICAgZXZlbnQubW9kZWwuc2V0KCdsYXllci52aXNpYmxlJywgIWN1cnJWaXNpYmxlKTtcblxuICAgIHRoaXMuX3BhcnNlTGF5ZXJzKHRoaXMuc2VsZWN0ZWRPdmVybGF5KTtcbiAgfVxuXG4gIG92ZXJsYXlTZWxlY3QoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkT3ZlcmxheSA9IChldmVudCkgPyBldmVudC5tb2RlbC5pdGVtIDogdGhpcy5vdmVybGF5TWFwc1swXTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkT3ZlcmxheS5yZXNldFZpZXdPblNlbGVjdCkge1xuICAgICAgdGhpcy5tYXAuZmx5VG8odGhpcy5zZWxlY3RlZE92ZXJsYXkuaW5pdGlhbENlbnRlciwgdGhpcy5zZWxlY3RlZE92ZXJsYXkuaW5pdGlhbFpvb20pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWEU6IEFjaHR1bmchIFViZXIgaGFja3khISFcbiAgc3dpdGNoQmFzZW1hcChldmVudCkge1xuICAgIGxldCBpZHggPSArK3RoaXMuX3NlbGVjdGVkQmFzZW1hcCAlIDI7XG4gICAgdGhpcy5iYXNlU291cmNlID0gdGhpcy5iYXNlTWFwc1tpZHhdLnNvdXJjZTtcbiAgICB0aGlzLmJhc2VGb3JtYXQgPSB0aGlzLmJhc2VNYXBzW2lkeF0uZm9ybWF0O1xuICAgIHRoaXMuYmFzZUxheWVycyA9IHRoaXMuYmFzZU1hcHNbaWR4XS5sYXllcnM7XG5cbiAgICBpZiAoaWR4ID09PSAxKSB7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi92ZWN0b3IucG5nKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoLi9hZXJpYWwucG5nKVwiO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUxheWVyc01lbnUoKSB7XG4gICAgbGV0IGxheWVyc01lbnUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignbWFpbiNsYXllcnMtbWVudScpO1xuICAgIGxheWVyc01lbnUuY2xhc3NMaXN0LnRvZ2dsZSgnc2hvdycpO1xuICB9XG5cbiAgX3BhcnNlTGF5ZXJzKG92ZXJsYXkpIHtcbiAgICBsZXQgbGF5ZXJzID0gb3ZlcmxheS5mbGF0dGVuZWRMYXllcnM7XG4gICAgbGV0IHdtc0xheWVycyA9IHt9O1xuXG4gICAgLy8gcmVzZXRcbiAgICB0aGlzLnNldCgnd21zR3JvdXBzJywgW10pO1xuICAgIHRoaXMuc2V0KCdnZW9qc29uTGF5ZXJzJywgW10pO1xuXG4gICAgbGF5ZXJzXG4gICAgICAuZmlsdGVyKGwgPT4gbC52aXNpYmxlKVxuICAgICAgLmZvckVhY2gobCA9PiB7XG4gICAgICAgIGlmIChsLnR5cGUgPT09ICd3bXMnKSB7XG4gICAgICAgICAgLy8gZ3JvdXAgdGhlIHNvdXJjZXNcbiAgICAgICAgICB3bXNMYXllcnNbbC5zb3VyY2VdID0gd21zTGF5ZXJzW2wuc291cmNlXSB8fCB7IGxheWVyczogW10sIGlkZW50aWZ5OiBmYWxzZSB9O1xuICAgICAgICAgIHdtc0xheWVyc1tsLnNvdXJjZV0ubGF5ZXJzLnB1c2gobC5tYWNoaW5lTmFtZSk7XG4gICAgICAgICAgd21zTGF5ZXJzW2wuc291cmNlXS5pZGVudGlmeSA9IHdtc0xheWVyc1tsLnNvdXJjZV0uaWRlbnRpZnkgfHwgbC5pZGVudGlmeTtcbiAgICAgICAgfSBlbHNlIGlmIChsLnR5cGUgPT09ICdnZW9qc29uJykge1xuICAgICAgICAgIHRoaXMucHVzaCgnZ2VvanNvbkxheWVycycsIGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8vIGZsYXR0ZW5lZCB0aGUgZ3JvdXBlZCBXTVMgc291cmNlc1xuICAgIGZvciAobGV0IHMgaW4gd21zTGF5ZXJzKSB7XG4gICAgICB0aGlzLnB1c2goJ3dtc0dyb3VwcycsIHsgc291cmNlOiBzLCBsYXllcnM6IHdtc0xheWVyc1tzXS5sYXllcnMsIGlkZW50aWZ5OiB3bXNMYXllcnNbc10uaWRlbnRpZnkgfSk7XG4gICAgfVxuICB9XG5cbiAgX21hcmtNYXAobWFya2Vyc0RhdGEpIHtcbiAgICB0aGlzLl9tYXJrZXJzR3JvdXAuY2xlYXJMYXllcnMoKTtcbiAgICBpZiAobWFya2Vyc0RhdGEubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBtYXJrZXJzRGF0YS5mb3JFYWNoKG0gPT4ge1xuICAgICAgdGhpcy5fbWFya2Vyc0dyb3VwXG4gICAgICAgIC5hZGRMYXllcihuZXcgTWFya2VyKG0uY29vcmRzLCB7XG4gICAgICAgICAgaWNvbjogbmV3IEljb24oe1xuICAgICAgICAgICAgaWNvblVybDogaWNvbixcbiAgICAgICAgICAgIHNoYWRvd1VybDogaWNvblNoYWRvdyxcbiAgICAgICAgICAgIGljb25TaXplOiBbMjUsIDQxXSxcbiAgICAgICAgICAgIGljb25BbmNob3I6IFsxMiwgNDFdLFxuICAgICAgICAgICAgcG9wdXBBbmNob3I6IFsxLCAtMzRdLFxuICAgICAgICAgICAgdG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuICAgICAgICAgICAgc2hhZG93U2l6ZTogWzQxLCA0MV1cbiAgICAgICAgICB9KVxuICAgICAgICB9KS5iaW5kUG9wdXAobS5hZGRyZXNzKSlcbiAgICB9KTtcblxuICAgIGlmIChtYXJrZXJzRGF0YS5sZW5ndGggPT09IDEpIHRoaXMubWFwLmZseVRvKG1hcmtlcnNEYXRhWzBdLmNvb3Jkcyk7XG4gICAgZWxzZSB0aGlzLm1hcC5maXRCb3VuZHModGhpcy5fbWFya2Vyc0dyb3VwLmdldEJvdW5kcygpKTtcbiAgfVxuXG4gIF9pc0N1cnJlbnRFeGNsdXNpdmUobGF5ZXIpIHtcbiAgICByZXR1cm4gbGF5ZXIudmlzaWJsZTtcbiAgfVxuXG4gIF9pc0N1cnJlbnRPdmVybGF5KHNlbGVjdGVkLCBpdGVtKSB7XG4gICAgcmV0dXJuIHNlbGVjdGVkID09PSBpdGVtO1xuICB9XG5cbiAgX292ZXJsYXlDaGFuZ2VkKG5ld092ZXJsYXkpIHtcbiAgICB0aGlzLl9wYXJzZUxheWVycyhuZXdPdmVybGF5KTtcbiAgfVxuXG4gIF9vdmVybGF5TGF5ZXJzU2hvdyhzZWxlY3RlZCwgaXRlbSkge1xuICAgIGlmIChzZWxlY3RlZCA9PT0gaXRlbSB8fCB0aGlzLmZsYXQpIHJldHVybiBcImNvbGxhcHNlIHNob3dcIjtcbiAgICByZXR1cm4gXCJjb2xsYXBzZVwiO1xuICB9XG5cbiAgX292ZXJsYXlJdGVtQ2xhc3Moc2VsZWN0ZWQsIGl0ZW0pIHtcbiAgICBsZXQgZGVmYXVsdENsYXNzID0gXCJvdmVybGF5LWl0ZW0gZC1mbGV4IGp1c3RpZnktY29udGVudC1zdGFydFwiO1xuICAgIGlmIChzZWxlY3RlZCA9PT0gaXRlbSkgcmV0dXJuIGRlZmF1bHRDbGFzcyArICcgc2VsZWN0ZWQnO1xuICAgIHJldHVybiBkZWZhdWx0Q2xhc3M7XG4gIH1cblxuICAvLyBGSVhNRTogbWFrZSB0aGlzIGxlc3MgaGFyZGNvZGV5XG4gIGRvd25sb2FkTGF5ZXIoZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gaWYgbW9kYWwgaXMgbm90IGFscmVhZHkgZm91bmQgaW4gbGlnaHQgRE9NLCBwdWxsIGZyb20gc2hhZG93IERPTVxuICAgIGxldCBkb20gPSAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2Rvd25sb2FkLW1vZGFsJykpID8gZG9jdW1lbnQgOiB0aGlzLnNoYWRvd1Jvb3Q7XG5cbiAgICBsZXQgbGF5ZXIgPSBldmVudC5tb2RlbC5sYXllcjtcbiAgICAvLyBGSVhNRTogaGFyZGNvZGVkIHVybFxuICAgIGxldCBkb3dubG9hZFVSTCA9IGBodHRwczovL3d3dy5jaS5nYXJkZW4tZ3JvdmUuY2EudXMvZ2Vvc2VydmVyL2dpcy9vd3M/c2VydmljZT1XRlMmdmVyc2lvbj0xLjAuMCZyZXF1ZXN0PUdldEZlYXR1cmUmdHlwZU5hbWU9JHtsYXllci5tYWNoaW5lTmFtZX1gO1xuXG4gICAgalF1ZXJ5KCcjbGF5ZXItbmFtZScsIGRvbSkuaHRtbChsYXllci5uYW1lKTtcbiAgICBqUXVlcnkoJyNnZW9qc29uLWRvd25sb2FkJywgZG9tKS5hdHRyKCdocmVmJywgZG93bmxvYWRVUkwgKyAnJm91dHB1dEZvcm1hdD1hcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgalF1ZXJ5KCcjY3N2LWRvd25sb2FkJywgZG9tKS5hdHRyKCdocmVmJywgZG93bmxvYWRVUkwgKyAnJm91dHB1dEZvcm1hdD1jc3YnKTtcbiAgICBqUXVlcnkoJyNrbWwtZG93bmxvYWQnLCBkb20pLmF0dHIoJ2hyZWYnLCBkb3dubG9hZFVSTCArICcmb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbCcpO1xuICAgIGpRdWVyeSgnI3NoYXBlZmlsZS1kb3dubG9hZCcsIGRvbSkuYXR0cignaHJlZicsIGRvd25sb2FkVVJMICsgJyZvdXRwdXRGb3JtYXQ9U0hBUEUtWklQJyk7XG4gICAgalF1ZXJ5KCcjZG93bmxvYWQtbW9kYWwnLCBkb20pLm1vZGFsKCk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdnZy1tYXAtdmlld2VyJywgR0dNYXBWaWV3ZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL2dnLW1hcC12aWV3ZXIuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCAqIGFzIGNhc2VNYXAkMCBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuLi91dGlscy9hc3luYy5qcyc7XG5cbmxldCBjYXNlTWFwID0gY2FzZU1hcCQwO1xuXG5sZXQgbWljcm90YXNrID0gbWljcm9UYXNrO1xuXG4vLyBTYXZlIG1hcCBvZiBuYXRpdmUgcHJvcGVydGllczsgdGhpcyBmb3JtcyBhIGJsYWNrbGlzdCBvciBwcm9wZXJ0aWVzXG4vLyB0aGF0IHdvbid0IGhhdmUgdGhlaXIgdmFsdWVzIFwic2F2ZWRcIiBieSBgc2F2ZUFjY2Vzc29yVmFsdWVgLCBzaW5jZVxuLy8gcmVhZGluZyBmcm9tIGFuIEhUTUxFbGVtZW50IGFjY2Vzc29yIGZyb20gdGhlIGNvbnRleHQgb2YgYSBwcm90b3R5cGUgdGhyb3dzXG5jb25zdCBuYXRpdmVQcm9wZXJ0aWVzID0ge307XG5sZXQgcHJvdG8gPSBIVE1MRWxlbWVudC5wcm90b3R5cGU7XG53aGlsZSAocHJvdG8pIHtcbiAgbGV0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuICBmb3IgKGxldCBpPTA7IGk8cHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBuYXRpdmVQcm9wZXJ0aWVzW3Byb3BzW2ldXSA9IHRydWU7XG4gIH1cbiAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xufVxuXG4vKipcbiAqIFVzZWQgdG8gc2F2ZSB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgb3ZlcnJpZGRlbiB3aXRoXG4gKiBhbiBhY2Nlc3Nvci4gSWYgdGhlIGBtb2RlbGAgaXMgYSBwcm90b3R5cGUsIHRoZSB2YWx1ZXMgd2lsbCBiZSBzYXZlZFxuICogaW4gYF9fZGF0YVByb3RvYCwgYW5kIGl0J3MgdXAgdG8gdGhlIHVzZXIgKG9yIGRvd25zdHJlYW0gbWl4aW4pIHRvXG4gKiBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRoZXNlIHZhbHVlcyBiYWNrIGludG8gdGhlIGFjY2Vzc29ycy5cbiAqIElmIGBtb2RlbGAgaXMgYWxyZWFkeSBhbiBpbnN0YW5jZSAoaXQgaGFzIGEgYF9fZGF0YWAgcHJvcGVydHkpLCB0aGVuXG4gKiB0aGUgdmFsdWUgd2lsbCBiZSBzZXQgYXMgYSBwZW5kaW5nIHByb3BlcnR5LCBtZWFuaW5nIHRoZSB1c2VyIHNob3VsZFxuICogY2FsbCBgX2ludmFsaWRhdGVQcm9wZXJ0aWVzYCBvciBgX2ZsdXNoUHJvcGVydGllc2AgdG8gdGFrZSBlZmZlY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZUFjY2Vzc29yVmFsdWUobW9kZWwsIHByb3BlcnR5KSB7XG4gIC8vIERvbid0IHJlYWQvc3RvcmUgdmFsdWUgZm9yIGFueSBuYXRpdmUgcHJvcGVydGllcyBzaW5jZSB0aGV5IGNvdWxkIHRocm93XG4gIGlmICghbmF0aXZlUHJvcGVydGllc1twcm9wZXJ0eV0pIHtcbiAgICBsZXQgdmFsdWUgPSBtb2RlbFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChtb2RlbC5fX2RhdGEpIHtcbiAgICAgICAgLy8gQWRkaW5nIGFjY2Vzc29yIHRvIGluc3RhbmNlOyB1cGRhdGUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIEl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gY2FsbCBfZmx1c2hQcm9wZXJ0aWVzXG4gICAgICAgIG1vZGVsLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBwcm90bzsgc2F2ZSBwcm90bydzIHZhbHVlIGZvciBpbnN0YW5jZS10aW1lIHVzZVxuICAgICAgICBpZiAoIW1vZGVsLl9fZGF0YVByb3RvKSB7XG4gICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG8gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19kYXRhUHJvdG8nLCBtb2RlbCkpKSB7XG4gICAgICAgICAgbW9kZWwuX19kYXRhUHJvdG8gPSBPYmplY3QuY3JlYXRlKG1vZGVsLl9fZGF0YVByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5fX2RhdGFQcm90b1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFByb3BlcnR5QWNjZXNzb3JzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlBY2Nlc3NvcnN9XG4gICAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNsYXNzIFByb3BlcnR5QWNjZXNzb3JzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgcHJvcGVydHkgYWNjZXNzb3JzIGZvciBhbGwgYXR0cmlidXRlcyBpbiB0aGUgc3RhbmRhcmRcbiAgICAgKiBzdGF0aWMgYG9ic2VydmVkQXR0cmlidXRlc2AgYXJyYXkuXG4gICAgICpcbiAgICAgKiBBdHRyaWJ1dGUgbmFtZXMgYXJlIG1hcHBlZCB0byBwcm9wZXJ0eSBuYW1lcyB1c2luZyB0aGUgYGRhc2gtY2FzZWAgdG9cbiAgICAgKiBgY2FtZWxDYXNlYCBjb252ZW50aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMoKSB7XG4gICAgICBsZXQgYSQgPSB0aGlzLm9ic2VydmVkQXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IGEkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGEkW2ldKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nO1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUVuYWJsZWQ7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YVJlYWR5O1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGE7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhUHJvdG87XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3I7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcztcbiAgICAgIHRoaXMuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBuYXRpdmUgQ3VzdG9tIEVsZW1lbnRzIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHRvXG4gICAgICogc2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSB0byBhIHByb3BlcnR5IHZpYSBgX2F0dHJpYnV0ZVRvUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUgdGhhdCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgTmV3IGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqXG4gICAgICogUHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGUgcG9pbnQgZm9yIHBlcmZvcm1pbmcgYW55IHNldHVwIHdvcmsgcHJpb3JcbiAgICAgKiB0byBpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5IGFjY2Vzc29yIHN5c3RlbS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhQ291bnRlciA9IDA7XG4gICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGEgPSB7fTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5fX2RhdGFQcm90bykge1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHRoaXMuX19kYXRhUHJvdG8pO1xuICAgICAgICB0aGlzLl9fZGF0YVByb3RvID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIENhcHR1cmUgaW5zdGFuY2UgcHJvcGVydGllczsgdGhlc2Ugd2lsbCBiZSBzZXQgaW50byBhY2Nlc3NvcnNcbiAgICAgIC8vIGR1cmluZyBmaXJzdCBmbHVzaC4gRG9uJ3Qgc2V0IHRoZW0gaGVyZSwgc2luY2Ugd2Ugd2FudFxuICAgICAgLy8gdGhlc2UgdG8gb3ZlcndyaXRlIGRlZmF1bHRzL2NvbnN0cnVjdG9yIGFzc2lnbm1lbnRzXG4gICAgICBmb3IgKGxldCBwIGluIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMgPSB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMgfHwge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzW3BdID0gdGhpc1twXTtcbiAgICAgICAgICBkZWxldGUgdGhpc1twXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCBpbnN0YW5jZSB0aW1lIHdpdGggYmFnIG9mIHByb3BlcnRpZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICogYnkgYWNjZXNzb3JzIG9uIHRoZSBwcm90b3R5cGUgd2hlbiBhY2Nlc3NvcnMgd2VyZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgKiBzZXR0ZXIgYXQgaW5zdGFuY2UgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBmb3IgKGxldCBwIGluIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHAsIHByb3BzW3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgcmVhZHkgdGltZSB3aXRoIGJhZyBvZiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHRoYXQgb3Zlcndyb3RlXG4gICAgICogYWNjZXNzb3JzIHdoZW4gdGhlIGVsZW1lbnQgdXBncmFkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzZXRzIHRoZXNlIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZVxuICAgICAqIHNldHRlciBhdCByZWFkeSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIGVsZW1lbnQgaGFzIHRoZSBnaXZlbiBhdHRyaWJ1dGUuIElmIGl0IGRvZXMgbm90LFxuICAgICAqIGFzc2lnbnMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZW5zdXJlIGlzIHNldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBfZW5zdXJlQXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSh0aGlzLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZXMgYW4gYXR0cmlidXRlIHRvIGl0cyBhc3NvY2lhdGVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIGBfZGVzZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHRvIGNvbnZlcnQgdGhlIHN0cmluZyB0b1xuICAgICAqIGEgdHlwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0geyo9fSB0eXBlIHR5cGUgdG8gZGVzZXJpYWxpemUgdG8uXG4gICAgICovXG4gICAgX2F0dHJpYnV0ZVRvUHJvcGVydHkoYXR0cmlidXRlLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgLy8gRG9uJ3QgZGVzZXJpYWxpemUgYmFjayB0byBwcm9wZXJ0eSBpZiBjdXJyZW50bHkgcmVmbGVjdGluZ1xuICAgICAgaWYgKCF0aGlzLl9fc2VyaWFsaXppbmcpIHtcbiAgICAgICAgbGV0IHByb3BlcnR5ID0gY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UoYXR0cmlidXRlKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgcHJvcGVydHkgdG8gaXRzIGFzc29jaWF0ZWQgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHJlZmVjdC5cbiAgICAgKi9cbiAgICBfcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gdHJ1ZTtcbiAgICAgIHZhbHVlID0gKGFyZ3VtZW50cy5sZW5ndGggPCAzKSA/IHRoaXNbcHJvcGVydHldIDogdmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSh0aGlzLCB2YWx1ZSxcbiAgICAgICAgYXR0cmlidXRlIHx8IGNhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSk7XG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdHlwZWQgdmFsdWUgdG8gYW4gSFRNTCBhdHRyaWJ1dGUgb24gYSBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSB0eXBlZFxuICAgICAqIHZhbHVlIHRvIGEgc3RyaW5nLiAgSWYgdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkICh0aGlzIGlzIHRoZSBkZWZhdWx0IGZvciBib29sZWFuXG4gICAgICogdHlwZSBgZmFsc2VgKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHNldCBhdHRyaWJ1dGUgdG8uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICovXG4gICAgX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKG5vZGUsIHZhbHVlLCBhdHRyaWJ1dGUpIHtcbiAgICAgIGxldCBzdHIgPSB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgc3RyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHNldHRpbmcgSlMgcHJvcGVydHkgdmFsdWVzIHRvXG4gICAgICogSFRNTCBhdHRyaWJ1dGVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIG9uIFBvbHltZXIgZWxlbWVudFxuICAgICAqIHByb3RvdHlwZXMgdG8gcHJvdmlkZSBzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFN0cmluZyBzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIF9zZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICcnIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS50b1N0cmluZygpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gcmVhZGluZyBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMgdG9cbiAgICAgKiBKUyBwcm9wZXJ0aWVzLiAgVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIG9uIFBvbHltZXIgZWxlbWVudFxuICAgICAqIHByb3RvdHlwZXMgdG8gcHJvdmlkZSBkZXNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSBgdHlwZWBzLiAgTm90ZSxcbiAgICAgKiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgYHR5cGVgIGZpZWxkIHByb3ZpZGVkIGluIHRoZVxuICAgICAqIGBwcm9wZXJ0aWVzYCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYSBnaXZlbiBwcm9wZXJ0eSwgYW5kIGlzXG4gICAgICogYnkgY29udmVudGlvbiB0aGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqXG4gICAgICogTm90ZTogVGhlIHJldHVybiB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBpcyB1c2VkIGFzIGEgc2VudGluZWwgdmFsdWUgdG9cbiAgICAgKiBpbmRpY2F0ZSB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUgdG8gZGVzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG8uXG4gICAgICogQHJldHVybiB7Kn0gVHlwZWQgdmFsdWUgZGVzZXJpYWxpemVkIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBfZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7Kn1cbiAgICAgICAqL1xuICAgICAgbGV0IG91dFZhbHVlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICAgIG91dFZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgb3V0VmFsdWUgPSAodmFsdWUgIT09IG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgLy8gYWxsb3cgbm9uLUpTT04gbGl0ZXJhbHMgbGlrZSBTdHJpbmdzIGFuZCBOdW1iZXJzXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUgc3RyaW5nICovKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFBvbHltZXI6OkF0dHJpYnV0ZXM6IGNvdWxkbid0IGRlY29kZSBBcnJheSBhcyBKU09OOiAke3ZhbHVlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgb3V0VmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dFZhbHVlO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWZhbGx0aHJvdWdoICovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0dGVyL2dldHRlciBwYWlyIGZvciB0aGUgbmFtZWQgcHJvcGVydHkgd2l0aCBpdHMgb3duXG4gICAgICogbG9jYWwgc3RvcmFnZS4gIFRoZSBnZXR0ZXIgcmV0dXJucyB0aGUgdmFsdWUgaW4gdGhlIGxvY2FsIHN0b3JhZ2UsXG4gICAgICogYW5kIHRoZSBzZXR0ZXIgY2FsbHMgYF9zZXRQcm9wZXJ0eWAsIHdoaWNoIHVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2VcbiAgICAgKiBmb3IgdGhlIHByb3BlcnR5IGFuZCBlbnF1ZXVlcyBhIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBvbiBhIHByb3RvdHlwZSBvciBhbiBpbnN0YW5jZS4gIENhbGxpbmdcbiAgICAgKiB0aGlzIG1ldGhvZCBtYXkgb3ZlcndyaXRlIGEgcHJvcGVydHkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvblxuICAgICAqIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgYnkgY3JlYXRpbmcgdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uXG4gICAgICogYSBwcm90b3R5cGUsIGFueSBvdmVyd3JpdHRlbiB2YWx1ZXMgYXJlIHNhdmVkIGluIGBfX2RhdGFQcm90b2AsXG4gICAgICogYW5kIGl0IGlzIHVwIHRvIHRoZSBzdWJjbGFzc2VyIHRvIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhvc2VcbiAgICAgKiBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3IuICBXaGVuIGNhbGxpbmcgb24gYW4gaW5zdGFuY2UsXG4gICAgICogdGhlIG92ZXJ3cml0dGVuIHZhbHVlIGlzIHNldCB2aWEgYF9zZXRQZW5kaW5nUHJvcGVydHlgLCBhbmQgdGhlXG4gICAgICogdXNlciBzaG91bGQgY2FsbCBgX2ludmFsaWRhdGVQcm9wZXJ0aWVzYCBvciBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgKiBmb3IgdGhlIHZhbHVlcyB0byB0YWtlIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHJlYWRPbmx5IFdoZW4gdHJ1ZSwgbm8gc2V0dGVyIGlzIGNyZWF0ZWQ7IHRoZVxuICAgICAqICAgcHJvdGVjdGVkIGBfc2V0UHJvcGVydHlgIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBzZXQgdGhlIHByb3BlcnR5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCByZWFkT25seSkge1xuICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdfX2RhdGFIYXNBY2Nlc3NvcicpKSB7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0pIHtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBzYXZlQWNjZXNzb3JWYWx1ZSh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwge1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4gICAgICAgICAgLyoqIEB0aGlzIHtQcm9wZXJ0eUFjY2Vzc29yc30gKi9cbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgc2V0OiByZWFkT25seSA/IGZ1bmN0aW9uKCkge30gOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsaWJyYXJ5IGNyZWF0ZWQgYW4gYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBhY2Nlc3NvciB3YXMgY3JlYXRlZFxuICAgICAqL1xuICAgIF9oYXNBY2Nlc3Nvcihwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IgJiYgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wZXJ0eV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSAodmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YClcbiAgICAgKiBhbmQgZW5xdWV1ZXMgYSBgX3Byb2VwcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHksIHJlY29yZHMgdGhlIHByZXZpb3VzIHZhbHVlLFxuICAgICAqIGFuZCBhZGRzIGl0IHRvIHRoZSBzZXQgb2YgXCJwZW5kaW5nIGNoYW5nZXNcIiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLiAgVGhpcyBtZXRob2QgZG9lcyBub3QgZW5xdWV1ZSB0aGVcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBsZXQgb2xkID0gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLl9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCk7XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIG9sZCBpcyBjYXB0dXJlZCBmcm9tIHRoZSBsYXN0IHR1cm5cbiAgICAgICAgaWYgKHRoaXMuX19kYXRhT2xkICYmICEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGRbcHJvcGVydHldID0gb2xkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHByb3BlcnR5IGhhcyBhIHBlbmRpbmcgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pc1Byb3BlcnR5UGVuZGluZyhwcm9wKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9fZGF0YVBlbmRpbmcgJiYgKHByb3AgaW4gdGhpcy5fX2RhdGFQZW5kaW5nKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHByb3BlcnRpZXMgYXMgaW52YWxpZCwgYW5kIGVucXVldWVzIGFuIGFzeW5jXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUludmFsaWQgJiYgdGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSB0cnVlO1xuICAgICAgICBtaWNyb3Rhc2sucnVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB0byBlbmFibGUgcHJvcGVydHkgYWNjZXNzb3IgcHJvY2Vzc2luZy4gQmVmb3JlIHRoaXMgbWV0aG9kIGlzXG4gICAgICogY2FsbGVkIGFjY2Vzc29yIHZhbHVlcyB3aWxsIGJlIHNldCBidXQgc2lkZSBlZmZlY3RzIGFyZVxuICAgICAqIHF1ZXVlZC4gV2hlbiBjYWxsZWQsIGFueSBwZW5kaW5nIHNpZGUgZWZmZWN0cyBvY2N1ciBpbW1lZGlhdGVseS5cbiAgICAgKiBGb3IgZWxlbWVudHMsIGdlbmVyYWxseSBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGEgbm9ybWFsIHNwb3QgdG8gZG8gc28uXG4gICAgICogSXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIGFzIGl0IG9ubHkgdHVybnMgb25cbiAgICAgKiBwcm9wZXJ0eSBhY2Nlc3NvcnMgb25jZS5cbiAgICAgKi9cbiAgICBfZW5hYmxlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyk7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrIHdpdGggdGhlIGN1cnJlbnQgc2V0IG9mXG4gICAgICogcGVuZGluZyBjaGFuZ2VzIChhbmQgb2xkIHZhbHVlcyByZWNvcmRlZCB3aGVuIHBlbmRpbmcgY2hhbmdlcyB3ZXJlXG4gICAgICogc2V0KSwgYW5kIHJlc2V0cyB0aGUgcGVuZGluZyBzZXQgb2YgY2hhbmdlcy4gR2VuZXJhbGx5LCB0aGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBub3QgYmUgY2FsbGVkIGluIHVzZXIgY29kZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9mbHVzaFByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFQZW5kaW5nICYmIHRoaXMuX19kYXRhT2xkKSB7XG4gICAgICAgIGxldCBjaGFuZ2VkUHJvcHMgPSB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX19kYXRhQ291bnRlcisrO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzQ2hhbmdlZCh0aGlzLl9fZGF0YSwgY2hhbmdlZFByb3BzLCB0aGlzLl9fZGF0YU9sZCk7XG4gICAgICAgIHRoaXMuX19kYXRhQ291bnRlci0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpZmVjeWNsZSBjYWxsYmFjayBjYWxsZWQgdGhlIGZpcnN0IHRpbWUgcHJvcGVydGllcyBhcmUgYmVpbmcgZmx1c2hlZC5cbiAgICAgKiBQcmlvciB0byBgcmVhZHlgLCBhbGwgcHJvcGVydHkgc2V0cyB0aHJvdWdoIGFjY2Vzc29ycyBhcmUgcXVldWVkIGFuZFxuICAgICAqIHRoZWlyIGVmZmVjdHMgYXJlIGZsdXNoZWQgYWZ0ZXIgdGhpcyBtZXRob2QgcmV0dXJucy5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIGltcGxlbWVudCBiZWhhdmlvciB0aGF0IGlzXG4gICAgICogZGVwZW5kZW50IG9uIHRoZSBlbGVtZW50IGhhdmluZyBpdHMgcHJvcGVydGllcyBpbml0aWFsaXplZCwgZS5nLlxuICAgICAqIGZyb20gZGVmYXVsdHMgKGluaXRpYWxpemVkIGZyb20gYGNvbnN0cnVjdG9yYCwgYF9pbml0aWFsaXplUHJvcGVydGllc2ApLFxuICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvciB2YWx1ZXMgcHJvcGFnYXRlZCBmcm9tIGhvc3QgZS5nLiB2aWFcbiAgICAgKiBiaW5kaW5ncy4gIGBzdXBlci5yZWFkeSgpYCBtdXN0IGJlIGNhbGxlZCB0byBlbnN1cmUgdGhlIGRhdGEgc3lzdGVtXG4gICAgICogYmVjb21lcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IHRydWU7XG4gICAgICAvLyBSdW4gbm9ybWFsIGZsdXNoXG4gICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiBhbnkgcHJvcGVydGllcyB3aXRoIGFjY2Vzc29ycyBjcmVhdGVkIHZpYVxuICAgICAqIGBfY3JlYXRlUHJvcGVydHlBY2Nlc3NvcmAgaGF2ZSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gY3VycmVudFByb3BzIEJhZyBvZiBhbGwgY3VycmVudCBhY2Nlc3NvciB2YWx1ZXNcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgcHJvcGVydGllcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0XG4gICAgICogICBjYWxsIHRvIGBfcHJvcGVydGllc0NoYW5nZWRgXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICogICBpbiBgY2hhbmdlZFByb3BzYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcHJvcGVydGllc0NoYW5nZWQoY3VycmVudFByb3BzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FsbGVkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcHJvcGVydHkgdmFsdWUgc2hvdWxkIGJlXG4gICAgICogY29uc2lkZXJlZCBhcyBhIGNoYW5nZSBhbmQgY2F1c2UgdGhlIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICogdG8gYmUgZW5xdWV1ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgcHJpbWl0aXZlIHR5cGVzIGlmIGFcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgZmFpbHMsIGFuZCByZXR1cm5zIGB0cnVlYCBmb3IgYWxsIE9iamVjdC9BcnJheXMuXG4gICAgICogVGhlIG1ldGhvZCBhbHdheXMgcmV0dXJucyBmYWxzZSBmb3IgYE5hTmAuXG4gICAgICpcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBlLmcuIHByb3ZpZGUgc3RyaWN0ZXIgY2hlY2tpbmcgZm9yXG4gICAgICogT2JqZWN0cy9BcnJheXMgd2hlbiB1c2luZyBpbW11dGFibGUgcGF0dGVybnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqICAgYW5kIGVucXVldWUgYSBgX3Byb2VwcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIFN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgICAgICAob2xkICE9PSB2YWx1ZSAmJlxuICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIChvbGQ9PU5hTiwgdmFsdWU9PU5hTikgYWx3YXlzIHJldHVybnMgZmFsc2VcbiAgICAgICAgIChvbGQgPT09IG9sZCB8fCB2YWx1ZSA9PT0gdmFsdWUpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQcm9wZXJ0eUFjY2Vzc29ycztcblxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcblxuLy8gMS54IGJhY2t3YXJkcy1jb21wYXRpYmxlIGF1dG8td3JhcHBlciBmb3IgdGVtcGxhdGUgdHlwZSBleHRlbnNpb25zXG4vLyBUaGlzIGlzIGEgY2xlYXIgbGF5ZXJpbmcgdmlvbGF0aW9uIGFuZCBnaXZlcyBmYXZvcmVkLW5hdGlvbiBzdGF0dXMgdG9cbi8vIGRvbS1pZiBhbmQgZG9tLXJlcGVhdCB0ZW1wbGF0ZXMuICBUaGlzIGlzIGEgY29uY2VpdCB3ZSdyZSBjaG9vc2luZyB0byBrZWVwXG4vLyBhLikgdG8gZWFzZSAxLnggYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZHVlIHRvIGxvc3Mgb2YgYGlzYCwgYW5kXG4vLyBiLikgdG8gbWFpbnRhaW4gaWYvcmVwZWF0IGNhcGFiaWxpdHkgaW4gcGFyc2VyLWNvbnN0cmFpbmVkIGVsZW1lbnRzXG4vLyAgICAgKGUuZy4gdGFibGUsIHNlbGVjdCkgaW4gbGlldSBvZiBuYXRpdmUgQ0UgdHlwZSBleHRlbnNpb25zIHdpdGhvdXRcbi8vICAgICBtYXNzaXZlIG5ldyBpbnZlbnRpb24gaW4gdGhpcyBzcGFjZSAoZS5nLiBkaXJlY3RpdmUgc3lzdGVtKVxuY29uc3QgdGVtcGxhdGVFeHRlbnNpb25zID0ge1xuICAnZG9tLWlmJzogdHJ1ZSxcbiAgJ2RvbS1yZXBlYXQnOiB0cnVlXG59O1xuZnVuY3Rpb24gd3JhcFRlbXBsYXRlRXh0ZW5zaW9uKG5vZGUpIHtcbiAgbGV0IGlzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lzJyk7XG4gIGlmIChpcyAmJiB0ZW1wbGF0ZUV4dGVuc2lvbnNbaXNdKSB7XG4gICAgbGV0IHQgPSBub2RlO1xuICAgIHQucmVtb3ZlQXR0cmlidXRlKCdpcycpO1xuICAgIG5vZGUgPSB0Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChpcyk7XG4gICAgdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCB0KTtcbiAgICBub2RlLmFwcGVuZENoaWxkKHQpO1xuICAgIHdoaWxlKHQuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lLCB0LmF0dHJpYnV0ZXNbMF0udmFsdWUpO1xuICAgICAgdC5yZW1vdmVBdHRyaWJ1dGUodC5hdHRyaWJ1dGVzWzBdLm5hbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mbykge1xuICAvLyByZWN1cnNpdmVseSBhc2NlbmQgdHJlZSB1bnRpbCB3ZSBoaXQgcm9vdFxuICBsZXQgcGFyZW50ID0gbm9kZUluZm8ucGFyZW50SW5mbyAmJiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvLnBhcmVudEluZm8pO1xuICAvLyB1bndpbmQgdGhlIHN0YWNrLCByZXR1cm5pbmcgdGhlIGluZGV4ZWQgbm9kZSBhdCBlYWNoIGxldmVsXG4gIGlmIChwYXJlbnQpIHtcbiAgICAvLyBub3RlOiBtYXJnaW5hbGx5IGZhc3RlciB0aGFuIGluZGV4aW5nIHZpYSBjaGlsZE5vZGVzXG4gICAgLy8gKGh0dHA6Ly9qc3BlcmYuY29tL2NoaWxkbm9kZXMtbG9va3VwKVxuICAgIGZvciAobGV0IG49cGFyZW50LmZpcnN0Q2hpbGQsIGk9MDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAobm9kZUluZm8ucGFyZW50SW5kZXggPT09IGkrKykge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cbn1cblxuLy8gY29uc3RydWN0IGAkYCBtYXAgKGZyb20gaWQgYW5ub3RhdGlvbnMpXG5mdW5jdGlvbiBhcHBseUlkVG9NYXAoaW5zdCwgbWFwLCBub2RlLCBub2RlSW5mbykge1xuICBpZiAobm9kZUluZm8uaWQpIHtcbiAgICBtYXBbbm9kZUluZm8uaWRdID0gbm9kZTtcbiAgfVxufVxuXG4vLyBpbnN0YWxsIGV2ZW50IGxpc3RlbmVycyAoZnJvbSBldmVudCBhbm5vdGF0aW9ucylcbmZ1bmN0aW9uIGFwcGx5RXZlbnRMaXN0ZW5lcihpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICBpZiAobm9kZUluZm8uZXZlbnRzICYmIG5vZGVJbmZvLmV2ZW50cy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBqPTAsIGUkPW5vZGVJbmZvLmV2ZW50cywgZTsgKGo8ZSQubGVuZ3RoKSAmJiAoZT1lJFtqXSk7IGorKykge1xuICAgICAgaW5zdC5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBlLm5hbWUsIGUudmFsdWUsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBwdXNoIGNvbmZpZ3VyYXRpb24gcmVmZXJlbmNlcyBhdCBjb25maWd1cmUgdGltZVxuZnVuY3Rpb24gYXBwbHlUZW1wbGF0ZUNvbnRlbnQoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLnRlbXBsYXRlSW5mbykge1xuICAgIG5vZGUuX3RlbXBsYXRlSW5mbyA9IG5vZGVJbmZvLnRlbXBsYXRlSW5mbztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAvLyBJbnN0YW5jZXMgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhIF9tZXRob2RIb3N0IHdoaWNoIGFsbG93cyByZWRpcmVjdGluZyB3aGVyZVxuICAvLyB0byBmaW5kIG1ldGhvZHMuIEN1cnJlbnRseSB1c2VkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgY29udGV4dCA9IGNvbnRleHQuX21ldGhvZEhvc3QgfHwgY29udGV4dDtcbiAgbGV0IGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNvbnRleHRbbWV0aG9kTmFtZV0pIHtcbiAgICAgIGNvbnRleHRbbWV0aG9kTmFtZV0oZSwgZS5kZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2xpc3RlbmVyIG1ldGhvZCBgJyArIG1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhbmRsZXI7XG59XG5cbmV4cG9ydCBjb25zdCBUZW1wbGF0ZVN0YW1wID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICovXG4gIGNsYXNzIFRlbXBsYXRlU3RhbXAgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgIC8qKlxuICAgICAqIFNjYW5zIGEgdGVtcGxhdGUgdG8gcHJvZHVjZSB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIFRlbXBsYXRlLXNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gdGhlIG9iamVjdCByZXR1cm5lZCwgYW5kIG5vZGUtXG4gICAgICogc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiBvYmplY3RzIGluIGl0cyBmbGF0dGVuZWQgYG5vZGVJbmZvTGlzdGBcbiAgICAgKiBhcnJheS4gIE9ubHkgbm9kZXMgaW4gdGhlIHRlbXBsYXRlIHRoYXQgd2VyZSBwYXJzZWQgYXMgbm9kZXMgb2ZcbiAgICAgKiBpbnRlcmVzdCBjb250YWluIGFuIG9iamVjdCBpbiBgbm9kZUluZm9MaXN0YC4gIEVhY2ggYG5vZGVJbmZvYCBvYmplY3RcbiAgICAgKiBjb250YWlucyBhbiBgaW5kZXhgIChgY2hpbGROb2Rlc2AgaW5kZXggaW4gcGFyZW50KSBhbmQgb3B0aW9uYWxseVxuICAgICAqIGBwYXJlbnRgLCB3aGljaCBwb2ludHMgdG8gbm9kZSBpbmZvIG9mIGl0cyBwYXJlbnQgKGluY2x1ZGluZyBpdHMgaW5kZXgpLlxuICAgICAqXG4gICAgICogVGhlIHRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoaXMgbWV0aG9kIGhhcyB0aGUgZm9sbG93aW5nXG4gICAgICogc3RydWN0dXJlIChtYW55IGZpZWxkcyBvcHRpb25hbCk6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqICAge1xuICAgICAqICAgICAvLyBGbGF0dGVuZWQgbGlzdCBvZiBub2RlIG1ldGFkYXRhIChmb3Igbm9kZXMgdGhhdCBnZW5lcmF0ZWQgbWV0YWRhdGEpXG4gICAgICogICAgIG5vZGVJbmZvTGlzdDogW1xuICAgICAqICAgICAgIHtcbiAgICAgKiAgICAgICAgIC8vIGBpZGAgYXR0cmlidXRlIGZvciBhbnkgbm9kZXMgd2l0aCBpZCdzIGZvciBnZW5lcmF0aW5nIGAkYCBtYXBcbiAgICAgKiAgICAgICAgIGlkOiB7c3RyaW5nfSxcbiAgICAgKiAgICAgICAgIC8vIGBvbi1ldmVudD1cImhhbmRsZXJcImAgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIGV2ZW50czogW1xuICAgICAqICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgbmFtZToge3N0cmluZ30sICAgLy8gZXZlbnQgbmFtZVxuICAgICAqICAgICAgICAgICAgIHZhbHVlOiB7c3RyaW5nfSwgIC8vIGhhbmRsZXIgbWV0aG9kIG5hbWVcbiAgICAgKiAgICAgICAgICAgfSwgLi4uXG4gICAgICogICAgICAgICBdLFxuICAgICAqICAgICAgICAgLy8gTm90ZXMgd2hlbiB0aGUgdGVtcGxhdGUgY29udGFpbmVkIGEgYDxzbG90PmAgZm9yIHNoYWR5IERPTVxuICAgICAqICAgICAgICAgLy8gb3B0aW1pemF0aW9uIHB1cnBvc2VzXG4gICAgICogICAgICAgICBoYXNJbnNlcnRpb25Qb2ludDoge2Jvb2xlYW59LFxuICAgICAqICAgICAgICAgLy8gRm9yIG5lc3RlZCBgPHRlbXBsYXRlPmBgIG5vZGVzLCBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIHRlbXBsYXRlSW5mbzoge29iamVjdH0sIC8vIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqICAgICAgICAgLy8gTWV0YWRhdGEgdG8gYWxsb3cgZWZmaWNpZW50IHJldHJpZXZhbCBvZiBpbnN0YW5jZWQgbm9kZVxuICAgICAqICAgICAgICAgLy8gY29ycmVzcG9uZGluZyB0byB0aGlzIG1ldGFkYXRhXG4gICAgICogICAgICAgICBwYXJlbnRJbmZvOiB7bnVtYmVyfSwgICAvLyByZWZlcmVuY2UgdG8gcGFyZW50IG5vZGVJbmZvPlxuICAgICAqICAgICAgICAgcGFyZW50SW5kZXg6IHtudW1iZXJ9LCAgLy8gaW5kZXggaW4gcGFyZW50J3MgYGNoaWxkTm9kZXNgIGNvbGxlY3Rpb25cbiAgICAgKiAgICAgICAgIGluZm9JbmRleDoge251bWJlcn0sICAgIC8vIGluZGV4IG9mIHRoaXMgYG5vZGVJbmZvYCBpbiBgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdGBcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgICBdLFxuICAgICAqICAgICAvLyBXaGVuIHRydWUsIHRoZSB0ZW1wbGF0ZSBoYWQgdGhlIGBzdHJpcC13aGl0ZXNwYWNlYCBhdHRyaWJ1dGVcbiAgICAgKiAgICAgLy8gb3Igd2FzIG5lc3RlZCBpbiBhIHRlbXBsYXRlIHdpdGggdGhhdCBzZXR0aW5nXG4gICAgICogICAgIHN0cmlwV2hpdGVzcGFjZToge2Jvb2xlYW59LFxuICAgICAqICAgICAvLyBGb3IgbmVzdGVkIHRlbXBsYXRlcywgbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQgaXMgbW92ZWQgaW50b1xuICAgICAqICAgICAvLyBhIGRvY3VtZW50IGZyYWdtZW50IHN0b3JlZCBoZXJlOyB0aGlzIGlzIGFuIG9wdGltaXphdGlvbiB0b1xuICAgICAqICAgICAvLyBhdm9pZCB0aGUgY29zdCBvZiBuZXN0ZWQgdGVtcGxhdGUgY2xvbmluZ1xuICAgICAqICAgICBjb250ZW50OiB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICAgKiAgIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGtpY2tzIG9mZiBhIHJlY3Vyc2l2ZSB0cmVld2FsayBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgX3BhcnNlVGVtcGxhdGUgPC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgIF9wYXJzZVRlbXBsYXRlQ29udGVudCAgICAgICAgICAgICAgfFxuICAgICAqICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGUgIDwtLS0tLS0tLS0tLS18LS0rXG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZSAtLSsgIHxcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMgLS0tLS0tLS0tK1xuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXNcbiAgICAgKiAgICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbWV0YWRhdGEgYWJvdXQgdGVtcGxhdGVzXG4gICAgICogdG8gZWl0aGVyIGB0ZW1wbGF0ZUluZm9gIG9yIGBub2RlSW5mb2AuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgbWF5IGJlIGRlc3RydWN0aXZlIHRvIHRoZSB0ZW1wbGF0ZSwgaW4gdGhhdFxuICAgICAqIGUuZy4gZXZlbnQgYW5ub3RhdGlvbnMgbWF5IGJlIHJlbW92ZWQgYWZ0ZXIgYmVpbmcgbm90ZWQgaW4gdGhlXG4gICAgICogdGVtcGxhdGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvPX0gb3V0ZXJUZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZnJvbSB0aGUgb3V0ZXJcbiAgICAgKiAgIHRlbXBsYXRlLCBmb3IgcGFyc2luZyBuZXN0ZWQgdGVtcGxhdGVzXG4gICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gUGFyc2VkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBvdXRlclRlbXBsYXRlSW5mbykge1xuICAgICAgLy8gc2luY2UgYSB0ZW1wbGF0ZSBtYXkgYmUgcmUtdXNlZCwgbWVtby1pemUgbWV0YWRhdGFcbiAgICAgIGlmICghdGVtcGxhdGUuX3RlbXBsYXRlSW5mbykge1xuICAgICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbyA9IHt9O1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0ID0gW107XG4gICAgICAgIHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgPVxuICAgICAgICAgIChvdXRlclRlbXBsYXRlSW5mbyAmJiBvdXRlclRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UpIHx8XG4gICAgICAgICAgdGVtcGxhdGUuaGFzQXR0cmlidXRlKCdzdHJpcC13aGl0ZXNwYWNlJyk7XG4gICAgICAgIHRoaXMuX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIHtwYXJlbnQ6IG51bGx9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhbmQgYWRkcyB0ZW1wbGF0ZSBhbmQgbm9kZSBtZXRhZGF0YSBiYXNlZCBvblxuICAgICAqIHRoZSBjdXJyZW50IG5vZGUsIGFuZCBpdHMgYGNoaWxkTm9kZXNgIGFuZCBgYXR0cmlidXRlc2AuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG5vZGUgb3IgdGVtcGxhdGUgc3BlY2lmaWNcbiAgICAgKiBtZXRhZGF0YSBiYXNlZCBvbiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IG5vdGVkO1xuICAgICAgbGV0IGVsZW1lbnQgPSAvKiogQHR5cGUgRWxlbWVudCAqLyhub2RlKTtcbiAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncHJlc2VydmUtY29udGVudCcpKSB7XG4gICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIC8vIEZvciBTaGFkeURvbSBvcHRpbWl6YXRpb24sIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICAgIHRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGVzICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjaGlsZCBub2RlcyBmb3IgdGhlIGdpdmVuIHJvb3Qgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsc28gd3JhcHMgd2hpdGVsaXN0ZWQgbGVnYWN5IHRlbXBsYXRlIGV4dGVuc2lvbnNcbiAgICAgKiAoYGlzPVwiZG9tLWlmXCJgIGFuZCBgaXM9XCJkb20tcmVwZWF0XCJgKSB3aXRoIHRoZWlyIGVxdWl2YWxlbnQgZWxlbWVudFxuICAgICAqIHdyYXBwZXJzLCBjb2xsYXBzZXMgdGV4dCBub2RlcywgYW5kIHN0cmlwcyB3aGl0ZXNwYWNlIGZyb20gdGhlIHRlbXBsYXRlXG4gICAgICogaWYgdGhlIGB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZXNwYWNlYCBzZXR0aW5nIHdhcyBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gcm9vdCBSb290IG5vZGUgd2hvc2UgYGNoaWxkTm9kZXNgIHdpbGwgYmUgcGFyc2VkXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKHJvb3QsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGZvciAobGV0IG5vZGU9cm9vdC5maXJzdENoaWxkLCBwYXJlbnRJbmRleD0wLCBuZXh0OyBub2RlOyBub2RlPW5leHQpIHtcbiAgICAgICAgLy8gV3JhcCB0ZW1wbGF0ZXNcbiAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICBub2RlID0gd3JhcFRlbXBsYXRlRXh0ZW5zaW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbGxhcHNlIGFkamFjZW50IHRleHROb2RlczogZml4ZXMgYW4gSUUgaXNzdWUgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgLy8gdGV4dCBub2RlcyB0byBiZSBpbmV4cGxpY2FibHkgc3BsaXQgPShcbiAgICAgICAgLy8gbm90ZSB0aGF0IHJvb3Qubm9ybWFsaXplKCkgc2hvdWxkIHdvcmsgYnV0IGRvZXMgbm90IHNvIHdlIGRvIHRoaXNcbiAgICAgICAgLy8gbWFudWFsbHkuXG4gICAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBsZXQgLyoqIE5vZGUgKi8gbiA9IG5leHQ7XG4gICAgICAgICAgd2hpbGUgKG4gJiYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSkge1xuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCArPSBuLnRleHRDb250ZW50O1xuICAgICAgICAgICAgbmV4dCA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICAgICAgbiA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG9wdGlvbmFsbHkgc3RyaXAgd2hpdGVzcGFjZVxuICAgICAgICAgIGlmICh0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlICYmICFub2RlLnRleHRDb250ZW50LnRyaW0oKSkge1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRJbmZvID0geyBwYXJlbnRJbmRleCwgcGFyZW50SW5mbzogbm9kZUluZm8gfTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgY2hpbGRJbmZvKSkge1xuICAgICAgICAgIGNoaWxkSW5mby5pbmZvSW5kZXggPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0LnB1c2goLyoqIEB0eXBlIHshTm9kZUluZm99ICovKGNoaWxkSW5mbykpIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbmNyZW1lbnQgaWYgbm90IHJlbW92ZWRcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHBhcmVudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY29udGVudCBmb3IgdGhlIGdpdmVuIG5lc3RlZCBgPHRlbXBsYXRlPmAuXG4gICAgICpcbiAgICAgKiBOZXN0ZWQgdGVtcGxhdGUgaW5mbyBpcyBzdG9yZWQgYXMgYHRlbXBsYXRlSW5mb2AgaW4gdGhlIGN1cnJlbnQgbm9kZSdzXG4gICAgICogYG5vZGVJbmZvYC4gYHRlbXBsYXRlLmNvbnRlbnRgIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBgdGVtcGxhdGVJbmZvYC5cbiAgICAgKiBJdCB3aWxsIHRoZW4gYmUgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBob3N0IHRvIHNldCBpdCBiYWNrIHRvIHRoZVxuICAgICAqIHRlbXBsYXRlIGFuZCBmb3IgdXNlcnMgc3RhbXBpbmcgbmVzdGVkIHRlbXBsYXRlcyB0byB1c2UgdGhlXG4gICAgICogYF9jb250ZW50Rm9yVGVtcGxhdGVgIG1ldGhvZCB0byByZXRyaWV2ZSB0aGUgY29udGVudCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICAgICAqIChhbiBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZSAoYSA8dGVtcGxhdGU+KVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqICAgdGhhdCBpbmNsdWRlcyB0aGUgdGVtcGxhdGUgYG5vZGVgXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX3BhcnNlVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8pO1xuICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCA9XG4gICAgICAgIG5vZGUuY29udGVudC5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZS5jb250ZW50KTtcbiAgICAgIG5vZGVJbmZvLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZXMgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogZm9yIG5vZGVzIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgLy8gTWFrZSBjb3B5IG9mIG9yaWdpbmFsIGF0dHJpYnV0ZSBsaXN0LCBzaW5jZSB0aGUgb3JkZXIgbWF5IGNoYW5nZVxuICAgICAgLy8gYXMgYXR0cmlidXRlcyBhcmUgYWRkZWQgYW5kIHJlbW92ZWRcbiAgICAgIGxldCBub3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGF0dHJzID0gQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpO1xuICAgICAgZm9yIChsZXQgaT1hdHRycy5sZW5ndGgtMSwgYTsgKGE9YXR0cnNbaV0pOyBpLS0pIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBhLm5hbWUsIGEudmFsdWUpIHx8IG5vdGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNpbmdsZSB0ZW1wbGF0ZSBub2RlIGF0dHJpYnV0ZSBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvXG4gICAgICogYG5vZGVJbmZvYCBmb3IgYXR0cmlidXRlcyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gYWRkcyBtZXRhZGF0YSBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICogYW5kIGBpZGAgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgLy8gZXZlbnRzIChvbi0qKVxuICAgICAgaWYgKG5hbWUuc2xpY2UoMCwgMykgPT09ICdvbi0nKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBub2RlSW5mby5ldmVudHMgPSBub2RlSW5mby5ldmVudHMgfHwgW107XG4gICAgICAgIG5vZGVJbmZvLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lLnNsaWNlKDMpLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHN0YXRpYyBpZFxuICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICBub2RlSW5mby5pZCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgY29udGVudGAgZG9jdW1lbnQgZnJhZ21lbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBGb3IgbmVzdGVkIHRlbXBsYXRlcywgUG9seW1lciBwZXJmb3JtcyBhbiBvcHRpbWl6YXRpb24gdG8gY2FjaGUgbmVzdGVkXG4gICAgICogdGVtcGxhdGUgY29udGVudCB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIGRlZXBseSBuZXN0ZWQgdGVtcGxhdGVzLlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHJpZXZlcyB0aGUgY2FjaGVkIGNvbnRlbnQgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHJldHJpZXZlIGBjb250ZW50YCBmb3JcbiAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBDb250ZW50IGZyYWdtZW50XG4gICAgICovXG4gICAgc3RhdGljIF9jb250ZW50Rm9yVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnRXaXRoSW5mb30gKi8gKHRlbXBsYXRlKS5fdGVtcGxhdGVJbmZvO1xuICAgICAgcmV0dXJuICh0ZW1wbGF0ZUluZm8gJiYgdGVtcGxhdGVJbmZvLmNvbnRlbnQpIHx8IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZSBjb250ZW50IGFuZCByZXR1cm5zIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgKiBjb250YWluaW5nIHRoZSBjbG9uZWQgZG9tLlxuICAgICAqXG4gICAgICogVGhlIHRlbXBsYXRlIGlzIHBhcnNlZCAob25jZSBhbmQgbWVtb2l6ZWQpIHVzaW5nIHRoaXMgbGlicmFyeSdzXG4gICAgICogdGVtcGxhdGUgcGFyc2luZyBmZWF0dXJlcywgYW5kIHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgdmFsdWUtYWRkZWRcbiAgICAgKiBmZWF0dXJlczpcbiAgICAgKiAqIEFkZHMgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIGF0dHJpYnV0ZXNcbiAgICAgKiAqIEdlbmVyYXRlcyBhbiBcImlkIG1hcFwiIGZvciBhbGwgbm9kZXMgd2l0aCBpZCdzIHVuZGVyIGAkYCBvbiByZXR1cm5lZFxuICAgICAqICAgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgKiAqIFBhc3NlcyB0ZW1wbGF0ZSBpbmZvIGluY2x1ZGluZyBgY29udGVudGAgYmFjayB0byB0ZW1wbGF0ZXMgYXNcbiAgICAgKiAgIGBfdGVtcGxhdGVJbmZvYCAoYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgZGVlcCB0ZW1wbGF0ZVxuICAgICAqICAgY2xvbmluZylcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgbWVtb2l6ZWQgdGVtcGxhdGUgcGFyc2luZyBwcm9jZXNzIGlzIGRlc3RydWN0aXZlIHRvIHRoZVxuICAgICAqIHRlbXBsYXRlOiBhdHRyaWJ1dGVzIGZvciBiaW5kaW5ncyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzIGFyZVxuICAgICAqIHJlbW92ZWQgYWZ0ZXIgYmVpbmcgbm90ZWQgaW4gbm90ZXMsIGFuZCBhbnkgbmVzdGVkIGA8dGVtcGxhdGU+LmNvbnRlbnRgXG4gICAgICogaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIG5vdGVzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBzdGFtcFxuICAgICAqIEByZXR1cm4geyFTdGFtcGVkVGVtcGxhdGV9IENsb25lZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICovXG4gICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIC8vIFBvbHlmaWxsIHN1cHBvcnQ6IGJvb3RzdHJhcCB0aGUgdGVtcGxhdGUgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW5cbiAgICAgIGlmICh0ZW1wbGF0ZSAmJiAhdGVtcGxhdGUuY29udGVudCAmJlxuICAgICAgICAgIHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50ICYmIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUpIHtcbiAgICAgICAgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBsZXQgbm9kZUluZm8gPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0O1xuICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZUluZm8uY29udGVudCB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgbGV0IGRvbSA9IC8qKiBAdHlwZSBEb2N1bWVudEZyYWdtZW50ICovIChkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpKTtcbiAgICAgIC8vIE5PVEU6IFNoYWR5RG9tIG9wdGltaXphdGlvbiBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgZG9tLl9fbm9JbnNlcnRpb25Qb2ludCA9ICF0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQ7XG4gICAgICBsZXQgbm9kZXMgPSBkb20ubm9kZUxpc3QgPSBuZXcgQXJyYXkobm9kZUluZm8ubGVuZ3RoKTtcbiAgICAgIGRvbS4kID0ge307XG4gICAgICBmb3IgKGxldCBpPTAsIGw9bm9kZUluZm8ubGVuZ3RoLCBpbmZvOyAoaTxsKSAmJiAoaW5mbz1ub2RlSW5mb1tpXSk7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldID0gZmluZFRlbXBsYXRlTm9kZShkb20sIGluZm8pO1xuICAgICAgICBhcHBseUlkVG9NYXAodGhpcywgZG9tLiQsIG5vZGUsIGluZm8pO1xuICAgICAgICBhcHBseVRlbXBsYXRlQ29udGVudCh0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgICAgYXBwbHlFdmVudExpc3RlbmVyKHRoaXMsIG5vZGUsIGluZm8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVN0YW1wZWRUZW1wbGF0ZX0gKi8oZG9tKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGJ5IG1ldGhvZCBuYW1lIGZvciB0aGUgZXZlbnQgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBnZW5lcmF0ZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgbG9va3MgdXAgdGhlIG1ldGhvZFxuICAgICAqIG5hbWUgYXQgaGFuZGxpbmcgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBsaXN0ZW5lciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgbWV0aG9kXG4gICAgICogQHBhcmFtIHsqPX0gY29udGV4dCBDb250ZXh0IHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb24gKGRlZmF1bHRzXG4gICAgICogICB0byBgbm9kZWApXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEdlbmVyYXRlZCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBub2RlO1xuICAgICAgbGV0IGhhbmRsZXIgPSBjcmVhdGVOb2RlRXZlbnRIYW5kbGVyKGNvbnRleHQsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIGFkZFxuICAgICAqL1xuICAgIF9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBUZW1wbGF0ZVN0YW1wO1xuXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvY29sb3IuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyc7XG5pbXBvcnQgeyBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBhZnRlck5leHRSZW5kZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcbmltcG9ydCB7IHNldFRvdWNoQWN0aW9uIH0gZnJvbSAnLi4vcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItdG9nZ2xlLWJ1dHRvblwiPlxuICA8dGVtcGxhdGUgc3RyaXAtd2hpdGVzcGFjZT1cIlwiPlxuXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1ob3Jpem9udGFsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6Zm9jdXMpIHtcbiAgICAgICAgb3V0bGluZTpub25lO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWJhciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMC40O1xuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIGxpbmVhciAuMDhzO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1iYXItY29sb3IsICMwMDAwMDApO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJhcjtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTNweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuICAgICAgICB3aWR0aDogMjBweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gICAgICAgIHRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIGxpbmVhciAuMDhzLCBiYWNrZ3JvdW5kLWNvbG9yIGxpbmVhciAuMDhzO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gbGluZWFyIC4wOHMsIGJhY2tncm91bmQtY29sb3IgbGluZWFyIC4wOHM7XG4gICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJ1dHRvbi1jb2xvciwgdmFyKC0tcGFwZXItZ3JleS01MCkpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1idXR0b24uZHJhZ2dpbmcge1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XG4gICAgICAgIHRyYW5zaXRpb246IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXTpub3QoW2Rpc2FibGVkXSkpIC50b2dnbGUtYmFyIHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYmFyLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJhcjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xuICAgICAgICBvcGFjaXR5OiAwLjEyO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbY2hlY2tlZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgxNnB4LCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTZweCwgMCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXTpub3QoW2Rpc2FibGVkXSkpIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJ1dHRvbi1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1idXR0b247XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2JkYmRiZDtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1pbmsge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTE0cHg7XG4gICAgICAgIGxlZnQ6IC0xNHB4O1xuICAgICAgICByaWdodDogYXV0bztcbiAgICAgICAgYm90dG9tOiBhdXRvO1xuICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtaW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1pbms7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXSkgLnRvZ2dsZS1pbmsge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWluay1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1pbms7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtY29udGFpbmVyIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAzNnB4O1xuICAgICAgICBoZWlnaHQ6IDE0cHg7XG4gICAgICAgIC8qIFRoZSB0b2dnbGUgYnV0dG9uIGhhcyBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiAtM3B4OyBUaGUgZXh0cmEgMXB4XG4gICAgICAgIC8qIGFjY291bnRzIGZvciB0aGUgdG9nZ2xlIGJ1dHRvbiBzaGFkb3cgYm94LiAqL1xuICAgICAgICBtYXJnaW46IDRweCAxcHg7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtbGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWxhYmVsLXNwYWNpbmcsIDhweCk7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1sYWJlbC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIGludmFsaWQgc3RhdGUgKi9cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtYmFyLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaW52YWxpZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1pbnZhbGlkLWJ1dHRvbi1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2ludmFsaWRdKSAudG9nZ2xlLWluayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtaW5rLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwidG9nZ2xlLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBpZD1cInRvZ2dsZUJhclwiIGNsYXNzPVwidG9nZ2xlLWJhclwiPjwvZGl2PlxuICAgICAgPGRpdiBpZD1cInRvZ2dsZUJ1dHRvblwiIGNsYXNzPVwidG9nZ2xlLWJ1dHRvblwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRvZ2dsZS1sYWJlbFwiPjxzbG90Pjwvc2xvdD48L2Rpdj5cblxuICA8L3RlbXBsYXRlPlxuXG4gIFxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci10b2dnbGUtYnV0dG9uJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JcbiAgXSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIHJvbGU6ICdidXR0b24nLFxuICAgICdhcmlhLXByZXNzZWQnOiAnZmFsc2UnLFxuICAgIHRhYmluZGV4OiAwXG4gIH0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcyBkdWUgdG8gdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICB0cmFjazogJ19vbnRyYWNrJ1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBhZnRlck5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUb3VjaEFjdGlvbih0aGlzLCAncGFuLXknKTtcbiAgICB9KTtcbiAgfSxcblxuICBfb250cmFjazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdHJhY2sgPSBldmVudC5kZXRhaWw7XG4gICAgaWYgKHRyYWNrLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLl90cmFja1N0YXJ0KHRyYWNrKTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrLnN0YXRlID09PSAndHJhY2snKSB7XG4gICAgICB0aGlzLl90cmFja01vdmUodHJhY2spO1xuICAgIH0gZWxzZSBpZiAodHJhY2suc3RhdGUgPT09ICdlbmQnKSB7XG4gICAgICB0aGlzLl90cmFja0VuZCh0cmFjayk7XG4gICAgfVxuICB9LFxuXG4gIF90cmFja1N0YXJ0OiBmdW5jdGlvbih0cmFjaykge1xuICAgIHRoaXMuX3dpZHRoID0gdGhpcy4kLnRvZ2dsZUJhci5vZmZzZXRXaWR0aCAvIDI7XG4gICAgLypcbiAgICAgKiBrZWVwIGFuIHRyYWNrLW9ubHkgY2hlY2sgc3RhdGUgdG8ga2VlcCB0aGUgZHJhZ2dpbmcgYmVoYXZpb3Igc21vb3RoXG4gICAgICogd2hpbGUgdG9nZ2xpbmcgYWN0aXZhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLl90cmFja0NoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG4gICAgdGhpcy4kLnRvZ2dsZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdkcmFnZ2luZycpO1xuICB9LFxuXG4gIF90cmFja01vdmU6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdmFyIGR4ID0gdHJhY2suZHg7XG4gICAgdGhpcy5feCA9IE1hdGgubWluKHRoaXMuX3dpZHRoLFxuICAgICAgICBNYXRoLm1heCgwLCB0aGlzLl90cmFja0NoZWNrZWQgPyB0aGlzLl93aWR0aCArIGR4IDogZHgpKTtcbiAgICB0aGlzLnRyYW5zbGF0ZTNkKHRoaXMuX3ggKyAncHgnLCAwLCAwLCB0aGlzLiQudG9nZ2xlQnV0dG9uKTtcbiAgICB0aGlzLl91c2VyQWN0aXZhdGUodGhpcy5feCA+ICh0aGlzLl93aWR0aCAvIDIpKTtcbiAgfSxcblxuICBfdHJhY2tFbmQ6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdGhpcy4kLnRvZ2dsZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnZ2luZycpO1xuICAgIHRoaXMudHJhbnNmb3JtKCcnLCB0aGlzLiQudG9nZ2xlQnV0dG9uKTtcbiAgfSxcblxuICAvLyBjdXN0b21pemUgdGhlIGVsZW1lbnQncyByaXBwbGVcbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmlwcGxlQ29udGFpbmVyID0gdGhpcy4kLnRvZ2dsZUJ1dHRvbjtcbiAgICB2YXIgcmlwcGxlID0gUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgcmlwcGxlLmlkID0gJ2luayc7XG4gICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgncmVjZW50ZXJzJywgJycpO1xuICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnLCAndG9nZ2xlLWluaycpO1xuICAgIHJldHVybiByaXBwbGU7XG4gIH1cblxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXRvZ2dsZS1idXR0b24vcGFwZXItdG9nZ2xlLWJ1dHRvbi5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFwcGx5U2hpbSBmcm9tICcuLi9zcmMvYXBwbHktc2hpbS5qcyc7XG5pbXBvcnQgdGVtcGxhdGVNYXAgZnJvbSAnLi4vc3JjL3RlbXBsYXRlLW1hcC5qcyc7XG5pbXBvcnQge2dldElzRXh0ZW5kcywgdG9Dc3NUZXh0fSBmcm9tICcuLi9zcmMvc3R5bGUtdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBBcHBseVNoaW1VdGlscyBmcm9tICcuLi9zcmMvYXBwbHktc2hpbS11dGlscy5qcyc7XG5pbXBvcnQgZG9jdW1lbnRXYWl0IGZyb20gJy4uL3NyYy9kb2N1bWVudC13YWl0LmpzJztcbmltcG9ydCB7Z2V0Q29tcHV0ZWRTdHlsZVZhbHVlLCB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzfSBmcm9tICcuLi9zcmMvY29tbW9uLXV0aWxzLmpzJztcbmltcG9ydCB7Q3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2V9IGZyb20gJy4uL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHtuYXRpdmVDc3NWYXJpYWJsZXMsIG5hdGl2ZVNoYWRvd30gZnJvbSAnLi4vc3JjL3N0eWxlLXNldHRpbmdzLmpzJztcblxuLyoqIEBjb25zdCB7QXBwbHlTaGltfSAqL1xuY29uc3QgYXBwbHlTaGltID0gbmV3IEFwcGx5U2hpbSgpO1xuXG5jbGFzcyBBcHBseVNoaW1JbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgez9DdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZX0gKi9cbiAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlID0gbnVsbDtcbiAgICBkb2N1bWVudFdhaXQoKCkgPT4ge1xuICAgICAgdGhpcy5lbnN1cmUoKTtcbiAgICB9KTtcbiAgICBhcHBseVNoaW1bJ2ludmFsaWRDYWxsYmFjayddID0gQXBwbHlTaGltVXRpbHMuaW52YWxpZGF0ZTtcbiAgfVxuICBlbnN1cmUoKSB7XG4gICAgaWYgKHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcbiAgICBpZiAodGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsndHJhbnNmb3JtQ2FsbGJhY2snXSA9IChzdHlsZSkgPT4ge1xuICAgICAgICBhcHBseVNoaW0udHJhbnNmb3JtQ3VzdG9tU3R5bGUoc3R5bGUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3ZhbGlkYXRlQ2FsbGJhY2snXSA9ICgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZW5xdWV1ZWQnXSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICovXG4gIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXSA9IHRlbXBsYXRlO1xuICAgIGxldCBhc3QgPSBhcHBseVNoaW0udHJhbnNmb3JtVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKTtcbiAgICAvLyBzYXZlIG9yaWdpbmFsIHN0eWxlIGFzdCB0byB1c2UgZm9yIHJldmFsaWRhdGluZyBpbnN0YW5jZXNcbiAgICB0ZW1wbGF0ZVsnX3N0eWxlQXN0J10gPSBhc3Q7XG4gIH1cbiAgZmx1c2hDdXN0b21TdHlsZXMoKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICBpZiAoIXRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0eWxlcyA9IHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3Byb2Nlc3NTdHlsZXMnXSgpO1xuICAgIGlmICghdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZW5xdWV1ZWQnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgIGxldCBjcyA9IHN0eWxlc1tpXTtcbiAgICAgIGxldCBzdHlsZSA9IHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2dldFN0eWxlRm9yQ3VzdG9tU3R5bGUnXShjcyk7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgYXBwbHlTaGltLnRyYW5zZm9ybUN1c3RvbVN0eWxlKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZW5xdWV1ZWQnXSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgKi9cbiAgc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIGxldCBzaGFkb3dDaGlsZHJlbiA9IGVsZW1lbnQuc2hhZG93Um9vdC5jaGlsZHJlbiB8fCBlbGVtZW50LnNoYWRvd1Jvb3QuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhZG93Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zdHlsZVN1YnRyZWUoLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oc2hhZG93Q2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbiB8fCBlbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGNoaWxkcmVuW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBzdHlsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgbGV0IHtpc30gPSBnZXRJc0V4dGVuZHMoZWxlbWVudCk7XG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbaXNdO1xuICAgIGlmICh0ZW1wbGF0ZSAmJiAhQXBwbHlTaGltVXRpbHMudGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSkge1xuICAgICAgLy8gb25seSByZXZhbGlkYXRlIHRlbXBsYXRlIG9uY2VcbiAgICAgIGlmICghQXBwbHlTaGltVXRpbHMudGVtcGxhdGVJc1ZhbGlkYXRpbmcodGVtcGxhdGUpKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBpcyk7XG4gICAgICAgIEFwcGx5U2hpbVV0aWxzLnN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSB0aGlzIGVsZW1lbnQgaW5zdGFuY2VcbiAgICAgIGxldCByb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyhyb290LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAvLyByZXVzZSB0aGUgdGVtcGxhdGUncyBzdHlsZSBhc3QsIGl0IGhhcyBhbGwgdGhlIG9yaWdpbmFsIGNzcyB0ZXh0XG4gICAgICAgICAgc3R5bGVbJ19fY3NzUnVsZXMnXSA9IHRlbXBsYXRlWydfc3R5bGVBc3QnXTtcbiAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRvQ3NzVGV4dCh0ZW1wbGF0ZVsnX3N0eWxlQXN0J10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgKi9cbiAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICB0aGlzLnN0eWxlU3VidHJlZShkb2N1bWVudC5ib2R5LCBwcm9wZXJ0aWVzKTtcbiAgfVxufVxuXG5pZiAoIXdpbmRvdy5TaGFkeUNTUyB8fCAhd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKSB7XG4gIGNvbnN0IGFwcGx5U2hpbUludGVyZmFjZSA9IG5ldyBBcHBseVNoaW1JbnRlcmZhY2UoKTtcbiAgbGV0IEN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcblxuICB3aW5kb3cuU2hhZHlDU1MgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVsZW1lbnRFeHRlbmRzXG4gICAgICovXG4gICAgcHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSwgZWxlbWVudEV4dGVuZHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2Uuc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHN0eWxlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5zdHlsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0eWxlRG9jdW1lbnQocHJvcGVydGllcykge1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2Uuc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gICAgfSxcbiAgICBuYXRpdmVDc3M6IG5hdGl2ZUNzc1ZhcmlhYmxlcyxcbiAgICBuYXRpdmVTaGFkb3c6IG5hdGl2ZVNoYWRvd1xuICB9O1xuXG4gIGlmIChDdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgIHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuICB9XG59XG5cbndpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW0gPSBhcHBseVNoaW07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9hcHBseS1zaGltLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbi8qXG4gKiBUaGUgYXBwbHkgc2hpbSBzaW11bGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGBAYXBwbHlgIHByb3Bvc2VkIGF0XG4gKiBodHRwczovL3RhYmF0a2lucy5naXRodWIuaW8vc3BlY3MvY3NzLWFwcGx5LXJ1bGUvLlxuICogVGhlIGFwcHJvYWNoIGlzIHRvIGNvbnZlcnQgYSBwcm9wZXJ0eSBsaWtlIHRoaXM6XG4gKlxuICogICAgLS1mb286IHtjb2xvcjogcmVkOyBiYWNrZ3JvdW5kOiBibHVlO31cbiAqXG4gKiB0byB0aGlzOlxuICpcbiAqICAgIC0tZm9vXy1fY29sb3I6IHJlZDtcbiAqICAgIC0tZm9vXy1fYmFja2dyb3VuZDogYmx1ZTtcbiAqXG4gKiBUaGVuIHdoZXJlIGBAYXBwbHkgLS1mb29gIGlzIHVzZWQsIHRoYXQgaXMgY29udmVydGVkIHRvOlxuICpcbiAqICAgIGNvbG9yOiB2YXIoLS1mb29fLV9jb2xvcik7XG4gKiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb29fLV9iYWNrZ3JvdW5kKTtcbiAqXG4gKiBUaGlzIGFwcHJvYWNoIGdlbmVyYWxseSB3b3JrcyBidXQgdGhlcmUgYXJlIHNvbWUgaXNzdWVzIGFuZCBsaW1pdGF0aW9ucy5cbiAqIENvbnNpZGVyLCBmb3IgZXhhbXBsZSwgdGhhdCBzb21ld2hlcmUgKmJldHdlZW4qIHdoZXJlIGAtLWZvb2AgaXMgc2V0IGFuZCB1c2VkLFxuICogYW5vdGhlciBlbGVtZW50IHNldHMgaXQgdG86XG4gKlxuICogICAgLS1mb286IHsgYm9yZGVyOiAycHggc29saWQgcmVkOyB9XG4gKlxuICogV2UgbXVzdCBub3cgZW5zdXJlIHRoYXQgdGhlIGNvbG9yIGFuZCBiYWNrZ3JvdW5kIGZyb20gdGhlIHByZXZpb3VzIHNldHRpbmdcbiAqIGRvIG5vdCBhcHBseS4gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgY2hhbmdpbmcgdGhlIHByb3BlcnR5IHNldCB0byB0aGlzOlxuICpcbiAqICAgIC0tZm9vXy1fYm9yZGVyOiAycHggc29saWQgcmVkO1xuICogICAgLS1mb29fLV9jb2xvcjogaW5pdGlhbDtcbiAqICAgIC0tZm9vXy1fYmFja2dyb3VuZDogaW5pdGlhbDtcbiAqXG4gKiBUaGlzIHdvcmtzIGJ1dCBpbnRyb2R1Y2VzIG9uZSBuZXcgaXNzdWUuXG4gKiBDb25zaWRlciB0aGlzIHNldHVwIGF0IHRoZSBwb2ludCB3aGVyZSB0aGUgYEBhcHBseWAgaXMgdXNlZDpcbiAqXG4gKiAgICBiYWNrZ3JvdW5kOiBvcmFuZ2U7XG4gKiAgICBgQGFwcGx5YCAtLWZvbztcbiAqXG4gKiBJbiB0aGlzIGNhc2UgdGhlIGJhY2tncm91bmQgd2lsbCBiZSB1bnNldCAoaW5pdGlhbCkgcmF0aGVyIHRoYW4gdGhlIGRlc2lyZWRcbiAqIGBvcmFuZ2VgLiBXZSBhZGRyZXNzIHRoaXMgYnkgYWx0ZXJpbmcgdGhlIHByb3BlcnR5IHNldCB0byB1c2UgYSBmYWxsYmFja1xuICogdmFsdWUgbGlrZSB0aGlzOlxuICpcbiAqICAgIGNvbG9yOiB2YXIoLS1mb29fLV9jb2xvcik7XG4gKiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb29fLV9iYWNrZ3JvdW5kLCBvcmFuZ2UpO1xuICogICAgYm9yZGVyOiB2YXIoLS1mb29fLV9ib3JkZXIpO1xuICpcbiAqIE5vdGUgdGhhdCB0aGUgZGVmYXVsdCBpcyByZXRhaW5lZCBpbiB0aGUgcHJvcGVydHkgc2V0IGFuZCB0aGUgYGJhY2tncm91bmRgIGlzXG4gKiB0aGUgZGVzaXJlZCBgb3JhbmdlYC4gVGhpcyBsZWFkcyB1cyB0byBhIGxpbWl0YXRpb24uXG4gKlxuICogTGltaXRhdGlvbiAxOlxuXG4gKiBPbmx5IHByb3BlcnRpZXMgaW4gdGhlIHJ1bGUgd2hlcmUgdGhlIGBAYXBwbHlgXG4gKiBpcyB1c2VkIGFyZSBjb25zaWRlcmVkIGFzIGRlZmF1bHQgdmFsdWVzLlxuICogSWYgYW5vdGhlciBydWxlIG1hdGNoZXMgdGhlIGVsZW1lbnQgYW5kIHNldHMgYGJhY2tncm91bmRgIHdpdGhcbiAqIGxlc3Mgc3BlY2lmaWNpdHkgdGhhbiB0aGUgcnVsZSBpbiB3aGljaCBgQGFwcGx5YCBhcHBlYXJzLFxuICogdGhlIGBiYWNrZ3JvdW5kYCB3aWxsIG5vdCBiZSBzZXQuXG4gKlxuICogTGltaXRhdGlvbiAyOlxuICpcbiAqIFdoZW4gdXNpbmcgUG9seW1lcidzIGB1cGRhdGVTdHlsZXNgIGFwaSwgbmV3IHByb3BlcnRpZXMgbWF5IG5vdCBiZSBzZXQgZm9yXG4gKiBgQGFwcGx5YCBwcm9wZXJ0aWVzLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Zm9yRWFjaFJ1bGUsIHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrLCBydWxlc0ZvclN0eWxlLCB0b0Nzc1RleHR9IGZyb20gJy4vc3R5bGUtdXRpbC5qcyc7XG5pbXBvcnQge01JWElOX01BVENILCBWQVJfQVNTSUdOfSBmcm9tICcuL2NvbW1vbi1yZWdleC5qcyc7XG5pbXBvcnQge2RldGVjdE1peGlufSBmcm9tICcuL2NvbW1vbi11dGlscy5qcyc7XG5pbXBvcnQge1N0eWxlTm9kZX0gZnJvbSAnLi9jc3MtcGFyc2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmNvbnN0IEFQUExZX05BTUVfQ0xFQU4gPSAvO1xccyovbTtcbmNvbnN0IElOSVRJQUxfSU5IRVJJVCA9IC9eXFxzKihpbml0aWFsKXwoaW5oZXJpdClcXHMqJC87XG5cbi8vIHNlcGFyYXRvciB1c2VkIGJldHdlZW4gbWl4aW4tbmFtZSBhbmQgbWl4aW4tcHJvcGVydHktbmFtZSB3aGVuIHByb2R1Y2luZyBwcm9wZXJ0aWVzXG4vLyBOT1RFOiBwbGFpbiAnLScgbWF5IGNhdXNlIGNvbGxpc2lvbnMgaW4gdXNlciBzdHlsZXNcbmNvbnN0IE1JWElOX1ZBUl9TRVAgPSAnXy1fJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmxldCBQcm9wZXJ0eUVudHJ5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHR5cGVkZWYgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xubGV0IERlcGVuZGFudHNFbnRyeTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKiogQHR5cGVkZWYge3tcbiAqICAgIHByb3BlcnRpZXM6IFByb3BlcnR5RW50cnksXG4gKiAgICBkZXBlbmRhbnRzOiBEZXBlbmRhbnRzRW50cnlcbiAqIH19XG4gKi9cbmxldCBNaXhpbk1hcEVudHJ5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8vIG1hcCBvZiBtaXhpbiB0byBwcm9wZXJ0eSBuYW1lc1xuLy8gLS1mb286IHtib3JkZXI6IDJweH0gLT4ge3Byb3BlcnRpZXM6IHsoLS1mb28sIFsnYm9yZGVyJ10pfSwgZGVwZW5kYW50czogeydlbGVtZW50LW5hbWUnOiBwcm90b319XG5jbGFzcyBNaXhpbk1hcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFNaXhpbk1hcEVudHJ5Pn0gKi9cbiAgICB0aGlzLl9tYXAgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHshUHJvcGVydHlFbnRyeX0gcHJvcHNcbiAgICovXG4gIHNldChuYW1lLCBwcm9wcykge1xuICAgIG5hbWUgPSBuYW1lLnRyaW0oKTtcbiAgICB0aGlzLl9tYXBbbmFtZV0gPSB7XG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wcyxcbiAgICAgIGRlcGVuZGFudHM6IHt9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtNaXhpbk1hcEVudHJ5fVxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBuYW1lID0gbmFtZS50cmltKCk7XG4gICAgcmV0dXJuIHRoaXMuX21hcFtuYW1lXSB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyBtYXJrZWQgaW52YWxpZFxuICogQHR5cGUgez9mdW5jdGlvbihzdHJpbmcpfVxuICovXG5sZXQgaW52YWxpZENhbGxiYWNrID0gbnVsbDtcblxuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbmNsYXNzIEFwcGx5U2hpbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtIVE1MTWV0YUVsZW1lbnR9ICovXG4gICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX21hcCA9IG5ldyBNaXhpbk1hcCgpO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm4gdHJ1ZSBpZiBgY3NzVGV4dGAgY29udGFpbnMgYSBtaXhpbiBkZWZpbml0aW9uIG9yIGNvbnN1bXB0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBkZXRlY3RNaXhpbihjc3NUZXh0KSB7XG4gICAgcmV0dXJuIGRldGVjdE1peGluKGNzc1RleHQpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICogQHJldHVybiB7U3R5bGVOb2RlfVxuICAgKi9cbiAgdHJhbnNmb3JtVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKSB7XG4gICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3Rvcignc3R5bGUnKSk7XG4gICAgLyoqIEB0eXBlIHtTdHlsZU5vZGV9ICovXG4gICAgbGV0IGFzdCA9IG51bGw7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBhc3QgPSB0aGlzLnRyYW5zZm9ybVN0eWxlKHN0eWxlLCBlbGVtZW50TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gICAqL1xuICB0cmFuc2Zvcm1TdHlsZShzdHlsZSwgZWxlbWVudE5hbWUgPSAnJykge1xuICAgIGxldCBhc3QgPSBydWxlc0ZvclN0eWxlKHN0eWxlKTtcbiAgICB0aGlzLnRyYW5zZm9ybVJ1bGVzKGFzdCwgZWxlbWVudE5hbWUpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gdG9Dc3NUZXh0KGFzdCk7XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAgICogQHJldHVybiB7U3R5bGVOb2RlfVxuICAgKi9cbiAgdHJhbnNmb3JtQ3VzdG9tU3R5bGUoc3R5bGUpIHtcbiAgICBsZXQgYXN0ID0gcnVsZXNGb3JTdHlsZShzdHlsZSk7XG4gICAgZm9yRWFjaFJ1bGUoYXN0LCAocnVsZSkgPT4ge1xuICAgICAgaWYgKHJ1bGVbJ3NlbGVjdG9yJ10gPT09ICc6cm9vdCcpIHtcbiAgICAgICAgcnVsZVsnc2VsZWN0b3InXSA9ICdodG1sJztcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmb3JtUnVsZShydWxlKTtcbiAgICB9KVxuICAgIHN0eWxlLnRleHRDb250ZW50ID0gdG9Dc3NUZXh0KGFzdCk7XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtTdHlsZU5vZGV9IHJ1bGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKi9cbiAgdHJhbnNmb3JtUnVsZXMocnVsZXMsIGVsZW1lbnROYW1lKSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50TmFtZTtcbiAgICBmb3JFYWNoUnVsZShydWxlcywgKHIpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtUnVsZShyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVN0eWxlTm9kZX0gcnVsZVxuICAgKi9cbiAgdHJhbnNmb3JtUnVsZShydWxlKSB7XG4gICAgcnVsZVsnY3NzVGV4dCddID0gdGhpcy50cmFuc2Zvcm1Dc3NUZXh0KHJ1bGVbJ3BhcnNlZENzc1RleHQnXSk7XG4gICAgLy8gOnJvb3Qgd2FzIG9ubHkgdXNlZCBmb3IgdmFyaWFibGUgYXNzaWdubWVudCBpbiBwcm9wZXJ0eSBzaGltLFxuICAgIC8vIGJ1dCBnZW5lcmF0ZXMgaW52YWxpZCBzZWxlY3RvcnMgd2l0aCByZWFsIHByb3BlcnRpZXMuXG4gICAgLy8gcmVwbGFjZSB3aXRoIGA6aG9zdCA+ICpgLCB3aGljaCBzZXJ2ZXMgdGhlIHNhbWUgZWZmZWN0XG4gICAgaWYgKHJ1bGVbJ3NlbGVjdG9yJ10gPT09ICc6cm9vdCcpIHtcbiAgICAgIHJ1bGVbJ3NlbGVjdG9yJ10gPSAnOmhvc3QgPiAqJztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRyYW5zZm9ybUNzc1RleHQoY3NzVGV4dCkge1xuICAgIC8vIHByb2R1Y2UgdmFyaWFibGVzXG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShWQVJfQVNTSUdOLCAobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pID0+XG4gICAgICB0aGlzLl9wcm9kdWNlQ3NzUHJvcGVydGllcyhtYXRjaFRleHQsIHByb3BlcnR5TmFtZSwgdmFsdWVQcm9wZXJ0eSwgdmFsdWVNaXhpbikpO1xuICAgIC8vIGNvbnN1bWUgbWl4aW5zXG4gICAgcmV0dXJuIHRoaXMuX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKGNzc1RleHQpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX2dldEluaXRpYWxWYWx1ZUZvclByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKCF0aGlzLl9tZWFzdXJlRWxlbWVudCkge1xuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSAvKiogQHR5cGUge0hUTUxNZXRhRWxlbWVudH0gKi8oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpKTtcbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXBwbHktc2hpbS1tZWFzdXJlJywgJycpO1xuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQuc3R5bGUuYWxsID0gJ2luaXRpYWwnO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLl9tZWFzdXJlRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZWFzdXJlRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlcGxhY2UgbWl4aW4gY29uc3VtcHRpb24gd2l0aCB2YXJpYWJsZSBjb25zdW1wdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfY29uc3VtZUNzc1Byb3BlcnRpZXModGV4dCkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gICAgbGV0IG0gPSBudWxsO1xuICAgIC8vIGxvb3Agb3ZlciB0ZXh0IHVudGlsIGFsbCBtaXhpbnMgd2l0aCBkZWZpbnRpb25zIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgd2hpbGUoKG0gPSBNSVhJTl9NQVRDSC5leGVjKHRleHQpKSkge1xuICAgICAgbGV0IG1hdGNoVGV4dCA9IG1bMF07XG4gICAgICBsZXQgbWl4aW5OYW1lID0gbVsxXTtcbiAgICAgIGxldCBpZHggPSBtLmluZGV4O1xuICAgICAgLy8gY29sbGVjdCBwcm9wZXJ0aWVzIGJlZm9yZSBhcHBseSB0byBiZSBcImRlZmF1bHRzXCIgaWYgbWl4aW4gbWlnaHQgb3ZlcnJpZGUgdGhlbVxuICAgICAgLy8gbWF0Y2ggaW5jbHVkZXMgYSBcInByZWZpeFwiLCBzbyBmaW5kIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiBAYXBwbHlcbiAgICAgIGxldCBhcHBseVBvcyA9IGlkeCArIG1hdGNoVGV4dC5pbmRleE9mKCdAYXBwbHknKTtcbiAgICAgIGxldCBhZnRlckFwcGx5UG9zID0gaWR4ICsgbWF0Y2hUZXh0Lmxlbmd0aDtcbiAgICAgIC8vIGZpbmQgcHJvcHMgZGVmaW5lZCBiZWZvcmUgdGhpcyBAYXBwbHlcbiAgICAgIGxldCB0ZXh0QmVmb3JlQXBwbHkgPSB0ZXh0LnNsaWNlKDAsIGFwcGx5UG9zKTtcbiAgICAgIGxldCB0ZXh0QWZ0ZXJBcHBseSA9IHRleHQuc2xpY2UoYWZ0ZXJBcHBseVBvcyk7XG4gICAgICBsZXQgZGVmYXVsdHMgPSB0aGlzLl9jc3NUZXh0VG9NYXAodGV4dEJlZm9yZUFwcGx5KTtcbiAgICAgIGxldCByZXBsYWNlbWVudCA9IHRoaXMuX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMobWl4aW5OYW1lLCBkZWZhdWx0cyk7XG4gICAgICAvLyB1c2UgcmVnZXggbWF0Y2ggcG9zaXRpb24gdG8gcmVwbGFjZSBtaXhpbiwga2VlcCBsaW5lYXIgcHJvY2Vzc2luZyB0aW1lXG4gICAgICB0ZXh0ID0gYCR7dGV4dEJlZm9yZUFwcGx5fSR7cmVwbGFjZW1lbnR9JHt0ZXh0QWZ0ZXJBcHBseX1gO1xuICAgICAgLy8gbW92ZSByZWdleCBzZWFyY2ggdG8gX2FmdGVyXyByZXBsYWNlbWVudFxuICAgICAgTUlYSU5fTUFUQ0gubGFzdEluZGV4ID0gaWR4ICsgcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICAvKipcbiAgICogcHJvZHVjZSB2YXJpYWJsZSBjb25zdW1wdGlvbiBhdCB0aGUgc2l0ZSBvZiBtaXhpbiBjb25zdW1wdGlvblxuICAgKiBgQGFwcGx5YCAtLWZvbzsgLT4gZm9yIGFsbCBwcm9wcyAoJHtwcm9wbmFtZX06IHZhcigtLWZvb18tXyR7cHJvcG5hbWV9LCAke2ZhbGxiYWNrW3Byb3BuYW1lXX19KSlcbiAgICogRXhhbXBsZTpcbiAgICogIGJvcmRlcjogdmFyKC0tZm9vXy1fYm9yZGVyKTsgcGFkZGluZzogdmFyKC0tZm9vXy1fcGFkZGluZywgMnB4KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWl4aW5OYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYWxsYmFja3NcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMobWl4aW5OYW1lLCBmYWxsYmFja3MpIHtcbiAgICBtaXhpbk5hbWUgPSBtaXhpbk5hbWUucmVwbGFjZShBUFBMWV9OQU1FX0NMRUFOLCAnJyk7XG4gICAgbGV0IHZhcnMgPSBbXTtcbiAgICBsZXQgbWl4aW5FbnRyeSA9IHRoaXMuX21hcC5nZXQobWl4aW5OYW1lKTtcbiAgICAvLyBpZiB3ZSBkZXBlbmQgb24gYSBtaXhpbiBiZWZvcmUgaXQgaXMgY3JlYXRlZFxuICAgIC8vIG1ha2UgYSBzZW50aW5lbCBlbnRyeSBpbiB0aGUgbWFwIHRvIGFkZCB0aGlzIGVsZW1lbnQgYXMgYSBkZXBlbmRlbmN5IGZvciB3aGVuIGl0IGlzIGRlZmluZWQuXG4gICAgaWYgKCFtaXhpbkVudHJ5KSB7XG4gICAgICB0aGlzLl9tYXAuc2V0KG1peGluTmFtZSwge30pO1xuICAgICAgbWl4aW5FbnRyeSA9IHRoaXMuX21hcC5nZXQobWl4aW5OYW1lKTtcbiAgICB9XG4gICAgaWYgKG1peGluRW50cnkpIHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBtaXhpbkVudHJ5LmRlcGVuZGFudHNbdGhpcy5fY3VycmVudEVsZW1lbnRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBwLCBwYXJ0cywgZjtcbiAgICAgIGZvciAocCBpbiBtaXhpbkVudHJ5LnByb3BlcnRpZXMpIHtcbiAgICAgICAgZiA9IGZhbGxiYWNrcyAmJiBmYWxsYmFja3NbcF07XG4gICAgICAgIHBhcnRzID0gW3AsICc6IHZhcignLCBtaXhpbk5hbWUsIE1JWElOX1ZBUl9TRVAsIHBdO1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIHBhcnRzLnB1c2goJywnLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKCcpJyk7XG4gICAgICAgIHZhcnMucHVzaChwYXJ0cy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YXJzLmpvaW4oJzsgJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfcmVwbGFjZUluaXRpYWxPckluaGVyaXQocHJvcGVydHksIHZhbHVlKSB7XG4gICAgbGV0IG1hdGNoID0gSU5JVElBTF9JTkhFUklULmV4ZWModmFsdWUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIGluaXRpYWxcbiAgICAgICAgLy8gcmVwbGFjZSBgaW5pdGlhbGAgd2l0aCB0aGUgY29uY3JldGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICB2YWx1ZSA9IHRoaXMuX2dldEluaXRpYWxWYWx1ZUZvclByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluaGVyaXRcbiAgICAgICAgLy8gd2l0aCB0aGlzIHB1cnBvc2Z1bGx5IGlsbGVnYWwgdmFsdWUsIHRoZSB2YXJpYWJsZSB3aWxsIGJlIGludmFsaWQgYXRcbiAgICAgICAgLy8gY29tcHV0ZSB0aW1lIChodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXZhcmlhYmxlcy8jaW52YWxpZC1hdC1jb21wdXRlZC12YWx1ZS10aW1lKVxuICAgICAgICAvLyBhbmQgZm9yIGluaGVyaXRpbmcgdmFsdWVzLCB3aWxsIGJlaGF2ZSBzaW1pbGFybHlcbiAgICAgICAgLy8gd2UgY2Fubm90IHN1cHBvcnQgdGhlIHNhbWUgYmVoYXZpb3IgZm9yIG5vbiBpbmhlcml0aW5nIHZhbHVlcyBsaWtlICdib3JkZXInXG4gICAgICAgIHZhbHVlID0gJ2FwcGx5LXNoaW0taW5oZXJpdCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcInBhcnNlXCIgYSBtaXhpbiBkZWZpbml0aW9uIGludG8gYSBtYXAgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAqIGNzc1RleHRUb01hcCgnYm9yZGVyOiAycHggc29saWQgYmxhY2snKSAtPiAoJ2JvcmRlcicsICcycHggc29saWQgYmxhY2snKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIF9jc3NUZXh0VG9NYXAodGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHRleHQuc3BsaXQoJzsnKTtcbiAgICBsZXQgcHJvcGVydHksIHZhbHVlO1xuICAgIGxldCBvdXQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMCwgcCwgc3A7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHApIHtcbiAgICAgICAgc3AgPSBwLnNwbGl0KCc6Jyk7XG4gICAgICAgIC8vIGlnbm9yZSBsaW5lcyB0aGF0IGFyZW4ndCBkZWZpbml0aW9ucyBsaWtlIEBtZWRpYVxuICAgICAgICBpZiAoc3AubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByb3BlcnR5ID0gc3BbMF0udHJpbSgpO1xuICAgICAgICAgIC8vIHNvbWUgcHJvcGVydGllcyBtYXkgaGF2ZSAnOicgaW4gdGhlIHZhbHVlLCBsaWtlIGRhdGEgdXJsc1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5fcmVwbGFjZUluaXRpYWxPckluaGVyaXQocHJvcGVydHksIHNwLnNsaWNlKDEpLmpvaW4oJzonKSk7XG4gICAgICAgICAgb3V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNaXhpbk1hcEVudHJ5fSBtaXhpbkVudHJ5XG4gICAqL1xuICBfaW52YWxpZGF0ZU1peGluRW50cnkobWl4aW5FbnRyeSkge1xuICAgIGlmICghaW52YWxpZENhbGxiYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGVsZW1lbnROYW1lIGluIG1peGluRW50cnkuZGVwZW5kYW50cykge1xuICAgICAgaWYgKGVsZW1lbnROYW1lICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBpbnZhbGlkQ2FsbGJhY2soZWxlbWVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZVByb3BlcnR5XG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVNaXhpblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfcHJvZHVjZUNzc1Byb3BlcnRpZXMobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pIHtcbiAgICAvLyBoYW5kbGUgY2FzZSB3aGVyZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhIG1peGluXG4gICAgaWYgKHZhbHVlUHJvcGVydHkpIHtcbiAgICAgIC8vIGZvcm06IC0tbWl4aW4yOiB2YXIoLS1taXhpbjEpLCB3aGVyZSAtLW1peGluMSBpcyBpbiB0aGUgbWFwXG4gICAgICBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayh2YWx1ZVByb3BlcnR5LCAocHJlZml4LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5fbWFwLmdldCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZU1peGluID0gYEBhcHBseSAke3ZhbHVlfTtgXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlTWl4aW4pIHtcbiAgICAgIHJldHVybiBtYXRjaFRleHQ7XG4gICAgfVxuICAgIGxldCBtaXhpbkFzUHJvcGVydGllcyA9IHRoaXMuX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKHZhbHVlTWl4aW4pO1xuICAgIGxldCBwcmVmaXggPSBtYXRjaFRleHQuc2xpY2UoMCwgbWF0Y2hUZXh0LmluZGV4T2YoJy0tJykpO1xuICAgIGxldCBtaXhpblZhbHVlcyA9IHRoaXMuX2Nzc1RleHRUb01hcChtaXhpbkFzUHJvcGVydGllcyk7XG4gICAgbGV0IGNvbWJpbmVkUHJvcHMgPSBtaXhpblZhbHVlcztcbiAgICBsZXQgbWl4aW5FbnRyeSA9IHRoaXMuX21hcC5nZXQocHJvcGVydHlOYW1lKTtcbiAgICBsZXQgb2xkUHJvcHMgPSBtaXhpbkVudHJ5ICYmIG1peGluRW50cnkucHJvcGVydGllcztcbiAgICBpZiAob2xkUHJvcHMpIHtcbiAgICAgIC8vIE5PVEU6IHNpbmNlIHdlIHVzZSBtaXhpbiwgdGhlIG1hcCBvZiBwcm9wZXJ0aWVzIGlzIHVwZGF0ZWQgaGVyZVxuICAgICAgLy8gYW5kIHRoaXMgaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgY29tYmluZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShvbGRQcm9wcyksIG1peGluVmFsdWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFwLnNldChwcm9wZXJ0eU5hbWUsIGNvbWJpbmVkUHJvcHMpO1xuICAgIH1cbiAgICBsZXQgb3V0ID0gW107XG4gICAgbGV0IHAsIHY7XG4gICAgLy8gc2V0IHZhcmlhYmxlcyBkZWZpbmVkIGJ5IGN1cnJlbnQgbWl4aW5cbiAgICBsZXQgbmVlZFRvSW52YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGZvciAocCBpbiBjb21iaW5lZFByb3BzKSB7XG4gICAgICB2ID0gbWl4aW5WYWx1ZXNbcF07XG4gICAgICAvLyBpZiBwcm9wZXJ0eSBub3QgZGVmaW5lZCBieSBjdXJyZW50IG1peGluLCBzZXQgaW5pdGlhbFxuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2ID0gJ2luaXRpYWwnO1xuICAgICAgfVxuICAgICAgaWYgKG9sZFByb3BzICYmICEocCBpbiBvbGRQcm9wcykpIHtcbiAgICAgICAgbmVlZFRvSW52YWxpZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChgJHtwcm9wZXJ0eU5hbWV9JHtNSVhJTl9WQVJfU0VQfSR7cH06ICR7dn1gKTtcbiAgICB9XG4gICAgaWYgKG5lZWRUb0ludmFsaWRhdGUpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVNaXhpbkVudHJ5KG1peGluRW50cnkpO1xuICAgIH1cbiAgICBpZiAobWl4aW5FbnRyeSkge1xuICAgICAgbWl4aW5FbnRyeS5wcm9wZXJ0aWVzID0gY29tYmluZWRQcm9wcztcbiAgICB9XG4gICAgLy8gYmVjYXVzZSB0aGUgbWl4aW5NYXAgaXMgZ2xvYmFsLCB0aGUgbWl4aW4gbWlnaHQgY29uZmxpY3Qgd2l0aFxuICAgIC8vIGEgZGlmZmVyZW50IHNjb3BlJ3Mgc2ltcGxlIHZhcmlhYmxlIGRlZmluaXRpb246XG4gICAgLy8gRXhhbXBsZTpcbiAgICAvLyBzb21lIHN0eWxlIHNvbWV3aGVyZTpcbiAgICAvLyAtLW1peGluMTp7IC4uLiB9XG4gICAgLy8gLS1taXhpbjI6IHZhcigtLW1peGluMSk7XG4gICAgLy8gc29tZSBvdGhlciBlbGVtZW50OlxuICAgIC8vIC0tbWl4aW4xOiAxMHB4IHNvbGlkIHJlZDtcbiAgICAvLyAtLWZvbzogdmFyKC0tbWl4aW4xKTtcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGxlYXZlIHRoZSBvcmlnaW5hbCB2YXJpYWJsZSBkZWZpbml0aW9uIGluIHBsYWNlLlxuICAgIGlmICh2YWx1ZVByb3BlcnR5KSB7XG4gICAgICBwcmVmaXggPSBgJHttYXRjaFRleHR9OyR7cHJlZml4fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcmVmaXh9JHtvdXQuam9pbignOyAnKX07YDtcbiAgfVxufVxuXG4vKiBleHBvcnRzICovXG5BcHBseVNoaW0ucHJvdG90eXBlWydkZXRlY3RNaXhpbiddID0gQXBwbHlTaGltLnByb3RvdHlwZS5kZXRlY3RNaXhpbjtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVN0eWxlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVN0eWxlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtQ3VzdG9tU3R5bGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtQ3VzdG9tU3R5bGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1SdWxlcyddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlcztcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVJ1bGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtUnVsZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVRlbXBsYXRlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVRlbXBsYXRlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsnX3NlcGFyYXRvciddID0gTUlYSU5fVkFSX1NFUDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBseVNoaW0ucHJvdG90eXBlLCAnaW52YWxpZENhbGxiYWNrJywge1xuICAvKiogQHJldHVybiB7P2Z1bmN0aW9uKHN0cmluZyl9ICovXG4gIGdldCgpIHtcbiAgICByZXR1cm4gaW52YWxpZENhbGxiYWNrO1xuICB9LFxuICAvKiogQHBhcmFtIHs/ZnVuY3Rpb24oc3RyaW5nKX0gY2IgKi9cbiAgc2V0KGNiKSB7XG4gICAgaW52YWxpZENhbGxiYWNrID0gY2I7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBcHBseVNoaW07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvYXBwbHktc2hpbS5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB0ZW1wbGF0ZU1hcCBmcm9tICcuL3RlbXBsYXRlLW1hcC5qcyc7XG5pbXBvcnQge1N0eWxlTm9kZX0gZnJvbSAnLi9jc3MtcGFyc2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qXG4gKiBVdGlsaXRpZXMgZm9yIGhhbmRsaW5nIGludmFsaWRhdGluZyBhcHBseS1zaGltIG1peGlucyBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGUgaW52YWxpZGF0aW9uIHN0cmF0ZWd5IGludm9sdmVzIGtlZXBpbmcgdHJhY2sgb2YgdGhlIFwiY3VycmVudFwiIHZlcnNpb24gb2YgYSB0ZW1wbGF0ZSdzIG1peGlucywgYW5kIHVwZGF0aW5nIHRoYXQgY291bnQgd2hlbiBhIG1peGluIGlzIGludmFsaWRhdGVkLlxuICogVGhlIHRlbXBsYXRlXG4gKi9cblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgQ1VSUkVOVF9WRVJTSU9OID0gJ19hcHBseVNoaW1DdXJyZW50VmVyc2lvbic7XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IE5FWFRfVkVSU0lPTiA9ICdfYXBwbHlTaGltTmV4dFZlcnNpb24nO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBWQUxJREFUSU5HX1ZFUlNJT04gPSAnX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uJztcblxuLyoqXG4gKiBAY29uc3Qge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlbWVudE5hbWUpe1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIGludmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gbWFyayBhIHRlbXBsYXRlIGludmFsaWRcbiAqIGFuZCBzaWduYWwgdGhhdCB0aGUgc3R5bGUgaW5zaWRlIG11c3QgYmUgcmVnZW5lcmF0ZWQuXG4gKlxuICogVXNlIGBzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZWAgdG8gYmVnaW4gYW4gYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gY3ljbGUuXG4gKiBEdXJpbmcgdGhhdCBjeWNsZSwgY2FsbCBgdGVtcGxhdGVJc1ZhbGlkYXRpbmdgIHRvIHNlZSBpZiB0aGUgdGVtcGxhdGUgbXVzdFxuICogYmUgcmV2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAvLyBkZWZhdWx0IHRoZSBjdXJyZW50IHZlcnNpb24gdG8gMFxuICB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID0gdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSB8fCAwO1xuICAvLyBlbnN1cmUgdGhlIFwidmFsaWRhdGluZyBmb3JcIiBmbGFnIGV4aXN0c1xuICB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID0gdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSB8fCAwO1xuICAvLyBpbmNyZW1lbnQgdGhlIG5leHQgdmVyc2lvblxuICB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dID0gKHRlbXBsYXRlW05FWFRfVkVSU0lPTl0gfHwgMCkgKyAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQoZWxlbWVudE5hbWUpIHtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBpZiAodGVtcGxhdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSB7XG4gIHJldHVybiB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID09PSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRhdGluZyhlbGVtZW50TmFtZSkge1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVtcGxhdGUgaXMgY3VycmVudGx5IGludmFsaWQgYW5kIGBzdGFydFZhbGlkYXRpbmdgIGhhcyBiZWVuIGNhbGxlZCBzaW5jZSB0aGUgbGFzdCBpbnZhbGlkYXRpb24uXG4gKiBJZiBmYWxzZSwgdGhlIHRlbXBsYXRlIG11c3QgYmUgdmFsaWRhdGVkLlxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlSXNWYWxpZGF0aW5nKHRlbXBsYXRlKSB7XG4gIHJldHVybiAhdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSAmJiB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID09PSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xufVxuXG4vKipcbiAqIHRoZSB0ZW1wbGF0ZSBpcyBtYXJrZWQgYXMgYHZhbGlkYXRpbmdgIGZvciBvbmUgbWljcm90YXNrIHNvIHRoYXQgYWxsIGluc3RhbmNlc1xuICogZm91bmQgaW4gdGhlIHRyZWUgY3Jhd2wgb2YgYGFwcGx5U3R5bGVgIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMsXG4gKiBidXQgdGhlIHRlbXBsYXRlIHdpbGwgb25seSBiZSB1cGRhdGVkIG9uY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRWYWxpZGF0aW5nKGVsZW1lbnROYW1lKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUodGVtcGxhdGUpO1xufVxuXG4vKipcbiAqIEJlZ2luIGFuIGFzeW5jaHJvbm91cyBpbnZhbGlkYXRpb24gY3ljbGUuXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgdmFsaWRhdGlvbiBvZiBhIHRlbXBsYXRlXG4gKlxuICogQWZ0ZXIgb25lIG1pY3JvdGFzaywgdGhlIHRlbXBsYXRlIHdpbGwgYmUgbWFya2VkIGFzIHZhbGlkIHVudGlsIHRoZSBuZXh0IGNhbGwgdG8gYGludmFsaWRhdGVUZW1wbGF0ZWBcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGN1cnJlbnQgXCJuZXh0IHZlcnNpb25cIiBpcyB0aGUgcmVhc29uIGZvciB0aGlzIHZhbGlkYXRpb24gY3ljbGVcbiAgdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSA9IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG4gIC8vIGhvd2V2ZXIsIHRoZXJlIG9ubHkgbmVlZHMgdG8gYmUgb25lIGFzeW5jIHRhc2sgdG8gY2xlYXIgdGhlIGNvdW50ZXJzXG4gIGlmICghdGVtcGxhdGUuX3ZhbGlkYXRpbmcpIHtcbiAgICB0ZW1wbGF0ZS5fdmFsaWRhdGluZyA9IHRydWU7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gc3luYyB0aGUgY3VycmVudCB2ZXJzaW9uIHRvIGxldCBmdXR1cmUgaW52YWxpZGF0aW9ucyBjYXVzZSBhIHJlZnJlc2ggY3ljbGVcbiAgICAgIHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xuICAgICAgdGVtcGxhdGUuX3ZhbGlkYXRpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50c0FyZUludmFsaWQoKSB7XG4gIGZvciAobGV0IGVsZW1lbnROYW1lIGluIHRlbXBsYXRlTWFwKSB7XG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICAgIGlmICghdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLXV0aWxzLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyBydW4gYSBjYWxsYmFjayB3aGVuIEhUTUxJbXBvcnRzIGFyZSByZWFkeSBvciBpbW1lZGlhdGVseSBpZlxuLy8gdGhpcyBhcGkgaXMgbm90IGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHdoZW5JbXBvcnRzUmVhZHkoY2IpIHtcbiAgaWYgKHdpbmRvdy5IVE1MSW1wb3J0cykge1xuICAgIEhUTUxJbXBvcnRzLndoZW5SZWFkeShjYik7XG4gIH0gZWxzZSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaW1wb3J0SHJlZiA9IGZ1bmN0aW9uKGhyZWYsIG9ubG9hZCwgb25lcnJvciwgb3B0QXN5bmMpIHtcbiAgbGV0IGxpbmsgPSAvKiogQHR5cGUge0hUTUxMaW5rRWxlbWVudH0gKi9cbiAgICAoZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKCdsaW5rW2hyZWY9XCInICsgaHJlZiArICdcIl1baW1wb3J0LWhyZWZdJykpO1xuICBpZiAoIWxpbmspIHtcbiAgICBsaW5rID0gLyoqIEB0eXBlIHtIVE1MTGlua0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJykpO1xuICAgIGxpbmsucmVsID0gJ2ltcG9ydCc7XG4gICAgbGluay5ocmVmID0gaHJlZjtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaW1wb3J0LWhyZWYnLCAnJyk7XG4gIH1cbiAgLy8gYWx3YXlzIGVuc3VyZSBsaW5rIGhhcyBgYXN5bmNgIGF0dHJpYnV0ZSBpZiB1c2VyIHNwZWNpZmllZCBvbmUsXG4gIC8vIGV2ZW4gaWYgaXQgd2FzIHByZXZpb3VzbHkgbm90IGFzeW5jLiBUaGlzIGlzIGNvbnNpZGVyZWQgbGVzcyBjb25mdXNpbmcuXG4gIGlmIChvcHRBc3luYykge1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdhc3luYycsICcnKTtcbiAgfVxuICAvLyBOT1RFOiB0aGUgbGluayBtYXkgbm93IGJlIGluIDMgc3RhdGVzOiAoMSkgcGVuZGluZyBpbnNlcnRpb24sXG4gIC8vICgyKSBpbmZsaWdodCwgKDMpIGFscmVhZHkgbGFvZGVkLiBJbiBlYWNoIGNhc2UsIHdlIG5lZWQgdG8gYWRkXG4gIC8vIGV2ZW50IGxpc3RlbmVycyB0byBwcm9jZXNzIGNhbGxiYWNrcy5cbiAgbGV0IGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkTGlzdGVuZXIpO1xuICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgfTtcbiAgbGV0IGxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgY2xlYW51cCgpO1xuICAgIC8vIEluIGNhc2Ugb2YgYSBzdWNjZXNzZnVsIGxvYWQsIGNhY2hlIHRoZSBsb2FkIGV2ZW50IG9uIHRoZSBsaW5rIHNvXG4gICAgLy8gdGhhdCBpdCBjYW4gYmUgdXNlZCB0byBzaG9ydC1jaXJjdWl0IHRoaXMgbWV0aG9kIGluIHRoZSBmdXR1cmUgd2hlblxuICAgIC8vIGl0IGlzIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGhyZWYgcGFyYW0uXG4gICAgbGluay5fX2R5bmFtaWNJbXBvcnRMb2FkZWQgPSB0cnVlO1xuICAgIGlmIChvbmxvYWQpIHtcbiAgICAgIHdoZW5JbXBvcnRzUmVhZHkoKCkgPT4ge1xuICAgICAgICBvbmxvYWQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBsZXQgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgY2xlYW51cCgpO1xuICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IsIHJlbW92ZSB0aGUgbGluayBmcm9tIHRoZSBkb2N1bWVudCBzbyB0aGF0IGl0XG4gICAgLy8gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgYWdhaW4gdGhlIG5leHQgdGltZSBgaW1wb3J0SHJlZmAgaXNcbiAgICAvLyBjYWxsZWQuXG4gICAgaWYgKGxpbmsucGFyZW50Tm9kZSkge1xuICAgICAgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgIH1cbiAgICBpZiAob25lcnJvcikge1xuICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgIG9uZXJyb3IoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkTGlzdGVuZXIpO1xuICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gIGlmIChsaW5rLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gIC8vIGlmIHRoZSBsaW5rIGFscmVhZHkgbG9hZGVkLCBkaXNwYXRjaCBhIGZha2UgbG9hZCBldmVudFxuICAvLyBzbyB0aGF0IGxpc3RlbmVycyBhcmUgY2FsbGVkIGFuZCBnZXQgYSBwcm9wZXIgZXZlbnQgYXJndW1lbnQuXG4gIH0gZWxzZSBpZiAobGluay5fX2R5bmFtaWNJbXBvcnRMb2FkZWQpIHtcbiAgICBsaW5rLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdsb2FkJykpO1xuICB9XG4gIHJldHVybiBsaW5rO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuanMiLCJmdW5jdGlvbiByZXNvbHZlKCkge1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZSgndW5yZXNvbHZlZCcpO1xufVxuXG5pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gIHJlc29sdmUoKTtcbn0gZWxzZSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgcmVzb2x2ZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanMiLCJpbXBvcnQgeyBMZWdhY3lFbGVtZW50TWl4aW4gfSBmcm9tICcuL2xlZ2FjeS1lbGVtZW50LW1peGluLmpzJztcbmltcG9ydCB7IERvbU1vZHVsZSB9IGZyb20gJy4uL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMnO1xuXG5sZXQgbWV0YVByb3BzID0ge1xuICBhdHRhY2hlZDogdHJ1ZSxcbiAgZGV0YWNoZWQ6IHRydWUsXG4gIHJlYWR5OiB0cnVlLFxuICBjcmVhdGVkOiB0cnVlLFxuICBiZWZvcmVSZWdpc3RlcjogdHJ1ZSxcbiAgcmVnaXN0ZXJlZDogdHJ1ZSxcbiAgYXR0cmlidXRlQ2hhbmdlZDogdHJ1ZSxcbiAgLy8gbWV0YSBvYmplY3RzXG4gIGJlaGF2aW9yczogdHJ1ZVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgXCJsZWdhY3lcIiBiZWhhdmlvciBvciBhcnJheSBvZiBiZWhhdmlvcnMgdG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgYXV0b21hdGljYWxseSBhbHNvIGFwcGx5IHRoZSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gXG4gKiB0byBlbnN1cmUgdGhhdCBhbnkgbGVnYWN5IGJlaGF2aW9ycyBjYW4gcmVseSBvbiBsZWdhY3kgUG9seW1lciBBUEkgb25cbiAqIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHshKE9iamVjdHxBcnJheSl9IGJlaGF2aW9ycyBCZWhhdmlvciBvYmplY3Qgb3IgYXJyYXkgb2YgYmVoYXZpb3JzLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR8ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0ga2xhc3MgRWxlbWVudCBjbGFzcy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IFJldHVybnMgYSBuZXcgRWxlbWVudCBjbGFzcyBleHRlbmRlZCBieSB0aGVcbiAqIHBhc3NlZCBpbiBgYmVoYXZpb3JzYCBhbmQgYWxzbyBieSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gLlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzLCBjaGVja1R5cGVzfVxuICovXG5mdW5jdGlvbiBtaXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKSB7XG4gIGlmICghYmVoYXZpb3JzKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGtsYXNzKTtcbiAgfVxuICAvLyBOT1RFOiBlbnN1cmUgdGhlIGJhaGV2aW9yIGlzIGV4dGVuZGluZyBhIGNsYXNzIHdpdGhcbiAgLy8gbGVnYWN5IGVsZW1lbnQgYXBpLiBUaGlzIGlzIG5lY2Vzc2FyeSBzaW5jZSBiZWhhdmlvcnMgZXhwZWN0IHRvIGJlIGFibGVcbiAgLy8gdG8gYWNjZXNzIDEueCBsZWdhY3kgYXBpLlxuICBrbGFzcyA9IExlZ2FjeUVsZW1lbnRNaXhpbihrbGFzcyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShiZWhhdmlvcnMpKSB7XG4gICAgYmVoYXZpb3JzID0gW2JlaGF2aW9yc107XG4gIH1cbiAgbGV0IHN1cGVyQmVoYXZpb3JzID0ga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycztcbiAgLy8gZ2V0IGZsYXR0ZW5lZCwgZGVkdXBlZCBsaXN0IG9mIGJlaGF2aW9ycyAqbm90KiBhbHJlYWR5IG9uIHN1cGVyIGNsYXNzXG4gIGJlaGF2aW9ycyA9IGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBudWxsLCBzdXBlckJlaGF2aW9ycyk7XG4gIC8vIG1peGluIG5ldyBiZWhhdmlvcnNcbiAga2xhc3MgPSBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcyk7XG4gIGlmIChzdXBlckJlaGF2aW9ycykge1xuICAgIGJlaGF2aW9ycyA9IHN1cGVyQmVoYXZpb3JzLmNvbmNhdChiZWhhdmlvcnMpO1xuICB9XG4gIC8vIFNldCBiZWhhdmlvcnMgb24gcHJvdG90eXBlIGZvciBCQy4uLlxuICBrbGFzcy5wcm90b3R5cGUuYmVoYXZpb3JzID0gYmVoYXZpb3JzO1xuICByZXR1cm4ga2xhc3M7XG59XG5cbi8vIE5PVEU6XG4vLyAxLnhcbi8vIEJlaGF2aW9ycyB3ZXJlIG1peGVkIGluICppbiByZXZlcnNlIG9yZGVyKiBhbmQgZGUtZHVwZWQgb24gdGhlIGZseS5cbi8vIFRoZSBydWxlIHdhcyB0aGF0IGJlaGF2aW9yIHByb3BlcnRpZXMgd2VyZSBjb3BpZWQgb250byB0aGUgZWxlbWVudFxuLy8gcHJvdG90eXBlIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm9wZXJ0eSBkaWQgbm90IGFscmVhZHkgZXhpc3QuXG4vLyBHaXZlbjogUG9seW1lcnsgYmVoYXZpb3JzOiBbQSwgQiwgQywgQSwgQl19LCBwcm9wZXJ0eSBjb3B5IG9yZGVyIHdhczpcbi8vICgxKSwgQiwgKDIpLCBBLCAoMykgQy4gVGhpcyBtZWFucyBwcm90b3R5cGUgcHJvcGVydGllcyB3aW4gb3ZlclxuLy8gQiBwcm9wZXJ0aWVzIHdpbiBvdmVyIEEgd2luIG92ZXIgQy4gVGhpcyBtaXJyb3JzIHdoYXQgd291bGQgaGFwcGVuXG4vLyB3aXRoIGluaGVyaXRhbmNlIGlmIGVsZW1lbnQgZXh0ZW5kZWQgQiBleHRlbmRlZCBBIGV4dGVuZGVkIEMuXG4vL1xuLy8gQWdhaW4gZ2l2ZW4sIFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgdGhlIHJlc3VsdGluZ1xuLy8gYGJlaGF2aW9yc2AgYXJyYXkgd2FzIFtDLCBBLCBCXS5cbi8vIEJlaGF2aW9yIGxpZmVjeWNsZSBtZXRob2RzIHdlcmUgY2FsbGVkIGluIGJlaGF2aW9yIGFycmF5IG9yZGVyXG4vLyBmb2xsb3dlZCBieSB0aGUgZWxlbWVudCwgZS5nLiAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLFxuLy8gKDMpIEIuY3JlYXRlZCwgKDQpIGVsZW1lbnQuY3JlYXRlZC4gVGhlcmUgd2FzIG5vIHN1cHBvcnQgZm9yXG4vLyBzdXBlciwgYW5kIFwic3VwZXItYmVoYXZpb3JcIiBtZXRob2RzIHdlcmUgY2FsbGFibGUgb25seSBieSBuYW1lKS5cbi8vXG4vLyAyLnhcbi8vIEJlaGF2aW9ycyBhcmUgbWFkZSBpbnRvIHByb3BlciBtaXhpbnMgd2hpY2ggbGl2ZSBpbiB0aGVcbi8vIGVsZW1lbnQncyBwcm90b3R5cGUgY2hhaW4uIEJlaGF2aW9ycyBhcmUgcGxhY2VkIGluIHRoZSBlbGVtZW50IHByb3RvdHlwZVxuLy8gZWxkZXN0IHRvIHlvdW5nZXN0IGFuZCBkZS1kdXBlZCB5b3VuZ2VzdCB0byBvbGRlc3Q6XG4vLyBTbywgZmlyc3QgW0EsIEIsIEMsIEEsIEJdIGJlY29tZXMgW0MsIEEsIEJdIHRoZW4sXG4vLyB0aGUgZWxlbWVudCBwcm90b3R5cGUgYmVjb21lcyAob2xkZXN0KSAoMSkgUG9seW1lci5FbGVtZW50LCAoMikgY2xhc3MoQyksXG4vLyAoMykgY2xhc3MoQSksICg0KSBjbGFzcyhCKSwgKDUpIGNsYXNzKFBvbHltZXIoey4uLn0pKS5cbi8vIFJlc3VsdDpcbi8vIFRoaXMgbWVhbnMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpbiBvdmVyIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpblxuLy8gb3ZlciBDLiAoc2FtZSBhcyAxLngpXG4vLyBJZiBsaWZlY3ljbGUgaXMgY2FsbGVkIChzdXBlciB0aGVuIG1lKSwgb3JkZXIgaXNcbi8vICgxKSBDLmNyZWF0ZWQsICgyKSBBLmNyZWF0ZWQsICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWRcbi8vIChhZ2FpbiBzYW1lIGFzIDEueClcbmZ1bmN0aW9uIF9taXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKSB7XG4gIGZvciAobGV0IGk9MDsgaTxiZWhhdmlvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICBpZiAoYikge1xuICAgICAga2xhc3MgPSBBcnJheS5pc0FycmF5KGIpID8gX21peGluQmVoYXZpb3JzKGIsIGtsYXNzKSA6XG4gICAgICAgIEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhiLCBrbGFzcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrbGFzcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBiZWhhdmlvcnMgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7QXJyYXk9fSBsaXN0IFRhcmdldCBsaXN0IHRvIGZsYXR0ZW4gYmVoYXZpb3JzIGludG8uXG4gKiBAcGFyYW0ge0FycmF5PX0gZXhjbHVkZSBMaXN0IG9mIGJlaGF2aW9ycyB0byBleGNsdWRlIGZyb20gdGhlIGxpc3QuXG4gKiBAcmV0dXJuIHshQXJyYXl9IFJldHVybnMgdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIGJlaGF2aW9ycy5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGxpc3QsIGV4Y2x1ZGUpIHtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIGZvciAobGV0IGk9YmVoYXZpb3JzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIGxldCBiID0gYmVoYXZpb3JzW2ldO1xuICAgIGlmIChiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICBmbGF0dGVuQmVoYXZpb3JzKGIsIGxpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVkdXBcbiAgICAgICAgaWYgKGxpc3QuaW5kZXhPZihiKSA8IDAgJiYgKCFleGNsdWRlIHx8IGV4Y2x1ZGUuaW5kZXhPZihiKSA8IDApKSB7XG4gICAgICAgICAgbGlzdC51bnNoaWZ0KGIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignYmVoYXZpb3IgaXMgbnVsbCwgY2hlY2sgZm9yIG1pc3Npbmcgb3IgNDA0IGltcG9ydCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQb2x5bWVyIGluZm8gb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEJhc2UgYmFzZSBjbGFzcyB0byBleHRlbmQgd2l0aCBpbmZvIG9iamVjdFxuICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gR2VuZXJhdGVkIGNsYXNzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oaW5mbywgQmFzZSkge1xuXG4gIGNsYXNzIFBvbHltZXJHZW5lcmF0ZWQgZXh0ZW5kcyBCYXNlIHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiBpbmZvLnByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gaW5mby5vYnNlcnZlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgZm9yIHRoaXMgY2xhc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgLy8gZ2V0IHRlbXBsYXRlIGZpcnN0IGZyb20gYW55IGltcGVyYXRpdmUgc2V0IGluIGBpbmZvLl90ZW1wbGF0ZWBcbiAgICAgIHJldHVybiBpbmZvLl90ZW1wbGF0ZSB8fFxuICAgICAgICAvLyBuZXh0IGxvb2sgaW4gZG9tLW1vZHVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlbGVtZW50J3MgaXMuXG4gICAgICAgIERvbU1vZHVsZSAmJiBEb21Nb2R1bGUuaW1wb3J0KHRoaXMuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgIC8vIG5leHQgbG9vayBmb3Igc3VwZXJjbGFzcyB0ZW1wbGF0ZSAobm90ZTogdXNlIHN1cGVyY2xhc3Mgc3ltYm9sXG4gICAgICAgIC8vIHRvIGVuc3VyZSBjb3JyZWN0IGB0aGlzLmlzYClcbiAgICAgICAgQmFzZS50ZW1wbGF0ZSB8fFxuICAgICAgICAvLyBmaW5hbGx5IGZhbGwgYmFjayB0byBgX3RlbXBsYXRlYCBpbiBlbGVtZW50J3MgcHJvdG95cGUuXG4gICAgICAgIHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZSB8fFxuICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIGNyZWF0ZWQoKSB7XG4gICAgICBzdXBlci5jcmVhdGVkKCk7XG4gICAgICBpZiAoaW5mby5jcmVhdGVkKSB7XG4gICAgICAgIGluZm8uY3JlYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWdpc3RlcmVkKCkge1xuICAgICAgc3VwZXIuX3JlZ2lzdGVyZWQoKTtcbiAgICAgIC8qIE5PVEU6IGBiZWZvcmVSZWdpc3RlcmAgaXMgY2FsbGVkIGhlcmUgZm9yIGJjLCBidXQgdGhlIGJlaGF2aW9yXG4gICAgICAgaXMgZGlmZmVyZW50IHRoYW4gaW4gMS54LiBJbiAxLjAsIHRoZSBtZXRob2Qgd2FzIGNhbGxlZCAqYWZ0ZXIqXG4gICAgICAgbWl4aW5nIHByb3RvdHlwZXMgdG9nZXRoZXIgYnV0ICpiZWZvcmUqIHByb2Nlc3Npbmcgb2YgbWV0YS1vYmplY3RzLlxuICAgICAgIEhvd2V2ZXIsIGR5bmFtaWMgZWZmZWN0cyBjYW4gc3RpbGwgYmUgc2V0IGhlcmUgYW5kIGNhbiBiZSBkb25lIGVpdGhlclxuICAgICAgIGluIGBiZWZvcmVSZWdpc3RlcmAgb3IgYHJlZ2lzdGVyZWRgLiBJdCBpcyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0XG4gICAgICAgYGlzYCBpbiBgYmVmb3JlUmVnaXN0ZXJgIGFzIHlvdSBjb3VsZCBpbiAxLnguXG4gICAgICAqL1xuICAgICAgaWYgKGluZm8uYmVmb3JlUmVnaXN0ZXIpIHtcbiAgICAgICAgaW5mby5iZWZvcmVSZWdpc3Rlci5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5yZWdpc3RlcmVkKSB7XG4gICAgICAgIGluZm8ucmVnaXN0ZXJlZC5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2FwcGx5TGlzdGVuZXJzKCkge1xuICAgICAgc3VwZXIuX2FwcGx5TGlzdGVuZXJzKCk7XG4gICAgICBpZiAoaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgZm9yIChsZXQgbCBpbiBpbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgIHRoaXMuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUodGhpcywgbCwgaW5mby5saXN0ZW5lcnNbbF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm90ZTogZXhjZXB0aW9uIHRvIFwic3VwZXIgdGhlbiBtZVwiIHJ1bGU7XG4gICAgLy8gZG8gd29yayBiZWZvcmUgY2FsbGluZyBzdXBlciBzbyB0aGF0IHN1cGVyIGF0dHJpYnV0ZXNcbiAgICAvLyBvbmx5IGFwcGx5IGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgICBfZW5zdXJlQXR0cmlidXRlcygpIHtcbiAgICAgIGlmIChpbmZvLmhvc3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAobGV0IGEgaW4gaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZShhLCBpbmZvLmhvc3RBdHRyaWJ1dGVzW2FdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3VwZXIuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICByZWFkeSgpIHtcbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgICBpZiAoaW5mby5yZWFkeSkge1xuICAgICAgICBpbmZvLnJlYWR5LmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0YWNoZWQoKSB7XG4gICAgICBzdXBlci5hdHRhY2hlZCgpO1xuICAgICAgaWYgKGluZm8uYXR0YWNoZWQpIHtcbiAgICAgICAgaW5mby5hdHRhY2hlZC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGFjaGVkKCkge1xuICAgICAgc3VwZXIuZGV0YWNoZWQoKTtcbiAgICAgIGlmIChpbmZvLmRldGFjaGVkKSB7XG4gICAgICAgIGluZm8uZGV0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICBpZiAoaW5mby5hdHRyaWJ1dGVDaGFuZ2VkKSB7XG4gICAgICAgIGluZm8uYXR0cmlidXRlQ2hhbmdlZC5jYWxsKHRoaXMsIG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgfVxuICAgfVxuICB9XG5cbiAgUG9seW1lckdlbmVyYXRlZC5nZW5lcmF0ZWRGcm9tID0gaW5mbztcblxuICBmb3IgKGxldCBwIGluIGluZm8pIHtcbiAgICAvLyBOT1RFOiBjYW5ub3QgY29weSBgbWV0YVByb3BzYCBtZXRob2RzIG9udG8gcHJvdG90eXBlIGF0IGxlYXN0IGJlY2F1c2VcbiAgICAvLyBgc3VwZXIucmVhZHlgIG11c3QgYmUgY2FsbGVkIGFuZCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHVzZXIgZm4uXG4gICAgaWYgKCEocCBpbiBtZXRhUHJvcHMpKSB7XG4gICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluZm8sIHApO1xuICAgICAgaWYgKHBkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2x5bWVyR2VuZXJhdGVkLnByb3RvdHlwZSwgcCwgcGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQb2x5bWVyR2VuZXJhdGVkO1xufVxuXG5leHBvcnQgY29uc3QgQ2xhc3MgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmICghaW5mbykge1xuICAgIGNvbnNvbGUud2FybignUG9seW1lci5DbGFzcyByZXF1aXJlcyBgaW5mb2AgYXJndW1lbnQnKTtcbiAgfVxuICBsZXQga2xhc3MgPSBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oaW5mbywgaW5mby5iZWhhdmlvcnMgP1xuICAgIC8vIG5vdGU6IG1peGluQmVoYXZpb3JzIGVuc3VyZXMgYExlZ2FjeUVsZW1lbnRNaXhpbmAuXG4gICAgbWl4aW5CZWhhdmlvcnMoaW5mby5iZWhhdmlvcnMsIEhUTUxFbGVtZW50KSA6XG4gICAgTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KSk7XG4gIC8vIGRlY29yYXRlIGtsYXNzIHdpdGggcmVnaXN0cmF0aW9uIGluZm9cbiAga2xhc3MuaXMgPSBpbmZvLmlzO1xuICByZXR1cm4ga2xhc3M7XG59O1xuXG5leHBvcnQgeyBtaXhpbkJlaGF2aW9ycyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvY2xhc3MuanMiLCJpbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBhcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwLCBUZW1wbGF0aXplIH0gZnJvbSAnLi4vdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5cbmxldCBUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFRlbXBsYXRlSW5zdGFuY2VCYXNlJDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBfdGVtcGxhdGl6ZXJUZW1wbGF0ZTogSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAqICAgX3BhcmVudE1vZGVsOiBib29sZWFuLFxuICogICBfaW5zdGFuY2VQcm9wczogT2JqZWN0LFxuICogICBfZm9yd2FyZEhvc3RQcm9wVjI6IEZ1bmN0aW9uLFxuICogICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IEZ1bmN0aW9uLFxuICogICBjdG9yOiBUZW1wbGF0ZUluc3RhbmNlQmFzZVxuICogfX1cbiAqL1xubGV0IFRlbXBsYXRpemVyVXNlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIFRoZSBgUG9seW1lci5UZW1wbGF0aXplcmAgYmVoYXZpb3IgYWRkcyBtZXRob2RzIHRvIGdlbmVyYXRlIGluc3RhbmNlcyBvZlxuICogdGVtcGxhdGVzIHRoYXQgYXJlIGVhY2ggbWFuYWdlZCBieSBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYFxuICogaW5zdGFuY2Ugd2hlcmUgZGF0YS1iaW5kaW5ncyBpbiB0aGUgc3RhbXBlZCB0ZW1wbGF0ZSBjb250ZW50IGFyZSBib3VuZCB0b1xuICogYWNjZXNzb3JzIG9uIGl0c2VsZi5cbiAqXG4gKiBUaGlzIGJlaGF2aW9yIGlzIHByb3ZpZGVkIGluIFBvbHltZXIgMi54IGFzIGEgaHlicmlkLWVsZW1lbnQgY29udmVuaWVuY2VcbiAqIG9ubHkuICBGb3Igbm9uLWh5YnJpZCB1c2FnZSwgdGhlIGBQb2x5bWVyLlRlbXBsYXRpemVgIGxpYnJhcnlcbiAqIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gKiAgICAgdGhpcy50ZW1wbGF0aXplKHRlbXBsYXRlKTtcbiAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAqICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLnN0YW1wKHtteVByb3A6ICdpbml0aWFsJ30pO1xuICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICogICAgIFBvbHltZXIuZG9tKHRoaXMpLmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICogICAgIC8vIENoYW5naW5nIGEgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlIHdpbGwgcHJvcGFnYXRlIHRvIGJpbmRpbmdzXG4gKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gKlxuICogVXNlcnMgb2YgYFRlbXBsYXRpemVyYCBtYXkgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBhYnN0cmFjdFxuICogQVBJJ3MgdG8gZGV0ZXJtaW5lIGhvdyBwcm9wZXJ0aWVzIGFuZCBwYXRocyBmcm9tIHRoZSBob3N0IHNob3VsZCBiZVxuICogZm9yd2FyZGVkIGludG8gdG8gaW5zdGFuY2VzOlxuICpcbiAqICAgICBfZm9yd2FyZEhvc3RQcm9wVjI6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKVxuICpcbiAqIExpa2V3aXNlLCB1c2VycyBtYXkgaW1wbGVtZW50IHRoZXNlIGFkZGl0aW9uYWwgYWJzdHJhY3QgQVBJJ3MgdG8gZGV0ZXJtaW5lXG4gKiBob3cgaW5zdGFuY2Utc3BlY2lmaWMgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBvbiB0aGUgaW5zdGFuY2Ugc2hvdWxkIGJlXG4gKiBmb3J3YXJkZWQgb3V0IHRvIHRoZSBob3N0LCBpZiBuZWNlc3NhcnkuXG4gKlxuICogICAgIF9ub3RpZnlJbnN0YW5jZVByb3BWMjogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpXG4gKlxuICogSW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoaWNoIHByb3BlcnRpZXMgYXJlIGluc3RhbmNlLXNwZWNpZmljIGFuZCByZXF1aXJlXG4gKiBjdXN0b20gbm90aWZpY2F0aW9uIHZpYSBgX25vdGlmeUluc3RhbmNlUHJvcGAsIGRlZmluZSBhbiBgX2luc3RhbmNlUHJvcHNgXG4gKiBvYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBlYWNoIGluc3RhbmNlIHByb3AsIGZvciBleGFtcGxlOlxuICpcbiAqICAgICBfaW5zdGFuY2VQcm9wczoge1xuICogICAgICAgaXRlbTogdHJ1ZSxcbiAqICAgICAgIGluZGV4OiB0cnVlXG4gKiAgICAgfVxuICpcbiAqIEFueSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluIF9pbnN0YW5jZVByb3BcbiAqIHdpbGwgYmUgZm9yd2FyZGVkIG91dCB0byB0aGUgVGVtcGxhdGl6ZSBgb3duZXJgIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogVXNlcnMgbWF5IGFsc28gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3QgZnVuY3Rpb24gdG8gc2hvdyBvclxuICogaGlkZSBhbnkgRE9NIGdlbmVyYXRlZCB1c2luZyBgc3RhbXBgOlxuICpcbiAqICAgICBfc2hvd0hpZGVDaGlsZHJlbjogZnVuY3Rpb24oc2hvdWxkSGlkZSlcbiAqXG4gKiBOb3RlIHRoYXQgc29tZSBjYWxsYmFja3MgYXJlIHN1ZmZpeGVkIHdpdGggYFYyYCBpbiB0aGUgUG9seW1lciAyLnggYmVoYXZpb3JcbiAqIGFzIHRoZSBpbXBsZW1lbnRhdGlvbnMgd2lsbCBuZWVkIHRvIGRpZmZlciBmcm9tIHRoZSBjYWxsYmFja3MgcmVxdWlyZWRcbiAqIGJ5IHRoZSAxLnggVGVtcGxhdGl6ZXIgQVBJIGR1ZSB0byBjaGFuZ2VzIGluIHRoZSBgVGVtcGxhdGVJbnN0YW5jZWAgQVBJXG4gKiBiZXR3ZWVuIHZlcnNpb25zIDEueCBhbmQgMi54LlxuICpcbiAqIEBwb2x5bWVyQmVoYXZpb3JcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCBUZW1wbGF0aXplciA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGFub255bW91cyBgVGVtcGxhdGVJbnN0YW5jZWAgY2xhc3MgKHN0b3JlZCBhcyBgdGhpcy5jdG9yYClcbiAgICogZm9yIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZS4gIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgb25jZSBwZXJcbiAgICogdGVtcGxhdGUgdG8gcHJlcGFyZSBhbiBlbGVtZW50IGZvciBzdGFtcGluZyB0aGUgdGVtcGxhdGUsIGZvbGxvd2VkXG4gICAqIGJ5IGBzdGFtcGAgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByZXBhcmVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gbXV0YWJsZURhdGEgV2hlbiBgdHJ1ZWAsIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgd2lsbCBza2lwXG4gICAqICAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvXG4gICAqICAgYmUgXCJkaXJ0eVwiKS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAqL1xuICB0ZW1wbGF0aXplKHRlbXBsYXRlLCBtdXRhYmxlRGF0YSkge1xuICAgIHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB0aGlzLmN0b3IgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuKG11dGFibGVEYXRhKSxcbiAgICAgIHBhcmVudE1vZGVsOiB0aGlzLl9wYXJlbnRNb2RlbCxcbiAgICAgIGluc3RhbmNlUHJvcHM6IHRoaXMuX2luc3RhbmNlUHJvcHMsXG4gICAgICBmb3J3YXJkSG9zdFByb3A6IHRoaXMuX2ZvcndhcmRIb3N0UHJvcFYyLFxuICAgICAgbm90aWZ5SW5zdGFuY2VQcm9wOiB0aGlzLl9ub3RpZnlJbnN0YW5jZVByb3BWMlxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBwcmVwYXJlZCBieSBgdGVtcGxhdGl6ZWAuICBUaGUgb2JqZWN0XG4gICAqIHJldHVybmVkIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBhbm9ueW1vdXMgY2xhc3MgZ2VuZXJhdGVkIGJ5IGB0ZW1wbGF0aXplYFxuICAgKiB3aG9zZSBgcm9vdGAgcHJvcGVydHkgaXMgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIG5ld2x5IGNsb25lZFxuICAgKiB0ZW1wbGF0ZSBjb250ZW50LCBhbmQgd2hpY2ggaGFzIHByb3BlcnR5IGFjY2Vzc29ycyBjb3JyZXNwb25kaW5nIHRvXG4gICAqIHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBtb2RlbCBPYmplY3QgY29udGFpbmluZyBpbml0aWFsIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgKiAgIHBvcHVsYXRlIGludG8gdGhlIHRlbXBsYXRlIGJpbmRpbmdzLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnN0YW5jZSBvZlxuICAgKiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgc3RhbXAobW9kZWwpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihtb2RlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiAoYFRlbXBsYXRlSW5zdGFuY2VgKSBhc3NvY2lhdGVkIHdpdGhcbiAgICogYSBnaXZlbiBlbGVtZW50LCB3aGljaCBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgKiBpbnN0YW5jZSB0aGUgZWxlbWVudCBpcyBjb250YWluZWQgaW4uICBBIHRlbXBsYXRlIG1vZGVsIHNob3VsZCBiZSB1c2VkXG4gICAqIHRvIG1hbmlwdWxhdGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBNb2RlbCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAqICAgdGhlIGVsZW1lbnQuXG4gICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAqL1xuICBtb2RlbEZvckVsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gVGVtcGxhdGl6ZS5tb2RlbEZvckVsZW1lbnQodGhpcy5fdGVtcGxhdGl6ZXJUZW1wbGF0ZSwgZWwpO1xuICB9XG59O1xuXG5leHBvcnQgeyBUZW1wbGF0aXplciB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuaW1wb3J0IHsgT3B0aW9uYWxNdXRhYmxlRGF0YSB9IGZyb20gJy4uL21peGlucy9tdXRhYmxlLWRhdGEuanMnO1xuaW1wb3J0IHsgR2VzdHVyZUV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnLi4vbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtIVE1MRWxlbWVudH1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gKi9cbmNvbnN0IGRvbUJpbmRCYXNlID1cbiAgR2VzdHVyZUV2ZW50TGlzdGVuZXJzKFxuICAgIE9wdGlvbmFsTXV0YWJsZURhdGEoXG4gICAgICBQcm9wZXJ0eUVmZmVjdHMoSFRNTEVsZW1lbnQpKSk7XG5cbi8qKlxuICogQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhIGJpbmRpbmcsXG4gKiBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy4pIGluIHRoZSBtYWluIGRvY3VtZW50IHdpdGhvdXQgZGVmaW5pbmdcbiAqIGEgbmV3IGN1c3RvbSBlbGVtZW50LlxuICpcbiAqIGA8dGVtcGxhdGU+YCB0YWdzIHV0aWxpemluZyBiaW5kaW5ncyBtYXkgYmUgd3JhcHBlZCB3aXRoIHRoZSBgPGRvbS1iaW5kPmBcbiAqIGVsZW1lbnQsIHdoaWNoIHdpbGwgaW1tZWRpYXRlbHkgc3RhbXAgdGhlIHdyYXBwZWQgdGVtcGxhdGUgaW50byB0aGUgbWFpblxuICogZG9jdW1lbnQgYW5kIGJpbmQgZWxlbWVudHMgdG8gdGhlIGBkb20tYmluZGAgZWxlbWVudCBpdHNlbGYgYXMgdGhlXG4gKiBiaW5kaW5nIHNjb3BlLlxuICpcbiAqIEBwb2x5bWVyXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnNcbiAqIEBleHRlbmRzIHtkb21CaW5kQmFzZX1cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0byBhbGxvdyB1c2luZyBQb2x5bWVyJ3MgdGVtcGxhdGUgZmVhdHVyZXMgKGRhdGFcbiAqICAgYmluZGluZywgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudC5cbiAqL1xuY2xhc3MgRG9tQmluZCBleHRlbmRzIGRvbUJpbmRCYXNlIHtcblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnbXV0YWJsZS1kYXRhJ107IH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy4kID0gbnVsbDtcbiAgICB0aGlzLl9fY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgLy8gYXNzdW1lcyBvbmx5IG9uZSBvYnNlcnZlZCBhdHRyaWJ1dGVcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCkge1xuICAgIHRoaXMubXV0YWJsZURhdGEgPSB0cnVlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX19yZW1vdmVDaGlsZHJlbigpO1xuICB9XG5cbiAgX19pbnNlcnRDaGlsZHJlbigpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMucm9vdCwgdGhpcyk7XG4gIH1cblxuICBfX3JlbW92ZUNoaWxkcmVuKCkge1xuICAgIGlmICh0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuX19jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIFRoaXMgaXMgdHlwaWNhbGx5IG9ubHlcbiAgICogbmVjZXNzYXJ5IHRvIGNhbGwgaWYgSFRNTEltcG9ydHMgd2l0aCB0aGUgYXN5bmMgYXR0cmlidXRlIGFyZSB1c2VkLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGxldCB0ZW1wbGF0ZTtcbiAgICBpZiAoIXRoaXMuX19jaGlsZHJlbikge1xuICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRlbXBsYXRlIHx8IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLWJpbmQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICB0aGlzLl9fY2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAobGV0IG49dGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICB0aGlzLl9fY2hpbGRyZW5bdGhpcy5fX2NoaWxkcmVuLmxlbmd0aF0gPSBuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgIH1cbiAgICB0aGlzLl9faW5zZXJ0Q2hpbGRyZW4oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfSkpO1xuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tYmluZCcsIERvbUJpbmQpO1xuXG5leHBvcnQgeyBEb21CaW5kIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmpzIiwiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uLy4uL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0aXplIH0gZnJvbSAnLi4vdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyBlbnF1ZXVlRGVib3VuY2VyLCBmbHVzaCB9IGZyb20gJy4uL3V0aWxzL2ZsdXNoLmpzJztcbmltcG9ydCB7IG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcbmltcG9ydCB7IHJvb3QgYXMgcm9vdCQwIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5cbi8qKlxuICogVGhlIGA8ZG9tLWlmPmAgZWxlbWVudCB3aWxsIHN0YW1wIGEgbGlnaHQtZG9tIGA8dGVtcGxhdGU+YCBjaGlsZCB3aGVuXG4gKiB0aGUgYGlmYCBwcm9wZXJ0eSBiZWNvbWVzIHRydXRoeSwgYW5kIHRoZSB0ZW1wbGF0ZSBjYW4gdXNlIFBvbHltZXJcbiAqIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgZmVhdHVyZXMgd2hlbiB1c2VkIGluIHRoZSBjb250ZXh0IG9mXG4gKiBhIFBvbHltZXIgZWxlbWVudCdzIHRlbXBsYXRlLlxuICpcbiAqIFdoZW4gYGlmYCBiZWNvbWVzIGZhbHNleSwgdGhlIHN0YW1wZWQgY29udGVudCBpcyBoaWRkZW4gYnV0IG5vdFxuICogcmVtb3ZlZCBmcm9tIGRvbS4gV2hlbiBgaWZgIHN1YnNlcXVlbnRseSBiZWNvbWVzIHRydXRoeSBhZ2FpbiwgdGhlIGNvbnRlbnRcbiAqIGlzIHNpbXBseSByZS1zaG93bi4gVGhpcyBhcHByb2FjaCBpcyB1c2VkIGR1ZSB0byBpdHMgZmF2b3JhYmxlIHBlcmZvcm1hbmNlXG4gKiBjaGFyYWN0ZXJpc3RpY3M6IHRoZSBleHBlbnNlIG9mIGNyZWF0aW5nIHRlbXBsYXRlIGNvbnRlbnQgaXMgcGFpZCBvbmx5XG4gKiBvbmNlIGFuZCBsYXppbHkuXG4gKlxuICogU2V0IHRoZSBgcmVzdGFtcGAgcHJvcGVydHkgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgc3RhbXBlZCBjb250ZW50IHRvIGJlXG4gKiBjcmVhdGVkIC8gZGVzdHJveWVkIHdoZW4gdGhlIGBpZmAgY29uZGl0aW9uIGNoYW5nZXMuXG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBwb2x5bWVyXG4gKiBAZXh0ZW5kcyBQb2x5bWVyLkVsZW1lbnRcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IGNvbmRpdGlvbmFsbHkgc3RhbXBzIGFuZCBoaWRlcyBvciByZW1vdmVzXG4gKiAgIHRlbXBsYXRlIGNvbnRlbnQgYmFzZWQgb24gYSBib29sZWFuIGZsYWcuXG4gKi9cbmNsYXNzIERvbUlmIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1pZic7IH1cblxuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgIHJldHVybiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbmV2ZXIgRE9NIGlzIGFkZGVkIG9yIHJlbW92ZWQvaGlkZGVuIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICAgKiBkZWZhdWx0LCByZW5kZXJpbmcgb2NjdXJzIGxhemlseSkuICBUbyBmb3JjZSBpbW1lZGlhdGUgcmVuZGVyaW5nLCBjYWxsXG4gICAgICAgKiBgcmVuZGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgZG9tLWNoYW5nZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIHRlbXBsYXRlIHNob3VsZCBzdGFtcC5cbiAgICAgICAqL1xuICAgICAgaWY6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRydWUsIGVsZW1lbnRzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIERPTSBhbmQgZGlzY2FyZGVkIHdoZW4gYGlmYFxuICAgICAgICogYmVjb21lcyBmYWxzZSBhbmQgcmUtY3JlYXRlZCBhbmQgYWRkZWQgYmFjayB0byB0aGUgRE9NIHdoZW4gYGlmYFxuICAgICAgICogYmVjb21lcyB0cnVlLiAgQnkgZGVmYXVsdCwgc3RhbXBlZCBlbGVtZW50cyB3aWxsIGJlIGhpZGRlbiBidXQgbGVmdFxuICAgICAgICogaW4gdGhlIERPTSB3aGVuIGBpZmAgYmVjb21lcyBmYWxzZSwgd2hpY2ggaXMgZ2VuZXJhbGx5IHJlc3VsdHNcbiAgICAgICAqIGluIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAqL1xuICAgICAgcmVzdGFtcDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBvYnNlcnZlcjogJ19fZGVib3VuY2VSZW5kZXInXG4gICAgICB9XG5cbiAgICB9O1xuXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5fbGFzdElmID0gZmFsc2U7XG4gICAgdGhpcy5fX2N0b3IgPSBudWxsO1xuICB9XG5cbiAgX19kZWJvdW5jZVJlbmRlcigpIHtcbiAgICAvLyBSZW5kZXIgaXMgYXN5bmMgZm9yIDIgcmVhc29uczpcbiAgICAvLyAxLiBUbyBlbGltaW5hdGUgZG9tIGNyZWF0aW9uIHRyYXNoaW5nIGlmIHVzZXIgY29kZSB0aHJhc2hlcyBgaWZgIGluIHRoZVxuICAgIC8vICAgIHNhbWUgdHVybi4gVGhpcyB3YXMgbW9yZSBjb21tb24gaW4gMS54IHdoZXJlIGEgY29tcG91bmQgY29tcHV0ZWRcbiAgICAvLyAgICBwcm9wZXJ0eSBjb3VsZCByZXN1bHQgaW4gdGhlIHJlc3VsdCBjaGFuZ2luZyBtdWx0aXBsZSB0aW1lcywgYnV0IGlzXG4gICAgLy8gICAgbWl0aWdhdGVkIHRvIGEgbGFyZ2UgZXh0ZW50IGJ5IGJhdGNoZWQgcHJvcGVydHkgcHJvY2Vzc2luZyBpbiAyLnguXG4gICAgLy8gMi4gVG8gYXZvaWQgZG91YmxlIG9iamVjdCBwcm9wYWdhdGlvbiB3aGVuIGEgYmFnIGluY2x1ZGluZyB2YWx1ZXMgYm91bmRcbiAgICAvLyAgICB0byB0aGUgYGlmYCBwcm9wZXJ0eSBhcyB3ZWxsIGFzIG9uZSBvciBtb3JlIGhvc3RQcm9wcyBjb3VsZCBlbnF1ZXVlXG4gICAgLy8gICAgdGhlIDxkb20taWY+IHRvIGZsdXNoIGJlZm9yZSB0aGUgPHRlbXBsYXRlPidzIGhvc3QgcHJvcGVydHlcbiAgICAvLyAgICBmb3J3YXJkaW5nLiBJbiB0aGF0IHNjZW5hcmlvIGNyZWF0aW5nIGFuIGluc3RhbmNlIHdvdWxkIHJlc3VsdCBpblxuICAgIC8vICAgIHRoZSBob3N0IHByb3BzIGJlaW5nIHNldCBvbmNlLCBhbmQgdGhlbiB0aGUgZW5xdWV1ZWQgY2hhbmdlcyBvbiB0aGVcbiAgICAvLyAgICB0ZW1wbGF0ZSB3b3VsZCBzZXQgcHJvcGVydGllcyBhIHNlY29uZCB0aW1lLCBwb3RlbnRpYWxseSBjYXVzaW5nIGFuXG4gICAgLy8gICAgb2JqZWN0IHRvIGJlIHNldCB0byBhbiBpbnN0YW5jZSBtb3JlIHRoYW4gb25jZS4gIENyZWF0aW5nIHRoZVxuICAgIC8vICAgIGluc3RhbmNlIGFzeW5jIGZyb20gZmx1c2hpbmcgZGF0YSBlbnN1cmVzIHRoaXMgZG9lc24ndCBoYXBwZW4uIElmXG4gICAgLy8gICAgd2Ugd2FudGVkIGEgc3luYyBvcHRpb24gaW4gdGhlIGZ1dHVyZSwgc2ltcGx5IGhhdmluZyA8ZG9tLWlmPiBmbHVzaFxuICAgIC8vICAgIChvciBjbGVhcikgaXRzIHRlbXBsYXRlJ3MgcGVuZGluZyBob3N0IHByb3BlcnRpZXMgYmVmb3JlIGNyZWF0aW5nXG4gICAgLy8gICAgdGhlIGluc3RhbmNlIHdvdWxkIGFsc28gYXZvaWQgdGhlIHByb2JsZW0uXG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICwgbWljcm9UYXNrXG4gICAgICAgICwgKCkgPT4gdGhpcy5fX3JlbmRlcigpKTtcbiAgICBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBpZiAoIXRoaXMucGFyZW50Tm9kZSB8fFxuICAgICAgICAodGhpcy5wYXJlbnROb2RlLm5vZGVUeXBlID09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJlxuICAgICAgICAgIXRoaXMucGFyZW50Tm9kZS5ob3N0KSkge1xuICAgICAgdGhpcy5fX3RlYXJkb3duSW5zdGFuY2UoKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBmbHVzaCgpO1xuICB9XG5cbiAgX19yZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgIGlmICghdGhpcy5fX2Vuc3VyZUluc3RhbmNlKCkpIHtcbiAgICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVzdGFtcCkge1xuICAgICAgdGhpcy5fX3RlYXJkb3duSW5zdGFuY2UoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlc3RhbXAgJiYgdGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlmICE9IHRoaXMuX2xhc3RJZikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuX2xhc3RJZiA9IHRoaXMuaWY7XG4gICAgfVxuICB9XG5cbiAgX19lbnN1cmVJbnN0YW5jZSgpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAvLyBHdWFyZCBhZ2FpbnN0IGVsZW1lbnQgYmVpbmcgZGV0YWNoZWQgd2hpbGUgcmVuZGVyIHdhcyBxdWV1ZWRcbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCF0aGlzLl9fY3Rvcikge1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1pZiByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N0b3IgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICAvLyBkb20taWYgdGVtcGxhdGl6ZXIgaW5zdGFuY2VzIHJlcXVpcmUgYG11dGFibGU6IHRydWVgLCBhc1xuICAgICAgICAgIC8vIGBfX3N5bmNIb3N0UHJvcGVydGllc2AgcmVsaWVzIG9uIHRoYXQgYmVoYXZpb3IgdG8gc3luYyBvYmplY3RzXG4gICAgICAgICAgbXV0YWJsZURhdGE6IHRydWUsXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gZm9yd2FyZFxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgcHJvcGVydHlcbiAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmb3J3YXJkSG9zdFByb3A6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2luc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBpbnN0YW5jZSBidXQgYXJlIHNxdWVsY2hpbmcgaG9zdCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIGZvcndhcmRpbmcgZHVlIHRvIGlmIGJlaW5nIGZhbHNlLCBub3RlIHRoZSBpbnZhbGlkYXRlZFxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgc28gYF9fc3luY0hvc3RQcm9wZXJ0aWVzYCBjYW4gc3luYyB0aGVtIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gdGltZSBgaWZgIGJlY29tZXMgdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wc1tyb290JDAocHJvcCldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UgPSBuZXcgdGhpcy5fX2N0b3IoKTtcbiAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fX2luc3RhbmNlLnJvb3QsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX3N5bmNIb3N0UHJvcGVydGllcygpO1xuICAgICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICAgIGlmIChjJCAmJiBjJC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEZXRlY3QgY2FzZSB3aGVyZSBkb20taWYgd2FzIHJlLWF0dGFjaGVkIGluIG5ldyBwb3NpdGlvblxuICAgICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBpZiAobGFzdENoaWxkICE9PSBjJFtjJC5sZW5ndGgtMV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfX3N5bmNIb3N0UHJvcGVydGllcygpIHtcbiAgICBsZXQgcHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB0aGlzLl9fZGF0YUhvc3RbcHJvcF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgICB0aGlzLl9faW5zdGFuY2UuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxuXG4gIF9fdGVhcmRvd25JbnN0YW5jZSgpIHtcbiAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgIC8vIHVzZSBmaXJzdCBjaGlsZCBwYXJlbnQsIGZvciBjYXNlIHdoZW4gZG9tLWlmIG1heSBoYXZlIGJlZW4gZGV0YWNoZWRcbiAgICAgICAgbGV0IHBhcmVudCA9IGMkWzBdLnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93SGlkZUNoaWxkcmVuKCkge1xuICAgIGxldCBoaWRkZW4gPSB0aGlzLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyB8fCAhdGhpcy5pZjtcbiAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICB0aGlzLl9faW5zdGFuY2UuX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKTtcbiAgICB9XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tSWYuaXMsIERvbUlmKTtcblxuZXhwb3J0IHsgRG9tSWYgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWlmLmpzIiwiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uLy4uL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlU3BsaWNlcyB9IGZyb20gJy4uL3V0aWxzL2FycmF5LXNwbGljZS5qcyc7XG5pbXBvcnQgeyBFbGVtZW50TWl4aW4gfSBmcm9tICcuLi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyc7XG5cbi8qKlxuICogRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5IHN1Y2ggdGhhdCBwYXRoIGNoYW5nZXMgdG8gdGhlXG4gKiBtYXN0ZXIgYXJyYXkgKGF0IHRoZSBob3N0KSBlbGVtZW50IG9yIGVsc2V3aGVyZSB2aWEgZGF0YS1iaW5kaW5nKSBhcmVcbiAqIGNvcnJlY3RseSBwcm9wYWdhdGVkIHRvIGl0ZW1zIGluIHRoZSBzZWxlY3RlZCBhcnJheSBhbmQgdmljZS12ZXJzYS5cbiAqXG4gKiBUaGUgYGl0ZW1zYCBwcm9wZXJ0eSBhY2NlcHRzIGFuIGFycmF5IG9mIHVzZXIgZGF0YSwgYW5kIHZpYSB0aGVcbiAqIGBzZWxlY3QoaXRlbSlgIGFuZCBgZGVzZWxlY3QoaXRlbSlgIEFQSSwgdXBkYXRlcyB0aGUgYHNlbGVjdGVkYCBwcm9wZXJ0eVxuICogd2hpY2ggbWF5IGJlIGJvdW5kIHRvIG90aGVyIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiwgYW5kIGFueSBjaGFuZ2VzIHRvXG4gKiBzdWItZmllbGRzIG9mIGBzZWxlY3RlZGAgaXRlbShzKSB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIGl0ZW1zIGluIHRoZVxuICogYGl0ZW1zYCBhcnJheS4gIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgYHNlbGVjdGVkYCBpcyBhIHByb3BlcnR5XG4gKiByZXByZXNlbnRpbmcgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbS4gIFdoZW4gYG11bHRpYCBpcyB0cnVlLCBgc2VsZWN0ZWRgXG4gKiBpcyBhbiBhcnJheSBvZiBtdWx0aXBseSBzZWxlY3RlZCBpdGVtcy5cbiAqXG4gKiBAcG9seW1lclxuICogQG1peGluRnVuY3Rpb25cbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBFbGVtZW50IG1peGluIGZvciByZWNvcmRpbmcgZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGFcbiAqIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhIGBzZWxlY3RlZGAgYXJyYXlcbiAqL1xubGV0IEFycmF5U2VsZWN0b3JNaXhpbiA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7c3VwZXJDbGFzc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKi9cbiAgbGV0IGVsZW1lbnRCYXNlID0gRWxlbWVudE1peGluKHN1cGVyQ2xhc3MpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9BcnJheVNlbGVjdG9yTWl4aW59XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNsYXNzIEFycmF5U2VsZWN0b3JNaXhpbiBleHRlbmRzIGVsZW1lbnRCYXNlIHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgICAgcmV0dXJuIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBpdGVtcyBmcm9tIHdoaWNoIHNlbGVjdGlvbiB3aWxsIGJlIG1hZGUuXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGB0cnVlYCwgbXVsdGlwbGUgaXRlbXMgbWF5IGJlIHNlbGVjdGVkIGF0IG9uY2UgKGluIHRoaXMgY2FzZSxcbiAgICAgICAgICogYHNlbGVjdGVkYCBpcyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMpLiAgV2hlbiBgZmFsc2VgLFxuICAgICAgICAgKiBvbmx5IG9uZSBpdGVtIG1heSBiZSBzZWxlY3RlZCBhdCBhIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgdGhpcyBpcyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGFueSBzZWxlY3RlZC5cbiAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAqIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEB0eXBlIHs/KE9iamVjdHxBcnJheTwhT2JqZWN0Pil9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAqIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRJdGVtOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGB0cnVlYCwgY2FsbGluZyBgc2VsZWN0YCBvbiBhbiBpdGVtIHRoYXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgKiB3aWxsIGRlc2VsZWN0IHRoZSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9nZ2xlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgcmV0dXJuIFsnX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zLiopJ107XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fX2xhc3RJdGVtcyA9IG51bGw7XG4gICAgICB0aGlzLl9fbGFzdE11bHRpID0gbnVsbDtcbiAgICAgIHRoaXMuX19zZWxlY3RlZE1hcCA9IG51bGw7XG4gICAgfVxuXG4gICAgX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zSW5mbykge1xuICAgICAgbGV0IHBhdGggPSBpdGVtc0luZm8ucGF0aDtcbiAgICAgIGlmIChwYXRoID09ICdpdGVtcycpIHtcbiAgICAgICAgLy8gQ2FzZSAxIC0gaXRlbXMgYXJyYXkgY2hhbmdlZCwgc28gZGlmZiBhZ2FpbnN0IHByZXZpb3VzIGFycmF5IGFuZFxuICAgICAgICAvLyBkZXNlbGVjdCBhbnkgcmVtb3ZlZCBpdGVtcyBhbmQgYWRqdXN0IHNlbGVjdGVkIGluZGljZXNcbiAgICAgICAgbGV0IG5ld0l0ZW1zID0gaXRlbXNJbmZvLmJhc2UgfHwgW107XG4gICAgICAgIGxldCBsYXN0SXRlbXMgPSB0aGlzLl9fbGFzdEl0ZW1zO1xuICAgICAgICBsZXQgbGFzdE11bHRpID0gdGhpcy5fX2xhc3RNdWx0aTtcbiAgICAgICAgaWYgKG11bHRpICE9PSBsYXN0TXVsdGkpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RJdGVtcykge1xuICAgICAgICAgIGxldCBzcGxpY2VzID0gY2FsY3VsYXRlU3BsaWNlcyhuZXdJdGVtcywgbGFzdEl0ZW1zKTtcbiAgICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKHNwbGljZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBuZXdJdGVtcztcbiAgICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG11bHRpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc0luZm8ucGF0aCA9PSAnaXRlbXMuc3BsaWNlcycpIHtcbiAgICAgICAgLy8gQ2FzZSAyIC0gZ290IHNwZWNpZmljIHNwbGljZSBpbmZvcm1hdGlvbiBkZXNjcmliaW5nIHRoZSBhcnJheSBtdXRhdGlvbjpcbiAgICAgICAgLy8gZGVzZWxlY3QgYW55IHJlbW92ZWQgaXRlbXMgYW5kIGFkanVzdCBzZWxlY3RlZCBpbmRpY2VzXG4gICAgICAgIHRoaXMuX19hcHBseVNwbGljZXMoaXRlbXNJbmZvLnZhbHVlLmluZGV4U3BsaWNlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYXNlIDMgLSBhbiBhcnJheSBlbGVtZW50IHdhcyBjaGFuZ2VkLCBzbyBkZXNlbGVjdCB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gaXRlbSBmb3IgdGhhdCBpbmRleCBpZiBpdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZFxuICAgICAgICBsZXQgcGFydCA9IHBhdGguc2xpY2UoJ2l0ZW1zLicubGVuZ3RoKTtcbiAgICAgICAgbGV0IGlkeCA9IHBhcnNlSW50KHBhcnQsIDEwKTtcbiAgICAgICAgaWYgKChwYXJ0LmluZGV4T2YoJy4nKSA8IDApICYmIHBhcnQgPT0gaWR4KSB7XG4gICAgICAgICAgdGhpcy5fX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19hcHBseVNwbGljZXMoc3BsaWNlcykge1xuICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX3NlbGVjdGVkTWFwO1xuICAgICAgLy8gQWRqdXN0IHNlbGVjdGVkIGluZGljZXMgYW5kIG1hcmsgcmVtb3ZhbHNcbiAgICAgIGZvciAobGV0IGk9MDsgaTxzcGxpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzID0gc3BsaWNlc1tpXTtcbiAgICAgICAgc2VsZWN0ZWQuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGlkeCA8IHMuaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaWR4ID49IHMuaW5kZXggKyBzLnJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhZGp1c3QgaW5kZXhcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldChpdGVtLCBpZHggKyBzLmFkZGVkQ291bnQgLSBzLnJlbW92ZWQubGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGluZGV4XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajxzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICAgIGxldCBpZHggPSBzLmluZGV4ICsgajtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQuaGFzKHRoaXMuaXRlbXNbaWR4XSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldCh0aGlzLml0ZW1zW2lkeF0sIGlkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgbGlua2VkIHBhdGhzXG4gICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoZSBpdGVtcyBhcnJheVxuICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgc2VsZWN0ZWQuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxlY3RlZC5kZWxldGUoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2lkeCsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfX3VwZGF0ZUxpbmtzKCkge1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHt9O1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ2l0ZW1zLicgKyBpZHgsICdzZWxlY3RlZC4nICsgc2lkeCsrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICB0aGlzLmxpbmtQYXRocygnc2VsZWN0ZWQnLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkSXRlbScsICdpdGVtcy4nICsgaWR4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgIC8vIFVuYmluZCBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgIC8vIFRoZSBzZWxlY3RlZCBtYXAgc3RvcmVzIDMgcGllY2VzIG9mIGluZm9ybWF0aW9uOlxuICAgICAgLy8ga2V5OiBpdGVtcyBhcnJheSBvYmplY3RcbiAgICAgIC8vIHZhbHVlOiBpdGVtcyBhcnJheSBpbmRleFxuICAgICAgLy8gb3JkZXI6IHNlbGVjdGVkIGFycmF5IGluZGV4XG4gICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvblxuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMubXVsdGkgPyBbXSA6IG51bGw7XG4gICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZWxlY3RlZE1hcC5oYXMoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNJbmRleFNlbGVjdGVkKGlkeCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZCh0aGlzLml0ZW1zW2lkeF0pO1xuICAgIH1cblxuICAgIF9fZGVzZWxlY3RDaGFuZ2VkSWR4KGlkeCkge1xuICAgICAgbGV0IHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgaWYgKHNpZHggPj0gMCkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoc2lkeCA9PSBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QoaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KSB7XG4gICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzWydpdGVtcy4nICsgaWR4XTtcbiAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2VsZWN0ZWQuc2xpY2UoJ3NlbGVjdGVkLicubGVuZ3RoKSwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbSBpZiBpdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIGRlc2VsZWN0XG4gICAgICovXG4gICAgZGVzZWxlY3QoaXRlbSkge1xuICAgICAgbGV0IGlkeCA9IHRoaXMuX19zZWxlY3RlZE1hcC5nZXQoaXRlbSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgbGV0IHNpZHg7XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgc2lkeCA9IHRoaXMuX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkJywgc2lkeCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXggaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIGRlc2VsZWN0XG4gICAgICovXG4gICAgZGVzZWxlY3RJbmRleChpZHgpIHtcbiAgICAgIHRoaXMuZGVzZWxlY3QodGhpcy5pdGVtc1tpZHhdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBpdGVtLiAgV2hlbiBgdG9nZ2xlYCBpcyB0cnVlLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAqIGRlc2VsZWN0IHRoZSBpdGVtIGlmIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gc2VsZWN0XG4gICAgICovXG4gICAgc2VsZWN0KGl0ZW0pIHtcbiAgICAgIHRoaXMuc2VsZWN0SW5kZXgodGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBpbmRleC4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gc2VsZWN0XG4gICAgICovXG4gICAgc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgIGlmICghdGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5zZXQoaXRlbSwgaWR4KTtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKCdzZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2dnbGUpIHtcbiAgICAgICAgdGhpcy5kZXNlbGVjdEluZGV4KGlkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQXJyYXlTZWxlY3Rvck1peGluO1xuXG59KTtcblxuZXhwb3J0IHsgQXJyYXlTZWxlY3Rvck1peGluIH07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7UG9seW1lci5FbGVtZW50fVxuICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICovXG5sZXQgYmFzZUFycmF5U2VsZWN0b3IgPSBBcnJheVNlbGVjdG9yTWl4aW4oRWxlbWVudCk7XG5cbi8qKlxuICogRWxlbWVudCBpbXBsZW1lbnRpbmcgdGhlIGBQb2x5bWVyLkFycmF5U2VsZWN0b3JgIG1peGluLCB3aGljaCByZWNvcmRzXG4gKiBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYSBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYVxuICogYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZSBtYXN0ZXIgYXJyYXkgKGF0IHRoZSBob3N0KVxuICogZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlIGNvcnJlY3RseSBwcm9wYWdhdGVkIHRvIGl0ZW1zXG4gKiBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gKlxuICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZG9tLW1vZHVsZSBpZD1cImVtcGxveWVlLWxpc3RcIj5cbiAqXG4gKiAgIDx0ZW1wbGF0ZT5cbiAqXG4gKiAgICAgPGRpdj4gRW1wbG95ZWUgbGlzdDogPC9kaXY+XG4gKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGlkPVwiZW1wbG95ZWVMaXN0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICogICAgICAgICA8YnV0dG9uIG9uLWNsaWNrPVwidG9nZ2xlU2VsZWN0aW9uXCI+U2VsZWN0PC9idXR0b24+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgICAgPGFycmF5LXNlbGVjdG9yIGlkPVwic2VsZWN0b3JcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIiBzZWxlY3RlZD1cInt7c2VsZWN0ZWR9fVwiIG11bHRpIHRvZ2dsZT48L2FycmF5LXNlbGVjdG9yPlxuICpcbiAqICAgICA8ZGl2PiBTZWxlY3RlZCBlbXBsb3llZXM6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7c2VsZWN0ZWR9fVwiPlxuICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICA8L3RlbXBsYXRlPlxuICpcbiAqICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiA8L2RvbS1tb2R1bGU+XG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogUG9seW1lcih7XG4gKiAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gKiAgIHJlYWR5KCkge1xuICogICAgIHRoaXMuZW1wbG95ZWVzID0gW1xuICogICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAqICAgICAgICAge2ZpcnN0OiAnU2FsbHknLCBsYXN0OiAnSm9obnNvbid9LFxuICogICAgICAgICAuLi5cbiAqICAgICBdO1xuICogICB9LFxuICogICB0b2dnbGVTZWxlY3Rpb24oZSkge1xuICogICAgIGxldCBpdGVtID0gdGhpcy4kLmVtcGxveWVlTGlzdC5pdGVtRm9yRWxlbWVudChlLnRhcmdldCk7XG4gKiAgICAgdGhpcy4kLnNlbGVjdG9yLnNlbGVjdChpdGVtKTtcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcG9seW1lclxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIHtiYXNlQXJyYXlTZWxlY3Rvcn1cbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5BcnJheVNlbGVjdG9yTWl4aW5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IGxpbmtzIHBhdGhzIGJldHdlZW4gYW4gaW5wdXQgYGl0ZW1zYCBhcnJheSBhbmRcbiAqICAgYW4gb3V0cHV0IGBzZWxlY3RlZGAgaXRlbSBvciBhcnJheSBiYXNlZCBvbiBjYWxscyB0byBpdHMgc2VsZWN0aW9uIEFQSS5cbiAqL1xuY2xhc3MgQXJyYXlTZWxlY3RvciBleHRlbmRzIGJhc2VBcnJheVNlbGVjdG9yIHtcbiAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2FycmF5LXNlbGVjdG9yJzsgfVxufVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKEFycmF5U2VsZWN0b3IuaXMsIEFycmF5U2VsZWN0b3IpO1xuZXhwb3J0IHsgQXJyYXlTZWxlY3RvciB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9hcnJheS1zZWxlY3Rvci5qcyIsImltcG9ydCAnLi4vLi4vLi4vLi4vQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyc7XG5pbXBvcnQgeyBjc3NGcm9tTW9kdWxlcyB9IGZyb20gJy4uL3V0aWxzL3N0eWxlLWdhdGhlci5qcyc7XG5cbmNvbnN0IGF0dHIgPSAnaW5jbHVkZSc7XG5cbmNvbnN0IEN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG4vKipcbiAqIEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW4gdGFrZVxuICogYWR2YW50YWdlIG9mIFtzaGFkeSBET01dKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5Y3NzKSBzaGltc1xuICogZm9yIHN0eWxlIGVuY2Fwc3VsYXRpb24sIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgY3VzdG9tIG1peGlucy5cbiAqXG4gKiAtIERvY3VtZW50IHN0eWxlcyBkZWZpbmVkIGluIGEgYDxjdXN0b20tc3R5bGU+YCBhcmUgc2hpbW1lZCB0byBlbnN1cmUgdGhleVxuICogICBkbyBub3QgbGVhayBpbnRvIGxvY2FsIERPTSB3aGVuIHJ1bm5pbmcgb24gYnJvd3NlcnMgd2l0aG91dCBuYXRpdmVcbiAqICAgU2hhZG93IERPTS5cbiAqIC0gQ3VzdG9tIHByb3BlcnRpZXMgY2FuIGJlIGRlZmluZWQgaW4gYSBgPGN1c3RvbS1zdHlsZT5gLiBVc2UgdGhlIGBodG1sYCBzZWxlY3RvclxuICogICB0byBkZWZpbmUgY3VzdG9tIHByb3BlcnRpZXMgdGhhdCBhcHBseSB0byBhbGwgY3VzdG9tIGVsZW1lbnRzLlxuICogLSBDdXN0b20gbWl4aW5zIGNhbiBiZSBkZWZpbmVkIGluIGEgYDxjdXN0b20tc3R5bGU+YCwgaWYgeW91IGltcG9ydCB0aGUgb3B0aW9uYWxcbiAqICAgW2FwcGx5IHNoaW1dKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5Y3NzI2Fib3V0LWFwcGx5c2hpbSlcbiAqICAgKGBzaGFkeWNzcy9hcHBseS1zaGltLmh0bWxgKS5cbiAqXG4gKiBUbyB1c2U6XG4gKlxuICogLSBJbXBvcnQgYGN1c3RvbS1zdHlsZS5odG1sYC5cbiAqIC0gUGxhY2UgYSBgPGN1c3RvbS1zdHlsZT5gIGVsZW1lbnQgaW4gdGhlIG1haW4gZG9jdW1lbnQsIHdyYXBwaW5nIGFuIGlubGluZSBgPHN0eWxlPmAgdGFnIHRoYXRcbiAqICAgY29udGFpbnMgdGhlIENTUyBydWxlcyB5b3Ugd2FudCB0byBzaGltLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYFxuICogPCEtLSBpbXBvcnQgYXBwbHkgc2hpbS0tb25seSByZXF1aXJlZCBpZiB1c2luZyBtaXhpbnMgLS0+XG4gKiA8bGluayByZWw9XCJpbXBvcnQgaHJlZj1cImJvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sXCI+XG4gKiA8IS0tIGltcG9ydCBjdXN0b20tc3R5bGUgZWxlbWVudCAtLT5cbiAqIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5odG1sXCI+XG4gKiAuLi5cbiAqIDxjdXN0b20tc3R5bGU+XG4gKiAgIDxzdHlsZT5cbiAqICAgICBodG1sIHtcbiAqICAgICAgIC0tY3VzdG9tLWNvbG9yOiBibHVlO1xuICogICAgICAgLS1jdXN0b20tbWl4aW46IHtcbiAqICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gKiAgICAgICAgIGNvbG9yOiByZWQ7XG4gKiAgICAgICB9O1xuICogICAgIH1cbiAqICAgPC9zdHlsZT5cbiAqIDwvY3VzdG9tLXN0eWxlPlxuICogYGBgXG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgZm9yIGRlZmluaW5nIHN0eWxlcyBpbiB0aGUgbWFpbiBkb2N1bWVudCB0aGF0IGNhblxuICogICB0YWtlIGFkdmFudGFnZSBvZiBQb2x5bWVyJ3Mgc3R5bGUgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnRpZXMgc2hpbXMuXG4gKi9cbmNsYXNzIEN1c3RvbVN0eWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICBDdXN0b21TdHlsZUludGVyZmFjZS5hZGRDdXN0b21TdHlsZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlnaHQtRE9NIGA8c3R5bGU+YCBjaGlsZCB0aGlzIGVsZW1lbnQgd3JhcHMuICBVcG9uIGZpcnN0XG4gICAqIGNhbGwgYW55IHN0eWxlIG1vZHVsZXMgcmVmZXJlbmNlZCB2aWEgdGhlIGBpbmNsdWRlYCBhdHRyaWJ1dGUgd2lsbCBiZVxuICAgKiBjb25jYXRlbmF0ZWQgdG8gdGhpcyBlbGVtZW50J3MgYDxzdHlsZT5gLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fSBUaGlzIGVsZW1lbnQncyBsaWdodC1ET00gYDxzdHlsZT5gXG4gICAqL1xuICBnZXRTdHlsZSgpIHtcbiAgICBpZiAodGhpcy5fc3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3Rvcignc3R5bGUnKSk7XG4gICAgaWYgKCFzdHlsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XG4gICAgY29uc3QgaW5jbHVkZSA9IHN0eWxlLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NGcm9tTW9kdWxlcyhpbmNsdWRlKSArIHN0eWxlLnRleHRDb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gIH1cbn1cblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY3VzdG9tLXN0eWxlJywgQ3VzdG9tU3R5bGUpO1xuZXhwb3J0IHsgQ3VzdG9tU3R5bGUgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmpzIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ3VzdG9tU3R5bGVJbnRlcmZhY2UgZnJvbSAnLi4vc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMnO1xuaW1wb3J0IHtnZXRDb21wdXRlZFN0eWxlVmFsdWUsIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXN9IGZyb20gJy4uL3NyYy9jb21tb24tdXRpbHMuanMnO1xuaW1wb3J0IHtuYXRpdmVDc3NWYXJpYWJsZXMsIG5hdGl2ZVNoYWRvd30gZnJvbSAnLi4vc3JjL3N0eWxlLXNldHRpbmdzLmpzJztcblxuY29uc3QgY3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBuZXcgQ3VzdG9tU3R5bGVJbnRlcmZhY2UoKTtcblxuaWYgKCF3aW5kb3cuU2hhZHlDU1MpIHtcbiAgd2luZG93LlNoYWR5Q1NTID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVsZW1lbnRFeHRlbmRzXG4gICAgICovXG4gICAgcHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSwgZWxlbWVudEV4dGVuZHMpIHt9LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgY3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvY2Vzc1N0eWxlcygpO1xuICAgICAgdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgc3R5bGVFbGVtZW50KGVsZW1lbnQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgY3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvY2Vzc1N0eWxlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZURvY3VtZW50KHByb3BlcnRpZXMpIHtcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICAgIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZG9jdW1lbnQuYm9keSwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpO1xuICAgIH0sXG4gICAgbmF0aXZlQ3NzOiBuYXRpdmVDc3NWYXJpYWJsZXMsXG4gICAgbmF0aXZlU2hhZG93OiBuYXRpdmVTaGFkb3dcbiAgfVxufVxuXG53aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBjdXN0b21TdHlsZUludGVyZmFjZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJpbXBvcnQgeyBNdXRhYmxlRGF0YSB9IGZyb20gJy4uL21peGlucy9tdXRhYmxlLWRhdGEuanMnO1xuXG5sZXQgbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuKFxuICAvKiogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gKi9cbiAgKGZ1bmN0aW9uKCkge1xuICBtdXRhYmxlUHJvcGVydHlDaGFuZ2UgPSBNdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xufSkpKCk7XG5cbmV4cG9ydCBjb25zdCBNdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRydWUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZS1sZXZlbCBmbGFnIGZvciBjb25maWd1cmluZyB0aGUgZGlydHktY2hlY2tpbmcgc3RyYXRlZ3lcbiAgICAgKiBmb3IgdGhpcyBlbGVtZW50LiAgV2hlbiB0cnVlLCBPYmplY3RzIGFuZCBBcnJheXMgd2lsbCBza2lwIGRpcnR5XG4gICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIG11dGFibGVEYXRhOiBCb29sZWFuXG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHNraXAgc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nXG4gICAqIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAqXG4gICAqIFB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgKiAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAqIEB0aGlzIHt0aGlzfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0aGlzLm11dGFibGVEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L211dGFibGUtZGF0YS1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcblxuICAgICAgLS1sYXlvdXQ6IHtcbiAgICAgICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWlubGluZToge1xuICAgICAgICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtaW5saW5lLWZsZXg7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaG9yaXpvbnRhbDoge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWhvcml6b250YWwtcmV2ZXJzZToge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXZlcnRpY2FsOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtdmVydGljYWwtcmV2ZXJzZToge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXdyYXA6IHtcbiAgICAgICAgLW1zLWZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgLXdlYmtpdC1mbGV4LXdyYXA6IHdyYXA7XG4gICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXdyYXAtcmV2ZXJzZToge1xuICAgICAgICAtbXMtZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XG4gICAgICAgIC13ZWJraXQtZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XG4gICAgICAgIGZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC1hdXRvOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxIDEgYXV0bztcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxIDEgYXV0bztcbiAgICAgICAgZmxleDogMSAxIGF1dG87XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LW5vbmU6IHtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtZmxleDogbm9uZTtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXg6IHtcbiAgICAgICAgLW1zLWZsZXg6IDEgMSAwLjAwMDAwMDAwMXB4O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIC13ZWJraXQtZmxleC1iYXNpczogMC4wMDAwMDAwMDFweDtcbiAgICAgICAgZmxleC1iYXNpczogMC4wMDAwMDAwMDFweDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMjoge1xuICAgICAgICAtbXMtZmxleDogMjtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAyO1xuICAgICAgICBmbGV4OiAyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0zOiB7XG4gICAgICAgIC1tcy1mbGV4OiAzO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDM7XG4gICAgICAgIGZsZXg6IDM7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTQ6IHtcbiAgICAgICAgLW1zLWZsZXg6IDQ7XG4gICAgICAgIC13ZWJraXQtZmxleDogNDtcbiAgICAgICAgZmxleDogNDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNToge1xuICAgICAgICAtbXMtZmxleDogNTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA1O1xuICAgICAgICBmbGV4OiA1O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC02OiB7XG4gICAgICAgIC1tcy1mbGV4OiA2O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDY7XG4gICAgICAgIGZsZXg6IDY7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTc6IHtcbiAgICAgICAgLW1zLWZsZXg6IDc7XG4gICAgICAgIC13ZWJraXQtZmxleDogNztcbiAgICAgICAgZmxleDogNztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtODoge1xuICAgICAgICAtbXMtZmxleDogODtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA4O1xuICAgICAgICBmbGV4OiA4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC05OiB7XG4gICAgICAgIC1tcy1mbGV4OiA5O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDk7XG4gICAgICAgIGZsZXg6IDk7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTEwOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxMDtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxMDtcbiAgICAgICAgZmxleDogMTA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTExOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxMTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxMTtcbiAgICAgICAgZmxleDogMTE7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTEyOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxMjtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxMjtcbiAgICAgICAgZmxleDogMTI7XG4gICAgICB9O1xuXG4gICAgICAvKiBhbGlnbm1lbnQgaW4gY3Jvc3MgYXhpcyAqL1xuXG4gICAgICAtLWxheW91dC1zdGFydDoge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyOiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWVuZDoge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogZW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYmFzZWxpbmU6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGJhc2VsaW5lO1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBiYXNlbGluZTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xuICAgICAgfTtcblxuICAgICAgLyogYWxpZ25tZW50IGluIG1haW4gYXhpcyAqL1xuXG4gICAgICAtLWxheW91dC1zdGFydC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXItanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1lbmQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGVuZDtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYXJvdW5kLWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBkaXN0cmlidXRlO1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBqdXN0aWZ5O1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyLWNlbnRlcjoge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDtcbiAgICAgIH07XG5cbiAgICAgIC8qIHNlbGYgYWxpZ25tZW50ICovXG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtc3RhcnQ6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICAgICAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtY2VudGVyOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogY2VudGVyO1xuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLWVuZDoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1zdHJldGNoOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLWJhc2VsaW5lOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBiYXNlbGluZTtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBiYXNlbGluZTtcbiAgICAgICAgYWxpZ24tc2VsZjogYmFzZWxpbmU7XG4gICAgICB9O1xuXG4gICAgICAvKiBtdWx0aS1saW5lIGFsaWdubWVudCBpbiBtYWluIGF4aXMgKi9cblxuICAgICAgLS1sYXlvdXQtc3RhcnQtYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IHN0YXJ0OyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBhbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZW5kLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBlbmQ7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgICAgYWxpZ24tY29udGVudDogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXItYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGNlbnRlcjsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWJldHdlZW4tYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGp1c3RpZnk7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1hcm91bmQtYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGRpc3RyaWJ1dGU7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICB9O1xuXG4gICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICAgIE90aGVyIExheW91dFxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgLS1sYXlvdXQtYmxvY2s6IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1pbnZpc2libGU6IHtcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1yZWxhdGl2ZToge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXQ6IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zY3JvbGw6IHtcbiAgICAgICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZ1bGxibGVlZDoge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICB9O1xuXG4gICAgICAvKiBmaXhlZCBwb3NpdGlvbiAqL1xuXG4gICAgICAtLWxheW91dC1maXhlZC10b3A6IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml4ZWQtcmlnaHQ6IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXhlZC1ib3R0b206IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml4ZWQtbGVmdDoge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfTtcblxuICAgIH1cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi9jb2xvci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGN1c3RvbS1zdHlsZT5cbiAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgaHRtbCB7XG4gICAgICAvKlxuICAgICAgICogWW91IGNhbiB1c2UgdGhlc2UgZ2VuZXJpYyB2YXJpYWJsZXMgaW4geW91ciBlbGVtZW50cyBmb3IgZWFzeSB0aGVtaW5nLlxuICAgICAgICogRm9yIGV4YW1wbGUsIGlmIGFsbCB5b3VyIGVsZW1lbnRzIHVzZSBcXGAtLXByaW1hcnktdGV4dC1jb2xvclxcYCBhcyBpdHMgbWFpblxuICAgICAgICogY29sb3IsIHRoZW4gc3dpdGNoaW5nIGZyb20gYSBsaWdodCB0byBhIGRhcmsgdGhlbWUgaXMganVzdCBhIG1hdHRlciBvZlxuICAgICAgICogY2hhbmdpbmcgdGhlIHZhbHVlIG9mIFxcYC0tcHJpbWFyeS10ZXh0LWNvbG9yXFxgIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgKi9cbiAgICAgIC0tcHJpbWFyeS10ZXh0LWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS10ZXh0LWNvbG9yKTtcbiAgICAgIC0tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgICAgIC0tc2Vjb25kYXJ5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcik7XG4gICAgICAtLWRpc2FibGVkLXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yKTtcbiAgICAgIC0tZGl2aWRlci1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcik7XG4gICAgICAtLWVycm9yLWNvbG9yOiB2YXIoLS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwKTtcblxuICAgICAgLypcbiAgICAgICAqIFByaW1hcnkgYW5kIGFjY2VudCBjb2xvcnMuIEFsc28gc2VlIGNvbG9yLmh0bWwgZm9yIG1vcmUgY29sb3JzLlxuICAgICAgICovXG4gICAgICAtLXByaW1hcnktY29sb3I6IHZhcigtLXBhcGVyLWluZGlnby01MDApO1xuICAgICAgLS1saWdodC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wYXBlci1pbmRpZ28tMTAwKTtcbiAgICAgIC0tZGFyay1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wYXBlci1pbmRpZ28tNzAwKTtcblxuICAgICAgLS1hY2NlbnQtY29sb3I6IHZhcigtLXBhcGVyLXBpbmstYTIwMCk7XG4gICAgICAtLWxpZ2h0LWFjY2VudC1jb2xvcjogdmFyKC0tcGFwZXItcGluay1hMTAwKTtcbiAgICAgIC0tZGFyay1hY2NlbnQtY29sb3I6IHZhcigtLXBhcGVyLXBpbmstYTQwMCk7XG5cblxuICAgICAgLypcbiAgICAgICAqIE1hdGVyaWFsIERlc2lnbiBMaWdodCBiYWNrZ3JvdW5kIHRoZW1lXG4gICAgICAgKi9cbiAgICAgIC0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcbiAgICAgIC0tbGlnaHQtdGhlbWUtYmFzZS1jb2xvcjogIzAwMDAwMDtcbiAgICAgIC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcjogdmFyKC0tcGFwZXItZ3JleS05MDApO1xuICAgICAgLS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3I6ICM3MzczNzM7ICAvKiBmb3Igc2Vjb25kYXJ5IHRleHQgYW5kIGljb25zICovXG4gICAgICAtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yOiAjOWI5YjliOyAgLyogZGlzYWJsZWQvaGludCB0ZXh0ICovXG4gICAgICAtLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3I6ICNkYmRiZGI7XG5cbiAgICAgIC8qXG4gICAgICAgKiBNYXRlcmlhbCBEZXNpZ24gRGFyayBiYWNrZ3JvdW5kIHRoZW1lXG4gICAgICAgKi9cbiAgICAgIC0tZGFyay10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci1ncmV5LTkwMCk7XG4gICAgICAtLWRhcmstdGhlbWUtYmFzZS1jb2xvcjogI2ZmZmZmZjtcbiAgICAgIC0tZGFyay10aGVtZS10ZXh0LWNvbG9yOiAjZmZmZmZmO1xuICAgICAgLS1kYXJrLXRoZW1lLXNlY29uZGFyeS1jb2xvcjogI2JjYmNiYzsgIC8qIGZvciBzZWNvbmRhcnkgdGV4dCBhbmQgaWNvbnMgKi9cbiAgICAgIC0tZGFyay10aGVtZS1kaXNhYmxlZC1jb2xvcjogIzY0NjQ2NDsgIC8qIGRpc2FibGVkL2hpbnQgdGV4dCAqL1xuICAgICAgLS1kYXJrLXRoZW1lLWRpdmlkZXItY29sb3I6ICMzYzNjM2M7XG5cbiAgICAgIC8qXG4gICAgICAgKiBEZXByZWNhdGVkIHZhbHVlcyBiZWNhdXNlIG9mIHRoZWlyIGNvbmZ1c2luZyBuYW1lcy5cbiAgICAgICAqL1xuICAgICAgLS10ZXh0LXByaW1hcnktY29sb3I6IHZhcigtLWRhcmstdGhlbWUtdGV4dC1jb2xvcik7XG4gICAgICAtLWRlZmF1bHQtcHJpbWFyeS1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XG4gICAgfVxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwsIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQYXBlclJpcHBsZUJlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCA9IHtcbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgZWxlbWVudCdzIGNoZWNrZWQgc3RhdGUgd2l0aCBpdHMgcmlwcGxlIGVmZmVjdC5cbiAgICovXG4gIF9jaGVja2VkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsLl9jaGVja2VkQ2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yaXBwbGUucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgdGhlIGVsZW1lbnQncyBgYWN0aXZlYCBhbmQgYGNoZWNrZWRgIHN0YXRlLlxuICAgKi9cbiAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgUGFwZXJSaXBwbGVCZWhhdmlvci5fYnV0dG9uU3RhdGVDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy5hY3RpdmU7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yID0gW1xuICBQYXBlcklua3lGb2N1c0JlaGF2aW9yLFxuICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvcixcbiAgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Gb3JtRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3RhdGUsIGB0cnVlYCBpcyBjaGVja2VkIGFuZCBgZmFsc2VgIGlzIHVuY2hlY2tlZC5cbiAgICAgKi9cbiAgICBjaGVja2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgb2JzZXJ2ZXI6ICdfY2hlY2tlZENoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gdG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIHdpdGggZWFjaCB0YXAgb3IgcHJlc3NcbiAgICAgKiBvZiB0aGUgc3BhY2ViYXIuXG4gICAgICovXG4gICAgdG9nZ2xlczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qIE92ZXJyaWRlbiBmcm9tIFBvbHltZXIuSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgKi9cbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdvbicsXG4gICAgICBvYnNlcnZlcjogJ192YWx1ZUNoYW5nZWQnXG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfcmVxdWlyZWRDaGFuZ2VkKHJlcXVpcmVkKSdcbiAgXSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2VkIGJ5IGBpcm9uLWZvcm1gIHRvIGhhbmRsZSB0aGUgY2FzZSB0aGF0IGFuIGVsZW1lbnQgd2l0aCB0aGlzIGJlaGF2aW9yXG4gICAgLy8gZG9lc24ndCBoYXZlIGEgcm9sZSBvZiAnY2hlY2tib3gnIG9yICdyYWRpbycsIGJ1dCBzaG91bGQgc3RpbGwgb25seSBiZVxuICAgIC8vIGluY2x1ZGVkIHdoZW4gdGhlIGZvcm0gaXMgc2VyaWFsaXplZCBpZiBgdGhpcy5jaGVja2VkID09PSB0cnVlYC5cbiAgICB0aGlzLl9oYXNJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFsc2UgaWYgdGhlIGVsZW1lbnQgaXMgcmVxdWlyZWQgYW5kIG5vdCBjaGVja2VkLCBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7Kj19IF92YWx1ZSBJZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGByZXF1aXJlZGAgaXMgZmFsc2Ugb3IgaWYgYGNoZWNrZWRgIGlzIHRydWUuXG4gICAqL1xuICBfZ2V0VmFsaWRpdHk6IGZ1bmN0aW9uKF92YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8ICF0aGlzLnJlcXVpcmVkIHx8IHRoaXMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhcmlhLXJlcXVpcmVkIGxhYmVsIHdoZW4gYHJlcXVpcmVkYCBpcyBjaGFuZ2VkLlxuICAgKi9cbiAgX3JlcXVpcmVkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVxdWlyZWQpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLXJlcXVpcmVkJywgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtcmVxdWlyZWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpcmUgYGlyb24tY2hhbmdlZGAgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzLlxuICAgKi9cbiAgX2NoZWNrZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuY2hlY2tlZDtcbiAgICB0aGlzLmZpcmUoJ2lyb24tY2hhbmdlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0IHZhbHVlIHRvICdvbicgaWYgaXQgaXMgc2V0IHRvIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgX3ZhbHVlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJ29uJztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IFtcbiAgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IsXG4gIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yLFxuICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yL2lyb24tY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbk1ldGEgfSBmcm9tICcuLi9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzJztcbmV4cG9ydCBsZXQgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSB2YWxpZGF0b3IgdG8gdXNlLlxuICAgICAqL1xuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGxhc3QgY2FsbCB0byBgdmFsaWRhdGVgIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgaW52YWxpZDoge1xuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX2ludmFsaWRDaGFuZ2VkJ1xuICAgIH0sXG4gIH0sXG5cbiAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhID0gbmV3IElyb25NZXRhKHt0eXBlOiAndmFsaWRhdG9yJ30pO1xuICB9LFxuXG4gIF9pbnZhbGlkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyogUmVjb21wdXRlIHRoaXMgZXZlcnkgdGltZSBpdCdzIG5lZWRlZCwgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGlmIHRoZVxuICAgKiB1bmRlcmx5aW5nIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSBoYXMgY2hhbmdlZC4gKi9cbiAgZ2V0IF92YWxpZGF0b3IoKSB7XG4gICAgcmV0dXJuIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSAmJlxuICAgICAgICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEuYnlLZXkodGhpcy52YWxpZGF0b3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWxpZGF0b3IgYHZhbGlkYXRvcmAgZXhpc3RzLlxuICAgKi9cbiAgaGFzVmFsaWRhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yICE9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCwgYW5kIHVwZGF0ZXMgYGludmFsaWRgLiBJZiB5b3Ugd2FudFxuICAgKiB5b3VyIGVsZW1lbnQgdG8gaGF2ZSBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYywgZG8gbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kO1xuICAgKiBvdmVycmlkZSBgX2dldFZhbGlkaXR5KHZhbHVlKWAgaW5zdGVhZC5cblxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgRGVwcmVjYXRlZDogVGhlIHZhbHVlIHRvIGJlIHZhbGlkYXRlZC4gQnkgZGVmYXVsdCxcbiAgICogaXQgaXMgcGFzc2VkIHRvIHRoZSB2YWxpZGF0b3IncyBgdmFsaWRhdGUoKWAgZnVuY3Rpb24sIGlmIGEgdmFsaWRhdG9yIGlzIHNldC5cbiAgICogSWYgdGhpcyBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZSBlbGVtZW50J3MgYHZhbHVlYCBwcm9wZXJ0eVxuICAgKiBpcyB1c2VkLCBpZiBpdCBleGlzdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC5cbiAgICovXG4gIHZhbGlkYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIElmIHRoaXMgaXMgYW4gZWxlbWVudCB0aGF0IGFsc28gaGFzIGEgdmFsdWUgcHJvcGVydHksIGFuZCB0aGVyZSB3YXNcbiAgICAvLyBubyBleHBsaWNpdCB2YWx1ZSBhcmd1bWVudCBwYXNzZWQsIHVzZSB0aGUgZWxlbWVudCdzIHByb3BlcnR5IGluc3RlYWQuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgdGhpcy5pbnZhbGlkID0gIXRoaXMuX2dldFZhbGlkaXR5KHRoaXMudmFsdWUpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuaW52YWxpZCA9ICF0aGlzLl9nZXRWYWxpZGl0eSh2YWx1ZSk7XG4gICAgcmV0dXJuICF0aGlzLmludmFsaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiAgQnkgZGVmYXVsdCwgaXQgaXMgcGFzc2VkXG4gICAqIHRvIHRoZSB2YWxpZGF0b3IncyBgdmFsaWRhdGUoKWAgZnVuY3Rpb24sIGlmIGEgdmFsaWRhdG9yIGlzIHNldC4gWW91XG4gICAqIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0byBpbXBsZW1lbnQgY3VzdG9tIHZhbGlkaXR5XG4gICAqIGxvZ2ljIGZvciB5b3VyIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdmFsaWRhdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuXG4gICAqL1xuXG4gIF9nZXRWYWxpZGl0eTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNWYWxpZGF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIGFzIFBvbHltZXIkMCB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7e3R5cGU6IChzdHJpbmd8bnVsbCksIGtleTogKHN0cmluZ3xudWxsKSwgdmFsdWU6ICp9fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIElyb25NZXRhKG9wdGlvbnMpIHtcbiAgdGhpcy50eXBlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSB8fCAnZGVmYXVsdCc7XG4gIHRoaXMua2V5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleTtcbiAgaWYgKCd2YWx1ZScgaW4gb3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB9XG59XG5cbklyb25NZXRhLnR5cGVzID0ge307XG5cbklyb25NZXRhLnByb3RvdHlwZSA9IHtcbiAgZ2V0IHZhbHVlKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgIHZhciBrZXkgPSB0aGlzLmtleTtcblxuICAgIGlmICh0eXBlICYmIGtleSkge1xuICAgICAgcmV0dXJuIElyb25NZXRhLnR5cGVzW3R5cGVdICYmIElyb25NZXRhLnR5cGVzW3R5cGVdW2tleV07XG4gICAgfVxuICB9LFxuXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgIHZhciBrZXkgPSB0aGlzLmtleTtcblxuICAgIGlmICh0eXBlICYmIGtleSkge1xuICAgICAgdHlwZSA9IElyb25NZXRhLnR5cGVzW3R5cGVdID0gSXJvbk1ldGEudHlwZXNbdHlwZV0gfHwge307XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgdHlwZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldCBsaXN0KCkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhJcm9uTWV0YS50eXBlc1t0aGlzLnR5cGVdKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBtZXRhRGF0YXNbdGhpcy50eXBlXVtrZXldO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufTtcblxuZXhwb3J0IHsgSXJvbk1ldGEgfTtcblxudmFyIG1ldGFEYXRhcyA9IElyb25NZXRhLnR5cGVzO1xuXG5Qb2x5bWVyJDAoe1xuXG4gIGlzOiAnaXJvbi1tZXRhJyxcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtZXRhLWRhdGEuICBBbGwgbWV0YS1kYXRhIG9mIHRoZSBzYW1lIHR5cGUgaXMgc3RvcmVkXG4gICAgICogdG9nZXRoZXIuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2RlZmF1bHQnLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHVzZWQgdG8gc3RvcmUgYHZhbHVlYCB1bmRlciB0aGUgYHR5cGVgIG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICBrZXk6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGEtZGF0YSB0byBzdG9yZSBvciByZXRyaWV2ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBgdmFsdWVgIGlzIHNldCB0byB0aGUgaXJvbi1tZXRhIGluc3RhbmNlIGl0c2VsZi5cbiAgICAgKi9cbiAgICAgc2VsZjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIG9ic2VydmVyOiAnX3NlbGZDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICBfX21ldGE6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBjb21wdXRlZDogJ19fY29tcHV0ZU1ldGEodHlwZSwga2V5LCB2YWx1ZSknXG4gICAgfVxuICB9LFxuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgaGlkZGVuOiB0cnVlXG4gIH0sXG5cbiAgX19jb21wdXRlTWV0YTogZnVuY3Rpb24odHlwZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBtZXRhID0gbmV3IElyb25NZXRhKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleVxuICAgIH0pO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG1ldGEudmFsdWUpIHtcbiAgICAgIG1ldGEudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgIT09IG1ldGEudmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBtZXRhLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhO1xuICB9LFxuXG4gIGdldCBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9fbWV0YSAmJiB0aGlzLl9fbWV0YS5saXN0O1xuICB9LFxuXG4gIF9zZWxmQ2hhbmdlZDogZnVuY3Rpb24oc2VsZikge1xuICAgIGlmIChzZWxmKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBtZXRhIGRhdGEgdmFsdWUgYnkga2V5LlxuICAgKlxuICAgKiBAbWV0aG9kIGJ5S2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0YS1kYXRhIHRvIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgYnlLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBuZXcgSXJvbk1ldGEoe1xuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAga2V5OiBrZXlcbiAgICB9KS52YWx1ZTtcbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tbWV0YS9pcm9uLW1ldGEuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWRkZWQgdG8gYW4gYGlyb24tZm9ybWAuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1mb3JtLWVsZW1lbnQtcmVnaXN0ZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGFuIGBpcm9uLWZvcm1gLlxuICAgICAqXG4gICAgICogQGV2ZW50IGlyb24tZm9ybS1lbGVtZW50LXVucmVnaXN0ZXJcbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIG1hcmsgdGhlIGlucHV0IGFzIHJlcXVpcmVkLiBJZiB1c2VkIGluIGEgZm9ybSwgYVxuICAgICAqIGN1c3RvbSBlbGVtZW50IHRoYXQgdXNlcyB0aGlzIGJlaGF2aW9yIHNob3VsZCBhbHNvIHVzZVxuICAgICAqIFBvbHltZXIuSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgYW5kIGRlZmluZSBhIGN1c3RvbSB2YWxpZGF0aW9uIG1ldGhvZC5cbiAgICAgKiBPdGhlcndpc2UsIGEgYHJlcXVpcmVkYCBlbGVtZW50IHdpbGwgYWx3YXlzIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gICAgICogSXQncyBhbHNvIHN0cm9uZ2x5IHJlY29tbWVuZGVkIHRvIHByb3ZpZGUgYSB2aXN1YWwgc3R5bGUgZm9yIHRoZSBlbGVtZW50XG4gICAgICogd2hlbiBpdHMgdmFsdWUgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICByZXF1aXJlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybSB0aGF0IHRoZSBlbGVtZW50IGlzIHJlZ2lzdGVyZWQgdG8uXG4gICAgICovXG4gICAgX3BhcmVudEZvcm06IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH1cbiAgfSxcblxuICBhdHRhY2hlZDogRWxlbWVudCA/IG51bGwgOiBmdW5jdGlvbigpIHtcbiAgICAvLyBOb3RlOiB0aGUgaXJvbi1mb3JtIHRoYXQgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gd2lsbCBzZXQgdGhpc1xuICAgIC8vIGVsZW1lbnQncyBfcGFyZW50Rm9ybSBwcm9wZXJ0eSB3aGVuIGhhbmRsaW5nIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5maXJlKCdpcm9uLWZvcm0tZWxlbWVudC1yZWdpc3RlcicpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBFbGVtZW50ID8gbnVsbCA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnRGb3JtKSB7XG4gICAgICB0aGlzLl9wYXJlbnRGb3JtLmZpcmUoJ2lyb24tZm9ybS1lbGVtZW50LXVucmVnaXN0ZXInLCB7dGFyZ2V0OiB0aGlzfSk7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yLmpzIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkJ1dHRvblN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Db250cm9sU3RhdGUgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwgPSB7XG4gIG9ic2VydmVyczogW1xuICAgICdfZm9jdXNlZENoYW5nZWQocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCknXG4gIF0sXG5cbiAgX2ZvY3VzZWRDaGFuZ2VkOiBmdW5jdGlvbihyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgaWYgKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUuaG9sZERvd24gPSByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkO1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmlwcGxlID0gUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgcmlwcGxlLmlkID0gJ2luayc7XG4gICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnY2VudGVyJywgJycpO1xuICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnKTtcbiAgICByZXR1cm4gcmlwcGxlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciA9IFtcbiAgSXJvbkJ1dHRvblN0YXRlLFxuICBJcm9uQ29udHJvbFN0YXRlLFxuICBQYXBlclJpcHBsZUJlaGF2aW9yLFxuICBQYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuXG52YXIgVXRpbGl0eSA9IHtcbiAgZGlzdGFuY2U6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIHhEZWx0YSA9ICh4MSAtIHgyKTtcbiAgICB2YXIgeURlbHRhID0gKHkxIC0geTIpO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCh4RGVsdGEgKiB4RGVsdGEgKyB5RGVsdGEgKiB5RGVsdGEpO1xuICB9LFxuXG4gIG5vdzogd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgP1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vd1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRWxlbWVudE1ldHJpY3MoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLndpZHRoID0gdGhpcy5ib3VuZGluZ1JlY3Qud2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3VuZGluZ1JlY3QuaGVpZ2h0O1xuXG4gIHRoaXMuc2l6ZSA9IE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn1cblxuRWxlbWVudE1ldHJpY3MucHJvdG90eXBlID0ge1xuICBnZXQgYm91bmRpbmdSZWN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9LFxuXG4gIGZ1cnRoZXN0Q29ybmVyRGlzdGFuY2VGcm9tOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHRvcExlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIDApO1xuICAgIHZhciB0b3BSaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgMCk7XG4gICAgdmFyIGJvdHRvbUxlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIHRoaXMuaGVpZ2h0KTtcbiAgICB2YXIgYm90dG9tUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIHJldHVybiBNYXRoLm1heCh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSaXBwbGUoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmNvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuY29sb3I7XG5cbiAgdGhpcy53YXZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMud2F2ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLndhdmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgdGhpcy53YXZlLmNsYXNzTGlzdC5hZGQoJ3dhdmUnKTtcbiAgdGhpcy53YXZlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3dhdmUtY29udGFpbmVyJyk7XG4gIGRvbSh0aGlzLndhdmVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMud2F2ZSk7XG5cbiAgdGhpcy5yZXNldEludGVyYWN0aW9uU3RhdGUoKTtcbn1cblxuUmlwcGxlLk1BWF9SQURJVVMgPSAzMDA7XG5cblJpcHBsZS5wcm90b3R5cGUgPSB7XG4gIGdldCByZWNlbnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5yZWNlbnRlcnM7XG4gIH0sXG5cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNlbnRlcjtcbiAgfSxcblxuICBnZXQgbW91c2VEb3duRWxhcHNlZCgpIHtcbiAgICB2YXIgZWxhcHNlZDtcblxuICAgIGlmICghdGhpcy5tb3VzZURvd25TdGFydCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZWxhcHNlZCA9IFV0aWxpdHkubm93KCkgLSB0aGlzLm1vdXNlRG93blN0YXJ0O1xuXG4gICAgaWYgKHRoaXMubW91c2VVcFN0YXJ0KSB7XG4gICAgICBlbGFwc2VkIC09IHRoaXMubW91c2VVcEVsYXBzZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsYXBzZWQ7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlVXBFbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlVXBTdGFydCA/XG4gICAgICBVdGlsaXR5Lm5vdyAoKSAtIHRoaXMubW91c2VVcFN0YXJ0IDogMDtcbiAgfSxcblxuICBnZXQgbW91c2VEb3duRWxhcHNlZFNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZCAvIDEwMDA7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlVXBFbGFwc2VkU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZVVwRWxhcHNlZCAvIDEwMDA7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkVsYXBzZWRTZWNvbmRzICsgdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHM7XG4gIH0sXG5cbiAgZ2V0IGluaXRpYWxPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaW5pdGlhbE9wYWNpdHk7XG4gIH0sXG5cbiAgZ2V0IG9wYWNpdHlEZWNheVZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQub3BhY2l0eURlY2F5VmVsb2NpdHk7XG4gIH0sXG5cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICB2YXIgd2lkdGgyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoICogdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoO1xuICAgIHZhciBoZWlnaHQyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAqIHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQ7XG4gICAgdmFyIHdhdmVSYWRpdXMgPSBNYXRoLm1pbihcbiAgICAgIE1hdGguc3FydCh3aWR0aDIgKyBoZWlnaHQyKSxcbiAgICAgIFJpcHBsZS5NQVhfUkFESVVTXG4gICAgKSAqIDEuMSArIDU7XG5cbiAgICB2YXIgZHVyYXRpb24gPSAxLjEgLSAwLjIgKiAod2F2ZVJhZGl1cyAvIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICB2YXIgdGltZU5vdyA9IHRoaXMubW91c2VJbnRlcmFjdGlvblNlY29uZHMgLyBkdXJhdGlvbjtcbiAgICB2YXIgc2l6ZSA9IHdhdmVSYWRpdXMgKiAoMSAtIE1hdGgucG93KDgwLCAtdGltZU5vdykpO1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKHNpemUpO1xuICB9LFxuXG4gIGdldCBvcGFjaXR5KCkge1xuICAgIGlmICghdGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxPcGFjaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIDAsXG4gICAgICB0aGlzLmluaXRpYWxPcGFjaXR5IC0gdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHMgKiB0aGlzLm9wYWNpdHlEZWNheVZlbG9jaXR5XG4gICAgKTtcbiAgfSxcblxuICBnZXQgb3V0ZXJPcGFjaXR5KCkge1xuICAgIC8vIExpbmVhciBpbmNyZWFzZSBpbiBiYWNrZ3JvdW5kIG9wYWNpdHksIGNhcHBlZCBhdCB0aGUgb3BhY2l0eVxuICAgIC8vIG9mIHRoZSB3YXZlZnJvbnQgKHdhdmVPcGFjaXR5KS5cbiAgICB2YXIgb3V0ZXJPcGFjaXR5ID0gdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHMgKiAwLjM7XG4gICAgdmFyIHdhdmVPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKG91dGVyT3BhY2l0eSwgd2F2ZU9wYWNpdHkpXG4gICAgKTtcbiAgfSxcblxuICBnZXQgaXNPcGFjaXR5RnVsbHlEZWNheWVkKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPCAwLjAxICYmXG4gICAgICB0aGlzLnJhZGl1cyA+PSBNYXRoLm1pbih0aGlzLm1heFJhZGl1cywgUmlwcGxlLk1BWF9SQURJVVMpO1xuICB9LFxuXG4gIGdldCBpc1Jlc3RpbmdBdE1heFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID49IHRoaXMuaW5pdGlhbE9wYWNpdHkgJiZcbiAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gIH0sXG5cbiAgZ2V0IGlzQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgIHRoaXMuaXNPcGFjaXR5RnVsbHlEZWNheWVkIDogdGhpcy5pc1Jlc3RpbmdBdE1heFJhZGl1cztcbiAgfSxcblxuICBnZXQgdHJhbnNsYXRpb25GcmFjdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAxLFxuICAgICAgdGhpcy5yYWRpdXMgLyB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAqIDIgLyBNYXRoLnNxcnQoMilcbiAgICApO1xuICB9LFxuXG4gIGdldCB4Tm93KCkge1xuICAgIGlmICh0aGlzLnhFbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnhTdGFydCArIHRoaXMudHJhbnNsYXRpb25GcmFjdGlvbiAqICh0aGlzLnhFbmQgLSB0aGlzLnhTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueFN0YXJ0O1xuICB9LFxuXG4gIGdldCB5Tm93KCkge1xuICAgIGlmICh0aGlzLnlFbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnlTdGFydCArIHRoaXMudHJhbnNsYXRpb25GcmFjdGlvbiAqICh0aGlzLnlFbmQgLSB0aGlzLnlTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueVN0YXJ0O1xuICB9LFxuXG4gIGdldCBpc01vdXNlRG93bigpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZURvd25TdGFydCAmJiAhdGhpcy5tb3VzZVVwU3RhcnQ7XG4gIH0sXG5cbiAgcmVzZXRJbnRlcmFjdGlvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgdGhpcy5tb3VzZURvd25TdGFydCA9IDA7XG4gICAgdGhpcy5tb3VzZVVwU3RhcnQgPSAwO1xuXG4gICAgdGhpcy54U3RhcnQgPSAwO1xuICAgIHRoaXMueVN0YXJ0ID0gMDtcbiAgICB0aGlzLnhFbmQgPSAwO1xuICAgIHRoaXMueUVuZCA9IDA7XG4gICAgdGhpcy5zbGlkZURpc3RhbmNlID0gMDtcblxuICAgIHRoaXMuY29udGFpbmVyTWV0cmljcyA9IG5ldyBFbGVtZW50TWV0cmljcyh0aGlzLmVsZW1lbnQpO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZTtcbiAgICB2YXIgdHJhbnNsYXRlU3RyaW5nO1xuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICB0aGlzLndhdmUuc3R5bGUub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgIHNjYWxlID0gdGhpcy5yYWRpdXMgLyAodGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgLyAyKTtcbiAgICBkeCA9IHRoaXMueE5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyKTtcbiAgICBkeSA9IHRoaXMueU5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMik7XG5cblxuICAgIC8vIDJkIHRyYW5zZm9ybSBmb3Igc2FmYXJpIGJlY2F1c2Ugb2YgYm9yZGVyLXJhZGl1cyBhbmQgb3ZlcmZsb3c6aGlkZGVuIGNsaXBwaW5nIGJ1Zy5cbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTg1MzhcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsICcgKyBkeSArICdweCknO1xuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIGR4ICsgJ3B4LCAnICsgZHkgKyAncHgsIDApJztcbiAgICB0aGlzLndhdmUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJyknO1xuICAgIHRoaXMud2F2ZS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUzZCgnICsgc2NhbGUgKyAnLCcgKyBzY2FsZSArICcsMSknO1xuICB9LFxuXG4gIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgeENlbnRlciA9IHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDI7XG4gICAgdmFyIHlDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcblxuICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgdGhpcy5tb3VzZURvd25TdGFydCA9IFV0aWxpdHkubm93KCk7XG5cbiAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgIHRoaXMueFN0YXJ0ID0geENlbnRlcjtcbiAgICAgIHRoaXMueVN0YXJ0ID0geUNlbnRlcjtcbiAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueFN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgIGV2ZW50LmRldGFpbC54IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLmJvdW5kaW5nUmVjdC5sZWZ0IDpcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgdGhpcy55U3RhcnQgPSBldmVudCA/XG4gICAgICAgICAgZXZlbnQuZGV0YWlsLnkgLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LnRvcCA6XG4gICAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjZW50ZXJzKSB7XG4gICAgICB0aGlzLnhFbmQgPSB4Q2VudGVyO1xuICAgICAgdGhpcy55RW5kID0geUNlbnRlcjtcbiAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXhSYWRpdXMgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb20oXG4gICAgICB0aGlzLnhTdGFydCxcbiAgICAgIHRoaXMueVN0YXJ0XG4gICAgKTtcblxuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50b3AgPVxuICAgICAgKHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSkgLyAyICsgJ3B4JztcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUubGVmdCA9XG4gICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG5cbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2lkdGggPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSArICdweCc7XG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgfSxcblxuICAvKiogQHBhcmFtIHtFdmVudD19IGV2ZW50ICovXG4gIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubW91c2VVcFN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGRvbSh0aGlzLndhdmVDb250YWluZXIucGFyZW50Tm9kZSkucmVtb3ZlQ2hpbGQoXG4gICAgICB0aGlzLndhdmVDb250YWluZXJcbiAgICApO1xuICB9XG59O1xuXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgLyogU2VlIFBvbHltZXJFbGVtZW50cy9wYXBlci1iZWhhdmlvcnMvaXNzdWVzLzM0LiBPbiBub24tQ2hyb21lIGJyb3dzZXJzLFxuICAgICAgICAgKiBjcmVhdGluZyBhIG5vZGUgKHdpdGggYSBwb3NpdGlvbjphYnNvbHV0ZSkgaW4gdGhlIG1pZGRsZSBvZiBhbiBldmVudFxuICAgICAgICAgKiBoYW5kbGVyIFwiaW50ZXJydXB0c1wiIHRoYXQgZXZlbnQgaGFuZGxlciAod2hpY2ggaGFwcGVucyB3aGVuIHRoZVxuICAgICAgICAgKiByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQpICovXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbYW5pbWF0aW5nXSkge1xuICAgICAgICAvKiBUaGlzIHJlc29sdmVzIGEgcmVuZGVyaW5nIGlzc3VlIGluIENocm9tZSAoYXMgb2YgNDApIHdoZXJlIHRoZVxuICAgICAgICAgICByaXBwbGUgaXMgbm90IHByb3Blcmx5IGNsaXBwZWQgYnkgaXRzIHBhcmVudCAod2hpY2ggbWF5IGhhdmVcbiAgICAgICAgICAgcm91bmRlZCBjb3JuZXJzKS4gU2VlOiBodHRwOi8vanNiaW4uY29tL3RlbWV4YS80XG5cbiAgICAgICAgICAgTm90ZTogV2Ugb25seSBhcHBseSB0aGlzIHN0eWxlIGNvbmRpdGlvbmFsbHkuIE90aGVyd2lzZSwgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgd2lsbCBjcmVhdGUgYSBuZXcgY29tcG9zaXRpbmcgbGF5ZXIgZm9yIGV2ZXJ5IHJpcHBsZSBlbGVtZW50IG9uIHRoZVxuICAgICAgICAgICBwYWdlLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWQuICovXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgI3dhdmVzLFxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgLndhdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC53YXZlLWNvbnRhaW5lcixcbiAgICAgIC53YXZlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAjYmFja2dyb3VuZCxcbiAgICAgIDpob3N0KC5jaXJjbGUpICN3YXZlcyB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLmNpcmNsZSkgLndhdmUtY29udGFpbmVyIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cImJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGlkPVwid2F2ZXNcIj48L2Rpdj5cbmAsXG5cbiAgaXM6ICdwYXBlci1yaXBwbGUnLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIElyb25BMTF5S2V5c0JlaGF2aW9yXG4gIF0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIG9wYWNpdHkgc2V0IG9uIHRoZSB3YXZlLlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBpbml0aWFsT3BhY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuMjVcbiAgICAgKi9cbiAgICBpbml0aWFsT3BhY2l0eToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDAuMjVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSG93IGZhc3QgKG9wYWNpdHkgcGVyIHNlY29uZCkgdGhlIHdhdmUgZmFkZXMgb3V0LlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBvcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuOFxuICAgICAqL1xuICAgIG9wYWNpdHlEZWNheVZlbG9jaXR5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWx1ZTogMC44XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBleGhpYml0IGEgZ3Jhdml0YXRpb25hbCBwdWxsIHRvd2FyZHNcbiAgICAgKiB0aGUgY2VudGVyIG9mIHRoZWlyIGNvbnRhaW5lciBhcyB0aGV5IGZhZGUgYXdheS5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgcmVjZW50ZXJzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBjZW50ZXIgaW5zaWRlIGl0cyBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgY2VudGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiB0aGUgdmlzdWFsIHJpcHBsZXMuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIHJpcHBsZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG4gICAgcmlwcGxlczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIHRoZXJlIGFyZSB2aXNpYmxlIHJpcHBsZXMgYW5pbWF0aW5nIHdpdGhpbiB0aGVcbiAgICAgKiBlbGVtZW50LlxuICAgICAqL1xuICAgIGFuaW1hdGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCByZW1haW4gaW4gdGhlIFwiZG93blwiIHN0YXRlIHVudGlsIGBob2xkRG93bmBcbiAgICAgKiBpcyBzZXQgdG8gZmFsc2UgYWdhaW4uXG4gICAgICovXG4gICAgaG9sZERvd246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBvYnNlcnZlcjogJ19ob2xkRG93bkNoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCBub3QgZ2VuZXJhdGUgYSByaXBwbGUgZWZmZWN0XG4gICAgICogdmlhIHBvaW50ZXIgaW50ZXJhY3Rpb24uXG4gICAgICogQ2FsbGluZyByaXBwbGUncyBpbXBlcmF0aXZlIGFwaSBsaWtlIGBzaW11bGF0ZWRSaXBwbGVgIHdpbGxcbiAgICAgKiBzdGlsbCBnZW5lcmF0ZSB0aGUgcmlwcGxlIGVmZmVjdC5cbiAgICAgKi9cbiAgICBub2luazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBfYW5pbWF0aW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIF9ib3VuZEFuaW1hdGU6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldCB0YXJnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmtleUV2ZW50VGFyZ2V0O1xuICB9LFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ2VudGVyOmtleWRvd24nOiAnX29uRW50ZXJLZXlkb3duJyxcbiAgICAnc3BhY2U6a2V5ZG93bic6ICdfb25TcGFjZUtleWRvd24nLFxuICAgICdzcGFjZTprZXl1cCc6ICdfb25TcGFjZUtleXVwJ1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBTZXQgdXAgYTExeUtleXNCZWhhdmlvciB0byBsaXN0ZW4gdG8ga2V5IGV2ZW50cyBvbiB0aGUgdGFyZ2V0LFxuICAgIC8vIHNvIHRoYXQgc3BhY2UgYW5kIGVudGVyIGFjdGl2YXRlIHRoZSByaXBwbGUgZXZlbiBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3RcbiAgICAvLyBoYW5kbGUga2V5IGV2ZW50cy4gVGhlIGtleSBoYW5kbGVycyBkZWFsIHdpdGggYG5vaW5rYCB0aGVtc2VsdmVzLlxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUubm9kZVR5cGUgPT0gMTEpIHsgLy8gRE9DVU1FTlRfRlJBR01FTlRfTk9ERVxuICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IGRvbSh0aGlzKS5nZXRPd25lclJvb3QoKS5ob3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB2YXIga2V5RXZlbnRUYXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKHRoaXMua2V5RXZlbnRUYXJnZXQpO1xuICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAnZG93bicsICd1aURvd25BY3Rpb24nKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bmxpc3Rlbih0aGlzLmtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IG51bGw7XG4gIH0sXG5cbiAgZ2V0IHNob3VsZEtlZXBBbmltYXRpbmcgKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJpcHBsZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlc1tpbmRleF0uaXNBbmltYXRpb25Db21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgc2ltdWxhdGVkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvd25BY3Rpb24obnVsbCk7XG5cbiAgICAvLyBQbGVhc2Ugc2VlIHBvbHltZXIvcG9seW1lciMxMzA1XG4gICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICB9LCAxKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdWlEb3duQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgdGhpcy5kb3duQWN0aW9uKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3Zva2VzIGEgcmlwcGxlIGRvd24gZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaG9sZERvd24gJiYgdGhpcy5yaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmlwcGxlID0gdGhpcy5hZGRSaXBwbGUoKTtcblxuICAgIHJpcHBsZS5kb3duQWN0aW9uKGV2ZW50KTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5hbmltYXRlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdWlVcEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubm9pbmspIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgdXAgZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLmhvbGREb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yaXBwbGVzLmZvckVhY2goZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICByaXBwbGUudXBBY3Rpb24oZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGUoKTtcbiAgfSxcblxuICBvbkFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiQuYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuICAgIHRoaXMuZmlyZSgndHJhbnNpdGlvbmVuZCcpO1xuICB9LFxuXG4gIGFkZFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpcHBsZSA9IG5ldyBSaXBwbGUodGhpcyk7XG5cbiAgICBkb20odGhpcy4kLndhdmVzKS5hcHBlbmRDaGlsZChyaXBwbGUud2F2ZUNvbnRhaW5lcik7XG4gICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmlwcGxlLmNvbG9yO1xuICAgIHRoaXMucmlwcGxlcy5wdXNoKHJpcHBsZSk7XG5cbiAgICB0aGlzLl9zZXRBbmltYXRpbmcodHJ1ZSk7XG5cbiAgICByZXR1cm4gcmlwcGxlO1xuICB9LFxuXG4gIHJlbW92ZVJpcHBsZTogZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgdmFyIHJpcHBsZUluZGV4ID0gdGhpcy5yaXBwbGVzLmluZGV4T2YocmlwcGxlKTtcblxuICAgIGlmIChyaXBwbGVJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJpcHBsZXMuc3BsaWNlKHJpcHBsZUluZGV4LCAxKTtcblxuICAgIHJpcHBsZS5yZW1vdmUoKTtcblxuICAgIGlmICghdGhpcy5yaXBwbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2V0QW5pbWF0aW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgY29uZmxpY3RzIHdpdGggRWxlbWVudCNhbnRpbWF0ZSgpLlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9hbmltYXRlXG4gICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbmRleDtcbiAgICB2YXIgcmlwcGxlO1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgcmlwcGxlID0gdGhpcy5yaXBwbGVzW2luZGV4XTtcblxuICAgICAgcmlwcGxlLmRyYXcoKTtcblxuICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IHJpcHBsZS5vdXRlck9wYWNpdHk7XG5cbiAgICAgIGlmIChyaXBwbGUuaXNPcGFjaXR5RnVsbHlEZWNheWVkICYmICFyaXBwbGUuaXNSZXN0aW5nQXRNYXhSYWRpdXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUocmlwcGxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2hvdWxkS2VlcEFuaW1hdGluZyAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZEFuaW1hdGUpO1xuICAgIH1cbiAgfSxcblxuICBfb25FbnRlcktleWRvd246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gICAgdGhpcy5hc3luYyh0aGlzLnVpVXBBY3Rpb24sIDEpO1xuICB9LFxuXG4gIF9vblNwYWNlS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51aURvd25BY3Rpb24oKTtcbiAgfSxcblxuICBfb25TcGFjZUtleXVwOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVpVXBBY3Rpb24oKTtcbiAgfSxcblxuICAvLyBub3RlOiBob2xkRG93biBkb2VzIG5vdCByZXNwZWN0IG5vaW5rIHNpbmNlIGl0IGNhbiBiZSBhIGZvY3VzIGJhc2VkXG4gIC8vIGVmZmVjdC5cbiAgX2hvbGREb3duQ2hhbmdlZDogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICBpZiAob2xkVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5ld1ZhbCkge1xuICAgICAgdGhpcy5kb3duQWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzLlxuICBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3YWl0IHVudGlsXG4gIHRoZSByaXBwbGUgYW5pbWF0aW9uIGZpbmlzaGVzIHRvIHBlcmZvcm0gc29tZSBhY3Rpb24uXG5cbiAgQGV2ZW50IHRyYW5zaXRpb25lbmRcbiAgQHBhcmFtIHt7bm9kZTogT2JqZWN0fX0gZGV0YWlsIENvbnRhaW5zIHRoZSBhbmltYXRlZCBub2RlLlxuICAqL1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXJpcHBsZS9wYXBlci1yaXBwbGUuanMiLCJpbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcbmltcG9ydCB7X3BvaW50ZXJzQ291bnR9IGZyb20gJy4vRG9tRXZlbnQuUG9pbnRlcic7XHJcblxyXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxudmFyIF90b3VjaHN0YXJ0ID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiBCcm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcmRvd24nIDogJ3RvdWNoc3RhcnQnO1xyXG52YXIgX3RvdWNoZW5kID0gQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnIDogQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJ1cCcgOiAndG91Y2hlbmQnO1xyXG52YXIgX3ByZSA9ICdfbGVhZmxldF8nO1xyXG5cclxuLy8gaW5zcGlyZWQgYnkgWmVwdG8gdG91Y2ggY29kZSBieSBUaG9tYXMgRnVjaHNcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpIHtcclxuXHR2YXIgbGFzdCwgdG91Y2gsXHJcblx0ICAgIGRvdWJsZVRhcCA9IGZhbHNlLFxyXG5cdCAgICBkZWxheSA9IDI1MDtcclxuXHJcblx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHRcdHZhciBjb3VudDtcclxuXHJcblx0XHRpZiAoQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGlmICgoIUJyb3dzZXIuZWRnZSkgfHwgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgeyByZXR1cm47IH1cclxuXHRcdFx0Y291bnQgPSBfcG9pbnRlcnNDb3VudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvdW50ID0gZS50b3VjaGVzLmxlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY291bnQgPiAxKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpLFxyXG5cdFx0ICAgIGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHR0b3VjaCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XHJcblx0XHRkb3VibGVUYXAgPSAoZGVsdGEgPiAwICYmIGRlbHRhIDw9IGRlbGF5KTtcclxuXHRcdGxhc3QgPSBub3c7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoRW5kKGUpIHtcclxuXHRcdGlmIChkb3VibGVUYXAgJiYgIXRvdWNoLmNhbmNlbEJ1YmJsZSkge1xyXG5cdFx0XHRpZiAoQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0aWYgKCghQnJvd3Nlci5lZGdlKSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuXHRcdFx0XHR2YXIgbmV3VG91Y2ggPSB7fSxcclxuXHRcdFx0XHQgICAgcHJvcCwgaTtcclxuXHJcblx0XHRcdFx0Zm9yIChpIGluIHRvdWNoKSB7XHJcblx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3AgJiYgcHJvcC5iaW5kID8gcHJvcC5iaW5kKHRvdWNoKSA6IHByb3A7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdH1cclxuXHRcdFx0dG91Y2gudHlwZSA9ICdkYmxjbGljayc7XHJcblx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRsYXN0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9ialtfcHJlICsgX3RvdWNoc3RhcnQgKyBpZF0gPSBvblRvdWNoU3RhcnQ7XHJcblx0b2JqW19wcmUgKyBfdG91Y2hlbmQgKyBpZF0gPSBvblRvdWNoRW5kO1xyXG5cdG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXSA9IGhhbmRsZXI7XHJcblxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKF90b3VjaHN0YXJ0LCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgKG5vdGFibHksIGNocm9tZTw1NSBvbiB3aW4xMCArIHRvdWNoc2NyZWVuICsgbW91c2UpLFxyXG5cdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSB0b3VjaGVuZC9wb2ludGVydXAgZXZlbnRzIGJ1dCBkb2VzIGZpcmVcclxuXHQvLyBuYXRpdmUgZGJsY2xpY2tzLiBTZWUgIzQxMjcuXHJcblx0Ly8gRWRnZSAxNCBhbHNvIGZpcmVzIG5hdGl2ZSBkYmxjbGlja3MsIGJ1dCBvbmx5IGZvciBwb2ludGVyVHlwZSBtb3VzZSwgc2VlICM1MTgwLlxyXG5cdG9iai5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGlkKSB7XHJcblx0dmFyIHRvdWNoc3RhcnQgPSBvYmpbX3ByZSArIF90b3VjaHN0YXJ0ICsgaWRdLFxyXG5cdCAgICB0b3VjaGVuZCA9IG9ialtfcHJlICsgX3RvdWNoZW5kICsgaWRdLFxyXG5cdCAgICBkYmxjbGljayA9IG9ialtfcHJlICsgJ2RibGNsaWNrJyArIGlkXTtcclxuXHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIGZhbHNlKTtcclxuXHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihfdG91Y2hlbmQsIHRvdWNoZW5kLCBmYWxzZSk7XHJcblx0aWYgKCFCcm93c2VyLmVkZ2UpIHtcclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGRibGNsaWNrLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgYm91bmRzID0gbWFwLmdldFBpeGVsQm91bmRzKCksXG5cdFx0ICAgIG9yaWdpbiA9IG1hcC5nZXRQaXhlbE9yaWdpbigpO1xuXG5cdFx0dmFyIHBhbkJvdW5kcyA9IHRvQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi5fc3VidHJhY3Qob3JpZ2luKS5hZGQocGFkZGluZyksXG5cdFx0XHRib3VuZHMubWF4Ll9zdWJ0cmFjdChvcmlnaW4pLnN1YnRyYWN0KHBhZGRpbmcpXG5cdFx0KTtcblxuXHRcdGlmICghcGFuQm91bmRzLmNvbnRhaW5zKGljb25Qb3MpKSB7XG5cdFx0XHQvLyBDb21wdXRlIGluY3JlbWVudGFsIG1vdmVtZW50XG5cdFx0XHR2YXIgbW92ZW1lbnQgPSB0b1BvaW50KFxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC54LCBpY29uUG9zLngpIC0gcGFuQm91bmRzLm1heC54KSAvIChib3VuZHMubWF4LnggLSBwYW5Cb3VuZHMubWF4LngpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5taW4ueCkgLyAoYm91bmRzLm1pbi54IC0gcGFuQm91bmRzLm1pbi54KSxcblxuXHRcdFx0XHQoTWF0aC5tYXgocGFuQm91bmRzLm1heC55LCBpY29uUG9zLnkpIC0gcGFuQm91bmRzLm1heC55KSAvIChib3VuZHMubWF4LnkgLSBwYW5Cb3VuZHMubWF4LnkpIC1cblx0XHRcdFx0KE1hdGgubWluKHBhbkJvdW5kcy5taW4ueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5taW4ueSkgLyAoYm91bmRzLm1pbi55IC0gcGFuQm91bmRzLm1pbi55KVxuXHRcdFx0KS5tdWx0aXBseUJ5KHNwZWVkKTtcblxuXHRcdFx0bWFwLnBhbkJ5KG1vdmVtZW50LCB7YW5pbWF0ZTogZmFsc2V9KTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChtb3ZlbWVudCk7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQobW92ZW1lbnQpO1xuXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24obWFya2VyLl9pY29uLCB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyk7XG5cdFx0XHR0aGlzLl9vbkRyYWcoZSk7XG5cblx0XHRcdHRoaXMuX3BhblJlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FkanVzdFBhbi5iaW5kKHRoaXMsIGUpKTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQHNlY3Rpb24gRHJhZ2dpbmcgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IGRyYWdzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RhcnRzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cblx0XHR0aGlzLl9vbGRMYXRMbmcgPSB0aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCk7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblx0fSxcblxuXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuKSB7XG5cdFx0XHRjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cdFx0XHR0aGlzLl9wYW5SZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLCBlKSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG5cdFx0aWNvblBvcyA9IERvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG5cdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdGlmIChzaGFkb3cpIHtcblx0XHRcdERvbVV0aWwuc2V0UG9zaXRpb24oc2hhZG93LCBpY29uUG9zKTtcblx0XHR9XG5cblx0XHRtYXJrZXIuX2xhdGxuZyA9IGxhdGxuZztcblx0XHRlLmxhdGxuZyA9IGxhdGxuZztcblx0XHRlLm9sZExhdExuZyA9IHRoaXMuX29sZExhdExuZztcblxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxuXHRcdC8vIEZpcmVkIHJlcGVhdGVkbHkgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIG1hcmtlci5cblx0XHRtYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCBlKVxuXHRcdCAgICAuZmlyZSgnZHJhZycsIGUpO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gQGV2ZW50IGRyYWdlbmQ6IERyYWdFbmRFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIG1hcmtlci5cblxuXHRcdCBjYW5jZWxBbmltRnJhbWUodGhpcy5fcGFuUmVxdWVzdCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZWVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgc3RvcHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblx0XHRkZWxldGUgdGhpcy5fb2xkTGF0TG5nO1xuXHRcdHRoaXMuX21hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZWVuZCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnZW5kJywgZSk7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci9tYXJrZXIvTWFya2VyLkRyYWcuanMiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIyMjczZTNkOGFkOTI2NGI3ZGFhNWJkYmY4ZTZiNDdmOC5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItaWNvbi5wbmdcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI0NGE1MjZlZWQyNTgyMjI1MTVhYTIxZWFmZmQxNGE5Ni5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2ltYWdlcy9tYXJrZXItc2hhZG93LnBuZ1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IE1hcCB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL21hcCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGlvbiB9IGZyb20gJy4uLy4uL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5BdHRyaWJ1dGlvbi5qcydcblxuLy8gTmVlZCB0aGVzZSBzaWRlIGVmZmVjdHNcbmltcG9ydCAnLi4vLi4vbGVhZmxldC9zcmMvY29udHJvbCc7XG5pbXBvcnQgJy4uLy4uL2xlYWZsZXQvc3JjL2xheWVyJztcblxuZXhwb3J0IGNsYXNzIExlYWZsZXRNYXAgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldEAxLjMuMS9kaXN0L2xlYWZsZXQuY3NzXCIgLz5cblxuICAgICAgPCEtLSBGSVhNRTogRmlndXJlIG91dCBTaGFkb3cgRE9NIHNvIHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGluY2x1ZGVkIGhlcmUgLS0+XG4gICAgICA8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXQubWFya2VyY2x1c3RlckAxLjMuMC9kaXN0L01hcmtlckNsdXN0ZXIuY3NzXCIgbWVkaWE9XCJzY3JlZW5cIj5cbiAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldC5tYXJrZXJjbHVzdGVyQDEuMy4wL2Rpc3QvTWFya2VyQ2x1c3Rlci5EZWZhdWx0LmNzc1wiIG1lZGlhPVwic2NyZWVuXCI+XG5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgI21hcCB7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgIEBhcHBseSAoLS1sZWFmbGV0LW1hcC1jb21wb25lbnQpXG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgaWQ9XCJtYXBcIj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFwOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICB9LFxuICAgICAgbGF0aXR1ZGU6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgbG9uZ2l0dWRlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIHpvb206IHtcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgbWluWm9vbToge1xuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXhab29tOiB7XG4gICAgICAgIHR5cGU6IE51bWJlclxuICAgICAgfSxcbiAgICAgIHpvb21Db250cm9sOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0aW9uUHJlZml4OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIF9jaGlsZHJlbk9ic2VydmVyOiBPYmplY3RcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aGlzLiQubWFwLCB7XG4gICAgICBjZW50ZXI6IFt0aGlzLmxhdGl0dWRlLCB0aGlzLmxvbmdpdHVkZV0sXG4gICAgICB6b29tOiB0aGlzLnpvb20sXG4gICAgICB6b29tQ29udHJvbDogdGhpcy56b29tQ29udHJvbCxcbiAgICAgIGluZXJ0aWFEZWNlbGVyYXRpb246IDMwMDAsXG4gICAgICBpbmVydGlhTWF4U3BlZWQ6IDMwMDAsXG4gICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IGZhbHNlLFxuICAgICAgbWluWm9vbTogdGhpcy5taW5ab29tLFxuICAgICAgbWF4Wm9vbTogdGhpcy5tYXhab29tLFxuICAgICAgdGFwVG9sZXJhbmNlOiA0MCxcbiAgICAgIHRhcDogZmFsc2VcbiAgICB9KTtcbiAgICBcbiAgICBpZiAodGhpcy5hdHRyaWJ1dGlvblByZWZpeCkge1xuICAgICAgbGV0IGF0dHJDb250cm9sID0gbmV3IEF0dHJpYnV0aW9uKHsgcHJlZml4OiB0aGlzLmF0dHJpYnV0aW9uUHJlZml4IH0pO1xuICAgICAgdGhpcy5tYXAuYWRkQ29udHJvbChhdHRyQ29udHJvbCk7XG4gICAgfVxuXG4gICAgLy8gTC5tYXJrZXIoW3RoaXMubGF0aXR1ZGUsIHRoaXMubG9uZ2l0dWRlXSkuYWRkVG8odGhpcy5tYXApO1xuXG4gICAgbGV0IHNsb3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3Rvcignc2xvdCcpO1xuICAgIHRoaXMuX2NoaWxkcmVuT2JzZXJ2ZXIgPSBuZXcgRmxhdHRlbmVkTm9kZXNPYnNlcnZlcihzbG90LCB0aGlzLl9iaW5kRGVwZW5kZW5jaWVzLmJpbmQodGhpcykpO1xuICB9XG4gIFxuICAvKiBTaGl0dHkgd2F5IG9mIHBhc3NpbmcgdmFsdWUgdG8gY2hpbGRyZW4gKi9cbiAgX2JpbmREZXBlbmRlbmNpZXMoe2FkZGVkTm9kZXN9KSB7XG4gICAgYWRkZWROb2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgbi5tYXAgPSB0aGlzLm1hcDtcbiAgICB9KTtcbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xlYWZsZXQtbWFwJywgTGVhZmxldE1hcCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL3Zhci93d3cvaHRtbC9AZ2djaXR5L2xlYWZsZXQtbWFwL2xlYWZsZXQtbWFwLmpzIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG5cdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG5cdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnYm94Wm9vbScsIEJveFpvb20pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuQm94Wm9vbS5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgYmUgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQgdW5sZXNzIHJ1bm5pbmcgb24gb2xkIEFuZHJvaWQgZGV2aWNlcy5cblx0aW5lcnRpYTogIUJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuZXhwb3J0IHZhciBEcmFnID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oe1xuXHRcdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0XHRkcmFnOiB0aGlzLl9vbkRyYWcsXG5cdFx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ0xpbWl0LCB0aGlzKTtcblx0XHRcdGlmIChtYXAub3B0aW9ucy53b3JsZENvcHlKdW1wKSB7XG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZ1dyYXAsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LWdyYWInKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC1kcmFnJyk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKTtcblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRtb3Zpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92aW5nO1xuXHR9LFxuXG5cdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRtYXAuX3N0b3AoKTtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzICYmIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IGxhdExuZ0JvdW5kcyh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IHRvQm91bmRzKFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLFxuXHRcdFx0XHR0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludChib3VuZHMuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpXG5cdFx0XHRcdFx0LmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSk7XG5cblx0XHRcdHRoaXMuX3Zpc2Nvc2l0eSA9IE1hdGgubWluKDEuMCwgTWF0aC5tYXgoMC4wLCB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdG1hcFxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXG5cdFx0aWYgKG1hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9ucyA9IFtdO1xuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0XHR9XG5cdH0sXG5cblx0X29uRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0ICAgIHBvcyA9IHRoaXMuX2xhc3RQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyB8fCB0aGlzLl9kcmFnZ2FibGUuX25ld1BvcztcblxuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnB1c2gocG9zKTtcblx0XHRcdHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKHRpbWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcFxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X3BydW5lUG9zaXRpb25zOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHdoaWxlICh0aGlzLl9wb3NpdGlvbnMubGVuZ3RoID4gMSAmJiB0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHR0aGlzLl90aW1lcy5zaGlmdCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BydW5lUG9zaXRpb25zKCtuZXcgRGF0ZSgpKTtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG1hcC5wYW5CeShvZmZzZXQsIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkZWNlbGVyYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXG5cdFx0XHRcdFx0XHRub01vdmVTdGFydDogdHJ1ZSxcblx0XHRcdFx0XHRcdGFuaW1hdGU6IHRydWVcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuLy8gTWFwIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIERyYWcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuRHJhZy5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0IHtvbiwgb2ZmLCBzdG9wfSBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cblxuLypcbiAqIEwuTWFwLktleWJvYXJkIGlzIGhhbmRsaW5nIGtleWJvYXJkIGludGVyYWN0aW9uIHdpdGggdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBLZXlib2FyZCBOYXZpZ2F0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5leHBvcnQgdmFyIEtleWJvYXJkID0gSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRvbihjb250YWluZXIsIHtcblx0XHRcdGZvY3VzOiB0aGlzLl9vbkZvY3VzLFxuXHRcdFx0Ymx1cjogdGhpcy5fb25CbHVyLFxuXHRcdFx0bW91c2Vkb3duOiB0aGlzLl9vbk1vdXNlRG93blxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLm9uKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW1vdmVIb29rcygpO1xuXG5cdFx0b2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vZmYoe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdFx0ICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8IGRvY0VsLnNjcm9sbFRvcCxcblx0XHQgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xuXG5cdFx0dGhpcy5fbWFwLl9jb250YWluZXIuZm9jdXMoKTtcblxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xuXHR9LFxuXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZm9jdXNlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2ZvY3VzJyk7XG5cdH0sXG5cblx0X29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9tYXAuZmlyZSgnYmx1cicpO1xuXHR9LFxuXG5cdF9zZXRQYW5EZWx0YTogZnVuY3Rpb24gKHBhbkRlbHRhKSB7XG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMubGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5sZWZ0W2ldXSA9IFstMSAqIHBhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMucmlnaHRbaV1dID0gW3BhbkRlbHRhLCAwXTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuZG93bi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5EZWx0YV07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnVwW2ldXSA9IFswLCAtMSAqIHBhbkRlbHRhXTtcblx0XHR9XG5cdH0sXG5cblx0X3NldFpvb21EZWx0YTogZnVuY3Rpb24gKHpvb21EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fem9vbUtleXMgPSB7fSxcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tSW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb21EZWx0YTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbU91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy56b29tT3V0W2ldXSA9IC16b29tRGVsdGE7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb2Zmc2V0O1xuXG5cdFx0aWYgKGtleSBpbiB0aGlzLl9wYW5LZXlzKSB7XG5cblx0XHRcdGlmIChtYXAuX3BhbkFuaW0gJiYgbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRpZiAoZS5zaGlmdEtleSkge1xuXHRcdFx0XHRvZmZzZXQgPSB0b1BvaW50KG9mZnNldCkubXVsdGlwbHlCeSgzKTtcblx0XHRcdH1cblxuXHRcdFx0bWFwLnBhbkJ5KG9mZnNldCk7XG5cblx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcblx0XHRcdFx0bWFwLnBhbkluc2lkZUJvdW5kcyhtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmIChrZXkgaW4gdGhpcy5fem9vbUtleXMpIHtcblx0XHRcdG1hcC5zZXRab29tKG1hcC5nZXRab29tKCkgKyAoZS5zaGlmdEtleSA/IDMgOiAxKSAqIHRoaXMuX3pvb21LZXlzW2tleV0pO1xuXG5cdFx0fSBlbHNlIGlmIChrZXkgPT09IDI3ICYmIG1hcC5fcG9wdXAgJiYgbWFwLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHN0b3AoZSk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBrZXlib2FyZDogSGFuZGxlclxuLy8gS2V5Ym9hcmQgbmF2aWdhdGlvbiBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2tleWJvYXJkJywgS2V5Ym9hcmQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9tYXAvaGFuZGxlci9NYXAuS2V5Ym9hcmQuanMiLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBMLkhhbmRsZXIuU2Nyb2xsV2hlZWxab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gZW5hYmxlIG1vdXNlIHNjcm9sbCB3aGVlbCB6b29tIG9uIHRoZSBtYXAuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBNb3VzZXdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbldoZWVsU2Nyb2xsOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBkZWx0YSA9IERvbUV2ZW50LmdldFdoZWVsRGVsdGEoZSk7XG5cblx0XHR2YXIgZGVib3VuY2UgPSB0aGlzLl9tYXAub3B0aW9ucy53aGVlbERlYm91bmNlVGltZTtcblxuXHRcdHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdGlmICghdGhpcy5fc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcblx0XHR9XG5cblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KGRlYm91bmNlIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcblxuXHRcdERvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgU2Nyb2xsV2hlZWxab29tKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLlNjcm9sbFdoZWVsWm9vbS5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG5cbi8qXG4gKiBMLk1hcC5UYXAgaXMgdXNlZCB0byBlbmFibGUgbW9iaWxlIGhhY2tzIGxpa2UgcXVpY2sgdGFwcyBhbmQgbG9uZyBob2xkLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRhcDogQm9vbGVhbiA9IHRydWVcblx0Ly8gRW5hYmxlcyBtb2JpbGUgaGFja3MgZm9yIHN1cHBvcnRpbmcgaW5zdGFudCB0YXBzIChmaXhpbmcgMjAwbXMgY2xpY2tcblx0Ly8gZGVsYXkgb24gaU9TL0FuZHJvaWQpIGFuZCB0b3VjaCBob2xkcyAoZmlyZWQgYXMgYGNvbnRleHRtZW51YCBldmVudHMpLlxuXHR0YXA6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuZXhwb3J0IHZhciBUYXAgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMpIHsgcmV0dXJuOyB9XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cblx0XHQvLyBpZiB0b3VjaGluZyBhIGxpbmssIGhpZ2hsaWdodCBpdFxuXHRcdGlmIChlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcblx0XHR9XG5cblx0XHQvLyBzaW11bGF0ZSBsb25nIGhvbGQgYnV0IHNldHRpbmcgYSB0aW1lb3V0XG5cdFx0dGhpcy5faG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XG5cdFx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vblVwKCk7XG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpLCAxMDAwKTtcblxuXHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNlZG93bicsIGZpcnN0KTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwge1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLl9vbk1vdmUsXG5cdFx0XHR0b3VjaGVuZDogdGhpcy5fb25VcFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcblxuXHRcdFx0dmFyIGZpcnN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXSxcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcblxuXHRcdFx0aWYgKGVsICYmIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ21vdXNldXAnLCBmaXJzdCk7XG5cblx0XHRcdC8vIHNpbXVsYXRlIGNsaWNrIGlmIHRoZSB0b3VjaCBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0ZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrID0gdHJ1ZTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdCAgICAgICAgdHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLFxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXG5cdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcblx0XHQgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbi8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuaWYgKEJyb3dzZXIudG91Y2ggJiYgIUJyb3dzZXIucG9pbnRlcikge1xuXHRNYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwJywgVGFwKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbWFwL2hhbmRsZXIvTWFwLlRhcC5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLlRvdWNoWm9vbSBpcyB1c2VkIGJ5IEwuTWFwIHRvIGFkZCBwaW5jaCB6b29tIG9uIHN1cHBvcnRlZCBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAc2VjdGlvbiBUb3VjaCBpbnRlcmFjdGlvbiBvcHRpb25zXG5cdC8vIEBvcHRpb24gdG91Y2hab29tOiBCb29sZWFufFN0cmluZyA9ICpcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdG91Y2gtZHJhZ2dpbmcgd2l0aCB0d28gZmluZ2Vycy4gSWZcblx0Ly8gcGFzc2VkIGAnY2VudGVyJ2AsIGl0IHdpbGwgem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3IHJlZ2FyZGxlc3Mgb2Zcblx0Ly8gd2hlcmUgdGhlIHRvdWNoIGV2ZW50cyAoZmluZ2Vycykgd2VyZS4gRW5hYmxlZCBmb3IgdG91Y2gtY2FwYWJsZSB3ZWJcblx0Ly8gYnJvd3NlcnMgZXhjZXB0IGZvciBvbGQgQW5kcm9pZHMuXG5cdHRvdWNoWm9vbTogQnJvd3Nlci50b3VjaCAmJiAhQnJvd3Nlci5hbmRyb2lkMjMsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSk7XG5cdFx0dGhpcy5fYW5pbVJlcXVlc3QgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuXHR9LFxuXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCB8fCAhdGhpcy5fem9vbWluZykge1xuXHRcdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcblxuXHRcdC8vIFBpbmNoIHVwZGF0ZXMgR3JpZExheWVycycgbGV2ZWxzIG9ubHkgd2hlbiB6b29tU25hcCBpcyBvZmYsIHNvIHpvb21TbmFwIGJlY29tZXMgbm9VcGRhdGUuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLCB0aGlzLl9tYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSwgdHJ1ZSwgdGhpcy5fbWFwLm9wdGlvbnMuem9vbVNuYXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRvdWNoWm9vbTogSGFuZGxlclxuLy8gVG91Y2ggem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RvdWNoWm9vbScsIFRvdWNoWm9vbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL21hcC9oYW5kbGVyL01hcC5Ub3VjaFpvb20uanMiLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5MYXllcnNcclxuICogQGFrYSBMLkNvbnRyb2wuTGF5ZXJzXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBsYXllcnMgY29udHJvbCBnaXZlcyB1c2VycyB0aGUgYWJpbGl0eSB0byBzd2l0Y2ggYmV0d2VlbiBkaWZmZXJlbnQgYmFzZSBsYXllcnMgYW5kIHN3aXRjaCBvdmVybGF5cyBvbi9vZmYgKGNoZWNrIG91dCB0aGUgW2RldGFpbGVkIGV4YW1wbGVdKGh0dHA6Ly9sZWFmbGV0anMuY29tL2V4YW1wbGVzL2xheWVycy1jb250cm9sLykpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMYXllcnMgPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuTGF5ZXJzIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIGNvbGxhcHNlZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBiZSBjb2xsYXBzZWQgaW50byBhbiBpY29uIGFuZCBleHBhbmRlZCBvbiBtb3VzZSBob3ZlciBvciB0b3VjaC5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihiYXNlTGF5ZXJzW2ldLCBpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgaW4gb3ZlcmxheXMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIob3ZlcmxheXNbaV0sIGksIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRDb250cm9sLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XHJcblx0XHQvLyBUcmlnZ2VyIGV4cGFuZCBhZnRlciBMYXllcnMgQ29udHJvbCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIERPTSBzbyB0aGF0IGlzIG5vdyBoYXMgYW4gYWN0dWFsIGhlaWdodC5cclxuXHRcdHJldHVybiB0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLmxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkQmFzZUxheWVyKGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYSBiYXNlIGxheWVyIChyYWRpbyBidXR0b24gZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkQmFzZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZE92ZXJsYXkobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBvdmVybGF5IChjaGVja2JveCBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRPdmVybGF5OiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUpIHtcclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lLCB0cnVlKTtcclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUxheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBSZW1vdmUgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGNvbnRyb2wuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0bGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG9iaiA9IHRoaXMuX2dldExheWVyKFV0aWwuc3RhbXAobGF5ZXIpKTtcclxuXHRcdGlmIChvYmopIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihvYmopLCAxKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAodGhpcy5fbWFwKSA/IHRoaXMuX3VwZGF0ZSgpIDogdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGV4cGFuZCgpOiB0aGlzXHJcblx0Ly8gRXhwYW5kIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBjb2xsYXBzZWQuXHJcblx0ZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX2Zvcm0uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fZm9ybSwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gYWNjZXB0YWJsZUhlaWdodCArICdweCc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2Zvcm0sICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhcicpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb2xsYXBzZSgpOiB0aGlzXHJcblx0Ly8gQ29sbGFwc2UgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGV4cGFuZGVkLlxyXG5cdGNvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxyXG5cdFx0ICAgIGNvbGxhcHNlZCA9IHRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHREb21FdmVudC5kaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHJcblx0XHR2YXIgZm9ybSA9IHRoaXMuX2Zvcm0gPSBEb21VdGlsLmNyZWF0ZSgnZm9ybScsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmIChjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuY29sbGFwc2UsIHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKCFCcm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRcdG1vdXNlZW50ZXI6IHRoaXMuZXhwYW5kLFxyXG5cdFx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxpbmsgPSB0aGlzLl9sYXllcnNMaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gJ0xheWVycyc7XHJcblxyXG5cdFx0aWYgKEJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctYmFzZScsIGZvcm0pO1xyXG5cdFx0dGhpcy5fc2VwYXJhdG9yID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgZm9ybSk7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIGZvcm0pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgVXRpbC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHRsYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycy5wdXNoKHtcclxuXHRcdFx0bGF5ZXI6IGxheWVyLFxyXG5cdFx0XHRuYW1lOiBuYW1lLFxyXG5cdFx0XHRvdmVybGF5OiBvdmVybGF5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNvcnRMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzLnNvcnQoVXRpbC5iaW5kKGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0RnVuY3Rpb24oYS5sYXllciwgYi5sYXllciwgYS5uYW1lLCBiLm5hbWUpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHREb21VdGlsLmVtcHR5KHRoaXMuX292ZXJsYXlzTGlzdCk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihVdGlsLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMucHVzaChpbnB1dCk7XHJcblx0XHRpbnB1dC5sYXllcklkID0gVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGlucHV0LCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG5cdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcclxuXHJcblx0XHQvLyBIZWxwcyBmcm9tIHByZXZlbnRpbmcgbGF5ZXIgY29udHJvbCBmbGlja2VyIHdoZW4gY2hlY2tib3hlcyBhcmUgZGlzYWJsZWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzI3NzFcclxuXHRcdHZhciBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsIGxheWVyO1xyXG5cdFx0dmFyIGFkZGVkTGF5ZXJzID0gW10sXHJcblx0XHQgICAgcmVtb3ZlZExheWVycyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG5cdFx0XHRcdGFkZGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0cmVtb3ZlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJ1Z2ZpeCBpc3N1ZSAyMzE4OiBTaG91bGQgcmVtb3ZlIGFsbCBvbGQgbGF5ZXJzIGJlZm9yZSByZWFkZGluZyBuZXcgb25lc1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuX21hcC5oYXNMYXllcihyZW1vdmVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihyZW1vdmVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGFkZGVkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5fbWFwLmhhc0xheWVyKGFkZGVkTGF5ZXJzW2ldKSkge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihhZGRlZExheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsXHJcblx0XHQgICAgaW5wdXQsXHJcblx0XHQgICAgbGF5ZXIsXHJcblx0XHQgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHRcdFx0aW5wdXQuZGlzYWJsZWQgPSAobGF5ZXIub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA8IGxheWVyLm9wdGlvbnMubWluWm9vbSkgfHxcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAobGF5ZXIub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgem9vbSA+IGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9leHBhbmRJZk5vdENvbGxhcHNlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmV4cGFuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgcmVtb3ZlIG1lIGluIDEuMS5cclxuXHRcdHJldHVybiB0aGlzLmNvbGxhcHNlKCk7XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmxheWVycyhiYXNlbGF5ZXJzPzogT2JqZWN0LCBvdmVybGF5cz86IE9iamVjdCwgb3B0aW9ucz86IENvbnRyb2wuTGF5ZXJzIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbCB3aXRoIHRoZSBnaXZlbiBsYXllcnMuIEJhc2UgbGF5ZXJzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCByYWRpbyBidXR0b25zLCB3aGlsZSBvdmVybGF5cyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggY2hlY2tib3hlcy4gTm90ZSB0aGF0IGFsbCBiYXNlIGxheWVycyBzaG91bGQgYmUgcGFzc2VkIGluIHRoZSBiYXNlIGxheWVycyBvYmplY3QsIGJ1dCBvbmx5IG9uZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG1hcCBkdXJpbmcgbWFwIGluc3RhbnRpYXRpb24uXHJcbmV4cG9ydCB2YXIgbGF5ZXJzID0gZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2NvbnRyb2wvQ29udHJvbC5MYXllcnMuanMiLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuWm9vbVxyXG4gKiBAYWthIEwuQ29udHJvbC5ab29tXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIEEgYmFzaWMgem9vbSBjb250cm9sIHdpdGggdHdvIGJ1dHRvbnMgKHpvb20gaW4gYW5kIHpvb20gb3V0KS4gSXQgaXMgcHV0IG9uIHRoZSBtYXAgYnkgZGVmYXVsdCB1bmxlc3MgeW91IHNldCBpdHMgW2B6b29tQ29udHJvbGAgb3B0aW9uXSgjbWFwLXpvb21jb250cm9sKSB0byBgZmFsc2VgLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIFpvb20gPSBDb250cm9sLmV4dGVuZCh7XHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIENvbnRyb2wuWm9vbSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21JblRleHQ6IFN0cmluZyA9ICcrJ1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGV4dDogJysnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJyYjeDIyMTI7J1xyXG5cdFx0Ly8gVGhlIHRleHQgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUZXh0OiAnJiN4MjIxMjsnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCB6b29tTmFtZSArICcgbGVhZmxldC1iYXInKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24ob3B0aW9ucy56b29tSW5UZXh0LCBvcHRpb25zLnpvb21JblRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctaW4nLCAgY29udGFpbmVyLCB0aGlzLl96b29tSW4pO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21PdXRUZXh0LCBvcHRpb25zLnpvb21PdXRUaXRsZSxcclxuXHRcdCAgICAgICAgem9vbU5hbWUgKyAnLW91dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdG1hcC5vbignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBjb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ3pvb21lbmQgem9vbWxldmVsc2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc2FibGVkLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA8IHRoaXMuX21hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21Jbih0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2Rpc2FibGVkICYmIHRoaXMuX21hcC5fem9vbSA+IHRoaXMuX21hcC5nZXRNaW5ab29tKCkpIHtcclxuXHRcdFx0dGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhICogKGUuc2hpZnRLZXkgPyAzIDogMSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuKSB7XHJcblx0XHR2YXIgbGluayA9IERvbVV0aWwuY3JlYXRlKCdhJywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0bGluay5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0bGluay5ocmVmID0gJyMnO1xyXG5cdFx0bGluay50aXRsZSA9IHRpdGxlO1xyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBXaWxsIGZvcmNlIHNjcmVlbiByZWFkZXJzIGxpa2UgVm9pY2VPdmVyIHRvIHJlYWQgdGhpcyBhcyBcIlpvb20gaW4gLSBidXR0b25cIlxyXG5cdFx0ICovXHJcblx0XHRsaW5rLnNldEF0dHJpYnV0ZSgncm9sZScsICdidXR0b24nKTtcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGxpbmspO1xyXG5cdFx0RG9tRXZlbnQub24obGluaywgJ2NsaWNrJywgRG9tRXZlbnQuc3RvcCk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcyk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9yZWZvY3VzT25NYXAsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiBsaW5rO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBjbGFzc05hbWUgPSAnbGVhZmxldC1kaXNhYmxlZCc7XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWF4Wm9vbSgpKSB7XHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdHRoaXMuem9vbUNvbnRyb2wgPSBuZXcgWm9vbSgpO1xyXG5cdFx0dGhpcy5hZGRDb250cm9sKHRoaXMuem9vbUNvbnRyb2wpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuWm9vbVxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuem9vbShvcHRpb25zOiBDb250cm9sLlpvb20gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhIHpvb20gY29udHJvbFxyXG5leHBvcnQgdmFyIHpvb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgWm9vbShvcHRpb25zKTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9jb250cm9sL0NvbnRyb2wuWm9vbS5qcyIsIlxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgQ29udHJvbC5TY2FsZVxuICogQGFrYSBMLkNvbnRyb2wuU2NhbGVcbiAqIEBpbmhlcml0cyBDb250cm9sXG4gKlxuICogQSBzaW1wbGUgc2NhbGUgY29udHJvbCB0aGF0IHNob3dzIHRoZSBzY2FsZSBvZiB0aGUgY3VycmVudCBjZW50ZXIgb2Ygc2NyZWVuIGluIG1ldHJpYyAobS9rbSkgYW5kIGltcGVyaWFsIChtaS9mdCkgc3lzdGVtcy4gRXh0ZW5kcyBgQ29udHJvbGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogTC5jb250cm9sLnNjYWxlKCkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU2NhbGUgPSBDb250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9hZGRTY2FsZXMob3B0aW9ucywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcblxuXHRcdG1hcC5vbihvcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHRcdG1hcC53aGVuUmVhZHkodGhpcy5fdXBkYXRlLCB0aGlzKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAub2ZmKHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRfYWRkU2NhbGVzOiBmdW5jdGlvbiAob3B0aW9ucywgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcblx0XHRcdHRoaXMuX21TY2FsZSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XG5cdFx0XHR0aGlzLl9pU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0bWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoWzAsIHldKSxcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsIHldKSk7XG5cblx0XHR0aGlzLl91cGRhdGVTY2FsZXMobWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlU2NhbGVzOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tZXRyaWMgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVNZXRyaWMobWF4TWV0ZXJzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbXBlcmlhbCAmJiBtYXhNZXRlcnMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVNZXRyaWM6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWV0ZXJzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWV0ZXJzKSxcblx0XHQgICAgbGFiZWwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5fbVNjYWxlLCBsYWJlbCwgbWV0ZXJzIC8gbWF4TWV0ZXJzKTtcblx0fSxcblxuXHRfdXBkYXRlSW1wZXJpYWw6IGZ1bmN0aW9uIChtYXhNZXRlcnMpIHtcblx0XHR2YXIgbWF4RmVldCA9IG1heE1ldGVycyAqIDMuMjgwODM5OSxcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xuXG5cdFx0aWYgKG1heEZlZXQgPiA1MjgwKSB7XG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xuXHRcdFx0bWlsZXMgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhNaWxlcyk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIG1pbGVzICsgJyBtaScsIG1pbGVzIC8gbWF4TWlsZXMpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZlZXQgPSB0aGlzLl9nZXRSb3VuZE51bShtYXhGZWV0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX2lTY2FsZSwgZmVldCArICcgZnQnLCBmZWV0IC8gbWF4RmVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVTY2FsZTogZnVuY3Rpb24gKHNjYWxlLCB0ZXh0LCByYXRpbykge1xuXHRcdHNjYWxlLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgKyAncHgnO1xuXHRcdHNjYWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdH0sXG5cblx0X2dldFJvdW5kTnVtOiBmdW5jdGlvbiAobnVtKSB7XG5cdFx0dmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcblxuXHRcdGQgPSBkID49IDEwID8gMTAgOlxuXHRcdCAgICBkID49IDUgPyA1IDpcblx0XHQgICAgZCA+PSAzID8gMyA6XG5cdFx0ICAgIGQgPj0gMiA/IDIgOiAxO1xuXG5cdFx0cmV0dXJuIHBvdzEwICogZDtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5jb250cm9sLnNjYWxlKG9wdGlvbnM/OiBDb250cm9sLlNjYWxlIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGFuIHNjYWxlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCB2YXIgc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNjYWxlKG9wdGlvbnMpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29udHJvbC9Db250cm9sLlNjYWxlLmpzIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwuVmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0YXV0b3BsYXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsb29wOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBsb29wIGJhY2sgdG8gdGhlIGJlZ2lubmluZyB3aGVuIHBsYXllZC5cclxuXHRcdGxvb3A6IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cclxuXHRcdHZpZC5vbnNlbGVjdHN0YXJ0ID0gVXRpbC5mYWxzZUZuO1xyXG5cdFx0dmlkLm9ubW91c2Vtb3ZlID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIGZpcnN0IGZyYW1lXHJcblx0XHR2aWQub25sb2FkZWRkYXRhID0gVXRpbC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ2xvYWQnKTtcclxuXHJcblx0XHRpZiAod2FzRWxlbWVudFN1cHBsaWVkKSB7XHJcblx0XHRcdHZhciBzb3VyY2VFbGVtZW50cyA9IHZpZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc291cmNlJyk7XHJcblx0XHRcdHZhciBzb3VyY2VzID0gW107XHJcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc291cmNlRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRzb3VyY2VzLnB1c2goc291cmNlRWxlbWVudHNbal0uc3JjKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdXJsID0gKHNvdXJjZUVsZW1lbnRzLmxlbmd0aCA+IDApID8gc291cmNlcyA6IFt2aWQuc3JjXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghVXRpbC5pc0FycmF5KHRoaXMuX3VybCkpIHsgdGhpcy5fdXJsID0gW3RoaXMuX3VybF07IH1cclxuXHJcblx0XHR2aWQuYXV0b3BsYXkgPSAhIXRoaXMub3B0aW9ucy5hdXRvcGxheTtcclxuXHRcdHZpZC5sb29wID0gISF0aGlzLm9wdGlvbnMubG9vcDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvVmlkZW9PdmVybGF5LmpzIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7UGF0aH0gZnJvbSAnLi92ZWN0b3IvUGF0aCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgUG9wdXBcclxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcclxuICogQGFrYSBMLlBvcHVwXHJcbiAqIFVzZWQgdG8gb3BlbiBwb3B1cHMgaW4gY2VydGFpbiBwbGFjZXMgb2YgdGhlIG1hcC4gVXNlIFtNYXAub3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgdG9cclxuICogb3BlbiBwb3B1cHMgd2hpbGUgbWFraW5nIHN1cmUgdGhhdCBvbmx5IG9uZSBwb3B1cCBpcyBvcGVuIGF0IG9uZSB0aW1lXHJcbiAqIChyZWNvbW1lbmRlZCBmb3IgdXNhYmlsaXR5KSwgb3IgdXNlIFtNYXAuYWRkTGF5ZXJdKCNtYXAtYWRkbGF5ZXIpIHRvIG9wZW4gYXMgbWFueSBhcyB5b3Ugd2FudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogSWYgeW91IHdhbnQgdG8ganVzdCBiaW5kIGEgcG9wdXAgdG8gbWFya2VyIGNsaWNrIGFuZCB0aGVuIG9wZW4gaXQsIGl0J3MgcmVhbGx5IGVhc3k6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcmtlci5iaW5kUG9wdXAocG9wdXBDb250ZW50KS5vcGVuUG9wdXAoKTtcclxuICogYGBgXHJcbiAqIFBhdGggb3ZlcmxheXMgbGlrZSBwb2x5bGluZXMgYWxzbyBoYXZlIGEgYGJpbmRQb3B1cGAgbWV0aG9kLlxyXG4gKiBIZXJlJ3MgYSBtb3JlIGNvbXBsaWNhdGVkIHdheSB0byBvcGVuIGEgcG9wdXAgb24gYSBtYXA6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb3B1cCA9IEwucG9wdXAoKVxyXG4gKiBcdC5zZXRMYXRMbmcobGF0bG5nKVxyXG4gKiBcdC5zZXRDb250ZW50KCc8cD5IZWxsbyB3b3JsZCE8YnIgLz5UaGlzIGlzIGEgbmljZSBwb3B1cC48L3A+JylcclxuICogXHQub3Blbk9uKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvcHVwXHJcbmV4cG9ydCB2YXIgUG9wdXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gYW5vdGhlciBwb3B1cCBpcyBvcGVuZWQuXHJcblx0XHRhdXRvQ2xvc2U6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uRXNjYXBlS2V5OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBFU0Mga2V5IGZvciBjbG9zaW5nIG9mIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlT25Fc2NhcGVLZXk6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbG9zZU9uQ2xpY2s6IEJvb2xlYW4gPSAqXHJcblx0XHQvLyBTZXQgaXQgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiB1c2VyIGNsaWNrc1xyXG5cdFx0Ly8gb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdGhlIG1hcCdzIFtgY2xvc2VQb3B1cE9uQ2xpY2tgXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24uXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBBIGN1c3RvbSBDU1MgY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHBvcHVwLlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdC8vIEBuYW1lc3BhY2UgUG9wdXBcclxuXHQvLyBAbWV0aG9kIG9wZW5PbihtYXA6IE1hcCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBwb3B1cCB0byB0aGUgbWFwIGFuZCBjbG9zZXMgdGhlIHByZXZpb3VzIG9uZS4gVGhlIHNhbWUgYXMgYG1hcC5vcGVuUG9wdXAocG9wdXApYC5cclxuXHRvcGVuT246IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vcGVuUG9wdXAodGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vbigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcblx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9mZigncHJlY2xpY2snLCBEb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgIT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsXHJcblx0XHRcdHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArXHJcblx0XHRcdCcgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudCcsIHdyYXBwZXIpO1xyXG5cclxuXHRcdERvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHdyYXBwZXIpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKTtcclxuXHRcdERvbUV2ZW50Lm9uKHdyYXBwZXIsICdjb250ZXh0bWVudScsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBEb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcclxuXHJcblx0XHRcdERvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuIHx8ICh0aGlzLl9tYXAuX3BhbkFuaW0gJiYgdGhpcy5fbWFwLl9wYW5BbmltLl9pblByb2dyZXNzKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KERvbVV0aWwuZ2V0U3R5bGUodGhpcy5fY29udGFpbmVyLCAnbWFyZ2luQm90dG9tJyksIDEwKSB8fCAwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQgKyBtYXJnaW5Cb3R0b20sXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHRcdCAgICBsYXllclBvcyA9IG5ldyBQb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBhdXRvcGFuc3RhcnQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIGF1dG9wYW5uaW5nIHdoZW4gb3BlbmluZyBhIHBvcHVwLlxyXG5cdFx0aWYgKGR4IHx8IGR5KSB7XHJcblx0XHRcdG1hcFxyXG5cdFx0XHQgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXHJcblx0XHRcdCAgICAucGFuQnkoW2R4LCBkeV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkNsb3NlQnV0dG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9jbG9zZSgpO1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IFBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQocG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXRsbmcpIHtcclxuXHRcdFx0cG9wdXAuc2V0TGF0TG5nKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIocG9wdXApKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSkge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFBvcHVwKSB7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBjb250ZW50O1xyXG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAgPSBuZXcgUG9wdXAob3B0aW9ucywgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xyXG5cdFx0XHR0aGlzLm9uKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBwb3B1cCBwcmV2aW91c2x5IGJvdW5kIHdpdGggYGJpbmRQb3B1cGAuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0Y2xpY2s6IHRoaXMuX29wZW5Qb3B1cCxcclxuXHRcdFx0XHRrZXlwcmVzczogdGhpcy5fb25LZXlQcmVzcyxcclxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcclxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHBvcHVwIGF0IHRoZSBzcGVjaWZpZWQgYGxhdGxuZ2Agb3IgYXQgdGhlIGRlZmF1bHQgcG9wdXAgYW5jaG9yIGlmIG5vIGBsYXRsbmdgIGlzIHBhc3NlZC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XHJcblx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIExheWVyKSkge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxhdGxuZykge1xyXG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0Ly8gc2V0IHBvcHVwIHNvdXJjZSB0byB0aGlzIGxheWVyXHJcblx0XHRcdHRoaXMuX3BvcHVwLl9zb3VyY2UgPSBsYXllcjtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgcG9wdXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxyXG5cdFx0XHR0aGlzLl9wb3B1cC51cGRhdGUoKTtcclxuXHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0dGhpcy5fbWFwLm9wZW5Qb3B1cCh0aGlzLl9wb3B1cCwgbGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlUG9wdXAoKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxyXG5cdGlzUG9wdXBPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gKHRoaXMuX3BvcHVwID8gdGhpcy5fcG9wdXAuaXNPcGVuKCkgOiBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0c2V0UG9wdXBDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXHJcblx0Ly8gUmV0dXJucyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllci5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmV2ZW50IG1hcCBjbGlja1xyXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcclxuXHJcblx0XHQvLyBpZiB0aGlzIGluaGVyaXRzIGZyb20gUGF0aCBpdHMgYSB2ZWN0b3IgYW5kIHdlIGNhbiBqdXN0XHJcblx0XHQvLyBvcGVuIHRoZSBwb3B1cCBhdCB0aGUgbmV3IGxvY2F0aW9uXHJcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBQYXRoKSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG90aGVyd2lzZSB0cmVhdCBpdCBsaWtlIGEgbWFya2VyIGFuZCBmaWd1cmUgb3V0XHJcblx0XHQvLyBpZiB3ZSBzaG91bGQgdG9nZ2xlIGl0IG9wZW4vY2xvc2VkXHJcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X21vdmVQb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5UHJlc3M6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX29wZW5Qb3B1cChlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL1BvcHVwLmpzIiwiXG5pbXBvcnQgKiBhcyBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQge0Rpdk92ZXJsYXl9IGZyb20gJy4vRGl2T3ZlcmxheSc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuaW1wb3J0IHtGZWF0dXJlR3JvdXB9IGZyb20gJy4vRmVhdHVyZUdyb3VwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIFRvb2x0aXBcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XG4gKiBAYWthIEwuVG9vbHRpcFxuICogVXNlZCB0byBkaXNwbGF5IHNtYWxsIHRleHRzIG9uIHRvcCBvZiBtYXAgbGF5ZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIG1hcmtlci5iaW5kVG9vbHRpcChcIm15IHRvb2x0aXAgdGV4dFwiKS5vcGVuVG9vbHRpcCgpO1xuICogYGBgXG4gKiBOb3RlIGFib3V0IHRvb2x0aXAgb2Zmc2V0LiBMZWFmbGV0IHRha2VzIHR3byBvcHRpb25zIGluIGNvbnNpZGVyYXRpb25cbiAqIGZvciBjb21wdXRpbmcgdG9vbHRpcCBvZmZzZXR0aW5nOlxuICogLSB0aGUgYG9mZnNldGAgVG9vbHRpcCBvcHRpb246IGl0IGRlZmF1bHRzIHRvIFswLCAwXSwgYW5kIGl0J3Mgc3BlY2lmaWMgdG8gb25lIHRvb2x0aXAuXG4gKiAgIEFkZCBhIHBvc2l0aXZlIHggb2Zmc2V0IHRvIG1vdmUgdGhlIHRvb2x0aXAgdG8gdGhlIHJpZ2h0LCBhbmQgYSBwb3NpdGl2ZSB5IG9mZnNldCB0b1xuICogICBtb3ZlIGl0IHRvIHRoZSBib3R0b20uIE5lZ2F0aXZlcyB3aWxsIG1vdmUgdG8gdGhlIGxlZnQgYW5kIHRvcC5cbiAqIC0gdGhlIGB0b29sdGlwQW5jaG9yYCBJY29uIG9wdGlvbjogdGhpcyB3aWxsIG9ubHkgYmUgY29uc2lkZXJlZCBmb3IgTWFya2VyLiBZb3VcbiAqICAgc2hvdWxkIGFkYXB0IHRoaXMgdmFsdWUgaWYgeW91IHVzZSBhIGN1c3RvbSBpY29uLlxuICovXG5cblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG5leHBvcnQgdmFyIFRvb2x0aXAgPSBEaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FsbHkgc3dpdGNoIGJldHdlZW4gYHJpZ2h0YCBhbmQgYGxlZnRgIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcFxuXHRcdC8vIHBvc2l0aW9uIG9uIHRoZSBtYXAuXG5cdFx0ZGlyZWN0aW9uOiAnYXV0bycsXG5cblx0XHQvLyBAb3B0aW9uIHBlcm1hbmVudDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0byBvcGVuIHRoZSB0b29sdGlwIHBlcm1hbmVudGx5IG9yIG9ubHkgb24gbW91c2VvdmVyLlxuXHRcdHBlcm1hbmVudDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIHN0aWNreTogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHRvb2x0aXAgd2lsbCBmb2xsb3cgdGhlIG1vdXNlIGluc3RlYWQgb2YgYmVpbmcgZml4ZWQgYXQgdGhlIGZlYXR1cmUgY2VudGVyLlxuXHRcdHN0aWNreTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBldmVudHMuXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAwLjlcblx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBvcGFjaXR5LlxuXHRcdG9wYWNpdHk6IDAuOVxuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxuXHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHRvb2x0aXBvcGVuOiBUb29sdGlwRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBpcyBvcGVuZWQgaW4gdGhlIG1hcC5cblx0XHRtYXAuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKEJyb3dzZXIudG91Y2ggJiYgIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuX2Nsb3NlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0X2Nsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbWFwLmNsb3NlVG9vbHRpcCh0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHJlZml4ID0gJ2xlYWZsZXQtdG9vbHRpcCcsXG5cdFx0ICAgIGNsYXNzTmFtZSA9IHByZWZpeCArICcgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XG5cblx0XHR0aGlzLl9jb250ZW50Tm9kZSA9IHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KC10b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIC10b29sdGlwSGVpZ2h0ICsgb2Zmc2V0LnkgKyBhbmNob3IueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KHRvUG9pbnQodG9vbHRpcFdpZHRoIC8gMiAtIG9mZnNldC54LCAtb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdCh0b1BvaW50KHRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSArIG9mZnNldC55LCB0cnVlKSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnYXV0bycgJiYgdG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0cG9zID0gcG9zLmFkZCh0b1BvaW50KG9mZnNldC54ICsgYW5jaG9yLngsIGFuY2hvci55IC0gdG9vbHRpcEhlaWdodCAvIDIgKyBvZmZzZXQueSwgdHJ1ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludCh0b29sdGlwV2lkdGggKyBhbmNob3IueCAtIG9mZnNldC54LCB0b29sdGlwSGVpZ2h0IC8gMiAtIGFuY2hvci55IC0gb2Zmc2V0LnksIHRydWUpKTtcblx0XHR9XG5cblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIFRvb2x0aXAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgdG9vbHRpcCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXG5leHBvcnQgdmFyIHRvb2x0aXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG5cdHJldHVybiBuZXcgVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbk1hcC5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKHRvb2x0aXA6IFRvb2x0aXApOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBzcGVjaWZpZWQgdG9vbHRpcC5cblx0Ly8gQGFsdGVybmF0aXZlXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50LCBsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ3JlYXRlcyBhIHRvb2x0aXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW4gaXQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCwgbGF0bG5nLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEodG9vbHRpcCBpbnN0YW5jZW9mIFRvb2x0aXApKSB7XG5cdFx0XHR0b29sdGlwID0gbmV3IFRvb2x0aXAob3B0aW9ucykuc2V0Q29udGVudCh0b29sdGlwKTtcblx0XHR9XG5cblx0XHRpZiAobGF0bG5nKSB7XG5cdFx0XHR0b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb258VG9vbHRpcCwgb3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSB0b29sdGlwIHRvIHRoZSBsYXllciB3aXRoIHRoZSBwYXNzZWQgYGNvbnRlbnRgIGFuZCBzZXRzIHVwIHRoZVxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIFRvb2x0aXApIHtcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBjb250ZW50O1xuXHRcdFx0Y29udGVudC5fc291cmNlID0gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCF0aGlzLl90b29sdGlwIHx8IG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBUb29sdGlwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllcjtcblx0XHRcdGxheWVyID0gdGhpcztcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApIHtcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbGF0bG5nKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuX21hcCkge1xuXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBzb3VyY2UgdG8gdGhpcyBsYXllclxuXHRcdFx0dGhpcy5fdG9vbHRpcC5fc291cmNlID0gbGF5ZXI7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgdG9vbHRpcCAoY29udGVudCwgbGF5b3V0LCBlY3QuLi4pXG5cdFx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLCBsYXRsbmcpO1xuXG5cdFx0XHQvLyBUb29sdGlwIGNvbnRhaW5lciBtYXkgbm90IGJlIGRlZmluZWQgaWYgbm90IHBlcm1hbmVudCBhbmQgbmV2ZXJcblx0XHRcdC8vIG9wZW5lZC5cblx0XHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVUb29sdGlwKCk6IHRoaXNcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgZGVwZW5kaW5nIG9uIGl0cyBjdXJyZW50IHN0YXRlLlxuXHR0b2dnbGVUb29sdGlwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICh0aGlzLl90b29sdGlwLl9tYXApIHtcblx0XHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblRvb2x0aXAodGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQ7XG5cblx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9wZW5Ub29sdGlwKGxheWVyLCB0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2xheWVyL1Rvb2x0aXAuanMiLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5leHBvcnQge2ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge0ljb25EZWZhdWx0fSBmcm9tICcuL0ljb24uRGVmYXVsdCc7XG5JY29uLkRlZmF1bHQgPSBJY29uRGVmYXVsdDtcbmV4cG9ydCB7SWNvbn07XG5cbmV4cG9ydCB7RGl2SWNvbiwgZGl2SWNvbn0gZnJvbSAnLi9EaXZJY29uJztcbmV4cG9ydCB7TWFya2VyLCBtYXJrZXJ9IGZyb20gJy4vTWFya2VyJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHt0b1BvaW50IGFzIHBvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5cbi8qXG4gKiBAY2xhc3MgRGl2SWNvblxuICogQGFrYSBMLkRpdkljb25cbiAqIEBpbmhlcml0cyBJY29uXG4gKlxuICogUmVwcmVzZW50cyBhIGxpZ2h0d2VpZ2h0IGljb24gZm9yIG1hcmtlcnMgdGhhdCB1c2VzIGEgc2ltcGxlIGA8ZGl2PmBcbiAqIGVsZW1lbnQgaW5zdGVhZCBvZiBhbiBpbWFnZS4gSW5oZXJpdHMgZnJvbSBgSWNvbmAgYnV0IGlnbm9yZXMgdGhlIGBpY29uVXJsYCBhbmQgc2hhZG93IG9wdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlJY29uID0gTC5kaXZJY29uKHtjbGFzc05hbWU6ICdteS1kaXYtaWNvbid9KTtcbiAqIC8vIHlvdSBjYW4gc2V0IC5teS1kaXYtaWNvbiBzdHlsZXMgaW4gQ1NTXG4gKlxuICogTC5tYXJrZXIoWzUwLjUwNSwgMzAuNTddLCB7aWNvbjogbXlJY29ufSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQsIGl0IGhhcyBhICdsZWFmbGV0LWRpdi1pY29uJyBDU1MgY2xhc3MgYW5kIGlzIHN0eWxlZCBhcyBhIGxpdHRsZSB3aGl0ZSBzcXVhcmUgd2l0aCBhIHNoYWRvdy5cbiAqL1xuXG5leHBvcnQgdmFyIERpdkljb24gPSBJY29uLmV4dGVuZCh7XG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAc2VjdGlvblxuXHRcdC8vIEBha2EgRGl2SWNvbiBvcHRpb25zXG5cdFx0aWNvblNpemU6IFsxMiwgMTJdLCAvLyBhbHNvIGNhbiBiZSBzZXQgdGhyb3VnaCBDU1NcblxuXHRcdC8vIGljb25BbmNob3I6IChQb2ludCksXG5cdFx0Ly8gcG9wdXBBbmNob3I6IChQb2ludCksXG5cblx0XHQvLyBAb3B0aW9uIGh0bWw6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQ3VzdG9tIEhUTUwgY29kZSB0byBwdXQgaW5zaWRlIHRoZSBkaXYgZWxlbWVudCwgZW1wdHkgYnkgZGVmYXVsdC5cblx0XHRodG1sOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gYmdQb3M6IFBvaW50ID0gWzAsIDBdXG5cdFx0Ly8gT3B0aW9uYWwgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGJhY2tncm91bmQsIGluIHBpeGVsc1xuXHRcdGJnUG9zOiBudWxsLFxuXG5cdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xuXHRcdHZhciBkaXYgPSAob2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdESVYnKSA/IG9sZEljb24gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGRpdi5pbm5lckhUTUwgPSBvcHRpb25zLmh0bWwgIT09IGZhbHNlID8gb3B0aW9ucy5odG1sIDogJyc7XG5cblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xuXHRcdFx0dmFyIGJnUG9zID0gcG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG5cdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZGl2SWNvbihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgRGl2SWNvbihvcHRpb25zKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9pbmRleC5qcyIsImV4cG9ydCB7UmVuZGVyZXJ9IGZyb20gJy4vUmVuZGVyZXInO1xuZXhwb3J0IHtDYW52YXMsIGNhbnZhc30gZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0IHtTVkcsIGNyZWF0ZSwgcG9pbnRzVG9QYXRoLCBzdmd9IGZyb20gJy4vU1ZHJztcblNWRy5jcmVhdGUgPSBjcmVhdGU7XG5TVkcucG9pbnRzVG9QYXRoID0gcG9pbnRzVG9QYXRoO1xuZXhwb3J0IHtTVkcsIHN2Z307XG5pbXBvcnQgJy4vUmVuZGVyZXIuZ2V0UmVuZGVyZXInO1x0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2ssIGJ1dCBuZWVkZWQgYmVjYXVzZSBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuZXhwb3J0IHtDaXJjbGVNYXJrZXIsIGNpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuZXhwb3J0IHtDaXJjbGUsIGNpcmNsZX0gZnJvbSAnLi9DaXJjbGUnO1xuZXhwb3J0IHtQb2x5bGluZSwgcG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuZXhwb3J0IHtQb2x5Z29uLCBwb2x5Z29ufSBmcm9tICcuL1BvbHlnb24nO1xuZXhwb3J0IHtSZWN0YW5nbGUsIHJlY3RhbmdsZX0gZnJvbSAnLi9SZWN0YW5nbGUnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvaW5kZXguanMiLCJpbXBvcnQge1BvbHlnb259IGZyb20gJy4vUG9seWdvbic7XG5pbXBvcnQge3RvTGF0TG5nQm91bmRzfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nQm91bmRzJztcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZWN0YW5nbGVcbiAqIEBpbmhlcml0cyBQb2x5Z29uXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyByZWN0YW5nbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBvbHlnb25gLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGRlZmluZSByZWN0YW5nbGUgZ2VvZ3JhcGhpY2FsIGJvdW5kc1xuICogdmFyIGJvdW5kcyA9IFtbNTQuNTU5MzIyLCAtNS43Njc4MjJdLCBbNTYuMTIxMDYwNCwgLTMuMDIxMjQwXV07XG4gKlxuICogLy8gY3JlYXRlIGFuIG9yYW5nZSByZWN0YW5nbGVcbiAqIEwucmVjdGFuZ2xlKGJvdW5kcywge2NvbG9yOiBcIiNmZjc4MDBcIiwgd2VpZ2h0OiAxfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHJlY3RhbmdsZSBib3VuZHNcbiAqIG1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAqIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCB2YXIgUmVjdGFuZ2xlID0gUG9seWdvbi5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdFx0UG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gcmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvUmVjdGFuZ2xlLmpzIiwiaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG5leHBvcnQgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHRcdH07XG5cdH1cbn0pKCk7XG5cblxuLypcbiAqIEBjbGFzcyBTVkdcbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydCBbVk1MXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfTWFya3VwX0xhbmd1YWdlKSwgYW5kIHRoZSBTVkcgcmVuZGVyZXIgd2lsbCBmYWxsIGJhY2sgdG8gVk1MIGluIHRoaXMgY2FzZS5cbiAqXG4gKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqL1xuXG4vLyBtaXhpbiB0byByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuZXhwb3J0IHZhciB2bWxNaXhpbiA9IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG5cdFx0bGF5ZXIuX3BhdGggPSB2bWxDcmVhdGUoJ3BhdGgnKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdERvbVV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG5cdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IHZtbENyZWF0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvU1ZHLlZNTC5qcyIsImltcG9ydCB7TWFwfSBmcm9tICcuLi8uLi9tYXAvTWFwJztcbmltcG9ydCB7Q2FudmFzLCBjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7U1ZHLCBzdmd9IGZyb20gJy4vU1ZHJztcblxuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgY2FudmFzKCkpIHx8IHN2ZygpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IChTVkcgJiYgc3ZnKHtwYW5lOiBuYW1lfSkpIHx8IChDYW52YXMgJiYgY2FudmFzKHtwYW5lOiBuYW1lfSkpO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9sYXllci92ZWN0b3IvUmVuZGVyZXIuZ2V0UmVuZGVyZXIuanMiLCJpbXBvcnQgeyBFbGVtZW50IGFzIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgRG9tUmVwZWF0IH0gZnJvbSAnLi4vLi4vQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5qcyc7XG5cbmltcG9ydCB7IHdtcyBhcyBXTVMgfSBmcm9tICcuL2xlYWZsZXQud21zLmpzJztcblxuaW1wb3J0ICcuL2xlYWZsZXQtd21zLWxheWVyLmpzJztcblxuXG5leHBvcnQgY2xhc3MgTGVhZmxldFdNU0dyb3VwIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIC8vIHJldHVybiBgXG4gICAgLy8gICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e3N1YkxheWVyc319XCI+XG4gICAgLy8gICAgIDxsZWFmbGV0LXdtcy1sYXllciB3bXMtc291cmNlPVwiW1t3bXNTb3VyY2VdXVwiIGxheWVyPVwiW1tpdGVtXV1cIj48L2xlYWZsZXQtd21zLWxheWVyPlxuICAgIC8vICAgPC90ZW1wbGF0ZT5cbiAgICAvLyBgO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBvYnNlcnZlcjogJ19tYXBTZXQnXG4gICAgICB9LFxuXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19zb3VyY2VDaGFuZ2UnLFxuICAgICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsYXllcnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIG9ic2VydmVyOiAnX2xheWVyc0NoYW5nZScsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgdHJhbnNwYXJlbnQ6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgaWRlbnRpZnk6IEJvb2xlYW4sXG4gICAgICBtaW5ab29tOiBOdW1iZXIsXG4gICAgICBtYXhab29tOiBOdW1iZXIsXG4gICAgICBhdHRyaWJ1dGlvbjogU3RyaW5nLFxuICAgICAgXG4gICAgICB3bXNTb3VyY2U6IE9iamVjdCxcbiAgICAgIHN1YkxheWVyczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgdmFsdWU6IFtdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cblxuICBfc291cmNlQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLndtc1NvdXJjZSkgdGhpcy53bXNTb3VyY2UucmVtb3ZlRnJvbSh0aGlzLm1hcCk7XG5cbiAgICB0aGlzLl93bXNPcHRpb25zID0ge1xuICAgICAgdHJhbnNwYXJlbnQ6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgaWRlbnRpZnk6IHRoaXMuaWRlbnRpZnksXG4gICAgICBtaW5ab29tOiB0aGlzLm1pblpvb20sXG4gICAgICBtYXhab29tOiB0aGlzLm1heFpvb20sXG4gICAgICBhdHRyaWJ1dGlvbjogdGhpcy5hdHRyaWJ1dGlvblxuICAgIH07XG5cbiAgICB0aGlzLndtc1NvdXJjZSA9IG5ldyBXTVMuU291cmNlKHRoaXMuc291cmNlLCB0aGlzLl93bXNPcHRpb25zKTtcbiAgICBpZiAodGhpcy5tYXApIHRoaXMud21zU291cmNlLmFkZFRvKHRoaXMubWFwKTtcblxuICAgIHRoaXMuX2xheWVyc0NoYW5nZSgpO1xuICB9XG5cbiAgX2xheWVyc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAvLyBGSVhNRTogdXNlIHByb21pc2UgaW5zdGVhZCBwbGVhc2VcbiAgICBpZiAodGhpcy53bXNTb3VyY2UpIHRoaXMud21zU291cmNlLnJlcGxhY2VBbGxTdWJMYXllcnModGhpcy5sYXllcnMpO1xuICB9XG5cbiAgX21hcFNldCgpIHtcbiAgICB0aGlzLndtc1NvdXJjZS5hZGRUbyh0aGlzLm1hcCk7IC8vIEZJWE1FOiB0aGVyZSBjb3VsZCBiZSBhIHJhY2UgY29uZGl0aW9uIGhlcmUgZm9yIHRoaXMubWFwXG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdsZWFmbGV0LXdtcy1ncm91cCcsIExlYWZsZXRXTVNHcm91cCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL3Zhci93d3cvaHRtbC9AZ2djaXR5L2xlYWZsZXQtd21zL2xlYWZsZXQtd21zLWdyb3VwLmpzIiwiLyohXG4gKiBsZWFmbGV0Lndtcy5qc1xuICogQSBjb2xsZWN0aW9uIG9mIExlYWZsZXQgdXRpbGl0aWVzIGZvciB3b3JraW5nIHdpdGggV2ViIE1hcHBpbmcgc2VydmljZXMuXG4gKiAoYykgMjAxNC0yMDE2LCBIb3VzdG9uIEVuZ2luZWVyaW5nLCBJbmMuXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IHsgSW1hZ2VPdmVybGF5IH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvSW1hZ2VPdmVybGF5LmpzJztcbmltcG9ydCB7IFRpbGVMYXllcldNUywgdGlsZUxheWVyV01TIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzJztcbmltcG9ydCB7IEVQU0c0MzI2IH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuRVBTRzQzMjYuanMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9sZWFmbGV0L3NyYy9jb3JlL1V0aWwuanMnO1xuXG5leHBvcnQgdmFyIHdtcyA9IHt9O1xuXG4vKlxuICogd21zLlNvdXJjZVxuICogVGhlIFNvdXJjZSBvYmplY3QgbWFuYWdlcyBhIHNpbmdsZSBXTVMgY29ubmVjdGlvbi4gIE11bHRpcGxlIFwibGF5ZXJzXCIgY2FuIGJlXG4gKiBjcmVhdGVkIHdpdGggdGhlIGdldExheWVyIGZ1bmN0aW9uLCBidXQgYSBzaW5nbGUgcmVxdWVzdCB3aWxsIGJlIHNlbnQgZm9yXG4gKiBlYWNoIGltYWdlIHVwZGF0ZS4gIENhbiBiZSB1c2VkIGluIG5vbi10aWxlZCBcIm92ZXJsYXlcIiBtb2RlIChkZWZhdWx0KSwgb3JcbiAqIHRpbGVkIG1vZGUsIHZpYSBhbiBpbnRlcm5hbCB3bXMuT3ZlcmxheSBvciB3bXMuVGlsZUxheWVyLCByZXNwZWN0aXZlbHkuXG4gKi9cbndtcy5Tb3VyY2UgPSBMYXllci5leHRlbmQoe1xuICAgICdvcHRpb25zJzoge1xuICAgICAgICAndW50aWxlZCc6IHRydWUsXG4gICAgICAgICdpZGVudGlmeSc6IHRydWVcbiAgICB9LFxuXG4gICAgJ2luaXRpYWxpemUnOiBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRpbGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudW50aWxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcbiAgICAgICAgdGhpcy5fc3ViTGF5ZXJzID0ge307XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSB0aGlzLmNyZWF0ZU92ZXJsYXkodGhpcy5vcHRpb25zLnVudGlsZWQpO1xuICAgIH0sXG5cbiAgICAnY3JlYXRlT3ZlcmxheSc6IGZ1bmN0aW9uKHVudGlsZWQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG92ZXJsYXkgd2l0aCBhbGwgb3B0aW9ucyBvdGhlciB0aGFuIHVudGlsZWQgJiBpZGVudGlmeVxuICAgICAgICB2YXIgb3ZlcmxheU9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgb3B0IGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdCAhPSAndW50aWxlZCcgJiYgb3B0ICE9ICdpZGVudGlmeScpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5T3B0aW9uc1tvcHRdID0gdGhpcy5vcHRpb25zW29wdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVudGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB3bXMub3ZlcmxheSh0aGlzLl91cmwsIG92ZXJsYXlPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3bXMudGlsZUxheWVyKHRoaXMuX3VybCwgb3ZlcmxheU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdvbkFkZCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hPdmVybGF5KCk7XG4gICAgfSxcblxuICAgICdvblJlbW92ZSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkgdGhpcy5fb3ZlcmxheS5yZW1vdmVGcm9tKHRoaXMuX21hcCk7XG4gICAgfSxcblxuICAgICdnZXRFdmVudHMnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZGVudGlmeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsnY2xpY2snOiB0aGlzLmlkZW50aWZ5fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnc2V0T3BhY2l0eSc6IGZ1bmN0aW9uKG9wYWNpdHkpIHtcbiAgICAgICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgIGlmICh0aGlzLl9vdmVybGF5KSB7XG4gICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgJ2JyaW5nVG9CYWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICB0aGlzLm9wdGlvbnMuaXNCYWNrID0gdHJ1ZTtcbiAgICAgICAgIGlmICh0aGlzLl9vdmVybGF5KSB7XG4gICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5icmluZ1RvQmFjaygpO1xuICAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnYnJpbmdUb0Zyb250JzogZnVuY3Rpb24oKSB7XG4gICAgICAgICB0aGlzLm9wdGlvbnMuaXNCYWNrID0gZmFsc2U7XG4gICAgICAgICBpZiAodGhpcy5fb3ZlcmxheSkge1xuICAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuYnJpbmdUb0Zyb250KCk7XG4gICAgICAgICB9XG4gICAgfSxcblxuICAgICdnZXRMYXllcic6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHdtcy5sYXllcih0aGlzLCBuYW1lKTtcbiAgICB9LFxuXG4gICAgJ2dldFN1YkxheWVycyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YkxheWVycztcbiAgICB9LFxuXG4gICAgJ2FkZFN1YkxheWVyJzogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLl9zdWJMYXllcnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlZnJlc2hPdmVybGF5KCk7XG4gICAgfSxcblxuICAgICdyZW1vdmVTdWJMYXllcic6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1YkxheWVyc1tuYW1lXTtcbiAgICAgICAgdGhpcy5yZWZyZXNoT3ZlcmxheSgpO1xuICAgIH0sXG5cbiAgICAvKiBFZmZpY2llbnQgd2F5IHRvIHN3YXAgb3V0IGFsbCBzdWIgbGF5ZXJzICovXG4gICAgJ3JlcGxhY2VBbGxTdWJMYXllcnMnOiBmdW5jdGlvbiAobmV3U3ViTGF5ZXJzKSB7XG4gICAgICAgIHRoaXMuX3N1YkxheWVycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1N1YkxheWVycy5sZW5ndGg7IGkrKykgdGhpcy5fc3ViTGF5ZXJzW25ld1N1YkxheWVyc1tpXV0gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlZnJlc2hPdmVybGF5KCk7XG4gICAgfSxcblxuICAgICdyZWZyZXNoT3ZlcmxheSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3ViTGF5ZXJzID0gT2JqZWN0LmtleXModGhpcy5fc3ViTGF5ZXJzKS5qb2luKFwiLFwiKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YkxheWVycykge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheS5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXkuc2V0UGFyYW1zKHsnbGF5ZXJzJzogc3ViTGF5ZXJzfSk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5LmFkZFRvKHRoaXMuX21hcCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2lkZW50aWZ5JzogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIC8vIElkZW50aWZ5IG1hcCBmZWF0dXJlcyBpbiByZXNwb25zZSB0byBtYXAgY2xpY2tzLiBUbyBjdXN0b21pemUgdGhpc1xuICAgICAgICAvLyBiZWhhdmlvciwgY3JlYXRlIGEgY2xhc3MgZXh0ZW5kaW5nIHdtcy5Tb3VyY2UgYW5kIG92ZXJyaWRlIG9uZSBvclxuICAgICAgICAvLyBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgaG9vayBmdW5jdGlvbnMuXG5cbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0SWRlbnRpZnlMYXllcnMoKTtcbiAgICAgICAgaWYgKCFsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRGZWF0dXJlSW5mbyhcbiAgICAgICAgICAgIGV2dC5jb250YWluZXJQb2ludCwgZXZ0LmxhdGxuZywgbGF5ZXJzLFxuICAgICAgICAgICAgdGhpcy5zaG93RmVhdHVyZUluZm9cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgJ2dldEZlYXR1cmVJbmZvJzogZnVuY3Rpb24ocG9pbnQsIGxhdGxuZywgbGF5ZXJzLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBSZXF1ZXN0IFdNUyBHZXRGZWF0dXJlSW5mbyBhbmQgY2FsbCBjYWxsYmFjayB3aXRoIHJlc3VsdHNcbiAgICAgICAgLy8gKHNwbGl0IGZyb20gaWRlbnRpZnkoKSB0byBmYWNpbGlhdGUgdXNlIG91dHNpZGUgb2YgbWFwIGV2ZW50cylcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0RmVhdHVyZUluZm9QYXJhbXMocG9pbnQsIGxheWVycyksXG4gICAgICAgICAgICB1cmwgPSB0aGlzLl91cmwgKyBVdGlsLmdldFBhcmFtU3RyaW5nKHBhcmFtcywgdGhpcy5fdXJsKTtcblxuICAgICAgICB0aGlzLnNob3dXYWl0aW5nKCk7XG4gICAgICAgIHRoaXMuYWpheCh1cmwsIGRvbmUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVXYWl0aW5nKCk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMucGFyc2VGZWF0dXJlSW5mbyhyZXN1bHQsIHVybCk7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGxhdGxuZywgdGV4dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2FqYXgnOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHdtcy5hamF4LmNhbGwodGhpcywgdXJsLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgICdnZXRJZGVudGlmeUxheWVycyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBIb29rIHRvIGRldGVybWluZSB3aGljaCBsYXllcnMgdG8gaWRlbnRpZnlcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZGVudGlmeUxheWVycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaWRlbnRpZnlMYXllcnM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdWJMYXllcnMpO1xuICAgICB9LFxuXG4gICAgJ2dldEZlYXR1cmVJbmZvUGFyYW1zJzogZnVuY3Rpb24ocG9pbnQsIGxheWVycykge1xuICAgICAgICAvLyBIb29rIHRvIGdlbmVyYXRlIHBhcmFtZXRlcnMgZm9yIFdNUyBzZXJ2aWNlIEdldEZlYXR1cmVJbmZvIHJlcXVlc3RcbiAgICAgICAgdmFyIHdtc1BhcmFtcywgb3ZlcmxheTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51bnRpbGVkKSB7XG4gICAgICAgICAgICAvLyBVc2UgZXhpc3Rpbmcgb3ZlcmxheVxuICAgICAgICAgICAgd21zUGFyYW1zID0gdGhpcy5fb3ZlcmxheS53bXNQYXJhbXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgb3ZlcmxheSBpbnN0YW5jZSB0byBsZXZlcmFnZSB1cGRhdGVXbXNQYXJhbXNcbiAgICAgICAgICAgIG92ZXJsYXkgPSB0aGlzLmNyZWF0ZU92ZXJsYXkodHJ1ZSk7XG4gICAgICAgICAgICBvdmVybGF5LnVwZGF0ZVdtc1BhcmFtcyh0aGlzLl9tYXApO1xuICAgICAgICAgICAgd21zUGFyYW1zID0gb3ZlcmxheS53bXNQYXJhbXM7XG4gICAgICAgICAgICB3bXNQYXJhbXMubGF5ZXJzID0gbGF5ZXJzLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mb1BhcmFtcyA9IHtcbiAgICAgICAgICAgICdyZXF1ZXN0JzogJ0dldEZlYXR1cmVJbmZvJyxcbiAgICAgICAgICAgICdxdWVyeV9sYXllcnMnOiBsYXllcnMuam9pbignLCcpLFxuICAgICAgICAgICAgJ1gnOiBNYXRoLnJvdW5kKHBvaW50LngpLFxuICAgICAgICAgICAgJ1knOiBNYXRoLnJvdW5kKHBvaW50LnkpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBVdGlsLmV4dGVuZCh7fSwgd21zUGFyYW1zLCBpbmZvUGFyYW1zKTtcbiAgICB9LFxuXG4gICAgJ3BhcnNlRmVhdHVyZUluZm8nOiBmdW5jdGlvbihyZXN1bHQsIHVybCkge1xuICAgICAgICAvLyBIb29rIHRvIGhhbmRsZSBwYXJzaW5nIEFKQVggcmVzcG9uc2VcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIC8vIEFKQVggZmFpbGVkLCBwb3NzaWJseSBkdWUgdG8gQ09SUyBpc3N1ZXMuXG4gICAgICAgICAgICAvLyBUcnkgbG9hZGluZyBjb250ZW50IGluIDxpZnJhbWU+LlxuICAgICAgICAgICAgcmVzdWx0ID0gXCI8aWZyYW1lIHNyYz0nXCIgKyB1cmwgKyBcIicgc3R5bGU9J2JvcmRlcjpub25lJz5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAnc2hvd0ZlYXR1cmVJbmZvJzogZnVuY3Rpb24obGF0bG5nLCBpbmZvKSB7XG4gICAgICAgIC8vIEhvb2sgdG8gaGFuZGxlIGRpc3BsYXlpbmcgcGFyc2VkIEFKQVggcmVzcG9uc2UgdG8gdGhlIHVzZXJcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAub3BlblBvcHVwKGluZm8sIGxhdGxuZyk7XG4gICAgfSxcblxuICAgICdzaG93V2FpdGluZyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBIb29rIHRvIGN1c3RvbWl6ZSBBSkFYIHdhaXQgYW5pbWF0aW9uXG4gICAgICAgIGlmICghdGhpcy5fbWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSBcInByb2dyZXNzXCI7XG4gICAgfSxcblxuICAgICdoaWRlV2FpdGluZyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBIb29rIHRvIHJlbW92ZSBBSkFYIHdhaXQgYW5pbWF0aW9uXG4gICAgICAgIGlmICghdGhpcy5fbWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgICB9XG59KTtcblxud21zLnNvdXJjZSA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgd21zLlNvdXJjZSh1cmwsIG9wdGlvbnMpO1xufTtcblxuLypcbiAqIExheWVyXG4gKiBMZWFmbGV0IFwibGF5ZXJcIiB3aXRoIGFsbCBhY3R1YWwgcmVuZGVyaW5nIGhhbmRsZWQgdmlhIGFuIHVuZGVybHlpbmcgU291cmNlXG4gKiBvYmplY3QuICBDYW4gYmUgY2FsbGVkIGRpcmVjdGx5IHdpdGggYSBVUkwgdG8gYXV0b21hdGljYWxseSBjcmVhdGUgb3IgcmV1c2VcbiAqIGFuIGV4aXN0aW5nIFNvdXJjZS4gIE5vdGUgdGhhdCB0aGUgYXV0by1zb3VyY2UgZmVhdHVyZSBkb2Vzbid0IHdvcmsgd2VsbCBpblxuICogbXVsdGktbWFwIGVudmlyb25tZW50czsgc28gZm9yIGJlc3QgcmVzdWx0cywgY3JlYXRlIGEgU291cmNlIGZpcnN0IGFuZCB1c2VcbiAqIGdldExheWVyKCkgdG8gcmV0cmlldmUgd21zLkxheWVyIGluc3RhbmNlcy5cbiAqL1xuXG53bXMuTGF5ZXIgPSBMYXllci5leHRlbmQoe1xuICAgICdpbml0aWFsaXplJzogZnVuY3Rpb24oc291cmNlLCBsYXllck5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXNvdXJjZS5hZGRTdWJMYXllcikge1xuICAgICAgICAgICAgLy8gQXNzdW1lIHNvdXJjZSBpcyBhIFVSTFxuICAgICAgICAgICAgc291cmNlID0gd21zLmdldFNvdXJjZUZvclVybChzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IGxheWVyTmFtZTtcbiAgICB9LFxuICAgICdvbkFkZCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZS5fbWFwKVxuICAgICAgICAgICAgdGhpcy5fc291cmNlLmFkZFRvKHRoaXMuX21hcCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5hZGRTdWJMYXllcih0aGlzLl9uYW1lKTtcbiAgICB9LFxuICAgICdvblJlbW92ZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9zb3VyY2UucmVtb3ZlU3ViTGF5ZXIodGhpcy5fbmFtZSk7XG4gICAgfSxcbiAgICAnc2V0T3BhY2l0eSc6IGZ1bmN0aW9uKG9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gICAgfSxcbiAgICAnYnJpbmdUb0JhY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc291cmNlLmJyaW5nVG9CYWNrKCk7XG4gICAgfSxcbiAgICAnYnJpbmdUb0Zyb250JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5icmluZ1RvRnJvbnQoKTtcbiAgICB9XG59KTtcblxud21zLmxheWVyID0gZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB3bXMuTGF5ZXIoc291cmNlLCBvcHRpb25zKTtcbn07XG5cbi8vIENhY2hlIG9mIHNvdXJjZXMgZm9yIHVzZSB3aXRoIHdtcy5MYXllciBhdXRvLXNvdXJjZSBvcHRpb25cbndtcy5zb3VyY2VzID0ge307XG53bXMuZ2V0U291cmNlRm9yVXJsID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgaWYgKCF3bXMuc291cmNlc1t1cmxdKSB7XG4gICAgICAgIHdtcy5zb3VyY2VzW3VybF0gPSB3bXMuc291cmNlKHVybCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB3bXMuc291cmNlc1t1cmxdO1xufTtcblxuXG4vLyBDb3B5IHRpbGVkIFdNUyBsYXllciBmcm9tIGxlYWZsZXQgY29yZSwgaW4gY2FzZSB3ZSBuZWVkIHRvIHN1YmNsYXNzIGl0IGxhdGVyXG53bXMuVGlsZUxheWVyID0gVGlsZUxheWVyV01TO1xud21zLnRpbGVMYXllciA9IHRpbGVMYXllcldNUztcblxuLypcbiAqIHdtcy5PdmVybGF5OlxuICogXCJTaW5nbGUgVGlsZVwiIFdNUyBpbWFnZSBvdmVybGF5IHRoYXQgdXBkYXRlcyB3aXRoIG1hcCBjaGFuZ2VzLlxuICogUG9ydGlvbnMgb2Ygd21zLk92ZXJsYXkgYXJlIGRpcmVjdGx5IGV4dHJhY3RlZCBmcm9tIEwuVGlsZUxheWVyLldNUy5cbiAqIFNlZSBMZWFmbGV0IGxpY2Vuc2UuXG4gKi9cbndtcy5PdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcbiAgICAnZGVmYXVsdFdtc1BhcmFtcyc6IHtcbiAgICAgICAgJ3NlcnZpY2UnOiAnV01TJyxcbiAgICAgICAgJ3JlcXVlc3QnOiAnR2V0TWFwJyxcbiAgICAgICAgJ3ZlcnNpb24nOiAnMS4xLjEnLFxuICAgICAgICAnbGF5ZXJzJzogJycsXG4gICAgICAgICdzdHlsZXMnOiAnJyxcbiAgICAgICAgJ2Zvcm1hdCc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgJ3RyYW5zcGFyZW50JzogZmFsc2VcbiAgICB9LFxuXG4gICAgJ29wdGlvbnMnOiB7XG4gICAgICAgICdjcnMnOiBudWxsLFxuICAgICAgICAndXBwZXJjYXNlJzogZmFsc2UsXG4gICAgICAgICdhdHRyaWJ1dGlvbic6ICcnLFxuICAgICAgICAnb3BhY2l0eSc6IDEsXG4gICAgICAgICdpc0JhY2snOiBmYWxzZSxcbiAgICAgICAgJ21pblpvb20nOiAwLFxuICAgICAgICAnbWF4Wm9vbSc6IDE4XG4gICAgfSxcblxuICAgICdpbml0aWFsaXplJzogZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcblxuICAgICAgICAvLyBNb3ZlIFdNUyBwYXJhbWV0ZXJzIHRvIHBhcmFtcyBvYmplY3RcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9LCBvcHRzID0ge307XG4gICAgICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgaWYgKG9wdCBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgb3B0c1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHBhcmFtc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMud21zUGFyYW1zID0gVXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgJ3NldFBhcmFtcyc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBVdGlsLmV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgJ2dldEF0dHJpYnV0aW9uJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG4gICAgfSxcblxuICAgICdvbkFkZCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAnb25SZW1vdmUnOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRPdmVybGF5KSB7XG4gICAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcy5fY3VycmVudE92ZXJsYXkpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2N1cnJlbnRPdmVybGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VXJsKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY3VycmVudFVybDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0RXZlbnRzJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnbW92ZWVuZCc6IHRoaXMudXBkYXRlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgICd1cGRhdGUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRlcm1pbmUgaW1hZ2UgVVJMIGFuZCB3aGV0aGVyIGl0IGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdXBkYXRlXG4gICAgICAgIHRoaXMudXBkYXRlV21zUGFyYW1zKCk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmdldEltYWdlVXJsKCk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VXJsID09IHVybCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRVcmwgPSB1cmw7XG5cbiAgICAgICAgLy8gS2VlcCBjdXJyZW50IGltYWdlIG92ZXJsYXkgaW4gcGxhY2UgdW50aWwgbmV3IG9uZSBsb2Fkc1xuICAgICAgICAvLyAoaW5zcGlyZWQgYnkgZXNyaS5sZWFmbGV0KVxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldEJvdW5kcygpO1xuICAgICAgICB2YXIgb3ZlcmxheSA9IG5ldyBJbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIHsnb3BhY2l0eSc6IDB9KTtcbiAgICAgICAgb3ZlcmxheS5hZGRUbyh0aGlzLl9tYXApO1xuICAgICAgICBvdmVybGF5Lm9uY2UoJ2xvYWQnLCBfc3dhcCwgdGhpcyk7XG4gICAgICAgIGZ1bmN0aW9uIF9zd2FwKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3ZlcmxheS5fdXJsICE9IHRoaXMuX2N1cnJlbnRVcmwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIob3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdXJyZW50T3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9jdXJyZW50T3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgICAgICBvdmVybGF5LnNldE9wYWNpdHkoXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPyB0aGlzLm9wdGlvbnMub3BhY2l0eSA6IDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzQmFjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuYnJpbmdUb0JhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNCYWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkuYnJpbmdUb0Zyb250KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLl9tYXAuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHx8XG4gICAgICAgICAgICAodGhpcy5fbWFwLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSl7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIob3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3NldE9wYWNpdHknOiBmdW5jdGlvbihvcGFjaXR5KSB7XG4gICAgICAgICB0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICBpZiAodGhpcy5fY3VycmVudE92ZXJsYXkpIHtcbiAgICAgICAgICAgICB0aGlzLl9jdXJyZW50T3ZlcmxheS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnYnJpbmdUb0JhY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmlzQmFjayA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50T3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudE92ZXJsYXkuYnJpbmdUb0JhY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnYnJpbmdUb0Zyb250JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pc0JhY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRPdmVybGF5KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T3ZlcmxheS5icmluZ1RvRnJvbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBTZWUgTC5UaWxlTGF5ZXIuV01TOiBvbkFkZCgpICYgZ2V0VGlsZVVybCgpXG4gICAgJ3VwZGF0ZVdtc1BhcmFtcyc6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgV01TIG9wdGlvbnNcbiAgICAgICAgdmFyIGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHNpemUgPSBtYXAuZ2V0U2l6ZSgpO1xuICAgICAgICB2YXIgd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XG4gICAgICAgIHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcbiAgICAgICAgdmFyIHByb2plY3Rpb25LZXkgPSB3bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XG4gICAgICAgIHZhciBudyA9IGNycy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aFdlc3QoKSk7XG4gICAgICAgIHZhciBzZSA9IGNycy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSk7XG5cbiAgICAgICAgLy8gQXNzZW1ibGUgV01TIHBhcmFtZXRlciBzdHJpbmdcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICd3aWR0aCc6IHNpemUueCxcbiAgICAgICAgICAgICdoZWlnaHQnOiBzaXplLnlcbiAgICAgICAgfTtcbiAgICAgICAgcGFyYW1zW3Byb2plY3Rpb25LZXldID0gY3JzLmNvZGU7XG4gICAgICAgIHBhcmFtcy5iYm94ID0gKFxuICAgICAgICAgICAgd21zVmVyc2lvbiA+PSAxLjMgJiYgY3JzLmNvZGUgPT09IEVQU0c0MzI2LmNvZGUgP1xuICAgICAgICAgICAgW3NlLnksIG53LngsIG53LnksIHNlLnhdIDpcbiAgICAgICAgICAgIFtudy54LCBzZS55LCBzZS54LCBudy55XVxuICAgICAgICApLmpvaW4oJywnKTtcblxuICAgICAgICBVdGlsLmV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgJ2dldEltYWdlVXJsJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cHBlcmNhc2UgPSB0aGlzLm9wdGlvbnMudXBwZXJjYXNlIHx8IGZhbHNlO1xuICAgICAgICB2YXIgcHN0ciA9IFV0aWwuZ2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHRoaXMuX3VybCwgdXBwZXJjYXNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybCArIHBzdHI7XG4gICAgfVxufSk7XG5cbndtcy5vdmVybGF5ID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB3bXMuT3ZlcmxheSh1cmwsIG9wdGlvbnMpO1xufTtcblxuLy8gU2ltcGxlIEFKQVggaGVscGVyIChzaW5jZSB3ZSBjYW4ndCBhc3N1bWUgalF1ZXJ5IGV0Yy4gYXJlIHByZXNlbnQpXG53bXMuYWpheCA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjaGFuZ2U7XG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwpO1xuICAgIHJlcXVlc3Quc2VuZCgpO1xuXG4gICAgZnVuY3Rpb24gY2hhbmdlKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgcmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC92YXIvd3d3L2h0bWwvQGdnY2l0eS9sZWFmbGV0LXdtcy9sZWFmbGV0Lndtcy5qcyIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5cbmV4cG9ydCBjbGFzcyBMZWFmbGV0V01TTGF5ZXIgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd21zU291cmNlOiBPYmplY3QsXG4gICAgICBsYXllcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIFxuICAgIGlmICh0aGlzLndtc1NvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMubGF5ZXIgPT09ICcnKSByZXR1cm47XG4gICAgdGhpcy53bXNTb3VyY2UuYWRkU3ViTGF5ZXIodGhpcy5sYXllcik7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdsZWFmbGV0LXdtcy1sYXllcicsIExlYWZsZXRXTVNMYXllcik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL3Zhci93d3cvaHRtbC9AZ2djaXR5L2xlYWZsZXQtd21zL2xlYWZsZXQtd21zLWxheWVyLmpzIiwiaW1wb3J0IHsgRWxlbWVudCBhcyBQb2x5bWVyRWxlbWVudCB9IGZyb20gJy4uLy4uL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcblxuaW1wb3J0IHsgVGlsZUxheWVyIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuanMnO1xuaW1wb3J0IHsgVGlsZUxheWVyV01TIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvdGlsZS9UaWxlTGF5ZXIuV01TLmpzJztcblxuZXhwb3J0IGNsYXNzIExlYWZsZXRUaWxlTGF5ZXIgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWFwOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfbWFwU2V0J1xuICAgICAgfSxcbiAgICAgIGJhc2U6IEJvb2xlYW4sXG4gICAgICB1cmw6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB2YWx1ZTogXCIvL3tzfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZ1wiLFxuICAgICAgICBvYnNlcnZlcjogJ191cmxDaGFuZ2VkJyxcbiAgICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZm9ybWF0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfZm9ybWF0Q2hhbmdlZCcsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxheWVyczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAnX2xheWVyc0NoYW5nZWQnXG4gICAgICB9LFxuICAgICAgbWluWm9vbTogTnVtYmVyLFxuICAgICAgbWF4Wm9vbTogTnVtYmVyLFxuICAgICAgYXR0cmlidXRpb246IFN0cmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgX3VybENoYW5nZWQgKCkge1xuICAgIGNvbnNvbGUubG9nKCd1cmwgY2hhbmdlZCcsIHRoaXMudXJsKTtcbiAgICBpZiAodGhpcy5sZWFmbGV0TGF5ZXIpIHRoaXMubGVhZmxldExheWVyLnNldFVybCh0aGlzLnVybCk7XG4gIH1cblxuICBfbGF5ZXJzQ2hhbmdlZCAoKSB7XG4gICAgY29uc29sZS5sb2coJ2xheWVycyBjaGFuZ2VkJywgdGhpcy5sYXllcnMpO1xuICAgIGlmICh0aGlzLmxlYWZsZXRMYXllciAmJiB0aGlzLmxlYWZsZXRMYXllciBpbnN0YW5jZW9mIFRpbGVMYXllcldNUykgdGhpcy5sZWFmbGV0TGF5ZXIuc2V0UGFyYW1zKHsgbGF5ZXJzOiB0aGlzLmxheWVycyB9KTtcbiAgfVxuXG4gIF9mb3JtYXRDaGFuZ2VkICgpIHtcbiAgICBjb25zb2xlLmxvZygnZm9ybWF0IGNoYW5nZWQnLCB0aGlzLmZvcm1hdCk7XG5cbiAgICBpZiAodGhpcy5sZWFmbGV0TGF5ZXIgJiYgdGhpcy5tYXApIHtcbiAgICAgIHRoaXMubGVhZmxldExheWVyLnJlbW92ZUZyb20odGhpcy5tYXApO1xuICAgIH1cblxuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgbWluWm9vbTogdGhpcy5taW5ab29tLFxuICAgICAgbWF4Wm9vbTogdGhpcy5tYXhab29tLFxuICAgICAgYXR0cmlidXRpb246IHRoaXMuYXR0cmlidXRpb25cbiAgICB9O1xuXG4gICAgc3dpdGNoICh0aGlzLmZvcm1hdCkge1xuICAgICAgY2FzZSAnWFlaJzpcbiAgICAgICAgdGhpcy5sZWFmbGV0TGF5ZXIgPSBuZXcgVGlsZUxheWVyKHRoaXMudXJsLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdXTVMnOlxuICAgICAgICB0aGlzLmxlYWZsZXRMYXllciA9IG5ldyBUaWxlTGF5ZXJXTVModGhpcy51cmwsIE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuICAgICAgICAgIGxheWVyczogdGhpcy5sYXllcnMsXG4gICAgICAgICAgZm9ybWF0OiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgICAgaGludHM6ICdxdWFsaXR5J1xuICAgICAgICB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBsZWFmbGV0LXRpbGUtbGF5ZXIgZm9ybWF0OiAnLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXApIHRoaXMubGVhZmxldExheWVyLmFkZFRvKHRoaXMubWFwKTtcbiAgICBlbHNlIGNvbnNvbGUubG9nKCdtYXAgbm90IHlldCBzZXQnKTtcbiAgfVxuXG4gIF9tYXBTZXQoKSB7XG4gICAgY29uc29sZS5sb2coJ21hcCBzZXQnKTtcbiAgICBpZiAodGhpcy5sZWFmbGV0TGF5ZXIgJiYgIXRoaXMubWFwLmhhc0xheWVyKHRoaXMubGVhZmxldExheWVyKSkge1xuICAgICAgY29uc29sZS5sb2coJ25vIGxheWVyIHlldCwgYWRkaW5nJyk7XG4gICAgICB0aGlzLmxlYWZsZXRMYXllci5hZGRUbyh0aGlzLm1hcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdsYXllciBvYmplY3Qgbm90IHNldCAvIGxheWVyIGV4aXN0cywgc2tpcHBpbmcnKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdsZWFmbGV0LXRpbGUtbGF5ZXInLCBMZWFmbGV0VGlsZUxheWVyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvdmFyL3d3dy9odG1sL0BnZ2NpdHkvbGVhZmxldC10aWxlLWxheWVyL2xlYWZsZXQtdGlsZS1sYXllci5qcyIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBEb21SZXBlYXQgfSBmcm9tICcuLi8uLi9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzJztcblxuaW1wb3J0IHsgQ2lyY2xlTWFya2VyIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyc7XG5pbXBvcnQgeyBHZW9KU09OIH0gZnJvbSAnLi4vLi4vbGVhZmxldC9zcmMvbGF5ZXIvR2VvSlNPTi5qcyc7XG5pbXBvcnQgJy4uLy4uL2xlYWZsZXQvc3JjL0xlYWZsZXQuanMnO1xuaW1wb3J0IHsgTWFya2VyQ2x1c3Rlckdyb3VwIH0gZnJvbSAnLi4vLi4vbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy8nO1xuXG5leHBvcnQgY2xhc3MgTGVhZmxldEdlb0pTT04gZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDoge1xuICAgICAgICB0eXBlOiBPYmplY3RcbiAgICAgIH0sXG5cbiAgICAgIHNvdXJjZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIG9ic2VydmVyOiAnX3NvdXJjZUNoYW5nZScsXG4gICAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgZmlsbENvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICcjRkY4MEFCJ1xuICAgICAgfSxcblxuICAgICAgb3V0bGluZUNvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICcjRkYxNzQ0J1xuICAgICAgfSxcblxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDEwXG4gICAgICB9LFxuXG4gICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogM1xuICAgICAgfSxcblxuICAgICAgb3BhY2l0eToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAxLjBcbiAgICAgIH0sXG5cbiAgICAgIGZpbGxPcGFjaXR5OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgfSxcblxuICAgICAgY2x1c3RlcjogQm9vbGVhbixcbiAgICAgIG1heENsdXN0ZXJSYWRpdXM6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogODBcbiAgICAgIH0sXG4gICAgICBpZGVudGlmeTogQm9vbGVhbixcbiAgICAgIG1pblpvb206IE51bWJlcixcbiAgICAgIG1heFpvb206IE51bWJlcixcbiAgICAgIGF0dHJpYnV0aW9uOiBTdHJpbmdcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHRoaXMuX2NsdXN0ZXJHcm91cCA9IG5ldyBNYXJrZXJDbHVzdGVyR3JvdXAoe1xuICAgICAgc2hvd0NvdmVyYWdlT25Ib3ZlcjogZmFsc2UsXG4gICAgICBtYXhDbHVzdGVyUmFkaXVzOiB0aGlzLm1heENsdXN0ZXJSYWRpdXNcbiAgICB9KTtcblxuICAgIHRoaXMuX2NpcmNsZU1ha2VyT3B0aW9ucyA9IHtcbiAgICAgIGNvbG9yOiB0aGlzLm91dGxpbmVDb2xvcixcbiAgICAgIGZpbGxDb2xvcjogdGhpcy5maWxsQ29sb3IsXG4gICAgICByYWRpdXM6IHRoaXMucmFkaXVzLFxuICAgICAgd2VpZ2h0OiB0aGlzLndlaWdodCxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLmZpbGxPcGFjaXR5XG4gICAgfTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdGhpcy5tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY2x1c3Rlckdyb3VwKTtcbiAgICB0aGlzLl9jbHVzdGVyR3JvdXAuY2xlYXJMYXllcnMoKTtcbiAgfVxuXG4gIF9hZGRHZW9KU09OTGF5ZXIoZ2VvanNvbikge1xuICAgIHRoaXMuX2NsdXN0ZXJHcm91cC5jbGVhckxheWVycygpO1xuXG4gICAgdGhpcy5fZ2VvSlNPTk9wdGlvbnMgPSB7XG4gICAgICBwb2ludFRvTGF5ZXI6IHRoaXMuX3BvaW50VG9MYXllci5iaW5kKHRoaXMpLFxuICAgICAgYXR0cmlidXRpb246IHRoaXMuYXR0cmlidXRpb25cbiAgICB9O1xuICAgIHRoaXMuX2dlb0pTT05MYXllciA9IG5ldyBHZW9KU09OKGdlb2pzb24sIHRoaXMuX2dlb0pTT05PcHRpb25zKTtcblxuICAgIGlmICh0aGlzLmNsdXN0ZXIpIHtcbiAgICAgIHRoaXMubWFwLmFkZExheWVyKHRoaXMuX2NsdXN0ZXJHcm91cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFwLmFkZExheWVyKHRoaXMuX2dlb0pTT05MYXllcik7XG4gICAgfVxuICB9XG5cbiAgX3BvaW50VG9MYXllcihmZWF0dXJlLCBsYXRsbmcpIHtcbiAgICBsZXQgbWFya2VyID0gbmV3IENpcmNsZU1hcmtlcihsYXRsbmcsIHRoaXMuX2NpcmNsZU1ha2VyT3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuaWRlbnRpZnkpIG1hcmtlci5iaW5kUG9wdXAodGhpcy5fZ2VuZXJhdGVQb3B1cENvbnRlbnQoZmVhdHVyZSkpO1xuXG4gICAgaWYgKHRoaXMuY2x1c3RlcikgdGhpcy5fY2x1c3Rlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG4gICAgcmV0dXJuIG1hcmtlcjtcbiAgfVxuXG4gIF9nZW5lcmF0ZVBvcHVwQ29udGVudCAoZmVhdHVyZSkge1xuICAgIGxldCByb3dzID0gJyc7XG4gICAgZm9yIChsZXQgcCBpbiBmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgIGxldCBmaWVsZE5hbWUgPSBwLnJlcGxhY2UoL1xcd1xcUyovZywgZnVuY3Rpb24odHh0KXsgcmV0dXJuIHR4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJyAnKTsgfSlcbiAgICAgIHJvd3MgKz0gYDx0cj48dGQ+JHtmaWVsZE5hbWV9OjwvdGQ+PHRkPjxzdHJvbmc+JHtmZWF0dXJlLnByb3BlcnRpZXNbcF19PC9zdHJvbmc+PC90ZD48L3RyPmA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGA8dGFibGU+JHtyb3dzfTwvdGFibGU+YDtcbiAgfVxuXG4gIF9zb3VyY2VDaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMubWFwICYmIHRoaXMuX2dlb0pTT05MYXllcikgdGhpcy5fZ2VvSlNPTkxheWVyLnJlbW92ZUZyb20odGhpcy5tYXApO1xuXG4gICAgZmV0Y2godGhpcy5zb3VyY2UpXG4gICAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgIC50aGVuKHRoaXMuX2FkZEdlb0pTT05MYXllci5iaW5kKHRoaXMpKTtcbiAgICAvLyAuY2F0Y2goKCkgPT4gYWxlcnQoJ1VuYWJsZSB0byBsb2FkIGxheWVyJykpO1xuICB9XG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGVhZmxldC1nZW9qc29uLXBvaW50cycsIExlYWZsZXRHZW9KU09OKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAvdmFyL3d3dy9odG1sL0BnZ2NpdHkvbGVhZmxldC1nZW9qc29uL2xlYWZsZXQtZ2VvanNvbi1wb2ludHMuanMiLCJcclxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi9wYWNrYWdlLmpzb24nO1xyXG5leHBvcnQge3ZlcnNpb259O1xyXG5cclxuLy8gY29udHJvbFxyXG5leHBvcnQgKiBmcm9tICcuL2NvbnRyb2wvaW5kZXgnO1xyXG5cclxuLy8gY29yZVxyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXgnO1xyXG5cclxuLy8gZG9tXHJcbmV4cG9ydCAqIGZyb20gJy4vZG9tL2luZGV4JztcclxuXHJcbi8vIGdlb21ldHJ5XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvbWV0cnkvaW5kZXgnO1xyXG5cclxuLy8gZ2VvXHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvL2luZGV4JztcclxuXHJcbi8vIGxheWVyXHJcbmV4cG9ydCAqIGZyb20gJy4vbGF5ZXIvaW5kZXgnO1xyXG5cclxuLy8gbWFwXHJcbmV4cG9ydCAqIGZyb20gJy4vbWFwL2luZGV4JztcclxuXHJcbi8vIG1pc2NcclxuXHJcbnZhciBvbGRMID0gd2luZG93Lkw7XHJcbmV4cG9ydCBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xyXG5cdHdpbmRvdy5MID0gb2xkTDtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQWx3YXlzIGV4cG9ydCB1cyB0byB3aW5kb3cgZ2xvYmFsIChzZWUgIzIzNjQpXHJcbndpbmRvdy5MID0gZXhwb3J0cztcclxuXHJcbmltcG9ydCB7ZnJlZXplfSBmcm9tICcuL2NvcmUvVXRpbCc7XHJcbk9iamVjdC5mcmVlemUgPSBmcmVlemU7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvTGVhZmxldC5qcyIsImltcG9ydCAqIGFzIEJyb3dzZXIgZnJvbSAnLi9Ccm93c2VyJztcbmV4cG9ydCB7QnJvd3Nlcn07XG5cbmV4cG9ydCB7Q2xhc3N9IGZyb20gJy4vQ2xhc3MnO1xuXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4vRXZlbnRzJztcbmltcG9ydCB7RXZlbnRzfSBmcm9tICcuL0V2ZW50cyc7XG5leHBvcnQge0V2ZW50ZWR9O1xuZXhwb3J0IHZhciBNaXhpbiA9IHtFdmVudHM6IEV2ZW50c307XG5cbmV4cG9ydCB7SGFuZGxlcn0gZnJvbSAnLi9IYW5kbGVyJztcblxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuL1V0aWwnO1xuZXhwb3J0IHtVdGlsfTtcbmV4cG9ydCB7ZXh0ZW5kLCBiaW5kLCBzdGFtcCwgc2V0T3B0aW9uc30gZnJvbSAnLi9VdGlsJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvY29yZS9pbmRleC5qcyIsImV4cG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuL1Bvc0FuaW1hdGlvbic7XG5cbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuZXhwb3J0IHtEb21FdmVudH07XG5cbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcbmV4cG9ydCB7RG9tVXRpbH07XG5cbmV4cG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuL0RyYWdnYWJsZSc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQvc3JjL2RvbS9pbmRleC5qcyIsImV4cG9ydCB7UG9pbnQsIHRvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4vUG9pbnQnO1xuZXhwb3J0IHtCb3VuZHMsIHRvQm91bmRzIGFzIGJvdW5kc30gZnJvbSAnLi9Cb3VuZHMnO1xuZXhwb3J0IHtUcmFuc2Zvcm1hdGlvbiwgdG9UcmFuc2Zvcm1hdGlvbiBhcyB0cmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi9UcmFuc2Zvcm1hdGlvbic7XG5cbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4vTGluZVV0aWwnO1xuZXhwb3J0IHtMaW5lVXRpbH07XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuL1BvbHlVdGlsJztcbmV4cG9ydCB7UG9seVV0aWx9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW9tZXRyeS9pbmRleC5qcyIsImV4cG9ydCB7TGF0TG5nLCB0b0xhdExuZyBhcyBsYXRMbmd9IGZyb20gJy4vTGF0TG5nJztcbmV4cG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcblxuaW1wb3J0ICogYXMgUHJvamVjdGlvbiBmcm9tICcuL3Byb2plY3Rpb24vaW5kZXgnO1xuZXhwb3J0IHtQcm9qZWN0aW9ufTtcblxuZXhwb3J0ICogZnJvbSAnLi9jcnMvaW5kZXgnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vaW5kZXguanMiLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xuaW1wb3J0IHtFUFNHMzM5NX0gZnJvbSAnLi9DUlMuRVBTRzMzOTUnO1xuaW1wb3J0IHtFUFNHMzg1NywgRVBTRzkwMDkxM30gZnJvbSAnLi9DUlMuRVBTRzM4NTcnO1xuaW1wb3J0IHtFUFNHNDMyNn0gZnJvbSAnLi9DUlMuRVBTRzQzMjYnO1xuaW1wb3J0IHtTaW1wbGV9IGZyb20gJy4vQ1JTLlNpbXBsZSc7XG5cbkNSUy5FYXJ0aCA9IEVhcnRoO1xuQ1JTLkVQU0czMzk1ID0gRVBTRzMzOTU7XG5DUlMuRVBTRzM4NTcgPSBFUFNHMzg1NztcbkNSUy5FUFNHOTAwOTEzID0gRVBTRzkwMDkxMztcbkNSUy5FUFNHNDMyNiA9IEVQU0c0MzI2O1xuQ1JTLlNpbXBsZSA9IFNpbXBsZTtcblxuZXhwb3J0IHtDUlN9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL2luZGV4LmpzIiwiaW1wb3J0IHtFYXJ0aH0gZnJvbSAnLi9DUlMuRWFydGgnO1xyXG5pbXBvcnQge01lcmNhdG9yfSBmcm9tICcuLi9wcm9qZWN0aW9uL1Byb2plY3Rpb24uTWVyY2F0b3InO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHMzM5NVxyXG4gKlxyXG4gKiBSYXJlbHkgdXNlZCBieSBzb21lIGNvbW1lcmNpYWwgdGlsZSBwcm92aWRlcnMuIFVzZXMgRWxsaXB0aWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHZhciBFUFNHMzM5NSA9IFV0aWwuZXh0ZW5kKHt9LCBFYXJ0aCwge1xyXG5cdGNvZGU6ICdFUFNHOjMzOTUnLFxyXG5cdHByb2plY3Rpb246IE1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBzY2FsZSA9IDAuNSAvIChNYXRoLlBJICogTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gdG9UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3NyYy9nZW8vY3JzL0NSUy5FUFNHMzM5NS5qcyIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL2Nycy9DUlMuU2ltcGxlLmpzIiwiLypcbiAqIEBjbGFzcyBQcm9qZWN0aW9uXG5cbiAqIEFuIG9iamVjdCB3aXRoIG1ldGhvZHMgZm9yIHByb2plY3RpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBvbnRvXG4gKiBhIGZsYXQgc3VyZmFjZSAoYW5kIGJhY2spLiBTZWUgW01hcCBwcm9qZWN0aW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcF9wcm9qZWN0aW9uKS5cblxuICogQHByb3BlcnR5IGJvdW5kczogQm91bmRzXG4gKiBUaGUgYm91bmRzIChzcGVjaWZpZWQgaW4gQ1JTIHVuaXRzKSB3aGVyZSB0aGUgcHJvamVjdGlvbiBpcyB2YWxpZFxuXG4gKiBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxuICogUHJvamVjdHMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGludG8gYSAyRCBwb2ludC5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xuICogVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLiBQcm9qZWN0cyBhIDJEIHBvaW50IGludG8gYSBnZW9ncmFwaGljYWwgbG9jYXRpb24uXG4gKiBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXG5cbiAqIE5vdGUgdGhhdCB0aGUgcHJvamVjdGlvbiBpbnN0YW5jZXMgZG8gbm90IGluaGVyaXQgZnJvbSBMZWFmZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC9zcmMvZ2VvL3Byb2plY3Rpb24vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIm5hbWVcIjpcImxlYWZsZXRcIixcInZlcnNpb25cIjpcIjEuMy4xXCIsXCJkZXNjcmlwdGlvblwiOlwiSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBtb2JpbGUtZnJpZW5kbHkgaW50ZXJhY3RpdmUgbWFwc1wiLFwiZGV2RGVwZW5kZW5jaWVzXCI6e1wiZXNsaW50XCI6XCJeNC41LjBcIixcImVzbGludC1jb25maWctbW91cm5lclwiOlwiXjIuMC4xXCIsXCJnaXQtcmV2LXN5bmNcIjpcIl4xLjguMFwiLFwiaGFwcGVuXCI6XCJ+MC4zLjJcIixcImpha2VcIjpcIn44LjAuMTJcIixcImthcm1hXCI6XCJeMS4zLjBcIixcImthcm1hLWNocm9tZS1sYXVuY2hlclwiOlwiXjIuMC4wXCIsXCJrYXJtYS1jb3ZlcmFnZVwiOlwifjEuMS4xXCIsXCJrYXJtYS1maXJlZm94LWxhdW5jaGVyXCI6XCJ+MS4wLjBcIixcImthcm1hLW1vY2hhXCI6XCJeMS4yLjBcIixcImthcm1hLXBoYW50b21qcy1sYXVuY2hlclwiOlwiXjEuMC4yXCIsXCJrYXJtYS1yb2xsdXAtcHJlcHJvY2Vzc29yXCI6XCJeNS4wLjFcIixcImthcm1hLXNhZmFyaS1sYXVuY2hlclwiOlwifjEuMC4wXCIsXCJsZWFmZG9jXCI6XCJeMS40LjFcIixcIm1vY2hhXCI6XCJeMy4xLjBcIixcInBoYW50b21qcy1wcmVidWlsdFwiOlwiXjIuMS4xMlwiLFwicHJvc3RoZXRpYy1oYW5kXCI6XCJeMS4zLjFcIixcInJvbGx1cFwiOlwiXjAuNTEuOFwiLFwicm9sbHVwLXBsdWdpbi1naXQtdmVyc2lvblwiOlwiMC4yLjFcIixcInJvbGx1cC1wbHVnaW4tanNvblwiOlwiXjIuMS4wXCIsXCJyb2xsdXAtd2F0Y2hcIjpcIl40LjMuMVwiLFwic291cmNlLW1hcFwiOlwiXjAuNS42XCIsXCJzc3JpXCI6XCJeNC4xLjJcIixcInVnbGlmeS1qc1wiOlwifjMuMC4yNlwifSxcIm1haW5cIjpcImRpc3QvbGVhZmxldC1zcmMuanNcIixcInN0eWxlXCI6XCJkaXN0L2xlYWZsZXQuY3NzXCIsXCJmaWxlc1wiOltcImRpc3RcIixcInNyY1wiLFwiIWRpc3QvbGVhZmxldC56aXBcIl0sXCJzY3JpcHRzXCI6e1wiZG9jc1wiOlwiamFrZSBkb2NzXCIsXCJ0ZXN0LWpha2VcIjpcImpha2UgdGVzdFwiLFwidGVzdFwiOlwiamFrZSB0ZXN0XCIsXCJidWlsZC1qYWtlXCI6XCJqYWtlIGJ1aWxkXCIsXCJidWlsZFwiOlwibnBtIHJ1biByb2xsdXAgJiYgbnBtIHJ1biB1Z2xpZnlcIixcInJlbGVhc2VcIjpcIi4vYnVpbGQvcHVibGlzaC5zaFwiLFwibGludFwiOlwiZXNsaW50IHNyYzsgZXNsaW50IHNwZWMvc3VpdGVzXCIsXCJsaW50Zml4XCI6XCJlc2xpbnQgc3JjIC0tZml4OyBlc2xpbnQgc3BlYy9zdWl0ZXMgLS1maXg7IFwiLFwicm9sbHVwXCI6XCJyb2xsdXAgLWMgYnVpbGQvcm9sbHVwLWNvbmZpZy5qc1wiLFwid2F0Y2hcIjpcInJvbGx1cCAtdyAtYyBidWlsZC9yb2xsdXAtd2F0Y2gtY29uZmlnLmpzXCIsXCJ1Z2xpZnlcIjpcInVnbGlmeWpzIGRpc3QvbGVhZmxldC1zcmMuanMgLWMgLW0gLW8gZGlzdC9sZWFmbGV0LmpzIC0tc291cmNlLW1hcCBmaWxlbmFtZT1kaXN0L2xlYWZsZXQuanMubWFwIC0taW4tc291cmNlLW1hcCBkaXN0L2xlYWZsZXQtc3JjLmpzLm1hcCAtLXNvdXJjZS1tYXAtdXJsIGxlYWZsZXQuanMubWFwIC0tY29tbWVudHNcIixcImludGVncml0eVwiOlwibm9kZWpzIC4vYnVpbGQvaW50ZWdyaXR5LmpzXCJ9LFwiZXNsaW50Q29uZmlnXCI6e1wicm9vdFwiOnRydWUsXCJnbG9iYWxzXCI6e1wiTFwiOnRydWV9LFwiZW52XCI6e1wiY29tbW9uanNcIjp0cnVlLFwiYW1kXCI6dHJ1ZSxcIm5vZGVcIjpmYWxzZX0sXCJleHRlbmRzXCI6XCJtb3VybmVyXCIsXCJwYXJzZXJPcHRpb25zXCI6e1wiZWNtYVZlcnNpb25cIjo2LFwic291cmNlVHlwZVwiOlwibW9kdWxlXCJ9LFwicnVsZXNcIjp7XCJsaW5lYnJlYWstc3R5bGVcIjpbMCxcInVuaXhcIl0sXCJuby1taXhlZC1zcGFjZXMtYW5kLXRhYnNcIjpbMixcInNtYXJ0LXRhYnNcIl0sXCJpbmRlbnRcIjpbMixcInRhYlwiLHtcIlZhcmlhYmxlRGVjbGFyYXRvclwiOjAsXCJmbGF0VGVybmFyeUV4cHJlc3Npb25zXCI6dHJ1ZX1dLFwiY3VybHlcIjoyLFwic3BhY2VkLWNvbW1lbnRcIjoyLFwic3RyaWN0XCI6MCxcIndyYXAtaWlmZVwiOjAsXCJrZXktc3BhY2luZ1wiOjAsXCJjb25zaXN0ZW50LXJldHVyblwiOjB9fSxcInJlcG9zaXRvcnlcIjp7XCJ0eXBlXCI6XCJnaXRcIixcInVybFwiOlwiZ2l0Oi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQuZ2l0XCJ9LFwia2V5d29yZHNcIjpbXCJnaXNcIixcIm1hcFwiXSxcImxpY2Vuc2VcIjpcIkJTRC0yLUNsYXVzZVwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0L3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxyXG5leHBvcnQgeyBNYXJrZXJDbHVzdGVyR3JvdXAgfSBmcm9tICcuL01hcmtlckNsdXN0ZXJHcm91cC5qcyc7XHJcbmV4cG9ydCB7IE1hcmtlckNsdXN0ZXIgfSBmcm9tICcuL01hcmtlckNsdXN0ZXIuanMnO1xyXG5pbXBvcnQge30gZnJvbSAnLi9NYXJrZXJPcGFjaXR5LmpzJztcclxuaW1wb3J0IHt9IGZyb20gJy4vRGlzdGFuY2VHcmlkLmpzJztcclxuaW1wb3J0IHt9IGZyb20gJy4vTWFya2VyQ2x1c3Rlci5RdWlja0h1bGwuanMnO1xyXG5pbXBvcnQge30gZnJvbSAnLi9NYXJrZXJDbHVzdGVyLlNwaWRlcmZpZXIuanMnO1xyXG5pbXBvcnQge30gZnJvbSAnLi9NYXJrZXJDbHVzdGVyR3JvdXAuUmVmcmVzaC5qcyc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9pbmRleC5qcyIsIi8qXHJcbiAqIEwuTWFya2VyQ2x1c3Rlckdyb3VwIGV4dGVuZHMgTC5GZWF0dXJlR3JvdXAgYnkgY2x1c3RlcmluZyB0aGUgbWFya2VycyBjb250YWluZWQgd2l0aGluXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXJrZXJDbHVzdGVyR3JvdXAgPSBMLk1hcmtlckNsdXN0ZXJHcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdG1heENsdXN0ZXJSYWRpdXM6IDgwLCAvL0EgY2x1c3RlciB3aWxsIGNvdmVyIGF0IG1vc3QgdGhpcyBtYW55IHBpeGVscyBmcm9tIGl0cyBjZW50ZXJcclxuXHRcdGljb25DcmVhdGVGdW5jdGlvbjogbnVsbCxcclxuXHRcdGNsdXN0ZXJQYW5lOiBMLk1hcmtlci5wcm90b3R5cGUub3B0aW9ucy5wYW5lLFxyXG5cclxuXHRcdHNwaWRlcmZ5T25NYXhab29tOiB0cnVlLFxyXG5cdFx0c2hvd0NvdmVyYWdlT25Ib3ZlcjogdHJ1ZSxcclxuXHRcdHpvb21Ub0JvdW5kc09uQ2xpY2s6IHRydWUsXHJcblx0XHRzaW5nbGVNYXJrZXJNb2RlOiBmYWxzZSxcclxuXHJcblx0XHRkaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbTogbnVsbCxcclxuXHJcblx0XHQvLyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcHJldmVudHMgdGhlIHJlbW92YWwgb2YgYW55IGNsdXN0ZXJzIG91dHNpZGUgb2YgdGhlIHZpZXdwb2ludCwgd2hpY2hcclxuXHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cclxuXHRcdHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzOiB0cnVlLFxyXG5cclxuXHRcdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGFsbCBhbmltYXRpb25zICh6b29tIGFuZCBzcGlkZXJmeSkuXHJcblx0XHQvLyBJZiBmYWxzZSwgb3B0aW9uIGFuaW1hdGVBZGRpbmdNYXJrZXJzIGJlbG93IGhhcyBubyBlZmZlY3QuXHJcblx0XHQvLyBJZiBMLkRvbVV0aWwuVFJBTlNJVElPTiBpcyBmYWxzeSwgdGhpcyBvcHRpb24gaGFzIG5vIGVmZmVjdC5cclxuXHRcdGFuaW1hdGU6IHRydWUsXHJcblxyXG5cdFx0Ly9XaGV0aGVyIHRvIGFuaW1hdGUgYWRkaW5nIG1hcmtlcnMgYWZ0ZXIgYWRkaW5nIHRoZSBNYXJrZXJDbHVzdGVyR3JvdXAgdG8gdGhlIG1hcFxyXG5cdFx0Ly8gSWYgeW91IGFyZSBhZGRpbmcgaW5kaXZpZHVhbCBtYXJrZXJzIHNldCB0byB0cnVlLCBpZiBhZGRpbmcgYnVsayBtYXJrZXJzIGxlYXZlIGZhbHNlIGZvciBtYXNzaXZlIHBlcmZvcm1hbmNlIGdhaW5zLlxyXG5cdFx0YW5pbWF0ZUFkZGluZ01hcmtlcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vSW5jcmVhc2UgdG8gaW5jcmVhc2UgdGhlIGRpc3RhbmNlIGF3YXkgdGhhdCBzcGlkZXJmaWVkIG1hcmtlcnMgYXBwZWFyIGZyb20gdGhlIGNlbnRlclxyXG5cdFx0c3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXI6IDEsXHJcblxyXG5cdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcG9seWxpbmUgb3B0aW9ucyBvbiBhIHNwaWRlciBsZWdcclxuXHRcdHNwaWRlckxlZ1BvbHlsaW5lT3B0aW9uczogeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogMC41IH0sXHJcblxyXG5cdFx0Ly8gV2hlbiBidWxrIGFkZGluZyBsYXllcnMsIGFkZHMgbWFya2VycyBpbiBjaHVua3MuIE1lYW5zIGFkZExheWVycyBtYXkgbm90IGFkZCBhbGwgdGhlIGxheWVycyBpbiB0aGUgY2FsbCwgb3RoZXJzIHdpbGwgYmUgbG9hZGVkIGR1cmluZyBzZXRUaW1lb3V0c1xyXG5cdFx0Y2h1bmtlZExvYWRpbmc6IGZhbHNlLFxyXG5cdFx0Y2h1bmtJbnRlcnZhbDogMjAwLCAvLyBwcm9jZXNzIG1hcmtlcnMgZm9yIGEgbWF4aW11bSBvZiB+IG4gbWlsbGlzZWNvbmRzICh0aGVuIHRyaWdnZXIgdGhlIGNodW5rUHJvZ3Jlc3MgY2FsbGJhY2spXHJcblx0XHRjaHVua0RlbGF5OiA1MCwgLy8gYXQgdGhlIGVuZCBvZiBlYWNoIGludGVydmFsLCBnaXZlIG4gbWlsbGlzZWNvbmRzIGJhY2sgdG8gc3lzdGVtL2Jyb3dzZXJcclxuXHRcdGNodW5rUHJvZ3Jlc3M6IG51bGwsIC8vIHByb2dyZXNzIGNhbGxiYWNrOiBmdW5jdGlvbihwcm9jZXNzZWQsIHRvdGFsLCBlbGFwc2VkKSAoZS5nLiBmb3IgYSBwcm9ncmVzcyBpbmRpY2F0b3IpXHJcblxyXG5cdFx0Ly9PcHRpb25zIHRvIHBhc3MgdG8gdGhlIEwuUG9seWdvbiBjb25zdHJ1Y3RvclxyXG5cdFx0cG9seWdvbk9wdGlvbnM6IHt9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XHJcblx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcclxuXHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTsgLy9NYXJrZXJzIHJlbW92ZWQgd2hpbGUgd2UgYXJlbid0IG9uIHRoZSBtYXAgbmVlZCB0byBiZSBrZXB0IHRyYWNrIG9mXHJcblx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuX3F1ZXVlID0gW107XHJcblxyXG5cdFx0dGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzID0ge1xyXG5cdFx0XHQnZHJhZ3N0YXJ0JzogdGhpcy5fY2hpbGRNYXJrZXJEcmFnU3RhcnQsXHJcblx0XHRcdCdtb3ZlJzogdGhpcy5fY2hpbGRNYXJrZXJNb3ZlZCxcclxuXHRcdFx0J2RyYWdlbmQnOiB0aGlzLl9jaGlsZE1hcmtlckRyYWdFbmQsXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEhvb2sgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBtZXRob2RzLlxyXG5cdFx0dmFyIGFuaW1hdGUgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0ZTtcclxuXHRcdEwuZXh0ZW5kKHRoaXMsIGFuaW1hdGUgPyB0aGlzLl93aXRoQW5pbWF0aW9uIDogdGhpcy5fbm9BbmltYXRpb24pO1xyXG5cdFx0Ly8gUmVtZW1iZXIgd2hpY2ggTWFya2VyQ2x1c3RlciBjbGFzcyB0byBpbnN0YW50aWF0ZSAoYW5pbWF0ZWQgb3Igbm90KS5cclxuXHRcdHRoaXMuX21hcmtlckNsdXN0ZXIgPSBhbmltYXRlID8gTC5NYXJrZXJDbHVzdGVyIDogTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQ7XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Eb24ndCBjbHVzdGVyIG5vbiBwb2ludCBkYXRhXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZExheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcucHVzaChsYXllcik7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvL0lmIHdlIGhhdmUgYWxyZWFkeSBjbHVzdGVyZWQgd2UnbGwgbmVlZCB0byBhZGQgdGhpcyBvbmUgdG8gYSBjbHVzdGVyXHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcclxuXHRcdHZhciB2aXNpYmxlTGF5ZXIgPSBsYXllcixcclxuXHRcdCAgICBjdXJyZW50Wm9vbSA9IHRoaXMuX3pvb207XHJcblx0XHRpZiAobGF5ZXIuX19wYXJlbnQpIHtcclxuXHRcdFx0d2hpbGUgKHZpc2libGVMYXllci5fX3BhcmVudC5fem9vbSA+PSBjdXJyZW50Wm9vbSkge1xyXG5cdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMuY29udGFpbnModmlzaWJsZUxheWVyLmdldExhdExuZygpKSkge1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmFuaW1hdGVBZGRpbmdNYXJrZXJzKSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXIobGF5ZXIsIHZpc2libGVMYXllcik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgdmlzaWJsZUxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cclxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYXllcnMoW2xheWVyXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Ob24gcG9pbnQgbGF5ZXJzXHJcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xyXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbGF5ZXIpICYmIHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdFx0dGhpcy5fbmVlZHNSZW1vdmluZy5wdXNoKHsgbGF5ZXI6IGxheWVyLCBsYXRsbmc6IGxheWVyLl9sYXRsbmcgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxheWVyLl9fcGFyZW50KSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XHJcblx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gY2x1c3RlcnNcclxuXHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLCB0cnVlKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0bGF5ZXIub2ZmKHRoaXMuX2NoaWxkTWFya2VyRXZlbnRIYW5kbGVycywgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ZlYXR1cmVHcm91cC5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XHJcblx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vVGFrZXMgYW4gYXJyYXkgb2YgbWFya2VycyBhbmQgYWRkcyB0aGVtIGluIGJ1bGtcclxuXHRhZGRMYXllcnM6IGZ1bmN0aW9uIChsYXllcnNBcnJheSwgc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdGlmICghTC5VdGlsLmlzQXJyYXkobGF5ZXJzQXJyYXkpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyc0FycmF5KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBjaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5rZWRMb2FkaW5nLFxyXG5cdFx0ICAgIGNodW5rSW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMuY2h1bmtJbnRlcnZhbCxcclxuXHRcdCAgICBjaHVua1Byb2dyZXNzID0gdGhpcy5vcHRpb25zLmNodW5rUHJvZ3Jlc3MsXHJcblx0XHQgICAgbCA9IGxheWVyc0FycmF5Lmxlbmd0aCxcclxuXHRcdCAgICBvZmZzZXQgPSAwLFxyXG5cdFx0ICAgIG9yaWdpbmFsQXJyYXkgPSB0cnVlLFxyXG5cdFx0ICAgIG07XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR2YXIgc3RhcnRlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcblx0XHRcdHZhciBwcm9jZXNzID0gTC5iaW5kKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHRcdGZvciAoOyBvZmZzZXQgPCBsOyBvZmZzZXQrKykge1xyXG5cdFx0XHRcdFx0aWYgKGNodW5rZWQgJiYgb2Zmc2V0ICUgMjAwID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdC8vIGV2ZXJ5IGNvdXBsZSBodW5kcmVkIG1hcmtlcnMsIGluc3RydW1lbnQgdGhlIHRpbWUgZWxhcHNlZCBzaW5jZSBwcm9jZXNzaW5nIHN0YXJ0ZWQ6XHJcblx0XHRcdFx0XHRcdHZhciBlbGFwc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xyXG5cdFx0XHRcdFx0XHRpZiAoZWxhcHNlZCA+IGNodW5rSW50ZXJ2YWwpIHtcclxuXHRcdFx0XHRcdFx0XHRicmVhazsgLy8gYmVlbiB3b3JraW5nIHRvbyBoYXJkLCB0aW1lIHRvIHRha2UgYSBicmVhayA6LSlcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheVtvZmZzZXRdO1xyXG5cclxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdFx0Ly8gU2lkZSBlZmZlY3RzOlxyXG5cdFx0XHRcdFx0Ly8gLSBUb3RhbCBpbmNyZWFzZXMsIHNvIGNodW5rUHJvZ3Jlc3MgcmF0aW8ganVtcHMgYmFja3dhcmQuXHJcblx0XHRcdFx0XHQvLyAtIEdyb3VwcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAsIG9ubHkgdGhlaXIgbm9uLWdyb3VwIGNoaWxkIGxheWVycyAoaGFzTGF5ZXIpLlxyXG5cdFx0XHRcdFx0Ly8gQ2hhbmdpbmcgYXJyYXkgbGVuZ3RoIHdoaWxlIGxvb3BpbmcgZG9lcyBub3QgYWZmZWN0IHBlcmZvcm1hbmNlIGluIGN1cnJlbnQgYnJvd3NlcnM6XHJcblx0XHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mb3ItbG9vcC1jaGFuZ2luZy1sZW5ndGgvNlxyXG5cdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vTm90IHBvaW50IGRhdGEsIGNhbid0IGJlIGNsdXN0ZXJlZFxyXG5cdFx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xyXG5cdFx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5oYXNMYXllcihtKSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihtLCB0aGlzLl9tYXhab29tKTtcclxuXHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9JZiB3ZSBqdXN0IG1hZGUgYSBjbHVzdGVyIG9mIHNpemUgMiB0aGVuIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBvdGhlciBtYXJrZXIgZnJvbSB0aGUgbWFwIChpZiBpdCBpcykgb3Igd2UgbmV2ZXIgd2lsbFxyXG5cdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKG0uX19wYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAyKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG1hcmtlcnMgPSBtLl9fcGFyZW50LmdldEFsbENoaWxkTWFya2VycygpLFxyXG5cdFx0XHRcdFx0XHRcdCAgICBvdGhlck1hcmtlciA9IG1hcmtlcnNbMF0gPT09IG0gPyBtYXJrZXJzWzFdIDogbWFya2Vyc1swXTtcclxuXHRcdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihvdGhlck1hcmtlcik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjaHVua1Byb2dyZXNzKSB7XHJcblx0XHRcdFx0XHQvLyByZXBvcnQgcHJvZ3Jlc3MgYW5kIHRpbWUgZWxhcHNlZDpcclxuXHRcdFx0XHRcdGNodW5rUHJvZ3Jlc3Mob2Zmc2V0LCBsLCAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnRlZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBDb21wbGV0ZWQgcHJvY2Vzc2luZyBhbGwgbWFya2Vycy5cclxuXHRcdFx0XHRpZiAob2Zmc2V0ID09PSBsKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHNldFRpbWVvdXQocHJvY2VzcywgdGhpcy5vcHRpb25zLmNodW5rRGVsYXkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRwcm9jZXNzKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbmVlZHNDbHVzdGVyaW5nID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xyXG5cclxuXHRcdFx0Zm9yICg7IG9mZnNldCA8IGw7IG9mZnNldCsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XHJcblx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XHJcblx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcclxuXHRcdFx0XHRpZiAoIW0uZ2V0TGF0TG5nKSB7XHJcblx0XHRcdFx0XHRucGcuYWRkTGF5ZXIobSk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5lZWRzQ2x1c3RlcmluZy5wdXNoKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIHJlbW92ZXMgdGhlbSBpbiBidWxrXHJcblx0cmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzQXJyYXkpIHtcclxuXHRcdHZhciBpLCBtLFxyXG5cdFx0ICAgIGwgPSBsYXllcnNBcnJheS5sZW5ndGgsXHJcblx0XHQgICAgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcclxuXHRcdCAgICBvcmlnaW5hbEFycmF5ID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W2ldO1xyXG5cclxuXHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xyXG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBtKTtcclxuXHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcucHVzaCh7IGxheWVyOiBtLCBsYXRsbmc6IG0uX2xhdGxuZyB9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IG0gfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3Vuc3BpZGVyZnkpIHtcclxuXHRcdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cclxuXHRcdFx0Ly8gV29yayBvbiBhIGNvcHkgb2YgdGhlIGFycmF5LCBzbyB0aGF0IG5leHQgbG9vcCBpcyBub3QgYWZmZWN0ZWQuXHJcblx0XHRcdHZhciBsYXllcnNBcnJheTIgPSBsYXllcnNBcnJheS5zbGljZSgpLFxyXG5cdFx0XHQgICAgbDIgPSBsO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDI7IGkrKykge1xyXG5cdFx0XHRcdG0gPSBsYXllcnNBcnJheTJbaV07XHJcblxyXG5cdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxyXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkyKTtcclxuXHRcdFx0XHRcdGwyID0gbGF5ZXJzQXJyYXkyLmxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fdW5zcGlkZXJmeUxheWVyKG0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XHJcblxyXG5cdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cclxuXHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xyXG5cdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xyXG5cdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghbS5fX3BhcmVudCkge1xyXG5cdFx0XHRcdG5wZy5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbSB9KTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobSwgdHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xyXG5cclxuXHRcdFx0aWYgKGZnLmhhc0xheWVyKG0pKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cclxuXHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XHJcblxyXG5cdFx0Ly9GaXggdXAgdGhlIGNsdXN0ZXJzIGFuZCBtYXJrZXJzIG9uIHRoZSBtYXBcclxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly9SZW1vdmVzIGFsbCBsYXllcnMgZnJvbSB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwXHJcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vTmVlZCBvdXIgb3duIHNwZWNpYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIExheWVyR3JvdXAgb25lIGRvZXNuJ3Qgd29yayBmb3IgdXNcclxuXHJcblx0XHQvL0lmIHdlIGFyZW4ndCBvbiB0aGUgbWFwICh5ZXQpLCBibG93IGF3YXkgdGhlIG1hcmtlcnMgd2Uga25vdyBvZlxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkQ2x1c3RlcnM7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSkge1xyXG5cdFx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL1JlbW92ZSBhbGwgdGhlIHZpc2libGUgbGF5ZXJzXHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuY2xlYXJMYXllcnMoKTtcclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAuY2xlYXJMYXllcnMoKTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobWFya2VyKSB7XHJcblx0XHRcdG1hcmtlci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcclxuXHRcdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0Ly9SZXNldCBfdG9wQ2x1c3RlckxldmVsIGFuZCB0aGUgRGlzdGFuY2VHcmlkc1xyXG5cdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGUgRmVhdHVyZUdyb3VwLmdldEJvdW5kcyBhcyBpdCBkb2Vzbid0IHdvcmtcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fdG9wQ2x1c3RlckxldmVsKSB7XHJcblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fdG9wQ2x1c3RlckxldmVsLl9ib3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9uZWVkc0NsdXN0ZXJpbmdbaV0uZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJvdW5kcy5leHRlbmQodGhpcy5fbm9uUG9pbnRHcm91cC5nZXRCb3VuZHMoKSk7XHJcblxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmVhY2hMYXllclxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0dmFyIG1hcmtlcnMgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmcuc2xpY2UoKSxcclxuXHRcdFx0bmVlZHNSZW1vdmluZyA9IHRoaXMuX25lZWRzUmVtb3ZpbmcsXHJcblx0XHRcdHRoaXNOZWVkc1JlbW92aW5nLCBpLCBqO1xyXG5cclxuXHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycyhtYXJrZXJzKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHRoaXNOZWVkc1JlbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdGZvciAoaiA9IG5lZWRzUmVtb3ZpbmcubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0XHRpZiAobmVlZHNSZW1vdmluZ1tqXS5sYXllciA9PT0gbWFya2Vyc1tpXSkge1xyXG5cdFx0XHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXNOZWVkc1JlbW92aW5nKSB7XHJcblx0XHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgbWFya2Vyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmVhY2hMYXllcihtZXRob2QsIGNvbnRleHQpO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZ2V0TGF5ZXJzXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobCkge1xyXG5cdFx0XHRsYXllcnMucHVzaChsKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIGxheWVycztcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyLCBXQVJOSU5HOiBSZWFsbHkgYmFkIHBlcmZvcm1hbmNlXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IG51bGw7XHJcblxyXG5cdFx0aWQgPSBwYXJzZUludChpZCwgMTApO1xyXG5cclxuXHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsKSB7XHJcblx0XHRcdGlmIChMLnN0YW1wKGwpID09PSBpZCkge1xyXG5cdFx0XHRcdHJlc3VsdCA9IGw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSxcclxuXHJcblx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGluIHRoaXMgTWFya2VyQ2x1c3Rlckdyb3VwXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGksIGFuQXJyYXkgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmc7XHJcblxyXG5cdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGFuQXJyYXkgPSB0aGlzLl9uZWVkc1JlbW92aW5nO1xyXG5cdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpZiAoYW5BcnJheVtpXS5sYXllciA9PT0gbGF5ZXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gISEobGF5ZXIuX19wYXJlbnQgJiYgbGF5ZXIuX19wYXJlbnQuX2dyb3VwID09PSB0aGlzKSB8fCB0aGlzLl9ub25Qb2ludEdyb3VwLmhhc0xheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvL1pvb20gZG93biB0byBzaG93IHRoZSBnaXZlbiBsYXllciAoc3BpZGVyZnlpbmcgaWYgbmVjZXNzYXJ5KSB0aGVuIGNhbGxzIHRoZSBjYWxsYmFja1xyXG5cdHpvb21Ub1Nob3dMYXllcjogZnVuY3Rpb24gKGxheWVyLCBjYWxsYmFjaykge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2hvd01hcmtlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKChsYXllci5faWNvbiB8fCBsYXllci5fX3BhcmVudC5faWNvbikgJiYgIXRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0XHR0aGlzLm9mZignYW5pbWF0aW9uZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdGlmIChsYXllci5faWNvbikge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll9pY29uKSB7XHJcblx0XHRcdFx0XHR0aGlzLm9uY2UoJ3NwaWRlcmZpZWQnLCBjYWxsYmFjaywgdGhpcyk7XHJcblx0XHRcdFx0XHRsYXllci5fX3BhcmVudC5zcGlkZXJmeSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAobGF5ZXIuX2ljb24gJiYgdGhpcy5fbWFwLmdldEJvdW5kcygpLmNvbnRhaW5zKGxheWVyLmdldExhdExuZygpKSkge1xyXG5cdFx0XHQvL0xheWVyIGlzIHZpc2libGUgb25kIG9uIHNjcmVlbiwgaW1tZWRpYXRlIHJldHVyblxyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fSBlbHNlIGlmIChsYXllci5fX3BhcmVudC5fem9vbSA8IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKSkge1xyXG5cdFx0XHQvL0xheWVyIHNob3VsZCBiZSB2aXNpYmxlIGF0IHRoaXMgem9vbSBsZXZlbC4gSXQgbXVzdCBub3QgYmUgb24gc2NyZWVuIHNvIGp1c3QgcGFuIG92ZXIgdG8gaXRcclxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblx0XHRcdHRoaXMuX21hcC5wYW5UbyhsYXllci5nZXRMYXRMbmcoKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5vbignYW5pbWF0aW9uZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XHJcblx0XHRcdGxheWVyLl9fcGFyZW50Lnpvb21Ub0JvdW5kcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vbkFkZFxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHR2YXIgaSwgbCwgbGF5ZXI7XHJcblxyXG5cdFx0aWYgKCFpc0Zpbml0ZSh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSkge1xyXG5cdFx0XHR0aHJvdyBcIk1hcCBoYXMgbm8gbWF4Wm9vbSBzcGVjaWZpZWRcIjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkVG8obWFwKTtcclxuXHRcdHRoaXMuX25vblBvaW50R3JvdXAuYWRkVG8obWFwKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2dyaWRDbHVzdGVycykge1xyXG5cdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21heExhdCA9IG1hcC5vcHRpb25zLmNycy5wcm9qZWN0aW9uLk1BWF9MQVRJVFVERTtcclxuXHJcblx0XHQvL1Jlc3RvcmUgYWxsIHRoZSBwb3NpdGlvbnMgYXMgdGhleSBhcmUgaW4gdGhlIE1DRyBiZWZvcmUgcmVtb3ZpbmcgdGhlbVxyXG5cdFx0Zm9yIChpID0gMCwgbCA9IHRoaXMuX25lZWRzUmVtb3ZpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbmVlZHNSZW1vdmluZ1tpXTtcclxuXHRcdFx0bGF5ZXIubmV3bGF0bG5nID0gbGF5ZXIubGF5ZXIuX2xhdGxuZztcclxuXHRcdFx0bGF5ZXIubGF5ZXIuX2xhdGxuZyA9IGxheWVyLmxhdGxuZztcclxuXHRcdH1cclxuXHRcdC8vUmVtb3ZlIHRoZW0sIHRoZW4gcmVzdG9yZSB0aGVpciBuZXcgcG9zaXRpb25zXHJcblx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy5fbmVlZHNSZW1vdmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9uZWVkc1JlbW92aW5nW2ldO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVMYXllcihsYXllci5sYXllciwgdHJ1ZSk7XHJcblx0XHRcdGxheWVyLmxheWVyLl9sYXRsbmcgPSBsYXllci5uZXdsYXRsbmc7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9uZWVkc1JlbW92aW5nID0gW107XHJcblxyXG5cdFx0Ly9SZW1lbWJlciB0aGUgY3VycmVudCB6b29tIGxldmVsIGFuZCBib3VuZHNcclxuXHRcdHRoaXMuX3pvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XHJcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl96b29tRW5kLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVyT25BZGQpIHsgLy9UT0RPIEZJWE1FOiBOb3Qgc3VyZSBob3cgdG8gaGF2ZSBzcGlkZXJmaWVyIGFkZCBzb21ldGhpbmcgb24gaGVyZSBuaWNlbHlcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllck9uQWRkKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmluZEV2ZW50cygpO1xyXG5cclxuXHRcdC8vQWN0dWFsbHkgYWRkIG91ciBtYXJrZXJzIHRvIHRoZSBtYXA6XHJcblx0XHRsID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xyXG5cdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XHJcblx0XHR0aGlzLmFkZExheWVycyhsLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvL092ZXJyaWRlcyBGZWF0dXJlR3JvdXAub25SZW1vdmVcclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCcsIHRoaXMuX3pvb21FbmQsIHRoaXMpO1xyXG5cdFx0bWFwLm9mZignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX3VuYmluZEV2ZW50cygpO1xyXG5cclxuXHRcdC8vSW4gY2FzZSB3ZSBhcmUgaW4gYSBjbHVzdGVyIGFuaW1hdGlvblxyXG5cdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSA9IHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY2x1c3Rlci1hbmltJywgJycpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUpIHsgLy9UT0RPIEZJWE1FOiBOb3Qgc3VyZSBob3cgdG8gaGF2ZSBzcGlkZXJmaWVyIGFkZCBzb21ldGhpbmcgb24gaGVyZSBuaWNlbHlcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllck9uUmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIHRoaXMuX21heExhdDtcclxuXHJcblx0XHQvL0NsZWFuIHVwIGFsbCB0aGUgbGF5ZXJzIHdlIGFkZGVkIHRvIHRoZSBtYXBcclxuXHRcdHRoaXMuX2hpZGVDb3ZlcmFnZSgpO1xyXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5yZW1vdmUoKTtcclxuXHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuY2xlYXJMYXllcnMoKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldFZpc2libGVQYXJlbnQ6IGZ1bmN0aW9uIChtYXJrZXIpIHtcclxuXHRcdHZhciB2TWFya2VyID0gbWFya2VyO1xyXG5cdFx0d2hpbGUgKHZNYXJrZXIgJiYgIXZNYXJrZXIuX2ljb24pIHtcclxuXHRcdFx0dk1hcmtlciA9IHZNYXJrZXIuX19wYXJlbnQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdk1hcmtlciB8fCBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8vUmVtb3ZlIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXlcclxuXHRfYXJyYXlTcGxpY2U6IGZ1bmN0aW9uIChhbkFycmF5LCBvYmopIHtcclxuXHRcdGZvciAodmFyIGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmIChhbkFycmF5W2ldID09PSBvYmopIHtcclxuXHRcdFx0XHRhbkFycmF5LnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgYSBtYXJrZXIgZnJvbSBhbGwgX2dyaWRVbmNsdXN0ZXJlZCB6b29tIGxldmVscywgc3RhcnRpbmcgYXQgdGhlIHN1cHBsaWVkIHpvb20uXHJcblx0ICogQHBhcmFtIG1hcmtlciB0byBiZSByZW1vdmVkIGZyb20gX2dyaWRVbmNsdXN0ZXJlZC5cclxuXHQgKiBAcGFyYW0geiBpbnRlZ2VyIGJvdHRvbSBzdGFydCB6b29tIGxldmVsIChpbmNsdWRlZClcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkOiBmdW5jdGlvbiAobWFya2VyLCB6KSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XHJcblxyXG5cdFx0Zm9yICg7IHogPj0gbWluWm9vbTsgei0tKSB7XHJcblx0XHRcdGlmICghZ3JpZFVuY2x1c3RlcmVkW3pdLnJlbW92ZU9iamVjdChtYXJrZXIsIG1hcC5wcm9qZWN0KG1hcmtlci5nZXRMYXRMbmcoKSwgeikpKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hpbGRNYXJrZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRlLnRhcmdldC5fX2RyYWdTdGFydCA9IGUudGFyZ2V0Ll9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0X2NoaWxkTWFya2VyTW92ZWQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2lnbm9yZU1vdmUgJiYgIWUudGFyZ2V0Ll9fZHJhZ1N0YXJ0KSB7XHJcblx0XHRcdHZhciBpc1BvcHVwT3BlbiA9IGUudGFyZ2V0Ll9wb3B1cCAmJiBlLnRhcmdldC5fcG9wdXAuaXNPcGVuKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGUub2xkTGF0TG5nLCBlLmxhdGxuZyk7XHJcblxyXG5cdFx0XHRpZiAoaXNQb3B1cE9wZW4pIHtcclxuXHRcdFx0XHRlLnRhcmdldC5vcGVuUG9wdXAoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChsYXllciwgZnJvbSwgdG8pIHtcclxuXHRcdGxheWVyLl9sYXRsbmcgPSBmcm9tO1xyXG5cdFx0dGhpcy5yZW1vdmVMYXllcihsYXllcik7XHJcblxyXG5cdFx0bGF5ZXIuX2xhdGxuZyA9IHRvO1xyXG5cdFx0dGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0X2NoaWxkTWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmIChlLnRhcmdldC5fX2RyYWdTdGFydCkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0LCBlLnRhcmdldC5fbGF0bG5nKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSBlLnRhcmdldC5fX2RyYWdTdGFydDtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly9JbnRlcm5hbCBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYSBtYXJrZXIgZnJvbSBldmVyeXRoaW5nLlxyXG5cdC8vZG9udFVwZGF0ZU1hcDogc2V0IHRvIHRydWUgaWYgeW91IHdpbGwgaGFuZGxlIHVwZGF0aW5nIHRoZSBtYXAgbWFudWFsbHkgKGZvciBidWxrIGZ1bmN0aW9ucylcclxuXHRfcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChtYXJrZXIsIHJlbW92ZUZyb21EaXN0YW5jZUdyaWQsIGRvbnRVcGRhdGVNYXApIHtcclxuXHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXHJcblx0XHRcdGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcclxuXHRcdFx0ZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXHJcblx0XHRcdG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XHJcblxyXG5cdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIGRpc3RhbmNlIGNsdXN0ZXJzIGl0IG1pZ2h0IGJlIGluXHJcblx0XHRpZiAocmVtb3ZlRnJvbURpc3RhbmNlR3JpZCkge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkKG1hcmtlciwgdGhpcy5fbWF4Wm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9Xb3JrIG91ciB3YXkgdXAgdGhlIGNsdXN0ZXJzIHJlbW92aW5nIHRoZW0gYXMgd2UgZ28gaWYgcmVxdWlyZWRcclxuXHRcdHZhciBjbHVzdGVyID0gbWFya2VyLl9fcGFyZW50LFxyXG5cdFx0XHRtYXJrZXJzID0gY2x1c3Rlci5fbWFya2VycyxcclxuXHRcdFx0b3RoZXJNYXJrZXI7XHJcblxyXG5cdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBpbW1lZGlhdGUgcGFyZW50cyBtYXJrZXIgbGlzdFxyXG5cdFx0dGhpcy5fYXJyYXlTcGxpY2UobWFya2VycywgbWFya2VyKTtcclxuXHJcblx0XHR3aGlsZSAoY2x1c3Rlcikge1xyXG5cdFx0XHRjbHVzdGVyLl9jaGlsZENvdW50LS07XHJcblx0XHRcdGNsdXN0ZXIuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKGNsdXN0ZXIuX3pvb20gPCBtaW5ab29tKSB7XHJcblx0XHRcdFx0Ly9Ub3AgbGV2ZWwsIGRvIG5vdGhpbmdcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fSBlbHNlIGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkICYmIGNsdXN0ZXIuX2NoaWxkQ291bnQgPD0gMSkgeyAvL0NsdXN0ZXIgbm8gbG9uZ2VyIHJlcXVpcmVkXHJcblx0XHRcdFx0Ly9XZSBuZWVkIHRvIHB1c2ggdGhlIG90aGVyIG1hcmtlciB1cCB0byB0aGUgcGFyZW50XHJcblx0XHRcdFx0b3RoZXJNYXJrZXIgPSBjbHVzdGVyLl9tYXJrZXJzWzBdID09PSBtYXJrZXIgPyBjbHVzdGVyLl9tYXJrZXJzWzFdIDogY2x1c3Rlci5fbWFya2Vyc1swXTtcclxuXHJcblx0XHRcdFx0Ly9VcGRhdGUgZGlzdGFuY2UgZ3JpZFxyXG5cdFx0XHRcdGdyaWRDbHVzdGVyc1tjbHVzdGVyLl96b29tXS5yZW1vdmVPYmplY3QoY2x1c3RlciwgbWFwLnByb2plY3QoY2x1c3Rlci5fY0xhdExuZywgY2x1c3Rlci5fem9vbSkpO1xyXG5cdFx0XHRcdGdyaWRVbmNsdXN0ZXJlZFtjbHVzdGVyLl96b29tXS5hZGRPYmplY3Qob3RoZXJNYXJrZXIsIG1hcC5wcm9qZWN0KG90aGVyTWFya2VyLmdldExhdExuZygpLCBjbHVzdGVyLl96b29tKSk7XHJcblxyXG5cdFx0XHRcdC8vTW92ZSBvdGhlck1hcmtlciB1cCB0byBwYXJlbnRcclxuXHRcdFx0XHR0aGlzLl9hcnJheVNwbGljZShjbHVzdGVyLl9fcGFyZW50Ll9jaGlsZENsdXN0ZXJzLCBjbHVzdGVyKTtcclxuXHRcdFx0XHRjbHVzdGVyLl9fcGFyZW50Ll9tYXJrZXJzLnB1c2gob3RoZXJNYXJrZXIpO1xyXG5cdFx0XHRcdG90aGVyTWFya2VyLl9fcGFyZW50ID0gY2x1c3Rlci5fX3BhcmVudDtcclxuXHJcblx0XHRcdFx0aWYgKGNsdXN0ZXIuX2ljb24pIHtcclxuXHRcdFx0XHRcdC8vQ2x1c3RlciBpcyBjdXJyZW50bHkgb24gdGhlIG1hcCwgbmVlZCB0byBwdXQgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGluc3RlYWRcclxuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGNsdXN0ZXIpO1xyXG5cdFx0XHRcdFx0aWYgKCFkb250VXBkYXRlTWFwKSB7XHJcblx0XHRcdFx0XHRcdGZnLmFkZExheWVyKG90aGVyTWFya2VyKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2x1c3Rlci5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y2x1c3RlciA9IGNsdXN0ZXIuX19wYXJlbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcclxuXHR9LFxyXG5cclxuXHRfaXNPcklzUGFyZW50OiBmdW5jdGlvbiAoZWwsIG9lbCkge1xyXG5cdFx0d2hpbGUgKG9lbCkge1xyXG5cdFx0XHRpZiAoZWwgPT09IG9lbCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG9lbCA9IG9lbC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmZpcmVcclxuXHRmaXJlOiBmdW5jdGlvbiAodHlwZSwgZGF0YSwgcHJvcGFnYXRlKSB7XHJcblx0XHRpZiAoZGF0YSAmJiBkYXRhLmxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSB7XHJcblx0XHRcdC8vUHJldmVudCBtdWx0aXBsZSBjbHVzdGVybW91c2VvdmVyL29mZiBldmVudHMgaWYgdGhlIGljb24gaXMgbWFkZSB1cCBvZiBzdGFja2VkIGRpdnMgKERvZXNuJ3Qgd29yayBpbiBpZSA8PSA4LCBubyByZWxhdGVkVGFyZ2V0KVxyXG5cdFx0XHRpZiAoZGF0YS5vcmlnaW5hbEV2ZW50ICYmIHRoaXMuX2lzT3JJc1BhcmVudChkYXRhLmxheWVyLl9pY29uLCBkYXRhLm9yaWdpbmFsRXZlbnQucmVsYXRlZFRhcmdldCkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZSA9ICdjbHVzdGVyJyArIHR5cGU7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmZpcmUuY2FsbCh0aGlzLCB0eXBlLCBkYXRhLCBwcm9wYWdhdGUpO1xyXG5cdH0sXHJcblxyXG5cdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmxpc3RlbnNcclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHRyZXR1cm4gTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCB0eXBlLCBwcm9wYWdhdGUpIHx8IEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5saXN0ZW5zLmNhbGwodGhpcywgJ2NsdXN0ZXInICsgdHlwZSwgcHJvcGFnYXRlKTtcclxuXHR9LFxyXG5cclxuXHQvL0RlZmF1bHQgZnVuY3Rpb25hbGl0eVxyXG5cdF9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uOiBmdW5jdGlvbiAoY2x1c3Rlcikge1xyXG5cdFx0dmFyIGNoaWxkQ291bnQgPSBjbHVzdGVyLmdldENoaWxkQ291bnQoKTtcclxuXHJcblx0XHR2YXIgYyA9ICcgbWFya2VyLWNsdXN0ZXItJztcclxuXHRcdGlmIChjaGlsZENvdW50IDwgMTApIHtcclxuXHRcdFx0YyArPSAnc21hbGwnO1xyXG5cdFx0fSBlbHNlIGlmIChjaGlsZENvdW50IDwgMTAwKSB7XHJcblx0XHRcdGMgKz0gJ21lZGl1bSc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjICs9ICdsYXJnZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkRpdkljb24oeyBodG1sOiAnPGRpdj48c3Bhbj4nICsgY2hpbGRDb3VudCArICc8L3NwYW4+PC9kaXY+JywgY2xhc3NOYW1lOiAnbWFya2VyLWNsdXN0ZXInICsgYywgaWNvblNpemU6IG5ldyBMLlBvaW50KDQwLCA0MCkgfSk7XHJcblx0fSxcclxuXHJcblx0X2JpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgc3BpZGVyZnlPbk1heFpvb20gPSB0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20sXHJcblx0XHQgICAgc2hvd0NvdmVyYWdlT25Ib3ZlciA9IHRoaXMub3B0aW9ucy5zaG93Q292ZXJhZ2VPbkhvdmVyLFxyXG5cdFx0ICAgIHpvb21Ub0JvdW5kc09uQ2xpY2sgPSB0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljaztcclxuXHJcblx0XHQvL1pvb20gb24gY2x1c3RlciBjbGljayBvciBzcGlkZXJmeSBpZiB3ZSBhcmUgYXQgdGhlIGxvd2VzdCBsZXZlbFxyXG5cdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5vbignY2x1c3RlcmNsaWNrJywgdGhpcy5fem9vbU9yU3BpZGVyZnksIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vU2hvdyBjb252ZXggaHVsbCAoYm91bmRhcnkpIHBvbHlnb24gb24gbW91c2Ugb3ZlclxyXG5cdFx0aWYgKHNob3dDb3ZlcmFnZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3pvb21PclNwaWRlcmZ5OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGNsdXN0ZXIgPSBlLmxheWVyLFxyXG5cdFx0ICAgIGJvdHRvbUNsdXN0ZXIgPSBjbHVzdGVyO1xyXG5cclxuXHRcdHdoaWxlIChib3R0b21DbHVzdGVyLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRib3R0b21DbHVzdGVyID0gYm90dG9tQ2x1c3Rlci5fY2hpbGRDbHVzdGVyc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYm90dG9tQ2x1c3Rlci5fem9vbSA9PT0gdGhpcy5fbWF4Wm9vbSAmJlxyXG5cdFx0XHRib3R0b21DbHVzdGVyLl9jaGlsZENvdW50ID09PSBjbHVzdGVyLl9jaGlsZENvdW50ICYmXHJcblx0XHRcdHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSkge1xyXG5cclxuXHRcdFx0Ly8gQWxsIGNoaWxkIG1hcmtlcnMgYXJlIGNvbnRhaW5lZCBpbiBhIHNpbmdsZSBjbHVzdGVyIGZyb20gdGhpcy5fbWF4Wm9vbSB0byB0aGlzIGNsdXN0ZXIuXHJcblx0XHRcdGNsdXN0ZXIuc3BpZGVyZnkoKTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2spIHtcclxuXHRcdFx0Y2x1c3Rlci56b29tVG9Cb3VuZHMoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGb2N1cyB0aGUgbWFwIGFnYWluIGZvciBrZXlib2FyZCB1c2Vycy5cclxuXHRcdGlmIChlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmtleUNvZGUgPT09IDEzKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3Nob3dDb3ZlcmFnZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9zaG93blBvbHlnb24pIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XHJcblx0XHR9XHJcblx0XHRpZiAoZS5sYXllci5nZXRDaGlsZENvdW50KCkgPiAyICYmIGUubGF5ZXIgIT09IHRoaXMuX3NwaWRlcmZpZWQpIHtcclxuXHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbmV3IEwuUG9seWdvbihlLmxheWVyLmdldENvbnZleEh1bGwoKSwgdGhpcy5vcHRpb25zLnBvbHlnb25PcHRpb25zKTtcclxuXHRcdFx0bWFwLmFkZExheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2hpZGVDb3ZlcmFnZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcclxuXHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbnVsbDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdW5iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3BpZGVyZnlPbk1heFpvb20gPSB0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20sXHJcblx0XHRcdHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3ZlcixcclxuXHRcdFx0em9vbVRvQm91bmRzT25DbGljayA9IHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrLFxyXG5cdFx0XHRtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2spIHtcclxuXHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJjbGljaycsIHRoaXMuX3pvb21PclNwaWRlcmZ5LCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKCdjbHVzdGVybW91c2VvdmVyJywgdGhpcy5fc2hvd0NvdmVyYWdlLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF96b29tRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyAvL01heSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYnkgYSB6b29tRW5kIGhhbmRsZXJcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fbWVyZ2VTcGxpdENsdXN0ZXJzKCk7XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcclxuXHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3Qm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XHJcblxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIG5ld0JvdW5kcyk7XHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSksIG5ld0JvdW5kcyk7XHJcblxyXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gbmV3Qm91bmRzO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH0sXHJcblxyXG5cdF9nZW5lcmF0ZUluaXRpYWxDbHVzdGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1heFpvb20gPSBNYXRoLmNlaWwodGhpcy5fbWFwLmdldE1heFpvb20oKSksXHJcblx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLFxyXG5cdFx0XHRyYWRpdXMgPSB0aGlzLm9wdGlvbnMubWF4Q2x1c3RlclJhZGl1cyxcclxuXHRcdFx0cmFkaXVzRm4gPSByYWRpdXM7XHJcblxyXG5cdFx0Ly9JZiB3ZSBqdXN0IHNldCBtYXhDbHVzdGVyUmFkaXVzIHRvIGEgc2luZ2xlIG51bWJlciwgd2UgbmVlZCB0byBjcmVhdGVcclxuXHRcdC8vYSBzaW1wbGUgZnVuY3Rpb24gdG8gcmV0dXJuIHRoYXQgbnVtYmVyLiBPdGhlcndpc2UsIHdlIGp1c3QgaGF2ZSB0b1xyXG5cdFx0Ly91c2UgdGhlIGZ1bmN0aW9uIHdlJ3ZlIHBhc3NlZCBpbi5cclxuXHRcdGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0cmFkaXVzRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByYWRpdXM7IH07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSAhPT0gbnVsbCkge1xyXG5cdFx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLmRpc2FibGVDbHVzdGVyaW5nQXRab29tIC0gMTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX21heFpvb20gPSBtYXhab29tO1xyXG5cdFx0dGhpcy5fZ3JpZENsdXN0ZXJzID0ge307XHJcblx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWQgPSB7fTtcclxuXHJcblx0XHQvL1NldCB1cCBEaXN0YW5jZUdyaWRzIGZvciBlYWNoIHpvb21cclxuXHRcdGZvciAodmFyIHpvb20gPSBtYXhab29tOyB6b29tID49IG1pblpvb207IHpvb20tLSkge1xyXG5cdFx0XHR0aGlzLl9ncmlkQ2x1c3RlcnNbem9vbV0gPSBuZXcgTC5EaXN0YW5jZUdyaWQocmFkaXVzRm4oem9vbSkpO1xyXG5cdFx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWRbem9vbV0gPSBuZXcgTC5EaXN0YW5jZUdyaWQocmFkaXVzRm4oem9vbSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluc3RhbnRpYXRlIHRoZSBhcHByb3ByaWF0ZSBMLk1hcmtlckNsdXN0ZXIgY2xhc3MgKGFuaW1hdGVkIG9yIG5vdCkuXHJcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCBtaW5ab29tIC0gMSk7XHJcblx0fSxcclxuXHJcblx0Ly9ab29tOiBab29tIHRvIHN0YXJ0IGFkZGluZyBhdCAoUGFzcyB0aGlzLl9tYXhab29tIHRvIHN0YXJ0IGF0IHRoZSBib3R0b20pXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIHpvb20pIHtcclxuXHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXHJcblx0XHQgICAgZ3JpZFVuY2x1c3RlcmVkID0gdGhpcy5fZ3JpZFVuY2x1c3RlcmVkLFxyXG5cdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcclxuXHRcdCAgICBtYXJrZXJQb2ludCwgejtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnNpbmdsZU1hcmtlck1vZGUpIHtcclxuXHRcdFx0dGhpcy5fb3ZlcnJpZGVNYXJrZXJJY29uKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5vbih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xyXG5cclxuXHRcdC8vRmluZCB0aGUgbG93ZXN0IHpvb20gbGV2ZWwgdG8gc2xvdCB0aGlzIG9uZSBpblxyXG5cdFx0Zm9yICg7IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XHJcblx0XHRcdG1hcmtlclBvaW50ID0gdGhpcy5fbWFwLnByb2plY3QobGF5ZXIuZ2V0TGF0TG5nKCksIHpvb20pOyAvLyBjYWxjdWxhdGUgcGl4ZWwgcG9zaXRpb25cclxuXHJcblx0XHRcdC8vVHJ5IGZpbmQgYSBjbHVzdGVyIGNsb3NlIGJ5XHJcblx0XHRcdHZhciBjbG9zZXN0ID0gZ3JpZENsdXN0ZXJzW3pvb21dLmdldE5lYXJPYmplY3QobWFya2VyUG9pbnQpO1xyXG5cdFx0XHRpZiAoY2xvc2VzdCkge1xyXG5cdFx0XHRcdGNsb3Nlc3QuX2FkZENoaWxkKGxheWVyKTtcclxuXHRcdFx0XHRsYXllci5fX3BhcmVudCA9IGNsb3Nlc3Q7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1RyeSBmaW5kIGEgbWFya2VyIGNsb3NlIGJ5IHRvIGZvcm0gYSBuZXcgY2x1c3RlciB3aXRoXHJcblx0XHRcdGNsb3Nlc3QgPSBncmlkVW5jbHVzdGVyZWRbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XHJcblx0XHRcdGlmIChjbG9zZXN0KSB7XHJcblx0XHRcdFx0dmFyIHBhcmVudCA9IGNsb3Nlc3QuX19wYXJlbnQ7XHJcblx0XHRcdFx0aWYgKHBhcmVudCkge1xyXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIoY2xvc2VzdCwgZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9DcmVhdGUgbmV3IGNsdXN0ZXIgd2l0aCB0aGVzZSAyIGluIGl0XHJcblxyXG5cdFx0XHRcdHZhciBuZXdDbHVzdGVyID0gbmV3IHRoaXMuX21hcmtlckNsdXN0ZXIodGhpcywgem9vbSwgY2xvc2VzdCwgbGF5ZXIpO1xyXG5cdFx0XHRcdGdyaWRDbHVzdGVyc1t6b29tXS5hZGRPYmplY3QobmV3Q2x1c3RlciwgdGhpcy5fbWFwLnByb2plY3QobmV3Q2x1c3Rlci5fY0xhdExuZywgem9vbSkpO1xyXG5cdFx0XHRcdGNsb3Nlc3QuX19wYXJlbnQgPSBuZXdDbHVzdGVyO1xyXG5cdFx0XHRcdGxheWVyLl9fcGFyZW50ID0gbmV3Q2x1c3RlcjtcclxuXHJcblx0XHRcdFx0Ly9GaXJzdCBjcmVhdGUgYW55IG5ldyBpbnRlcm1lZGlhdGUgcGFyZW50IGNsdXN0ZXJzIHRoYXQgZG9uJ3QgZXhpc3RcclxuXHRcdFx0XHR2YXIgbGFzdFBhcmVudCA9IG5ld0NsdXN0ZXI7XHJcblx0XHRcdFx0Zm9yICh6ID0gem9vbSAtIDE7IHogPiBwYXJlbnQuX3pvb207IHotLSkge1xyXG5cdFx0XHRcdFx0bGFzdFBhcmVudCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIHosIGxhc3RQYXJlbnQpO1xyXG5cdFx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pdLmFkZE9iamVjdChsYXN0UGFyZW50LCB0aGlzLl9tYXAucHJvamVjdChjbG9zZXN0LmdldExhdExuZygpLCB6KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBhcmVudC5fYWRkQ2hpbGQobGFzdFBhcmVudCk7XHJcblxyXG5cdFx0XHRcdC8vUmVtb3ZlIGNsb3Nlc3QgZnJvbSB0aGlzIHpvb20gbGV2ZWwgYW5kIGFueSBhYm92ZSB0aGF0IGl0IGlzIGluLCByZXBsYWNlIHdpdGggbmV3Q2x1c3RlclxyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQoY2xvc2VzdCwgem9vbSk7XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9EaWRuJ3QgbWFuYWdlIHRvIGNsdXN0ZXIgaW4gYXQgdGhpcyB6b29tLCByZWNvcmQgdXMgYXMgYSBtYXJrZXIgaGVyZSBhbmQgY29udGludWUgdXB3YXJkc1xyXG5cdFx0XHRncmlkVW5jbHVzdGVyZWRbem9vbV0uYWRkT2JqZWN0KGxheWVyLCBtYXJrZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly9EaWRuJ3QgZ2V0IGluIGFueXRoaW5nLCBhZGQgdXMgdG8gdGhlIHRvcFxyXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9hZGRDaGlsZChsYXllcik7XHJcblx0XHRsYXllci5fX3BhcmVudCA9IHRoaXMuX3RvcENsdXN0ZXJMZXZlbDtcclxuXHRcdHJldHVybjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWZyZXNoZXMgdGhlIGljb24gb2YgYWxsIFwiZGlydHlcIiB2aXNpYmxlIGNsdXN0ZXJzLlxyXG5cdCAqIE5vbi12aXNpYmxlIFwiZGlydHlcIiBjbHVzdGVycyB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGV5IGFyZSBhZGRlZCB0byB0aGUgbWFwLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3JlZnJlc2hDbHVzdGVyc0ljb25zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdGlmIChjIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyICYmIGMuX2ljb25OZWVkc1VwZGF0ZSkge1xyXG5cdFx0XHRcdGMuX3VwZGF0ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly9FbnF1ZXVlIGNvZGUgdG8gZmlyZSBhZnRlciB0aGUgbWFya2VyIGV4cGFuZC9jb250cmFjdCBoYXMgaGFwcGVuZWRcclxuXHRfZW5xdWV1ZTogZnVuY3Rpb24gKGZuKSB7XHJcblx0XHR0aGlzLl9xdWV1ZS5wdXNoKGZuKTtcclxuXHRcdGlmICghdGhpcy5fcXVldWVUaW1lb3V0KSB7XHJcblx0XHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3Byb2Nlc3NRdWV1ZSwgdGhpcyksIDMwMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX3F1ZXVlW2ldLmNhbGwodGhpcyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3F1ZXVlVGltZW91dCk7XHJcblx0XHR0aGlzLl9xdWV1ZVRpbWVvdXQgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8vTWVyZ2UgYW5kIHNwbGl0IGFueSBleGlzdGluZyBjbHVzdGVycyB0aGF0IGFyZSB0b28gYmlnIG9yIHNtYWxsXHJcblx0X21lcmdlU3BsaXRDbHVzdGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcFpvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XHJcblxyXG5cdFx0Ly9JbiBjYXNlIHdlIGFyZSBzdGFydGluZyB0byBzcGxpdCBiZWZvcmUgdGhlIGFuaW1hdGlvbiBmaW5pc2hlZFxyXG5cdFx0dGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb20gPCBtYXBab29tICYmIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKSkgeyAvL1pvb20gaW4sIHNwbGl0XHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblx0XHRcdC8vUmVtb3ZlIGNsdXN0ZXJzIG5vdyBvZmYgc2NyZWVuXHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCB0aGlzLl96b29tLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XHJcblxyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25ab29tSW4odGhpcy5fem9vbSwgbWFwWm9vbSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0aGlzLl96b29tID4gbWFwWm9vbSkgeyAvL1pvb20gb3V0LCBtZXJnZVxyXG5cdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xyXG5cclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbU91dCh0aGlzLl96b29tLCBtYXBab29tKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX21vdmVFbmQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL0dldHMgdGhlIG1hcHMgdmlzaWJsZSBib3VuZHMgZXhwYW5kZWQgaW4gZWFjaCBkaXJlY3Rpb24gYnkgdGhlIHNpemUgb2YgdGhlIHNjcmVlbiAoc28gdGhlIHVzZXIgY2Fubm90IHNlZSBhbiBhcmVhIHdlIGRvIG5vdCBjb3ZlciBpbiBvbmUgcGFuKVxyXG5cdF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9tYXBCb3VuZHNJbmZpbml0ZTtcclxuXHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLm1vYmlsZSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2hlY2tCb3VuZHNNYXhMYXQodGhpcy5fbWFwLmdldEJvdW5kcygpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tCb3VuZHNNYXhMYXQodGhpcy5fbWFwLmdldEJvdW5kcygpLnBhZCgxKSk7IC8vIFBhZGRpbmcgZXhwYW5kcyB0aGUgYm91bmRzIGJ5IGl0cyBvd24gZGltZW5zaW9ucyBidXQgc2NhbGVkIHdpdGggdGhlIGdpdmVuIGZhY3Rvci5cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBFeHBhbmRzIHRoZSBsYXRpdHVkZSB0byBJbmZpbml0eSAob3IgLUluZmluaXR5KSBpZiB0aGUgaW5wdXQgYm91bmRzIHJlYWNoIHRoZSBtYXAgcHJvamVjdGlvbiBtYXhpbXVtIGRlZmluZWQgbGF0aXR1ZGVcclxuXHQgKiAoaW4gdGhlIGNhc2Ugb2YgV2ViL1NwaGVyaWNhbCBNZXJjYXRvciwgaXQgaXMgODUuMDUxMTI4Nzc5OCAvIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWVyY2F0b3IjRm9ybXVsYXMpLlxyXG5cdCAqIE90aGVyd2lzZSwgdGhlIHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzIG9wdGlvbiB3aWxsIHJlbW92ZSBtYXJrZXJzIGJleW9uZCB0aGF0IGxpbWl0LCB3aGVyZWFzIHRoZSBzYW1lIG1hcmtlcnMgd2l0aG91dFxyXG5cdCAqIHRoaXMgb3B0aW9uIChvciBvdXRzaWRlIE1DRykgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9uIGZsb29yZWQgKGNlaWxlZCkgYnkgdGhlIHByb2plY3Rpb24gYW5kIHJlbmRlcmVkIGF0IHRoYXQgbGltaXQsXHJcblx0ICogbWFraW5nIHRoZSB1c2VyIHRoaW5rIHRoYXQgTUNHIFwiZWF0c1wiIHRoZW0gYW5kIG5ldmVyIGRpc3BsYXlzIHRoZW0gYWdhaW4uXHJcblx0ICogQHBhcmFtIGJvdW5kcyBMLkxhdExuZ0JvdW5kc1xyXG5cdCAqIEByZXR1cm5zIHtMLkxhdExuZ0JvdW5kc31cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9jaGVja0JvdW5kc01heExhdDogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIG1heExhdCA9IHRoaXMuX21heExhdDtcclxuXHJcblx0XHRpZiAobWF4TGF0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYgKGJvdW5kcy5nZXROb3J0aCgpID49IG1heExhdCkge1xyXG5cdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxhdCA9IEluZmluaXR5O1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChib3VuZHMuZ2V0U291dGgoKSA8PSAtbWF4TGF0KSB7XHJcblx0XHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubGF0ID0gLUluZmluaXR5O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9LFxyXG5cclxuXHQvL1NoYXJlZCBhbmltYXRpb24gY29kZVxyXG5cdF9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcclxuXHRcdGlmIChuZXdDbHVzdGVyID09PSBsYXllcikge1xyXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fSBlbHNlIGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID09PSAyKSB7XHJcblx0XHRcdG5ld0NsdXN0ZXIuX2FkZFRvTWFwKCk7XHJcblxyXG5cdFx0XHR2YXIgbWFya2VycyA9IG5ld0NsdXN0ZXIuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtYXJrZXJzWzBdKTtcclxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcnNbMV0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmV3Q2x1c3Rlci5fdXBkYXRlSWNvbigpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4dHJhY3RzIGluZGl2aWR1YWwgKGkuZS4gbm9uLWdyb3VwKSBsYXllcnMgZnJvbSBhIExheWVyIEdyb3VwLlxyXG5cdCAqIEBwYXJhbSBncm91cCB0byBleHRyYWN0IGxheWVycyBmcm9tLlxyXG5cdCAqIEBwYXJhbSBvdXRwdXQge0FycmF5fSBpbiB3aGljaCB0byBzdG9yZSB0aGUgZXh0cmFjdGVkIGxheWVycy5cclxuXHQgKiBAcmV0dXJucyB7KnxBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9leHRyYWN0Tm9uR3JvdXBMYXllcnM6IGZ1bmN0aW9uIChncm91cCwgb3V0cHV0KSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gZ3JvdXAuZ2V0TGF5ZXJzKCksXHJcblx0XHQgICAgaSA9IDAsXHJcblx0XHQgICAgbGF5ZXI7XHJcblxyXG5cdFx0b3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xyXG5cclxuXHRcdGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxheWVyID0gbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XHJcblx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKGxheWVyLCBvdXRwdXQpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvdXRwdXQucHVzaChsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSBzaW5nbGVNYXJrZXJNb2RlIG9wdGlvbi5cclxuXHQgKiBAcGFyYW0gbGF5ZXIgTWFya2VyIHRvIHJlLXN0eWxlIHVzaW5nIHRoZSBDbHVzdGVycyBpY29uQ3JlYXRlRnVuY3Rpb24uXHJcblx0ICogQHJldHVybnMge0wuSWNvbn0gVGhlIG5ld2x5IGNyZWF0ZWQgaWNvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9vdmVycmlkZU1hcmtlckljb246IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGljb24gPSBsYXllci5vcHRpb25zLmljb24gPSB0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHtcclxuXHRcdFx0Z2V0Q2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRnZXRBbGxDaGlsZE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2xheWVyXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGljb247XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIENvbnN0YW50IGJvdW5kcyB1c2VkIGluIGNhc2Ugb3B0aW9uIFwicmVtb3ZlT3V0c2lkZVZpc2libGVCb3VuZHNcIiBpcyBzZXQgdG8gZmFsc2UuXHJcbkwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xyXG5cdF9tYXBCb3VuZHNJbmZpbml0ZTogbmV3IEwuTGF0TG5nQm91bmRzKG5ldyBMLkxhdExuZygtSW5maW5pdHksIC1JbmZpbml0eSksIG5ldyBMLkxhdExuZyhJbmZpbml0eSwgSW5maW5pdHkpKVxyXG59KTtcclxuXHJcbkwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xyXG5cdF9ub0FuaW1hdGlvbjoge1xyXG5cdFx0Ly9Ob24gQW5pbWF0ZWQgdmVyc2lvbnMgb2YgZXZlcnl0aGluZ1xyXG5cdFx0X2FuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vRG8gbm90aGluZy4uLlxyXG5cdFx0fSxcclxuXHRcdF9hbmltYXRpb25ab29tSW46IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCk7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cclxuXHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXHJcblx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XHJcblx0XHR9LFxyXG5cdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCk7XHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xyXG5cclxuXHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXHJcblx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XHJcblx0XHR9LFxyXG5cdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcclxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgbmV3Q2x1c3Rlcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3dpdGhBbmltYXRpb246IHtcclxuXHRcdC8vQW5pbWF0ZWQgdmVyc2lvbnMgaGVyZVxyXG5cdFx0X2FuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgKz0gJyBsZWFmbGV0LWNsdXN0ZXItYW5pbSc7XHJcblx0XHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbisrO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCksXHJcblx0XHRcdCAgICBmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcclxuXHRcdFx0ICAgIGk7XHJcblxyXG5cdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vQWRkIGFsbCBjaGlsZHJlbiBvZiBjdXJyZW50IGNsdXN0ZXJzIHRvIG1hcCBhbmQgcmVtb3ZlIHRob3NlIGNsdXN0ZXJzIGZyb20gbWFwXHJcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHkoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHR2YXIgc3RhcnRQb3MgPSBjLl9sYXRsbmcsXHJcblx0XHRcdFx0ICAgIG1hcmtlcnMgID0gYy5fbWFya2VycyxcclxuXHRcdFx0XHQgICAgbTtcclxuXHJcblx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMoc3RhcnRQb3MpKSB7XHJcblx0XHRcdFx0XHRzdGFydFBvcyA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoYy5faXNTaW5nbGVQYXJlbnQoKSAmJiBwcmV2aW91c1pvb21MZXZlbCArIDEgPT09IG5ld1pvb21MZXZlbCkgeyAvL0ltbWVkaWF0ZWx5IGFkZCB0aGUgbmV3IGNoaWxkIGFuZCByZW1vdmUgdXNcclxuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgYm91bmRzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly9GYWRlIG91dCBvbGQgY2x1c3RlclxyXG5cdFx0XHRcdFx0Yy5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKHN0YXJ0UG9zLCBuZXdab29tTGV2ZWwsIGJvdW5kcyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL1JlbW92ZSBhbGwgbWFya2VycyB0aGF0IGFyZW4ndCB2aXNpYmxlIGFueSBtb3JlXHJcblx0XHRcdFx0Ly9UT0RPOiBEbyB3ZSBhY3R1YWxseSBuZWVkIHRvIGRvIHRoaXMgb24gdGhlIGhpZ2hlciBsZXZlbHMgdG9vP1xyXG5cdFx0XHRcdGZvciAoaSA9IG1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdG0gPSBtYXJrZXJzW2ldO1xyXG5cdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMobS5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XHJcblxyXG5cdFx0XHQvL1VwZGF0ZSBvcGFjaXRpZXNcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUJlY29tZVZpc2libGUoYm91bmRzLCBuZXdab29tTGV2ZWwpO1xyXG5cdFx0XHQvL1RPRE8gTWF5YmU/IFVwZGF0ZSBtYXJrZXJzIGluIF9yZWN1cnNpdmVseUJlY29tZVZpc2libGVcclxuXHRcdFx0ZmcuZWFjaExheWVyKGZ1bmN0aW9uIChuKSB7XHJcblx0XHRcdFx0aWYgKCEobiBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3RlcikgJiYgbi5faWNvbikge1xyXG5cdFx0XHRcdFx0bi5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcclxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwsIGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMobmV3Wm9vbUxldmVsKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvL1JlbW92ZSB0aGUgb2xkIGNsdXN0ZXJzIGFuZCBjbG9zZSB0aGUgem9vbSBhbmltYXRpb25cclxuXHRcdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0Ly91cGRhdGUgdGhlIHBvc2l0aW9ucyBvZiB0aGUganVzdCBhZGRlZCBjbHVzdGVycy9tYXJrZXJzXHJcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoYyk7XHJcblx0XHRcdFx0XHRjLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkVuZCgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUodGhpcy5fdG9wQ2x1c3RlckxldmVsLCBwcmV2aW91c1pvb21MZXZlbCAtIDEsIG5ld1pvb21MZXZlbCk7XHJcblxyXG5cdFx0XHQvL05lZWQgdG8gYWRkIG1hcmtlcnMgZm9yIHRob3NlIHRoYXQgd2VyZW4ndCBvbiB0aGUgbWFwIGJlZm9yZSBidXQgYXJlIG5vd1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHRcdFx0Ly9SZW1vdmUgbWFya2VycyB0aGF0IHdlcmUgb24gdGhlIG1hcCBiZWZvcmUgYnV0IHdvbid0IGJlIG5vd1xyXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcywgTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSwgcHJldmlvdXNab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcclxuXHRcdFx0dmFyIG1lID0gdGhpcyxcclxuXHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwO1xyXG5cclxuXHRcdFx0ZmcuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0XHRpZiAobmV3Q2x1c3RlciAhPT0gbGF5ZXIpIHtcclxuXHRcdFx0XHRpZiAobmV3Q2x1c3Rlci5fY2hpbGRDb3VudCA+IDIpIHsgLy9XYXMgYWxyZWFkeSBhIGNsdXN0ZXJcclxuXHJcblx0XHRcdFx0XHRuZXdDbHVzdGVyLl91cGRhdGVJY29uKCk7XHJcblx0XHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcclxuXHJcblx0XHRcdFx0XHRsYXllci5fc2V0UG9zKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobmV3Q2x1c3Rlci5nZXRMYXRMbmcoKSkpO1xyXG5cdFx0XHRcdFx0bGF5ZXIuY2x1c3RlckhpZGUoKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobGF5ZXIpO1xyXG5cdFx0XHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xyXG5cclxuXHRcdFx0XHRcdFx0bWUuX2FuaW1hdGlvbkVuZCgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7IC8vSnVzdCBiZWNhbWUgYSBjbHVzdGVyXHJcblx0XHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xyXG5cclxuXHRcdFx0XHRcdG1lLl9hbmltYXRpb25TdGFydCgpO1xyXG5cdFx0XHRcdFx0bWUuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUobmV3Q2x1c3RlciwgdGhpcy5fbWFwLmdldE1heFpvb20oKSwgdGhpcy5fem9vbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gUHJpdmF0ZSBtZXRob2RzIGZvciBhbmltYXRlZCB2ZXJzaW9ucy5cclxuXHRfYW5pbWF0aW9uWm9vbU91dFNpbmdsZTogZnVuY3Rpb24gKGNsdXN0ZXIsIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSxcclxuXHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XHJcblxyXG5cdFx0Ly9BbmltYXRlIGFsbCBvZiB0aGUgbWFya2VycyBpbiB0aGUgY2x1c3RlcnMgdG8gbW92ZSB0byB0aGVpciBjbHVzdGVyIGNlbnRlciBwb2ludFxyXG5cdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcChib3VuZHMsIG1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsICsgMSwgbmV3Wm9vbUxldmVsKTtcclxuXHJcblx0XHR2YXIgbWUgPSB0aGlzO1xyXG5cclxuXHRcdC8vVXBkYXRlIHRoZSBvcGFjaXR5IChJZiB3ZSBpbW1lZGlhdGVseSBzZXQgaXQgdGhleSB3b24ndCBhbmltYXRlKVxyXG5cdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcclxuXHRcdGNsdXN0ZXIuX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZShib3VuZHMsIG5ld1pvb21MZXZlbCk7XHJcblxyXG5cdFx0Ly9UT0RPOiBNYXliZSB1c2UgdGhlIHRyYW5zaXRpb24gdGltaW5nIHN0dWZmIHRvIG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlXHJcblx0XHQvL1doZW4gdGhlIGFuaW1hdGlvbnMgYXJlIGRvbmUsIHRpZHkgdXBcclxuXHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Ly9UaGlzIGNsdXN0ZXIgc3RvcHBlZCBiZWluZyBhIGNsdXN0ZXIgYmVmb3JlIHRoZSB0aW1lb3V0IGZpcmVkXHJcblx0XHRcdGlmIChjbHVzdGVyLl9jaGlsZENvdW50ID09PSAxKSB7XHJcblx0XHRcdFx0dmFyIG0gPSBjbHVzdGVyLl9tYXJrZXJzWzBdO1xyXG5cdFx0XHRcdC8vSWYgd2Ugd2VyZSBpbiBhIGNsdXN0ZXIgYW5pbWF0aW9uIGF0IHRoZSB0aW1lIHRoZW4gdGhlIG9wYWNpdHkgYW5kIHBvc2l0aW9uIG9mIG91ciBjaGlsZCBjb3VsZCBiZSB3cm9uZyBub3csIHNvIGZpeCBpdFxyXG5cdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cdFx0XHRcdG0uc2V0TGF0TG5nKG0uZ2V0TGF0TG5nKCkpO1xyXG5cdFx0XHRcdHRoaXMuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseShib3VuZHMsIG5ld1pvb21MZXZlbCwgbWluWm9vbSwgZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwKGJvdW5kcywgbWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwgKyAxKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0aW9uRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgPSB0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNsdXN0ZXItYW5pbScsICcnKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbi0tO1xyXG5cdFx0dGhpcy5maXJlKCdhbmltYXRpb25lbmQnKTtcclxuXHR9LFxyXG5cclxuXHQvL0ZvcmNlIGEgYnJvd3NlciBsYXlvdXQgb2Ygc3R1ZmYgaW4gdGhlIG1hcFxyXG5cdC8vIFNob3VsZCBhcHBseSB0aGUgY3VycmVudCBvcGFjaXR5IGFuZCBsb2NhdGlvbiB0byBhbGwgZWxlbWVudHMgc28gd2UgY2FuIHVwZGF0ZSB0aGVtIGFnYWluIGZvciBhbiBhbmltYXRpb25cclxuXHRfZm9yY2VMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vSW4gbXkgdGVzdGluZyB0aGlzIHdvcmtzLCBpbmZhY3Qgb2Zmc2V0V2lkdGggb2YgYW55IGVsZW1lbnQgc2VlbXMgdG8gd29yay5cclxuXHRcdC8vQ291bGQgbG9vcCBhbGwgdGhpcy5fbGF5ZXJzIGFuZCBkbyB0aGlzIGZvciBlYWNoIF9pY29uIGlmIGl0IHN0b3BzIHdvcmtpbmdcclxuXHJcblx0XHRMLlV0aWwuZmFsc2VGbihkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5tYXJrZXJDbHVzdGVyR3JvdXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXJrZXJDbHVzdGVyR3JvdXAob3B0aW9ucyk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyR3JvdXAuanMiLCJleHBvcnQgdmFyIE1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlci5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IEwuSWNvbi5wcm90b3R5cGUub3B0aW9ucyxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdyb3VwLCB6b29tLCBhLCBiKSB7XHJcblxyXG5cdFx0TC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBhID8gKGEuX2NMYXRMbmcgfHwgYS5nZXRMYXRMbmcoKSkgOiBuZXcgTC5MYXRMbmcoMCwgMCksXHJcbiAgICAgICAgICAgIHsgaWNvbjogdGhpcywgcGFuZTogZ3JvdXAub3B0aW9ucy5jbHVzdGVyUGFuZSB9KTtcclxuXHJcblx0XHR0aGlzLl9ncm91cCA9IGdyb3VwO1xyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblxyXG5cdFx0dGhpcy5fbWFya2VycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDbHVzdGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fY2hpbGRDb3VudCA9IDA7XHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblxyXG5cdFx0aWYgKGEpIHtcclxuXHRcdFx0dGhpcy5fYWRkQ2hpbGQoYSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYikge1xyXG5cdFx0XHR0aGlzLl9hZGRDaGlsZChiKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL1JlY3Vyc2l2ZWx5IHJldHJpZXZlIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMgY2x1c3RlclxyXG5cdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKHN0b3JhZ2VBcnJheSkge1xyXG5cdFx0c3RvcmFnZUFycmF5ID0gc3RvcmFnZUFycmF5IHx8IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnNbaV0uZ2V0QWxsQ2hpbGRNYXJrZXJzKHN0b3JhZ2VBcnJheSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IHRoaXMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuXHRcdFx0c3RvcmFnZUFycmF5LnB1c2godGhpcy5fbWFya2Vyc1tqXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0b3JhZ2VBcnJheTtcclxuXHR9LFxyXG5cclxuXHQvL1JldHVybnMgdGhlIGNvdW50IG9mIGhvdyBtYW55IGNoaWxkIG1hcmtlcnMgd2UgaGF2ZVxyXG5cdGdldENoaWxkQ291bnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGlsZENvdW50O1xyXG5cdH0sXHJcblxyXG5cdC8vWm9vbSB0byB0aGUgbWluaW11bSBvZiBzaG93aW5nIGFsbCBvZiB0aGUgY2hpbGQgbWFya2Vycywgb3IgdGhlIGV4dGVudHMgb2YgdGhpcyBjbHVzdGVyXHJcblx0em9vbVRvQm91bmRzOiBmdW5jdGlvbiAoZml0Qm91bmRzT3B0aW9ucykge1xyXG5cdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLnNsaWNlKCksXHJcblx0XHRcdG1hcCA9IHRoaXMuX2dyb3VwLl9tYXAsXHJcblx0XHRcdGJvdW5kc1pvb20gPSBtYXAuZ2V0Qm91bmRzWm9vbSh0aGlzLl9ib3VuZHMpLFxyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbSArIDEsXHJcblx0XHRcdG1hcFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxyXG5cdFx0XHRpO1xyXG5cclxuXHRcdC8vY2FsY3VsYXRlIGhvdyBmYXIgd2UgbmVlZCB0byB6b29tIGRvd24gdG8gc2VlIGFsbCBvZiB0aGUgbWFya2Vyc1xyXG5cdFx0d2hpbGUgKGNoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiBib3VuZHNab29tID4gem9vbSkge1xyXG5cdFx0XHR6b29tKys7XHJcblx0XHRcdHZhciBuZXdDbHVzdGVycyA9IFtdO1xyXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdG5ld0NsdXN0ZXJzID0gbmV3Q2x1c3RlcnMuY29uY2F0KGNoaWxkQ2x1c3RlcnNbaV0uX2NoaWxkQ2x1c3RlcnMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNoaWxkQ2x1c3RlcnMgPSBuZXdDbHVzdGVycztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYm91bmRzWm9vbSA+IHpvb20pIHtcclxuXHRcdFx0dGhpcy5fZ3JvdXAuX21hcC5zZXRWaWV3KHRoaXMuX2xhdGxuZywgem9vbSk7XHJcblx0XHR9IGVsc2UgaWYgKGJvdW5kc1pvb20gPD0gbWFwWm9vbSkgeyAvL0lmIGZpdEJvdW5kcyB3b3VsZG4ndCB6b29tIHVzIGRvd24sIHpvb20gdXMgZG93biBpbnN0ZWFkXHJcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIG1hcFpvb20gKyAxKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuZml0Qm91bmRzKHRoaXMuX2JvdW5kcywgZml0Qm91bmRzT3B0aW9ucyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XHJcblx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX2JvdW5kcyk7XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dGhpcy5zZXRJY29uKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vQ2x1ZGdlIGZvciBJY29uLCB3ZSBwcmV0ZW5kIHRvIGJlIGFuIGljb24gZm9yIHBlcmZvcm1hbmNlXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb25OZWVkc1VwZGF0ZSkge1xyXG5cdFx0XHR0aGlzLl9pY29uT2JqID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24odGhpcyk7XHJcblx0XHRcdHRoaXMuX2ljb25OZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlSWNvbigpO1xyXG5cdH0sXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbk9iai5jcmVhdGVTaGFkb3coKTtcclxuXHR9LFxyXG5cclxuXHJcblx0X2FkZENoaWxkOiBmdW5jdGlvbiAobmV3MSwgaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcclxuXHJcblx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5fc2V0Q2x1c3RlckNlbnRlcihuZXcxKTtcclxuXHJcblx0XHRpZiAobmV3MSBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xyXG5cdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XHJcblx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVycy5wdXNoKG5ldzEpO1xyXG5cdFx0XHRcdG5ldzEuX19wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2NoaWxkQ291bnQgKz0gbmV3MS5fY2hpbGRDb3VudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghaXNOb3RpZmljYXRpb25Gcm9tQ2hpbGQpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXJrZXJzLnB1c2gobmV3MSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fY2hpbGRDb3VudCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9fcGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX19wYXJlbnQuX2FkZENoaWxkKG5ldzEsIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1ha2VzIHN1cmUgdGhlIGNsdXN0ZXIgY2VudGVyIGlzIHNldC4gSWYgbm90LCB1c2VzIHRoZSBjaGlsZCBjZW50ZXIgaWYgaXQgaXMgYSBjbHVzdGVyLCBvciB0aGUgbWFya2VyIHBvc2l0aW9uLlxyXG5cdCAqIEBwYXJhbSBjaGlsZCBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2x1c3RlciBjZW50ZXIgaWYgbm90IGRlZmluZWQgeWV0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3NldENsdXN0ZXJDZW50ZXI6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG5cdFx0aWYgKCF0aGlzLl9jTGF0TG5nKSB7XHJcblx0XHRcdC8vIHdoZW4gY2x1c3RlcmluZywgdGFrZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgYXMgdGhlIGNsdXN0ZXIgY2VudGVyXHJcblx0XHRcdHRoaXMuX2NMYXRMbmcgPSBjaGlsZC5fY0xhdExuZyB8fCBjaGlsZC5fbGF0bG5nO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFzc2lnbnMgaW1wb3NzaWJsZSBib3VuZGluZyB2YWx1ZXMgc28gdGhhdCB0aGUgbmV4dCBleHRlbmQgZW50aXJlbHkgZGV0ZXJtaW5lcyB0aGUgbmV3IGJvdW5kcy5cclxuXHQgKiBUaGlzIG1ldGhvZCBhdm9pZHMgaGF2aW5nIHRvIHRyYXNoIHRoZSBwcmV2aW91cyBMLkxhdExuZ0JvdW5kcyBvYmplY3QgYW5kIHRvIGNyZWF0ZSBhIG5ldyBvbmUsIHdoaWNoIGlzIG11Y2ggc2xvd2VyIGZvciB0aGlzIGNsYXNzLlxyXG5cdCAqIEFzIGxvbmcgYXMgdGhlIGJvdW5kcyBhcmUgbm90IGV4dGVuZGVkLCBtb3N0IG90aGVyIG1ldGhvZHMgd291bGQgcHJvYmFibHkgZmFpbCwgYXMgdGhleSB3b3VsZCB3aXRoIGJvdW5kcyBpbml0aWFsaXplZCBidXQgbm90IGV4dGVuZGVkLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X3Jlc2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzO1xyXG5cclxuXHRcdGlmIChib3VuZHMuX3NvdXRoV2VzdCkge1xyXG5cdFx0XHRib3VuZHMuX3NvdXRoV2VzdC5sYXQgPSBJbmZpbml0eTtcclxuXHRcdFx0Ym91bmRzLl9zb3V0aFdlc3QubG5nID0gSW5maW5pdHk7XHJcblx0XHR9XHJcblx0XHRpZiAoYm91bmRzLl9ub3J0aEVhc3QpIHtcclxuXHRcdFx0Ym91bmRzLl9ub3J0aEVhc3QubGF0ID0gLUluZmluaXR5O1xyXG5cdFx0XHRib3VuZHMuX25vcnRoRWFzdC5sbmcgPSAtSW5maW5pdHk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlY2FsY3VsYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFya2VycyA9IHRoaXMuX21hcmtlcnMsXHJcblx0XHQgICAgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMsXHJcblx0XHQgICAgbGF0U3VtID0gMCxcclxuXHRcdCAgICBsbmdTdW0gPSAwLFxyXG5cdFx0ICAgIHRvdGFsQ291bnQgPSB0aGlzLl9jaGlsZENvdW50LFxyXG5cdFx0ICAgIGksIGNoaWxkLCBjaGlsZExhdExuZywgY2hpbGRDb3VudDtcclxuXHJcblx0XHQvLyBDYXNlIHdoZXJlIGFsbCBtYXJrZXJzIGFyZSByZW1vdmVkIGZyb20gdGhlIG1hcCBhbmQgd2UgYXJlIGxlZnQgd2l0aCBqdXN0IGFuIGVtcHR5IF90b3BDbHVzdGVyTGV2ZWwuXHJcblx0XHRpZiAodG90YWxDb3VudCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVzZXQgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgb2JqZWN0LCBmb3IgcGVyZm9ybWFuY2UuXHJcblx0XHR0aGlzLl9yZXNldEJvdW5kcygpO1xyXG5cclxuXHRcdC8vIENoaWxkIG1hcmtlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjaGlsZExhdExuZyA9IG1hcmtlcnNbaV0uX2xhdGxuZztcclxuXHJcblx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQoY2hpbGRMYXRMbmcpO1xyXG5cclxuXHRcdFx0bGF0U3VtICs9IGNoaWxkTGF0TG5nLmxhdDtcclxuXHRcdFx0bG5nU3VtICs9IGNoaWxkTGF0TG5nLmxuZztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGlsZCBjbHVzdGVycy5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZENsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNoaWxkID0gY2hpbGRDbHVzdGVyc1tpXTtcclxuXHJcblx0XHRcdC8vIFJlLWNvbXB1dGUgY2hpbGQgYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbiBmaXJzdCBpZiBuZWNlc3NhcnkuXHJcblx0XHRcdGlmIChjaGlsZC5fYm91bmRzTmVlZFVwZGF0ZSkge1xyXG5cdFx0XHRcdGNoaWxkLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGNoaWxkLl9ib3VuZHMpO1xyXG5cclxuXHRcdFx0Y2hpbGRMYXRMbmcgPSBjaGlsZC5fd0xhdExuZztcclxuXHRcdFx0Y2hpbGRDb3VudCA9IGNoaWxkLl9jaGlsZENvdW50O1xyXG5cclxuXHRcdFx0bGF0U3VtICs9IGNoaWxkTGF0TG5nLmxhdCAqIGNoaWxkQ291bnQ7XHJcblx0XHRcdGxuZ1N1bSArPSBjaGlsZExhdExuZy5sbmcgKiBjaGlsZENvdW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRoaXMuX3dMYXRMbmcgPSBuZXcgTC5MYXRMbmcobGF0U3VtIC8gdG90YWxDb3VudCwgbG5nU3VtIC8gdG90YWxDb3VudCk7XHJcblxyXG5cdFx0Ly8gUmVzZXQgZGlydHkgZmxhZy5cclxuXHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvL1NldCBvdXIgbWFya2VycyBwb3NpdGlvbiBhcyBnaXZlbiBhbmQgYWRkIGl0IHRvIHRoZSBtYXBcclxuXHRfYWRkVG9NYXA6IGZ1bmN0aW9uIChzdGFydFBvcykge1xyXG5cdFx0aWYgKHN0YXJ0UG9zKSB7XHJcblx0XHRcdHRoaXMuX2JhY2t1cExhdGxuZyA9IHRoaXMuX2xhdGxuZztcclxuXHRcdFx0dGhpcy5zZXRMYXRMbmcoc3RhcnRQb3MpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcih0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbjogZnVuY3Rpb24gKGJvdW5kcywgY2VudGVyLCBtYXhab29tKSB7XHJcblx0XHR0aGlzLl9yZWN1cnNpdmVseShib3VuZHMsIHRoaXMuX2dyb3VwLl9tYXAuZ2V0TWluWm9vbSgpLCBtYXhab29tIC0gMSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHR2YXIgbWFya2VycyA9IGMuX21hcmtlcnMsXHJcblx0XHRcdFx0XHRpLCBtO1xyXG5cdFx0XHRcdGZvciAoaSA9IG1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdG0gPSBtYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0XHRcdC8vT25seSBkbyBpdCBpZiB0aGUgaWNvbiBpcyBzdGlsbCBvbiB0aGUgbWFwXHJcblx0XHRcdFx0XHRpZiAobS5faWNvbikge1xyXG5cdFx0XHRcdFx0XHRtLl9zZXRQb3MoY2VudGVyKTtcclxuXHRcdFx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IGMuX2NoaWxkQ2x1c3RlcnMsXHJcblx0XHRcdFx0XHRqLCBjbTtcclxuXHRcdFx0XHRmb3IgKGogPSBjaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcblx0XHRcdFx0XHRjbSA9IGNoaWxkQ2x1c3RlcnNbal07XHJcblx0XHRcdFx0XHRpZiAoY20uX2ljb24pIHtcclxuXHRcdFx0XHRcdFx0Y20uX3NldFBvcyhjZW50ZXIpO1xyXG5cdFx0XHRcdFx0XHRjbS5jbHVzdGVySGlkZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcDogZnVuY3Rpb24gKGJvdW5kcywgbWFwTWluWm9vbSwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCBuZXdab29tTGV2ZWwsIG1hcE1pblpvb20sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5Jbihib3VuZHMsIGMuX2dyb3VwLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGMuZ2V0TGF0TG5nKCkpLnJvdW5kKCksIHByZXZpb3VzWm9vbUxldmVsKTtcclxuXHJcblx0XHRcdFx0Ly9UT0RPOiBkZXB0aFRvQW5pbWF0ZUluIGFmZmVjdHMgX2lzU2luZ2xlUGFyZW50LCBpZiB0aGVyZSBpcyBhIG11bHRpem9vbSB3ZSBtYXkvbWF5IG5vdCBiZS5cclxuXHRcdFx0XHQvL0FzIGEgaGFjayB3ZSBvbmx5IGRvIGEgYW5pbWF0aW9uIGZyZWUgem9vbSBvbiBhIHNpbmdsZSBsZXZlbCB6b29tLCBpZiBzb21lb25lIGRvZXMgbXVsdGlwbGUgbGV2ZWxzIHRoZW4gd2UgYWx3YXlzIGFuaW1hdGVcclxuXHRcdFx0XHRpZiAoYy5faXNTaW5nbGVQYXJlbnQoKSAmJiBwcmV2aW91c1pvb21MZXZlbCAtIDEgPT09IG5ld1pvb21MZXZlbCkge1xyXG5cdFx0XHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAoYm91bmRzLCBtYXBNaW5ab29tLCBwcmV2aW91c1pvb21MZXZlbCk7IC8vSW1tZWRpYXRlbHkgcmVtb3ZlIG91ciBjaGlsZHJlbiBhcyB3ZSBhcmUgcmVwbGFjaW5nIHRoZW0uIFRPRE8gcHJldmlvdXNCb3VuZHMgbm90IGJvdW5kc1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjLl9hZGRUb01hcCgpO1xyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWN1cnNpdmVseUJlY29tZVZpc2libGU6IGZ1bmN0aW9uIChib3VuZHMsIHpvb21MZXZlbCkge1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCB0aGlzLl9ncm91cC5fbWFwLmdldE1pblpvb20oKSwgem9vbUxldmVsLCBudWxsLCBmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRjLmNsdXN0ZXJTaG93KCk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MsIHpvb21MZXZlbCwgYm91bmRzKSB7XHJcblx0XHR0aGlzLl9yZWN1cnNpdmVseShib3VuZHMsIHRoaXMuX2dyb3VwLl9tYXAuZ2V0TWluWm9vbSgpIC0gMSwgem9vbUxldmVsLFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdGlmICh6b29tTGV2ZWwgPT09IGMuX3pvb20pIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vQWRkIG91ciBjaGlsZCBtYXJrZXJzIGF0IHN0YXJ0UG9zIChzbyB0aGV5IGNhbiBiZSBhbmltYXRlZCBvdXQpXHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IGMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdHZhciBubSA9IGMuX21hcmtlcnNbaV07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMobm0uX2xhdGxuZykpIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0UG9zKSB7XHJcblx0XHRcdFx0XHRcdG5tLl9iYWNrdXBMYXRsbmcgPSBubS5nZXRMYXRMbmcoKTtcclxuXHJcblx0XHRcdFx0XHRcdG5tLnNldExhdExuZyhzdGFydFBvcyk7XHJcblx0XHRcdFx0XHRcdGlmIChubS5jbHVzdGVySGlkZSkge1xyXG5cdFx0XHRcdFx0XHRcdG5tLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLmFkZExheWVyKG5tKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGZ1bmN0aW9uIChjKSB7XHJcblx0XHRcdFx0Yy5fYWRkVG9NYXAoc3RhcnRQb3MpO1xyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9uczogZnVuY3Rpb24gKHpvb21MZXZlbCkge1xyXG5cdFx0Ly9GaXggcG9zaXRpb25zIG9mIGNoaWxkIG1hcmtlcnNcclxuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHZhciBubSA9IHRoaXMuX21hcmtlcnNbaV07XHJcblx0XHRcdGlmIChubS5fYmFja3VwTGF0bG5nKSB7XHJcblx0XHRcdFx0bm0uc2V0TGF0TG5nKG5tLl9iYWNrdXBMYXRsbmcpO1xyXG5cdFx0XHRcdGRlbGV0ZSBubS5fYmFja3VwTGF0bG5nO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHpvb21MZXZlbCAtIDEgPT09IHRoaXMuX3pvb20pIHtcclxuXHRcdFx0Ly9SZXBvc2l0aW9uIGNoaWxkIGNsdXN0ZXJzXHJcblx0XHRcdGZvciAodmFyIGogPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcblx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1tqXS5fcmVzdG9yZVBvc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAodmFyIGsgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XHJcblx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1trXS5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMoem9vbUxldmVsKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZXN0b3JlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9iYWNrdXBMYXRsbmcpIHtcclxuXHRcdFx0dGhpcy5zZXRMYXRMbmcodGhpcy5fYmFja3VwTGF0bG5nKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2JhY2t1cExhdGxuZztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvL2V4Y2VwdEJvdW5kczogSWYgc2V0LCBkb24ndCByZW1vdmUgYW55IG1hcmtlcnMvY2x1c3RlcnMgaW4gaXRcclxuXHRfcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXA6IGZ1bmN0aW9uIChwcmV2aW91c0JvdW5kcywgbWFwTWluWm9vbSwgem9vbUxldmVsLCBleGNlcHRCb3VuZHMpIHtcclxuXHRcdHZhciBtLCBpO1xyXG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkocHJldmlvdXNCb3VuZHMsIG1hcE1pblpvb20gLSAxLCB6b29tTGV2ZWwgLSAxLFxyXG5cdFx0XHRmdW5jdGlvbiAoYykge1xyXG5cdFx0XHRcdC8vUmVtb3ZlIG1hcmtlcnMgYXQgZXZlcnkgbGV2ZWxcclxuXHRcdFx0XHRmb3IgKGkgPSBjLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gYy5fbWFya2Vyc1tpXTtcclxuXHRcdFx0XHRcdGlmICghZXhjZXB0Qm91bmRzIHx8ICFleGNlcHRCb3VuZHMuY29udGFpbnMobS5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcclxuXHRcdFx0XHQvL1JlbW92ZSBjaGlsZCBjbHVzdGVycyBhdCBqdXN0IHRoZSBib3R0b20gbGV2ZWxcclxuXHRcdFx0XHRmb3IgKGkgPSBjLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRtID0gYy5fY2hpbGRDbHVzdGVyc1tpXTtcclxuXHRcdFx0XHRcdGlmICghZXhjZXB0Qm91bmRzIHx8ICFleGNlcHRCb3VuZHMuY29udGFpbnMobS5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG0pO1xyXG5cdFx0XHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvL1J1biB0aGUgZ2l2ZW4gZnVuY3Rpb25zIHJlY3Vyc2l2ZWx5IHRvIHRoaXMgYW5kIGNoaWxkIGNsdXN0ZXJzXHJcblx0Ly8gYm91bmRzVG9BcHBseVRvOiBhIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudGluZyB0aGUgYm91bmRzIG9mIHdoYXQgY2x1c3RlcnMgdG8gcmVjdXJzZSBpbiB0b1xyXG5cdC8vIHpvb21MZXZlbFRvU3RhcnQ6IHpvb20gbGV2ZWwgdG8gc3RhcnQgcnVubmluZyBmdW5jdGlvbnMgKGluY2x1c2l2ZSlcclxuXHQvLyB6b29tTGV2ZWxUb1N0b3A6IHpvb20gbGV2ZWwgdG8gc3RvcCBydW5uaW5nIGZ1bmN0aW9ucyAoaW5jbHVzaXZlKVxyXG5cdC8vIHJ1bkF0RXZlcnlMZXZlbDogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBMLk1hcmtlckNsdXN0ZXIgYXMgYW4gYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBvbiBldmVyeSBsZXZlbFxyXG5cdC8vIHJ1bkF0Qm90dG9tTGV2ZWw6IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gTC5NYXJrZXJDbHVzdGVyIGFzIGFuIGFyZ3VtZW50IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgYXQgb25seSB0aGUgYm90dG9tIGxldmVsXHJcblx0X3JlY3Vyc2l2ZWx5OiBmdW5jdGlvbiAoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCkge1xyXG5cdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl96b29tLFxyXG5cdFx0ICAgIGksIGM7XHJcblxyXG5cdFx0aWYgKHpvb21MZXZlbFRvU3RhcnQgPD0gem9vbSkge1xyXG5cdFx0XHRpZiAocnVuQXRFdmVyeUxldmVsKSB7XHJcblx0XHRcdFx0cnVuQXRFdmVyeUxldmVsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChydW5BdEJvdHRvbUxldmVsICYmIHpvb20gPT09IHpvb21MZXZlbFRvU3RvcCkge1xyXG5cdFx0XHRcdHJ1bkF0Qm90dG9tTGV2ZWwodGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoem9vbSA8IHpvb21MZXZlbFRvU3RhcnQgfHwgem9vbSA8IHpvb21MZXZlbFRvU3RvcCkge1xyXG5cdFx0XHRmb3IgKGkgPSBjaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0YyA9IGNoaWxkQ2x1c3RlcnNbaV07XHJcblx0XHRcdFx0aWYgKGJvdW5kc1RvQXBwbHlUby5pbnRlcnNlY3RzKGMuX2JvdW5kcykpIHtcclxuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5KGJvdW5kc1RvQXBwbHlUbywgem9vbUxldmVsVG9TdGFydCwgem9vbUxldmVsVG9TdG9wLCBydW5BdEV2ZXJ5TGV2ZWwsIHJ1bkF0Qm90dG9tTGV2ZWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vUmV0dXJucyB0cnVlIGlmIHdlIGFyZSB0aGUgcGFyZW50IG9mIG9ubHkgb25lIGNsdXN0ZXIgYW5kIHRoYXQgY2x1c3RlciBpcyB0aGUgc2FtZSBhcyB1c1xyXG5cdF9pc1NpbmdsZVBhcmVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly9Eb24ndCBuZWVkIHRvIGNoZWNrIHRoaXMuX21hcmtlcnMgYXMgdGhlIHJlc3Qgd29uJ3Qgd29yayBpZiB0aGVyZSBhcmUgYW55XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggPiAwICYmIHRoaXMuX2NoaWxkQ2x1c3RlcnNbMF0uX2NoaWxkQ291bnQgPT09IHRoaXMuX2NoaWxkQ291bnQ7XHJcblx0fVxyXG59KTtcclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL3NyYy9NYXJrZXJDbHVzdGVyLmpzIiwiXHJcbi8qXHJcbiogRXh0ZW5kcyBMLk1hcmtlciB0byBpbmNsdWRlIHR3byBleHRyYSBtZXRob2RzOiBjbHVzdGVySGlkZSBhbmQgY2x1c3RlclNob3cuXHJcbiogXHJcbiogVGhleSB3b3JrIGFzIHNldE9wYWNpdHkoMCkgYW5kIHNldE9wYWNpdHkoMSkgcmVzcGVjdGl2ZWx5LCBidXRcclxuKiB0aGV5IHdpbGwgcmVtZW1iZXIgdGhlIG1hcmtlcidzIG9wYWNpdHkgd2hlbiBoaWRpbmcgYW5kIHNob3dpbmcgaXQgYWdhaW4uXHJcbiogXHJcbiovXHJcblxyXG5cclxuTC5NYXJrZXIuaW5jbHVkZSh7XHJcblx0XHJcblx0Y2x1c3RlckhpZGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5V2hlblVuY2x1c3RlcmVkID0gdGhpcy5vcHRpb25zLm9wYWNpdHkgfHwgMTtcclxuXHRcdHJldHVybiB0aGlzLnNldE9wYWNpdHkoMCk7XHJcblx0fSxcclxuXHRcclxuXHRjbHVzdGVyU2hvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHJldCA9IHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSB8fCB0aGlzLm9wdGlvbnMub3BhY2l0eVdoZW5VbmNsdXN0ZXJlZCk7XHJcblx0XHRkZWxldGUgdGhpcy5vcHRpb25zLm9wYWNpdHlXaGVuVW5jbHVzdGVyZWQ7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHRcclxufSk7XHJcblxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlck9wYWNpdHkuanMiLCJcclxuTC5EaXN0YW5jZUdyaWQgPSBmdW5jdGlvbiAoY2VsbFNpemUpIHtcclxuXHR0aGlzLl9jZWxsU2l6ZSA9IGNlbGxTaXplO1xyXG5cdHRoaXMuX3NxQ2VsbFNpemUgPSBjZWxsU2l6ZSAqIGNlbGxTaXplO1xyXG5cdHRoaXMuX2dyaWQgPSB7fTtcclxuXHR0aGlzLl9vYmplY3RQb2ludCA9IHsgfTtcclxufTtcclxuXHJcbkwuRGlzdGFuY2VHcmlkLnByb3RvdHlwZSA9IHtcclxuXHJcblx0YWRkT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xyXG5cdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcclxuXHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXHJcblx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXHJcblx0XHQgICAgcm93ID0gZ3JpZFt5XSA9IGdyaWRbeV0gfHwge30sXHJcblx0XHQgICAgY2VsbCA9IHJvd1t4XSA9IHJvd1t4XSB8fCBbXSxcclxuXHRcdCAgICBzdGFtcCA9IEwuVXRpbC5zdGFtcChvYmopO1xyXG5cclxuXHRcdHRoaXMuX29iamVjdFBvaW50W3N0YW1wXSA9IHBvaW50O1xyXG5cclxuXHRcdGNlbGwucHVzaChvYmopO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZU9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcclxuXHRcdHRoaXMucmVtb3ZlT2JqZWN0KG9iaik7XHJcblx0XHR0aGlzLmFkZE9iamVjdChvYmosIHBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvL1JldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IHdhcyBmb3VuZFxyXG5cdHJlbW92ZU9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcclxuXHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXHJcblx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxyXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxyXG5cdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxyXG5cdFx0ICAgIGNlbGwgPSByb3dbeF0gPSByb3dbeF0gfHwgW10sXHJcblx0XHQgICAgaSwgbGVuO1xyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9vYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV07XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAoY2VsbFtpXSA9PT0gb2JqKSB7XHJcblxyXG5cdFx0XHRcdGNlbGwuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0XHRpZiAobGVuID09PSAxKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgcm93W3hdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0ZWFjaE9iamVjdDogZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgaSwgaiwgaywgbGVuLCByb3csIGNlbGwsIHJlbW92ZWQsXHJcblx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQ7XHJcblxyXG5cdFx0Zm9yIChpIGluIGdyaWQpIHtcclxuXHRcdFx0cm93ID0gZ3JpZFtpXTtcclxuXHJcblx0XHRcdGZvciAoaiBpbiByb3cpIHtcclxuXHRcdFx0XHRjZWxsID0gcm93W2pdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGsgPSAwLCBsZW4gPSBjZWxsLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XHJcblx0XHRcdFx0XHRyZW1vdmVkID0gZm4uY2FsbChjb250ZXh0LCBjZWxsW2tdKTtcclxuXHRcdFx0XHRcdGlmIChyZW1vdmVkKSB7XHJcblx0XHRcdFx0XHRcdGstLTtcclxuXHRcdFx0XHRcdFx0bGVuLS07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0TmVhck9iamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxyXG5cdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcclxuXHRcdCAgICBpLCBqLCBrLCByb3csIGNlbGwsIGxlbiwgb2JqLCBkaXN0LFxyXG5cdFx0ICAgIG9iamVjdFBvaW50ID0gdGhpcy5fb2JqZWN0UG9pbnQsXHJcblx0XHQgICAgY2xvc2VzdERpc3RTcSA9IHRoaXMuX3NxQ2VsbFNpemUsXHJcblx0XHQgICAgY2xvc2VzdCA9IG51bGw7XHJcblxyXG5cdFx0Zm9yIChpID0geSAtIDE7IGkgPD0geSArIDE7IGkrKykge1xyXG5cdFx0XHRyb3cgPSB0aGlzLl9ncmlkW2ldO1xyXG5cdFx0XHRpZiAocm93KSB7XHJcblxyXG5cdFx0XHRcdGZvciAoaiA9IHggLSAxOyBqIDw9IHggKyAxOyBqKyspIHtcclxuXHRcdFx0XHRcdGNlbGwgPSByb3dbal07XHJcblx0XHRcdFx0XHRpZiAoY2VsbCkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGNlbGxba107XHJcblx0XHRcdFx0XHRcdFx0ZGlzdCA9IHRoaXMuX3NxRGlzdChvYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV0sIHBvaW50KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0U3EgfHxcclxuXHRcdFx0XHRcdFx0XHRcdGRpc3QgPD0gY2xvc2VzdERpc3RTcSAmJiBjbG9zZXN0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdFNxID0gZGlzdDtcclxuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3QgPSBvYmo7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2xvc2VzdDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Q29vcmQ6IGZ1bmN0aW9uICh4KSB7XHJcblx0XHR2YXIgY29vcmQgPSBNYXRoLmZsb29yKHggLyB0aGlzLl9jZWxsU2l6ZSk7XHJcblx0XHRyZXR1cm4gaXNGaW5pdGUoY29vcmQpID8gY29vcmQgOiB4O1xyXG5cdH0sXHJcblxyXG5cdF9zcURpc3Q6IGZ1bmN0aW9uIChwLCBwMikge1xyXG5cdFx0dmFyIGR4ID0gcDIueCAtIHAueCxcclxuXHRcdCAgICBkeSA9IHAyLnkgLSBwLnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi4vbm9kZV9tb2R1bGVzL2xlYWZsZXQubWFya2VyY2x1c3Rlci9zcmMvRGlzdGFuY2VHcmlkLmpzIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyIHRoZSBhdXRob3JzIGxpc3RlZCBhdCB0aGUgZm9sbG93aW5nIFVSTCwgYW5kL29yXHJcbnRoZSBhdXRob3JzIG9mIHJlZmVyZW5jZWQgYXJ0aWNsZXMgb3IgaW5jb3Jwb3JhdGVkIGV4dGVybmFsIGNvZGU6XHJcbmh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP2FjdGlvbj1oaXN0b3J5Jm9mZnNldD0yMDEyMDQxMDE3NTI1NlxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG5SZXRyaWV2ZWQgZnJvbTogaHR0cDovL2VuLmxpdGVyYXRlcHJvZ3JhbXMub3JnL1F1aWNraHVsbF8oSmF2YXNjcmlwdCk/b2xkaWQ9MTg0MzRcclxuKi9cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0TC5RdWlja0h1bGwgPSB7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjcHQgYSBwb2ludCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBiYXNlbGluZVxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYmwgdGhlIGJhc2VsaW5lLCBhcyByZXByZXNlbnRlZCBieSBhIHR3by1lbGVtZW50XHJcblx0XHQgKiAgIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzLlxyXG5cdFx0ICogQHJldHVybnMge051bWJlcn0gYW4gYXBwcm94aW1hdGUgZGlzdGFuY2UgbWVhc3VyZVxyXG5cdFx0ICovXHJcblx0XHRnZXREaXN0YW50OiBmdW5jdGlvbiAoY3B0LCBibCkge1xyXG5cdFx0XHR2YXIgdlkgPSBibFsxXS5sYXQgLSBibFswXS5sYXQsXHJcblx0XHRcdFx0dlggPSBibFswXS5sbmcgLSBibFsxXS5sbmc7XHJcblx0XHRcdHJldHVybiAodlggKiAoY3B0LmxhdCAtIGJsWzBdLmxhdCkgKyB2WSAqIChjcHQubG5nIC0gYmxbMF0ubG5nKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlTGluZSBhIHR3by1lbGVtZW50IGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiAgIHJlcHJlc2VudGluZyB0aGUgYmFzZWxpbmUgdG8gcHJvamVjdCBmcm9tXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzIGFuIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXHJcblx0XHQgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgbWF4aW11bSBwb2ludCBhbmQgYWxsIG5ldyBwb2ludHMgdG8gc3RheVxyXG5cdFx0ICogICBpbiBjb25zaWRlcmF0aW9uIGZvciB0aGUgaHVsbC5cclxuXHRcdCAqL1xyXG5cdFx0ZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmU6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgbWF4RCA9IDAsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLFxyXG5cdFx0XHRcdG5ld1BvaW50cyA9IFtdLFxyXG5cdFx0XHRcdGksIHB0LCBkO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdHB0ID0gbGF0TG5nc1tpXTtcclxuXHRcdFx0XHRkID0gdGhpcy5nZXREaXN0YW50KHB0LCBiYXNlTGluZSk7XHJcblxyXG5cdFx0XHRcdGlmIChkID4gMCkge1xyXG5cdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocHQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChkID4gbWF4RCkge1xyXG5cdFx0XHRcdFx0bWF4RCA9IGQ7XHJcblx0XHRcdFx0XHRtYXhQdCA9IHB0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHsgbWF4UG9pbnQ6IG1heFB0LCBuZXdQb2ludHM6IG5ld1BvaW50cyB9O1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LypcclxuXHRcdCAqIEdpdmVuIGEgYmFzZWxpbmUsIGNvbXB1dGUgdGhlIGNvbnZleCBodWxsIG9mIGxhdExuZ3MgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdExuZ3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5nc1xyXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdFx0ICovXHJcblx0XHRidWlsZENvbnZleEh1bGw6IGZ1bmN0aW9uIChiYXNlTGluZSwgbGF0TG5ncykge1xyXG5cdFx0XHR2YXIgY29udmV4SHVsbEJhc2VMaW5lcyA9IFtdLFxyXG5cdFx0XHRcdHQgPSB0aGlzLmZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lKGJhc2VMaW5lLCBsYXRMbmdzKTtcclxuXHJcblx0XHRcdGlmICh0Lm1heFBvaW50KSB7IC8vIGlmIHRoZXJlIGlzIHN0aWxsIGEgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZVxyXG5cdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxyXG5cdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXHJcblx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFtiYXNlTGluZVswXSwgdC5tYXhQb2ludF0sIHQubmV3UG9pbnRzKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzID1cclxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbdC5tYXhQb2ludCwgYmFzZUxpbmVbMV1dLCB0Lm5ld1BvaW50cylcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnZleEh1bGxCYXNlTGluZXM7XHJcblx0XHRcdH0gZWxzZSB7ICAvLyBpZiB0aGVyZSBpcyBubyBtb3JlIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmUsIHRoZSBjdXJyZW50IGJhc2UgbGluZSBpcyBwYXJ0IG9mIHRoZSBjb252ZXggaHVsbFxyXG5cdFx0XHRcdHJldHVybiBbYmFzZUxpbmVbMF1dO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQgKiBHaXZlbiBhbiBhcnJheSBvZiBsYXRsbmdzLCBjb21wdXRlIGEgY29udmV4IGh1bGwgYXMgYW4gYXJyYXlcclxuXHRcdCAqIG9mIGxhdGxuZ3NcclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXHJcblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0XHQgKi9cclxuXHRcdGdldENvbnZleEh1bGw6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XHJcblx0XHRcdC8vIGZpbmQgZmlyc3QgYmFzZWxpbmVcclxuXHRcdFx0dmFyIG1heExhdCA9IGZhbHNlLCBtaW5MYXQgPSBmYWxzZSxcclxuXHRcdFx0XHRtYXhMbmcgPSBmYWxzZSwgbWluTG5nID0gZmFsc2UsXHJcblx0XHRcdFx0bWF4TGF0UHQgPSBudWxsLCBtaW5MYXRQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4TG5nUHQgPSBudWxsLCBtaW5MbmdQdCA9IG51bGwsXHJcblx0XHRcdFx0bWF4UHQgPSBudWxsLCBtaW5QdCA9IG51bGwsXHJcblx0XHRcdFx0aTtcclxuXHJcblx0XHRcdGZvciAoaSA9IGxhdExuZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHR2YXIgcHQgPSBsYXRMbmdzW2ldO1xyXG5cdFx0XHRcdGlmIChtYXhMYXQgPT09IGZhbHNlIHx8IHB0LmxhdCA+IG1heExhdCkge1xyXG5cdFx0XHRcdFx0bWF4TGF0UHQgPSBwdDtcclxuXHRcdFx0XHRcdG1heExhdCA9IHB0LmxhdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pbkxhdCA9PT0gZmFsc2UgfHwgcHQubGF0IDwgbWluTGF0KSB7XHJcblx0XHRcdFx0XHRtaW5MYXRQdCA9IHB0O1xyXG5cdFx0XHRcdFx0bWluTGF0ID0gcHQubGF0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobWF4TG5nID09PSBmYWxzZSB8fCBwdC5sbmcgPiBtYXhMbmcpIHtcclxuXHRcdFx0XHRcdG1heExuZ1B0ID0gcHQ7XHJcblx0XHRcdFx0XHRtYXhMbmcgPSBwdC5sbmc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtaW5MbmcgPT09IGZhbHNlIHx8IHB0LmxuZyA8IG1pbkxuZykge1xyXG5cdFx0XHRcdFx0bWluTG5nUHQgPSBwdDtcclxuXHRcdFx0XHRcdG1pbkxuZyA9IHB0LmxuZztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmIChtaW5MYXQgIT09IG1heExhdCkge1xyXG5cdFx0XHRcdG1pblB0ID0gbWluTGF0UHQ7XHJcblx0XHRcdFx0bWF4UHQgPSBtYXhMYXRQdDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtaW5QdCA9IG1pbkxuZ1B0O1xyXG5cdFx0XHRcdG1heFB0ID0gbWF4TG5nUHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBjaCA9IFtdLmNvbmNhdCh0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWluUHQsIG1heFB0XSwgbGF0TG5ncyksXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWF4UHQsIG1pblB0XSwgbGF0TG5ncykpO1xyXG5cdFx0XHRyZXR1cm4gY2g7XHJcblx0XHR9XHJcblx0fTtcclxufSgpKTtcclxuXHJcbkwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcclxuXHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0cG9pbnRzID0gW10sXHJcblx0XHRcdHAsIGk7XHJcblxyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHAgPSBjaGlsZE1hcmtlcnNbaV0uZ2V0TGF0TG5nKCk7XHJcblx0XHRcdHBvaW50cy5wdXNoKHApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLlF1aWNrSHVsbC5nZXRDb252ZXhIdWxsKHBvaW50cyk7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXIuUXVpY2tIdWxsLmpzIiwiLy9UaGlzIGNvZGUgaXMgMTAwJSBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vamF3ai9PdmVybGFwcGluZ01hcmtlclNwaWRlcmZpZXItTGVhZmxldFxyXG4vL0h1Z2UgdGhhbmtzIHRvIGphd2ogZm9yIGltcGxlbWVudGluZyBpdCBmaXJzdCB0byBtYWtlIG15IGpvYiBlYXN5IDotKVxyXG5cclxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xyXG5cclxuXHRfMlBJOiBNYXRoLlBJICogMixcclxuXHRfY2lyY2xlRm9vdFNlcGFyYXRpb246IDI1LCAvL3JlbGF0ZWQgdG8gY2lyY3VtZmVyZW5jZSBvZiBjaXJjbGVcclxuXHRfY2lyY2xlU3RhcnRBbmdsZTogMCxcclxuXHJcblx0X3NwaXJhbEZvb3RTZXBhcmF0aW9uOiAgMjgsIC8vcmVsYXRlZCB0byBzaXplIG9mIHNwaXJhbCAoZXhwZXJpbWVudCEpXHJcblx0X3NwaXJhbExlbmd0aFN0YXJ0OiAxMSxcclxuXHRfc3BpcmFsTGVuZ3RoRmFjdG9yOiA1LFxyXG5cclxuXHRfY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjogOSwgLy9zaG93IHNwaXJhbCBpbnN0ZWFkIG9mIGNpcmNsZSBmcm9tIHRoaXMgbWFya2VyIGNvdW50IHVwd2FyZHMuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAwIC0+IGFsd2F5cyBzcGlyYWw7IEluZmluaXR5IC0+IGFsd2F5cyBjaXJjbGVcclxuXHJcblx0c3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9PT0gdGhpcyB8fCB0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0Y2VudGVyID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0XHRwb3NpdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fZ3JvdXAuX3Vuc3BpZGVyZnkoKTtcclxuXHRcdHRoaXMuX2dyb3VwLl9zcGlkZXJmaWVkID0gdGhpcztcclxuXHJcblx0XHQvL1RPRE8gTWF5YmU6IGNoaWxkTWFya2VycyBvcmRlciBieSBkaXN0YW5jZSB0byBjZW50ZXJcclxuXHJcblx0XHRpZiAoY2hpbGRNYXJrZXJzLmxlbmd0aCA+PSB0aGlzLl9jaXJjbGVTcGlyYWxTd2l0Y2hvdmVyKSB7XHJcblx0XHRcdHBvc2l0aW9ucyA9IHRoaXMuX2dlbmVyYXRlUG9pbnRzU3BpcmFsKGNoaWxkTWFya2Vycy5sZW5ndGgsIGNlbnRlcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjZW50ZXIueSArPSAxMDsgLy8gT3RoZXJ3aXNlIGNpcmNsZXMgbG9vayB3cm9uZyA9PiBoYWNrIGZvciBzdGFuZGFyZCBibHVlIGljb24sIHJlbmRlcnMgZGlmZmVyZW50bHkgZm9yIG90aGVyIGljb25zLlxyXG5cdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c0NpcmNsZShjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGlvblNwaWRlcmZ5KGNoaWxkTWFya2VycywgcG9zaXRpb25zKTtcclxuXHR9LFxyXG5cclxuXHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdC8vLyA8cGFyYW0gTmFtZT1cInpvb21EZXRhaWxzXCI+QXJndW1lbnQgZnJvbSB6b29tYW5pbSBpZiBiZWluZyBjYWxsZWQgaW4gYSB6b29tIGFuaW1hdGlvbiBvciBudWxsIG90aGVyd2lzZTwvcGFyYW0+XHJcblx0XHRpZiAodGhpcy5fZ3JvdXAuX2luWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hbmltYXRpb25VbnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcclxuXHJcblx0XHR0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dlbmVyYXRlUG9pbnRzQ2lyY2xlOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XHJcblx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9jaXJjbGVGb290U2VwYXJhdGlvbiAqICgyICsgY291bnQpLFxyXG5cdFx0XHRsZWdMZW5ndGggPSBjaXJjdW1mZXJlbmNlIC8gdGhpcy5fMlBJLCAgLy9yYWRpdXMgZnJvbSBjaXJjdW1mZXJlbmNlXHJcblx0XHRcdGFuZ2xlU3RlcCA9IHRoaXMuXzJQSSAvIGNvdW50LFxyXG5cdFx0XHRyZXMgPSBbXSxcclxuXHRcdFx0aSwgYW5nbGU7XHJcblxyXG5cdFx0bGVnTGVuZ3RoID0gTWF0aC5tYXgobGVnTGVuZ3RoLCAzNSk7IC8vIE1pbmltdW0gZGlzdGFuY2UgdG8gZ2V0IG91dHNpZGUgdGhlIGNsdXN0ZXIgaWNvbi5cclxuXHJcblx0XHRyZXMubGVuZ3RoID0gY291bnQ7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHsgLy8gQ2xvY2t3aXNlLCBsaWtlIHNwaXJhbC5cclxuXHRcdFx0YW5nbGUgPSB0aGlzLl9jaXJjbGVTdGFydEFuZ2xlICsgaSAqIGFuZ2xlU3RlcDtcclxuXHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9LFxyXG5cclxuXHRfZ2VuZXJhdGVQb2ludHNTcGlyYWw6IGZ1bmN0aW9uIChjb3VudCwgY2VudGVyUHQpIHtcclxuXHRcdHZhciBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIsXHJcblx0XHRcdGxlZ0xlbmd0aCA9IHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fc3BpcmFsTGVuZ3RoU3RhcnQsXHJcblx0XHRcdHNlcGFyYXRpb24gPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbEZvb3RTZXBhcmF0aW9uLFxyXG5cdFx0XHRsZW5ndGhGYWN0b3IgPSBzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aEZhY3RvciAqIHRoaXMuXzJQSSxcclxuXHRcdFx0YW5nbGUgPSAwLFxyXG5cdFx0XHRyZXMgPSBbXSxcclxuXHRcdFx0aTtcclxuXHJcblx0XHRyZXMubGVuZ3RoID0gY291bnQ7XHJcblxyXG5cdFx0Ly8gSGlnaGVyIGluZGV4LCBjbG9zZXIgcG9zaXRpb24gdG8gY2x1c3RlciBjZW50ZXIuXHJcblx0XHRmb3IgKGkgPSBjb3VudDsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0Ly8gU2tpcCB0aGUgZmlyc3QgcG9zaXRpb24sIHNvIHRoYXQgd2UgYXJlIGFscmVhZHkgZmFydGhlciBmcm9tIGNlbnRlciBhbmQgd2UgYXZvaWRcclxuXHRcdFx0Ly8gYmVpbmcgdW5kZXIgdGhlIGRlZmF1bHQgY2x1c3RlciBpY29uIChlc3BlY2lhbGx5IGltcG9ydGFudCBmb3IgQ2lyY2xlIE1hcmtlcnMpLlxyXG5cdFx0XHRpZiAoaSA8IGNvdW50KSB7XHJcblx0XHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YW5nbGUgKz0gc2VwYXJhdGlvbiAvIGxlZ0xlbmd0aCArIGkgKiAwLjAwMDU7XHJcblx0XHRcdGxlZ0xlbmd0aCArPSBsZW5ndGhGYWN0b3IgLyBhbmdsZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fSxcclxuXHJcblx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAsXHJcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXHJcblx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcclxuXHRcdFx0Y2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0bSwgaTtcclxuXHJcblx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXRPcGFjaXR5KDEpO1xyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcclxuXHJcblx0XHRcdGlmIChtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xyXG5cdFx0XHRcdG0uc2V0TGF0TG5nKG0uX3ByZVNwaWRlcmZ5TGF0bG5nKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XHJcblx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcclxuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xyXG5cdFx0XHRjbHVzdGVyOiB0aGlzLFxyXG5cdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcclxuXHRcdH0pO1xyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHRcdGdyb3VwLl9zcGlkZXJmaWVkID0gbnVsbDtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy9Ob24gQW5pbWF0ZWQgdmVyc2lvbnMgb2YgZXZlcnl0aGluZ1xyXG5MLk1hcmtlckNsdXN0ZXJOb25BbmltYXRlZCA9IEwuTWFya2VyQ2x1c3Rlci5leHRlbmQoe1xyXG5cdF9hbmltYXRpb25TcGlkZXJmeTogZnVuY3Rpb24gKGNoaWxkTWFya2VycywgcG9zaXRpb25zKSB7XHJcblx0XHR2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHRsZWdPcHRpb25zID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMsXHJcblx0XHRcdGksIG0sIGxlZywgbmV3UG9zO1xyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBUcmF2ZXJzZSBpbiBhc2NlbmRpbmcgb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgaW5uZXIgY2lyY2xlTWFya2VycyBhcmUgb24gdG9wIG9mIGZ1cnRoZXIgbGVncy4gTm9ybWFsIG1hcmtlcnMgYXJlIHJlLW9yZGVyZWQgYnkgbmV3UG9zaXRpb24uXHJcblx0XHQvLyBUaGUgcmV2ZXJzZSBvcmRlciB0cmljayBubyBsb25nZXIgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb24gbW9kZXJuIGJyb3dzZXJzLlxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkTWFya2Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XHJcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHQvLyBBZGQgdGhlIGxlZyBiZWZvcmUgdGhlIG1hcmtlciwgc28gdGhhdCBpbiBjYXNlIHRoZSBsYXR0ZXIgaXMgYSBjaXJjbGVNYXJrZXIsIHRoZSBsZWcgaXMgYmVoaW5kIGl0LlxyXG5cdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbdGhpcy5fbGF0bG5nLCBuZXdQb3NdLCBsZWdPcHRpb25zKTtcclxuXHRcdFx0bWFwLmFkZExheWVyKGxlZyk7XHJcblx0XHRcdG0uX3NwaWRlckxlZyA9IGxlZztcclxuXHJcblx0XHRcdC8vIE5vdyBhZGQgdGhlIG1hcmtlci5cclxuXHRcdFx0bS5fcHJlU3BpZGVyZnlMYXRsbmcgPSBtLl9sYXRsbmc7XHJcblx0XHRcdG0uc2V0TGF0TG5nKG5ld1Bvcyk7XHJcblx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xyXG5cdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDEwMDAwMDApOyAvL01ha2UgdGhlc2UgYXBwZWFyIG9uIHRvcCBvZiBFVkVSWVRISU5HXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZnLmFkZExheWVyKG0pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XHJcblx0XHRcdGNsdXN0ZXI6IHRoaXMsXHJcblx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcclxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xyXG5cclxuXHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xyXG5cdFx0dmFyIG1lID0gdGhpcyxcclxuXHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHR0aGlzTGF5ZXJMYXRMbmcgPSB0aGlzLl9sYXRsbmcsXHJcblx0XHRcdHRoaXNMYXllclBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpc0xheWVyTGF0TG5nKSxcclxuXHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcclxuXHRcdFx0bGVnT3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCB0aGlzLl9ncm91cC5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucyksIC8vIENvcHkgdGhlIG9wdGlvbnMgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZW0gZm9yIGFuaW1hdGlvbi5cclxuXHRcdFx0ZmluYWxMZWdPcGFjaXR5ID0gbGVnT3B0aW9ucy5vcGFjaXR5LFxyXG5cdFx0XHRpLCBtLCBsZWcsIGxlZ1BhdGgsIGxlZ0xlbmd0aCwgbmV3UG9zO1xyXG5cclxuXHRcdGlmIChmaW5hbExlZ09wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRmaW5hbExlZ09wYWNpdHkgPSBMLk1hcmtlckNsdXN0ZXJHcm91cC5wcm90b3R5cGUub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMub3BhY2l0eTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdC8vIElmIHRoZSBpbml0aWFsIG9wYWNpdHkgb2YgdGhlIHNwaWRlciBsZWcgaXMgbm90IDAgdGhlbiBpdCBhcHBlYXJzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cclxuXHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gMDtcclxuXHJcblx0XHRcdC8vIEFkZCB0aGUgY2xhc3MgZm9yIENTUyB0cmFuc2l0aW9ucy5cclxuXHRcdFx0bGVnT3B0aW9ucy5jbGFzc05hbWUgPSAobGVnT3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LWNsdXN0ZXItc3BpZGVyLWxlZyc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGRlZmluZWQgb3BhY2l0eS5cclxuXHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gZmluYWxMZWdPcGFjaXR5O1xyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBBZGQgbWFya2VycyBhbmQgc3BpZGVyIGxlZ3MgdG8gbWFwLCBoaWRkZW4gYXQgb3VyIGNlbnRlciBwb2ludC5cclxuXHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cclxuXHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XHJcblxyXG5cdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XHJcblxyXG5cdFx0XHQvLyBBZGQgdGhlIGxlZyBiZWZvcmUgdGhlIG1hcmtlciwgc28gdGhhdCBpbiBjYXNlIHRoZSBsYXR0ZXIgaXMgYSBjaXJjbGVNYXJrZXIsIHRoZSBsZWcgaXMgYmVoaW5kIGl0LlxyXG5cdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbdGhpc0xheWVyTGF0TG5nLCBuZXdQb3NdLCBsZWdPcHRpb25zKTtcclxuXHRcdFx0bWFwLmFkZExheWVyKGxlZyk7XHJcblx0XHRcdG0uX3NwaWRlckxlZyA9IGxlZztcclxuXHJcblx0XHRcdC8vIEV4cGxhbmF0aW9uczogaHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8yMDEzL2FuaW1hdGVkLWxpbmUtZHJhd2luZy1zdmcvXHJcblx0XHRcdC8vIEluIG91ciBjYXNlIHRoZSB0cmFuc2l0aW9uIHByb3BlcnR5IGlzIGRlY2xhcmVkIGluIHRoZSBDU1MgZmlsZS5cclxuXHRcdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XHJcblx0XHRcdFx0bGVnTGVuZ3RoID0gbGVnUGF0aC5nZXRUb3RhbExlbmd0aCgpICsgMC4xOyAvLyBOZWVkIGEgc21hbGwgZXh0cmEgbGVuZ3RoIHRvIGF2b2lkIHJlbWFpbmluZyBkb3QgaW4gRmlyZWZveC5cclxuXHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hhcnJheSA9IGxlZ0xlbmd0aDsgLy8gSnVzdCAxIGxlbmd0aCBpcyBlbm91Z2gsIGl0IHdpbGwgYmUgZHVwbGljYXRlZC5cclxuXHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBsZWdMZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIGl0IGlzIGEgbWFya2VyLCBhZGQgaXQgbm93IGFuZCB3ZSdsbCBhbmltYXRlIGl0IG91dFxyXG5cdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy8gTWFrZSBub3JtYWwgbWFya2VycyBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobS5jbHVzdGVySGlkZSkge1xyXG5cdFx0XHRcdG0uY2x1c3RlckhpZGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVmVjdG9ycyBqdXN0IGdldCBpbW1lZGlhdGVseSBhZGRlZFxyXG5cdFx0XHRmZy5hZGRMYXllcihtKTtcclxuXHJcblx0XHRcdGlmIChtLl9zZXRQb3MpIHtcclxuXHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLl9mb3JjZUxheW91dCgpO1xyXG5cdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0Ly8gUmV2ZWFsIG1hcmtlcnMgYW5kIHNwaWRlciBsZWdzLlxyXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcclxuXHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdC8vTW92ZSBtYXJrZXIgdG8gbmV3IHBvc2l0aW9uXHJcblx0XHRcdG0uX3ByZVNwaWRlcmZ5TGF0bG5nID0gbS5fbGF0bG5nO1xyXG5cdFx0XHRtLnNldExhdExuZyhuZXdQb3MpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFuaW1hdGUgbGVnIChhbmltYXRpb24gaXMgYWN0dWFsbHkgZGVsZWdhdGVkIHRvIENTUyB0cmFuc2l0aW9uKS5cclxuXHRcdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRcdGxlZyA9IG0uX3NwaWRlckxlZztcclxuXHRcdFx0XHRsZWdQYXRoID0gbGVnLl9wYXRoO1xyXG5cdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IDA7XHJcblx0XHRcdFx0Ly9sZWdQYXRoLnN0eWxlLnN0cm9rZU9wYWNpdHkgPSBmaW5hbExlZ09wYWNpdHk7XHJcblx0XHRcdFx0bGVnLnNldFN0eWxlKHtvcGFjaXR5OiBmaW5hbExlZ09wYWNpdHl9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Z3JvdXAuX2FuaW1hdGlvbkVuZCgpO1xyXG5cdFx0XHRncm91cC5maXJlKCdzcGlkZXJmaWVkJywge1xyXG5cdFx0XHRcdGNsdXN0ZXI6IG1lLFxyXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xyXG5cdFx0dmFyIG1lID0gdGhpcyxcclxuXHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcclxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcclxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxyXG5cdFx0XHR0aGlzTGF5ZXJQb3MgPSB6b29tRGV0YWlscyA/IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgem9vbURldGFpbHMuem9vbSwgem9vbURldGFpbHMuY2VudGVyKSA6IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdFx0Y2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcclxuXHRcdFx0c3ZnID0gTC5QYXRoLlNWRyxcclxuXHRcdFx0bSwgaSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5vbkFuaW1hdGFibGU7XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xyXG5cdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XHJcblxyXG5cdFx0Ly9NYWtlIHVzIHZpc2libGUgYW5kIGJyaW5nIHRoZSBjaGlsZCBtYXJrZXJzIGJhY2sgaW5cclxuXHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcclxuXHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cclxuXHRcdFx0Ly9NYXJrZXIgd2FzIGFkZGVkIHRvIHVzIGFmdGVyIHdlIHdlcmUgc3BpZGVyZmllZFxyXG5cdFx0XHRpZiAoIW0uX3ByZVNwaWRlcmZ5TGF0bG5nKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vQ2xvc2UgYW55IHBvcHVwIG9uIHRoZSBtYXJrZXIgZmlyc3QsIG90aGVyd2lzZSBzZXR0aW5nIHRoZSBsb2NhdGlvbiBvZiB0aGUgbWFya2VyIHdpbGwgbWFrZSB0aGUgbWFwIHNjcm9sbFxyXG5cdFx0XHRtLmNsb3NlUG9wdXAoKTtcclxuXHJcblx0XHRcdC8vRml4IHVwIHRoZSBsb2NhdGlvbiB0byB0aGUgcmVhbCBvbmVcclxuXHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xyXG5cdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XHJcblxyXG5cdFx0XHQvL0hhY2sgb3ZlcnJpZGUgdGhlIGxvY2F0aW9uIHRvIGJlIG91ciBjZW50ZXJcclxuXHRcdFx0bm9uQW5pbWF0YWJsZSA9IHRydWU7XHJcblx0XHRcdGlmIChtLl9zZXRQb3MpIHtcclxuXHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcclxuXHRcdFx0XHRub25BbmltYXRhYmxlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcclxuXHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XHJcblx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChub25BbmltYXRhYmxlKSB7XHJcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFuaW1hdGUgdGhlIHNwaWRlciBsZWcgYmFjayBpbiAoYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGRlbGVnYXRlZCB0byBDU1MgdHJhbnNpdGlvbikuXHJcblx0XHRcdGlmIChzdmcpIHtcclxuXHRcdFx0XHRsZWcgPSBtLl9zcGlkZXJMZWc7XHJcblx0XHRcdFx0bGVnUGF0aCA9IGxlZy5fcGF0aDtcclxuXHRcdFx0XHRsZWdMZW5ndGggPSBsZWdQYXRoLmdldFRvdGFsTGVuZ3RoKCkgKyAwLjE7XHJcblx0XHRcdFx0bGVnUGF0aC5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gbGVnTGVuZ3RoO1xyXG5cdFx0XHRcdGxlZy5zZXRTdHlsZSh7b3BhY2l0eTogMH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcclxuXHJcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0Ly9JZiB3ZSBoYXZlIG9ubHkgPD0gb25lIGNoaWxkIGxlZnQgdGhlbiB0aGF0IG1hcmtlciB3aWxsIGJlIHNob3duIG9uIHRoZSBtYXAgc28gZG9uJ3QgcmVtb3ZlIGl0IVxyXG5cdFx0XHR2YXIgc3RpbGxUaGVyZUNoaWxkQ291bnQgPSAwO1xyXG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xyXG5cdFx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcclxuXHRcdFx0XHRcdHN0aWxsVGhlcmVDaGlsZENvdW50Kys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcclxuXHJcblx0XHRcdFx0aWYgKCFtLl9zcGlkZXJMZWcpIHsgLy9IYXMgYWxyZWFkeSBiZWVuIHVuc3BpZGVyZmllZFxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xyXG5cdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0aWxsVGhlcmVDaGlsZENvdW50ID4gMSkge1xyXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIobS5fc3BpZGVyTGVnKTtcclxuXHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xyXG5cdFx0XHR9XHJcblx0XHRcdGdyb3VwLl9hbmltYXRpb25FbmQoKTtcclxuXHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xyXG5cdFx0XHRcdGNsdXN0ZXI6IG1lLFxyXG5cdFx0XHRcdG1hcmtlcnM6IGNoaWxkTWFya2Vyc1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcclxuXHQvL1RoZSBNYXJrZXJDbHVzdGVyIGN1cnJlbnRseSBzcGlkZXJmaWVkIChpZiBhbnkpXHJcblx0X3NwaWRlcmZpZWQ6IG51bGwsXHJcblxyXG5cdHVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR9LFxyXG5cclxuXHRfc3BpZGVyZmllck9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHQvL0Jyb3dzZXJzIHdpdGhvdXQgem9vbUFuaW1hdGlvbiBvciBhIGJpZyB6b29tIGRvbid0IGZpcmUgem9vbXN0YXJ0XHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdHRoaXMuX21hcC5nZXRSZW5kZXJlcih0aGlzKTtcclxuXHRcdFx0Ly9OZWVkcyB0byBoYXBwZW4gaW4gdGhlIHBhZ2Vsb2FkLCBub3QgYWZ0ZXIsIG9yIGFuaW1hdGlvbnMgZG9uJ3Qgd29yayBpbiB3ZWJraXRcclxuXHRcdFx0Ly8gIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1NTIwMC9zdmctYW5pbWF0ZS13aXRoLWR5bmFtaWNhbGx5LWFkZGVkLWVsZW1lbnRzXHJcblx0XHRcdC8vRGlzYWJsZSBvbiB0b3VjaCBicm93c2VycyBhcyB0aGUgYW5pbWF0aW9uIG1lc3NlcyB1cCBvbiBhIHRvdWNoIHpvb20gYW5kIGlzbid0IHZlcnkgbm90aWNhYmxlXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NwaWRlcmZpZXJPblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl91bnNwaWRlcmZ5V3JhcHBlciwgdGhpcyk7XHJcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbVN0YXJ0LCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xyXG5cclxuXHRcdC8vRW5zdXJlIHRoYXQgbWFya2VycyBhcmUgYmFjayB3aGVyZSB0aGV5IHNob3VsZCBiZVxyXG5cdFx0Ly8gVXNlIG5vIGFuaW1hdGlvbiB0byBhdm9pZCBhIHN0aWNreSBsZWFmbGV0LWNsdXN0ZXItYW5pbSBjbGFzcyBvbiBtYXBQYW5lXHJcblx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcclxuXHR9LFxyXG5cclxuXHQvL09uIHpvb20gc3RhcnQgd2UgYWRkIGEgem9vbWFuaW0gaGFuZGxlciBzbyB0aGF0IHdlIGFyZSBndWFyYW50ZWVkIHRvIGJlIGxhc3QgKGFmdGVyIG1hcmtlcnMgYXJlIGFuaW1hdGVkKVxyXG5cdC8vVGhpcyBtZWFucyB3ZSBjYW4gZGVmaW5lIHRoZSBhbmltYXRpb24gdGhleSBkbyByYXRoZXIgdGhhbiBNYXJrZXJzIGRvaW5nIGFuIGFuaW1hdGlvbiB0byB0aGVpciBhY3R1YWwgbG9jYXRpb25cclxuXHRfdW5zcGlkZXJmeVpvb21TdGFydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgLy9NYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGJ5IGEgem9vbUVuZCBoYW5kbGVyXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAub24oJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfdW5zcGlkZXJmeVpvb21BbmltOiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdC8vV2FpdCB1bnRpbCB0aGUgZmlyc3Qgem9vbWFuaW0gYWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIHRvdWNoLXpvb21pbmcgYmVmb3JlIHJ1bm5pbmcgdGhlIGFuaW1hdGlvblxyXG5cdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9tYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcclxuXHRcdHRoaXMuX3Vuc3BpZGVyZnkoem9vbURldGFpbHMpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5V3JhcHBlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8vIDxzdW1tYXJ5Pl91bnNwaWRlcmZ5IGJ1dCBwYXNzZXMgbm8gYXJndW1lbnRzPC9zdW1tYXJ5PlxyXG5cdFx0dGhpcy5fdW5zcGlkZXJmeSgpO1xyXG5cdH0sXHJcblxyXG5cdF91bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcclxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XHJcblx0XHRcdHRoaXMuX3NwaWRlcmZpZWQudW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcclxuXHRcdFx0dGhpcy5fc3BpZGVyZmllZC5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly9JZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGJlaW5nIHNwaWRlcmZpZWQgdGhlbiB3ZSB1bnNwaWRlcmZ5IGl0IHNvIGl0IGlzbid0IG9uIHRoZSBtYXAgYW55bW9yZSBldGNcclxuXHRfdW5zcGlkZXJmeUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmIChsYXllci5fc3BpZGVyTGVnKSB7XHJcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihsYXllcik7XHJcblxyXG5cdFx0XHRpZiAobGF5ZXIuY2x1c3RlclNob3cpIHtcclxuXHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFx0Ly9Qb3NpdGlvbiB3aWxsIGJlIGZpeGVkIHVwIGltbWVkaWF0ZWx5IGluIF9hbmltYXRpb25VbnNwaWRlcmZ5XHJcblx0XHRcdGlmIChsYXllci5zZXRaSW5kZXhPZmZzZXQpIHtcclxuXHRcdFx0XHRsYXllci5zZXRaSW5kZXhPZmZzZXQoMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcihsYXllci5fc3BpZGVyTGVnKTtcclxuXHRcdFx0ZGVsZXRlIGxheWVyLl9zcGlkZXJMZWc7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXIuU3BpZGVyZmllci5qcyIsIi8qKlxyXG4gKiBBZGRzIDEgcHVibGljIG1ldGhvZCB0byBNQ0cgYW5kIDEgdG8gTC5NYXJrZXIgdG8gZmFjaWxpdGF0ZSBjaGFuZ2luZ1xyXG4gKiBtYXJrZXJzJyBpY29uIG9wdGlvbnMgYW5kIHJlZnJlc2hpbmcgdGhlaXIgaWNvbiBhbmQgdGhlaXIgcGFyZW50IGNsdXN0ZXJzXHJcbiAqIGFjY29yZGluZ2x5IChjYXNlIHdoZXJlIHRoZWlyIGljb25DcmVhdGVGdW5jdGlvbiB1c2VzIGRhdGEgb2YgY2hpbGRNYXJrZXJzXHJcbiAqIHRvIG1ha2UgdXAgdGhlIGNsdXN0ZXIgaWNvbikuXHJcbiAqL1xyXG5cclxuXHJcbkwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGljb24gb2YgYWxsIGNsdXN0ZXJzIHdoaWNoIGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBtYXJrZXIocykuXHJcblx0ICogSW4gc2luZ2xlTWFya2VyTW9kZSwgYWxzbyB1cGRhdGVzIHRoZSBnaXZlbiBtYXJrZXIocykgaWNvbi5cclxuXHQgKiBAcGFyYW0gbGF5ZXJzIEwuTWFya2VyQ2x1c3Rlckdyb3VwfEwuTGF5ZXJHcm91cHxBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKXxcclxuXHQgKiBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgKG9wdGlvbmFsKSBsaXN0IG9mIG1hcmtlcnMgKG9yIHNpbmdsZSBtYXJrZXIpIHdob3NlIHBhcmVudFxyXG5cdCAqIGNsdXN0ZXJzIG5lZWQgdG8gYmUgdXBkYXRlZC4gSWYgbm90IHByb3ZpZGVkLCByZXRyaWV2ZXMgYWxsIGNoaWxkIG1hcmtlcnMgb2YgdGhpcy5cclxuXHQgKiBAcmV0dXJucyB7TC5NYXJrZXJDbHVzdGVyR3JvdXB9XHJcblx0ICovXHJcblx0cmVmcmVzaENsdXN0ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHRpZiAoIWxheWVycykge1xyXG5cdFx0XHRsYXllcnMgPSB0aGlzLl90b3BDbHVzdGVyTGV2ZWwuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlckdyb3VwKSB7XHJcblx0XHRcdGxheWVycyA9IGxheWVycy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycygpO1xyXG5cdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcclxuXHRcdFx0bGF5ZXJzID0gbGF5ZXJzLl9sYXllcnM7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xyXG5cdFx0XHRsYXllcnMgPSBsYXllcnMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XHJcblx0XHR9IGVsc2UgaWYgKGxheWVycyBpbnN0YW5jZW9mIEwuTWFya2VyKSB7XHJcblx0XHRcdGxheWVycyA9IFtsYXllcnNdO1xyXG5cdFx0fSAvLyBlbHNlOiBtdXN0IGJlIGFuIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpXHJcblx0XHR0aGlzLl9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZShsYXllcnMpO1xyXG5cdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcclxuXHJcblx0XHQvLyBJbiBjYXNlIG9mIHNpbmdsZU1hcmtlck1vZGUsIGFsc28gcmUtZHJhdyB0aGUgbWFya2Vycy5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2luZ2xlTWFya2VyTW9kZSkge1xyXG5cdFx0XHR0aGlzLl9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnMobGF5ZXJzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaW1wbHkgZmxhZ3MgYWxsIHBhcmVudCBjbHVzdGVycyBvZiB0aGUgZ2l2ZW4gbWFya2VycyBhcyBoYXZpbmcgYSBcImRpcnR5XCIgaWNvbi5cclxuXHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9mbGFnUGFyZW50c0ljb25zTmVlZFVwZGF0ZTogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0dmFyIGlkLCBwYXJlbnQ7XHJcblxyXG5cdFx0Ly8gQXNzdW1lcyBsYXllcnMgaXMgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IHdob3NlIHByb3RvdHlwZSBpcyBub24tZW51bWVyYWJsZS5cclxuXHRcdGZvciAoaWQgaW4gbGF5ZXJzKSB7XHJcblx0XHRcdC8vIEZsYWcgcGFyZW50IGNsdXN0ZXJzJyBpY29uIGFzIFwiZGlydHlcIiwgYWxsIHRoZSB3YXkgdXAuXHJcblx0XHRcdC8vIER1bWIgcHJvY2VzcyB0aGF0IGZsYWdzIG11bHRpcGxlIHRpbWVzIHVwcGVyIHBhcmVudHMsIGJ1dCBzdGlsbFxyXG5cdFx0XHQvLyBtdWNoIG1vcmUgZWZmaWNpZW50IHRoYW4gdHJ5aW5nIHRvIGJlIHNtYXJ0IGFuZCBtYWtlIHNob3J0IGxpc3RzLFxyXG5cdFx0XHQvLyBhdCBsZWFzdCBpbiB0aGUgY2FzZSBvZiBhIGhpZXJhcmNoeSBmb2xsb3dpbmcgYSBwb3dlciBsYXc6XHJcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL2ZsYWctbm9kZXMtaW4tcG93ZXItaGllcmFyY2h5LzJcclxuXHRcdFx0cGFyZW50ID0gbGF5ZXJzW2lkXS5fX3BhcmVudDtcclxuXHRcdFx0d2hpbGUgKHBhcmVudCkge1xyXG5cdFx0XHRcdHBhcmVudC5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX19wYXJlbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZS1kcmF3cyB0aGUgaWNvbiBvZiB0aGUgc3VwcGxpZWQgbWFya2Vycy5cclxuXHQgKiBUbyBiZSB1c2VkIGluIHNpbmdsZU1hcmtlck1vZGUgb25seS5cclxuXHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdHZhciBpZCwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSBsYXllcnNbaWRdO1xyXG5cclxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRvIG5vdCBvdmVycmlkZSBtYXJrZXJzIHRoYXQgZG8gbm90IGJlbG9uZyB0byBUSElTIGdyb3VwLlxyXG5cdFx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0XHQvLyBOZWVkIHRvIHJlLWNyZWF0ZSB0aGUgaWNvbiBmaXJzdCwgdGhlbiByZS1kcmF3IHRoZSBtYXJrZXIuXHJcblx0XHRcdFx0bGF5ZXIuc2V0SWNvbih0aGlzLl9vdmVycmlkZU1hcmtlckljb24obGF5ZXIpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBnaXZlbiBvcHRpb25zIGluIHRoZSBtYXJrZXIncyBpY29uIGFuZCByZWZyZXNoZXMgdGhlIG1hcmtlci5cclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBtYXAgb2JqZWN0IG9mIGljb24gb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0gZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgYm9vbGVhbiAob3B0aW9uYWwpIHRydWUgdG8gdHJpZ2dlclxyXG5cdCAqIE1DRy5yZWZyZXNoQ2x1c3RlcnNPZigpIHJpZ2h0IGF3YXkgd2l0aCB0aGlzIHNpbmdsZSBtYXJrZXIuXHJcblx0ICogQHJldHVybnMge0wuTWFya2VyfVxyXG5cdCAqL1xyXG5cdHJlZnJlc2hJY29uT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMsIGRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzKSB7XHJcblx0XHR2YXIgaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uO1xyXG5cclxuXHRcdEwuc2V0T3B0aW9ucyhpY29uLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLnNldEljb24oaWNvbik7XHJcblxyXG5cdFx0Ly8gU2hvcnRjdXQgdG8gcmVmcmVzaCB0aGUgYXNzb2NpYXRlZCBNQ0cgY2x1c3RlcnMgcmlnaHQgYXdheS5cclxuXHRcdC8vIFRvIGJlIHVzZWQgd2hlbiByZWZyZXNoaW5nIGEgc2luZ2xlIG1hcmtlci5cclxuXHRcdC8vIE90aGVyd2lzZSwgYmV0dGVyIHVzZSBNQ0cucmVmcmVzaENsdXN0ZXJzKCkgb25jZSBhdCB0aGUgZW5kIHdpdGhcclxuXHRcdC8vIHRoZSBsaXN0IG9mIG1vZGlmaWVkIG1hcmtlcnMuXHJcblx0XHRpZiAoZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgJiYgdGhpcy5fX3BhcmVudCkge1xyXG5cdFx0XHR0aGlzLl9fcGFyZW50Ll9ncm91cC5yZWZyZXNoQ2x1c3RlcnModGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9sZWFmbGV0Lm1hcmtlcmNsdXN0ZXIvc3JjL01hcmtlckNsdXN0ZXJHcm91cC5SZWZyZXNoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvNC4wLjAtYmV0YS9jc3MvYm9vdHN0cmFwLm1pbi5jc3NcXFwiIGludGVncml0eT1cXFwic2hhMzg0LS9ZNnBENkZWL1Z2MkhKbkE2dCt2c2xVNmZ3WVhqQ0Z0Y0VwSGJOSjBseUFGc1hUc2pCYmZhRGp6QUxlUXNONk1cXFwiXFxuICBjcm9zc29yaWdpbj1cXFwiYW5vbnltb3VzXFxcIj5cXG48bGluayBocmVmPVxcXCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9TGF0bzozMDAsNDAwLDQwMGksOTAwXFxcIiByZWw9XFxcInN0eWxlc2hlZXRcXFwiPlxcbjxsaW5rIGhyZWY9XFxcImh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNy4wL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzc1xcXCIgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBpbnRlZ3JpdHk9XFxcInNoYTM4NC13dmZYcHFwWlpWUUdLNlRBaDVQVmxHT2ZRTkhTb0QyeGJFK1FrUHhDQUZsTkVldm9FSDNTbDBzaWJWY09RVm5OXFxcIlxcbiAgY3Jvc3NvcmlnaW49XFxcImFub255bW91c1xcXCI+XFxuXFxuXFxuICA8bGluayByZWw9XFxcInN0eWxlc2hlZXRcXFwiIGhyZWY9XFxcImh0dHBzOi8vdW5wa2cuY29tL2xlYWZsZXQubWFya2VyY2x1c3RlckAxLjMuMC9kaXN0L01hcmtlckNsdXN0ZXIuY3NzXFxcIiBtZWRpYT1cXFwic2NyZWVuXFxcIj5cXG4gIDxsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiaHR0cHM6Ly91bnBrZy5jb20vbGVhZmxldC5tYXJrZXJjbHVzdGVyQDEuMy4wL2Rpc3QvTWFya2VyQ2x1c3Rlci5EZWZhdWx0LmNzc1xcXCIgbWVkaWE9XFxcInNjcmVlblxcXCI+XFxuXFxuXFxuPHN0eWxlPlxcbiAgIDpob3N0IHtcXG4gICAgZm9udC1mYW1pbHk6ICdMYXRvJywgc2Fucy1zZXJpZjtcXG4gICAgLS1wcmltYXJ5LWNvbG9yOiAjMDAzZDdkO1xcbiAgICAtLXNlY29uZGFyeS1jb2xvcjogI2ZmNGI1ZjtcXG4gIH1cXG5cXG4gIG1haW4uY2FyZCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMTVweDtcXG4gICAgdG9wOiAxNXB4O1xcbiAgICBib3R0b206IDE1cHg7XFxuICAgIHdpZHRoOiAzMDBweDtcXG4gICAgei1pbmRleDogMTAwNTtcXG5cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgYm94LXNoYWRvdzogMCA4cHggMTBweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKSwgMCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xcblxcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTc1bXM7XFxuICB9XFxuXFxuICBhIHtcXG4gICAgY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IsIGluaGVyaXQpO1xcbiAgfVxcblxcbiAgLmJ0bi1wcmltYXJ5IHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IsIGluaGVyaXQpO1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXByaW1hcnktY29sb3IsIGluaGVyaXQpO1xcbiAgfVxcblxcbiAgaGVhZGVyI3BhZ2UtdGl0bGUge1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXG4gICAgaGVpZ2h0OiAxNTBweDtcXG4gIH1cXG5cXG4gIGhlYWRlciNwYWdlLXRpdGxlIGgxIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICAgIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHBhZGRpbmctYm90dG9tOiA1cHg7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzPnVsPmxpLmxpc3QtZ3JvdXAtaXRlbSB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICBzZWN0aW9uI292ZXJsYXlzIC5vdmVybGF5LWl0ZW0ge1xcbiAgICBmb250LXNpemU6IDEuMXJlbTtcXG4gICAgcGFkZGluZzogMC43NXJlbSAxLjI1cmVtO1xcbiAgICBjb2xvcjogIzQ0NDtcXG4gIH1cXG5cXG4gIHNlY3Rpb24jb3ZlcmxheXMgLm92ZXJsYXktaXRlbTpob3ZlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIH1cXG5cXG4gIHNlY3Rpb24jb3ZlcmxheXMgLm92ZXJsYXktaXRlbS5zZWxlY3RlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxuICAgIGNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcXG5cXG4gICAgLyogbGVmdCBib3JkZXIgYW5kIG9mZnNldCB0ZXh0IGJhY2sgKi9cXG4gICAgYm9yZGVyLWxlZnQ6IDAuMjVyZW0gc29saWQgdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuICAgIHBhZGRpbmctbGVmdDogMXJlbTtcXG4gIH1cXG5cXG4gIHVsLm92ZXJsYXktbGF5ZXJzPmxpLmxpc3QtZ3JvdXAtaXRlbSB7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgYm9yZGVyLWxlZnQ6IDAuMjVyZW0gc29saWQgdmFyKC0tcHJpbWFyeS1jb2xvcik7XFxuICAgIHBhZGRpbmctbGVmdDogMS43NXJlbTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcblxcbiAgdWwub3ZlcmxheS1sYXllcnMgLm92ZXJsYXktbGF5ZXJzLXRvZ2dsZSB7XFxuICAgIC0tcHJpbWFyeS1jb2xvcjogdmFyKC0tc2Vjb25kYXJ5LWNvbG9yKTtcXG4gIH1cXG5cXG4gIGJ1dHRvbiNiYXNlbWFwLXN3aXRjaGVyLFxcbiAgYnV0dG9uI2xheWVycy1tZW51LXRvZ2dsZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcmlnaHQ6IDMwcHg7XFxuICAgIHdpZHRoOiAxNjBweDtcXG4gICAgaGVpZ2h0OiA5MHB4O1xcbiAgICB6LWluZGV4OiAxMDAxO1xcbiAgICBib3JkZXI6IDVweCBzb2xpZCAjZmZmZmZmO1xcbiAgICBib3gtc2hhZG93OiAwIDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDNweCAxNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTIpLCAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMyk7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG5cXG4gIGJ1dHRvbiNiYXNlbWFwLXN3aXRjaGVyIHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcuL2FlcmlhbC5wbmcnKTtcXG4gICAgYm90dG9tOiAzMHB4O1xcbiAgfVxcblxcbiAgYnV0dG9uI2xheWVycy1tZW51LXRvZ2dsZSB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGJvdHRvbTogMTMwcHg7XFxuICB9XFxuXFxuICBzZWN0aW9uI2Rvd25sb2FkLWRpc2NsYWltZXIge1xcbiAgICBtYXgtaGVpZ2h0OiA0MDBweDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHRleHQtYWxpZ246IGp1c3RpZnk7XFxuICB9XFxuXFxuICAuc2hvdy1tb2JpbGUge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxuICAgIG1haW4uY2FyZCB7XFxuICAgICAgcmlnaHQ6IDMwcHg7XFxuICAgICAgbGVmdDogMzBweDtcXG4gICAgICB0b3A6IDMwcHg7XFxuICAgICAgYm90dG9tOiAzMHB4O1xcbiAgICAgIHdpZHRoOiB1bnNldDtcXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKDApO1xcbiAgICB9XFxuXFxuICAgIG1haW4uc2hvdyB7XFxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgfVxcblxcbiAgICAuc2hvdy1tb2JpbGUge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB9XFxuXFxuICAgIGJ1dHRvbiNiYXNlbWFwLXN3aXRjaGVyLFxcbiAgICBidXR0b24jbGF5ZXJzLW1lbnUtdG9nZ2xlIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICB3aWR0aDogOTBweDtcXG4gICAgICBoZWlnaHQ6IDkwcHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogOTBweDtcXG4gICAgfVxcbiAgfVxcbjwvc3R5bGU+XFxuXFxuPCEtLWxpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC80LjAuMC1iZXRhL2Nzcy9ib290c3RyYXAubWluLmNzc1xcXCIgaW50ZWdyaXR5PVxcXCJzaGEzODQtL1k2cEQ2RlYvVnYySEpuQTZ0K3ZzbFU2ZndZWGpDRnRjRXBIYk5KMGx5QUZzWFRzakJiZmFEanpBTGVRc042TVxcXCIgY3Jvc3NvcmlnaW49XFxcImFub255bW91c1xcXCItLT5cXG5cXG48bWFpbiBpZD1cXFwibGF5ZXJzLW1lbnVcXFwiIGNsYXNzPVxcXCJjYXJkXFxcIj5cXG4gIDxoZWFkZXIgaWQ9XFxcInBhZ2UtdGl0bGVcXFwiIGNsYXNzPVxcXCJjYXJkLWltZy10b3AgZC1mbGV4IGFsaWduLWl0ZW1zLWVuZFxcXCI+XFxuICAgIDxoMSBjbGFzcz1cXFwiaDJcXFwiPltbbWFwVGl0bGVdXTwvaDE+XFxuICA8L2hlYWRlcj5cXG5cXG4gIDwhLS0gU2VhcmNoIHNlY3Rpb24gLS0+XFxuICA8c2VjdGlvbiBpZD1cXFwic2VhcmNoLXNlY3Rpb25cXFwiIGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCI+XFxuICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJzZWFyY2hcXFwiIGlkPVxcXCJzZWFyY2hcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgcm91bmRlZC0wXFxcIiBwbGFjZWhvbGRlcj1cXFwiU2VhcmNoIGFkZHJlc3NcXFwiPlxcbiAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuIHJvdW5kZWQtMFxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1zZWNvbmRhcnkgcm91bmRlZC0wXFxcIj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1zZWFyY2hcXFwiPjwvaT5cXG4gICAgICA8L2J1dHRvbj5cXG4gICAgPC9zcGFuPlxcbiAgPC9zZWN0aW9uPlxcblxcbiAgPCEtLSBMaXN0IG9mIGF2YWlsYWJsZSBvdmVybGF5cyAtLT5cXG4gIDxzZWN0aW9uIGlkPVxcXCJvdmVybGF5c1xcXCI+XFxuICAgIDx1bCBjbGFzcz1cXFwibGlzdC1ncm91cFxcXCI+XFxuXFxuICAgICAgPHRlbXBsYXRlIGlzPVxcXCJkb20tcmVwZWF0XFxcIiBpdGVtcz1cXFwie3tvdmVybGF5TWFwc319XFxcIj5cXG4gICAgICAgIDxsaSBjbGFzcz1cXFwibGlzdC1ncm91cC1pdGVtXFxcIj5cXG5cXG4gICAgICAgICAgPCEtLSBNYWluIG92ZXJsYXkgdG9nZ2xlIC0tPlxcbiAgICAgICAgICA8dGVtcGxhdGUgaXM9XFxcImRvbS1pZlxcXCIgaWY9XFxcInt7IWZsYXR9fVxcXCI+XFxuICAgICAgICAgICAgPGRpdiB0aXRsZT1cXFwiW1tpdGVtLmRlc2NyaXB0aW9uXV1cXFwiIGNsYXNzJD1cXFwiW1tfb3ZlcmxheUl0ZW1DbGFzcyhzZWxlY3RlZE92ZXJsYXksIGl0ZW0pXV1cXFwiIG9uLWNsaWNrPVxcXCJvdmVybGF5U2VsZWN0XFxcIj5cXG4gICAgICAgICAgICAgIDxwYXBlci10b2dnbGUtYnV0dG9uIGNoZWNrZWQ9XFxcIltbX2lzQ3VycmVudE92ZXJsYXkoc2VsZWN0ZWRPdmVybGF5LCBpdGVtKV1dXFxcIj48L3BhcGVyLXRvZ2dsZS1idXR0b24+XFxuICAgICAgICAgICAgICA8c3Bhbj5bW2l0ZW0ubmFtZV1dPC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L3RlbXBsYXRlPlxcblxcbiAgICAgICAgICA8ZGl2IGNsYXNzJD1cXFwiW1tfb3ZlcmxheUxheWVyc1Nob3coc2VsZWN0ZWRPdmVybGF5LCBpdGVtKV1dXFxcIj5cXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcIm92ZXJsYXktbGF5ZXJzIGxpc3QtZ3JvdXAgbGlzdC1ncm91cC1mbHVzaFxcXCI+XFxuXFxuICAgICAgICAgICAgICA8IS0tIEV4Y2x1c2l2ZSBsYXllcnMgLS0+XFxuICAgICAgICAgICAgICA8dGVtcGxhdGUgaXM9XFxcImRvbS1yZXBlYXRcXFwiIGl0ZW1zPVxcXCJ7e2l0ZW0ubGF5ZXJzLmV4Y2x1c2l2ZXN9fVxcXCIgYXM9XFxcImxheWVyXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJsaXN0LWdyb3VwLWl0ZW0gZC1mbGV4IGp1c3RpZnktY29udGVudC1zdGFydFxcXCIgb24tY2xpY2s9XFxcInRvZ2dsZUxheWVyXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8cGFwZXItdG9nZ2xlLWJ1dHRvbiBjbGFzcz1cXFwib3ZlcmxheS1sYXllcnMtdG9nZ2xlXFxcIiBjaGVja2VkPVxcXCJbW19pc0N1cnJlbnRFeGNsdXNpdmUobGF5ZXIsIHdtc0dyb3VwcyldXVxcXCI+PC9wYXBlci10b2dnbGUtYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtci1hdXRvXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIFtbbGF5ZXIubmFtZV1dXFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIG9uLWNsaWNrPVxcXCJkb3dubG9hZExheWVyXFxcIiBjbGFzcz1cXFwianVzdGlmeS1zZWxmLWVuZFxcXCI+PGkgdGl0bGU9XFxcIkRvd25sb2FkIFtbbGF5ZXIubmFtZV1dXFxcIiBjbGFzcz1cXFwiZmEgZmEtZncgZmEtZG93bmxvYWRcXFwiPjwvaT48L2E+XFxuICAgICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgICA8L3RlbXBsYXRlPlxcblxcbiAgICAgICAgICAgICAgPCEtLSBPcHRpb25hbCBsYXllcnMgLS0+XFxuICAgICAgICAgICAgICA8dGVtcGxhdGUgaXM9XFxcImRvbS1yZXBlYXRcXFwiIGl0ZW1zPVxcXCJ7e2l0ZW0ubGF5ZXJzLm9wdGlvbmFsc319XFxcIiBhcz1cXFwibGF5ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcImxpc3QtZ3JvdXAtaXRlbSBkLWZsZXgganVzdGlmeS1jb250ZW50LXN0YXJ0XFxcIiBvbi1jbGljaz1cXFwidG9nZ2xlTGF5ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxwYXBlci10b2dnbGUtYnV0dG9uIGNsYXNzPVxcXCJvdmVybGF5LWxheWVycy10b2dnbGVcXFwiIGNoZWNrZWQ9XFxcIltbbGF5ZXIudmlzaWJsZV1dXFxcIj48L3BhcGVyLXRvZ2dsZS1idXR0b24+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1yLWF1dG9cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgW1tsYXllci5uYW1lXV1cXG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgb24tY2xpY2s9XFxcImRvd25sb2FkTGF5ZXJcXFwiIGNsYXNzPVxcXCJqdXN0aWZ5LXNlbGYtZW5kXFxcIj48aSB0aXRsZT1cXFwiRG93bmxvYWQgW1tsYXllci5uYW1lXV1cXFwiIGNsYXNzPVxcXCJmYSBmYS1mdyBmYS1kb3dubG9hZFxcXCI+PC9pPjwvYT5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIDwvdGVtcGxhdGU+XFxuXFxuICAgICAgICAgICAgPC91bD5cXG4gICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8L2xpPlxcbiAgICAgIDwvdGVtcGxhdGU+XFxuXFxuICAgIDwvdWw+XFxuICA8L3NlY3Rpb24+XFxuXFxuICA8Zm9vdGVyIGNsYXNzPVxcXCJjYXJkLWJvZHlcXFwiPlxcbiAgICA8IS0tIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPkhlbHA8L2E+XFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPlRvdXI8L2E+IC0tPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0IHNob3ctbW9iaWxlXFxcIj5cXG4gICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBvbi1jbGljaz1cXFwidG9nZ2xlTGF5ZXJzTWVudVxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtbWFwXFxcIj48L2k+XFxuICAgICAgICBWaWV3IE1hcFxcbiAgICAgIDwvYT5cXG4gICAgPC9kaXY+XFxuICA8L2Zvb3Rlcj5cXG48L21haW4+XFxuXFxuPCEtLSBCYXNlbWFwIHRvZ2dsZSBidXR0b24gLS0+XFxuPGJ1dHRvbiBpZD1cXFwiYmFzZW1hcC1zd2l0Y2hlclxcXCIgb24tY2xpY2s9XFxcInN3aXRjaEJhc2VtYXBcXFwiPjwvYnV0dG9uPlxcblxcbjwhLS0gTGF5ZXJzIGNvbnRyb2wgbWVudSAobW9iaWxlIG9ubHkpIC0tPlxcbjxidXR0b24gaWQ9XFxcImxheWVycy1tZW51LXRvZ2dsZVxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgb24tY2xpY2s9XFxcInRvZ2dsZUxheWVyc01lbnVcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1iYXJzIGZhLTN4XFxcIj48L2k+PC9idXR0b24+XFxuXFxuPGxlYWZsZXQtbWFwIG1hcD1cXFwie3ttYXB9fVxcXCIgbGF0aXR1ZGU9XFxcIjMzLjc3ODcyNFxcXCIgbG9uZ2l0dWRlPVxcXCItMTE3Ljk2MDA1OFxcXCIgem9vbT1cXFwiMTNcXFwiIG1pbi16b29tPVxcXCIxMVxcXCIgbWF4LXpvb209XFxcIjE5XFxcIiBhdHRyaWJ1dGlvbi1wcmVmaXg9XFxcIkNpdHkgb2YgR2FyZGVuIEdyb3ZlXFxcIj5cXG5cXG4gIDx0ZW1wbGF0ZSBpcz1cXFwiZG9tLWlmXFxcIiBpZj1cXFwie3tiYXNlU291cmNlfX1cXFwiIHJlc3RhbXA+XFxuICAgIDxsZWFmbGV0LXRpbGUtbGF5ZXIgbWFwPVxcXCJ7e21hcH19XFxcIiB1cmw9XFxcIltbYmFzZVNvdXJjZV1dXFxcIiBmb3JtYXQ9XFxcIltbYmFzZUZvcm1hdF1dXFxcIiBsYXllcnM9XFxcIltbYmFzZUxheWVyc11dXFxcIiBhdHRyaWJ1dGlvbj1cXFwiJmNvcHk7IE9wZW5TdHJlZXRNYXBcXFwiPlxcbiAgICA8L2xlYWZsZXQtdGlsZS1sYXllcj5cXG4gIDwvdGVtcGxhdGU+XFxuXFxuICA8dGVtcGxhdGUgaXM9XFxcImRvbS1yZXBlYXRcXFwiIGl0ZW1zPVxcXCJ7e3dtc0dyb3Vwc319XFxcIiBhcz1cXFwiZ3JvdXBcXFwiPlxcbiAgICA8bGVhZmxldC13bXMtZ3JvdXAgbWFwPVxcXCJ7e21hcH19XFxcIiBzb3VyY2U9XFxcIltbZ3JvdXAuc291cmNlXV1cXFwiIGxheWVycz1cXFwiW1tncm91cC5sYXllcnNdXVxcXCIgdHJhbnNwYXJlbnQgZm9ybWF0PVxcXCJpbWFnZS9wbmdcXFwiIGlkZW50aWZ5PVxcXCJbW2dyb3VwLmlkZW50aWZ5XV1cXFwiPlxcbiAgICA8L2xlYWZsZXQtd21zLWdyb3VwPlxcbiAgPC90ZW1wbGF0ZT5cXG5cXG4gIDx0ZW1wbGF0ZSBpcz1cXFwiZG9tLXJlcGVhdFxcXCIgaXRlbXM9XFxcInt7Z2VvanNvbkxheWVyc319XFxcIiBhcz1cXFwibGF5ZXJcXFwiPlxcbiAgICA8bGVhZmxldC1nZW9qc29uLXBvaW50cyBtYXA9XFxcInt7bWFwfX1cXFwiIHNvdXJjZSQ9XFxcIltbbGF5ZXIuc291cmNlXV1cXFwiIHJhZGl1cyQ9XFxcIltbbGF5ZXIucmFkaXVzXV1cXFwiIHdlaWdodCQ9XFxcIltbbGF5ZXIud2VpZ2h0XV1cXFwiIG1heC1jbHVzdGVyLXJhZGl1cyQ9XFxcIltbbGF5ZXIubWF4Q2x1c3RlclJhZGl1c11dXFxcIlxcbiAgICAgIGZpbGwtY29sb3IkPVxcXCJbW2xheWVyLmZpbGxDb2xvcl1dXFxcIiBvdXRsaW5lLWNvbG9yJD1cXFwiW1tsYXllci5vdXRsaW5lQ29sb3JdXVxcXCIgb3BhY2l0eSQ9XFxcIltbbGF5ZXIub3BhY2l0eV1dXFxcIiBmaWxsLW9wYWNpdHkkPVxcXCJbW2xheWVyLmZpbGxPcGFjaXR5XV1cXFwiIGlkZW50aWZ5JD1cXFwiW1tsYXllci5pZGVudGlmeV1dXFxcIlxcbiAgICAgIGF0dHJpYnV0aW9uJD1cXFwiW1tsYXllci5hdHRyaWJ1dGlvbl1dXFxcIiBjbHVzdGVyJD1cXFwiW1tsYXllci5jbHVzdGVyXV1cXFwiPlxcbiAgICA8L2xlYWZsZXQtZ2VvanNvbi1wb2ludHM+XFxuICA8L3RlbXBsYXRlPlxcbjwvbGVhZmxldC1tYXA+XFxuXFxuPCEtLSBEb3dubG9hZCBNb2RhbCAtLT5cXG48ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlXFxcIiBpZD1cXFwiZG93bmxvYWQtbW9kYWxcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwiZGlhbG9nXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImRvd25sb2FkLW1vZGFsLWxhYmVsXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1kaWFsb2cgbW9kYWwtbGdcXFwiIHJvbGU9XFxcImRvY3VtZW50XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtaGVhZGVyXFxcIj5cXG4gICAgICAgIDxoMyBjbGFzcz1cXFwibW9kYWwtdGl0bGVcXFwiIGlkPVxcXCJkb3dubG9hZC1tb2RhbC1sYWJlbFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGlkPVxcXCJsYXllci1uYW1lXFxcIj48L3NwYW4+XFxuICAgICAgICA8L2gzPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgYXJpYS1sYWJlbD1cXFwiQ2xvc2VcXFwiPlxcbiAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvc3Bhbj5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcbiAgICAgICAgPHNlY3Rpb24gc3R5bGU9XFxcImhlaWdodDogNDAwcHg7IG92ZXJmbG93OiBhdXRvOyBwYWRkaW5nOiAxMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyBmb250LXNpemU6IDAuODVyZW07XFxcIj5cXG4gICAgICAgICAgPGg1PkRvd25sb2FkIERpc2NsYWltZXI8L2g1PlxcblxcbiAgICAgICAgICA8cD5UaGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgcHJvdmlkZXMgdGhlIGRhdGEgYXMgYSBwdWJsaWMgcmVzb3VyY2Ugb2YgZ2VuZXJhbCBpbmZvcm1hdGlvbiBmb3IgdXNlIFxcXCJhcyBpcy5cXFwiIFRoZSBDaXR5XFxuICAgICAgICAgICAgb2YgR2FyZGVuIEdyb3ZlIHByb3ZpZGVzIHRoaXMgaW5mb3JtYXRpb24gd2l0aCB0aGUgdW5kZXJzdGFuZGluZyB0aGF0IGl0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGFjY3VyYXRlLCBjb3JyZWN0XFxuICAgICAgICAgICAgb3IgY29tcGxldGUgYW5kIGFueSBjb25jbHVzaW9ucyBkcmF3biBmcm9tIHN1Y2ggaW5mb3JtYXRpb24gYXJlIHRoZSBzb2xlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyLiBGdXJ0aGVyLFxcbiAgICAgICAgICAgIHRoZSBDaXR5IG9mIEdhcmRlbiBHcm92ZSBtYWtlcyBubyB3YXJyYW50eSwgcmVwcmVzZW50YXRpb24gb3IgZ3VhcmFudHkgYXMgdG8gdGhlIGNvbnRlbnQsIHNlcXVlbmNlLCBhY2N1cmFjeSxcXG4gICAgICAgICAgICB0aW1lbGluZXNzIG9yIGNvbXBsZXRlbmVzcyBvZiBhbnkgb2YgdGhlIHNwYXRpYWwgb3IgZGF0YWJhc2UgaW5mb3JtYXRpb24gcHJvdmlkZWQgaGVyZWluLiBXaGlsZSBldmVyeSBlZmZvcnRcXG4gICAgICAgICAgICBoYXMgYmVlbiBtYWRlIHRvIGVuc3VyZSB0aGUgY29udGVudCwgc2VxdWVuY2UsIGFjY3VyYWN5LCB0aW1lbGluZXNzIG9yIGNvbXBsZXRlbmVzcyBvZiBtYXRlcmlhbHMgcHJlc2VudGVkIHdpdGhpblxcbiAgICAgICAgICAgIHRoZXNlIHBhZ2VzLCB0aGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgYXNzdW1lcyBubyByZXNwb25zaWJpbGl0eSBmb3IgZXJyb3JzIG9yIG9taXNzaW9ucywgYW5kIGV4cGxpY2l0bHkgZGlzY2xhaW1zXFxuICAgICAgICAgICAgYW55IHJlcHJlc2VudGF0aW9ucyBhbmQgd2FycmFudGllcywgaW5jbHVkaW5nLCB3aXRob3V0IGxpbWl0YXRpb24sIHRoZSBpbXBsaWVkIHdhcnJhbnRpZXMgb2YgbWVyY2hhbnRhYmlsaXR5XFxuICAgICAgICAgICAgYW5kIGZpdG5lc3MgZm9yIGEgcGFydGljdWxhciBwdXJwb3NlLiBUaGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgc2hhbGwgYXNzdW1lIG5vIGxpYWJpbGl0eSBmb3I6PC9wPlxcbiAgICAgICAgICA8cD4xLkFueSBlcnJvcnMsIG9taXNzaW9ucywgb3IgaW5hY2N1cmFjaWVzIGluIHRoZSBpbmZvcm1hdGlvbiBwcm92aWRlZCwgcmVnYXJkbGVzcyBvZiBob3cgY2F1c2VkOyBvciAyLkFueSBkZWNpc2lvblxcbiAgICAgICAgICAgIG1hZGUgb3IgYWN0aW9uIHRha2VuIG9yIG5vdCB0YWtlbiBieSB2aWV3ZXIgaW4gcmVsaWFuY2UgdXBvbiBhbnkgaW5mb3JtYXRpb24gb3IgZGF0YSBmdXJuaXNoZWQgaGVyZXVuZGVyLjwvcD5cXG4gICAgICAgICAgPHA+QXZhaWxhYmlsaXR5IG9mIHRoZSBDaXR5IG9mIEdhcmRlbiBHcm92ZSBHSVMgaXMgbm90IGd1YXJhbnRlZWQuIEFwcGxpY2F0aW9ucywgc2VydmVycywgYW5kIG5ldHdvcmsgY29ubmVjdGlvbnNcXG4gICAgICAgICAgICBtYXkgYmUgdW5hdmFpbGFibGUgYXQgYW55IHRpbWUgZm9yIG1haW50ZW5hbmNlIG9yIHVuc2NoZWR1bGVkIG91dGFnZXMuIE91dGFnZXMgbWF5IGJlIG9mIGxvbmcgZHVyYXRpb24uIFVzZXJzXFxuICAgICAgICAgICAgYXJlIGNhdXRpb25lZCB0byBjcmVhdGUgZGVwZW5kZW5jaWVzIG9uIHRoZXNlIHNlcnZpY2VzIGZvciBjcml0aWNhbCBuZWVkcy48L3A+XFxuICAgICAgICAgIDxwPlRIRSBGT1JFR09JTkcgV0FSUkFOVFkgSVMgRVhDTFVTSVZFIEFORCBJTiBMSUVVIE9GIEFMTCBPVEhFUiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgUEFSVElDVUxBUlxcbiAgICAgICAgICAgIFBVUlBPU0UgQU5EL09SIEFOWSBPVEhFUiBUWVBFIFdIRVRIRVIgRVhQUkVTU0VEIE9SIElNUExJRUQuIEluIG5vIGV2ZW50IHNoYWxsIFRoZSBDaXR5IG9mIEdhcmRlbiBHcm92ZSBiZWNvbWVcXG4gICAgICAgICAgICBsaWFibGUgdG8gdXNlcnMgb2YgdGhlc2UgZGF0YSwgb3IgYW55IG90aGVyIHBhcnR5LCBmb3IgYW55IGxvc3Mgb3IgZGlyZWN0LCBpbmRpcmVjdCwgc3BlY2lhbCwgaW5jaWRlbnRhbCBvciBjb25zZXF1ZW50aWFsXFxuICAgICAgICAgICAgZGFtYWdlcywgaW5jbHVkaW5nLCBidXQgbm90IGxpbWl0ZWQgdG8sIHRpbWUsIG1vbmV5IG9yIGdvb2R3aWxsLCBhcmlzaW5nIGZyb20gdGhlIHVzZSBvciBtb2RpZmljYXRpb24gb2YgdGhlXFxuICAgICAgICAgICAgZGF0YS5cXG4gICAgICAgICAgPC9wPlxcbiAgICAgICAgICA8cD5UbyBhc3Npc3QgVGhlIENpdHkgb2YgR2FyZGVuIEdyb3ZlIGluIHRoZSBtYWludGVuYW5jZSBhbmQvb3IgY29ycmVjdGlvbiBvZiB0aGUgZGF0YSwgdXNlcnMgc2hvdWxkIHByb3ZpZGUgdGhlIENpdHlcXG4gICAgICAgICAgICBvZiBHYXJkZW4gR3JvdmUgd2l0aCBpbmZvcm1hdGlvbiBjb25jZXJuaW5nIGVycm9ycyBvciBkaXNjcmVwYW5jaWVzIGZvdW5kIGluIHVzaW5nIHRoZSBkYXRhLiBQbGVhc2UgYWNrbm93bGVkZ2VcXG4gICAgICAgICAgICB0aGUgQ2l0eSBvZiBHYXJkZW4gR3JvdmUgYXMgdGhlIHNvdXJjZSB3aGVuIGRhdGEgaXMgdXNlZCBpbiB0aGUgcHJlcGFyYXRpb24gb2YgcmVwb3J0cywgcGFwZXJzLCBwdWJsaWNhdGlvbnMsXFxuICAgICAgICAgICAgbWFwcywgb3Igb3RoZXIgcHJvZHVjdHMuPC9wPlxcbiAgICAgICAgPC9zZWN0aW9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxuICAgICAgICA8IS0tYnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc2Vjb25kYXJ5XFxcIiBkYXRhLWRpc21pc3M9XFxcIm1vZGFsXFxcIj5DbG9zZTwvYnV0dG9uLS0+XFxuICAgICAgICA8c3BhbiBpZD1cXFwiZG93bmxvYWQtYnV0dG9ucy1sYWJlbFxcXCI+RG93bmxvYWQgYXM6PC9zcGFuPlxcbiAgICAgICAgPGEgaWQ9XFxcImdlb2pzb24tZG93bmxvYWRcXFwiIGhyZWY9XFxcIiNcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImRvd25sb2FkLWJ1dHRvbnMtbGFiZWxcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZG93bmxvYWRcXFwiPjwvaT5HZW9KU09OXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwiY3N2LWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+Q1NWXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwia21sLWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+S01MXFxuICAgICAgICA8L2E+XFxuICAgICAgICA8YSBpZD1cXFwic2hhcGVmaWxlLWRvd25sb2FkXFxcIiBocmVmPVxcXCIjXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJkb3dubG9hZC1idXR0b25zLWxhYmVsXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWRvd25sb2FkXFxcIj48L2k+U2hhcGVmaWxlXFxuICAgICAgICA8L2E+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9hcHAudGVtcGxhdGUuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcykuanN5YW1sPWUoKX19KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uIGUodCxuLGkpe2Z1bmN0aW9uIHIoYSxzKXtpZighblthXSl7aWYoIXRbYV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXMmJmMpcmV0dXJuIGMoYSwhMCk7aWYobylyZXR1cm4gbyhhLCEwKTt2YXIgdT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2ErXCInXCIpO3Rocm93IHUuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix1fXZhciBsPW5bYV09e2V4cG9ydHM6e319O3RbYV1bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFthXVsxXVtlXTtyZXR1cm4gcihufHxlKX0sbCxsLmV4cG9ydHMsZSx0LG4saSl9cmV0dXJuIG5bYV0uZXhwb3J0c31mb3IodmFyIG89XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxhPTA7YTxpLmxlbmd0aDthKyspcihpW2FdKTtyZXR1cm4gcn0oezE6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiBmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIFwiK2UrXCIgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuXCIpfX12YXIgcj1lKFwiLi9qcy15YW1sL2xvYWRlclwiKSxvPWUoXCIuL2pzLXlhbWwvZHVtcGVyXCIpO3QuZXhwb3J0cy5UeXBlPWUoXCIuL2pzLXlhbWwvdHlwZVwiKSx0LmV4cG9ydHMuU2NoZW1hPWUoXCIuL2pzLXlhbWwvc2NoZW1hXCIpLHQuZXhwb3J0cy5GQUlMU0FGRV9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIiksdC5leHBvcnRzLkpTT05fU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2pzb25cIiksdC5leHBvcnRzLkNPUkVfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2NvcmVcIiksdC5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlXCIpLHQuZXhwb3J0cy5ERUZBVUxUX0ZVTExfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSx0LmV4cG9ydHMubG9hZD1yLmxvYWQsdC5leHBvcnRzLmxvYWRBbGw9ci5sb2FkQWxsLHQuZXhwb3J0cy5zYWZlTG9hZD1yLnNhZmVMb2FkLHQuZXhwb3J0cy5zYWZlTG9hZEFsbD1yLnNhZmVMb2FkQWxsLHQuZXhwb3J0cy5kdW1wPW8uZHVtcCx0LmV4cG9ydHMuc2FmZUR1bXA9by5zYWZlRHVtcCx0LmV4cG9ydHMuWUFNTEV4Y2VwdGlvbj1lKFwiLi9qcy15YW1sL2V4Y2VwdGlvblwiKSx0LmV4cG9ydHMuTUlOSU1BTF9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIiksdC5leHBvcnRzLlNBRkVfU0NIRU1BPWUoXCIuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZVwiKSx0LmV4cG9ydHMuREVGQVVMVF9TQ0hFTUE9ZShcIi4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsXCIpLHQuZXhwb3J0cy5zY2FuPWkoXCJzY2FuXCIpLHQuZXhwb3J0cy5wYXJzZT1pKFwicGFyc2VcIiksdC5leHBvcnRzLmNvbXBvc2U9aShcImNvbXBvc2VcIiksdC5leHBvcnRzLmFkZENvbnN0cnVjdG9yPWkoXCJhZGRDb25zdHJ1Y3RvclwiKX0se1wiLi9qcy15YW1sL2R1bXBlclwiOjMsXCIuL2pzLXlhbWwvZXhjZXB0aW9uXCI6NCxcIi4vanMteWFtbC9sb2FkZXJcIjo1LFwiLi9qcy15YW1sL3NjaGVtYVwiOjcsXCIuL2pzLXlhbWwvc2NoZW1hL2NvcmVcIjo4LFwiLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGxcIjo5LFwiLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmVcIjoxMCxcIi4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmVcIjoxMSxcIi4vanMteWFtbC9zY2hlbWEvanNvblwiOjEyLFwiLi9qcy15YW1sL3R5cGVcIjoxM31dLDI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiB2b2lkIDA9PT1lfHxudWxsPT09ZX10LmV4cG9ydHMuaXNOb3RoaW5nPWksdC5leHBvcnRzLmlzT2JqZWN0PWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZX0sdC5leHBvcnRzLnRvQXJyYXk9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTppKGUpP1tdOltlXX0sdC5leHBvcnRzLnJlcGVhdD1mdW5jdGlvbihlLHQpe3ZhciBuLGk9XCJcIjtmb3Iobj0wO248dDtuKz0xKWkrPWU7cmV0dXJuIGl9LHQuZXhwb3J0cy5pc05lZ2F0aXZlWmVybz1mdW5jdGlvbihlKXtyZXR1cm4gMD09PWUmJk51bWJlci5ORUdBVElWRV9JTkZJTklUWT09PTEvZX0sdC5leHBvcnRzLmV4dGVuZD1mdW5jdGlvbihlLHQpe3ZhciBuLGkscixvO2lmKHQpZm9yKG49MCxpPShvPU9iamVjdC5rZXlzKHQpKS5sZW5ndGg7bjxpO24rPTEpZVtyPW9bbl1dPXRbcl07cmV0dXJuIGV9fSx7fV0sMzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0KXt2YXIgbixpLHIsbyxhLHMsYztpZihudWxsPT09dClyZXR1cm57fTtmb3Iobj17fSxyPTAsbz0oaT1PYmplY3Qua2V5cyh0KSkubGVuZ3RoO3I8bztyKz0xKWE9aVtyXSxzPVN0cmluZyh0W2FdKSxcIiEhXCI9PT1hLnNsaWNlKDAsMikmJihhPVwidGFnOnlhbWwub3JnLDIwMDI6XCIrYS5zbGljZSgyKSksKGM9ZS5jb21waWxlZFR5cGVNYXAuZmFsbGJhY2tbYV0pJiZULmNhbGwoYy5zdHlsZUFsaWFzZXMscykmJihzPWMuc3R5bGVBbGlhc2VzW3NdKSxuW2FdPXM7cmV0dXJuIG59ZnVuY3Rpb24gcihlKXt2YXIgdCxuLGk7aWYodD1lLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLGU8PTI1NSluPVwieFwiLGk9MjtlbHNlIGlmKGU8PTY1NTM1KW49XCJ1XCIsaT00O2Vsc2V7aWYoIShlPD00Mjk0OTY3Mjk1KSl0aHJvdyBuZXcgRihcImNvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkZcIik7bj1cIlVcIixpPTh9cmV0dXJuXCJcXFxcXCIrbitFLnJlcGVhdChcIjBcIixpLXQubGVuZ3RoKSt0fWZ1bmN0aW9uIG8oZSl7dGhpcy5zY2hlbWE9ZS5zY2hlbWF8fF8sdGhpcy5pbmRlbnQ9TWF0aC5tYXgoMSxlLmluZGVudHx8MiksdGhpcy5za2lwSW52YWxpZD1lLnNraXBJbnZhbGlkfHwhMSx0aGlzLmZsb3dMZXZlbD1FLmlzTm90aGluZyhlLmZsb3dMZXZlbCk/LTE6ZS5mbG93TGV2ZWwsdGhpcy5zdHlsZU1hcD1pKHRoaXMuc2NoZW1hLGUuc3R5bGVzfHxudWxsKSx0aGlzLnNvcnRLZXlzPWUuc29ydEtleXN8fCExLHRoaXMubGluZVdpZHRoPWUubGluZVdpZHRofHw4MCx0aGlzLm5vUmVmcz1lLm5vUmVmc3x8ITEsdGhpcy5ub0NvbXBhdE1vZGU9ZS5ub0NvbXBhdE1vZGV8fCExLHRoaXMuY29uZGVuc2VGbG93PWUuY29uZGVuc2VGbG93fHwhMSx0aGlzLmltcGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdCx0aGlzLmV4cGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdCx0aGlzLnRhZz1udWxsLHRoaXMucmVzdWx0PVwiXCIsdGhpcy5kdXBsaWNhdGVzPVtdLHRoaXMudXNlZER1cGxpY2F0ZXM9bnVsbH1mdW5jdGlvbiBhKGUsdCl7Zm9yKHZhciBuLGk9RS5yZXBlYXQoXCIgXCIsdCkscj0wLG89LTEsYT1cIlwiLHM9ZS5sZW5ndGg7cjxzOyktMT09PShvPWUuaW5kZXhPZihcIlxcblwiLHIpKT8obj1lLnNsaWNlKHIpLHI9cyk6KG49ZS5zbGljZShyLG8rMSkscj1vKzEpLG4ubGVuZ3RoJiZcIlxcblwiIT09biYmKGErPWkpLGErPW47cmV0dXJuIGF9ZnVuY3Rpb24gcyhlLHQpe3JldHVyblwiXFxuXCIrRS5yZXBlYXQoXCIgXCIsZS5pbmRlbnQqdCl9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuLGk7Zm9yKG49MCxpPWUuaW1wbGljaXRUeXBlcy5sZW5ndGg7bjxpO24rPTEpaWYoZS5pbXBsaWNpdFR5cGVzW25dLnJlc29sdmUodCkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gdShlKXtyZXR1cm4gZT09PVV8fGU9PT1MfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIDMyPD1lJiZlPD0xMjZ8fDE2MTw9ZSYmZTw9NTUyOTUmJjgyMzIhPT1lJiY4MjMzIT09ZXx8NTczNDQ8PWUmJmU8PTY1NTMzJiY2NTI3OSE9PWV8fDY1NTM2PD1lJiZlPD0xMTE0MTExfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGwoZSkmJjY1Mjc5IT09ZSYmZSE9PSQmJmUhPT1KJiZlIT09USYmZSE9PWVlJiZlIT09bmUmJmUhPT1HJiZlIT09Un1mdW5jdGlvbiBmKGUpe3JldHVybiBsKGUpJiY2NTI3OSE9PWUmJiF1KGUpJiZlIT09SCYmZSE9PVomJmUhPT1HJiZlIT09JCYmZSE9PUomJmUhPT1RJiZlIT09ZWUmJmUhPT1uZSYmZSE9PVImJmUhPT1XJiZlIT09SyYmZSE9PXEmJmUhPT10ZSYmZSE9PVYmJmUhPT1CJiZlIT09WSYmZSE9PVAmJmUhPT16JiZlIT09WH1mdW5jdGlvbiBkKGUsdCxuLGkscil7dmFyIG8sYSxzPSExLGM9ITEsZD0tMSE9PWksaD0tMSxtPWYoZS5jaGFyQ29kZUF0KDApKSYmIXUoZS5jaGFyQ29kZUF0KGUubGVuZ3RoLTEpKTtpZih0KWZvcihvPTA7bzxlLmxlbmd0aDtvKyspe2lmKGE9ZS5jaGFyQ29kZUF0KG8pLCFsKGEpKXJldHVybiB1ZTttPW0mJnAoYSl9ZWxzZXtmb3Iobz0wO288ZS5sZW5ndGg7bysrKXtpZigoYT1lLmNoYXJDb2RlQXQobykpPT09RClzPSEwLGQmJihjPWN8fG8taC0xPmkmJlwiIFwiIT09ZVtoKzFdLGg9byk7ZWxzZSBpZighbChhKSlyZXR1cm4gdWU7bT1tJiZwKGEpfWM9Y3x8ZCYmby1oLTE+aSYmXCIgXCIhPT1lW2grMV19cmV0dXJuIHN8fGM/XCIgXCI9PT1lWzBdJiZuPjk/dWU6Yz9jZTpzZTptJiYhcihlKT9vZTphZX1mdW5jdGlvbiBoKGUsdCxuLGkpe2UuZHVtcD1mdW5jdGlvbigpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm5cIicnXCI7aWYoIWUubm9Db21wYXRNb2RlJiYtMSE9PXJlLmluZGV4T2YodCkpcmV0dXJuXCInXCIrdCtcIidcIjt2YXIgcj1lLmluZGVudCpNYXRoLm1heCgxLG4pLG89LTE9PT1lLmxpbmVXaWR0aD8tMTpNYXRoLm1heChNYXRoLm1pbihlLmxpbmVXaWR0aCw0MCksZS5saW5lV2lkdGgtcikscz1pfHxlLmZsb3dMZXZlbD4tMSYmbj49ZS5mbG93TGV2ZWw7c3dpdGNoKGQodCxzLGUuaW5kZW50LG8sZnVuY3Rpb24odCl7cmV0dXJuIGMoZSx0KX0pKXtjYXNlIG9lOnJldHVybiB0O2Nhc2UgYWU6cmV0dXJuXCInXCIrdC5yZXBsYWNlKC8nL2csXCInJ1wiKStcIidcIjtjYXNlIHNlOnJldHVyblwifFwiK20odCxlLmluZGVudCkrZyhhKHQscikpO2Nhc2UgY2U6cmV0dXJuXCI+XCIrbSh0LGUuaW5kZW50KStnKGEoeSh0LG8pLHIpKTtjYXNlIHVlOnJldHVybidcIicrdih0KSsnXCInO2RlZmF1bHQ6dGhyb3cgbmV3IEYoXCJpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZVwiKX19KCl9ZnVuY3Rpb24gbShlLHQpe3ZhciBuPVwiIFwiPT09ZVswXT9TdHJpbmcodCk6XCJcIixpPVwiXFxuXCI9PT1lW2UubGVuZ3RoLTFdO3JldHVybiBuKyhpJiYoXCJcXG5cIj09PWVbZS5sZW5ndGgtMl18fFwiXFxuXCI9PT1lKT9cIitcIjppP1wiXCI6XCItXCIpK1wiXFxuXCJ9ZnVuY3Rpb24gZyhlKXtyZXR1cm5cIlxcblwiPT09ZVtlLmxlbmd0aC0xXT9lLnNsaWNlKDAsLTEpOmV9ZnVuY3Rpb24geShlLHQpe2Zvcih2YXIgbixpLHI9LyhcXG4rKShbXlxcbl0qKS9nLG89ZnVuY3Rpb24oKXt2YXIgbj1lLmluZGV4T2YoXCJcXG5cIik7cmV0dXJuIG49LTEhPT1uP246ZS5sZW5ndGgsci5sYXN0SW5kZXg9bix4KGUuc2xpY2UoMCxuKSx0KX0oKSxhPVwiXFxuXCI9PT1lWzBdfHxcIiBcIj09PWVbMF07aT1yLmV4ZWMoZSk7KXt2YXIgcz1pWzFdLGM9aVsyXTtuPVwiIFwiPT09Y1swXSxvKz1zKyhhfHxufHxcIlwiPT09Yz9cIlwiOlwiXFxuXCIpK3goYyx0KSxhPW59cmV0dXJuIG99ZnVuY3Rpb24geChlLHQpe2lmKFwiXCI9PT1lfHxcIiBcIj09PWVbMF0pcmV0dXJuIGU7Zm9yKHZhciBuLGkscj0vIFteIF0vZyxvPTAsYT0wLHM9MCxjPVwiXCI7bj1yLmV4ZWMoZSk7KShzPW4uaW5kZXgpLW8+dCYmKGk9YT5vP2E6cyxjKz1cIlxcblwiK2Uuc2xpY2UobyxpKSxvPWkrMSksYT1zO3JldHVybiBjKz1cIlxcblwiLGUubGVuZ3RoLW8+dCYmYT5vP2MrPWUuc2xpY2UobyxhKStcIlxcblwiK2Uuc2xpY2UoYSsxKTpjKz1lLnNsaWNlKG8pLGMuc2xpY2UoMSl9ZnVuY3Rpb24gdihlKXtmb3IodmFyIHQsbixpLG89XCJcIixhPTA7YTxlLmxlbmd0aDthKyspKHQ9ZS5jaGFyQ29kZUF0KGEpKT49NTUyOTYmJnQ8PTU2MzE5JiYobj1lLmNoYXJDb2RlQXQoYSsxKSk+PTU2MzIwJiZuPD01NzM0Mz8obys9cigxMDI0Kih0LTU1Mjk2KStuLTU2MzIwKzY1NTM2KSxhKyspOm8rPSEoaT1pZVt0XSkmJmwodCk/ZVthXTppfHxyKHQpO3JldHVybiBvfWZ1bmN0aW9uIEEoZSx0LG4pe3ZhciBpLHIsbz1cIlwiLGE9ZS50YWc7Zm9yKGk9MCxyPW4ubGVuZ3RoO2k8cjtpKz0xKWooZSx0LG5baV0sITEsITEpJiYoMCE9PWkmJihvKz1cIixcIisoZS5jb25kZW5zZUZsb3c/XCJcIjpcIiBcIikpLG8rPWUuZHVtcCk7ZS50YWc9YSxlLmR1bXA9XCJbXCIrbytcIl1cIn1mdW5jdGlvbiBiKGUsdCxuLGkpe3ZhciByLG8sYT1cIlwiLGM9ZS50YWc7Zm9yKHI9MCxvPW4ubGVuZ3RoO3I8bztyKz0xKWooZSx0KzEsbltyXSwhMCwhMCkmJihpJiYwPT09cnx8KGErPXMoZSx0KSksZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/YSs9XCItXCI6YSs9XCItIFwiLGErPWUuZHVtcCk7ZS50YWc9YyxlLmR1bXA9YXx8XCJbXVwifWZ1bmN0aW9uIHcoZSx0LG4pe3ZhciBpLHIsbyxhLHMsYz1cIlwiLHU9ZS50YWcsbD1PYmplY3Qua2V5cyhuKTtmb3IoaT0wLHI9bC5sZW5ndGg7aTxyO2krPTEpcz1lLmNvbmRlbnNlRmxvdz8nXCInOlwiXCIsMCE9PWkmJihzKz1cIiwgXCIpLGE9bltvPWxbaV1dLGooZSx0LG8sITEsITEpJiYoZS5kdW1wLmxlbmd0aD4xMDI0JiYocys9XCI/IFwiKSxzKz1lLmR1bXArKGUuY29uZGVuc2VGbG93PydcIic6XCJcIikrXCI6XCIrKGUuY29uZGVuc2VGbG93P1wiXCI6XCIgXCIpLGooZSx0LGEsITEsITEpJiYoYys9cys9ZS5kdW1wKSk7ZS50YWc9dSxlLmR1bXA9XCJ7XCIrYytcIn1cIn1mdW5jdGlvbiBDKGUsdCxuLGkpe3ZhciByLG8sYSxjLHUsbCxwPVwiXCIsZj1lLnRhZyxkPU9iamVjdC5rZXlzKG4pO2lmKCEwPT09ZS5zb3J0S2V5cylkLnNvcnQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc29ydEtleXMpZC5zb3J0KGUuc29ydEtleXMpO2Vsc2UgaWYoZS5zb3J0S2V5cyl0aHJvdyBuZXcgRihcInNvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb25cIik7Zm9yKHI9MCxvPWQubGVuZ3RoO3I8bztyKz0xKWw9XCJcIixpJiYwPT09cnx8KGwrPXMoZSx0KSksYz1uW2E9ZFtyXV0saihlLHQrMSxhLCEwLCEwLCEwKSYmKCh1PW51bGwhPT1lLnRhZyYmXCI/XCIhPT1lLnRhZ3x8ZS5kdW1wJiZlLmR1bXAubGVuZ3RoPjEwMjQpJiYoZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/bCs9XCI/XCI6bCs9XCI/IFwiKSxsKz1lLmR1bXAsdSYmKGwrPXMoZSx0KSksaihlLHQrMSxjLCEwLHUpJiYoZS5kdW1wJiZEPT09ZS5kdW1wLmNoYXJDb2RlQXQoMCk/bCs9XCI6XCI6bCs9XCI6IFwiLHArPWwrPWUuZHVtcCkpO2UudGFnPWYsZS5kdW1wPXB8fFwie31cIn1mdW5jdGlvbiBrKGUsdCxuKXt2YXIgaSxyLG8sYSxzLGM7Zm9yKG89MCxhPShyPW4/ZS5leHBsaWNpdFR5cGVzOmUuaW1wbGljaXRUeXBlcykubGVuZ3RoO288YTtvKz0xKWlmKCgocz1yW29dKS5pbnN0YW5jZU9mfHxzLnByZWRpY2F0ZSkmJighcy5pbnN0YW5jZU9mfHxcIm9iamVjdFwiPT10eXBlb2YgdCYmdCBpbnN0YW5jZW9mIHMuaW5zdGFuY2VPZikmJighcy5wcmVkaWNhdGV8fHMucHJlZGljYXRlKHQpKSl7aWYoZS50YWc9bj9zLnRhZzpcIj9cIixzLnJlcHJlc2VudCl7aWYoYz1lLnN0eWxlTWFwW3MudGFnXXx8cy5kZWZhdWx0U3R5bGUsXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT09TS5jYWxsKHMucmVwcmVzZW50KSlpPXMucmVwcmVzZW50KHQsYyk7ZWxzZXtpZighVC5jYWxsKHMucmVwcmVzZW50LGMpKXRocm93IG5ldyBGKFwiITxcIitzLnRhZysnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInK2MrJ1wiIHN0eWxlJyk7aT1zLnJlcHJlc2VudFtjXSh0LGMpfWUuZHVtcD1pfXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGooZSx0LG4saSxyLG8pe2UudGFnPW51bGwsZS5kdW1wPW4sayhlLG4sITEpfHxrKGUsbiwhMCk7dmFyIGE9TS5jYWxsKGUuZHVtcCk7aSYmKGk9ZS5mbG93TGV2ZWw8MHx8ZS5mbG93TGV2ZWw+dCk7dmFyIHMsYyx1PVwiW29iamVjdCBPYmplY3RdXCI9PT1hfHxcIltvYmplY3QgQXJyYXldXCI9PT1hO2lmKHUmJihjPS0xIT09KHM9ZS5kdXBsaWNhdGVzLmluZGV4T2YobikpKSwobnVsbCE9PWUudGFnJiZcIj9cIiE9PWUudGFnfHxjfHwyIT09ZS5pbmRlbnQmJnQ+MCkmJihyPSExKSxjJiZlLnVzZWREdXBsaWNhdGVzW3NdKWUuZHVtcD1cIipyZWZfXCIrcztlbHNle2lmKHUmJmMmJiFlLnVzZWREdXBsaWNhdGVzW3NdJiYoZS51c2VkRHVwbGljYXRlc1tzXT0hMCksXCJbb2JqZWN0IE9iamVjdF1cIj09PWEpaSYmMCE9PU9iamVjdC5rZXlzKGUuZHVtcCkubGVuZ3RoPyhDKGUsdCxlLmR1bXAsciksYyYmKGUuZHVtcD1cIiZyZWZfXCIrcytlLmR1bXApKToodyhlLHQsZS5kdW1wKSxjJiYoZS5kdW1wPVwiJnJlZl9cIitzK1wiIFwiK2UuZHVtcCkpO2Vsc2UgaWYoXCJbb2JqZWN0IEFycmF5XVwiPT09YSlpJiYwIT09ZS5kdW1wLmxlbmd0aD8oYihlLHQsZS5kdW1wLHIpLGMmJihlLmR1bXA9XCImcmVmX1wiK3MrZS5kdW1wKSk6KEEoZSx0LGUuZHVtcCksYyYmKGUuZHVtcD1cIiZyZWZfXCIrcytcIiBcIitlLmR1bXApKTtlbHNle2lmKFwiW29iamVjdCBTdHJpbmddXCIhPT1hKXtpZihlLnNraXBJbnZhbGlkKXJldHVybiExO3Rocm93IG5ldyBGKFwidW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgXCIrYSl9XCI/XCIhPT1lLnRhZyYmaChlLGUuZHVtcCx0LG8pfW51bGwhPT1lLnRhZyYmXCI/XCIhPT1lLnRhZyYmKGUuZHVtcD1cIiE8XCIrZS50YWcrXCI+IFwiK2UuZHVtcCl9cmV0dXJuITB9ZnVuY3Rpb24gSShlLHQpe3ZhciBuLGkscj1bXSxvPVtdO2ZvcihTKGUscixvKSxuPTAsaT1vLmxlbmd0aDtuPGk7bis9MSl0LmR1cGxpY2F0ZXMucHVzaChyW29bbl1dKTt0LnVzZWREdXBsaWNhdGVzPW5ldyBBcnJheShpKX1mdW5jdGlvbiBTKGUsdCxuKXt2YXIgaSxyLG87aWYobnVsbCE9PWUmJlwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKC0xIT09KHI9dC5pbmRleE9mKGUpKSktMT09PW4uaW5kZXhPZihyKSYmbi5wdXNoKHIpO2Vsc2UgaWYodC5wdXNoKGUpLEFycmF5LmlzQXJyYXkoZSkpZm9yKHI9MCxvPWUubGVuZ3RoO3I8bztyKz0xKVMoZVtyXSx0LG4pO2Vsc2UgZm9yKHI9MCxvPShpPU9iamVjdC5rZXlzKGUpKS5sZW5ndGg7cjxvO3IrPTEpUyhlW2lbcl1dLHQsbil9ZnVuY3Rpb24gTyhlLHQpe3ZhciBuPW5ldyBvKHQ9dHx8e30pO3JldHVybiBuLm5vUmVmc3x8SShlLG4pLGoobiwwLGUsITAsITApP24uZHVtcCtcIlxcblwiOlwiXCJ9dmFyIEU9ZShcIi4vY29tbW9uXCIpLEY9ZShcIi4vZXhjZXB0aW9uXCIpLF89ZShcIi4vc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSxOPWUoXCIuL3NjaGVtYS9kZWZhdWx0X3NhZmVcIiksTT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxMPTksRD0xMCxVPTMyLHE9MzMsWT0zNCxSPTM1LFA9MzcsVz0zOCxCPTM5LEs9NDIsJD00NCxIPTQ1LEc9NTgsVj02MixaPTYzLHo9NjQsSj05MSxRPTkzLFg9OTYsZWU9MTIzLHRlPTEyNCxuZT0xMjUsaWU9e307aWVbMF09XCJcXFxcMFwiLGllWzddPVwiXFxcXGFcIixpZVs4XT1cIlxcXFxiXCIsaWVbOV09XCJcXFxcdFwiLGllWzEwXT1cIlxcXFxuXCIsaWVbMTFdPVwiXFxcXHZcIixpZVsxMl09XCJcXFxcZlwiLGllWzEzXT1cIlxcXFxyXCIsaWVbMjddPVwiXFxcXGVcIixpZVszNF09J1xcXFxcIicsaWVbOTJdPVwiXFxcXFxcXFxcIixpZVsxMzNdPVwiXFxcXE5cIixpZVsxNjBdPVwiXFxcXF9cIixpZVs4MjMyXT1cIlxcXFxMXCIsaWVbODIzM109XCJcXFxcUFwiO3ZhciByZT1bXCJ5XCIsXCJZXCIsXCJ5ZXNcIixcIlllc1wiLFwiWUVTXCIsXCJvblwiLFwiT25cIixcIk9OXCIsXCJuXCIsXCJOXCIsXCJub1wiLFwiTm9cIixcIk5PXCIsXCJvZmZcIixcIk9mZlwiLFwiT0ZGXCJdLG9lPTEsYWU9MixzZT0zLGNlPTQsdWU9NTt0LmV4cG9ydHMuZHVtcD1PLHQuZXhwb3J0cy5zYWZlRHVtcD1mdW5jdGlvbihlLHQpe3JldHVybiBPKGUsRS5leHRlbmQoe3NjaGVtYTpOfSx0KSl9fSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL3NjaGVtYS9kZWZhdWx0X2Z1bGxcIjo5LFwiLi9zY2hlbWEvZGVmYXVsdF9zYWZlXCI6MTB9XSw0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQpe0Vycm9yLmNhbGwodGhpcyksdGhpcy5uYW1lPVwiWUFNTEV4Y2VwdGlvblwiLHRoaXMucmVhc29uPWUsdGhpcy5tYXJrPXQsdGhpcy5tZXNzYWdlPSh0aGlzLnJlYXNvbnx8XCIodW5rbm93biByZWFzb24pXCIpKyh0aGlzLm1hcms/XCIgXCIrdGhpcy5tYXJrLnRvU3RyaW5nKCk6XCJcIiksRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0aGlzLmNvbnN0cnVjdG9yKTp0aGlzLnN0YWNrPShuZXcgRXJyb3IpLnN0YWNrfHxcIlwifShpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5uYW1lK1wiOiBcIjtyZXR1cm4gdCs9dGhpcy5yZWFzb258fFwiKHVua25vd24gcmVhc29uKVwiLCFlJiZ0aGlzLm1hcmsmJih0Kz1cIiBcIit0aGlzLm1hcmsudG9TdHJpbmcoKSksdH0sdC5leHBvcnRzPWl9LHt9XSw1OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXtyZXR1cm4gMTA9PT1lfHwxMz09PWV9ZnVuY3Rpb24gcihlKXtyZXR1cm4gOT09PWV8fDMyPT09ZX1mdW5jdGlvbiBvKGUpe3JldHVybiA5PT09ZXx8MzI9PT1lfHwxMD09PWV8fDEzPT09ZX1mdW5jdGlvbiBhKGUpe3JldHVybiA0ND09PWV8fDkxPT09ZXx8OTM9PT1lfHwxMjM9PT1lfHwxMjU9PT1lfWZ1bmN0aW9uIHMoZSl7dmFyIHQ7cmV0dXJuIDQ4PD1lJiZlPD01Nz9lLTQ4Ojk3PD0odD0zMnxlKSYmdDw9MTAyP3QtOTcrMTA6LTF9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gMTIwPT09ZT8yOjExNz09PWU/NDo4NT09PWU/ODowfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIDQ4PD1lJiZlPD01Nz9lLTQ4Oi0xfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIDQ4PT09ZT9cIlxcMFwiOjk3PT09ZT9cIlx1MDAwN1wiOjk4PT09ZT9cIlxcYlwiOjExNj09PWU/XCJcXHRcIjo5PT09ZT9cIlxcdFwiOjExMD09PWU/XCJcXG5cIjoxMTg9PT1lP1wiXFx2XCI6MTAyPT09ZT9cIlxcZlwiOjExND09PWU/XCJcXHJcIjoxMDE9PT1lP1wiXHUwMDFiXCI6MzI9PT1lP1wiIFwiOjM0PT09ZT8nXCInOjQ3PT09ZT9cIi9cIjo5Mj09PWU/XCJcXFxcXCI6Nzg9PT1lP1wiwoVcIjo5NT09PWU/XCLCoFwiOjc2PT09ZT9cIlxcdTIwMjhcIjo4MD09PWU/XCJcXHUyMDI5XCI6XCJcIn1mdW5jdGlvbiBwKGUpe3JldHVybiBlPD02NTUzNT9TdHJpbmcuZnJvbUNoYXJDb2RlKGUpOlN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGUtNjU1MzY+PjEwKSw1NjMyMCsoZS02NTUzNiYxMDIzKSl9ZnVuY3Rpb24gZihlLHQpe3RoaXMuaW5wdXQ9ZSx0aGlzLmZpbGVuYW1lPXQuZmlsZW5hbWV8fG51bGwsdGhpcy5zY2hlbWE9dC5zY2hlbWF8fFcsdGhpcy5vbldhcm5pbmc9dC5vbldhcm5pbmd8fG51bGwsdGhpcy5sZWdhY3k9dC5sZWdhY3l8fCExLHRoaXMuanNvbj10Lmpzb258fCExLHRoaXMubGlzdGVuZXI9dC5saXN0ZW5lcnx8bnVsbCx0aGlzLmltcGxpY2l0VHlwZXM9dGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdCx0aGlzLnR5cGVNYXA9dGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwLHRoaXMubGVuZ3RoPWUubGVuZ3RoLHRoaXMucG9zaXRpb249MCx0aGlzLmxpbmU9MCx0aGlzLmxpbmVTdGFydD0wLHRoaXMubGluZUluZGVudD0wLHRoaXMuZG9jdW1lbnRzPVtdfWZ1bmN0aW9uIGQoZSx0KXtyZXR1cm4gbmV3IFkodCxuZXcgUihlLmZpbGVuYW1lLGUuaW5wdXQsZS5wb3NpdGlvbixlLmxpbmUsZS5wb3NpdGlvbi1lLmxpbmVTdGFydCkpfWZ1bmN0aW9uIGgoZSx0KXt0aHJvdyBkKGUsdCl9ZnVuY3Rpb24gbShlLHQpe2Uub25XYXJuaW5nJiZlLm9uV2FybmluZy5jYWxsKG51bGwsZChlLHQpKX1mdW5jdGlvbiBnKGUsdCxuLGkpe3ZhciByLG8sYSxzO2lmKHQ8bil7aWYocz1lLmlucHV0LnNsaWNlKHQsbiksaSlmb3Iocj0wLG89cy5sZW5ndGg7cjxvO3IrPTEpOT09PShhPXMuY2hhckNvZGVBdChyKSl8fDMyPD1hJiZhPD0xMTE0MTExfHxoKGUsXCJleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlclwiKTtlbHNlIEoudGVzdChzKSYmaChlLFwidGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnNcIik7ZS5yZXN1bHQrPXN9fWZ1bmN0aW9uIHkoZSx0LG4saSl7dmFyIHIsbyxhLHM7Zm9yKHEuaXNPYmplY3Qobil8fGgoZSxcImNhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlXCIpLGE9MCxzPShyPU9iamVjdC5rZXlzKG4pKS5sZW5ndGg7YTxzO2ErPTEpbz1yW2FdLEIuY2FsbCh0LG8pfHwodFtvXT1uW29dLGlbb109ITApfWZ1bmN0aW9uIHgoZSx0LG4saSxyLG8sYSxzKXt2YXIgYyx1O2lmKHI9U3RyaW5nKHIpLG51bGw9PT10JiYodD17fSksXCJ0YWc6eWFtbC5vcmcsMjAwMjptZXJnZVwiPT09aSlpZihBcnJheS5pc0FycmF5KG8pKWZvcihjPTAsdT1vLmxlbmd0aDtjPHU7Yys9MSl5KGUsdCxvW2NdLG4pO2Vsc2UgeShlLHQsbyxuKTtlbHNlIGUuanNvbnx8Qi5jYWxsKG4scil8fCFCLmNhbGwodCxyKXx8KGUubGluZT1hfHxlLmxpbmUsZS5wb3NpdGlvbj1zfHxlLnBvc2l0aW9uLGgoZSxcImR1cGxpY2F0ZWQgbWFwcGluZyBrZXlcIikpLHRbcl09byxkZWxldGUgbltyXTtyZXR1cm4gdH1mdW5jdGlvbiB2KGUpe3ZhciB0OzEwPT09KHQ9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKT9lLnBvc2l0aW9uKys6MTM9PT10PyhlLnBvc2l0aW9uKyssMTA9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJmUucG9zaXRpb24rKyk6aChlLFwiYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkXCIpLGUubGluZSs9MSxlLmxpbmVTdGFydD1lLnBvc2l0aW9ufWZ1bmN0aW9uIEEoZSx0LG4pe2Zvcih2YXIgbz0wLGE9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pOzAhPT1hOyl7Zm9yKDtyKGEpOylhPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKHQmJjM1PT09YSlkb3thPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKDEwIT09YSYmMTMhPT1hJiYwIT09YSk7aWYoIWkoYSkpYnJlYWs7Zm9yKHYoZSksYT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksbysrLGUubGluZUluZGVudD0wOzMyPT09YTspZS5saW5lSW5kZW50KyssYT1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX1yZXR1cm4tMSE9PW4mJjAhPT1vJiZlLmxpbmVJbmRlbnQ8biYmbShlLFwiZGVmaWNpZW50IGluZGVudGF0aW9uXCIpLG99ZnVuY3Rpb24gYihlKXt2YXIgdCxuPWUucG9zaXRpb247cmV0dXJuISg0NSE9PSh0PWUuaW5wdXQuY2hhckNvZGVBdChuKSkmJjQ2IT09dHx8dCE9PWUuaW5wdXQuY2hhckNvZGVBdChuKzEpfHx0IT09ZS5pbnB1dC5jaGFyQ29kZUF0KG4rMil8fChuKz0zLDAhPT0odD1lLmlucHV0LmNoYXJDb2RlQXQobikpJiYhbyh0KSkpfWZ1bmN0aW9uIHcoZSx0KXsxPT09dD9lLnJlc3VsdCs9XCIgXCI6dD4xJiYoZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsdC0xKSl9ZnVuY3Rpb24gQyhlLHQsbil7dmFyIHMsYyx1LGwscCxmLGQsaCxtLHk9ZS5raW5kLHg9ZS5yZXN1bHQ7aWYobT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksbyhtKXx8YShtKXx8MzU9PT1tfHwzOD09PW18fDQyPT09bXx8MzM9PT1tfHwxMjQ9PT1tfHw2Mj09PW18fDM5PT09bXx8MzQ9PT1tfHwzNz09PW18fDY0PT09bXx8OTY9PT1tKXJldHVybiExO2lmKCg2Mz09PW18fDQ1PT09bSkmJihjPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKzEpLG8oYyl8fG4mJmEoYykpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLHU9bD1lLnBvc2l0aW9uLHA9ITE7MCE9PW07KXtpZig1OD09PW0pe2lmKGM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSksbyhjKXx8biYmYShjKSlicmVha31lbHNlIGlmKDM1PT09bSl7aWYocz1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbi0xKSxvKHMpKWJyZWFrfWVsc2V7aWYoZS5wb3NpdGlvbj09PWUubGluZVN0YXJ0JiZiKGUpfHxuJiZhKG0pKWJyZWFrO2lmKGkobSkpe2lmKGY9ZS5saW5lLGQ9ZS5saW5lU3RhcnQsaD1lLmxpbmVJbmRlbnQsQShlLCExLC0xKSxlLmxpbmVJbmRlbnQ+PXQpe3A9ITAsbT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbik7Y29udGludWV9ZS5wb3NpdGlvbj1sLGUubGluZT1mLGUubGluZVN0YXJ0PWQsZS5saW5lSW5kZW50PWg7YnJlYWt9fXAmJihnKGUsdSxsLCExKSx3KGUsZS5saW5lLWYpLHU9bD1lLnBvc2l0aW9uLHA9ITEpLHIobSl8fChsPWUucG9zaXRpb24rMSksbT1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX1yZXR1cm4gZyhlLHUsbCwhMSksISFlLnJlc3VsdHx8KGUua2luZD15LGUucmVzdWx0PXgsITEpfWZ1bmN0aW9uIGsoZSx0KXt2YXIgbixyLG87aWYoMzkhPT0obj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLGUucG9zaXRpb24rKyxyPW89ZS5wb3NpdGlvbjswIT09KG49ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKTspaWYoMzk9PT1uKXtpZihnKGUscixlLnBvc2l0aW9uLCEwKSwzOSE9PShuPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pKSlyZXR1cm4hMDtyPWUucG9zaXRpb24sZS5wb3NpdGlvbisrLG89ZS5wb3NpdGlvbn1lbHNlIGkobik/KGcoZSxyLG8sITApLHcoZSxBKGUsITEsdCkpLHI9bz1lLnBvc2l0aW9uKTplLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyXCIpOihlLnBvc2l0aW9uKyssbz1lLnBvc2l0aW9uKTtoKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyXCIpfWZ1bmN0aW9uIGooZSx0KXt2YXIgbixyLG8sYSx1LGw7aWYoMzQhPT0obD1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihlLmtpbmQ9XCJzY2FsYXJcIixlLnJlc3VsdD1cIlwiLGUucG9zaXRpb24rKyxuPXI9ZS5wb3NpdGlvbjswIT09KGw9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKTspe2lmKDM0PT09bClyZXR1cm4gZyhlLG4sZS5wb3NpdGlvbiwhMCksZS5wb3NpdGlvbisrLCEwO2lmKDkyPT09bCl7aWYoZyhlLG4sZS5wb3NpdGlvbiwhMCksbD1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSxpKGwpKUEoZSwhMSx0KTtlbHNlIGlmKGw8MjU2JiZuZVtsXSllLnJlc3VsdCs9aWVbbF0sZS5wb3NpdGlvbisrO2Vsc2UgaWYoKHU9YyhsKSk+MCl7Zm9yKG89dSxhPTA7bz4wO28tLSkodT1zKGw9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpKT49MD9hPShhPDw0KSt1OmgoZSxcImV4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlclwiKTtlLnJlc3VsdCs9cChhKSxlLnBvc2l0aW9uKyt9ZWxzZSBoKGUsXCJ1bmtub3duIGVzY2FwZSBzZXF1ZW5jZVwiKTtuPXI9ZS5wb3NpdGlvbn1lbHNlIGkobCk/KGcoZSxuLHIsITApLHcoZSxBKGUsITEsdCkpLG49cj1lLnBvc2l0aW9uKTplLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyXCIpOihlLnBvc2l0aW9uKysscj1lLnBvc2l0aW9uKX1oKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyXCIpfWZ1bmN0aW9uIEkoZSx0KXt2YXIgbixpLHIsYSxzLGMsdSxsLHAsZixkPSEwLG09ZS50YWcsZz1lLmFuY2hvcix5PXt9O2lmKDkxPT09KGY9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSlyPTkzLGM9ITEsaT1bXTtlbHNle2lmKDEyMyE9PWYpcmV0dXJuITE7cj0xMjUsYz0hMCxpPXt9fWZvcihudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09aSksZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKTswIT09Zjspe2lmKEEoZSwhMCx0KSwoZj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpPT09cilyZXR1cm4gZS5wb3NpdGlvbisrLGUudGFnPW0sZS5hbmNob3I9ZyxlLmtpbmQ9Yz9cIm1hcHBpbmdcIjpcInNlcXVlbmNlXCIsZS5yZXN1bHQ9aSwhMDtkfHxoKGUsXCJtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllc1wiKSxsPXU9cD1udWxsLGE9cz0hMSw2Mz09PWYmJm8oZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkpJiYoYT1zPSEwLGUucG9zaXRpb24rKyxBKGUsITAsdCkpLG49ZS5saW5lLE0oZSx0LEssITEsITApLGw9ZS50YWcsdT1lLnJlc3VsdCxBKGUsITAsdCksZj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksIXMmJmUubGluZSE9PW58fDU4IT09Znx8KGE9ITAsZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSxBKGUsITAsdCksTShlLHQsSywhMSwhMCkscD1lLnJlc3VsdCksYz94KGUsaSx5LGwsdSxwKTphP2kucHVzaCh4KGUsbnVsbCx5LGwsdSxwKSk6aS5wdXNoKHUpLEEoZSwhMCx0KSw0ND09PShmPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKSk/KGQ9ITAsZj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6ZD0hMX1oKGUsXCJ1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvblwiKX1mdW5jdGlvbiBTKGUsdCl7dmFyIG4sbyxhLHMsYz1WLGw9ITEscD0hMSxmPXQsZD0wLG09ITE7aWYoMTI0PT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSlvPSExO2Vsc2V7aWYoNjIhPT1zKXJldHVybiExO289ITB9Zm9yKGUua2luZD1cInNjYWxhclwiLGUucmVzdWx0PVwiXCI7MCE9PXM7KWlmKDQzPT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpfHw0NT09PXMpVj09PWM/Yz00Mz09PXM/ejpaOmgoZSxcInJlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllclwiKTtlbHNle2lmKCEoKGE9dShzKSk+PTApKWJyZWFrOzA9PT1hP2goZSxcImJhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmVcIik6cD9oKGUsXCJyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllclwiKTooZj10K2EtMSxwPSEwKX1pZihyKHMpKXtkb3tzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKHIocykpO2lmKDM1PT09cylkb3tzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pfXdoaWxlKCFpKHMpJiYwIT09cyl9Zm9yKDswIT09czspe2Zvcih2KGUpLGUubGluZUluZGVudD0wLHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pOyghcHx8ZS5saW5lSW5kZW50PGYpJiYzMj09PXM7KWUubGluZUluZGVudCsrLHM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7aWYoIXAmJmUubGluZUluZGVudD5mJiYoZj1lLmxpbmVJbmRlbnQpLGkocykpZCsrO2Vsc2V7aWYoZS5saW5lSW5kZW50PGYpe2M9PT16P2UucmVzdWx0Kz1xLnJlcGVhdChcIlxcblwiLGw/MStkOmQpOmM9PT1WJiZsJiYoZS5yZXN1bHQrPVwiXFxuXCIpO2JyZWFrfWZvcihvP3Iocyk/KG09ITAsZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsbD8xK2Q6ZCkpOm0/KG09ITEsZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsZCsxKSk6MD09PWQ/bCYmKGUucmVzdWx0Kz1cIiBcIik6ZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsZCk6ZS5yZXN1bHQrPXEucmVwZWF0KFwiXFxuXCIsbD8xK2Q6ZCksbD0hMCxwPSEwLGQ9MCxuPWUucG9zaXRpb247IWkocykmJjAhPT1zOylzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2coZSxuLGUucG9zaXRpb24sITEpfX1yZXR1cm4hMH1mdW5jdGlvbiBPKGUsdCl7dmFyIG4saSxyLGE9ZS50YWcscz1lLmFuY2hvcixjPVtdLHU9ITE7Zm9yKG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1jKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTswIT09ciYmNDU9PT1yJiYoaT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbisxKSxvKGkpKTspaWYodT0hMCxlLnBvc2l0aW9uKyssQShlLCEwLC0xKSYmZS5saW5lSW5kZW50PD10KWMucHVzaChudWxsKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTtlbHNlIGlmKG49ZS5saW5lLE0oZSx0LEgsITEsITApLGMucHVzaChlLnJlc3VsdCksQShlLCEwLC0xKSxyPWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKSwoZS5saW5lPT09bnx8ZS5saW5lSW5kZW50PnQpJiYwIT09ciloKGUsXCJiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeVwiKTtlbHNlIGlmKGUubGluZUluZGVudDx0KWJyZWFrO3JldHVybiEhdSYmKGUudGFnPWEsZS5hbmNob3I9cyxlLmtpbmQ9XCJzZXF1ZW5jZVwiLGUucmVzdWx0PWMsITApfWZ1bmN0aW9uIEUoZSx0LG4pe3ZhciBpLGEscyxjLHUsbD1lLnRhZyxwPWUuYW5jaG9yLGY9e30sZD17fSxtPW51bGwsZz1udWxsLHk9bnVsbCx2PSExLGI9ITE7Zm9yKG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1mKSx1PWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTswIT09dTspe2lmKGk9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkscz1lLmxpbmUsYz1lLnBvc2l0aW9uLDYzIT09dSYmNTghPT11fHwhbyhpKSl7aWYoIU0oZSxuLCQsITEsITApKWJyZWFrO2lmKGUubGluZT09PXMpe2Zvcih1PWUuaW5wdXQuY2hhckNvZGVBdChlLnBvc2l0aW9uKTtyKHUpOyl1PWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKDU4PT09dSlvKHU9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpfHxoKGUsXCJhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmdcIiksdiYmKHgoZSxmLGQsbSxnLG51bGwpLG09Zz15PW51bGwpLGI9ITAsdj0hMSxhPSExLG09ZS50YWcsZz1lLnJlc3VsdDtlbHNle2lmKCFiKXJldHVybiBlLnRhZz1sLGUuYW5jaG9yPXAsITA7aChlLFwiY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWRcIil9fWVsc2V7aWYoIWIpcmV0dXJuIGUudGFnPWwsZS5hbmNob3I9cCwhMDtoKGUsXCJjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXlcIil9fWVsc2UgNjM9PT11Pyh2JiYoeChlLGYsZCxtLGcsbnVsbCksbT1nPXk9bnVsbCksYj0hMCx2PSEwLGE9ITApOnY/KHY9ITEsYT0hMCk6aChlLFwiaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkOyBvciBmb2xsb3dlZCBieSBhIG5vbi10YWJ1bGF0ZWQgZW1wdHkgbGluZVwiKSxlLnBvc2l0aW9uKz0xLHU9aTtpZigoZS5saW5lPT09c3x8ZS5saW5lSW5kZW50PnQpJiYoTShlLHQsRywhMCxhKSYmKHY/Zz1lLnJlc3VsdDp5PWUucmVzdWx0KSx2fHwoeChlLGYsZCxtLGcseSxzLGMpLG09Zz15PW51bGwpLEEoZSwhMCwtMSksdT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpLGUubGluZUluZGVudD50JiYwIT09dSloKGUsXCJiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5XCIpO2Vsc2UgaWYoZS5saW5lSW5kZW50PHQpYnJlYWt9cmV0dXJuIHYmJngoZSxmLGQsbSxnLG51bGwpLGImJihlLnRhZz1sLGUuYW5jaG9yPXAsZS5raW5kPVwibWFwcGluZ1wiLGUucmVzdWx0PWYpLGJ9ZnVuY3Rpb24gRihlKXt2YXIgdCxuLGkscixhPSExLHM9ITE7aWYoMzMhPT0ocj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2lmKG51bGwhPT1lLnRhZyYmaChlLFwiZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHlcIiksNjA9PT0ocj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk/KGE9ITAscj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6MzM9PT1yPyhzPSEwLG49XCIhIVwiLHI9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbikpOm49XCIhXCIsdD1lLnBvc2l0aW9uLGEpe2Rve3I9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbil9d2hpbGUoMCE9PXImJjYyIT09cik7ZS5wb3NpdGlvbjxlLmxlbmd0aD8oaT1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbikscj1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKSk6aChlLFwidW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWdcIil9ZWxzZXtmb3IoOzAhPT1yJiYhbyhyKTspMzM9PT1yJiYocz9oKGUsXCJ0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzXCIpOihuPWUuaW5wdXQuc2xpY2UodC0xLGUucG9zaXRpb24rMSksZWUudGVzdChuKXx8aChlLFwibmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnNcIikscz0hMCx0PWUucG9zaXRpb24rMSkpLHI9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7aT1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbiksWC50ZXN0KGkpJiZoKGUsXCJ0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnNcIil9cmV0dXJuIGkmJiF0ZS50ZXN0KGkpJiZoKGUsXCJ0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6IFwiK2kpLGE/ZS50YWc9aTpCLmNhbGwoZS50YWdNYXAsbik/ZS50YWc9ZS50YWdNYXBbbl0raTpcIiFcIj09PW4/ZS50YWc9XCIhXCIraTpcIiEhXCI9PT1uP2UudGFnPVwidGFnOnlhbWwub3JnLDIwMDI6XCIraTpoKGUsJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicrbisnXCInKSwhMH1mdW5jdGlvbiBfKGUpe3ZhciB0LG47aWYoMzghPT0obj1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihudWxsIT09ZS5hbmNob3ImJmgoZSxcImR1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eVwiKSxuPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09biYmIW8obikmJiFhKG4pOyluPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO3JldHVybiBlLnBvc2l0aW9uPT09dCYmaChlLFwibmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlclwiKSxlLmFuY2hvcj1lLmlucHV0LnNsaWNlKHQsZS5wb3NpdGlvbiksITB9ZnVuY3Rpb24gTihlKXt2YXIgdCxuLGk7aWYoNDIhPT0oaT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikpKXJldHVybiExO2ZvcihpPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09aSYmIW8oaSkmJiFhKGkpOylpPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO3JldHVybiBlLnBvc2l0aW9uPT09dCYmaChlLFwibmFtZSBvZiBhbiBhbGlhcyBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyXCIpLG49ZS5pbnB1dC5zbGljZSh0LGUucG9zaXRpb24pLGUuYW5jaG9yTWFwLmhhc093blByb3BlcnR5KG4pfHxoKGUsJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicrbisnXCInKSxlLnJlc3VsdD1lLmFuY2hvck1hcFtuXSxBKGUsITAsLTEpLCEwfWZ1bmN0aW9uIE0oZSx0LG4saSxyKXt2YXIgbyxhLHMsYyx1LGwscCxmLGQ9MSxtPSExLGc9ITE7aWYobnVsbCE9PWUubGlzdGVuZXImJmUubGlzdGVuZXIoXCJvcGVuXCIsZSksZS50YWc9bnVsbCxlLmFuY2hvcj1udWxsLGUua2luZD1udWxsLGUucmVzdWx0PW51bGwsbz1hPXM9Rz09PW58fEg9PT1uLGkmJkEoZSwhMCwtMSkmJihtPSEwLGUubGluZUluZGVudD50P2Q9MTplLmxpbmVJbmRlbnQ9PT10P2Q9MDplLmxpbmVJbmRlbnQ8dCYmKGQ9LTEpKSwxPT09ZClmb3IoO0YoZSl8fF8oZSk7KUEoZSwhMCwtMSk/KG09ITAscz1vLGUubGluZUluZGVudD50P2Q9MTplLmxpbmVJbmRlbnQ9PT10P2Q9MDplLmxpbmVJbmRlbnQ8dCYmKGQ9LTEpKTpzPSExO2lmKHMmJihzPW18fHIpLDEhPT1kJiZHIT09bnx8KHA9Sz09PW58fCQ9PT1uP3Q6dCsxLGY9ZS5wb3NpdGlvbi1lLmxpbmVTdGFydCwxPT09ZD9zJiYoTyhlLGYpfHxFKGUsZixwKSl8fEkoZSxwKT9nPSEwOihhJiZTKGUscCl8fGsoZSxwKXx8aihlLHApP2c9ITA6TihlKT8oZz0hMCxudWxsPT09ZS50YWcmJm51bGw9PT1lLmFuY2hvcnx8aChlLFwiYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXNcIikpOkMoZSxwLEs9PT1uKSYmKGc9ITAsbnVsbD09PWUudGFnJiYoZS50YWc9XCI/XCIpKSxudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09ZS5yZXN1bHQpKTowPT09ZCYmKGc9cyYmTyhlLGYpKSksbnVsbCE9PWUudGFnJiZcIiFcIiE9PWUudGFnKWlmKFwiP1wiPT09ZS50YWcpe2ZvcihjPTAsdT1lLmltcGxpY2l0VHlwZXMubGVuZ3RoO2M8dTtjKz0xKWlmKChsPWUuaW1wbGljaXRUeXBlc1tjXSkucmVzb2x2ZShlLnJlc3VsdCkpe2UucmVzdWx0PWwuY29uc3RydWN0KGUucmVzdWx0KSxlLnRhZz1sLnRhZyxudWxsIT09ZS5hbmNob3ImJihlLmFuY2hvck1hcFtlLmFuY2hvcl09ZS5yZXN1bHQpO2JyZWFrfX1lbHNlIEIuY2FsbChlLnR5cGVNYXBbZS5raW5kfHxcImZhbGxiYWNrXCJdLGUudGFnKT8obD1lLnR5cGVNYXBbZS5raW5kfHxcImZhbGxiYWNrXCJdW2UudGFnXSxudWxsIT09ZS5yZXN1bHQmJmwua2luZCE9PWUua2luZCYmaChlLFwidW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITxcIitlLnRhZysnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicrbC5raW5kKydcIiwgbm90IFwiJytlLmtpbmQrJ1wiJyksbC5yZXNvbHZlKGUucmVzdWx0KT8oZS5yZXN1bHQ9bC5jb25zdHJ1Y3QoZS5yZXN1bHQpLG51bGwhPT1lLmFuY2hvciYmKGUuYW5jaG9yTWFwW2UuYW5jaG9yXT1lLnJlc3VsdCkpOmgoZSxcImNhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8XCIrZS50YWcrXCI+IGV4cGxpY2l0IHRhZ1wiKSk6aChlLFwidW5rbm93biB0YWcgITxcIitlLnRhZytcIj5cIik7cmV0dXJuIG51bGwhPT1lLmxpc3RlbmVyJiZlLmxpc3RlbmVyKFwiY2xvc2VcIixlKSxudWxsIT09ZS50YWd8fG51bGwhPT1lLmFuY2hvcnx8Z31mdW5jdGlvbiBUKGUpe3ZhciB0LG4sYSxzLGM9ZS5wb3NpdGlvbix1PSExO2ZvcihlLnZlcnNpb249bnVsbCxlLmNoZWNrTGluZUJyZWFrcz1lLmxlZ2FjeSxlLnRhZ01hcD17fSxlLmFuY2hvck1hcD17fTswIT09KHM9ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24pKSYmKEEoZSwhMCwtMSkscz1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbiksIShlLmxpbmVJbmRlbnQ+MHx8MzchPT1zKSk7KXtmb3IodT0hMCxzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pLHQ9ZS5wb3NpdGlvbjswIT09cyYmIW8ocyk7KXM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7Zm9yKGE9W10sKG49ZS5pbnB1dC5zbGljZSh0LGUucG9zaXRpb24pKS5sZW5ndGg8MSYmaChlLFwiZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoXCIpOzAhPT1zOyl7Zm9yKDtyKHMpOylzPWUuaW5wdXQuY2hhckNvZGVBdCgrK2UucG9zaXRpb24pO2lmKDM1PT09cyl7ZG97cz1lLmlucHV0LmNoYXJDb2RlQXQoKytlLnBvc2l0aW9uKX13aGlsZSgwIT09cyYmIWkocykpO2JyZWFrfWlmKGkocykpYnJlYWs7Zm9yKHQ9ZS5wb3NpdGlvbjswIT09cyYmIW8ocyk7KXM9ZS5pbnB1dC5jaGFyQ29kZUF0KCsrZS5wb3NpdGlvbik7YS5wdXNoKGUuaW5wdXQuc2xpY2UodCxlLnBvc2l0aW9uKSl9MCE9PXMmJnYoZSksQi5jYWxsKG9lLG4pP29lW25dKGUsbixhKTptKGUsJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJytuKydcIicpfUEoZSwhMCwtMSksMD09PWUubGluZUluZGVudCYmNDU9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJjQ1PT09ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMSkmJjQ1PT09ZS5pbnB1dC5jaGFyQ29kZUF0KGUucG9zaXRpb24rMik/KGUucG9zaXRpb24rPTMsQShlLCEwLC0xKSk6dSYmaChlLFwiZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZFwiKSxNKGUsZS5saW5lSW5kZW50LTEsRywhMSwhMCksQShlLCEwLC0xKSxlLmNoZWNrTGluZUJyZWFrcyYmUS50ZXN0KGUuaW5wdXQuc2xpY2UoYyxlLnBvc2l0aW9uKSkmJm0oZSxcIm5vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudFwiKSxlLmRvY3VtZW50cy5wdXNoKGUucmVzdWx0KSxlLnBvc2l0aW9uPT09ZS5saW5lU3RhcnQmJmIoZSk/NDY9PT1lLmlucHV0LmNoYXJDb2RlQXQoZS5wb3NpdGlvbikmJihlLnBvc2l0aW9uKz0zLEEoZSwhMCwtMSkpOmUucG9zaXRpb248ZS5sZW5ndGgtMSYmaChlLFwiZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWRcIil9ZnVuY3Rpb24gTChlLHQpe2U9U3RyaW5nKGUpLHQ9dHx8e30sMCE9PWUubGVuZ3RoJiYoMTAhPT1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSkmJjEzIT09ZS5jaGFyQ29kZUF0KGUubGVuZ3RoLTEpJiYoZSs9XCJcXG5cIiksNjUyNzk9PT1lLmNoYXJDb2RlQXQoMCkmJihlPWUuc2xpY2UoMSkpKTt2YXIgbj1uZXcgZihlLHQpO2ZvcihuLmlucHV0Kz1cIlxcMFwiOzMyPT09bi5pbnB1dC5jaGFyQ29kZUF0KG4ucG9zaXRpb24pOyluLmxpbmVJbmRlbnQrPTEsbi5wb3NpdGlvbis9MTtmb3IoO24ucG9zaXRpb248bi5sZW5ndGgtMTspVChuKTtyZXR1cm4gbi5kb2N1bWVudHN9ZnVuY3Rpb24gRChlLHQsbil7dmFyIGkscixvPUwoZSxuKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBvO2ZvcihpPTAscj1vLmxlbmd0aDtpPHI7aSs9MSl0KG9baV0pfWZ1bmN0aW9uIFUoZSx0KXt2YXIgbj1MKGUsdCk7aWYoMCE9PW4ubGVuZ3RoKXtpZigxPT09bi5sZW5ndGgpcmV0dXJuIG5bMF07dGhyb3cgbmV3IFkoXCJleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZVwiKX19Zm9yKHZhciBxPWUoXCIuL2NvbW1vblwiKSxZPWUoXCIuL2V4Y2VwdGlvblwiKSxSPWUoXCIuL21hcmtcIiksUD1lKFwiLi9zY2hlbWEvZGVmYXVsdF9zYWZlXCIpLFc9ZShcIi4vc2NoZW1hL2RlZmF1bHRfZnVsbFwiKSxCPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksSz0xLCQ9MixIPTMsRz00LFY9MSxaPTIsej0zLEo9L1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vLFE9L1tcXHg4NVxcdTIwMjhcXHUyMDI5XS8sWD0vWyxcXFtcXF1cXHtcXH1dLyxlZT0vXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pLHRlPS9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2ksbmU9bmV3IEFycmF5KDI1NiksaWU9bmV3IEFycmF5KDI1NikscmU9MDtyZTwyNTY7cmUrKyluZVtyZV09bChyZSk/MTowLGllW3JlXT1sKHJlKTt2YXIgb2U9e1lBTUw6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpLHIsbztudWxsIT09ZS52ZXJzaW9uJiZoKGUsXCJkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmVcIiksMSE9PW4ubGVuZ3RoJiZoKGUsXCJZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIpLG51bGw9PT0oaT0vXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKG5bMF0pKSYmaChlLFwiaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmVcIikscj1wYXJzZUludChpWzFdLDEwKSxvPXBhcnNlSW50KGlbMl0sMTApLDEhPT1yJiZoKGUsXCJ1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudFwiKSxlLnZlcnNpb249blswXSxlLmNoZWNrTGluZUJyZWFrcz1vPDIsMSE9PW8mJjIhPT1vJiZtKGUsXCJ1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50XCIpfSxUQUc6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpLHI7MiE9PW4ubGVuZ3RoJiZoKGUsXCJUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzXCIpLGk9blswXSxyPW5bMV0sZWUudGVzdChpKXx8aChlLFwiaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmVcIiksQi5jYWxsKGUudGFnTWFwLGkpJiZoKGUsJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJytpKydcIiB0YWcgaGFuZGxlJyksdGUudGVzdChyKXx8aChlLFwiaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlXCIpLGUudGFnTWFwW2ldPXJ9fTt0LmV4cG9ydHMubG9hZEFsbD1ELHQuZXhwb3J0cy5sb2FkPVUsdC5leHBvcnRzLnNhZmVMb2FkQWxsPWZ1bmN0aW9uKGUsdCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXJldHVybiBEKGUscS5leHRlbmQoe3NjaGVtYTpQfSxuKSk7RChlLHQscS5leHRlbmQoe3NjaGVtYTpQfSxuKSl9LHQuZXhwb3J0cy5zYWZlTG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBVKGUscS5leHRlbmQoe3NjaGVtYTpQfSx0KSl9fSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL21hcmtcIjo2LFwiLi9zY2hlbWEvZGVmYXVsdF9mdWxsXCI6OSxcIi4vc2NoZW1hL2RlZmF1bHRfc2FmZVwiOjEwfV0sNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSx0LG4saSxyKXt0aGlzLm5hbWU9ZSx0aGlzLmJ1ZmZlcj10LHRoaXMucG9zaXRpb249bix0aGlzLmxpbmU9aSx0aGlzLmNvbHVtbj1yfXZhciByPWUoXCIuL2NvbW1vblwiKTtpLnByb3RvdHlwZS5nZXRTbmlwcGV0PWZ1bmN0aW9uKGUsdCl7dmFyIG4saSxvLGEscztpZighdGhpcy5idWZmZXIpcmV0dXJuIG51bGw7Zm9yKGU9ZXx8NCx0PXR8fDc1LG49XCJcIixpPXRoaXMucG9zaXRpb247aT4wJiYtMT09PVwiXFwwXFxyXFxuwoVcXHUyMDI4XFx1MjAyOVwiLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGktMSkpOylpZihpLT0xLHRoaXMucG9zaXRpb24taT50LzItMSl7bj1cIiAuLi4gXCIsaSs9NTticmVha31mb3Iobz1cIlwiLGE9dGhpcy5wb3NpdGlvbjthPHRoaXMuYnVmZmVyLmxlbmd0aCYmLTE9PT1cIlxcMFxcclxcbsKFXFx1MjAyOFxcdTIwMjlcIi5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChhKSk7KWlmKChhKz0xKS10aGlzLnBvc2l0aW9uPnQvMi0xKXtvPVwiIC4uLiBcIixhLT01O2JyZWFrfXJldHVybiBzPXRoaXMuYnVmZmVyLnNsaWNlKGksYSksci5yZXBlYXQoXCIgXCIsZSkrbitzK28rXCJcXG5cIityLnJlcGVhdChcIiBcIixlK3RoaXMucG9zaXRpb24taStuLmxlbmd0aCkrXCJeXCJ9LGkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0LG49XCJcIjtyZXR1cm4gdGhpcy5uYW1lJiYobis9J2luIFwiJyt0aGlzLm5hbWUrJ1wiICcpLG4rPVwiYXQgbGluZSBcIisodGhpcy5saW5lKzEpK1wiLCBjb2x1bW4gXCIrKHRoaXMuY29sdW1uKzEpLGV8fCh0PXRoaXMuZ2V0U25pcHBldCgpKSYmKG4rPVwiOlxcblwiK3QpLG59LHQuZXhwb3J0cz1pfSx7XCIuL2NvbW1vblwiOjJ9XSw3OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlLHQsbil7dmFyIHI9W107cmV0dXJuIGUuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe249aShlLHQsbil9KSxlW3RdLmZvckVhY2goZnVuY3Rpb24oZSl7bi5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7dC50YWc9PT1lLnRhZyYmdC5raW5kPT09ZS5raW5kJiZyLnB1c2gobil9KSxuLnB1c2goZSl9KSxuLmZpbHRlcihmdW5jdGlvbihlLHQpe3JldHVybi0xPT09ci5pbmRleE9mKHQpfSl9ZnVuY3Rpb24gcigpe3ZhciBlLHQsbj17c2NhbGFyOnt9LHNlcXVlbmNlOnt9LG1hcHBpbmc6e30sZmFsbGJhY2s6e319O2ZvcihlPTAsdD1hcmd1bWVudHMubGVuZ3RoO2U8dDtlKz0xKWFyZ3VtZW50c1tlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe25bZS5raW5kXVtlLnRhZ109bi5mYWxsYmFja1tlLnRhZ109ZX0pO3JldHVybiBufWZ1bmN0aW9uIG8oZSl7dGhpcy5pbmNsdWRlPWUuaW5jbHVkZXx8W10sdGhpcy5pbXBsaWNpdD1lLmltcGxpY2l0fHxbXSx0aGlzLmV4cGxpY2l0PWUuZXhwbGljaXR8fFtdLHRoaXMuaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbihlKXtpZihlLmxvYWRLaW5kJiZcInNjYWxhclwiIT09ZS5sb2FkS2luZCl0aHJvdyBuZXcgcyhcIlRoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKX0pLHRoaXMuY29tcGlsZWRJbXBsaWNpdD1pKHRoaXMsXCJpbXBsaWNpdFwiLFtdKSx0aGlzLmNvbXBpbGVkRXhwbGljaXQ9aSh0aGlzLFwiZXhwbGljaXRcIixbXSksdGhpcy5jb21waWxlZFR5cGVNYXA9cih0aGlzLmNvbXBpbGVkSW1wbGljaXQsdGhpcy5jb21waWxlZEV4cGxpY2l0KX12YXIgYT1lKFwiLi9jb21tb25cIikscz1lKFwiLi9leGNlcHRpb25cIiksYz1lKFwiLi90eXBlXCIpO28uREVGQVVMVD1udWxsLG8uY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIGUsdDtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAxOmU9by5ERUZBVUxULHQ9YXJndW1lbnRzWzBdO2JyZWFrO2Nhc2UgMjplPWFyZ3VtZW50c1swXSx0PWFyZ3VtZW50c1sxXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBzKFwiV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvblwiKX1pZihlPWEudG9BcnJheShlKSx0PWEudG9BcnJheSh0KSwhZS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIG99KSl0aHJvdyBuZXcgcyhcIlNwZWNpZmllZCBsaXN0IG9mIHN1cGVyIHNjaGVtYXMgKG9yIGEgc2luZ2xlIFNjaGVtYSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVNjaGVtYSBvYmplY3QuXCIpO2lmKCF0LmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgY30pKXRocm93IG5ldyBzKFwiU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LlwiKTtyZXR1cm4gbmV3IG8oe2luY2x1ZGU6ZSxleHBsaWNpdDp0fSl9LHQuZXhwb3J0cz1vfSx7XCIuL2NvbW1vblwiOjIsXCIuL2V4Y2VwdGlvblwiOjQsXCIuL3R5cGVcIjoxM31dLDg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vc2NoZW1hXCIpO3QuZXhwb3J0cz1uZXcgaSh7aW5jbHVkZTpbZShcIi4vanNvblwiKV19KX0se1wiLi4vc2NoZW1hXCI6NyxcIi4vanNvblwiOjEyfV0sOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPWkuREVGQVVMVD1uZXcgaSh7aW5jbHVkZTpbZShcIi4vZGVmYXVsdF9zYWZlXCIpXSxleHBsaWNpdDpbZShcIi4uL3R5cGUvanMvdW5kZWZpbmVkXCIpLGUoXCIuLi90eXBlL2pzL3JlZ2V4cFwiKSxlKFwiLi4vdHlwZS9qcy9mdW5jdGlvblwiKV19KX0se1wiLi4vc2NoZW1hXCI6NyxcIi4uL3R5cGUvanMvZnVuY3Rpb25cIjoxOCxcIi4uL3R5cGUvanMvcmVnZXhwXCI6MTksXCIuLi90eXBlL2pzL3VuZGVmaW5lZFwiOjIwLFwiLi9kZWZhdWx0X3NhZmVcIjoxMH1dLDEwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3NjaGVtYVwiKTt0LmV4cG9ydHM9bmV3IGkoe2luY2x1ZGU6W2UoXCIuL2NvcmVcIildLGltcGxpY2l0OltlKFwiLi4vdHlwZS90aW1lc3RhbXBcIiksZShcIi4uL3R5cGUvbWVyZ2VcIildLGV4cGxpY2l0OltlKFwiLi4vdHlwZS9iaW5hcnlcIiksZShcIi4uL3R5cGUvb21hcFwiKSxlKFwiLi4vdHlwZS9wYWlyc1wiKSxlKFwiLi4vdHlwZS9zZXRcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL2JpbmFyeVwiOjE0LFwiLi4vdHlwZS9tZXJnZVwiOjIyLFwiLi4vdHlwZS9vbWFwXCI6MjQsXCIuLi90eXBlL3BhaXJzXCI6MjUsXCIuLi90eXBlL3NldFwiOjI3LFwiLi4vdHlwZS90aW1lc3RhbXBcIjoyOSxcIi4vY29yZVwiOjh9XSwxMTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPW5ldyBpKHtleHBsaWNpdDpbZShcIi4uL3R5cGUvc3RyXCIpLGUoXCIuLi90eXBlL3NlcVwiKSxlKFwiLi4vdHlwZS9tYXBcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL21hcFwiOjIxLFwiLi4vdHlwZS9zZXFcIjoyNixcIi4uL3R5cGUvc3RyXCI6Mjh9XSwxMjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi9zY2hlbWFcIik7dC5leHBvcnRzPW5ldyBpKHtpbmNsdWRlOltlKFwiLi9mYWlsc2FmZVwiKV0saW1wbGljaXQ6W2UoXCIuLi90eXBlL251bGxcIiksZShcIi4uL3R5cGUvYm9vbFwiKSxlKFwiLi4vdHlwZS9pbnRcIiksZShcIi4uL3R5cGUvZmxvYXRcIildfSl9LHtcIi4uL3NjaGVtYVwiOjcsXCIuLi90eXBlL2Jvb2xcIjoxNSxcIi4uL3R5cGUvZmxvYXRcIjoxNixcIi4uL3R5cGUvaW50XCI6MTcsXCIuLi90eXBlL251bGxcIjoyMyxcIi4vZmFpbHNhZmVcIjoxMX1dLDEzOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaShlKXt2YXIgdD17fTtyZXR1cm4gbnVsbCE9PWUmJk9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24obil7ZVtuXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbU3RyaW5nKGUpXT1ufSl9KSx0fXZhciByPWUoXCIuL2V4Y2VwdGlvblwiKSxvPVtcImtpbmRcIixcInJlc29sdmVcIixcImNvbnN0cnVjdFwiLFwiaW5zdGFuY2VPZlwiLFwicHJlZGljYXRlXCIsXCJyZXByZXNlbnRcIixcImRlZmF1bHRTdHlsZVwiLFwic3R5bGVBbGlhc2VzXCJdLGE9W1wic2NhbGFyXCIsXCJzZXF1ZW5jZVwiLFwibWFwcGluZ1wiXTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZih0PXR8fHt9LE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24odCl7aWYoLTE9PT1vLmluZGV4T2YodCkpdGhyb3cgbmV3IHIoJ1Vua25vd24gb3B0aW9uIFwiJyt0KydcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicrZSsnXCIgWUFNTCB0eXBlLicpfSksdGhpcy50YWc9ZSx0aGlzLmtpbmQ9dC5raW5kfHxudWxsLHRoaXMucmVzb2x2ZT10LnJlc29sdmV8fGZ1bmN0aW9uKCl7cmV0dXJuITB9LHRoaXMuY29uc3RydWN0PXQuY29uc3RydWN0fHxmdW5jdGlvbihlKXtyZXR1cm4gZX0sdGhpcy5pbnN0YW5jZU9mPXQuaW5zdGFuY2VPZnx8bnVsbCx0aGlzLnByZWRpY2F0ZT10LnByZWRpY2F0ZXx8bnVsbCx0aGlzLnJlcHJlc2VudD10LnJlcHJlc2VudHx8bnVsbCx0aGlzLmRlZmF1bHRTdHlsZT10LmRlZmF1bHRTdHlsZXx8bnVsbCx0aGlzLnN0eWxlQWxpYXNlcz1pKHQuc3R5bGVBbGlhc2VzfHxudWxsKSwtMT09PWEuaW5kZXhPZih0aGlzLmtpbmQpKXRocm93IG5ldyByKCdVbmtub3duIGtpbmQgXCInK3RoaXMua2luZCsnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicrZSsnXCIgWUFNTCB0eXBlLicpfX0se1wiLi9leGNlcHRpb25cIjo0fV0sMTQ6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaTt0cnl7aT1lKFwiYnVmZmVyXCIpLkJ1ZmZlcn1jYXRjaChlKXt9dmFyIHI9ZShcIi4uL3R5cGVcIiksbz1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyXCI7dC5leHBvcnRzPW5ldyByKFwidGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5XCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiExO3ZhciB0LG4saT0wLHI9ZS5sZW5ndGgsYT1vO2ZvcihuPTA7bjxyO24rKylpZighKCh0PWEuaW5kZXhPZihlLmNoYXJBdChuKSkpPjY0KSl7aWYodDwwKXJldHVybiExO2krPTZ9cmV0dXJuIGklOD09MH0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lLnJlcGxhY2UoL1tcXHJcXG49XS9nLFwiXCIpLGE9ci5sZW5ndGgscz1vLGM9MCx1PVtdO2Zvcih0PTA7dDxhO3QrKyl0JTQ9PTAmJnQmJih1LnB1c2goYz4+MTYmMjU1KSx1LnB1c2goYz4+OCYyNTUpLHUucHVzaCgyNTUmYykpLGM9Yzw8NnxzLmluZGV4T2Yoci5jaGFyQXQodCkpO3JldHVybiAwPT0obj1hJTQqNik/KHUucHVzaChjPj4xNiYyNTUpLHUucHVzaChjPj44JjI1NSksdS5wdXNoKDI1NSZjKSk6MTg9PT1uPyh1LnB1c2goYz4+MTAmMjU1KSx1LnB1c2goYz4+MiYyNTUpKToxMj09PW4mJnUucHVzaChjPj40JjI1NSksaT9pLmZyb20/aS5mcm9tKHUpOm5ldyBpKHUpOnV9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm4gaSYmaS5pc0J1ZmZlcihlKX0scmVwcmVzZW50OmZ1bmN0aW9uKGUpe3ZhciB0LG4saT1cIlwiLHI9MCxhPWUubGVuZ3RoLHM9bztmb3IodD0wO3Q8YTt0KyspdCUzPT0wJiZ0JiYoaSs9c1tyPj4xOCY2M10saSs9c1tyPj4xMiY2M10saSs9c1tyPj42JjYzXSxpKz1zWzYzJnJdKSxyPShyPDw4KStlW3RdO3JldHVybiAwPT0obj1hJTMpPyhpKz1zW3I+PjE4JjYzXSxpKz1zW3I+PjEyJjYzXSxpKz1zW3I+PjYmNjNdLGkrPXNbNjMmcl0pOjI9PT1uPyhpKz1zW3I+PjEwJjYzXSxpKz1zW3I+PjQmNjNdLGkrPXNbcjw8MiY2M10saSs9c1s2NF0pOjE9PT1uJiYoaSs9c1tyPj4yJjYzXSxpKz1zW3I8PDQmNjNdLGkrPXNbNjRdLGkrPXNbNjRdKSxpfX0pfSx7XCIuLi90eXBlXCI6MTN9XSwxNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOmJvb2xcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITE7dmFyIHQ9ZS5sZW5ndGg7cmV0dXJuIDQ9PT10JiYoXCJ0cnVlXCI9PT1lfHxcIlRydWVcIj09PWV8fFwiVFJVRVwiPT09ZSl8fDU9PT10JiYoXCJmYWxzZVwiPT09ZXx8XCJGYWxzZVwiPT09ZXx8XCJGQUxTRVwiPT09ZSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm5cInRydWVcIj09PWV8fFwiVHJ1ZVwiPT09ZXx8XCJUUlVFXCI9PT1lfSxwcmVkaWNhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEJvb2xlYW5dXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDp7bG93ZXJjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1widHJ1ZVwiOlwiZmFsc2VcIn0sdXBwZXJjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1wiVFJVRVwiOlwiRkFMU0VcIn0sY2FtZWxjYXNlOmZ1bmN0aW9uKGUpe3JldHVybiBlP1wiVHJ1ZVwiOlwiRmFsc2VcIn19LGRlZmF1bHRTdHlsZTpcImxvd2VyY2FzZVwifSl9LHtcIi4uL3R5cGVcIjoxM31dLDE2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL2NvbW1vblwiKSxyPWUoXCIuLi90eXBlXCIpLG89bmV3IFJlZ0V4cChcIl4oPzpbLStdPyg/OjB8WzEtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT98XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT98Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKnxbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpfFxcXFwuKD86bmFufE5hTnxOQU4pKSRcIiksYT0vXlstK10/WzAtOV0rZS87dC5leHBvcnRzPW5ldyByKFwidGFnOnlhbWwub3JnLDIwMDI6ZmxvYXRcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1lJiYhKCFvLnRlc3QoZSl8fFwiX1wiPT09ZVtlLmxlbmd0aC0xXSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdCxuLGkscjtyZXR1cm4gdD1lLnJlcGxhY2UoL18vZyxcIlwiKS50b0xvd2VyQ2FzZSgpLG49XCItXCI9PT10WzBdPy0xOjEscj1bXSxcIistXCIuaW5kZXhPZih0WzBdKT49MCYmKHQ9dC5zbGljZSgxKSksXCIuaW5mXCI9PT10PzE9PT1uP051bWJlci5QT1NJVElWRV9JTkZJTklUWTpOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6XCIubmFuXCI9PT10P05hTjp0LmluZGV4T2YoXCI6XCIpPj0wPyh0LnNwbGl0KFwiOlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3IudW5zaGlmdChwYXJzZUZsb2F0KGUsMTApKX0pLHQ9MCxpPTEsci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QrPWUqaSxpKj02MH0pLG4qdCk6bipwYXJzZUZsb2F0KHQsMTApfSxwcmVkaWNhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IE51bWJlcl1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSYmKGUlMSE9MHx8aS5pc05lZ2F0aXZlWmVybyhlKSl9LHJlcHJlc2VudDpmdW5jdGlvbihlLHQpe3ZhciBuO2lmKGlzTmFOKGUpKXN3aXRjaCh0KXtjYXNlXCJsb3dlcmNhc2VcIjpyZXR1cm5cIi5uYW5cIjtjYXNlXCJ1cHBlcmNhc2VcIjpyZXR1cm5cIi5OQU5cIjtjYXNlXCJjYW1lbGNhc2VcIjpyZXR1cm5cIi5OYU5cIn1lbHNlIGlmKE51bWJlci5QT1NJVElWRV9JTkZJTklUWT09PWUpc3dpdGNoKHQpe2Nhc2VcImxvd2VyY2FzZVwiOnJldHVyblwiLmluZlwiO2Nhc2VcInVwcGVyY2FzZVwiOnJldHVyblwiLklORlwiO2Nhc2VcImNhbWVsY2FzZVwiOnJldHVyblwiLkluZlwifWVsc2UgaWYoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPT09ZSlzd2l0Y2godCl7Y2FzZVwibG93ZXJjYXNlXCI6cmV0dXJuXCItLmluZlwiO2Nhc2VcInVwcGVyY2FzZVwiOnJldHVyblwiLS5JTkZcIjtjYXNlXCJjYW1lbGNhc2VcIjpyZXR1cm5cIi0uSW5mXCJ9ZWxzZSBpZihpLmlzTmVnYXRpdmVaZXJvKGUpKXJldHVyblwiLTAuMFwiO3JldHVybiBuPWUudG9TdHJpbmcoMTApLGEudGVzdChuKT9uLnJlcGxhY2UoXCJlXCIsXCIuZVwiKTpufSxkZWZhdWx0U3R5bGU6XCJsb3dlcmNhc2VcIn0pfSx7XCIuLi9jb21tb25cIjoyLFwiLi4vdHlwZVwiOjEzfV0sMTc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiA0ODw9ZSYmZTw9NTd8fDY1PD1lJiZlPD03MHx8OTc8PWUmJmU8PTEwMn1mdW5jdGlvbiByKGUpe3JldHVybiA0ODw9ZSYmZTw9NTV9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gNDg8PWUmJmU8PTU3fXZhciBhPWUoXCIuLi9jb21tb25cIikscz1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IHMoXCJ0YWc6eWFtbC5vcmcsMjAwMjppbnRcIix7a2luZDpcInNjYWxhclwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITE7dmFyIHQsbj1lLmxlbmd0aCxhPTAscz0hMTtpZighbilyZXR1cm4hMTtpZihcIi1cIiE9PSh0PWVbYV0pJiZcIitcIiE9PXR8fCh0PWVbKythXSksXCIwXCI9PT10KXtpZihhKzE9PT1uKXJldHVybiEwO2lmKFwiYlwiPT09KHQ9ZVsrK2FdKSl7Zm9yKGErKzthPG47YSsrKWlmKFwiX1wiIT09KHQ9ZVthXSkpe2lmKFwiMFwiIT09dCYmXCIxXCIhPT10KXJldHVybiExO3M9ITB9cmV0dXJuIHMmJlwiX1wiIT09dH1pZihcInhcIj09PXQpe2ZvcihhKys7YTxuO2ErKylpZihcIl9cIiE9PSh0PWVbYV0pKXtpZighaShlLmNoYXJDb2RlQXQoYSkpKXJldHVybiExO3M9ITB9cmV0dXJuIHMmJlwiX1wiIT09dH1mb3IoO2E8bjthKyspaWYoXCJfXCIhPT0odD1lW2FdKSl7aWYoIXIoZS5jaGFyQ29kZUF0KGEpKSlyZXR1cm4hMTtzPSEwfXJldHVybiBzJiZcIl9cIiE9PXR9aWYoXCJfXCI9PT10KXJldHVybiExO2Zvcig7YTxuO2ErKylpZihcIl9cIiE9PSh0PWVbYV0pKXtpZihcIjpcIj09PXQpYnJlYWs7aWYoIW8oZS5jaGFyQ29kZUF0KGEpKSlyZXR1cm4hMTtzPSEwfXJldHVybiEoIXN8fFwiX1wiPT09dCkmJihcIjpcIiE9PXR8fC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChlLnNsaWNlKGEpKSl9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdCxuLGk9ZSxyPTEsbz1bXTtyZXR1cm4tMSE9PWkuaW5kZXhPZihcIl9cIikmJihpPWkucmVwbGFjZSgvXy9nLFwiXCIpKSxcIi1cIiE9PSh0PWlbMF0pJiZcIitcIiE9PXR8fChcIi1cIj09PXQmJihyPS0xKSx0PShpPWkuc2xpY2UoMSkpWzBdKSxcIjBcIj09PWk/MDpcIjBcIj09PXQ/XCJiXCI9PT1pWzFdP3IqcGFyc2VJbnQoaS5zbGljZSgyKSwyKTpcInhcIj09PWlbMV0/cipwYXJzZUludChpLDE2KTpyKnBhcnNlSW50KGksOCk6LTEhPT1pLmluZGV4T2YoXCI6XCIpPyhpLnNwbGl0KFwiOlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe28udW5zaGlmdChwYXJzZUludChlLDEwKSl9KSxpPTAsbj0xLG8uZm9yRWFjaChmdW5jdGlvbihlKXtpKz1lKm4sbio9NjB9KSxyKmkpOnIqcGFyc2VJbnQoaSwxMCl9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgTnVtYmVyXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpJiZlJTE9PTAmJiFhLmlzTmVnYXRpdmVaZXJvKGUpfSxyZXByZXNlbnQ6e2JpbmFyeTpmdW5jdGlvbihlKXtyZXR1cm5cIjBiXCIrZS50b1N0cmluZygyKX0sb2N0YWw6ZnVuY3Rpb24oZSl7cmV0dXJuXCIwXCIrZS50b1N0cmluZyg4KX0sZGVjaW1hbDpmdW5jdGlvbihlKXtyZXR1cm4gZS50b1N0cmluZygxMCl9LGhleGFkZWNpbWFsOmZ1bmN0aW9uKGUpe3JldHVyblwiMHhcIitlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfX0sZGVmYXVsdFN0eWxlOlwiZGVjaW1hbFwiLHN0eWxlQWxpYXNlczp7YmluYXJ5OlsyLFwiYmluXCJdLG9jdGFsOls4LFwib2N0XCJdLGRlY2ltYWw6WzEwLFwiZGVjXCJdLGhleGFkZWNpbWFsOlsxNixcImhleFwiXX19KX0se1wiLi4vY29tbW9uXCI6MixcIi4uL3R5cGVcIjoxM31dLDE4OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk7dHJ5e2k9ZShcImVzcHJpbWFcIil9Y2F0Y2goZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKGk9d2luZG93LmVzcHJpbWEpfXZhciByPWUoXCIuLi8uLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgcihcInRhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiExO3RyeXt2YXIgdD1cIihcIitlK1wiKVwiLG49aS5wYXJzZSh0LHtyYW5nZTohMH0pO3JldHVyblwiUHJvZ3JhbVwiPT09bi50eXBlJiYxPT09bi5ib2R5Lmxlbmd0aCYmXCJFeHByZXNzaW9uU3RhdGVtZW50XCI9PT1uLmJvZHlbMF0udHlwZSYmXCJGdW5jdGlvbkV4cHJlc3Npb25cIj09PW4uYm9keVswXS5leHByZXNzaW9uLnR5cGV9Y2F0Y2goZSl7cmV0dXJuITF9fSxjb25zdHJ1Y3Q6ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIihcIitlK1wiKVwiLHI9aS5wYXJzZShuLHtyYW5nZTohMH0pLG89W107aWYoXCJQcm9ncmFtXCIhPT1yLnR5cGV8fDEhPT1yLmJvZHkubGVuZ3RofHxcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiE9PXIuYm9keVswXS50eXBlfHxcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIT09ci5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvblwiKTtyZXR1cm4gci5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24oZSl7by5wdXNoKGUubmFtZSl9KSx0PXIuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2UsbmV3IEZ1bmN0aW9uKG8sbi5zbGljZSh0WzBdKzEsdFsxXS0xKSl9LHByZWRpY2F0ZTpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgRnVuY3Rpb25dXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDpmdW5jdGlvbihlKXtyZXR1cm4gZS50b1N0cmluZygpfX0pfSx7XCIuLi8uLi90eXBlXCI6MTN9XSwxOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi8uLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cFwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm4hMTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuITE7dmFyIHQ9ZSxuPS9cXC8oW2dpbV0qKSQvLmV4ZWMoZSksaT1cIlwiO2lmKFwiL1wiPT09dFswXSl7aWYobiYmKGk9blsxXSksaS5sZW5ndGg+MylyZXR1cm4hMTtpZihcIi9cIiE9PXRbdC5sZW5ndGgtaS5sZW5ndGgtMV0pcmV0dXJuITF9cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXt2YXIgdD1lLG49L1xcLyhbZ2ltXSopJC8uZXhlYyhlKSxpPVwiXCI7cmV0dXJuXCIvXCI9PT10WzBdJiYobiYmKGk9blsxXSksdD10LnNsaWNlKDEsdC5sZW5ndGgtaS5sZW5ndGgtMSkpLG5ldyBSZWdFeHAodCxpKX0scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBSZWdFeHBdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHJlcHJlc2VudDpmdW5jdGlvbihlKXt2YXIgdD1cIi9cIitlLnNvdXJjZStcIi9cIjtyZXR1cm4gZS5nbG9iYWwmJih0Kz1cImdcIiksZS5tdWx0aWxpbmUmJih0Kz1cIm1cIiksZS5pZ25vcmVDYXNlJiYodCs9XCJpXCIpLHR9fSl9LHtcIi4uLy4uL3R5cGVcIjoxM31dLDIwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uLy4uL3R5cGVcIik7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6anMvdW5kZWZpbmVkXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbigpe30scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lfSxyZXByZXNlbnQ6ZnVuY3Rpb24oKXtyZXR1cm5cIlwifX0pfSx7XCIuLi8uLi90eXBlXCI6MTN9XSwyMTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOm1hcFwiLHtraW5kOlwibWFwcGluZ1wiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTp7fX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjptZXJnZVwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtyZXR1cm5cIjw8XCI9PT1lfHxudWxsPT09ZX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpudWxsXCIse2tpbmQ6XCJzY2FsYXJcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiEwO3ZhciB0PWUubGVuZ3RoO3JldHVybiAxPT09dCYmXCJ+XCI9PT1lfHw0PT09dCYmKFwibnVsbFwiPT09ZXx8XCJOdWxsXCI9PT1lfHxcIk5VTExcIj09PWUpfSxjb25zdHJ1Y3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0scHJlZGljYXRlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT09ZX0scmVwcmVzZW50OntjYW5vbmljYWw6ZnVuY3Rpb24oKXtyZXR1cm5cIn5cIn0sbG93ZXJjYXNlOmZ1bmN0aW9uKCl7cmV0dXJuXCJudWxsXCJ9LHVwcGVyY2FzZTpmdW5jdGlvbigpe3JldHVyblwiTlVMTFwifSxjYW1lbGNhc2U6ZnVuY3Rpb24oKXtyZXR1cm5cIk51bGxcIn19LGRlZmF1bHRTdHlsZTpcImxvd2VyY2FzZVwifSl9LHtcIi4uL3R5cGVcIjoxM31dLDI0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3R5cGVcIikscj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpvbWFwXCIse2tpbmQ6XCJzZXF1ZW5jZVwiLHJlc29sdmU6ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUpcmV0dXJuITA7dmFyIHQsbixpLGEscyxjPVtdLHU9ZTtmb3IodD0wLG49dS5sZW5ndGg7dDxuO3QrPTEpe2lmKGk9dVt0XSxzPSExLFwiW29iamVjdCBPYmplY3RdXCIhPT1vLmNhbGwoaSkpcmV0dXJuITE7Zm9yKGEgaW4gaSlpZihyLmNhbGwoaSxhKSl7aWYocylyZXR1cm4hMTtzPSEwfWlmKCFzKXJldHVybiExO2lmKC0xIT09Yy5pbmRleE9mKGEpKXJldHVybiExO2MucHVzaChhKX1yZXR1cm4hMH0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09ZT9lOltdfX0pfSx7XCIuLi90eXBlXCI6MTN9XSwyNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpLHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpwYWlyc1wiLHtraW5kOlwic2VxdWVuY2VcIixyZXNvbHZlOmZ1bmN0aW9uKGUpe2lmKG51bGw9PT1lKXJldHVybiEwO3ZhciB0LG4saSxvLGEscz1lO2ZvcihhPW5ldyBBcnJheShzLmxlbmd0aCksdD0wLG49cy5sZW5ndGg7dDxuO3QrPTEpe2lmKGk9c1t0XSxcIltvYmplY3QgT2JqZWN0XVwiIT09ci5jYWxsKGkpKXJldHVybiExO2lmKDEhPT0obz1PYmplY3Qua2V5cyhpKSkubGVuZ3RoKXJldHVybiExO2FbdF09W29bMF0saVtvWzBdXV19cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm5bXTt2YXIgdCxuLGkscixvLGE9ZTtmb3Iobz1uZXcgQXJyYXkoYS5sZW5ndGgpLHQ9MCxuPWEubGVuZ3RoO3Q8bjt0Kz0xKWk9YVt0XSxyPU9iamVjdC5rZXlzKGkpLG9bdF09W3JbMF0saVtyWzBdXV07cmV0dXJuIG99fSl9LHtcIi4uL3R5cGVcIjoxM31dLDI2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9ZShcIi4uL3R5cGVcIik7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6c2VxXCIse2tpbmQ6XCJzZXF1ZW5jZVwiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTpbXX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKSxyPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPW5ldyBpKFwidGFnOnlhbWwub3JnLDIwMDI6c2V0XCIse2tpbmQ6XCJtYXBwaW5nXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtpZihudWxsPT09ZSlyZXR1cm4hMDt2YXIgdCxuPWU7Zm9yKHQgaW4gbilpZihyLmNhbGwobix0KSYmbnVsbCE9PW5bdF0pcmV0dXJuITE7cmV0dXJuITB9LGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTp7fX19KX0se1wiLi4vdHlwZVwiOjEzfV0sMjg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi4vdHlwZVwiKTt0LmV4cG9ydHM9bmV3IGkoXCJ0YWc6eWFtbC5vcmcsMjAwMjpzdHJcIix7a2luZDpcInNjYWxhclwiLGNvbnN0cnVjdDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWU/ZTpcIlwifX0pfSx7XCIuLi90eXBlXCI6MTN9XSwyOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciBpPWUoXCIuLi90eXBlXCIpLHI9bmV3IFJlZ0V4cChcIl4oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldKS0oWzAtOV1bMC05XSkkXCIpLG89bmV3IFJlZ0V4cChcIl4oWzAtOV1bMC05XVswLTldWzAtOV0pLShbMC05XVswLTldPyktKFswLTldWzAtOV0/KSg/OltUdF18WyBcXFxcdF0rKShbMC05XVswLTldPyk6KFswLTldWzAtOV0pOihbMC05XVswLTldKSg/OlxcXFwuKFswLTldKikpPyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPykoPzo6KFswLTldWzAtOV0pKT8pKT8kXCIpO3QuZXhwb3J0cz1uZXcgaShcInRhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcFwiLHtraW5kOlwic2NhbGFyXCIscmVzb2x2ZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9PWUmJihudWxsIT09ci5leGVjKGUpfHxudWxsIT09by5leGVjKGUpKX0sY29uc3RydWN0OmZ1bmN0aW9uKGUpe3ZhciB0LG4saSxhLHMsYyx1LGwscD0wLGY9bnVsbDtpZihudWxsPT09KHQ9ci5leGVjKGUpKSYmKHQ9by5leGVjKGUpKSxudWxsPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJEYXRlIHJlc29sdmUgZXJyb3JcIik7aWYobj0rdFsxXSxpPSt0WzJdLTEsYT0rdFszXSwhdFs0XSlyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMobixpLGEpKTtpZihzPSt0WzRdLGM9K3RbNV0sdT0rdFs2XSx0WzddKXtmb3IocD10WzddLnNsaWNlKDAsMyk7cC5sZW5ndGg8MzspcCs9XCIwXCI7cD0rcH1yZXR1cm4gdFs5XSYmKGY9NmU0Kig2MCordFsxMF0rICsodFsxMV18fDApKSxcIi1cIj09PXRbOV0mJihmPS1mKSksbD1uZXcgRGF0ZShEYXRlLlVUQyhuLGksYSxzLGMsdSxwKSksZiYmbC5zZXRUaW1lKGwuZ2V0VGltZSgpLWYpLGx9LGluc3RhbmNlT2Y6RGF0ZSxyZXByZXNlbnQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9JU09TdHJpbmcoKX19KX0se1wiLi4vdHlwZVwiOjEzfV0sXCIvXCI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1lKFwiLi9saWIvanMteWFtbC5qc1wiKTt0LmV4cG9ydHM9aX0se1wiLi9saWIvanMteWFtbC5qc1wiOjF9XX0se30sW10pKFwiL1wiKX0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2Rpc3QvanMteWFtbC5taW4uanMiXSwic291cmNlUm9vdCI6IiJ9